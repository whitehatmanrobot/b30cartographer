ILEPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockHelp2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef HELP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define HELP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "VSHelp80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class Help2NotImpl :
	public Help2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(Help2NotImpl)

public:

	typedef Help2 Interface;

	STDMETHOD(SearchEx)(
		/*[in]*/ BSTR /*bstrSearchFilterTransform*/,
		/*[in]*/ BSTR /*pszSearchTerm*/,
		/*[in]*/ vsSearchFlags /*vssfSearchFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HowDoI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Favorites)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AskAQuestion)(
		/*[in]*/ vsAskQuestionFlags /*askQuestionFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromURLEx2)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[in]*/ vsHelpDisplayUrlFlags /*displayUrlFlags*/,
		/*[in]*/ BSTR /*bstrParam*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeSettingsToken)(
		/*[in]*/ BSTR /*bstrSettingsToken*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Contents)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Index)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Search)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IndexResults)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SearchResults)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromId)(
		/*[in]*/ BSTR /*bstrFile*/,
		/*[in]*/ DWORD /*Id*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromURL)(
		/*[in]*/ BSTR /*pszURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromURLEx)(
		/*[in]*/ BSTR /*pszURL*/,
		/*[in]*/ IVsHelpTopicShowEvents* /*pIVsHelpTopicShowEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromKeyword)(
		/*[in]*/ BSTR /*pszKeyword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromF1Keyword)(
		/*[in]*/ BSTR /*pszKeyword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFrom_OLD_Help)(
		/*[in]*/ BSTR /*bstrFile*/,
		/*[in]*/ DWORD /*Id*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SyncContents)(
		/*[in]*/ BSTR /*bstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanSyncContents)(
		/*[in]*/ BSTR /*bstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNextTopic)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[out,retval]*/ BSTR* /*pbstrNext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPrevTopic)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[out,retval]*/ BSTR* /*pbstrPrev*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanShowFilterUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SyncIndex)(
		/*[in]*/ BSTR /*bstrKeyword*/,
		/*[in]*/ BOOL /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCollection)(
		/*[in]*/ BSTR /*bstrCollection*/,
		/*[in]*/ BSTR /*bstrFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ BSTR* /*pbstrCollection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Filter)(
		/*[out,retval]*/ BSTR* /*pbstrFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Filter)(
		/*[in]*/ BSTR /*bstrFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FilterQuery)(
		/*[out,retval]*/ BSTR* /*pbstrFilterQuery*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HelpOwner)(
		/*[out,retval]*/ IVsHelpOwner** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_HelpOwner)(
		/*[in]*/ IVsHelpOwner* /*pObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HxSession)(
		/*[out,retval]*/ IDispatch** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Help)(
		/*[out,retval]*/ IDispatch** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetObject)(
		/*[in]*/ BSTR /*bstrMoniker*/,
		/*[in]*/ BSTR /*bstrOptions*/,
		/*[out,retval]*/ IDispatch** /*ppDisp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class Help2MockImpl :
	public Help2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(Help2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(Help2MockImpl)

	typedef Help2 Interface;
	struct SearchExValidValues
	{
		/*[in]*/ BSTR bstrSearchFilterTransform;
		/*[in]*/ BSTR pszSearchTerm;
		/*[in]*/ vsSearchFlags vssfSearchFlags;
		HRESULT retValue;
	};

	STDMETHOD(SearchEx)(
		/*[in]*/ BSTR bstrSearchFilterTransform,
		/*[in]*/ BSTR pszSearchTerm,
		/*[in]*/ vsSearchFlags vssfSearchFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SearchEx)

		VSL_CHECK_VALIDVALUE_BSTR(bstrSearchFilterTransform);

		VSL_CHECK_VALIDVALUE_BSTR(pszSearchTerm);

		VSL_CHECK_VALIDVALUE(vssfSearchFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct HowDoIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HowDoI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HowDoI)

		VSL_RETURN_VALIDVALUES();
	}
	struct FavoritesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Favorites)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Favorites)

		VSL_RETURN_VALIDVALUES();
	}
	struct AskAQuestionValidValues
	{
		/*[in]*/ vsAskQuestionFlags askQuestionFlags;
		HRESULT retValue;
	};

	STDMETHOD(AskAQuestion)(
		/*[in]*/ vsAskQuestionFlags askQuestionFlags)
	{
		VSL_DEFINE_MOCK_METHOD(AskAQuestion)

		VSL_CHECK_VALIDVALUE(askQuestionFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromURLEx2ValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[in]*/ vsHelpDisplayUrlFlags displayUrlFlags;
		/*[in]*/ BSTR bstrParam;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromURLEx2)(
		/*[in]*/ BSTR bstrURL,
		/*[in]*/ vsHelpDisplayUrlFlags displayUrlFlags,
		/*[in]*/ BSTR bstrParam)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromURLEx2)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_CHECK_VALIDVALUE(displayUrlFlags);

		VSL_CHECK_VALIDVALUE_BSTR(bstrParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeSettingsTokenValidValues
	{
		/*[in]*/ BSTR bstrSettingsToken;
		HRESULT retValue;
	};

	STDMETHOD(InitializeSettingsToken)(
		/*[in]*/ BSTR bstrSettingsToken)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeSettingsToken)

		VSL_CHECK_VALIDVALUE_BSTR(bstrSettingsToken);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContentsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Contents)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Contents)

		VSL_RETURN_VALIDVALUES();
	}
	struct IndexValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Index)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Index)

		VSL_RETURN_VALIDVALUES();
	}
	struct SearchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Search)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Search)

		VSL_RETURN_VALIDVALUES();
	}
	struct IndexResultsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IndexResults)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IndexResults)

		VSL_RETURN_VALIDVALUES();
	}
	struct SearchResultsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SearchResults)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SearchResults)

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromIdValidValues
	{
		/*[in]*/ BSTR bstrFile;
		/*[in]*/ DWORD Id;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromId)(
		/*[in]*/ BSTR bstrFile,
		/*[in]*/ DWORD Id)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromId)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFile);

		VSL_CHECK_VALIDVALUE(Id);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromURLValidValues
	{
		/*[in]*/ BSTR pszURL;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromURL)(
		/*[in]*/ BSTR pszURL)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromURL)

		VSL_CHECK_VALIDVALUE_BSTR(pszURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromURLExValidValues
	{
		/*[in]*/ BSTR pszURL;
		/*[in]*/ IVsHelpTopicShowEvents* pIVsHelpTopicShowEvents;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromURLEx)(
		/*[in]*/ BSTR pszURL,
		/*[in]*/ IVsHelpTopicShowEvents* pIVsHelpTopicShowEvents)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromURLEx)

		VSL_CHECK_VALIDVALUE_BSTR(pszURL);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHelpTopicShowEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromKeywordValidValues
	{
		/*[in]*/ BSTR pszKeyword;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromKeyword)(
		/*[in]*/ BSTR pszKeyword)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromKeyword)

		VSL_CHECK_VALIDVALUE_BSTR(pszKeyword);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromF1KeywordValidValues
	{
		/*[in]*/ BSTR pszKeyword;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromF1Keyword)(
		/*[in]*/ BSTR pszKeyword)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromF1Keyword)

		VSL_CHECK_VALIDVALUE_BSTR(pszKeyword);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFrom_OLD_HelpValidValues
	{
		/*[in]*/ BSTR bstrFile;
		/*[in]*/ DWORD Id;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFrom_OLD_Help)(
		/*[in]*/ BSTR bstrFile,
		/*[in]*/ DWORD Id)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFrom_OLD_Help)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFile);

		VSL_CHECK_VALIDVALUE(Id);

		VSL_RETURN_VALIDVALUES();
	}
	struct SyncContentsValidValues
	{
		/*[in]*/ BSTR bstrURL;
		HRESULT retValue;
	};

	STDMETHOD(SyncContents)(
		/*[in]*/ BSTR bstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(SyncContents)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanSyncContentsValidValues
	{
		/*[in]*/ BSTR bstrURL;
		HRESULT retValue;
	};

	STDMETHOD(CanSyncContents)(
		/*[in]*/ BSTR bstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(CanSyncContents)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNextTopicValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[out,retval]*/ BSTR* pbstrNext;
		HRESULT retValue;
	};

	STDMETHOD(GetNextTopic)(
		/*[in]*/ BSTR bstrURL,
		/*[out,retval]*/ BSTR* pbstrNext)
	{
		VSL_DEFINE_MOCK_METHOD(GetNextTopic)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_SET_VALIDVALUE_BSTR(pbstrNext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPrevTopicValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[out,retval]*/ BSTR* pbstrPrev;
		HRESULT retValue;
	};

	STDMETHOD(GetPrevTopic)(
		/*[in]*/ BSTR bstrURL,
		/*[out,retval]*/ BSTR* pbstrPrev)
	{
		VSL_DEFINE_MOCK_METHOD(GetPrevTopic)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_SET_VALIDVALUE_BSTR(pbstrPrev);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FilterUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FilterUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanShowFilterUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanShowFilterUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanShowFilterUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct SyncIndexValidValues
	{
		/*[in]*/ BSTR bstrKeyword;
		/*[in]*/ BOOL fShow;
		HRESULT retValue;
	};

	STDMETHOD(SyncIndex)(
		/*[in]*/ BSTR bstrKeyword,
		/*[in]*/ BOOL fShow)
	{
		VSL_DEFINE_MOCK_METHOD(SyncIndex)

		VSL_CHECK_VALIDVALUE_BSTR(bstrKeyword);

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCollectionValidValues
	{
		/*[in]*/ BSTR bstrCollection;
		/*[in]*/ BSTR bstrFilter;
		HRESULT retValue;
	};

	STDMETHOD(SetCollection)(
		/*[in]*/ BSTR bstrCollection,
		/*[in]*/ BSTR bstrFilter)
	{
		VSL_DEFINE_MOCK_METHOD(SetCollection)

		VSL_CHECK_VALIDVALUE_BSTR(bstrCollection);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CollectionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCollection;
		HRESULT retValue;
	};

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ BSTR* pbstrCollection)
	{
		VSL_DEFINE_MOCK_METHOD(get_Collection)

		VSL_SET_VALIDVALUE_BSTR(pbstrCollection);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FilterValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFilter;
		HRESULT retValue;
	};

	STDMETHOD(get_Filter)(
		/*[out,retval]*/ BSTR* pbstrFilter)
	{
		VSL_DEFINE_MOCK_METHOD(get_Filter)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FilterValidValues
	{
		/*[in]*/ BSTR bstrFilter;
		HRESULT retValue;
	};

	STDMETHOD(put_Filter)(
		/*[in]*/ BSTR bstrFilter)
	{
		VSL_DEFINE_MOCK_METHOD(put_Filter)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FilterQueryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFilterQuery;
		HRESULT retValue;
	};

	STDMETHOD(get_FilterQuery)(
		/*[out,retval]*/ BSTR* pbstrFilterQuery)
	{
		VSL_DEFINE_MOCK_METHOD(get_FilterQuery)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilterQuery);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpOwnerValidValues
	{
		/*[out,retval]*/ IVsHelpOwner** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_HelpOwner)(
		/*[out,retval]*/ IVsHelpOwner** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_HelpOwner)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_HelpOwnerValidValues
	{
		/*[in]*/ IVsHelpOwner* pObj;
		HRESULT retValue;
	};

	STDMETHOD(put_HelpOwner)(
		/*[in]*/ IVsHelpOwner* pObj)
	{
		VSL_DEFINE_MOCK_METHOD(put_HelpOwner)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HxSessionValidValues
	{
		/*[out,retval]*/ IDispatch** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_HxSession)(
		/*[out,retval]*/ IDispatch** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_HxSession)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpValidValues
	{
		/*[out,retval]*/ IDispatch** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_Help)(
		/*[out,retval]*/ IDispatch** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_Help)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetObjectValidValues
	{
		/*[in]*/ BSTR bstrMoniker;
		/*[in]*/ BSTR bstrOptions;
		/*[out,retval]*/ IDispatch** ppDisp;
		HRESULT retValue;
	};

	STDMETHOD(GetObject)(
		/*[in]*/ BSTR bstrMoniker,
		/*[in]*/ BSTR bstrOptions,
		/*[out,retval]*/ IDispatch** ppDisp)
	{
		VSL_DEFINE_MOCK_METHOD(GetObject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMoniker);

		VSL_CHECK_VALIDVALUE_BSTR(bstrOptions);

		VSL_SET_VALIDVALUE_INTERFACE(ppDisp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // HELP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "undoredo.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IActionNotImpl :
	public IAction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IActionNotImpl)

public:

	typedef IAction Interface;

	STDMETHOD(GetName)(
		/*[in]*/ BSTR* /*bstrName*/,
		/*[in]*/ BOOL /*fLongName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[in]*/ long* /*piSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Undo)(
		/*[in]*/ IUnknown* /*pObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Redo)(
		/*[in]*/ IUnknown* /*pObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Abort)(
		/*[in]*/ IUnknown* /*pObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddSibling)(
		/*[in]*/ IAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNextSibling)(
		/*[in]*/ IAction** /*ppAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddChild)(
		/*[in]*/ IAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFirstChild)(
		/*[in]*/ IAction** /*ppAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanMerge)(
		/*[in]*/ IAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Merge)(
		/*[in]*/ IAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL
};

class IActionMockImpl :
	public IAction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IActionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IActionMockImpl)

	typedef IAction Interface;
	struct GetNameValidValues
	{
		/*[in]*/ BSTR* bstrName;
		/*[in]*/ BOOL fLongName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ BSTR* bstrName,
		/*[in]*/ BOOL fLongName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE_POINTER(bstrName);

		VSL_CHECK_VALIDVALUE(fLongName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[in]*/ long* piSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[in]*/ long* piSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_CHECK_VALIDVALUE_POINTER(piSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct UndoValidValues
	{
		/*[in]*/ IUnknown* pObject;
		HRESULT retValue;
	};

	STDMETHOD(Undo)(
		/*[in]*/ IUnknown* pObject)
	{
		VSL_DEFINE_MOCK_METHOD(Undo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct RedoValidValues
	{
		/*[in]*/ IUnknown* pObject;
		HRESULT retValue;
	};

	STDMETHOD(Redo)(
		/*[in]*/ IUnknown* pObject)
	{
		VSL_DEFINE_MOCK_METHOD(Redo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct AbortValidValues
	{
		/*[in]*/ IUnknown* pObject;
		HRESULT retValue;
	};

	STDMETHOD(Abort)(
		/*[in]*/ IUnknown* pObject)
	{
		VSL_DEFINE_MOCK_METHOD(Abort)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddSiblingValidValues
	{
		/*[in]*/ IAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(AddSibling)(
		/*[in]*/ IAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(AddSibling)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNextSiblingValidValues
	{
		/*[in]*/ IAction** ppAction;
		HRESULT retValue;
	};

	STDMETHOD(GetNextSibling)(
		/*[in]*/ IAction** ppAction)
	{
		VSL_DEFINE_MOCK_METHOD(GetNextSibling)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddChildValidValues
	{
		/*[in]*/ IAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(AddChild)(
		/*[in]*/ IAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(AddChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFirstChildValidValues
	{
		/*[in]*/ IAction** ppAction;
		HRESULT retValue;
	};

	STDMETHOD(GetFirstChild)(
		/*[in]*/ IAction** ppAction)
	{
		VSL_DEFINE_MOCK_METHOD(GetFirstChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanMergeValidValues
	{
		/*[in]*/ IAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(CanMerge)(
		/*[in]*/ IAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(CanMerge)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct MergeValidValues
	{
		/*[in]*/ IAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(Merge)(
		/*[in]*/ IAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(Merge)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockFileProperties2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef FILEPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define FILEPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class FileProperties2NotImpl :
	public FileProperties2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FileProperties2NotImpl)

public:

	typedef FileProperties2 Interface;

	STDMETHOD(get_CopyToOutputDirectory)(
		/*[out,retval]*/ COPYTOOUTPUTSTATE* /*pCopy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CopyToOutputDirectory)(
		/*[in]*/ COPYTOOUTPUTSTATE /*Copy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ItemType)(
		/*[out,retval]*/ BSTR* /*pbstrItemType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ItemType)(
		/*[in]*/ BSTR /*ItemType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsSharedDesignTimeBuildInput)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsSharedDesignTimeBuildInput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extension)(
		/*[out,retval]*/ BSTR* /*pbstrExtension*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Filesize)(
		/*[out,retval]*/ unsigned long* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HTMLTitle)(
		/*[out,retval]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Author)(
		/*[out,retval]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DateCreated)(
		/*[out,retval]*/ BSTR* /*pbstrDateCreated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DateModified)(
		/*[out,retval]*/ BSTR* /*pbstrDateCreated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ModifiedBy)(
		/*[out,retval]*/ BSTR* /*pbstrDateCreated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubType)(
		/*[out,retval]*/ BSTR* /*pbstrSubType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SubType)(
		/*[in]*/ BSTR /*bstrSubType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildAction)(
		/*[out,retval]*/ prjBuildAction* /*pbuildAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BuildAction)(
		/*[in]*/ prjBuildAction /*buildAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomTool)(
		/*[out,retval]*/ BSTR* /*pbstrCustomTool*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CustomTool)(
		/*[in]*/ BSTR /*bstrCustomTool*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomToolNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrCustomToolNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CustomToolNamespace)(
		/*[in]*/ BSTR /*bstrCustomToolNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomToolOutput)(
		/*[out,retval]*/ BSTR* /*pbstrCustomToolOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsCustomToolOutput)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsCustomToolOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDependentFile)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsDepedentFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsLink)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsLinkFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDesignTimeBuildInput)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsDesignTimeBuildInput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class FileProperties2MockImpl :
	public FileProperties2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FileProperties2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(FileProperties2MockImpl)

	typedef FileProperties2 Interface;
	struct get_CopyToOutputDirectoryValidValues
	{
		/*[out,retval]*/ COPYTOOUTPUTSTATE* pCopy;
		HRESULT retValue;
	};

	STDMETHOD(get_CopyToOutputDirectory)(
		/*[out,retval]*/ COPYTOOUTPUTSTATE* pCopy)
	{
		VSL_DEFINE_MOCK_METHOD(get_CopyToOutputDirectory)

		VSL_SET_VALIDVALUE(pCopy);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CopyToOutputDirectoryValidValues
	{
		/*[in]*/ COPYTOOUTPUTSTATE Copy;
		HRESULT retValue;
	};

	STDMETHOD(put_CopyToOutputDirectory)(
		/*[in]*/ COPYTOOUTPUTSTATE Copy)
	{
		VSL_DEFINE_MOCK_METHOD(put_CopyToOutputDirectory)

		VSL_CHECK_VALIDVALUE(Copy);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ItemTypeValidValues
	{
		/*[out,retval]*/ BSTR* pbstrItemType;
		HRESULT retValue;
	};

	STDMETHOD(get_ItemType)(
		/*[out,retval]*/ BSTR* pbstrItemType)
	{
		VSL_DEFINE_MOCK_METHOD(get_ItemType)

		VSL_SET_VALIDVALUE_BSTR(pbstrItemType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ItemTypeValidValues
	{
		/*[in]*/ BSTR ItemType;
		HRESULT retValue;
	};

	STDMETHOD(put_ItemType)(
		/*[in]*/ BSTR ItemType)
	{
		VSL_DEFINE_MOCK_METHOD(put_ItemType)

		VSL_CHECK_VALIDVALUE_BSTR(ItemType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsSharedDesignTimeBuildInputValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsSharedDesignTimeBuildInput;
		HRESULT retValue;
	};

	STDMETHOD(get_IsSharedDesignTimeBuildInput)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsSharedDesignTimeBuildInput)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsSharedDesignTimeBuildInput)

		VSL_SET_VALIDVALUE(pbIsSharedDesignTimeBuildInput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtensionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrExtension;
		HRESULT retValue;
	};

	STDMETHOD(get_Extension)(
		/*[out,retval]*/ BSTR* pbstrExtension)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extension)

		VSL_SET_VALIDVALUE_BSTR(pbstrExtension);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FilesizeValidValues
	{
		/*[out,retval]*/ unsigned long* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(get_Filesize)(
		/*[out,retval]*/ unsigned long* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Filesize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HTMLTitleValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(get_HTMLTitle)(
		/*[out,retval]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(get_HTMLTitle)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AuthorValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(get_Author)(
		/*[out,retval]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(get_Author)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DateCreatedValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDateCreated;
		HRESULT retValue;
	};

	STDMETHOD(get_DateCreated)(
		/*[out,retval]*/ BSTR* pbstrDateCreated)
	{
		VSL_DEFINE_MOCK_METHOD(get_DateCreated)

		VSL_SET_VALIDVALUE_BSTR(pbstrDateCreated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DateModifiedValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDateCreated;
		HRESULT retValue;
	};

	STDMETHOD(get_DateModified)(
		/*[out,retval]*/ BSTR* pbstrDateCreated)
	{
		VSL_DEFINE_MOCK_METHOD(get_DateModified)

		VSL_SET_VALIDVALUE_BSTR(pbstrDateCreated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ModifiedByValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDateCreated;
		HRESULT retValue;
	};

	STDMETHOD(get_ModifiedBy)(
		/*[out,retval]*/ BSTR* pbstrDateCreated)
	{
		VSL_DEFINE_MOCK_METHOD(get_ModifiedBy)

		VSL_SET_VALIDVALUE_BSTR(pbstrDateCreated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubTypeValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSubType;
		HRESULT retValue;
	};

	STDMETHOD(get_SubType)(
		/*[out,retval]*/ BSTR* pbstrSubType)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubType)

		VSL_SET_VALIDVALUE_BSTR(pbstrSubType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SubTypeValidValues
	{
		/*[in]*/ BSTR bstrSubType;
		HRESULT retValue;
	};

	STDMETHOD(put_SubType)(
		/*[in]*/ BSTR bstrSubType)
	{
		VSL_DEFINE_MOCK_METHOD(put_SubType)

		VSL_CHECK_VALIDVALUE_BSTR(bstrSubType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildActionValidValues
	{
		/*[out,retval]*/ prjBuildAction* pbuildAction;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildAction)(
		/*[out,retval]*/ prjBuildAction* pbuildAction)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildAction)

		VSL_SET_VALIDVALUE(pbuildAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BuildActionValidValues
	{
		/*[in]*/ prjBuildAction buildAction;
		HRESULT retValue;
	};

	STDMETHOD(put_BuildAction)(
		/*[in]*/ prjBuildAction buildAction)
	{
		VSL_DEFINE_MOCK_METHOD(put_BuildAction)

		VSL_CHECK_VALIDVALUE(buildAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomToolValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCustomTool;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomTool)(
		/*[out,retval]*/ BSTR* pbstrCustomTool)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomTool)

		VSL_SET_VALIDVALUE_BSTR(pbstrCustomTool);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CustomToolValidValues
	{
		/*[in]*/ BSTR bstrCustomTool;
		HRESULT retValue;
	};

	STDMETHOD(put_CustomTool)(
		/*[in]*/ BSTR bstrCustomTool)
	{
		VSL_DEFINE_MOCK_METHOD(put_CustomTool)

		VSL_CHECK_VALIDVALUE_BSTR(bstrCustomTool);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomToolNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCustomToolNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomToolNamespace)(
		/*[out,retval]*/ BSTR* pbstrCustomToolNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomToolNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrCustomToolNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CustomToolNamespaceValidValues
	{
		/*[in]*/ BSTR bstrCustomToolNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_CustomToolNamespace)(
		/*[in]*/ BSTR bstrCustomToolNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_CustomToolNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrCustomToolNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomToolOutputValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCustomToolOutput;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomToolOutput)(
		/*[out,retval]*/ BSTR* pbstrCustomToolOutput)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomToolOutput)

		VSL_SET_VALIDVALUE_BSTR(pbstrCustomToolOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsCustomToolOutputValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsCustomToolOutput;
		HRESULT retValue;
	};

	STDMETHOD(get_IsCustomToolOutput)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsCustomToolOutput)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsCustomToolOutput)

		VSL_SET_VALIDVALUE(pbIsCustomToolOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDependentFileValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsDepedentFile;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDependentFile)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsDepedentFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDependentFile)

		VSL_SET_VALIDVALUE(pbIsDepedentFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsLinkValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsLinkFile;
		HRESULT retValue;
	};

	STDMETHOD(get_IsLink)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsLinkFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsLink)

		VSL_SET_VALIDVALUE(pbIsLinkFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDesignTimeBuildInputValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsDesignTimeBuildInput;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDesignTimeBuildInput)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsDesignTimeBuildInput)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDesignTimeBuildInput)

		VSL_SET_VALIDVALUE(pbIsDesignTimeBuildInput);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // FILEPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockHelp.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef HELP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define HELP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vshelp.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class HelpNotImpl :
	public Help
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(HelpNotImpl)

public:

	typedef Help Interface;

	STDMETHOD(Contents)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Index)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Search)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IndexResults)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SearchResults)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromId)(
		/*[in]*/ BSTR /*bstrFile*/,
		/*[in]*/ DWORD /*Id*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromURL)(
		/*[in]*/ BSTR /*pszURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromURLEx)(
		/*[in]*/ BSTR /*pszURL*/,
		/*[in]*/ IVsHelpTopicShowEvents* /*pIVsHelpTopicShowEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromKeyword)(
		/*[in]*/ BSTR /*pszKeyword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFromF1Keyword)(
		/*[in]*/ BSTR /*pszKeyword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayTopicFrom_OLD_Help)(
		/*[in]*/ BSTR /*bstrFile*/,
		/*[in]*/ DWORD /*Id*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SyncContents)(
		/*[in]*/ BSTR /*bstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanSyncContents)(
		/*[in]*/ BSTR /*bstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNextTopic)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[out,retval]*/ BSTR* /*pbstrNext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPrevTopic)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[out,retval]*/ BSTR* /*pbstrPrev*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanShowFilterUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SyncIndex)(
		/*[in]*/ BSTR /*bstrKeyword*/,
		/*[in]*/ BOOL /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCollection)(
		/*[in]*/ BSTR /*bstrCollection*/,
		/*[in]*/ BSTR /*bstrFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ BSTR* /*pbstrCollection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Filter)(
		/*[out,retval]*/ BSTR* /*pbstrFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Filter)(
		/*[in]*/ BSTR /*bstrFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FilterQuery)(
		/*[out,retval]*/ BSTR* /*pbstrFilterQuery*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HelpOwner)(
		/*[out,retval]*/ IVsHelpOwner** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_HelpOwner)(
		/*[in]*/ IVsHelpOwner* /*pObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HxSession)(
		/*[out,retval]*/ IDispatch** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Help)(
		/*[out,retval]*/ IDispatch** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetObject)(
		/*[in]*/ BSTR /*bstrMoniker*/,
		/*[in]*/ BSTR /*bstrOptions*/,
		/*[out,retval]*/ IDispatch** /*ppDisp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class HelpMockImpl :
	public Help,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(HelpMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(HelpMockImpl)

	typedef Help Interface;
	struct ContentsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Contents)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Contents)

		VSL_RETURN_VALIDVALUES();
	}
	struct IndexValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Index)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Index)

		VSL_RETURN_VALIDVALUES();
	}
	struct SearchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Search)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Search)

		VSL_RETURN_VALIDVALUES();
	}
	struct IndexResultsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IndexResults)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IndexResults)

		VSL_RETURN_VALIDVALUES();
	}
	struct SearchResultsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SearchResults)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SearchResults)

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromIdValidValues
	{
		/*[in]*/ BSTR bstrFile;
		/*[in]*/ DWORD Id;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromId)(
		/*[in]*/ BSTR bstrFile,
		/*[in]*/ DWORD Id)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromId)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFile);

		VSL_CHECK_VALIDVALUE(Id);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromURLValidValues
	{
		/*[in]*/ BSTR pszURL;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromURL)(
		/*[in]*/ BSTR pszURL)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromURL)

		VSL_CHECK_VALIDVALUE_BSTR(pszURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromURLExValidValues
	{
		/*[in]*/ BSTR pszURL;
		/*[in]*/ IVsHelpTopicShowEvents* pIVsHelpTopicShowEvents;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromURLEx)(
		/*[in]*/ BSTR pszURL,
		/*[in]*/ IVsHelpTopicShowEvents* pIVsHelpTopicShowEvents)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromURLEx)

		VSL_CHECK_VALIDVALUE_BSTR(pszURL);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHelpTopicShowEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromKeywordValidValues
	{
		/*[in]*/ BSTR pszKeyword;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromKeyword)(
		/*[in]*/ BSTR pszKeyword)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromKeyword)

		VSL_CHECK_VALIDVALUE_BSTR(pszKeyword);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFromF1KeywordValidValues
	{
		/*[in]*/ BSTR pszKeyword;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFromF1Keyword)(
		/*[in]*/ BSTR pszKeyword)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFromF1Keyword)

		VSL_CHECK_VALIDVALUE_BSTR(pszKeyword);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayTopicFrom_OLD_HelpValidValues
	{
		/*[in]*/ BSTR bstrFile;
		/*[in]*/ DWORD Id;
		HRESULT retValue;
	};

	STDMETHOD(DisplayTopicFrom_OLD_Help)(
		/*[in]*/ BSTR bstrFile,
		/*[in]*/ DWORD Id)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayTopicFrom_OLD_Help)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFile);

		VSL_CHECK_VALIDVALUE(Id);

		VSL_RETURN_VALIDVALUES();
	}
	struct SyncContentsValidValues
	{
		/*[in]*/ BSTR bstrURL;
		HRESULT retValue;
	};

	STDMETHOD(SyncContents)(
		/*[in]*/ BSTR bstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(SyncContents)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanSyncContentsValidValues
	{
		/*[in]*/ BSTR bstrURL;
		HRESULT retValue;
	};

	STDMETHOD(CanSyncContents)(
		/*[in]*/ BSTR bstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(CanSyncContents)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNextTopicValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[out,retval]*/ BSTR* pbstrNext;
		HRESULT retValue;
	};

	STDMETHOD(GetNextTopic)(
		/*[in]*/ BSTR bstrURL,
		/*[out,retval]*/ BSTR* pbstrNext)
	{
		VSL_DEFINE_MOCK_METHOD(GetNextTopic)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_SET_VALIDVALUE_BSTR(pbstrNext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPrevTopicValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[out,retval]*/ BSTR* pbstrPrev;
		HRESULT retValue;
	};

	STDMETHOD(GetPrevTopic)(
		/*[in]*/ BSTR bstrURL,
		/*[out,retval]*/ BSTR* pbstrPrev)
	{
		VSL_DEFINE_MOCK_METHOD(GetPrevTopic)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_SET_VALIDVALUE_BSTR(pbstrPrev);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FilterUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FilterUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanShowFilterUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanShowFilterUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanShowFilterUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct SyncIndexValidValues
	{
		/*[in]*/ BSTR bstrKeyword;
		/*[in]*/ BOOL fShow;
		HRESULT retValue;
	};

	STDMETHOD(SyncIndex)(
		/*[in]*/ BSTR bstrKeyword,
		/*[in]*/ BOOL fShow)
	{
		VSL_DEFINE_MOCK_METHOD(SyncIndex)

		VSL_CHECK_VALIDVALUE_BSTR(bstrKeyword);

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCollectionValidValues
	{
		/*[in]*/ BSTR bstrCollection;
		/*[in]*/ BSTR bstrFilter;
		HRESULT retValue;
	};

	STDMETHOD(SetCollection)(
		/*[in]*/ BSTR bstrCollection,
		/*[in]*/ BSTR bstrFilter)
	{
		VSL_DEFINE_MOCK_METHOD(SetCollection)

		VSL_CHECK_VALIDVALUE_BSTR(bstrCollection);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CollectionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCollection;
		HRESULT retValue;
	};

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ BSTR* pbstrCollection)
	{
		VSL_DEFINE_MOCK_METHOD(get_Collection)

		VSL_SET_VALIDVALUE_BSTR(pbstrCollection);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FilterValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFilter;
		HRESULT retValue;
	};

	STDMETHOD(get_Filter)(
		/*[out,retval]*/ BSTR* pbstrFilter)
	{
		VSL_DEFINE_MOCK_METHOD(get_Filter)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FilterValidValues
	{
		/*[in]*/ BSTR bstrFilter;
		HRESULT retValue;
	};

	STDMETHOD(put_Filter)(
		/*[in]*/ BSTR bstrFilter)
	{
		VSL_DEFINE_MOCK_METHOD(put_Filter)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FilterQueryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFilterQuery;
		HRESULT retValue;
	};

	STDMETHOD(get_FilterQuery)(
		/*[out,retval]*/ BSTR* pbstrFilterQuery)
	{
		VSL_DEFINE_MOCK_METHOD(get_FilterQuery)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilterQuery);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpOwnerValidValues
	{
		/*[out,retval]*/ IVsHelpOwner** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_HelpOwner)(
		/*[out,retval]*/ IVsHelpOwner** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_HelpOwner)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_HelpOwnerValidValues
	{
		/*[in]*/ IVsHelpOwner* pObj;
		HRESULT retValue;
	};

	STDMETHOD(put_HelpOwner)(
		/*[in]*/ IVsHelpOwner* pObj)
	{
		VSL_DEFINE_MOCK_METHOD(put_HelpOwner)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HxSessionValidValues
	{
		/*[out,retval]*/ IDispatch** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_HxSession)(
		/*[out,retval]*/ IDispatch** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_HxSession)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpValidValues
	{
		/*[out,retval]*/ IDispatch** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_Help)(
		/*[out,retval]*/ IDispatch** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_Help)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetObjectValidValues
	{
		/*[in]*/ BSTR bstrMoniker;
		/*[in]*/ BSTR bstrOptions;
		/*[out,retval]*/ IDispatch** ppDisp;
		HRESULT retValue;
	};

	STDMETHOD(GetObject)(
		/*[in]*/ BSTR bstrMoniker,
		/*[in]*/ BSTR bstrOptions,
		/*[out,retval]*/ IDispatch** ppDisp)
	{
		VSL_DEFINE_MOCK_METHOD(GetObject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMoniker);

		VSL_CHECK_VALIDVALUE_BSTR(bstrOptions);

		VSL_SET_VALIDVALUE_INTERFACE(ppDisp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // HELP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockFolderProperties2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef FOLDERPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define FOLDERPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class FolderProperties2NotImpl :
	public FolderProperties2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FolderProperties2NotImpl)

public:

	typedef FolderProperties2 Interface;

	STDMETHOD(get_WebReferenceInterface)(
		/*[out,retval]*/ IUnknown** /*ppWebReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebReference)(
		/*[out,retval]*/ BSTR* /*pbstrWebReferenceUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebReference)(
		/*[in]*/ BSTR /*bstrWebReferenceUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UrlBehavior)(
		/*[out,retval]*/ webrefUrlBehavior* /*pUrlBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_UrlBehavior)(
		/*[in]*/ webrefUrlBehavior /*urlBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class FolderProperties2MockImpl :
	public FolderProperties2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FolderProperties2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(FolderProperties2MockImpl)

	typedef FolderProperties2 Interface;
	struct get_WebReferenceInterfaceValidValues
	{
		/*[out,retval]*/ IUnknown** ppWebReference;
		HRESULT retValue;
	};

	STDMETHOD(get_WebReferenceInterface)(
		/*[out,retval]*/ IUnknown** ppWebReference)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebReferenceInterface)

		VSL_SET_VALIDVALUE_INTERFACE(ppWebReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebReferenceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebReferenceUrl;
		HRESULT retValue;
	};

	STDMETHOD(get_WebReference)(
		/*[out,retval]*/ BSTR* pbstrWebReferenceUrl)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebReference)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebReferenceUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebReferenceValidValues
	{
		/*[in]*/ BSTR bstrWebReferenceUrl;
		HRESULT retValue;
	};

	STDMETHOD(put_WebReference)(
		/*[in]*/ BSTR bstrWebReferenceUrl)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWebReferenceUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* pbstrNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UrlBehaviorValidValues
	{
		/*[out,retval]*/ webrefUrlBehavior* pUrlBehavior;
		HRESULT retValue;
	};

	STDMETHOD(get_UrlBehavior)(
		/*[out,retval]*/ webrefUrlBehavior* pUrlBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(get_UrlBehavior)

		VSL_SET_VALIDVALUE(pUrlBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_UrlBehaviorValidValues
	{
		/*[in]*/ webrefUrlBehavior urlBehavior;
		HRESULT retValue;
	};

	STDMETHOD(put_UrlBehavior)(
		/*[in]*/ webrefUrlBehavior urlBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(put_UrlBehavior)

		VSL_CHECK_VALIDVALUE(urlBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // FOLDERPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIActionHistory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IACTIONHISTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IACTIONHISTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "undoredo.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IActionHistoryNotImpl :
	public IActionHistory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IActionHistoryNotImpl)

public:

	typedef IActionHistory Interface;

	STDMETHOD(RecordAction)(
		/*[in]*/ IAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenAction)(
		/*[in]*/ IAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseAction)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AbortAction)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanRedo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Undo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Redo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumUndoActions)(
		/*[in]*/ IEnumActions** /*ppEnumUndoActions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumRedoActions)(
		/*[in]*/ IEnumActions** /*ppEnumRedoActions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL
};

class IActionHistoryMockImpl :
	public IActionHistory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IActionHistoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IActionHistoryMockImpl)

	typedef IActionHistory Interface;
	struct RecordActionValidValues
	{
		/*[in]*/ IAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(RecordAction)(
		/*[in]*/ IAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(RecordAction)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenActionValidValues
	{
		/*[in]*/ IAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(OpenAction)(
		/*[in]*/ IAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(OpenAction)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseActionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseAction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseAction)

		VSL_RETURN_VALIDVALUES();
	}
	struct AbortActionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AbortAction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AbortAction)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanRedoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanRedo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanRedo)

		VSL_RETURN_VALIDVALUES();
	}
	struct UndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Undo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Undo)

		VSL_RETURN_VALIDVALUES();
	}
	struct RedoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Redo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Redo)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumUndoActionsValidValues
	{
		/*[in]*/ IEnumActions** ppEnumUndoActions;
		HRESULT retValue;
	};

	STDMETHOD(EnumUndoActions)(
		/*[in]*/ IEnumActions** ppEnumUndoActions)
	{
		VSL_DEFINE_MOCK_METHOD(EnumUndoActions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppEnumUndoActions);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumRedoActionsValidValues
	{
		/*[in]*/ IEnumActions** ppEnumRedoActions;
		HRESULT retValue;
	};

	STDMETHOD(EnumRedoActions)(
		/*[in]*/ IEnumActions** ppEnumRedoActions)
	{
		VSL_DEFINE_MOCK_METHOD(EnumRedoActions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppEnumRedoActions);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IACTIONHISTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAddrTrackingControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IADDRTRACKINGCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IADDRTRACKINGCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAddrTrackingControlNotImpl :
	public IAddrTrackingControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAddrTrackingControlNotImpl)

public:

	typedef IAddrTrackingControl Interface;

	STDMETHOD(EnableCOMDynamicAddrTracking)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisableCOMDynamicAddrTracking)()VSL_STDMETHOD_NOTIMPL
};

class IAddrTrackingControlMockImpl :
	public IAddrTrackingControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAddrTrackingControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAddrTrackingControlMockImpl)

	typedef IAddrTrackingControl Interface;
	struct EnableCOMDynamicAddrTrackingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EnableCOMDynamicAddrTracking)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EnableCOMDynamicAddrTracking)

		VSL_RETURN_VALIDVALUES();
	}
	struct DisableCOMDynamicAddrTrackingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DisableCOMDynamicAddrTracking)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DisableCOMDynamicAddrTracking)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IADDRTRACKINGCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAdviseSink2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IADVISESINK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IADVISESINK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAdviseSink2NotImpl :
	public IAdviseSink2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAdviseSink2NotImpl)

public:

	typedef IAdviseSink2 Interface;

	virtual void STDMETHODCALLTYPE OnLinkSrcChange(
		/*[in,unique]*/ IMoniker* /*pmk*/){ return ; }

	virtual void STDMETHODCALLTYPE OnDataChange(
		/*[in,unique]*/ FORMATETC* /*pFormatetc*/,
		/*[in,unique]*/ STGMEDIUM* /*pStgmed*/){ return ; }

	virtual void STDMETHODCALLTYPE OnViewChange(
		/*[in]*/ DWORD /*dwAspect*/,
		/*[in]*/ LONG /*lindex*/){ return ; }

	virtual void STDMETHODCALLTYPE OnRename(
		/*[in]*/ IMoniker* /*pmk*/){ return ; }

	virtual void STDMETHODCALLTYPE OnSave(){ return ; }

	virtual void STDMETHODCALLTYPE OnClose(){ return ; }
};

class IAdviseSink2MockImpl :
	public IAdviseSink2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAdviseSink2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAdviseSink2MockImpl)

	typedef IAdviseSink2 Interface;
	struct OnLinkSrcChangeValidValues
	{
		/*[in,unique]*/ IMoniker* pmk;
	};

	virtual void _stdcall OnLinkSrcChange(
		/*[in,unique]*/ IMoniker* pmk)
	{
		VSL_DEFINE_MOCK_METHOD(OnLinkSrcChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

	}
	struct OnDataChangeValidValues
	{
		/*[in,unique]*/ FORMATETC* pFormatetc;
		/*[in,unique]*/ STGMEDIUM* pStgmed;
	};

	virtual void _stdcall OnDataChange(
		/*[in,unique]*/ FORMATETC* pFormatetc,
		/*[in,unique]*/ STGMEDIUM* pStgmed)
	{
		VSL_DEFINE_MOCK_METHOD(OnDataChange)

		VSL_CHECK_VALIDVALUE_POINTER(pFormatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pStgmed);

	}
	struct OnViewChangeValidValues
	{
		/*[in]*/ DWORD dwAspect;
		/*[in]*/ LONG lindex;
	};

	virtual void _stdcall OnViewChange(
		/*[in]*/ DWORD dwAspect,
		/*[in]*/ LONG lindex)
	{
		VSL_DEFINE_MOCK_METHOD(OnViewChange)

		VSL_CHECK_VALIDVALUE(dwAspect);

		VSL_CHECK_VALIDVALUE(lindex);

	}
	struct OnRenameValidValues
	{
		/*[in]*/ IMoniker* pmk;
	};

	virtual void _stdcall OnRename(
		/*[in]*/ IMoniker* pmk)
	{
		VSL_DEFINE_MOCK_METHOD(OnRename)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

	}

	virtual void _stdcall OnSave()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnSave)

	}

	virtual void _stdcall OnClose()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnClose)

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IADVISESINK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAddrExclusionControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IADDREXCLUSIONCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IADDREXCLUSIONCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAddrExclusionControlNotImpl :
	public IAddrExclusionControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAddrExclusionControlNotImpl)

public:

	typedef IAddrExclusionControl Interface;

	STDMETHOD(GetCurrentAddrExclusionList)(
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppEnumerator*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateAddrExclusionList)(
		/*[in]*/ IUnknown* /*pEnumerator*/)VSL_STDMETHOD_NOTIMPL
};

class IAddrExclusionControlMockImpl :
	public IAddrExclusionControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAddrExclusionControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAddrExclusionControlMockImpl)

	typedef IAddrExclusionControl Interface;
	struct GetCurrentAddrExclusionListValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppEnumerator;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentAddrExclusionList)(
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppEnumerator)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentAddrExclusionList)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppEnumerator);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateAddrExclusionListValidValues
	{
		/*[in]*/ IUnknown* pEnumerator;
		HRESULT retValue;
	};

	STDMETHOD(UpdateAddrExclusionList)(
		/*[in]*/ IUnknown* pEnumerator)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateAddrExclusionList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEnumerator);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IADDREXCLUSIONCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIActiveDesigner.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IACTIVEDESIGNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IACTIVEDESIGNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IActiveDesignerNotImpl :
	public IActiveDesigner
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IActiveDesignerNotImpl)

public:

	typedef IActiveDesigner Interface;

	STDMETHOD(GetRuntimeClassID)(
		/*[out]*/ CLSID* /*pclsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRuntimeMiscStatusFlags)(
		/*[out]*/ DWORD* /*pdwMiscFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryPersistenceInterface)(
		/*[in]*/ REFIID /*riidPersist*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveRuntimeState)(
		/*[in]*/ REFIID /*riidPersist*/,
		/*[in]*/ REFIID /*riidObjStgMed*/,
		/*[in]*/ void* /*pObjStgMed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtensibilityObject)(
		/*[out]*/ IDispatch** /*ppvObjOut*/)VSL_STDMETHOD_NOTIMPL
};

class IActiveDesignerMockImpl :
	public IActiveDesigner,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IActiveDesignerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IActiveDesignerMockImpl)

	typedef IActiveDesigner Interface;
	struct GetRuntimeClassIDValidValues
	{
		/*[out]*/ CLSID* pclsid;
		HRESULT retValue;
	};

	STDMETHOD(GetRuntimeClassID)(
		/*[out]*/ CLSID* pclsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetRuntimeClassID)

		VSL_SET_VALIDVALUE(pclsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRuntimeMiscStatusFlagsValidValues
	{
		/*[out]*/ DWORD* pdwMiscFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetRuntimeMiscStatusFlags)(
		/*[out]*/ DWORD* pdwMiscFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetRuntimeMiscStatusFlags)

		VSL_SET_VALIDVALUE(pdwMiscFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryPersistenceInterfaceValidValues
	{
		/*[in]*/ REFIID riidPersist;
		HRESULT retValue;
	};

	STDMETHOD(QueryPersistenceInterface)(
		/*[in]*/ REFIID riidPersist)
	{
		VSL_DEFINE_MOCK_METHOD(QueryPersistenceInterface)

		VSL_CHECK_VALIDVALUE(riidPersist);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveRuntimeStateValidValues
	{
		/*[in]*/ REFIID riidPersist;
		/*[in]*/ REFIID riidObjStgMed;
		/*[in]*/ void* pObjStgMed;
		HRESULT retValue;
		size_t pObjStgMed_size_in_bytes;
	};

	STDMETHOD(SaveRuntimeState)(
		/*[in]*/ REFIID riidPersist,
		/*[in]*/ REFIID riidObjStgMed,
		/*[in]*/ void* pObjStgMed)
	{
		VSL_DEFINE_MOCK_METHOD(SaveRuntimeState)

		VSL_CHECK_VALIDVALUE(riidPersist);

		VSL_CHECK_VALIDVALUE(riidObjStgMed);

		VSL_CHECK_VALIDVALUE_PVOID(pObjStgMed);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtensibilityObjectValidValues
	{
		/*[out]*/ IDispatch** ppvObjOut;
		HRESULT retValue;
	};

	STDMETHOD(GetExtensibilityObject)(
		/*[out]*/ IDispatch** ppvObjOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtensibilityObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppvObjOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IACTIVEDESIGNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAdviseSinkEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IADVISESINKEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IADVISESINKEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAdviseSinkExNotImpl :
	public IAdviseSinkEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAdviseSinkExNotImpl)

public:

	typedef IAdviseSinkEx Interface;

	virtual void STDMETHODCALLTYPE OnViewStatusChange(
		/*[in]*/ DWORD /*dwViewStatus*/){ return ; }

	virtual void STDMETHODCALLTYPE OnDataChange(
		/*[in,unique]*/ FORMATETC* /*pFormatetc*/,
		/*[in,unique]*/ STGMEDIUM* /*pStgmed*/){ return ; }

	virtual void STDMETHODCALLTYPE OnViewChange(
		/*[in]*/ DWORD /*dwAspect*/,
		/*[in]*/ LONG /*lindex*/){ return ; }

	virtual void STDMETHODCALLTYPE OnRename(
		/*[in]*/ IMoniker* /*pmk*/){ return ; }

	virtual void STDMETHODCALLTYPE OnSave(){ return ; }

	virtual void STDMETHODCALLTYPE OnClose(){ return ; }
};

class IAdviseSinkExMockImpl :
	public IAdviseSinkEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAdviseSinkExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAdviseSinkExMockImpl)

	typedef IAdviseSinkEx Interface;
	struct OnViewStatusChangeValidValues
	{
		/*[in]*/ DWORD dwViewStatus;
	};

	virtual void _stdcall OnViewStatusChange(
		/*[in]*/ DWORD dwViewStatus)
	{
		VSL_DEFINE_MOCK_METHOD(OnViewStatusChange)

		VSL_CHECK_VALIDVALUE(dwViewStatus);

	}
	struct OnDataChangeValidValues
	{
		/*[in,unique]*/ FORMATETC* pFormatetc;
		/*[in,unique]*/ STGMEDIUM* pStgmed;
	};

	virtual void _stdcall OnDataChange(
		/*[in,unique]*/ FORMATETC* pFormatetc,
		/*[in,unique]*/ STGMEDIUM* pStgmed)
	{
		VSL_DEFINE_MOCK_METHOD(OnDataChange)

		VSL_CHECK_VALIDVALUE_POINTER(pFormatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pStgmed);

	}
	struct OnViewChangeValidValues
	{
		/*[in]*/ DWORD dwAspect;
		/*[in]*/ LONG lindex;
	};

	virtual void _stdcall OnViewChange(
		/*[in]*/ DWORD dwAspect,
		/*[in]*/ LONG lindex)
	{
		VSL_DEFINE_MOCK_METHOD(OnViewChange)

		VSL_CHECK_VALIDVALUE(dwAspect);

		VSL_CHECK_VALIDVALUE(lindex);

	}
	struct OnRenameValidValues
	{
		/*[in]*/ IMoniker* pmk;
	};

	virtual void _stdcall OnRename(
		/*[in]*/ IMoniker* pmk)
	{
		VSL_DEFINE_MOCK_METHOD(OnRename)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

	}

	virtual void _stdcall OnSave()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnSave)

	}

	virtual void _stdcall OnClose()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnClose)

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IADVISESINKEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAdviseSink.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IADVISESINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IADVISESINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAdviseSinkNotImpl :
	public IAdviseSink
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAdviseSinkNotImpl)

public:

	typedef IAdviseSink Interface;

	virtual void STDMETHODCALLTYPE OnDataChange(
		/*[in,unique]*/ FORMATETC* /*pFormatetc*/,
		/*[in,unique]*/ STGMEDIUM* /*pStgmed*/){ return ; }

	virtual void STDMETHODCALLTYPE OnViewChange(
		/*[in]*/ DWORD /*dwAspect*/,
		/*[in]*/ LONG /*lindex*/){ return ; }

	virtual void STDMETHODCALLTYPE OnRename(
		/*[in]*/ IMoniker* /*pmk*/){ return ; }

	virtual void STDMETHODCALLTYPE OnSave(){ return ; }

	virtual void STDMETHODCALLTYPE OnClose(){ return ; }
};

class IAdviseSinkMockImpl :
	public IAdviseSink,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAdviseSinkMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAdviseSinkMockImpl)

	typedef IAdviseSink Interface;
	struct OnDataChangeValidValues
	{
		/*[in,unique]*/ FORMATETC* pFormatetc;
		/*[in,unique]*/ STGMEDIUM* pStgmed;
	};

	virtual void _stdcall OnDataChange(
		/*[in,unique]*/ FORMATETC* pFormatetc,
		/*[in,unique]*/ STGMEDIUM* pStgmed)
	{
		VSL_DEFINE_MOCK_METHOD(OnDataChange)

		VSL_CHECK_VALIDVALUE_POINTER(pFormatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pStgmed);

	}
	struct OnViewChangeValidValues
	{
		/*[in]*/ DWORD dwAspect;
		/*[in]*/ LONG lindex;
	};

	virtual void _stdcall OnViewChange(
		/*[in]*/ DWORD dwAspect,
		/*[in]*/ LONG lindex)
	{
		VSL_DEFINE_MOCK_METHOD(OnViewChange)

		VSL_CHECK_VALIDVALUE(dwAspect);

		VSL_CHECK_VALIDVALUE(lindex);

	}
	struct OnRenameValidValues
	{
		/*[in]*/ IMoniker* pmk;
	};

	virtual void _stdcall OnRename(
		/*[in]*/ IMoniker* pmk)
	{
		VSL_DEFINE_MOCK_METHOD(OnRename)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

	}

	virtual void _stdcall OnSave()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnSave)

	}

	virtual void _stdcall OnClose()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnClose)

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IADVISESINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAsyncManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IASYNCMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IASYNCMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAsyncManagerNotImpl :
	public IAsyncManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAsyncManagerNotImpl)

public:

	typedef IAsyncManager Interface;

	STDMETHOD(CompleteCall)(
		/*[in]*/ HRESULT /*Result*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCallContext)(
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*pInterface*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[out]*/ ULONG* /*pulStateFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IAsyncManagerMockImpl :
	public IAsyncManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAsyncManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAsyncManagerMockImpl)

	typedef IAsyncManager Interface;
	struct CompleteCallValidValues
	{
		/*[in]*/ HRESULT Result;
		HRESULT retValue;
	};

	STDMETHOD(CompleteCall)(
		/*[in]*/ HRESULT Result)
	{
		VSL_DEFINE_MOCK_METHOD(CompleteCall)

		VSL_CHECK_VALIDVALUE(Result);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCallContextValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out]*/ void** pInterface;
		HRESULT retValue;
	};

	STDMETHOD(GetCallContext)(
		/*[in]*/ REFIID riid,
		/*[out]*/ void** pInterface)
	{
		VSL_DEFINE_MOCK_METHOD(GetCallContext)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(pInterface);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[out]*/ ULONG* pulStateFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[out]*/ ULONG* pulStateFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(pulStateFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IASYNCMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIAsyncRpcChannelBuffer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IASYNCRPCCHANNELBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IASYNCRPCCHANNELBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IAsyncRpcChannelBufferNotImpl :
	public IAsyncRpcChannelBuffer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAsyncRpcChannelBufferNotImpl)

public:

	typedef IAsyncRpcChannelBuffer Interface;

	STDMETHOD(Send)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[in]*/ ISynchronize* /*pSync*/,
		/*[out]*/ ULONG* /*pulStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Receive)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[out]*/ ULONG* /*pulStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestCtxEx)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[out]*/ DWORD* /*pdwDestContext*/,
		/*[out]*/ void** /*ppvDestContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProtocolVersion)(
		/*[in,out]*/ DWORD* /*pdwVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[in]*/ REFIID /*riid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[out]*/ ULONG* /*pStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* /*pdwDestContext*/,
		/*[out]*/ void** /*ppvDestContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsConnected)()VSL_STDMETHOD_NOTIMPL
};

class IAsyncRpcChannelBufferMockImpl :
	public IAsyncRpcChannelBuffer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IAsyncRpcChannelBufferMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IAsyncRpcChannelBufferMockImpl)

	typedef IAsyncRpcChannelBuffer Interface;
	struct SendValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMsg;
		/*[in]*/ ISynchronize* pSync;
		/*[out]*/ ULONG* pulStatus;
		HRESULT retValue;
	};

	STDMETHOD(Send)(
		/*[in,out]*/ RPCOLEMESSAGE* pMsg,
		/*[in]*/ ISynchronize* pSync,
		/*[out]*/ ULONG* pulStatus)
	{
		VSL_DEFINE_MOCK_METHOD(Send)

		VSL_SET_VALIDVALUE(pMsg);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSync);

		VSL_SET_VALIDVALUE(pulStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReceiveValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMsg;
		/*[out]*/ ULONG* pulStatus;
		HRESULT retValue;
	};

	STDMETHOD(Receive)(
		/*[in,out]*/ RPCOLEMESSAGE* pMsg,
		/*[out]*/ ULONG* pulStatus)
	{
		VSL_DEFINE_MOCK_METHOD(Receive)

		VSL_SET_VALIDVALUE(pMsg);

		VSL_SET_VALIDVALUE(pulStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestCtxExValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		/*[out]*/ DWORD* pdwDestContext;
		/*[out]*/ void** ppvDestContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDestCtxEx)(
		/*[in]*/ RPCOLEMESSAGE* pMsg,
		/*[out]*/ DWORD* pdwDestContext,
		/*[out]*/ void** ppvDestContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestCtxEx)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_SET_VALIDVALUE(pdwDestContext);

		VSL_SET_VALIDVALUE(ppvDestContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProtocolVersionValidValues
	{
		/*[in,out]*/ DWORD* pdwVersion;
		HRESULT retValue;
	};

	STDMETHOD(GetProtocolVersion)(
		/*[in,out]*/ DWORD* pdwVersion)
	{
		VSL_DEFINE_MOCK_METHOD(GetProtocolVersion)

		VSL_SET_VALIDVALUE(pdwVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		/*[in]*/ REFIID riid;
		HRESULT retValue;
	};

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage,
		/*[in]*/ REFIID riid)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendReceiveValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMessage;
		/*[out]*/ ULONG* pStatus;
		HRESULT retValue;
	};

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* pMessage,
		/*[out]*/ ULONG* pStatus)
	{
		VSL_DEFINE_MOCK_METHOD(SendReceive)

		VSL_SET_VALIDVALUE(pMessage);

		VSL_SET_VALIDVALUE(pStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		HRESULT retValue;
	};

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage)
	{
		VSL_DEFINE_MOCK_METHOD(FreeBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestCtxValidValues
	{
		/*[out]*/ DWORD* pdwDestContext;
		/*[out]*/ void** ppvDestContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* pdwDestContext,
		/*[out]*/ void** ppvDestContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestCtx)

		VSL_SET_VALIDVALUE(pdwDestContext);

		VSL_SET_VALIDVALUE(ppvDestContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsConnectedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsConnected)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsConnected)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IASYNCRPCCHANNELBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICallFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICALLFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICALLFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICallFactoryNotImpl :
	public ICallFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICallFactoryNotImpl)

public:

	typedef ICallFactory Interface;

	STDMETHOD(CreateCall)(
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ IUnknown* /*pCtrlUnk*/,
		/*[in]*/ REFIID /*riid2*/,
		/*[out,iid_is(riid2)]*/ IUnknown** /*ppv*/)VSL_STDMETHOD_NOTIMPL
};

class ICallFactoryMockImpl :
	public ICallFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICallFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICallFactoryMockImpl)

	typedef ICallFactory Interface;
	struct CreateCallValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in]*/ IUnknown* pCtrlUnk;
		/*[in]*/ REFIID riid2;
		/*[out,iid_is(riid2)]*/ IUnknown** ppv;
		HRESULT retValue;
	};

	STDMETHOD(CreateCall)(
		/*[in]*/ REFIID riid,
		/*[in]*/ IUnknown* pCtrlUnk,
		/*[in]*/ REFIID riid2,
		/*[out,iid_is(riid2)]*/ IUnknown** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(CreateCall)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCtrlUnk);

		VSL_CHECK_VALIDVALUE(riid2);

		VSL_SET_VALIDVALUE_INTERFACE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICALLFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICancelMethodCalls.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICANCELMETHODCALLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICANCELMETHODCALLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICancelMethodCallsNotImpl :
	public ICancelMethodCalls
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICancelMethodCallsNotImpl)

public:

	typedef ICancelMethodCalls Interface;

	STDMETHOD(Cancel)(
		/*[in]*/ ULONG /*ulSeconds*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TestCancel)()VSL_STDMETHOD_NOTIMPL
};

class ICancelMethodCallsMockImpl :
	public ICancelMethodCalls,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICancelMethodCallsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICancelMethodCallsMockImpl)

	typedef ICancelMethodCalls Interface;
	struct CancelValidValues
	{
		/*[in]*/ ULONG ulSeconds;
		HRESULT retValue;
	};

	STDMETHOD(Cancel)(
		/*[in]*/ ULONG ulSeconds)
	{
		VSL_DEFINE_MOCK_METHOD(Cancel)

		VSL_CHECK_VALIDVALUE(ulSeconds);

		VSL_RETURN_VALIDVALUES();
	}
	struct TestCancelValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(TestCancel)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(TestCancel)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICANCELMETHODCALLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIBuilderWizardManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IBUILDERWIZARDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IBUILDERWIZARDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ocdesign.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IBuilderWizardManagerNotImpl :
	public IBuilderWizardManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IBuilderWizardManagerNotImpl)

public:

	typedef IBuilderWizardManager Interface;

	STDMETHOD(DoesBuilderExist)(
		/*[in]*/ REFGUID /*rguidBuilder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapObjectToBuilderCLSID)(
		/*[in]*/ REFCLSID /*rclsidObject*/,
		/*[in]*/ DWORD /*dwPromptOpt*/,
		/*[in]*/ HWND /*hwndPromptOwner*/,
		/*[out]*/ CLSID* /*pclsidBuilder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapBuilderCATIDToCLSID)(
		/*[in]*/ REFGUID /*rguidBuilder*/,
		/*[in]*/ DWORD /*dwPromptOpt*/,
		/*[in]*/ HWND /*hwndPromptOwner*/,
		/*[out]*/ CLSID* /*pclsidBuilder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuilder)(
		/*[in]*/ REFGUID /*rguidBuilder*/,
		/*[in]*/ DWORD /*grfGetOpt*/,
		/*[in]*/ HWND /*hwndPromptOwner*/,
		/*[out]*/ IDispatch** /*ppdispApp*/,
		/*[out]*/ HWND* /*pwndBuilderOwner*/,
		/*[in]*/ REFIID /*riidBuilder*/,
		/*[out]*/ IUnknown** /*ppunkBuilder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL
};

class IBuilderWizardManagerMockImpl :
	public IBuilderWizardManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IBuilderWizardManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IBuilderWizardManagerMockImpl)

	typedef IBuilderWizardManager Interface;
	struct DoesBuilderExistValidValues
	{
		/*[in]*/ REFGUID rguidBuilder;
		HRESULT retValue;
	};

	STDMETHOD(DoesBuilderExist)(
		/*[in]*/ REFGUID rguidBuilder)
	{
		VSL_DEFINE_MOCK_METHOD(DoesBuilderExist)

		VSL_CHECK_VALIDVALUE(rguidBuilder);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapObjectToBuilderCLSIDValidValues
	{
		/*[in]*/ REFCLSID rclsidObject;
		/*[in]*/ DWORD dwPromptOpt;
		/*[in]*/ HWND hwndPromptOwner;
		/*[out]*/ CLSID* pclsidBuilder;
		HRESULT retValue;
	};

	STDMETHOD(MapObjectToBuilderCLSID)(
		/*[in]*/ REFCLSID rclsidObject,
		/*[in]*/ DWORD dwPromptOpt,
		/*[in]*/ HWND hwndPromptOwner,
		/*[out]*/ CLSID* pclsidBuilder)
	{
		VSL_DEFINE_MOCK_METHOD(MapObjectToBuilderCLSID)

		VSL_CHECK_VALIDVALUE(rclsidObject);

		VSL_CHECK_VALIDVALUE(dwPromptOpt);

		VSL_CHECK_VALIDVALUE(hwndPromptOwner);

		VSL_SET_VALIDVALUE(pclsidBuilder);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapBuilderCATIDToCLSIDValidValues
	{
		/*[in]*/ REFGUID rguidBuilder;
		/*[in]*/ DWORD dwPromptOpt;
		/*[in]*/ HWND hwndPromptOwner;
		/*[out]*/ CLSID* pclsidBuilder;
		HRESULT retValue;
	};

	STDMETHOD(MapBuilderCATIDToCLSID)(
		/*[in]*/ REFGUID rguidBuilder,
		/*[in]*/ DWORD dwPromptOpt,
		/*[in]*/ HWND hwndPromptOwner,
		/*[out]*/ CLSID* pclsidBuilder)
	{
		VSL_DEFINE_MOCK_METHOD(MapBuilderCATIDToCLSID)

		VSL_CHECK_VALIDVALUE(rguidBuilder);

		VSL_CHECK_VALIDVALUE(dwPromptOpt);

		VSL_CHECK_VALIDVALUE(hwndPromptOwner);

		VSL_SET_VALIDVALUE(pclsidBuilder);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBuilderValidValues
	{
		/*[in]*/ REFGUID rguidBuilder;
		/*[in]*/ DWORD grfGetOpt;
		/*[in]*/ HWND hwndPromptOwner;
		/*[out]*/ IDispatch** ppdispApp;
		/*[out]*/ HWND* pwndBuilderOwner;
		/*[in]*/ REFIID riidBuilder;
		/*[out]*/ IUnknown** ppunkBuilder;
		HRESULT retValue;
	};

	STDMETHOD(GetBuilder)(
		/*[in]*/ REFGUID rguidBuilder,
		/*[in]*/ DWORD grfGetOpt,
		/*[in]*/ HWND hwndPromptOwner,
		/*[out]*/ IDispatch** ppdispApp,
		/*[out]*/ HWND* pwndBuilderOwner,
		/*[in]*/ REFIID riidBuilder,
		/*[out]*/ IUnknown** ppunkBuilder)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuilder)

		VSL_CHECK_VALIDVALUE(rguidBuilder);

		VSL_CHECK_VALIDVALUE(grfGetOpt);

		VSL_CHECK_VALIDVALUE(hwndPromptOwner);

		VSL_SET_VALIDVALUE_INTERFACE(ppdispApp);

		VSL_SET_VALIDVALUE(pwndBuilderOwner);

		VSL_CHECK_VALIDVALUE(riidBuilder);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkBuilder);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableModelessValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(EnableModeless)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IBUILDERWIZARDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICategorizeProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICATEGORIZEPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICATEGORIZEPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICategorizePropertiesNotImpl :
	public ICategorizeProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICategorizePropertiesNotImpl)

public:

	typedef ICategorizeProperties Interface;

	STDMETHOD(MapPropertyToCategory)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out]*/ PROPCAT* /*ppropcat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategoryName)(
		/*[in]*/ PROPCAT /*propcat*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL
};

class ICategorizePropertiesMockImpl :
	public ICategorizeProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICategorizePropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICategorizePropertiesMockImpl)

	typedef ICategorizeProperties Interface;
	struct MapPropertyToCategoryValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out]*/ PROPCAT* ppropcat;
		HRESULT retValue;
	};

	STDMETHOD(MapPropertyToCategory)(
		/*[in]*/ DISPID dispid,
		/*[out]*/ PROPCAT* ppropcat)
	{
		VSL_DEFINE_MOCK_METHOD(MapPropertyToCategory)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(ppropcat);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryNameValidValues
	{
		/*[in]*/ PROPCAT propcat;
		/*[in]*/ LCID lcid;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetCategoryName)(
		/*[in]*/ PROPCAT propcat,
		/*[in]*/ LCID lcid,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategoryName)

		VSL_CHECK_VALIDVALUE(propcat);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICATEGORIZEPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIBlockingLock.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IBLOCKINGLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IBLOCKINGLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IBlockingLockNotImpl :
	public IBlockingLock
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IBlockingLockNotImpl)

public:

	typedef IBlockingLock Interface;

	STDMETHOD(Lock)(
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unlock)()VSL_STDMETHOD_NOTIMPL
};

class IBlockingLockMockImpl :
	public IBlockingLock,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IBlockingLockMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IBlockingLockMockImpl)

	typedef IBlockingLock Interface;
	struct LockValidValues
	{
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(Lock)(
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(Lock)

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unlock)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unlock)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IBLOCKINGLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIBindCtx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IBINDCTX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IBINDCTX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IBindCtxNotImpl :
	public IBindCtx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IBindCtxNotImpl)

public:

	typedef IBindCtx Interface;

	STDMETHOD(RegisterObjectBound)(
		/*[in,unique]*/ IUnknown* /*punk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevokeObjectBound)(
		/*[in,unique]*/ IUnknown* /*punk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseBoundObjects)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBindOptions)(
		/*[in]*/ BIND_OPTS* /*pbindopts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBindOptions)(
		/*[in,out]*/ BIND_OPTS* /*pbindopts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRunningObjectTable)(
		/*[out]*/ IRunningObjectTable** /*pprot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterObjectParam)(
		/*[in]*/ LPOLESTR /*pszKey*/,
		/*[in,unique]*/ IUnknown* /*punk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetObjectParam)(
		/*[in]*/ LPOLESTR /*pszKey*/,
		/*[out]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumObjectParam)(
		/*[out]*/ IEnumString** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevokeObjectParam)(
		/*[in]*/ LPOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL
};

class IBindCtxMockImpl :
	public IBindCtx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IBindCtxMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IBindCtxMockImpl)

	typedef IBindCtx Interface;
	struct RegisterObjectBoundValidValues
	{
		/*[in,unique]*/ IUnknown* punk;
		HRESULT retValue;
	};

	STDMETHOD(RegisterObjectBound)(
		/*[in,unique]*/ IUnknown* punk)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterObjectBound)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevokeObjectBoundValidValues
	{
		/*[in,unique]*/ IUnknown* punk;
		HRESULT retValue;
	};

	STDMETHOD(RevokeObjectBound)(
		/*[in,unique]*/ IUnknown* punk)
	{
		VSL_DEFINE_MOCK_METHOD(RevokeObjectBound)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseBoundObjectsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ReleaseBoundObjects)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReleaseBoundObjects)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBindOptionsValidValues
	{
		/*[in]*/ BIND_OPTS* pbindopts;
		HRESULT retValue;
	};

	STDMETHOD(SetBindOptions)(
		/*[in]*/ BIND_OPTS* pbindopts)
	{
		VSL_DEFINE_MOCK_METHOD(SetBindOptions)

		VSL_CHECK_VALIDVALUE_POINTER(pbindopts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBindOptionsValidValues
	{
		/*[in,out]*/ BIND_OPTS* pbindopts;
		HRESULT retValue;
	};

	STDMETHOD(GetBindOptions)(
		/*[in,out]*/ BIND_OPTS* pbindopts)
	{
		VSL_DEFINE_MOCK_METHOD(GetBindOptions)

		VSL_SET_VALIDVALUE(pbindopts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRunningObjectTableValidValues
	{
		/*[out]*/ IRunningObjectTable** pprot;
		HRESULT retValue;
	};

	STDMETHOD(GetRunningObjectTable)(
		/*[out]*/ IRunningObjectTable** pprot)
	{
		VSL_DEFINE_MOCK_METHOD(GetRunningObjectTable)

		VSL_SET_VALIDVALUE_INTERFACE(pprot);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterObjectParamValidValues
	{
		/*[in]*/ LPOLESTR pszKey;
		/*[in,unique]*/ IUnknown* punk;
		HRESULT retValue;
	};

	STDMETHOD(RegisterObjectParam)(
		/*[in]*/ LPOLESTR pszKey,
		/*[in,unique]*/ IUnknown* punk)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterObjectParam)

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetObjectParamValidValues
	{
		/*[in]*/ LPOLESTR pszKey;
		/*[out]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetObjectParam)(
		/*[in]*/ LPOLESTR pszKey,
		/*[out]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetObjectParam)

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumObjectParamValidValues
	{
		/*[out]*/ IEnumString** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumObjectParam)(
		/*[out]*/ IEnumString** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumObjectParam)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevokeObjectParamValidValues
	{
		/*[in]*/ LPOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(RevokeObjectParam)(
		/*[in]*/ LPOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(RevokeObjectParam)

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IBINDCTX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIClassActivator.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICLASSACTIVATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICLASSACTIVATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IClassActivatorNotImpl :
	public IClassActivator
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClassActivatorNotImpl)

public:

	typedef IClassActivator Interface;

	STDMETHOD(GetClassObject)(
		/*[in]*/ REFCLSID /*rclsid*/,
		/*[in]*/ DWORD /*dwClassContext*/,
		/*[in]*/ LCID /*locale*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppv*/)VSL_STDMETHOD_NOTIMPL
};

class IClassActivatorMockImpl :
	public IClassActivator,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClassActivatorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IClassActivatorMockImpl)

	typedef IClassActivator Interface;
	struct GetClassObjectValidValues
	{
		/*[in]*/ REFCLSID rclsid;
		/*[in]*/ DWORD dwClassContext;
		/*[in]*/ LCID locale;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppv;
		HRESULT retValue;
	};

	STDMETHOD(GetClassObject)(
		/*[in]*/ REFCLSID rclsid,
		/*[in]*/ DWORD dwClassContext,
		/*[in]*/ LCID locale,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassObject)

		VSL_CHECK_VALIDVALUE(rclsid);

		VSL_CHECK_VALIDVALUE(dwClassContext);

		VSL_CHECK_VALIDVALUE(locale);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICLASSACTIVATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIChannelHook.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICHANNELHOOK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICHANNELHOOK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IChannelHookNotImpl :
	public IChannelHook
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IChannelHookNotImpl)

public:

	typedef IChannelHook Interface;

	virtual void STDMETHODCALLTYPE ClientGetSize(
		/*[in]*/ REFGUID /*uExtent*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ ULONG* /*pDataSize*/){ return ; }

	virtual void STDMETHODCALLTYPE ClientFillBuffer(
		/*[in]*/ REFGUID /*uExtent*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in,out]*/ ULONG* /*pDataSize*/,
		/*[in]*/ void* /*pDataBuffer*/){ return ; }

	virtual void STDMETHODCALLTYPE ClientNotify(
		/*[in]*/ REFGUID /*uExtent*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ ULONG /*cbDataSize*/,
		/*[in]*/ void* /*pDataBuffer*/,
		/*[in]*/ DWORD /*lDataRep*/,
		/*[in]*/ HRESULT /*hrFault*/){ return ; }

	virtual void STDMETHODCALLTYPE ServerNotify(
		/*[in]*/ REFGUID /*uExtent*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ ULONG /*cbDataSize*/,
		/*[in]*/ void* /*pDataBuffer*/,
		/*[in]*/ DWORD /*lDataRep*/){ return ; }

	virtual void STDMETHODCALLTYPE ServerGetSize(
		/*[in]*/ REFGUID /*uExtent*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ HRESULT /*hrFault*/,
		/*[out]*/ ULONG* /*pDataSize*/){ return ; }

	virtual void STDMETHODCALLTYPE ServerFillBuffer(
		/*[in]*/ REFGUID /*uExtent*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in,out]*/ ULONG* /*pDataSize*/,
		/*[in]*/ void* /*pDataBuffer*/,
		/*[in]*/ HRESULT /*hrFault*/){ return ; }
};

class IChannelHookMockImpl :
	public IChannelHook,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IChannelHookMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IChannelHookMockImpl)

	typedef IChannelHook Interface;
	struct ClientGetSizeValidValues
	{
		/*[in]*/ REFGUID uExtent;
		/*[in]*/ REFIID riid;
		/*[out]*/ ULONG* pDataSize;
	};

	virtual void _stdcall ClientGetSize(
		/*[in]*/ REFGUID uExtent,
		/*[in]*/ REFIID riid,
		/*[out]*/ ULONG* pDataSize)
	{
		VSL_DEFINE_MOCK_METHOD(ClientGetSize)

		VSL_CHECK_VALIDVALUE(uExtent);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(pDataSize);

	}
	struct ClientFillBufferValidValues
	{
		/*[in]*/ REFGUID uExtent;
		/*[in]*/ REFIID riid;
		/*[in,out]*/ ULONG* pDataSize;
		/*[in]*/ void* pDataBuffer;
		size_t pDataBuffer_size_in_bytes;
	};

	virtual void _stdcall ClientFillBuffer(
		/*[in]*/ REFGUID uExtent,
		/*[in]*/ REFIID riid,
		/*[in,out]*/ ULONG* pDataSize,
		/*[in]*/ void* pDataBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(ClientFillBuffer)

		VSL_CHECK_VALIDVALUE(uExtent);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(pDataSize);

		VSL_CHECK_VALIDVALUE_PVOID(pDataBuffer);

	}
	struct ClientNotifyValidValues
	{
		/*[in]*/ REFGUID uExtent;
		/*[in]*/ REFIID riid;
		/*[in]*/ ULONG cbDataSize;
		/*[in]*/ void* pDataBuffer;
		/*[in]*/ DWORD lDataRep;
		/*[in]*/ HRESULT hrFault;
		size_t pDataBuffer_size_in_bytes;
	};

	virtual void _stdcall ClientNotify(
		/*[in]*/ REFGUID uExtent,
		/*[in]*/ REFIID riid,
		/*[in]*/ ULONG cbDataSize,
		/*[in]*/ void* pDataBuffer,
		/*[in]*/ DWORD lDataRep,
		/*[in]*/ HRESULT hrFault)
	{
		VSL_DEFINE_MOCK_METHOD(ClientNotify)

		VSL_CHECK_VALIDVALUE(uExtent);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(cbDataSize);

		VSL_CHECK_VALIDVALUE_PVOID(pDataBuffer);

		VSL_CHECK_VALIDVALUE(lDataRep);

		VSL_CHECK_VALIDVALUE(hrFault);

	}
	struct ServerNotifyValidValues
	{
		/*[in]*/ REFGUID uExtent;
		/*[in]*/ REFIID riid;
		/*[in]*/ ULONG cbDataSize;
		/*[in]*/ void* pDataBuffer;
		/*[in]*/ DWORD lDataRep;
		size_t pDataBuffer_size_in_bytes;
	};

	virtual void _stdcall ServerNotify(
		/*[in]*/ REFGUID uExtent,
		/*[in]*/ REFIID riid,
		/*[in]*/ ULONG cbDataSize,
		/*[in]*/ void* pDataBuffer,
		/*[in]*/ DWORD lDataRep)
	{
		VSL_DEFINE_MOCK_METHOD(ServerNotify)

		VSL_CHECK_VALIDVALUE(uExtent);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(cbDataSize);

		VSL_CHECK_VALIDVALUE_PVOID(pDataBuffer);

		VSL_CHECK_VALIDVALUE(lDataRep);

	}
	struct ServerGetSizeValidValues
	{
		/*[in]*/ REFGUID uExtent;
		/*[in]*/ REFIID riid;
		/*[in]*/ HRESULT hrFault;
		/*[out]*/ ULONG* pDataSize;
	};

	virtual void _stdcall ServerGetSize(
		/*[in]*/ REFGUID uExtent,
		/*[in]*/ REFIID riid,
		/*[in]*/ HRESULT hrFault,
		/*[out]*/ ULONG* pDataSize)
	{
		VSL_DEFINE_MOCK_METHOD(ServerGetSize)

		VSL_CHECK_VALIDVALUE(uExtent);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(hrFault);

		VSL_SET_VALIDVALUE(pDataSize);

	}
	struct ServerFillBufferValidValues
	{
		/*[in]*/ REFGUID uExtent;
		/*[in]*/ REFIID riid;
		/*[in,out]*/ ULONG* pDataSize;
		/*[in]*/ void* pDataBuffer;
		/*[in]*/ HRESULT hrFault;
		size_t pDataBuffer_size_in_bytes;
	};

	virtual void _stdcall ServerFillBuffer(
		/*[in]*/ REFGUID uExtent,
		/*[in]*/ REFIID riid,
		/*[in,out]*/ ULONG* pDataSize,
		/*[in]*/ void* pDataBuffer,
		/*[in]*/ HRESULT hrFault)
	{
		VSL_DEFINE_MOCK_METHOD(ServerFillBuffer)

		VSL_CHECK_VALIDVALUE(uExtent);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(pDataSize);

		VSL_CHECK_VALIDVALUE_PVOID(pDataBuffer);

		VSL_CHECK_VALIDVALUE(hrFault);

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICHANNELHOOK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIClassFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICLASSFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICLASSFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "Unknwn.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IClassFactoryNotImpl :
	public IClassFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClassFactoryNotImpl)

public:

	typedef IClassFactory Interface;

	STDMETHOD(CreateInstance)(
		/*[in,unique]*/ IUnknown* /*pUnkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockServer)(
		/*[in]*/ BOOL /*fLock*/)VSL_STDMETHOD_NOTIMPL
};

class IClassFactoryMockImpl :
	public IClassFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClassFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IClassFactoryMockImpl)

	typedef IClassFactory Interface;
	struct CreateInstanceValidValues
	{
		/*[in,unique]*/ IUnknown* pUnkOuter;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in,unique]*/ IUnknown* pUnkOuter,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockServerValidValues
	{
		/*[in]*/ BOOL fLock;
		HRESULT retValue;
	};

	STDMETHOD(LockServer)(
		/*[in]*/ BOOL fLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockServer)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICLASSFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICodeNavigate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICODENAVIGATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICODENAVIGATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICodeNavigateNotImpl :
	public ICodeNavigate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICodeNavigateNotImpl)

public:

	typedef ICodeNavigate Interface;

	STDMETHOD(DisplayDefaultEventHandler)(
		/*[in]*/ LPCOLESTR /*lpstrObjectName*/)VSL_STDMETHOD_NOTIMPL
};

class ICodeNavigateMockImpl :
	public ICodeNavigate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICodeNavigateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICodeNavigateMockImpl)

	typedef ICodeNavigate Interface;
	struct DisplayDefaultEventHandlerValidValues
	{
		/*[in]*/ LPCOLESTR lpstrObjectName;
		HRESULT retValue;
	};

	STDMETHOD(DisplayDefaultEventHandler)(
		/*[in]*/ LPCOLESTR lpstrObjectName)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayDefaultEventHandler)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrObjectName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICODENAVIGATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIClientSecurity.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICLIENTSECURITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICLIENTSECURITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IClientSecurityNotImpl :
	public IClientSecurity
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClientSecurityNotImpl)

public:

	typedef IClientSecurity Interface;

	STDMETHOD(QueryBlanket)(
		/*[in]*/ IUnknown* /*pProxy*/,
		/*[out]*/ DWORD* /*pAuthnSvc*/,
		/*[out]*/ DWORD* /*pAuthzSvc*/,
		/*[out]*/ OLECHAR** /*pServerPrincName*/,
		/*[out]*/ DWORD* /*pAuthnLevel*/,
		/*[out]*/ DWORD* /*pImpLevel*/,
		/*[out]*/ void** /*pAuthInfo*/,
		/*[out]*/ DWORD* /*pCapabilites*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBlanket)(
		/*[in]*/ IUnknown* /*pProxy*/,
		/*[in]*/ DWORD /*dwAuthnSvc*/,
		/*[in]*/ DWORD /*dwAuthzSvc*/,
		/*[in]*/ OLECHAR* /*pServerPrincName*/,
		/*[in]*/ DWORD /*dwAuthnLevel*/,
		/*[in]*/ DWORD /*dwImpLevel*/,
		/*[in]*/ void* /*pAuthInfo*/,
		/*[in]*/ DWORD /*dwCapabilities*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyProxy)(
		/*[in]*/ IUnknown* /*pProxy*/,
		/*[out]*/ IUnknown** /*ppCopy*/)VSL_STDMETHOD_NOTIMPL
};

class IClientSecurityMockImpl :
	public IClientSecurity,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClientSecurityMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IClientSecurityMockImpl)

	typedef IClientSecurity Interface;
	struct QueryBlanketValidValues
	{
		/*[in]*/ IUnknown* pProxy;
		/*[out]*/ DWORD* pAuthnSvc;
		/*[out]*/ DWORD* pAuthzSvc;
		/*[out]*/ OLECHAR** pServerPrincName;
		/*[out]*/ DWORD* pAuthnLevel;
		/*[out]*/ DWORD* pImpLevel;
		/*[out]*/ void** pAuthInfo;
		/*[out]*/ DWORD* pCapabilites;
		HRESULT retValue;
	};

	STDMETHOD(QueryBlanket)(
		/*[in]*/ IUnknown* pProxy,
		/*[out]*/ DWORD* pAuthnSvc,
		/*[out]*/ DWORD* pAuthzSvc,
		/*[out]*/ OLECHAR** pServerPrincName,
		/*[out]*/ DWORD* pAuthnLevel,
		/*[out]*/ DWORD* pImpLevel,
		/*[out]*/ void** pAuthInfo,
		/*[out]*/ DWORD* pCapabilites)
	{
		VSL_DEFINE_MOCK_METHOD(QueryBlanket)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProxy);

		VSL_SET_VALIDVALUE(pAuthnSvc);

		VSL_SET_VALIDVALUE(pAuthzSvc);

		VSL_SET_VALIDVALUE(pServerPrincName);

		VSL_SET_VALIDVALUE(pAuthnLevel);

		VSL_SET_VALIDVALUE(pImpLevel);

		VSL_SET_VALIDVALUE(pAuthInfo);

		VSL_SET_VALIDVALUE(pCapabilites);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBlanketValidValues
	{
		/*[in]*/ IUnknown* pProxy;
		/*[in]*/ DWORD dwAuthnSvc;
		/*[in]*/ DWORD dwAuthzSvc;
		/*[in]*/ OLECHAR* pServerPrincName;
		/*[in]*/ DWORD dwAuthnLevel;
		/*[in]*/ DWORD dwImpLevel;
		/*[in]*/ void* pAuthInfo;
		/*[in]*/ DWORD dwCapabilities;
		HRESULT retValue;
		size_t pAuthInfo_size_in_bytes;
	};

	STDMETHOD(SetBlanket)(
		/*[in]*/ IUnknown* pProxy,
		/*[in]*/ DWORD dwAuthnSvc,
		/*[in]*/ DWORD dwAuthzSvc,
		/*[in]*/ OLECHAR* pServerPrincName,
		/*[in]*/ DWORD dwAuthnLevel,
		/*[in]*/ DWORD dwImpLevel,
		/*[in]*/ void* pAuthInfo,
		/*[in]*/ DWORD dwCapabilities)
	{
		VSL_DEFINE_MOCK_METHOD(SetBlanket)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProxy);

		VSL_CHECK_VALIDVALUE(dwAuthnSvc);

		VSL_CHECK_VALIDVALUE(dwAuthzSvc);

		VSL_CHECK_VALIDVALUE_STRINGW(pServerPrincName);

		VSL_CHECK_VALIDVALUE(dwAuthnLevel);

		VSL_CHECK_VALIDVALUE(dwImpLevel);

		VSL_CHECK_VALIDVALUE_PVOID(pAuthInfo);

		VSL_CHECK_VALIDVALUE(dwCapabilities);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyProxyValidValues
	{
		/*[in]*/ IUnknown* pProxy;
		/*[out]*/ IUnknown** ppCopy;
		HRESULT retValue;
	};

	STDMETHOD(CopyProxy)(
		/*[in]*/ IUnknown* pProxy,
		/*[out]*/ IUnknown** ppCopy)
	{
		VSL_DEFINE_MOCK_METHOD(CopyProxy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProxy);

		VSL_SET_VALIDVALUE_INTERFACE(ppCopy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICLIENTSECURITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICodeNavigate2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICODENAVIGATE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICODENAVIGATE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICodeNavigate2NotImpl :
	public ICodeNavigate2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICodeNavigate2NotImpl)

public:

	typedef ICodeNavigate2 Interface;

	STDMETHOD(DisplayEventHandler)(
		/*[in]*/ LPCOLESTR /*lpstrObjectName*/,
		/*[in]*/ LPCOLESTR /*lpstrEventName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayDefaultEventHandler)(
		/*[in]*/ LPCOLESTR /*lpstrObjectName*/)VSL_STDMETHOD_NOTIMPL
};

class ICodeNavigate2MockImpl :
	public ICodeNavigate2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICodeNavigate2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICodeNavigate2MockImpl)

	typedef ICodeNavigate2 Interface;
	struct DisplayEventHandlerValidValues
	{
		/*[in]*/ LPCOLESTR lpstrObjectName;
		/*[in]*/ LPCOLESTR lpstrEventName;
		HRESULT retValue;
	};

	STDMETHOD(DisplayEventHandler)(
		/*[in]*/ LPCOLESTR lpstrObjectName,
		/*[in]*/ LPCOLESTR lpstrEventName)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayEventHandler)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrEventName);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayDefaultEventHandlerValidValues
	{
		/*[in]*/ LPCOLESTR lpstrObjectName;
		HRESULT retValue;
	};

	STDMETHOD(DisplayDefaultEventHandler)(
		/*[in]*/ LPCOLESTR lpstrObjectName)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayDefaultEventHandler)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrObjectName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICODENAVIGATE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIConnectionPoint.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICONNECTIONPOINT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICONNECTIONPOINT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IConnectionPointNotImpl :
	public IConnectionPoint
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IConnectionPointNotImpl)

public:

	typedef IConnectionPoint Interface;

	STDMETHOD(GetConnectionInterface)(
		/*[out]*/ IID* /*pIID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetConnectionPointContainer)(
		/*[out]*/ IConnectionPointContainer** /*ppCPC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Advise)(
		/*[in]*/ IUnknown* /*pUnkSink*/,
		/*[out]*/ DWORD* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumConnections)(
		/*[out]*/ IEnumConnections** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IConnectionPointMockImpl :
	public IConnectionPoint,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IConnectionPointMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IConnectionPointMockImpl)

	typedef IConnectionPoint Interface;
	struct GetConnectionInterfaceValidValues
	{
		/*[out]*/ IID* pIID;
		HRESULT retValue;
	};

	STDMETHOD(GetConnectionInterface)(
		/*[out]*/ IID* pIID)
	{
		VSL_DEFINE_MOCK_METHOD(GetConnectionInterface)

		VSL_SET_VALIDVALUE(pIID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetConnectionPointContainerValidValues
	{
		/*[out]*/ IConnectionPointContainer** ppCPC;
		HRESULT retValue;
	};

	STDMETHOD(GetConnectionPointContainer)(
		/*[out]*/ IConnectionPointContainer** ppCPC)
	{
		VSL_DEFINE_MOCK_METHOD(GetConnectionPointContainer)

		VSL_SET_VALIDVALUE_INTERFACE(ppCPC);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseValidValues
	{
		/*[in]*/ IUnknown* pUnkSink;
		/*[out]*/ DWORD* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(Advise)(
		/*[in]*/ IUnknown* pUnkSink,
		/*[out]*/ DWORD* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Advise)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseValidValues
	{
		/*[in]*/ DWORD dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Unadvise)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumConnectionsValidValues
	{
		/*[out]*/ IEnumConnections** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumConnections)(
		/*[out]*/ IEnumConnections** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumConnections)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICONNECTIONPOINT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIClassFactory2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICLASSFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICLASSFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IClassFactory2NotImpl :
	public IClassFactory2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClassFactory2NotImpl)

public:

	typedef IClassFactory2 Interface;

	STDMETHOD(GetLicInfo)(
		/*[out]*/ LICINFO* /*pLicInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RequestLicKey)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[out]*/ BSTR* /*pBstrKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstanceLic)(
		/*[in]*/ IUnknown* /*pUnkOuter*/,
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ BSTR /*bstrKey*/,
		/*[out,iid_is(riid)]*/ PVOID* /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstance)(
		/*[in,unique]*/ IUnknown* /*pUnkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockServer)(
		/*[in]*/ BOOL /*fLock*/)VSL_STDMETHOD_NOTIMPL
};

class IClassFactory2MockImpl :
	public IClassFactory2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IClassFactory2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IClassFactory2MockImpl)

	typedef IClassFactory2 Interface;
	struct GetLicInfoValidValues
	{
		/*[out]*/ LICINFO* pLicInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetLicInfo)(
		/*[out]*/ LICINFO* pLicInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetLicInfo)

		VSL_SET_VALIDVALUE(pLicInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct RequestLicKeyValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[out]*/ BSTR* pBstrKey;
		HRESULT retValue;
	};

	STDMETHOD(RequestLicKey)(
		/*[in]*/ DWORD dwReserved,
		/*[out]*/ BSTR* pBstrKey)
	{
		VSL_DEFINE_MOCK_METHOD(RequestLicKey)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE_BSTR(pBstrKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceLicValidValues
	{
		/*[in]*/ IUnknown* pUnkOuter;
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in]*/ REFIID riid;
		/*[in]*/ BSTR bstrKey;
		/*[out,iid_is(riid)]*/ PVOID* ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstanceLic)(
		/*[in]*/ IUnknown* pUnkOuter,
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in]*/ REFIID riid,
		/*[in]*/ BSTR bstrKey,
		/*[out,iid_is(riid)]*/ PVOID* ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstanceLic)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkOuter);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_BSTR(bstrKey);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceValidValues
	{
		/*[in,unique]*/ IUnknown* pUnkOuter;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in,unique]*/ IUnknown* pUnkOuter,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockServerValidValues
	{
		/*[in]*/ BOOL fLock;
		HRESULT retValue;
	};

	STDMETHOD(LockServer)(
		/*[in]*/ BOOL fLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockServer)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICLASSFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIComThreadingInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICOMTHREADINGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICOMTHREADINGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IComThreadingInfoNotImpl :
	public IComThreadingInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IComThreadingInfoNotImpl)

public:

	typedef IComThreadingInfo Interface;

	STDMETHOD(GetCurrentApartmentType)(
		/*[out]*/ APTTYPE* /*pAptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentThreadType)(
		/*[out]*/ THDTYPE* /*pThreadType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentLogicalThreadId)(
		/*[out]*/ GUID* /*pguidLogicalThreadId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCurrentLogicalThreadId)(
		/*[in]*/ REFGUID /*rguid*/)VSL_STDMETHOD_NOTIMPL
};

class IComThreadingInfoMockImpl :
	public IComThreadingInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IComThreadingInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IComThreadingInfoMockImpl)

	typedef IComThreadingInfo Interface;
	struct GetCurrentApartmentTypeValidValues
	{
		/*[out]*/ APTTYPE* pAptType;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentApartmentType)(
		/*[out]*/ APTTYPE* pAptType)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentApartmentType)

		VSL_SET_VALIDVALUE(pAptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentThreadTypeValidValues
	{
		/*[out]*/ THDTYPE* pThreadType;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentThreadType)(
		/*[out]*/ THDTYPE* pThreadType)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentThreadType)

		VSL_SET_VALIDVALUE(pThreadType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentLogicalThreadIdValidValues
	{
		/*[out]*/ GUID* pguidLogicalThreadId;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentLogicalThreadId)(
		/*[out]*/ GUID* pguidLogicalThreadId)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentLogicalThreadId)

		VSL_SET_VALIDVALUE(pguidLogicalThreadId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCurrentLogicalThreadIdValidValues
	{
		/*[in]*/ REFGUID rguid;
		HRESULT retValue;
	};

	STDMETHOD(SetCurrentLogicalThreadId)(
		/*[in]*/ REFGUID rguid)
	{
		VSL_DEFINE_MOCK_METHOD(SetCurrentLogicalThreadId)

		VSL_CHECK_VALIDVALUE(rguid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICOMTHREADINGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIConnectionPointContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICONNECTIONPOINTCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICONNECTIONPOINTCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IConnectionPointContainerNotImpl :
	public IConnectionPointContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IConnectionPointContainerNotImpl)

public:

	typedef IConnectionPointContainer Interface;

	STDMETHOD(EnumConnectionPoints)(
		/*[out]*/ IEnumConnectionPoints** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindConnectionPoint)(
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ IConnectionPoint** /*ppCP*/)VSL_STDMETHOD_NOTIMPL
};

class IConnectionPointContainerMockImpl :
	public IConnectionPointContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IConnectionPointContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IConnectionPointContainerMockImpl)

	typedef IConnectionPointContainer Interface;
	struct EnumConnectionPointsValidValues
	{
		/*[out]*/ IEnumConnectionPoints** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumConnectionPoints)(
		/*[out]*/ IEnumConnectionPoints** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumConnectionPoints)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindConnectionPointValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out]*/ IConnectionPoint** ppCP;
		HRESULT retValue;
	};

	STDMETHOD(FindConnectionPoint)(
		/*[in]*/ REFIID riid,
		/*[out]*/ IConnectionPoint** ppCP)
	{
		VSL_DEFINE_MOCK_METHOD(FindConnectionPoint)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE_INTERFACE(ppCP);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICONNECTIONPOINTCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIContinueCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICONTINUECALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICONTINUECALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IContinueCallbackNotImpl :
	public IContinueCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IContinueCallbackNotImpl)

public:

	typedef IContinueCallback Interface;

	STDMETHOD(FContinue)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FContinuePrinting)(
		/*[in]*/ LONG /*nCntPrinted*/,
		/*[in]*/ LONG /*nCurPage*/,
		/*[in,unique]*/ wchar_t* /*pwszPrintStatus*/)VSL_STDMETHOD_NOTIMPL
};

class IContinueCallbackMockImpl :
	public IContinueCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IContinueCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IContinueCallbackMockImpl)

	typedef IContinueCallback Interface;
	struct FContinueValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FContinue)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FContinue)

		VSL_RETURN_VALIDVALUES();
	}
	struct FContinuePrintingValidValues
	{
		/*[in]*/ LONG nCntPrinted;
		/*[in]*/ LONG nCurPage;
		/*[in,unique]*/ wchar_t* pwszPrintStatus;
		HRESULT retValue;
	};

	STDMETHOD(FContinuePrinting)(
		/*[in]*/ LONG nCntPrinted,
		/*[in]*/ LONG nCurPage,
		/*[in,unique]*/ wchar_t* pwszPrintStatus)
	{
		VSL_DEFINE_MOCK_METHOD(FContinuePrinting)

		VSL_CHECK_VALIDVALUE(nCntPrinted);

		VSL_CHECK_VALIDVALUE(nCurPage);

		VSL_CHECK_VALIDVALUE_POINTER(pwszPrintStatus);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICONTINUECALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIContinue.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICONTINUE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICONTINUE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IContinueNotImpl :
	public IContinue
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IContinueNotImpl)

public:

	typedef IContinue Interface;

	STDMETHOD(FContinue)()VSL_STDMETHOD_NOTIMPL
};

class IContinueMockImpl :
	public IContinue,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IContinueMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IContinueMockImpl)

	typedef IContinue Interface;
	struct FContinueValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FContinue)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FContinue)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICONTINUE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICreateErrorInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICREATEERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICREATEERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICreateErrorInfoNotImpl :
	public ICreateErrorInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateErrorInfoNotImpl)

public:

	typedef ICreateErrorInfo Interface;

	STDMETHOD(SetGUID)(
		/*[in]*/ REFGUID /*rguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSource)(
		/*[in]*/ LPOLESTR /*szSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDescription)(
		/*[in]*/ LPOLESTR /*szDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpFile)(
		/*[in]*/ LPOLESTR /*szHelpFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL
};

class ICreateErrorInfoMockImpl :
	public ICreateErrorInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateErrorInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICreateErrorInfoMockImpl)

	typedef ICreateErrorInfo Interface;
	struct SetGUIDValidValues
	{
		/*[in]*/ REFGUID rguid;
		HRESULT retValue;
	};

	STDMETHOD(SetGUID)(
		/*[in]*/ REFGUID rguid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGUID)

		VSL_CHECK_VALIDVALUE(rguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSourceValidValues
	{
		/*[in]*/ LPOLESTR szSource;
		HRESULT retValue;
	};

	STDMETHOD(SetSource)(
		/*[in]*/ LPOLESTR szSource)
	{
		VSL_DEFINE_MOCK_METHOD(SetSource)

		VSL_CHECK_VALIDVALUE_STRINGW(szSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDescriptionValidValues
	{
		/*[in]*/ LPOLESTR szDescription;
		HRESULT retValue;
	};

	STDMETHOD(SetDescription)(
		/*[in]*/ LPOLESTR szDescription)
	{
		VSL_DEFINE_MOCK_METHOD(SetDescription)

		VSL_CHECK_VALIDVALUE_STRINGW(szDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpFileValidValues
	{
		/*[in]*/ LPOLESTR szHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpFile)(
		/*[in]*/ LPOLESTR szHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpFile)

		VSL_CHECK_VALIDVALUE_STRINGW(szHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpContextValidValues
	{
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpContext)

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICREATEERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICreateTypeInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICREATETYPEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICREATETYPEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICreateTypeInfo2NotImpl :
	public ICreateTypeInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeInfo2NotImpl)

public:

	typedef ICreateTypeInfo2 Interface;

	STDMETHOD(DeleteFuncDesc)(
		/*[in]*/ UINT /*index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteFuncDescByMemId)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ INVOKEKIND /*invKind*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteVarDesc)(
		/*[in]*/ UINT /*index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteVarDescByMemId)(
		/*[in]*/ MEMBERID /*memid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteImplType)(
		/*[in]*/ UINT /*index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCustData)(
		/*[in]*/ REFGUID /*guid*/,
		/*[in]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncCustData)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[in]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetParamCustData)(
		/*[in]*/ UINT /*indexFunc*/,
		/*[in]*/ UINT /*indexParam*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[in]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarCustData)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[in]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetImplTypeCustData)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[in]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpStringContext)(
		/*[in]*/ ULONG /*dwHelpStringContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncHelpStringContext)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ ULONG /*dwHelpStringContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarHelpStringContext)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ ULONG /*dwHelpStringContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invalidate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ LPOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID /*guid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTypeFlags)(
		/*[in]*/ UINT /*uTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR /*pStrDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD /*wMajorVerNum*/,
		/*[in]*/ WORD /*wMinorVerNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddRefTypeInfo)(
		/*[in]*/ ITypeInfo* /*pTInfo*/,
		/*[in]*/ HREFTYPE* /*phRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddFuncDesc)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ FUNCDESC* /*pFuncDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddImplType)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ HREFTYPE /*hRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetImplTypeFlags)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ INT /*implTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAlignment)(
		/*[in]*/ WORD /*cbAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSchema)(
		/*[in]*/ LPOLESTR /*pStrSchema*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddVarDesc)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ VARDESC* /*pVarDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncAndParamNames)(
		/*[in]*/ UINT /*index*/,
		/*[in,size_is((UINT)cNames),in]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarName)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTypeDescAlias)(
		/*[in]*/ TYPEDESC* /*pTDescAlias*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DefineFuncAsDllEntry)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szDllName*/,
		/*[in]*/ LPOLESTR /*szProcName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncDocString)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szDocString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarDocString)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szDocString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncHelpContext)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarHelpContext)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMops)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ BSTR /*bstrMops*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTypeIdldesc)(
		/*[in]*/ IDLDESC* /*pIdlDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LayOut)()VSL_STDMETHOD_NOTIMPL
};

class ICreateTypeInfo2MockImpl :
	public ICreateTypeInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICreateTypeInfo2MockImpl)

	typedef ICreateTypeInfo2 Interface;
	struct DeleteFuncDescValidValues
	{
		/*[in]*/ UINT index;
		HRESULT retValue;
	};

	STDMETHOD(DeleteFuncDesc)(
		/*[in]*/ UINT index)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteFuncDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteFuncDescByMemIdValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ INVOKEKIND invKind;
		HRESULT retValue;
	};

	STDMETHOD(DeleteFuncDescByMemId)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ INVOKEKIND invKind)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteFuncDescByMemId)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(invKind);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteVarDescValidValues
	{
		/*[in]*/ UINT index;
		HRESULT retValue;
	};

	STDMETHOD(DeleteVarDesc)(
		/*[in]*/ UINT index)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteVarDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteVarDescByMemIdValidValues
	{
		/*[in]*/ MEMBERID memid;
		HRESULT retValue;
	};

	STDMETHOD(DeleteVarDescByMemId)(
		/*[in]*/ MEMBERID memid)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteVarDescByMemId)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteImplTypeValidValues
	{
		/*[in]*/ UINT index;
		HRESULT retValue;
	};

	STDMETHOD(DeleteImplType)(
		/*[in]*/ UINT index)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteImplType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCustDataValidValues
	{
		/*[in]*/ REFGUID guid;
		/*[in]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(SetCustData)(
		/*[in]*/ REFGUID guid,
		/*[in]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetCustData)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_POINTER(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ REFGUID guid;
		/*[in]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncCustData)(
		/*[in]*/ UINT index,
		/*[in]*/ REFGUID guid,
		/*[in]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_POINTER(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetParamCustDataValidValues
	{
		/*[in]*/ UINT indexFunc;
		/*[in]*/ UINT indexParam;
		/*[in]*/ REFGUID guid;
		/*[in]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(SetParamCustData)(
		/*[in]*/ UINT indexFunc,
		/*[in]*/ UINT indexParam,
		/*[in]*/ REFGUID guid,
		/*[in]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetParamCustData)

		VSL_CHECK_VALIDVALUE(indexFunc);

		VSL_CHECK_VALIDVALUE(indexParam);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_POINTER(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ REFGUID guid;
		/*[in]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(SetVarCustData)(
		/*[in]*/ UINT index,
		/*[in]*/ REFGUID guid,
		/*[in]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_POINTER(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetImplTypeCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ REFGUID guid;
		/*[in]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(SetImplTypeCustData)(
		/*[in]*/ UINT index,
		/*[in]*/ REFGUID guid,
		/*[in]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetImplTypeCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_POINTER(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpStringContextValidValues
	{
		/*[in]*/ ULONG dwHelpStringContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpStringContext)(
		/*[in]*/ ULONG dwHelpStringContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpStringContext)

		VSL_CHECK_VALIDVALUE(dwHelpStringContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncHelpStringContextValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ ULONG dwHelpStringContext;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncHelpStringContext)(
		/*[in]*/ UINT index,
		/*[in]*/ ULONG dwHelpStringContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncHelpStringContext)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(dwHelpStringContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarHelpStringContextValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ ULONG dwHelpStringContext;
		HRESULT retValue;
	};

	STDMETHOD(SetVarHelpStringContext)(
		/*[in]*/ UINT index,
		/*[in]*/ ULONG dwHelpStringContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarHelpStringContext)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(dwHelpStringContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Invalidate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Invalidate)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ LPOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ LPOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidValidValues
	{
		/*[in]*/ REFGUID guid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID guid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuid)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeFlagsValidValues
	{
		/*[in]*/ UINT uTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetTypeFlags)(
		/*[in]*/ UINT uTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetTypeFlags)

		VSL_CHECK_VALIDVALUE(uTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDocStringValidValues
	{
		/*[in]*/ LPOLESTR pStrDoc;
		HRESULT retValue;
	};

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR pStrDoc)
	{
		VSL_DEFINE_MOCK_METHOD(SetDocString)

		VSL_CHECK_VALIDVALUE_STRINGW(pStrDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpContextValidValues
	{
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpContext)

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVersionValidValues
	{
		/*[in]*/ WORD wMajorVerNum;
		/*[in]*/ WORD wMinorVerNum;
		HRESULT retValue;
	};

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD wMajorVerNum,
		/*[in]*/ WORD wMinorVerNum)
	{
		VSL_DEFINE_MOCK_METHOD(SetVersion)

		VSL_CHECK_VALIDVALUE(wMajorVerNum);

		VSL_CHECK_VALIDVALUE(wMinorVerNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddRefTypeInfoValidValues
	{
		/*[in]*/ ITypeInfo* pTInfo;
		/*[in]*/ HREFTYPE* phRefType;
		HRESULT retValue;
	};

	STDMETHOD(AddRefTypeInfo)(
		/*[in]*/ ITypeInfo* pTInfo,
		/*[in]*/ HREFTYPE* phRefType)
	{
		VSL_DEFINE_MOCK_METHOD(AddRefTypeInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTInfo);

		VSL_CHECK_VALIDVALUE_POINTER(phRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddFuncDescValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ FUNCDESC* pFuncDesc;
		HRESULT retValue;
	};

	STDMETHOD(AddFuncDesc)(
		/*[in]*/ UINT index,
		/*[in]*/ FUNCDESC* pFuncDesc)
	{
		VSL_DEFINE_MOCK_METHOD(AddFuncDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_POINTER(pFuncDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddImplTypeValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ HREFTYPE hRefType;
		HRESULT retValue;
	};

	STDMETHOD(AddImplType)(
		/*[in]*/ UINT index,
		/*[in]*/ HREFTYPE hRefType)
	{
		VSL_DEFINE_MOCK_METHOD(AddImplType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(hRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetImplTypeFlagsValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ INT implTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetImplTypeFlags)(
		/*[in]*/ UINT index,
		/*[in]*/ INT implTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetImplTypeFlags)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(implTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAlignmentValidValues
	{
		/*[in]*/ WORD cbAlignment;
		HRESULT retValue;
	};

	STDMETHOD(SetAlignment)(
		/*[in]*/ WORD cbAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(SetAlignment)

		VSL_CHECK_VALIDVALUE(cbAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSchemaValidValues
	{
		/*[in]*/ LPOLESTR pStrSchema;
		HRESULT retValue;
	};

	STDMETHOD(SetSchema)(
		/*[in]*/ LPOLESTR pStrSchema)
	{
		VSL_DEFINE_MOCK_METHOD(SetSchema)

		VSL_CHECK_VALIDVALUE_STRINGW(pStrSchema);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddVarDescValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ VARDESC* pVarDesc;
		HRESULT retValue;
	};

	STDMETHOD(AddVarDesc)(
		/*[in]*/ UINT index,
		/*[in]*/ VARDESC* pVarDesc)
	{
		VSL_DEFINE_MOCK_METHOD(AddVarDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_POINTER(pVarDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncAndParamNamesValidValues
	{
		/*[in]*/ UINT index;
		/*[in,size_is((UINT)cNames),in]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncAndParamNames)(
		/*[in]*/ UINT index,
		/*[in,size_is((UINT)cNames),in]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncAndParamNames)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarNameValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(SetVarName)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarName)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeDescAliasValidValues
	{
		/*[in]*/ TYPEDESC* pTDescAlias;
		HRESULT retValue;
	};

	STDMETHOD(SetTypeDescAlias)(
		/*[in]*/ TYPEDESC* pTDescAlias)
	{
		VSL_DEFINE_MOCK_METHOD(SetTypeDescAlias)

		VSL_CHECK_VALIDVALUE_POINTER(pTDescAlias);

		VSL_RETURN_VALIDVALUES();
	}
	struct DefineFuncAsDllEntryValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szDllName;
		/*[in]*/ LPOLESTR szProcName;
		HRESULT retValue;
	};

	STDMETHOD(DefineFuncAsDllEntry)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szDllName,
		/*[in]*/ LPOLESTR szProcName)
	{
		VSL_DEFINE_MOCK_METHOD(DefineFuncAsDllEntry)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szDllName);

		VSL_CHECK_VALIDVALUE_STRINGW(szProcName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncDocStringValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szDocString;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncDocString)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szDocString)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncDocString)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szDocString);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarDocStringValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szDocString;
		HRESULT retValue;
	};

	STDMETHOD(SetVarDocString)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szDocString)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarDocString)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szDocString);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncHelpContextValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncHelpContext)(
		/*[in]*/ UINT index,
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncHelpContext)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarHelpContextValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetVarHelpContext)(
		/*[in]*/ UINT index,
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarHelpContext)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMopsValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ BSTR bstrMops;
		HRESULT retValue;
	};

	STDMETHOD(SetMops)(
		/*[in]*/ UINT index,
		/*[in]*/ BSTR bstrMops)
	{
		VSL_DEFINE_MOCK_METHOD(SetMops)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_BSTR(bstrMops);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeIdldescValidValues
	{
		/*[in]*/ IDLDESC* pIdlDesc;
		HRESULT retValue;
	};

	STDMETHOD(SetTypeIdldesc)(
		/*[in]*/ IDLDESC* pIdlDesc)
	{
		VSL_DEFINE_MOCK_METHOD(SetTypeIdldesc)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIdlDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct LayOutValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LayOut)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LayOut)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICREATETYPEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDataAdviseHolder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDATAADVISEHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDATAADVISEHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDataAdviseHolderNotImpl :
	public IDataAdviseHolder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDataAdviseHolderNotImpl)

public:

	typedef IDataAdviseHolder Interface;

	STDMETHOD(Advise)(
		/*[in,unique]*/ IDataObject* /*pDataObject*/,
		/*[in,unique]*/ FORMATETC* /*pFetc*/,
		/*[in]*/ DWORD /*advf*/,
		/*[in,unique]*/ IAdviseSink* /*pAdvise*/,
		/*[out]*/ DWORD* /*pdwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD /*dwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumAdvise)(
		/*[out]*/ IEnumSTATDATA** /*ppenumAdvise*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendOnDataChange)(
		/*[in,unique]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ DWORD /*advf*/)VSL_STDMETHOD_NOTIMPL
};

class IDataAdviseHolderMockImpl :
	public IDataAdviseHolder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDataAdviseHolderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDataAdviseHolderMockImpl)

	typedef IDataAdviseHolder Interface;
	struct AdviseValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObject;
		/*[in,unique]*/ FORMATETC* pFetc;
		/*[in]*/ DWORD advf;
		/*[in,unique]*/ IAdviseSink* pAdvise;
		/*[out]*/ DWORD* pdwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Advise)(
		/*[in,unique]*/ IDataObject* pDataObject,
		/*[in,unique]*/ FORMATETC* pFetc,
		/*[in]*/ DWORD advf,
		/*[in,unique]*/ IAdviseSink* pAdvise,
		/*[out]*/ DWORD* pdwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Advise)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE_POINTER(pFetc);

		VSL_CHECK_VALIDVALUE(advf);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAdvise);

		VSL_SET_VALIDVALUE(pdwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseValidValues
	{
		/*[in]*/ DWORD dwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD dwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Unadvise)

		VSL_CHECK_VALIDVALUE(dwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumAdviseValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenumAdvise;
		HRESULT retValue;
	};

	STDMETHOD(EnumAdvise)(
		/*[out]*/ IEnumSTATDATA** ppenumAdvise)
	{
		VSL_DEFINE_MOCK_METHOD(EnumAdvise)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumAdvise);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendOnDataChangeValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ DWORD advf;
		HRESULT retValue;
	};

	STDMETHOD(SendOnDataChange)(
		/*[in,unique]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ DWORD advf)
	{
		VSL_DEFINE_MOCK_METHOD(SendOnDataChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(advf);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDATAADVISEHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICreateTypeInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICREATETYPEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICREATETYPEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICreateTypeInfoNotImpl :
	public ICreateTypeInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeInfoNotImpl)

public:

	typedef ICreateTypeInfo Interface;

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID /*guid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTypeFlags)(
		/*[in]*/ UINT /*uTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR /*pStrDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD /*wMajorVerNum*/,
		/*[in]*/ WORD /*wMinorVerNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddRefTypeInfo)(
		/*[in]*/ ITypeInfo* /*pTInfo*/,
		/*[in]*/ HREFTYPE* /*phRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddFuncDesc)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ FUNCDESC* /*pFuncDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddImplType)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ HREFTYPE /*hRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetImplTypeFlags)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ INT /*implTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAlignment)(
		/*[in]*/ WORD /*cbAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSchema)(
		/*[in]*/ LPOLESTR /*pStrSchema*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddVarDesc)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ VARDESC* /*pVarDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncAndParamNames)(
		/*[in]*/ UINT /*index*/,
		/*[in,size_is((UINT)cNames),in]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarName)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTypeDescAlias)(
		/*[in]*/ TYPEDESC* /*pTDescAlias*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DefineFuncAsDllEntry)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szDllName*/,
		/*[in]*/ LPOLESTR /*szProcName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncDocString)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szDocString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarDocString)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ LPOLESTR /*szDocString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFuncHelpContext)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVarHelpContext)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMops)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ BSTR /*bstrMops*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTypeIdldesc)(
		/*[in]*/ IDLDESC* /*pIdlDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LayOut)()VSL_STDMETHOD_NOTIMPL
};

class ICreateTypeInfoMockImpl :
	public ICreateTypeInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICreateTypeInfoMockImpl)

	typedef ICreateTypeInfo Interface;
	struct SetGuidValidValues
	{
		/*[in]*/ REFGUID guid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID guid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuid)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeFlagsValidValues
	{
		/*[in]*/ UINT uTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetTypeFlags)(
		/*[in]*/ UINT uTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetTypeFlags)

		VSL_CHECK_VALIDVALUE(uTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDocStringValidValues
	{
		/*[in]*/ LPOLESTR pStrDoc;
		HRESULT retValue;
	};

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR pStrDoc)
	{
		VSL_DEFINE_MOCK_METHOD(SetDocString)

		VSL_CHECK_VALIDVALUE_STRINGW(pStrDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpContextValidValues
	{
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpContext)

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVersionValidValues
	{
		/*[in]*/ WORD wMajorVerNum;
		/*[in]*/ WORD wMinorVerNum;
		HRESULT retValue;
	};

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD wMajorVerNum,
		/*[in]*/ WORD wMinorVerNum)
	{
		VSL_DEFINE_MOCK_METHOD(SetVersion)

		VSL_CHECK_VALIDVALUE(wMajorVerNum);

		VSL_CHECK_VALIDVALUE(wMinorVerNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddRefTypeInfoValidValues
	{
		/*[in]*/ ITypeInfo* pTInfo;
		/*[in]*/ HREFTYPE* phRefType;
		HRESULT retValue;
	};

	STDMETHOD(AddRefTypeInfo)(
		/*[in]*/ ITypeInfo* pTInfo,
		/*[in]*/ HREFTYPE* phRefType)
	{
		VSL_DEFINE_MOCK_METHOD(AddRefTypeInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTInfo);

		VSL_CHECK_VALIDVALUE_POINTER(phRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddFuncDescValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ FUNCDESC* pFuncDesc;
		HRESULT retValue;
	};

	STDMETHOD(AddFuncDesc)(
		/*[in]*/ UINT index,
		/*[in]*/ FUNCDESC* pFuncDesc)
	{
		VSL_DEFINE_MOCK_METHOD(AddFuncDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_POINTER(pFuncDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddImplTypeValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ HREFTYPE hRefType;
		HRESULT retValue;
	};

	STDMETHOD(AddImplType)(
		/*[in]*/ UINT index,
		/*[in]*/ HREFTYPE hRefType)
	{
		VSL_DEFINE_MOCK_METHOD(AddImplType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(hRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetImplTypeFlagsValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ INT implTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetImplTypeFlags)(
		/*[in]*/ UINT index,
		/*[in]*/ INT implTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetImplTypeFlags)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(implTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAlignmentValidValues
	{
		/*[in]*/ WORD cbAlignment;
		HRESULT retValue;
	};

	STDMETHOD(SetAlignment)(
		/*[in]*/ WORD cbAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(SetAlignment)

		VSL_CHECK_VALIDVALUE(cbAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSchemaValidValues
	{
		/*[in]*/ LPOLESTR pStrSchema;
		HRESULT retValue;
	};

	STDMETHOD(SetSchema)(
		/*[in]*/ LPOLESTR pStrSchema)
	{
		VSL_DEFINE_MOCK_METHOD(SetSchema)

		VSL_CHECK_VALIDVALUE_STRINGW(pStrSchema);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddVarDescValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ VARDESC* pVarDesc;
		HRESULT retValue;
	};

	STDMETHOD(AddVarDesc)(
		/*[in]*/ UINT index,
		/*[in]*/ VARDESC* pVarDesc)
	{
		VSL_DEFINE_MOCK_METHOD(AddVarDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_POINTER(pVarDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncAndParamNamesValidValues
	{
		/*[in]*/ UINT index;
		/*[in,size_is((UINT)cNames),in]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncAndParamNames)(
		/*[in]*/ UINT index,
		/*[in,size_is((UINT)cNames),in]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncAndParamNames)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarNameValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(SetVarName)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarName)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeDescAliasValidValues
	{
		/*[in]*/ TYPEDESC* pTDescAlias;
		HRESULT retValue;
	};

	STDMETHOD(SetTypeDescAlias)(
		/*[in]*/ TYPEDESC* pTDescAlias)
	{
		VSL_DEFINE_MOCK_METHOD(SetTypeDescAlias)

		VSL_CHECK_VALIDVALUE_POINTER(pTDescAlias);

		VSL_RETURN_VALIDVALUES();
	}
	struct DefineFuncAsDllEntryValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szDllName;
		/*[in]*/ LPOLESTR szProcName;
		HRESULT retValue;
	};

	STDMETHOD(DefineFuncAsDllEntry)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szDllName,
		/*[in]*/ LPOLESTR szProcName)
	{
		VSL_DEFINE_MOCK_METHOD(DefineFuncAsDllEntry)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szDllName);

		VSL_CHECK_VALIDVALUE_STRINGW(szProcName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncDocStringValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szDocString;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncDocString)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szDocString)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncDocString)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szDocString);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarDocStringValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ LPOLESTR szDocString;
		HRESULT retValue;
	};

	STDMETHOD(SetVarDocString)(
		/*[in]*/ UINT index,
		/*[in]*/ LPOLESTR szDocString)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarDocString)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_STRINGW(szDocString);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFuncHelpContextValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetFuncHelpContext)(
		/*[in]*/ UINT index,
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetFuncHelpContext)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVarHelpContextValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetVarHelpContext)(
		/*[in]*/ UINT index,
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetVarHelpContext)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMopsValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ BSTR bstrMops;
		HRESULT retValue;
	};

	STDMETHOD(SetMops)(
		/*[in]*/ UINT index,
		/*[in]*/ BSTR bstrMops)
	{
		VSL_DEFINE_MOCK_METHOD(SetMops)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_BSTR(bstrMops);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeIdldescValidValues
	{
		/*[in]*/ IDLDESC* pIdlDesc;
		HRESULT retValue;
	};

	STDMETHOD(SetTypeIdldesc)(
		/*[in]*/ IDLDESC* pIdlDesc)
	{
		VSL_DEFINE_MOCK_METHOD(SetTypeIdldesc)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIdlDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct LayOutValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LayOut)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LayOut)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICREATETYPEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICreateTypeLib.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICREATETYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICREATETYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICreateTypeLibNotImpl :
	public ICreateTypeLib
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeLibNotImpl)

public:

	typedef ICreateTypeLib Interface;

	STDMETHOD(CreateTypeInfo)(
		/*[in]*/ LPOLESTR /*szName*/,
		/*[in]*/ TYPEKIND /*tkind*/,
		/*[out]*/ ICreateTypeInfo** /*ppCTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ LPOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD /*wMajorVerNum*/,
		/*[in]*/ WORD /*wMinorVerNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID /*guid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR /*szDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpFileName)(
		/*[in]*/ LPOLESTR /*szHelpFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLcid)(
		/*[in]*/ LCID /*lcid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLibFlags)(
		/*[in]*/ UINT /*uLibFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveAllChanges)()VSL_STDMETHOD_NOTIMPL
};

class ICreateTypeLibMockImpl :
	public ICreateTypeLib,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeLibMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICreateTypeLibMockImpl)

	typedef ICreateTypeLib Interface;
	struct CreateTypeInfoValidValues
	{
		/*[in]*/ LPOLESTR szName;
		/*[in]*/ TYPEKIND tkind;
		/*[out]*/ ICreateTypeInfo** ppCTInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateTypeInfo)(
		/*[in]*/ LPOLESTR szName,
		/*[in]*/ TYPEKIND tkind,
		/*[out]*/ ICreateTypeInfo** ppCTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateTypeInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE(tkind);

		VSL_SET_VALIDVALUE_INTERFACE(ppCTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ LPOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ LPOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVersionValidValues
	{
		/*[in]*/ WORD wMajorVerNum;
		/*[in]*/ WORD wMinorVerNum;
		HRESULT retValue;
	};

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD wMajorVerNum,
		/*[in]*/ WORD wMinorVerNum)
	{
		VSL_DEFINE_MOCK_METHOD(SetVersion)

		VSL_CHECK_VALIDVALUE(wMajorVerNum);

		VSL_CHECK_VALIDVALUE(wMinorVerNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidValidValues
	{
		/*[in]*/ REFGUID guid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID guid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuid)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDocStringValidValues
	{
		/*[in]*/ LPOLESTR szDoc;
		HRESULT retValue;
	};

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR szDoc)
	{
		VSL_DEFINE_MOCK_METHOD(SetDocString)

		VSL_CHECK_VALIDVALUE_STRINGW(szDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpFileNameValidValues
	{
		/*[in]*/ LPOLESTR szHelpFileName;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpFileName)(
		/*[in]*/ LPOLESTR szHelpFileName)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpFileName)

		VSL_CHECK_VALIDVALUE_STRINGW(szHelpFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpContextValidValues
	{
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpContext)

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLcidValidValues
	{
		/*[in]*/ LCID lcid;
		HRESULT retValue;
	};

	STDMETHOD(SetLcid)(
		/*[in]*/ LCID lcid)
	{
		VSL_DEFINE_MOCK_METHOD(SetLcid)

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLibFlagsValidValues
	{
		/*[in]*/ UINT uLibFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetLibFlags)(
		/*[in]*/ UINT uLibFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetLibFlags)

		VSL_CHECK_VALIDVALUE(uLibFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveAllChangesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SaveAllChanges)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SaveAllChanges)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICREATETYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockICreateTypeLib2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ICREATETYPELIB2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ICREATETYPELIB2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ICreateTypeLib2NotImpl :
	public ICreateTypeLib2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeLib2NotImpl)

public:

	typedef ICreateTypeLib2 Interface;

	STDMETHOD(DeleteTypeInfo)(
		/*[in]*/ LPOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCustData)(
		/*[in]*/ REFGUID /*guid*/,
		/*[in]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpStringContext)(
		/*[in]*/ ULONG /*dwHelpStringContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpStringDll)(
		/*[in]*/ LPOLESTR /*szFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateTypeInfo)(
		/*[in]*/ LPOLESTR /*szName*/,
		/*[in]*/ TYPEKIND /*tkind*/,
		/*[out]*/ ICreateTypeInfo** /*ppCTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ LPOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD /*wMajorVerNum*/,
		/*[in]*/ WORD /*wMinorVerNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID /*guid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR /*szDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpFileName)(
		/*[in]*/ LPOLESTR /*szHelpFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLcid)(
		/*[in]*/ LCID /*lcid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLibFlags)(
		/*[in]*/ UINT /*uLibFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveAllChanges)()VSL_STDMETHOD_NOTIMPL
};

class ICreateTypeLib2MockImpl :
	public ICreateTypeLib2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ICreateTypeLib2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ICreateTypeLib2MockImpl)

	typedef ICreateTypeLib2 Interface;
	struct DeleteTypeInfoValidValues
	{
		/*[in]*/ LPOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(DeleteTypeInfo)(
		/*[in]*/ LPOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteTypeInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCustDataValidValues
	{
		/*[in]*/ REFGUID guid;
		/*[in]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(SetCustData)(
		/*[in]*/ REFGUID guid,
		/*[in]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetCustData)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_POINTER(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpStringContextValidValues
	{
		/*[in]*/ ULONG dwHelpStringContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpStringContext)(
		/*[in]*/ ULONG dwHelpStringContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpStringContext)

		VSL_CHECK_VALIDVALUE(dwHelpStringContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpStringDllValidValues
	{
		/*[in]*/ LPOLESTR szFileName;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpStringDll)(
		/*[in]*/ LPOLESTR szFileName)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpStringDll)

		VSL_CHECK_VALIDVALUE_STRINGW(szFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateTypeInfoValidValues
	{
		/*[in]*/ LPOLESTR szName;
		/*[in]*/ TYPEKIND tkind;
		/*[out]*/ ICreateTypeInfo** ppCTInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateTypeInfo)(
		/*[in]*/ LPOLESTR szName,
		/*[in]*/ TYPEKIND tkind,
		/*[out]*/ ICreateTypeInfo** ppCTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateTypeInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE(tkind);

		VSL_SET_VALIDVALUE_INTERFACE(ppCTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ LPOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ LPOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVersionValidValues
	{
		/*[in]*/ WORD wMajorVerNum;
		/*[in]*/ WORD wMinorVerNum;
		HRESULT retValue;
	};

	STDMETHOD(SetVersion)(
		/*[in]*/ WORD wMajorVerNum,
		/*[in]*/ WORD wMinorVerNum)
	{
		VSL_DEFINE_MOCK_METHOD(SetVersion)

		VSL_CHECK_VALIDVALUE(wMajorVerNum);

		VSL_CHECK_VALIDVALUE(wMinorVerNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidValidValues
	{
		/*[in]*/ REFGUID guid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuid)(
		/*[in]*/ REFGUID guid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuid)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDocStringValidValues
	{
		/*[in]*/ LPOLESTR szDoc;
		HRESULT retValue;
	};

	STDMETHOD(SetDocString)(
		/*[in]*/ LPOLESTR szDoc)
	{
		VSL_DEFINE_MOCK_METHOD(SetDocString)

		VSL_CHECK_VALIDVALUE_STRINGW(szDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpFileNameValidValues
	{
		/*[in]*/ LPOLESTR szHelpFileName;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpFileName)(
		/*[in]*/ LPOLESTR szHelpFileName)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpFileName)

		VSL_CHECK_VALIDVALUE_STRINGW(szHelpFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHelpContextValidValues
	{
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(SetHelpContext)(
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetHelpContext)

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLcidValidValues
	{
		/*[in]*/ LCID lcid;
		HRESULT retValue;
	};

	STDMETHOD(SetLcid)(
		/*[in]*/ LCID lcid)
	{
		VSL_DEFINE_MOCK_METHOD(SetLcid)

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLibFlagsValidValues
	{
		/*[in]*/ UINT uLibFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetLibFlags)(
		/*[in]*/ UINT uLibFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetLibFlags)

		VSL_CHECK_VALIDVALUE(uLibFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveAllChangesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SaveAllChanges)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SaveAllChanges)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ICREATETYPELIB2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDataObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDATAOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDATAOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDataObjectNotImpl :
	public IDataObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDataObjectNotImpl)

public:

	typedef IDataObject Interface;

	STDMETHOD(GetData)(
		/*[in,unique]*/ FORMATETC* /*pformatetcIn*/,
		/*[out]*/ STGMEDIUM* /*pmedium*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDataHere)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/,
		/*[in,out]*/ STGMEDIUM* /*pmedium*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryGetData)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCanonicalFormatEtc)(
		/*[in,unique]*/ FORMATETC* /*pformatectIn*/,
		/*[out]*/ FORMATETC* /*pformatetcOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetData)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/,
		/*[in,unique]*/ STGMEDIUM* /*pmedium*/,
		/*[in]*/ BOOL /*fRelease*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumFormatEtc)(
		/*[in]*/ DWORD /*dwDirection*/,
		/*[out]*/ IEnumFORMATETC** /*ppenumFormatEtc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DAdvise)(
		/*[in]*/ FORMATETC* /*pformatetc*/,
		/*[in]*/ DWORD /*advf*/,
		/*[in,unique]*/ IAdviseSink* /*pAdvSink*/,
		/*[out]*/ DWORD* /*pdwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DUnadvise)(
		/*[in]*/ DWORD /*dwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumDAdvise)(
		/*[out]*/ IEnumSTATDATA** /*ppenumAdvise*/)VSL_STDMETHOD_NOTIMPL
};

class IDataObjectMockImpl :
	public IDataObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDataObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDataObjectMockImpl)

	typedef IDataObject Interface;
	struct GetDataValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetcIn;
		/*[out]*/ STGMEDIUM* pmedium;
		HRESULT retValue;
	};

	STDMETHOD(GetData)(
		/*[in,unique]*/ FORMATETC* pformatetcIn,
		/*[out]*/ STGMEDIUM* pmedium)
	{
		VSL_DEFINE_MOCK_METHOD(GetData)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetcIn);

		VSL_SET_VALIDVALUE(pmedium);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDataHereValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		/*[in,out]*/ STGMEDIUM* pmedium;
		HRESULT retValue;
	};

	STDMETHOD(GetDataHere)(
		/*[in,unique]*/ FORMATETC* pformatetc,
		/*[in,out]*/ STGMEDIUM* pmedium)
	{
		VSL_DEFINE_MOCK_METHOD(GetDataHere)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_SET_VALIDVALUE(pmedium);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryGetDataValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		HRESULT retValue;
	};

	STDMETHOD(QueryGetData)(
		/*[in,unique]*/ FORMATETC* pformatetc)
	{
		VSL_DEFINE_MOCK_METHOD(QueryGetData)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCanonicalFormatEtcValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatectIn;
		/*[out]*/ FORMATETC* pformatetcOut;
		HRESULT retValue;
	};

	STDMETHOD(GetCanonicalFormatEtc)(
		/*[in,unique]*/ FORMATETC* pformatectIn,
		/*[out]*/ FORMATETC* pformatetcOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetCanonicalFormatEtc)

		VSL_CHECK_VALIDVALUE_POINTER(pformatectIn);

		VSL_SET_VALIDVALUE(pformatetcOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDataValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		/*[in,unique]*/ STGMEDIUM* pmedium;
		/*[in]*/ BOOL fRelease;
		HRESULT retValue;
	};

	STDMETHOD(SetData)(
		/*[in,unique]*/ FORMATETC* pformatetc,
		/*[in,unique]*/ STGMEDIUM* pmedium,
		/*[in]*/ BOOL fRelease)
	{
		VSL_DEFINE_MOCK_METHOD(SetData)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pmedium);

		VSL_CHECK_VALIDVALUE(fRelease);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumFormatEtcValidValues
	{
		/*[in]*/ DWORD dwDirection;
		/*[out]*/ IEnumFORMATETC** ppenumFormatEtc;
		HRESULT retValue;
	};

	STDMETHOD(EnumFormatEtc)(
		/*[in]*/ DWORD dwDirection,
		/*[out]*/ IEnumFORMATETC** ppenumFormatEtc)
	{
		VSL_DEFINE_MOCK_METHOD(EnumFormatEtc)

		VSL_CHECK_VALIDVALUE(dwDirection);

		VSL_SET_VALIDVALUE_INTERFACE(ppenumFormatEtc);

		VSL_RETURN_VALIDVALUES();
	}
	struct DAdviseValidValues
	{
		/*[in]*/ FORMATETC* pformatetc;
		/*[in]*/ DWORD advf;
		/*[in,unique]*/ IAdviseSink* pAdvSink;
		/*[out]*/ DWORD* pdwConnection;
		HRESULT retValue;
	};

	STDMETHOD(DAdvise)(
		/*[in]*/ FORMATETC* pformatetc,
		/*[in]*/ DWORD advf,
		/*[in,unique]*/ IAdviseSink* pAdvSink,
		/*[out]*/ DWORD* pdwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(DAdvise)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_CHECK_VALIDVALUE(advf);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAdvSink);

		VSL_SET_VALIDVALUE(pdwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct DUnadviseValidValues
	{
		/*[in]*/ DWORD dwConnection;
		HRESULT retValue;
	};

	STDMETHOD(DUnadvise)(
		/*[in]*/ DWORD dwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(DUnadvise)

		VSL_CHECK_VALIDVALUE(dwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumDAdviseValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenumAdvise;
		HRESULT retValue;
	};

	STDMETHOD(EnumDAdvise)(
		/*[out]*/ IEnumSTATDATA** ppenumAdvise)
	{
		VSL_DEFINE_MOCK_METHOD(EnumDAdvise)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumAdvise);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDATAOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBeforeSymbolSearchEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBEFORESYMBOLSEARCHEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBEFORESYMBOLSEARCHEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBeforeSymbolSearchEvent2NotImpl :
	public IDebugBeforeSymbolSearchEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBeforeSymbolSearchEvent2NotImpl)

public:

	typedef IDebugBeforeSymbolSearchEvent2 Interface;

	STDMETHOD(GetModuleName)(
		/*[out]*/ BSTR* /*pbstrModuleName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBeforeSymbolSearchEvent2MockImpl :
	public IDebugBeforeSymbolSearchEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBeforeSymbolSearchEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBeforeSymbolSearchEvent2MockImpl)

	typedef IDebugBeforeSymbolSearchEvent2 Interface;
	struct GetModuleNameValidValues
	{
		/*[out]*/ BSTR* pbstrModuleName;
		HRESULT retValue;
	};

	STDMETHOD(GetModuleName)(
		/*[out]*/ BSTR* pbstrModuleName)
	{
		VSL_DEFINE_MOCK_METHOD(GetModuleName)

		VSL_SET_VALIDVALUE_BSTR(pbstrModuleName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBEFORESYMBOLSEARCHEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugActivateDocumentEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGACTIVATEDOCUMENTEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGACTIVATEDOCUMENTEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugActivateDocumentEvent2NotImpl :
	public IDebugActivateDocumentEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugActivateDocumentEvent2NotImpl)

public:

	typedef IDebugActivateDocumentEvent2 Interface;

	STDMETHOD(GetDocument)(
		/*[out]*/ IDebugDocument2** /*ppDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** /*ppDocContext*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugActivateDocumentEvent2MockImpl :
	public IDebugActivateDocumentEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugActivateDocumentEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugActivateDocumentEvent2MockImpl)

	typedef IDebugActivateDocumentEvent2 Interface;
	struct GetDocumentValidValues
	{
		/*[out]*/ IDebugDocument2** ppDoc;
		HRESULT retValue;
	};

	STDMETHOD(GetDocument)(
		/*[out]*/ IDebugDocument2** ppDoc)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocument)

		VSL_SET_VALIDVALUE_INTERFACE(ppDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentContextValidValues
	{
		/*[out]*/ IDebugDocumentContext2** ppDocContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** ppDocContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppDocContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGACTIVATEDOCUMENTEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugAttachSecurityCallback2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGATTACHSECURITYCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGATTACHSECURITYCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugAttachSecurityCallback2NotImpl :
	public IDebugAttachSecurityCallback2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugAttachSecurityCallback2NotImpl)

public:

	typedef IDebugAttachSecurityCallback2 Interface;

	STDMETHOD(OnUnsafeAttach)(
		/*[in]*/ IDebugProcess2* /*pProcess*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugAttachSecurityCallback2MockImpl :
	public IDebugAttachSecurityCallback2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugAttachSecurityCallback2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugAttachSecurityCallback2MockImpl)

	typedef IDebugAttachSecurityCallback2 Interface;
	struct OnUnsafeAttachValidValues
	{
		/*[in]*/ IDebugProcess2* pProcess;
		HRESULT retValue;
	};

	STDMETHOD(OnUnsafeAttach)(
		/*[in]*/ IDebugProcess2* pProcess)
	{
		VSL_DEFINE_MOCK_METHOD(OnUnsafeAttach)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGATTACHSECURITYCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBoundBreakpoint3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBOUNDBREAKPOINT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBOUNDBREAKPOINT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBoundBreakpoint3NotImpl :
	public IDebugBoundBreakpoint3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBoundBreakpoint3NotImpl)

public:

	typedef IDebugBoundBreakpoint3 Interface;

	STDMETHOD(SetTracepoint)(
		/*[in]*/ LPCOLESTR /*bpBstrTracepoint*/,
		/*[in]*/ BP_FLAGS /*bpFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBoundBreakpoint3MockImpl :
	public IDebugBoundBreakpoint3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBoundBreakpoint3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBoundBreakpoint3MockImpl)

	typedef IDebugBoundBreakpoint3 Interface;
	struct SetTracepointValidValues
	{
		/*[in]*/ LPCOLESTR bpBstrTracepoint;
		/*[in]*/ BP_FLAGS bpFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetTracepoint)(
		/*[in]*/ LPCOLESTR bpBstrTracepoint,
		/*[in]*/ BP_FLAGS bpFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetTracepoint)

		VSL_CHECK_VALIDVALUE_STRINGW(bpBstrTracepoint);

		VSL_CHECK_VALIDVALUE(bpFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBOUNDBREAKPOINT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBoundBreakpoint2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBOUNDBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBOUNDBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBoundBreakpoint2NotImpl :
	public IDebugBoundBreakpoint2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBoundBreakpoint2NotImpl)

public:

	typedef IDebugBoundBreakpoint2 Interface;

	STDMETHOD(GetPendingBreakpoint)(
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBreakpoint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[out]*/ BP_STATE* /*pState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHitCount)(
		/*[out]*/ DWORD* /*pdwHitCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBreakpointResolution)(
		/*[out]*/ IDebugBreakpointResolution2** /*ppBPResolution*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Enable)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHitCount)(
		/*[in]*/ DWORD /*dwHitCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCondition)(
		/*[in]*/ BP_CONDITION /*bpCondition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPassCount)(
		/*[in]*/ BP_PASSCOUNT /*bpPassCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Delete)()VSL_STDMETHOD_NOTIMPL
};

class IDebugBoundBreakpoint2MockImpl :
	public IDebugBoundBreakpoint2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBoundBreakpoint2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBoundBreakpoint2MockImpl)

	typedef IDebugBoundBreakpoint2 Interface;
	struct GetPendingBreakpointValidValues
	{
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBreakpoint;
		HRESULT retValue;
	};

	STDMETHOD(GetPendingBreakpoint)(
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBreakpoint)
	{
		VSL_DEFINE_MOCK_METHOD(GetPendingBreakpoint)

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBreakpoint);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[out]*/ BP_STATE* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[out]*/ BP_STATE* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHitCountValidValues
	{
		/*[out]*/ DWORD* pdwHitCount;
		HRESULT retValue;
	};

	STDMETHOD(GetHitCount)(
		/*[out]*/ DWORD* pdwHitCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetHitCount)

		VSL_SET_VALIDVALUE(pdwHitCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBreakpointResolutionValidValues
	{
		/*[out]*/ IDebugBreakpointResolution2** ppBPResolution;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpointResolution)(
		/*[out]*/ IDebugBreakpointResolution2** ppBPResolution)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpointResolution)

		VSL_SET_VALIDVALUE_INTERFACE(ppBPResolution);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(Enable)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(Enable)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHitCountValidValues
	{
		/*[in]*/ DWORD dwHitCount;
		HRESULT retValue;
	};

	STDMETHOD(SetHitCount)(
		/*[in]*/ DWORD dwHitCount)
	{
		VSL_DEFINE_MOCK_METHOD(SetHitCount)

		VSL_CHECK_VALIDVALUE(dwHitCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetConditionValidValues
	{
		/*[in]*/ BP_CONDITION bpCondition;
		HRESULT retValue;
	};

	STDMETHOD(SetCondition)(
		/*[in]*/ BP_CONDITION bpCondition)
	{
		VSL_DEFINE_MOCK_METHOD(SetCondition)

		VSL_CHECK_VALIDVALUE(bpCondition);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPassCountValidValues
	{
		/*[in]*/ BP_PASSCOUNT bpPassCount;
		HRESULT retValue;
	};

	STDMETHOD(SetPassCount)(
		/*[in]*/ BP_PASSCOUNT bpPassCount)
	{
		VSL_DEFINE_MOCK_METHOD(SetPassCount)

		VSL_CHECK_VALIDVALUE(bpPassCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Delete)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Delete)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBOUNDBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointErrorEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTERROREVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTERROREVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointErrorEvent2NotImpl :
	public IDebugBreakpointErrorEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointErrorEvent2NotImpl)

public:

	typedef IDebugBreakpointErrorEvent2 Interface;

	STDMETHOD(GetErrorBreakpoint)(
		/*[out]*/ IDebugErrorBreakpoint2** /*ppErrorBP*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointErrorEvent2MockImpl :
	public IDebugBreakpointErrorEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointErrorEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointErrorEvent2MockImpl)

	typedef IDebugBreakpointErrorEvent2 Interface;
	struct GetErrorBreakpointValidValues
	{
		/*[out]*/ IDebugErrorBreakpoint2** ppErrorBP;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorBreakpoint)(
		/*[out]*/ IDebugErrorBreakpoint2** ppErrorBP)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorBreakpoint)

		VSL_SET_VALIDVALUE_INTERFACE(ppErrorBP);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTERROREVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointChecksumRequest2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTCHECKSUMREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTCHECKSUMREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointChecksumRequest2NotImpl :
	public IDebugBreakpointChecksumRequest2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointChecksumRequest2NotImpl)

public:

	typedef IDebugBreakpointChecksumRequest2 Interface;

	STDMETHOD(GetChecksum)(
		/*[in]*/ REFGUID /*guidAlgorithm*/,
		/*[out]*/ CHECKSUM_DATA* /*pChecksumData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsChecksumEnabled)(
		/*[out]*/ BOOL* /*pfChecksumEnabled*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointChecksumRequest2MockImpl :
	public IDebugBreakpointChecksumRequest2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointChecksumRequest2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointChecksumRequest2MockImpl)

	typedef IDebugBreakpointChecksumRequest2 Interface;
	struct GetChecksumValidValues
	{
		/*[in]*/ REFGUID guidAlgorithm;
		/*[out]*/ CHECKSUM_DATA* pChecksumData;
		HRESULT retValue;
	};

	STDMETHOD(GetChecksum)(
		/*[in]*/ REFGUID guidAlgorithm,
		/*[out]*/ CHECKSUM_DATA* pChecksumData)
	{
		VSL_DEFINE_MOCK_METHOD(GetChecksum)

		VSL_CHECK_VALIDVALUE(guidAlgorithm);

		VSL_SET_VALIDVALUE(pChecksumData);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsChecksumEnabledValidValues
	{
		/*[out]*/ BOOL* pfChecksumEnabled;
		HRESULT retValue;
	};

	STDMETHOD(IsChecksumEnabled)(
		/*[out]*/ BOOL* pfChecksumEnabled)
	{
		VSL_DEFINE_MOCK_METHOD(IsChecksumEnabled)

		VSL_SET_VALIDVALUE(pfChecksumEnabled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTCHECKSUMREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointBoundEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTBOUNDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTBOUNDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointBoundEvent2NotImpl :
	public IDebugBreakpointBoundEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointBoundEvent2NotImpl)

public:

	typedef IDebugBreakpointBoundEvent2 Interface;

	STDMETHOD(GetPendingBreakpoint)(
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumBoundBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointBoundEvent2MockImpl :
	public IDebugBreakpointBoundEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointBoundEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointBoundEvent2MockImpl)

	typedef IDebugBreakpointBoundEvent2 Interface;
	struct GetPendingBreakpointValidValues
	{
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP;
		HRESULT retValue;
	};

	STDMETHOD(GetPendingBreakpoint)(
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP)
	{
		VSL_DEFINE_MOCK_METHOD(GetPendingBreakpoint)

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBP);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumBoundBreakpointsValidValues
	{
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumBoundBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumBoundBreakpoints)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTBOUNDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointEvent2NotImpl :
	public IDebugBreakpointEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointEvent2NotImpl)

public:

	typedef IDebugBreakpointEvent2 Interface;

	STDMETHOD(EnumBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointEvent2MockImpl :
	public IDebugBreakpointEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointEvent2MockImpl)

	typedef IDebugBreakpointEvent2 Interface;
	struct EnumBreakpointsValidValues
	{
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumBreakpoints)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointRequest2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointRequest2NotImpl :
	public IDebugBreakpointRequest2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointRequest2NotImpl)

public:

	typedef IDebugBreakpointRequest2 Interface;

	STDMETHOD(GetLocationType)(
		/*[out]*/ BP_LOCATION_TYPE* /*pBPLocationType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRequestInfo)(
		/*[in]*/ BPREQI_FIELDS /*dwFields*/,
		/*[out]*/ BP_REQUEST_INFO* /*pBPRequestInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointRequest2MockImpl :
	public IDebugBreakpointRequest2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointRequest2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointRequest2MockImpl)

	typedef IDebugBreakpointRequest2 Interface;
	struct GetLocationTypeValidValues
	{
		/*[out]*/ BP_LOCATION_TYPE* pBPLocationType;
		HRESULT retValue;
	};

	STDMETHOD(GetLocationType)(
		/*[out]*/ BP_LOCATION_TYPE* pBPLocationType)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocationType)

		VSL_SET_VALIDVALUE(pBPLocationType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRequestInfoValidValues
	{
		/*[in]*/ BPREQI_FIELDS dwFields;
		/*[out]*/ BP_REQUEST_INFO* pBPRequestInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRequestInfo)(
		/*[in]*/ BPREQI_FIELDS dwFields,
		/*[out]*/ BP_REQUEST_INFO* pBPRequestInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRequestInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pBPRequestInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointRequest3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTREQUEST3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTREQUEST3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointRequest3NotImpl :
	public IDebugBreakpointRequest3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointRequest3NotImpl)

public:

	typedef IDebugBreakpointRequest3 Interface;

	STDMETHOD(GetRequestInfo2)(
		/*[in]*/ BPREQI_FIELDS /*dwFields*/,
		/*[out]*/ BP_REQUEST_INFO2* /*bBPRequestInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLocationType)(
		/*[out]*/ BP_LOCATION_TYPE* /*pBPLocationType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRequestInfo)(
		/*[in]*/ BPREQI_FIELDS /*dwFields*/,
		/*[out]*/ BP_REQUEST_INFO* /*pBPRequestInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointRequest3MockImpl :
	public IDebugBreakpointRequest3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointRequest3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointRequest3MockImpl)

	typedef IDebugBreakpointRequest3 Interface;
	struct GetRequestInfo2ValidValues
	{
		/*[in]*/ BPREQI_FIELDS dwFields;
		/*[out]*/ BP_REQUEST_INFO2* bBPRequestInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRequestInfo2)(
		/*[in]*/ BPREQI_FIELDS dwFields,
		/*[out]*/ BP_REQUEST_INFO2* bBPRequestInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRequestInfo2)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(bBPRequestInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLocationTypeValidValues
	{
		/*[out]*/ BP_LOCATION_TYPE* pBPLocationType;
		HRESULT retValue;
	};

	STDMETHOD(GetLocationType)(
		/*[out]*/ BP_LOCATION_TYPE* pBPLocationType)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocationType)

		VSL_SET_VALIDVALUE(pBPLocationType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRequestInfoValidValues
	{
		/*[in]*/ BPREQI_FIELDS dwFields;
		/*[out]*/ BP_REQUEST_INFO* pBPRequestInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRequestInfo)(
		/*[in]*/ BPREQI_FIELDS dwFields,
		/*[out]*/ BP_REQUEST_INFO* pBPRequestInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRequestInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pBPRequestInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTREQUEST3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointUnboundEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTUNBOUNDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTUNBOUNDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointUnboundEvent2NotImpl :
	public IDebugBreakpointUnboundEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointUnboundEvent2NotImpl)

public:

	typedef IDebugBreakpointUnboundEvent2 Interface;

	STDMETHOD(GetBreakpoint)(
		/*[out]*/ IDebugBoundBreakpoint2** /*ppBP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReason)(
		/*[out]*/ BP_UNBOUND_REASON* /*pdwUnboundReason*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointUnboundEvent2MockImpl :
	public IDebugBreakpointUnboundEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointUnboundEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointUnboundEvent2MockImpl)

	typedef IDebugBreakpointUnboundEvent2 Interface;
	struct GetBreakpointValidValues
	{
		/*[out]*/ IDebugBoundBreakpoint2** ppBP;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpoint)(
		/*[out]*/ IDebugBoundBreakpoint2** ppBP)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpoint)

		VSL_SET_VALIDVALUE_INTERFACE(ppBP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReasonValidValues
	{
		/*[out]*/ BP_UNBOUND_REASON* pdwUnboundReason;
		HRESULT retValue;
	};

	STDMETHOD(GetReason)(
		/*[out]*/ BP_UNBOUND_REASON* pdwUnboundReason)
	{
		VSL_DEFINE_MOCK_METHOD(GetReason)

		VSL_SET_VALIDVALUE(pdwUnboundReason);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTUNBOUNDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugBreakpointResolution2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGBREAKPOINTRESOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGBREAKPOINTRESOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugBreakpointResolution2NotImpl :
	public IDebugBreakpointResolution2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointResolution2NotImpl)

public:

	typedef IDebugBreakpointResolution2 Interface;

	STDMETHOD(GetBreakpointType)(
		/*[out]*/ BP_TYPE* /*pBPType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetResolutionInfo)(
		/*[in]*/ BPRESI_FIELDS /*dwFields*/,
		/*[out]*/ BP_RESOLUTION_INFO* /*pBPResolutionInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugBreakpointResolution2MockImpl :
	public IDebugBreakpointResolution2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugBreakpointResolution2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugBreakpointResolution2MockImpl)

	typedef IDebugBreakpointResolution2 Interface;
	struct GetBreakpointTypeValidValues
	{
		/*[out]*/ BP_TYPE* pBPType;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpointType)(
		/*[out]*/ BP_TYPE* pBPType)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpointType)

		VSL_SET_VALIDVALUE(pBPType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetResolutionInfoValidValues
	{
		/*[in]*/ BPRESI_FIELDS dwFields;
		/*[out]*/ BP_RESOLUTION_INFO* pBPResolutionInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetResolutionInfo)(
		/*[in]*/ BPRESI_FIELDS dwFields,
		/*[out]*/ BP_RESOLUTION_INFO* pBPResolutionInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetResolutionInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pBPResolutionInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGBREAKPOINTRESOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCanStopEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCANSTOPEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCANSTOPEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCanStopEvent2NotImpl :
	public IDebugCanStopEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCanStopEvent2NotImpl)

public:

	typedef IDebugCanStopEvent2 Interface;

	STDMETHOD(GetReason)(
		/*[out]*/ CANSTOP_REASON* /*pcr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanStop)(
		/*[in]*/ BOOL /*fCanStop*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** /*ppDocCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeContext)(
		/*[out]*/ IDebugCodeContext2** /*ppCodeContext*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCanStopEvent2MockImpl :
	public IDebugCanStopEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCanStopEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCanStopEvent2MockImpl)

	typedef IDebugCanStopEvent2 Interface;
	struct GetReasonValidValues
	{
		/*[out]*/ CANSTOP_REASON* pcr;
		HRESULT retValue;
	};

	STDMETHOD(GetReason)(
		/*[out]*/ CANSTOP_REASON* pcr)
	{
		VSL_DEFINE_MOCK_METHOD(GetReason)

		VSL_SET_VALIDVALUE(pcr);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanStopValidValues
	{
		/*[in]*/ BOOL fCanStop;
		HRESULT retValue;
	};

	STDMETHOD(CanStop)(
		/*[in]*/ BOOL fCanStop)
	{
		VSL_DEFINE_MOCK_METHOD(CanStop)

		VSL_CHECK_VALIDVALUE(fCanStop);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentContextValidValues
	{
		/*[out]*/ IDebugDocumentContext2** ppDocCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** ppDocCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppDocCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeContextValidValues
	{
		/*[out]*/ IDebugCodeContext2** ppCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeContext)(
		/*[out]*/ IDebugCodeContext2** ppCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCANSTOPEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCodeContext3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCODECONTEXT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCODECONTEXT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCodeContext3NotImpl :
	public IDebugCodeContext3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCodeContext3NotImpl)

public:

	typedef IDebugCodeContext3 Interface;

	STDMETHOD(GetModule)(
		/*[out]*/ IDebugModule2** /*ppModule*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcess)(
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** /*ppSrcCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* /*pbstrLanguage*/,
		/*[in,out,ptr]*/ GUID* /*pguidLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ CONTEXT_INFO_FIELDS /*dwFields*/,
		/*[out]*/ CONTEXT_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ UINT64 /*dwCount*/,
		/*[out]*/ IDebugMemoryContext2** /*ppMemCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Subtract)(
		/*[in]*/ UINT64 /*dwCount*/,
		/*[out]*/ IDebugMemoryContext2** /*ppMemCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Compare)(
		/*[in]*/ CONTEXT_COMPARE /*compare*/,
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** /*rgpMemoryContextSet*/,
		/*[in]*/ DWORD /*dwMemoryContextSetLen*/,
		/*[out]*/ DWORD* /*pdwMemoryContext*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCodeContext3MockImpl :
	public IDebugCodeContext3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCodeContext3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCodeContext3MockImpl)

	typedef IDebugCodeContext3 Interface;
	struct GetModuleValidValues
	{
		/*[out]*/ IDebugModule2** ppModule;
		HRESULT retValue;
	};

	STDMETHOD(GetModule)(
		/*[out]*/ IDebugModule2** ppModule)
	{
		VSL_DEFINE_MOCK_METHOD(GetModule)

		VSL_SET_VALIDVALUE_INTERFACE(ppModule);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessValidValues
	{
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(GetProcess)(
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcess)

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentContextValidValues
	{
		/*[out]*/ IDebugDocumentContext2** ppSrcCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** ppSrcCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppSrcCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageInfoValidValues
	{
		/*[in,out,ptr]*/ BSTR* pbstrLanguage;
		/*[in,out,ptr]*/ GUID* pguidLanguage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* pbstrLanguage,
		/*[in,out,ptr]*/ GUID* pguidLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrLanguage);

		VSL_SET_VALIDVALUE(pguidLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ CONTEXT_INFO_FIELDS dwFields;
		/*[out]*/ CONTEXT_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ CONTEXT_INFO_FIELDS dwFields,
		/*[out]*/ CONTEXT_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ UINT64 dwCount;
		/*[out]*/ IDebugMemoryContext2** ppMemCxt;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ UINT64 dwCount,
		/*[out]*/ IDebugMemoryContext2** ppMemCxt)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppMemCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct SubtractValidValues
	{
		/*[in]*/ UINT64 dwCount;
		/*[out]*/ IDebugMemoryContext2** ppMemCxt;
		HRESULT retValue;
	};

	STDMETHOD(Subtract)(
		/*[in]*/ UINT64 dwCount,
		/*[out]*/ IDebugMemoryContext2** ppMemCxt)
	{
		VSL_DEFINE_MOCK_METHOD(Subtract)

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppMemCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct CompareValidValues
	{
		/*[in]*/ CONTEXT_COMPARE compare;
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** rgpMemoryContextSet;
		/*[in]*/ DWORD dwMemoryContextSetLen;
		/*[out]*/ DWORD* pdwMemoryContext;
		HRESULT retValue;
	};

	STDMETHOD(Compare)(
		/*[in]*/ CONTEXT_COMPARE compare,
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** rgpMemoryContextSet,
		/*[in]*/ DWORD dwMemoryContextSetLen,
		/*[out]*/ DWORD* pdwMemoryContext)
	{
		VSL_DEFINE_MOCK_METHOD(Compare)

		VSL_CHECK_VALIDVALUE(compare);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpMemoryContextSet, dwMemoryContextSetLen, validValues.dwMemoryContextSetLen);

		VSL_CHECK_VALIDVALUE(dwMemoryContextSetLen);

		VSL_SET_VALIDVALUE(pdwMemoryContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCODECONTEXT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCodeContext2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCODECONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCODECONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCodeContext2NotImpl :
	public IDebugCodeContext2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCodeContext2NotImpl)

public:

	typedef IDebugCodeContext2 Interface;

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** /*ppSrcCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* /*pbstrLanguage*/,
		/*[in,out,ptr]*/ GUID* /*pguidLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ CONTEXT_INFO_FIELDS /*dwFields*/,
		/*[out]*/ CONTEXT_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ UINT64 /*dwCount*/,
		/*[out]*/ IDebugMemoryContext2** /*ppMemCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Subtract)(
		/*[in]*/ UINT64 /*dwCount*/,
		/*[out]*/ IDebugMemoryContext2** /*ppMemCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Compare)(
		/*[in]*/ CONTEXT_COMPARE /*compare*/,
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** /*rgpMemoryContextSet*/,
		/*[in]*/ DWORD /*dwMemoryContextSetLen*/,
		/*[out]*/ DWORD* /*pdwMemoryContext*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCodeContext2MockImpl :
	public IDebugCodeContext2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCodeContext2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCodeContext2MockImpl)

	typedef IDebugCodeContext2 Interface;
	struct GetDocumentContextValidValues
	{
		/*[out]*/ IDebugDocumentContext2** ppSrcCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** ppSrcCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppSrcCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageInfoValidValues
	{
		/*[in,out,ptr]*/ BSTR* pbstrLanguage;
		/*[in,out,ptr]*/ GUID* pguidLanguage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* pbstrLanguage,
		/*[in,out,ptr]*/ GUID* pguidLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrLanguage);

		VSL_SET_VALIDVALUE(pguidLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ CONTEXT_INFO_FIELDS dwFields;
		/*[out]*/ CONTEXT_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ CONTEXT_INFO_FIELDS dwFields,
		/*[out]*/ CONTEXT_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ UINT64 dwCount;
		/*[out]*/ IDebugMemoryContext2** ppMemCxt;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ UINT64 dwCount,
		/*[out]*/ IDebugMemoryContext2** ppMemCxt)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppMemCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct SubtractValidValues
	{
		/*[in]*/ UINT64 dwCount;
		/*[out]*/ IDebugMemoryContext2** ppMemCxt;
		HRESULT retValue;
	};

	STDMETHOD(Subtract)(
		/*[in]*/ UINT64 dwCount,
		/*[out]*/ IDebugMemoryContext2** ppMemCxt)
	{
		VSL_DEFINE_MOCK_METHOD(Subtract)

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppMemCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct CompareValidValues
	{
		/*[in]*/ CONTEXT_COMPARE compare;
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** rgpMemoryContextSet;
		/*[in]*/ DWORD dwMemoryContextSetLen;
		/*[out]*/ DWORD* pdwMemoryContext;
		HRESULT retValue;
	};

	STDMETHOD(Compare)(
		/*[in]*/ CONTEXT_COMPARE compare,
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** rgpMemoryContextSet,
		/*[in]*/ DWORD dwMemoryContextSetLen,
		/*[out]*/ DWORD* pdwMemoryContext)
	{
		VSL_DEFINE_MOCK_METHOD(Compare)

		VSL_CHECK_VALIDVALUE(compare);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpMemoryContextSet, dwMemoryContextSetLen, validValues.dwMemoryContextSetLen);

		VSL_CHECK_VALIDVALUE(dwMemoryContextSetLen);

		VSL_SET_VALIDVALUE(pdwMemoryContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCODECONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCOMPlusProgramNode2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCOMPLUSPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCOMPLUSPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCOMPlusProgramNode2NotImpl :
	public IDebugCOMPlusProgramNode2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCOMPlusProgramNode2NotImpl)

public:

	typedef IDebugCOMPlusProgramNode2 Interface;

	STDMETHOD(GetAppDomainId)(
		/*[out]*/ ULONG32* /*pul32Id*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCOMPlusProgramNode2MockImpl :
	public IDebugCOMPlusProgramNode2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCOMPlusProgramNode2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCOMPlusProgramNode2MockImpl)

	typedef IDebugCOMPlusProgramNode2 Interface;
	struct GetAppDomainIdValidValues
	{
		/*[out]*/ ULONG32* pul32Id;
		HRESULT retValue;
	};

	STDMETHOD(GetAppDomainId)(
		/*[out]*/ ULONG32* pul32Id)
	{
		VSL_DEFINE_MOCK_METHOD(GetAppDomainId)

		VSL_SET_VALIDVALUE(pul32Id);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCOMPLUSPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCoreServer2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCORESERVER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCORESERVER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCoreServer2NotImpl :
	public IDebugCoreServer2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCoreServer2NotImpl)

public:

	typedef IDebugCoreServer2 Interface;

	STDMETHOD(GetMachineInfo)(
		/*[in]*/ MACHINE_INFO_FIELDS /*Fields*/,
		/*[out]*/ MACHINE_INFO* /*pMachineInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMachineName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplier)(
		/*[in]*/ REFGUID /*guidPortSupplier*/,
		/*[out]*/ IDebugPortSupplier2** /*ppPortSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID /*guidPort*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPortSuppliers)(
		/*[out]*/ IEnumDebugPortSuppliers2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMachineUtilities_V7)(
		/*[out]*/ IDebugMDMUtil2_V7** /*ppUtil*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCoreServer2MockImpl :
	public IDebugCoreServer2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCoreServer2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCoreServer2MockImpl)

	typedef IDebugCoreServer2 Interface;
	struct GetMachineInfoValidValues
	{
		/*[in]*/ MACHINE_INFO_FIELDS Fields;
		/*[out]*/ MACHINE_INFO* pMachineInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetMachineInfo)(
		/*[in]*/ MACHINE_INFO_FIELDS Fields,
		/*[out]*/ MACHINE_INFO* pMachineInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetMachineInfo)

		VSL_CHECK_VALIDVALUE(Fields);

		VSL_SET_VALIDVALUE(pMachineInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMachineNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetMachineName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetMachineName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierValidValues
	{
		/*[in]*/ REFGUID guidPortSupplier;
		/*[out]*/ IDebugPortSupplier2** ppPortSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplier)(
		/*[in]*/ REFGUID guidPortSupplier,
		/*[out]*/ IDebugPortSupplier2** ppPortSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplier)

		VSL_CHECK_VALIDVALUE(guidPortSupplier);

		VSL_SET_VALIDVALUE_INTERFACE(ppPortSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortValidValues
	{
		/*[in]*/ REFGUID guidPort;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID guidPort,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPort)

		VSL_CHECK_VALIDVALUE(guidPort);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortsValidValues
	{
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPorts)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortSuppliersValidValues
	{
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPortSuppliers)(
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPortSuppliers)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMachineUtilities_V7ValidValues
	{
		/*[out]*/ IDebugMDMUtil2_V7** ppUtil;
		HRESULT retValue;
	};

	STDMETHOD(GetMachineUtilities_V7)(
		/*[out]*/ IDebugMDMUtil2_V7** ppUtil)
	{
		VSL_DEFINE_MOCK_METHOD(GetMachineUtilities_V7)

		VSL_SET_VALIDVALUE_INTERFACE(ppUtil);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCORESERVER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDefaultPort2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDEFAULTPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDEFAULTPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDefaultPort2NotImpl :
	public IDebugDefaultPort2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDefaultPort2NotImpl)

public:

	typedef IDebugDefaultPort2 Interface;

	STDMETHOD(GetPortNotify)(
		/*[out]*/ IDebugPortNotify2** /*ppPortNotify*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetServer)(
		/*[out]*/ IDebugCoreServer3** /*ppServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryIsLocal)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortId)(
		/*[out]*/ GUID* /*pguidPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortRequest)(
		/*[out]*/ IDebugPortRequest2** /*ppRequest*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplier)(
		/*[out]*/ IDebugPortSupplier2** /*ppSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcess)(
		/*[in]*/ AD_PROCESS_ID /*ProcessId*/,
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDefaultPort2MockImpl :
	public IDebugDefaultPort2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDefaultPort2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDefaultPort2MockImpl)

	typedef IDebugDefaultPort2 Interface;
	struct GetPortNotifyValidValues
	{
		/*[out]*/ IDebugPortNotify2** ppPortNotify;
		HRESULT retValue;
	};

	STDMETHOD(GetPortNotify)(
		/*[out]*/ IDebugPortNotify2** ppPortNotify)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortNotify)

		VSL_SET_VALIDVALUE_INTERFACE(ppPortNotify);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetServerValidValues
	{
		/*[out]*/ IDebugCoreServer3** ppServer;
		HRESULT retValue;
	};

	STDMETHOD(GetServer)(
		/*[out]*/ IDebugCoreServer3** ppServer)
	{
		VSL_DEFINE_MOCK_METHOD(GetServer)

		VSL_SET_VALIDVALUE_INTERFACE(ppServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryIsLocalValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(QueryIsLocal)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(QueryIsLocal)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetPortName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortIdValidValues
	{
		/*[out]*/ GUID* pguidPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPortId)(
		/*[out]*/ GUID* pguidPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortId)

		VSL_SET_VALIDVALUE(pguidPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortRequestValidValues
	{
		/*[out]*/ IDebugPortRequest2** ppRequest;
		HRESULT retValue;
	};

	STDMETHOD(GetPortRequest)(
		/*[out]*/ IDebugPortRequest2** ppRequest)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortRequest)

		VSL_SET_VALIDVALUE_INTERFACE(ppRequest);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierValidValues
	{
		/*[out]*/ IDebugPortSupplier2** ppSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplier)(
		/*[out]*/ IDebugPortSupplier2** ppSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplier)

		VSL_SET_VALIDVALUE_INTERFACE(ppSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessValidValues
	{
		/*[in]*/ AD_PROCESS_ID ProcessId;
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(GetProcess)(
		/*[in]*/ AD_PROCESS_ID ProcessId,
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcess)

		VSL_CHECK_VALIDVALUE(ProcessId);

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProcessesValidValues
	{
		/*[out]*/ IEnumDebugProcesses2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProcesses)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDEFAULTPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCustomViewer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCUSTOMVIEWER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCUSTOMVIEWER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCustomViewerNotImpl :
	public IDebugCustomViewer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCustomViewerNotImpl)

public:

	typedef IDebugCustomViewer Interface;

	STDMETHOD(DisplayValue)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ DWORD /*dwID*/,
		/*[in]*/ IUnknown* /*pHostServices*/,
		/*[in]*/ IDebugProperty3* /*pDebugProperty*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCustomViewerMockImpl :
	public IDebugCustomViewer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCustomViewerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCustomViewerMockImpl)

	typedef IDebugCustomViewer Interface;
	struct DisplayValueValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ DWORD dwID;
		/*[in]*/ IUnknown* pHostServices;
		/*[in]*/ IDebugProperty3* pDebugProperty;
		HRESULT retValue;
	};

	STDMETHOD(DisplayValue)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ DWORD dwID,
		/*[in]*/ IUnknown* pHostServices,
		/*[in]*/ IDebugProperty3* pDebugProperty)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayValue)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(dwID);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHostServices);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDebugProperty);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCUSTOMVIEWER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugCoreServer3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGCORESERVER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGCORESERVER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugCoreServer3NotImpl :
	public IDebugCoreServer3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCoreServer3NotImpl)

public:

	typedef IDebugCoreServer3 Interface;

	STDMETHOD(GetServerName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetServerFriendlyName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableAutoAttach)(
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[in,ptr]*/ LPCOLESTR /*pszStartPageUrl*/,
		/*[out]*/ BSTR* /*pbstrSessionId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiagnoseWebDebuggingError)(
		/*[in,ptr]*/ LPCWSTR /*pszUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstanceInServer)(
		/*[in,ptr]*/ LPCWSTR /*szDll*/,
		/*[in]*/ WORD /*wLangId*/,
		/*[in]*/ REFCLSID /*clsidObject*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryIsLocal)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetConnectionProtocol)(
		/*[out]*/ CONNECTION_PROTOCOL* /*pProtocol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisableAutoAttach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMachineInfo)(
		/*[in]*/ MACHINE_INFO_FIELDS /*Fields*/,
		/*[out]*/ MACHINE_INFO* /*pMachineInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMachineName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplier)(
		/*[in]*/ REFGUID /*guidPortSupplier*/,
		/*[out]*/ IDebugPortSupplier2** /*ppPortSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID /*guidPort*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPortSuppliers)(
		/*[out]*/ IEnumDebugPortSuppliers2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMachineUtilities_V7)(
		/*[out]*/ IDebugMDMUtil2_V7** /*ppUtil*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugCoreServer3MockImpl :
	public IDebugCoreServer3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugCoreServer3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugCoreServer3MockImpl)

	typedef IDebugCoreServer3 Interface;
	struct GetServerNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetServerName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetServerName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetServerFriendlyNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetServerFriendlyName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetServerFriendlyName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableAutoAttachValidValues
	{
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[in,ptr]*/ LPCOLESTR pszStartPageUrl;
		/*[out]*/ BSTR* pbstrSessionId;
		HRESULT retValue;
	};

	STDMETHOD(EnableAutoAttach)(
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[in,ptr]*/ LPCOLESTR pszStartPageUrl,
		/*[out]*/ BSTR* pbstrSessionId)
	{
		VSL_DEFINE_MOCK_METHOD(EnableAutoAttach)

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_CHECK_VALIDVALUE_STRINGW(pszStartPageUrl);

		VSL_SET_VALIDVALUE_BSTR(pbstrSessionId);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiagnoseWebDebuggingErrorValidValues
	{
		/*[in,ptr]*/ LPCWSTR pszUrl;
		HRESULT retValue;
	};

	STDMETHOD(DiagnoseWebDebuggingError)(
		/*[in,ptr]*/ LPCWSTR pszUrl)
	{
		VSL_DEFINE_MOCK_METHOD(DiagnoseWebDebuggingError)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceInServerValidValues
	{
		/*[in,ptr]*/ LPCWSTR szDll;
		/*[in]*/ WORD wLangId;
		/*[in]*/ REFCLSID clsidObject;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstanceInServer)(
		/*[in,ptr]*/ LPCWSTR szDll,
		/*[in]*/ WORD wLangId,
		/*[in]*/ REFCLSID clsidObject,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstanceInServer)

		VSL_CHECK_VALIDVALUE_STRINGW(szDll);

		VSL_CHECK_VALIDVALUE(wLangId);

		VSL_CHECK_VALIDVALUE(clsidObject);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryIsLocalValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(QueryIsLocal)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(QueryIsLocal)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetConnectionProtocolValidValues
	{
		/*[out]*/ CONNECTION_PROTOCOL* pProtocol;
		HRESULT retValue;
	};

	STDMETHOD(GetConnectionProtocol)(
		/*[out]*/ CONNECTION_PROTOCOL* pProtocol)
	{
		VSL_DEFINE_MOCK_METHOD(GetConnectionProtocol)

		VSL_SET_VALIDVALUE(pProtocol);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisableAutoAttachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DisableAutoAttach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DisableAutoAttach)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMachineInfoValidValues
	{
		/*[in]*/ MACHINE_INFO_FIELDS Fields;
		/*[out]*/ MACHINE_INFO* pMachineInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetMachineInfo)(
		/*[in]*/ MACHINE_INFO_FIELDS Fields,
		/*[out]*/ MACHINE_INFO* pMachineInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetMachineInfo)

		VSL_CHECK_VALIDVALUE(Fields);

		VSL_SET_VALIDVALUE(pMachineInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMachineNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetMachineName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetMachineName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierValidValues
	{
		/*[in]*/ REFGUID guidPortSupplier;
		/*[out]*/ IDebugPortSupplier2** ppPortSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplier)(
		/*[in]*/ REFGUID guidPortSupplier,
		/*[out]*/ IDebugPortSupplier2** ppPortSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplier)

		VSL_CHECK_VALIDVALUE(guidPortSupplier);

		VSL_SET_VALIDVALUE_INTERFACE(ppPortSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortValidValues
	{
		/*[in]*/ REFGUID guidPort;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID guidPort,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPort)

		VSL_CHECK_VALIDVALUE(guidPort);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortsValidValues
	{
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPorts)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortSuppliersValidValues
	{
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPortSuppliers)(
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPortSuppliers)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMachineUtilities_V7ValidValues
	{
		/*[out]*/ IDebugMDMUtil2_V7** ppUtil;
		HRESULT retValue;
	};

	STDMETHOD(GetMachineUtilities_V7)(
		/*[out]*/ IDebugMDMUtil2_V7** ppUtil)
	{
		VSL_DEFINE_MOCK_METHOD(GetMachineUtilities_V7)

		VSL_SET_VALIDVALUE_INTERFACE(ppUtil);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGCORESERVER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDataGrid.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDATAGRID_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDATAGRID_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDataGridNotImpl :
	public IDebugDataGrid
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDataGridNotImpl)

public:

	typedef IDebugDataGrid Interface;

	STDMETHOD(GetGridInfo)(
		/*[out]*/ ULONG* /*pX*/,
		/*[out]*/ ULONG* /*pY*/,
		/*[out]*/ BSTR* /*bpstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGridPropertyInfo)(
		/*[in]*/ ULONG /*x*/,
		/*[in]*/ ULONG /*y*/,
		/*[in]*/ ULONG /*celtX*/,
		/*[in]*/ ULONG /*celtY*/,
		/*[in]*/ ULONG /*celtXtimesY*/,
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[out,size_is(celtXtimesY),length_is(*pceltFetched)]*/ DEBUG_PROPERTY_INFO* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDataGridMockImpl :
	public IDebugDataGrid,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDataGridMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDataGridMockImpl)

	typedef IDebugDataGrid Interface;
	struct GetGridInfoValidValues
	{
		/*[out]*/ ULONG* pX;
		/*[out]*/ ULONG* pY;
		/*[out]*/ BSTR* bpstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(GetGridInfo)(
		/*[out]*/ ULONG* pX,
		/*[out]*/ ULONG* pY,
		/*[out]*/ BSTR* bpstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(GetGridInfo)

		VSL_SET_VALIDVALUE(pX);

		VSL_SET_VALIDVALUE(pY);

		VSL_SET_VALIDVALUE_BSTR(bpstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGridPropertyInfoValidValues
	{
		/*[in]*/ ULONG x;
		/*[in]*/ ULONG y;
		/*[in]*/ ULONG celtX;
		/*[in]*/ ULONG celtY;
		/*[in]*/ ULONG celtXtimesY;
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[out,size_is(celtXtimesY),length_is(*pceltFetched)]*/ DEBUG_PROPERTY_INFO* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetGridPropertyInfo)(
		/*[in]*/ ULONG x,
		/*[in]*/ ULONG y,
		/*[in]*/ ULONG celtX,
		/*[in]*/ ULONG celtY,
		/*[in]*/ ULONG celtXtimesY,
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[out,size_is(celtXtimesY),length_is(*pceltFetched)]*/ DEBUG_PROPERTY_INFO* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetGridPropertyInfo)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(celtX);

		VSL_CHECK_VALIDVALUE(celtY);

		VSL_CHECK_VALIDVALUE(celtXtimesY);

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celtXtimesY*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDATAGRID_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDisassemblyStream2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDISASSEMBLYSTREAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDISASSEMBLYSTREAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDisassemblyStream2NotImpl :
	public IDebugDisassemblyStream2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDisassemblyStream2NotImpl)

public:

	typedef IDebugDisassemblyStream2 Interface;

	STDMETHOD(Read)(
		/*[in]*/ DWORD /*dwInstructions*/,
		/*[in]*/ DISASSEMBLY_STREAM_FIELDS /*dwFields*/,
		/*[out]*/ DWORD* /*pdwInstructionsRead*/,
		/*[out,size_is(dwInstructions),length_is(*pdwInstructionsRead)]*/ DisassemblyData* /*prgDisassembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Seek)(
		/*[in]*/ SEEK_START /*dwSeekStart*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/,
		/*[in]*/ UINT64 /*uCodeLocationId*/,
		/*[in]*/ INT64 /*iInstructions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeLocationId)(
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/,
		/*[out]*/ UINT64* /*puCodeLocationId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeContext)(
		/*[in]*/ UINT64 /*uCodeLocationId*/,
		/*[out]*/ IDebugCodeContext2** /*ppCodeContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentLocation)(
		/*[out]*/ UINT64* /*puCodeLocationId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocument)(
		/*[in]*/ BSTR /*bstrDocumentUrl*/,
		/*[out]*/ IDebugDocument2** /*ppDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetScope)(
		/*[out]*/ DISASSEMBLY_STREAM_SCOPE* /*pdwScope*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ UINT64* /*pnSize*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDisassemblyStream2MockImpl :
	public IDebugDisassemblyStream2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDisassemblyStream2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDisassemblyStream2MockImpl)

	typedef IDebugDisassemblyStream2 Interface;
	struct ReadValidValues
	{
		/*[in]*/ DWORD dwInstructions;
		/*[in]*/ DISASSEMBLY_STREAM_FIELDS dwFields;
		/*[out]*/ DWORD* pdwInstructionsRead;
		/*[out,size_is(dwInstructions),length_is(*pdwInstructionsRead)]*/ DisassemblyData* prgDisassembly;
		HRESULT retValue;
	};

	STDMETHOD(Read)(
		/*[in]*/ DWORD dwInstructions,
		/*[in]*/ DISASSEMBLY_STREAM_FIELDS dwFields,
		/*[out]*/ DWORD* pdwInstructionsRead,
		/*[out,size_is(dwInstructions),length_is(*pdwInstructionsRead)]*/ DisassemblyData* prgDisassembly)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_CHECK_VALIDVALUE(dwInstructions);

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pdwInstructionsRead);

		VSL_SET_VALIDVALUE_MEMCPY(prgDisassembly, dwInstructions*sizeof(prgDisassembly[0]), *(validValues.pdwInstructionsRead)*sizeof(validValues.prgDisassembly[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct SeekValidValues
	{
		/*[in]*/ SEEK_START dwSeekStart;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		/*[in]*/ UINT64 uCodeLocationId;
		/*[in]*/ INT64 iInstructions;
		HRESULT retValue;
	};

	STDMETHOD(Seek)(
		/*[in]*/ SEEK_START dwSeekStart,
		/*[in]*/ IDebugCodeContext2* pCodeContext,
		/*[in]*/ UINT64 uCodeLocationId,
		/*[in]*/ INT64 iInstructions)
	{
		VSL_DEFINE_MOCK_METHOD(Seek)

		VSL_CHECK_VALIDVALUE(dwSeekStart);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_CHECK_VALIDVALUE(uCodeLocationId);

		VSL_CHECK_VALIDVALUE(iInstructions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeLocationIdValidValues
	{
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		/*[out]*/ UINT64* puCodeLocationId;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeLocationId)(
		/*[in]*/ IDebugCodeContext2* pCodeContext,
		/*[out]*/ UINT64* puCodeLocationId)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeLocationId)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_SET_VALIDVALUE(puCodeLocationId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeContextValidValues
	{
		/*[in]*/ UINT64 uCodeLocationId;
		/*[out]*/ IDebugCodeContext2** ppCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeContext)(
		/*[in]*/ UINT64 uCodeLocationId,
		/*[out]*/ IDebugCodeContext2** ppCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeContext)

		VSL_CHECK_VALIDVALUE(uCodeLocationId);

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentLocationValidValues
	{
		/*[out]*/ UINT64* puCodeLocationId;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentLocation)(
		/*[out]*/ UINT64* puCodeLocationId)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentLocation)

		VSL_SET_VALIDVALUE(puCodeLocationId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentValidValues
	{
		/*[in]*/ BSTR bstrDocumentUrl;
		/*[out]*/ IDebugDocument2** ppDocument;
		HRESULT retValue;
	};

	STDMETHOD(GetDocument)(
		/*[in]*/ BSTR bstrDocumentUrl,
		/*[out]*/ IDebugDocument2** ppDocument)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocument)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDocumentUrl);

		VSL_SET_VALIDVALUE_INTERFACE(ppDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetScopeValidValues
	{
		/*[out]*/ DISASSEMBLY_STREAM_SCOPE* pdwScope;
		HRESULT retValue;
	};

	STDMETHOD(GetScope)(
		/*[out]*/ DISASSEMBLY_STREAM_SCOPE* pdwScope)
	{
		VSL_DEFINE_MOCK_METHOD(GetScope)

		VSL_SET_VALIDVALUE(pdwScope);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ UINT64* pnSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ UINT64* pnSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pnSize);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDISASSEMBLYSTREAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocument2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocument2NotImpl :
	public IDebugDocument2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocument2NotImpl)

public:

	typedef IDebugDocument2 Interface;

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE /*gnType*/,
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentClassId)(
		/*[out]*/ CLSID* /*pclsid*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocument2MockImpl :
	public IDebugDocument2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocument2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocument2MockImpl)

	typedef IDebugDocument2 Interface;
	struct GetNameValidValues
	{
		/*[in]*/ GETNAME_TYPE gnType;
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE gnType,
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE(gnType);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentClassIdValidValues
	{
		/*[out]*/ CLSID* pclsid;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentClassId)(
		/*[out]*/ CLSID* pclsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentClassId)

		VSL_SET_VALIDVALUE(pclsid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocumentChecksum2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENTCHECKSUM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENTCHECKSUM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocumentChecksum2NotImpl :
	public IDebugDocumentChecksum2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentChecksum2NotImpl)

public:

	typedef IDebugDocumentChecksum2 Interface;

	STDMETHOD(GetChecksumAndAlgorithmId)(
		/*[out]*/ GUID* /*pRetVal*/,
		/*[in]*/ ULONG /*cMaxBytes*/,
		/*[out,length_is(*pcNumBytes),size_is(cMaxBytes)]*/ BYTE* /*pChecksum*/,
		/*[out]*/ ULONG* /*pcNumBytes*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocumentChecksum2MockImpl :
	public IDebugDocumentChecksum2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentChecksum2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocumentChecksum2MockImpl)

	typedef IDebugDocumentChecksum2 Interface;
	struct GetChecksumAndAlgorithmIdValidValues
	{
		/*[out]*/ GUID* pRetVal;
		/*[in]*/ ULONG cMaxBytes;
		/*[out,length_is(*pcNumBytes),size_is(cMaxBytes)]*/ BYTE* pChecksum;
		/*[out]*/ ULONG* pcNumBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetChecksumAndAlgorithmId)(
		/*[out]*/ GUID* pRetVal,
		/*[in]*/ ULONG cMaxBytes,
		/*[out,length_is(*pcNumBytes),size_is(cMaxBytes)]*/ BYTE* pChecksum,
		/*[out]*/ ULONG* pcNumBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetChecksumAndAlgorithmId)

		VSL_SET_VALIDVALUE(pRetVal);

		VSL_CHECK_VALIDVALUE(cMaxBytes);

		VSL_SET_VALIDVALUE_MEMCPY(pChecksum, cMaxBytes*sizeof(pChecksum[0]), *(validValues.pcNumBytes)*sizeof(validValues.pChecksum[0]));

		VSL_SET_VALIDVALUE(pcNumBytes);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENTCHECKSUM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocumentContext2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENTCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENTCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocumentContext2NotImpl :
	public IDebugDocumentContext2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentContext2NotImpl)

public:

	typedef IDebugDocumentContext2 Interface;

	STDMETHOD(GetDocument)(
		/*[out]*/ IDebugDocument2** /*ppDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE /*gnType*/,
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodeContexts)(
		/*[out]*/ IEnumDebugCodeContexts2** /*ppEnumCodeCxts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* /*pbstrLanguage*/,
		/*[in,out,ptr]*/ GUID* /*pguidLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStatementRange)(
		/*[in,out,ptr]*/ TEXT_POSITION* /*pBegPosition*/,
		/*[in,out,ptr]*/ TEXT_POSITION* /*pEndPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSourceRange)(
		/*[in,out,ptr]*/ TEXT_POSITION* /*pBegPosition*/,
		/*[in,out,ptr]*/ TEXT_POSITION* /*pEndPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Compare)(
		/*[in]*/ DOCCONTEXT_COMPARE /*compare*/,
		/*[in,size_is(dwDocContextSetLen),length_is(dwDocContextSetLen)]*/ IDebugDocumentContext2** /*rgpDocContextSet*/,
		/*[in]*/ DWORD /*dwDocContextSetLen*/,
		/*[out]*/ DWORD* /*pdwDocContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Seek)(
		/*[in]*/ int /*nCount*/,
		/*[out]*/ IDebugDocumentContext2** /*ppDocContext*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocumentContext2MockImpl :
	public IDebugDocumentContext2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentContext2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocumentContext2MockImpl)

	typedef IDebugDocumentContext2 Interface;
	struct GetDocumentValidValues
	{
		/*[out]*/ IDebugDocument2** ppDocument;
		HRESULT retValue;
	};

	STDMETHOD(GetDocument)(
		/*[out]*/ IDebugDocument2** ppDocument)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocument)

		VSL_SET_VALIDVALUE_INTERFACE(ppDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[in]*/ GETNAME_TYPE gnType;
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE gnType,
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE(gnType);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodeContextsValidValues
	{
		/*[out]*/ IEnumDebugCodeContexts2** ppEnumCodeCxts;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodeContexts)(
		/*[out]*/ IEnumDebugCodeContexts2** ppEnumCodeCxts)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodeContexts)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumCodeCxts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageInfoValidValues
	{
		/*[in,out,ptr]*/ BSTR* pbstrLanguage;
		/*[in,out,ptr]*/ GUID* pguidLanguage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* pbstrLanguage,
		/*[in,out,ptr]*/ GUID* pguidLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrLanguage);

		VSL_SET_VALIDVALUE(pguidLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStatementRangeValidValues
	{
		/*[in,out,ptr]*/ TEXT_POSITION* pBegPosition;
		/*[in,out,ptr]*/ TEXT_POSITION* pEndPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetStatementRange)(
		/*[in,out,ptr]*/ TEXT_POSITION* pBegPosition,
		/*[in,out,ptr]*/ TEXT_POSITION* pEndPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetStatementRange)

		VSL_SET_VALIDVALUE(pBegPosition);

		VSL_SET_VALIDVALUE(pEndPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceRangeValidValues
	{
		/*[in,out,ptr]*/ TEXT_POSITION* pBegPosition;
		/*[in,out,ptr]*/ TEXT_POSITION* pEndPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceRange)(
		/*[in,out,ptr]*/ TEXT_POSITION* pBegPosition,
		/*[in,out,ptr]*/ TEXT_POSITION* pEndPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceRange)

		VSL_SET_VALIDVALUE(pBegPosition);

		VSL_SET_VALIDVALUE(pEndPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct CompareValidValues
	{
		/*[in]*/ DOCCONTEXT_COMPARE compare;
		/*[in,size_is(dwDocContextSetLen),length_is(dwDocContextSetLen)]*/ IDebugDocumentContext2** rgpDocContextSet;
		/*[in]*/ DWORD dwDocContextSetLen;
		/*[out]*/ DWORD* pdwDocContext;
		HRESULT retValue;
	};

	STDMETHOD(Compare)(
		/*[in]*/ DOCCONTEXT_COMPARE compare,
		/*[in,size_is(dwDocContextSetLen),length_is(dwDocContextSetLen)]*/ IDebugDocumentContext2** rgpDocContextSet,
		/*[in]*/ DWORD dwDocContextSetLen,
		/*[out]*/ DWORD* pdwDocContext)
	{
		VSL_DEFINE_MOCK_METHOD(Compare)

		VSL_CHECK_VALIDVALUE(compare);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpDocContextSet, dwDocContextSetLen, validValues.dwDocContextSetLen);

		VSL_CHECK_VALIDVALUE(dwDocContextSetLen);

		VSL_SET_VALIDVALUE(pdwDocContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SeekValidValues
	{
		/*[in]*/ int nCount;
		/*[out]*/ IDebugDocumentContext2** ppDocContext;
		HRESULT retValue;
	};

	STDMETHOD(Seek)(
		/*[in]*/ int nCount,
		/*[out]*/ IDebugDocumentContext2** ppDocContext)
	{
		VSL_DEFINE_MOCK_METHOD(Seek)

		VSL_CHECK_VALIDVALUE(nCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppDocContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENTCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocumentPosition2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENTPOSITION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENTPOSITION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocumentPosition2NotImpl :
	public IDebugDocumentPosition2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentPosition2NotImpl)

public:

	typedef IDebugDocumentPosition2 Interface;

	STDMETHOD(GetFileName)(
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocument)(
		/*[out]*/ IDebugDocument2** /*ppDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPositionInDocument)(
		/*[in]*/ IDebugDocument2* /*pDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRange)(
		/*[in,out,ptr]*/ TEXT_POSITION* /*pBegPosition*/,
		/*[in,out,ptr]*/ TEXT_POSITION* /*pEndPosition*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocumentPosition2MockImpl :
	public IDebugDocumentPosition2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentPosition2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocumentPosition2MockImpl)

	typedef IDebugDocumentPosition2 Interface;
	struct GetFileNameValidValues
	{
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetFileName)(
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetFileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentValidValues
	{
		/*[out]*/ IDebugDocument2** ppDoc;
		HRESULT retValue;
	};

	STDMETHOD(GetDocument)(
		/*[out]*/ IDebugDocument2** ppDoc)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocument)

		VSL_SET_VALIDVALUE_INTERFACE(ppDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPositionInDocumentValidValues
	{
		/*[in]*/ IDebugDocument2* pDoc;
		HRESULT retValue;
	};

	STDMETHOD(IsPositionInDocument)(
		/*[in]*/ IDebugDocument2* pDoc)
	{
		VSL_DEFINE_MOCK_METHOD(IsPositionInDocument)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRangeValidValues
	{
		/*[in,out,ptr]*/ TEXT_POSITION* pBegPosition;
		/*[in,out,ptr]*/ TEXT_POSITION* pEndPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetRange)(
		/*[in,out,ptr]*/ TEXT_POSITION* pBegPosition,
		/*[in,out,ptr]*/ TEXT_POSITION* pEndPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetRange)

		VSL_SET_VALIDVALUE(pBegPosition);

		VSL_SET_VALIDVALUE(pEndPosition);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENTPOSITION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocumentText2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENTTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENTTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocumentText2NotImpl :
	public IDebugDocumentText2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentText2NotImpl)

public:

	typedef IDebugDocumentText2 Interface;

	STDMETHOD(GetSize)(
		/*[in,out,ptr]*/ ULONG* /*pcNumLines*/,
		/*[in,out,ptr]*/ ULONG* /*pcNumChars*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[in]*/ TEXT_POSITION /*pos*/,
		/*[in]*/ ULONG /*cMaxChars*/,
		/*[out,length_is(*pcNumChars),size_is(cMaxChars)]*/ WCHAR* /*pText*/,
		/*[out]*/ ULONG* /*pcNumChars*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE /*gnType*/,
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentClassId)(
		/*[out]*/ CLSID* /*pclsid*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocumentText2MockImpl :
	public IDebugDocumentText2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentText2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocumentText2MockImpl)

	typedef IDebugDocumentText2 Interface;
	struct GetSizeValidValues
	{
		/*[in,out,ptr]*/ ULONG* pcNumLines;
		/*[in,out,ptr]*/ ULONG* pcNumChars;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[in,out,ptr]*/ ULONG* pcNumLines,
		/*[in,out,ptr]*/ ULONG* pcNumChars)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pcNumLines);

		VSL_SET_VALIDVALUE(pcNumChars);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[in]*/ TEXT_POSITION pos;
		/*[in]*/ ULONG cMaxChars;
		/*[out,length_is(*pcNumChars),size_is(cMaxChars)]*/ WCHAR* pText;
		/*[out]*/ ULONG* pcNumChars;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ TEXT_POSITION pos,
		/*[in]*/ ULONG cMaxChars,
		/*[out,length_is(*pcNumChars),size_is(cMaxChars)]*/ WCHAR* pText,
		/*[out]*/ ULONG* pcNumChars)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE(cMaxChars);

		VSL_SET_VALIDVALUE_STRINGW(pText, cMaxChars);

		VSL_SET_VALIDVALUE(pcNumChars);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[in]*/ GETNAME_TYPE gnType;
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE gnType,
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE(gnType);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentClassIdValidValues
	{
		/*[out]*/ CLSID* pclsid;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentClassId)(
		/*[out]*/ CLSID* pclsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentClassId)

		VSL_SET_VALIDVALUE(pclsid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENTTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocumentPositionOffset2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENTPOSITIONOFFSET2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENTPOSITIONOFFSET2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocumentPositionOffset2NotImpl :
	public IDebugDocumentPositionOffset2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentPositionOffset2NotImpl)

public:

	typedef IDebugDocumentPositionOffset2 Interface;

	STDMETHOD(GetRange)(
		/*[in,out,ptr]*/ DWORD* /*pdwBegOffset*/,
		/*[in,out,ptr]*/ DWORD* /*pdwEndOffset*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocumentPositionOffset2MockImpl :
	public IDebugDocumentPositionOffset2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentPositionOffset2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocumentPositionOffset2MockImpl)

	typedef IDebugDocumentPositionOffset2 Interface;
	struct GetRangeValidValues
	{
		/*[in,out,ptr]*/ DWORD* pdwBegOffset;
		/*[in,out,ptr]*/ DWORD* pdwEndOffset;
		HRESULT retValue;
	};

	STDMETHOD(GetRange)(
		/*[in,out,ptr]*/ DWORD* pdwBegOffset,
		/*[in,out,ptr]*/ DWORD* pdwEndOffset)
	{
		VSL_DEFINE_MOCK_METHOD(GetRange)

		VSL_SET_VALIDVALUE(pdwBegOffset);

		VSL_SET_VALIDVALUE(pdwEndOffset);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENTPOSITIONOFFSET2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugENCDocumentContextUpdate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENCDOCUMENTCONTEXTUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENCDOCUMENTCONTEXTUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugENCDocumentContextUpdateNotImpl :
	public IDebugENCDocumentContextUpdate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugENCDocumentContextUpdateNotImpl)

public:

	typedef IDebugENCDocumentContextUpdate Interface;

	STDMETHOD(UpdateDocumentContext)(
		/*[in]*/ IDebugCodeContext2* /*pContext*/,
		/*[in]*/ IDebugDocumentContext2* /*pDocContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateStatementPosition)(
		/*[in]*/ TEXT_POSITION /*posBegStatement*/,
		/*[in]*/ TEXT_POSITION /*posEndStatement*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugENCDocumentContextUpdateMockImpl :
	public IDebugENCDocumentContextUpdate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugENCDocumentContextUpdateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugENCDocumentContextUpdateMockImpl)

	typedef IDebugENCDocumentContextUpdate Interface;
	struct UpdateDocumentContextValidValues
	{
		/*[in]*/ IDebugCodeContext2* pContext;
		/*[in]*/ IDebugDocumentContext2* pDocContext;
		HRESULT retValue;
	};

	STDMETHOD(UpdateDocumentContext)(
		/*[in]*/ IDebugCodeContext2* pContext,
		/*[in]*/ IDebugDocumentContext2* pDocContext)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateDocumentContext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pContext);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDocContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateStatementPositionValidValues
	{
		/*[in]*/ TEXT_POSITION posBegStatement;
		/*[in]*/ TEXT_POSITION posEndStatement;
		HRESULT retValue;
	};

	STDMETHOD(UpdateStatementPosition)(
		/*[in]*/ TEXT_POSITION posBegStatement,
		/*[in]*/ TEXT_POSITION posEndStatement)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateStatementPosition)

		VSL_CHECK_VALIDVALUE(posBegStatement);

		VSL_CHECK_VALIDVALUE(posEndStatement);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENCDOCUMENTCONTEXTUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEngine2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENGINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENGINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEngine2NotImpl :
	public IDebugEngine2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngine2NotImpl)

public:

	typedef IDebugEngine2 Interface;

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach)(
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgram2** /*rgpPrograms*/,
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgramNode2** /*rgpProgramNodes*/,
		/*[in]*/ DWORD /*celtPrograms*/,
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in]*/ ATTACH_REASON /*dwReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* /*pBPRequest*/,
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID /*guidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineId)(
		/*[out]*/ GUID* /*pguidEngine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DestroyProgram)(
		/*[in]*/ IDebugProgram2* /*pProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContinueFromSynchronousEvent)(
		/*[in]*/ IDebugEvent2* /*pEvent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD /*wLangID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR /*pszRegistryRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMetric)(
		/*[in]*/ LPCOLESTR /*pszMetric*/,
		/*[in]*/ VARIANT /*varValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL
};

class IDebugEngine2MockImpl :
	public IDebugEngine2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngine2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEngine2MockImpl)

	typedef IDebugEngine2 Interface;
	struct EnumProgramsValidValues
	{
		/*[out]*/ IEnumDebugPrograms2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPrograms)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachValidValues
	{
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgram2** rgpPrograms;
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgramNode2** rgpProgramNodes;
		/*[in]*/ DWORD celtPrograms;
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in]*/ ATTACH_REASON dwReason;
		HRESULT retValue;
	};

	STDMETHOD(Attach)(
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgram2** rgpPrograms,
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgramNode2** rgpProgramNodes,
		/*[in]*/ DWORD celtPrograms,
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in]*/ ATTACH_REASON dwReason)
	{
		VSL_DEFINE_MOCK_METHOD(Attach)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpPrograms, celtPrograms, validValues.celtPrograms);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProgramNodes, celtPrograms, validValues.celtPrograms);

		VSL_CHECK_VALIDVALUE(celtPrograms);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE(dwReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePendingBreakpointValidValues
	{
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest;
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP;
		HRESULT retValue;
	};

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest,
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePendingBreakpoint)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBPRequest);

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBP);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(SetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveSetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveSetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllSetExceptionsValidValues
	{
		/*[in]*/ REFGUID guidType;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID guidType)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAllSetExceptions)

		VSL_CHECK_VALIDVALUE(guidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineIdValidValues
	{
		/*[out]*/ GUID* pguidEngine;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineId)(
		/*[out]*/ GUID* pguidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineId)

		VSL_SET_VALIDVALUE(pguidEngine);

		VSL_RETURN_VALIDVALUES();
	}
	struct DestroyProgramValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		HRESULT retValue;
	};

	STDMETHOD(DestroyProgram)(
		/*[in]*/ IDebugProgram2* pProgram)
	{
		VSL_DEFINE_MOCK_METHOD(DestroyProgram)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContinueFromSynchronousEventValidValues
	{
		/*[in]*/ IDebugEvent2* pEvent;
		HRESULT retValue;
	};

	STDMETHOD(ContinueFromSynchronousEvent)(
		/*[in]*/ IDebugEvent2* pEvent)
	{
		VSL_DEFINE_MOCK_METHOD(ContinueFromSynchronousEvent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvent);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLocaleValidValues
	{
		/*[in]*/ WORD wLangID;
		HRESULT retValue;
	};

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD wLangID)
	{
		VSL_DEFINE_MOCK_METHOD(SetLocale)

		VSL_CHECK_VALIDVALUE(wLangID);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRegistryRootValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot;
		HRESULT retValue;
	};

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot)
	{
		VSL_DEFINE_MOCK_METHOD(SetRegistryRoot)

		VSL_CHECK_VALIDVALUE_STRINGW(pszRegistryRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMetricValidValues
	{
		/*[in]*/ LPCOLESTR pszMetric;
		/*[in]*/ VARIANT varValue;
		HRESULT retValue;
	};

	STDMETHOD(SetMetric)(
		/*[in]*/ LPCOLESTR pszMetric,
		/*[in]*/ VARIANT varValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetMetric)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENGINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugDocumentTextEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGDOCUMENTTEXTEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGDOCUMENTTEXTEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugDocumentTextEvents2NotImpl :
	public IDebugDocumentTextEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentTextEvents2NotImpl)

public:

	typedef IDebugDocumentTextEvents2 Interface;

	STDMETHOD(onDestroy)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(onInsertText)(
		/*[in]*/ TEXT_POSITION /*pos*/,
		/*[in]*/ DWORD /*dwNumToInsert*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(onRemoveText)(
		/*[in]*/ TEXT_POSITION /*pos*/,
		/*[in]*/ DWORD /*dwNumToRemove*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(onReplaceText)(
		/*[in]*/ TEXT_POSITION /*pos*/,
		/*[in]*/ DWORD /*dwNumToReplace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(onUpdateTextAttributes)(
		/*[in]*/ TEXT_POSITION /*pos*/,
		/*[in]*/ DWORD /*dwNumToUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(onUpdateDocumentAttributes)(
		/*[in]*/ TEXT_DOC_ATTR_2 /*textdocattr*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugDocumentTextEvents2MockImpl :
	public IDebugDocumentTextEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugDocumentTextEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugDocumentTextEvents2MockImpl)

	typedef IDebugDocumentTextEvents2 Interface;
	struct onDestroyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(onDestroy)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(onDestroy)

		VSL_RETURN_VALIDVALUES();
	}
	struct onInsertTextValidValues
	{
		/*[in]*/ TEXT_POSITION pos;
		/*[in]*/ DWORD dwNumToInsert;
		HRESULT retValue;
	};

	STDMETHOD(onInsertText)(
		/*[in]*/ TEXT_POSITION pos,
		/*[in]*/ DWORD dwNumToInsert)
	{
		VSL_DEFINE_MOCK_METHOD(onInsertText)

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE(dwNumToInsert);

		VSL_RETURN_VALIDVALUES();
	}
	struct onRemoveTextValidValues
	{
		/*[in]*/ TEXT_POSITION pos;
		/*[in]*/ DWORD dwNumToRemove;
		HRESULT retValue;
	};

	STDMETHOD(onRemoveText)(
		/*[in]*/ TEXT_POSITION pos,
		/*[in]*/ DWORD dwNumToRemove)
	{
		VSL_DEFINE_MOCK_METHOD(onRemoveText)

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE(dwNumToRemove);

		VSL_RETURN_VALIDVALUES();
	}
	struct onReplaceTextValidValues
	{
		/*[in]*/ TEXT_POSITION pos;
		/*[in]*/ DWORD dwNumToReplace;
		HRESULT retValue;
	};

	STDMETHOD(onReplaceText)(
		/*[in]*/ TEXT_POSITION pos,
		/*[in]*/ DWORD dwNumToReplace)
	{
		VSL_DEFINE_MOCK_METHOD(onReplaceText)

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE(dwNumToReplace);

		VSL_RETURN_VALIDVALUES();
	}
	struct onUpdateTextAttributesValidValues
	{
		/*[in]*/ TEXT_POSITION pos;
		/*[in]*/ DWORD dwNumToUpdate;
		HRESULT retValue;
	};

	STDMETHOD(onUpdateTextAttributes)(
		/*[in]*/ TEXT_POSITION pos,
		/*[in]*/ DWORD dwNumToUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(onUpdateTextAttributes)

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE(dwNumToUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct onUpdateDocumentAttributesValidValues
	{
		/*[in]*/ TEXT_DOC_ATTR_2 textdocattr;
		HRESULT retValue;
	};

	STDMETHOD(onUpdateDocumentAttributes)(
		/*[in]*/ TEXT_DOC_ATTR_2 textdocattr)
	{
		VSL_DEFINE_MOCK_METHOD(onUpdateDocumentAttributes)

		VSL_CHECK_VALIDVALUE(textdocattr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGDOCUMENTTEXTEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEncNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENCNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENCNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEncNotifyNotImpl :
	public IDebugEncNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEncNotifyNotImpl)

public:

	typedef IDebugEncNotify Interface;

	STDMETHOD(NotifyEncIsUnavailable)(
		/*[in]*/ EncUnavailableReason /*reason*/,
		/*[in]*/ BOOL /*fEditWasApplied*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyEncUpdateCurrentStatement)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyEncEditAttemptedAtInvalidStopState)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyEncEditDisallowedByProject)(
		/*[in]*/ IUnknown* /*pProject*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugEncNotifyMockImpl :
	public IDebugEncNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEncNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEncNotifyMockImpl)

	typedef IDebugEncNotify Interface;
	struct NotifyEncIsUnavailableValidValues
	{
		/*[in]*/ EncUnavailableReason reason;
		/*[in]*/ BOOL fEditWasApplied;
		HRESULT retValue;
	};

	STDMETHOD(NotifyEncIsUnavailable)(
		/*[in]*/ EncUnavailableReason reason,
		/*[in]*/ BOOL fEditWasApplied)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyEncIsUnavailable)

		VSL_CHECK_VALIDVALUE(reason);

		VSL_CHECK_VALIDVALUE(fEditWasApplied);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyEncUpdateCurrentStatementValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NotifyEncUpdateCurrentStatement)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NotifyEncUpdateCurrentStatement)

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyEncEditAttemptedAtInvalidStopStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NotifyEncEditAttemptedAtInvalidStopState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NotifyEncEditAttemptedAtInvalidStopState)

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyEncEditDisallowedByProjectValidValues
	{
		/*[in]*/ IUnknown* pProject;
		HRESULT retValue;
	};

	STDMETHOD(NotifyEncEditDisallowedByProject)(
		/*[in]*/ IUnknown* pProject)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyEncEditDisallowedByProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENCNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEngine3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENGINE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENGINE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEngine3NotImpl :
	public IDebugEngine3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngine3NotImpl)

public:

	typedef IDebugEngine3 Interface;

	STDMETHOD(SetSymbolPath)(
		/*[in]*/ LPCOLESTR /*szSymbolSearchPath*/,
		/*[in]*/ LPCOLESTR /*szSymbolCachePath*/,
		/*[in]*/ LOAD_SYMBOLS_FLAGS /*Flags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadSymbols)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetJustMyCodeState)(
		/*[in]*/ BOOL /*fUpdate*/,
		/*[in]*/ DWORD /*dwModules*/,
		/*[in,size_is(dwModules),ptr]*/ JMC_CODE_SPEC* /*rgJMCSpec*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEngineGuid)(
		/*[in]*/ GUID* /*guidEngine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAllExceptions)(
		/*[in]*/ EXCEPTION_STATE /*dwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach)(
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgram2** /*rgpPrograms*/,
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgramNode2** /*rgpProgramNodes*/,
		/*[in]*/ DWORD /*celtPrograms*/,
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in]*/ ATTACH_REASON /*dwReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* /*pBPRequest*/,
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID /*guidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineId)(
		/*[out]*/ GUID* /*pguidEngine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DestroyProgram)(
		/*[in]*/ IDebugProgram2* /*pProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContinueFromSynchronousEvent)(
		/*[in]*/ IDebugEvent2* /*pEvent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD /*wLangID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR /*pszRegistryRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMetric)(
		/*[in]*/ LPCOLESTR /*pszMetric*/,
		/*[in]*/ VARIANT /*varValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL
};

class IDebugEngine3MockImpl :
	public IDebugEngine3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngine3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEngine3MockImpl)

	typedef IDebugEngine3 Interface;
	struct SetSymbolPathValidValues
	{
		/*[in]*/ LPCOLESTR szSymbolSearchPath;
		/*[in]*/ LPCOLESTR szSymbolCachePath;
		/*[in]*/ LOAD_SYMBOLS_FLAGS Flags;
		HRESULT retValue;
	};

	STDMETHOD(SetSymbolPath)(
		/*[in]*/ LPCOLESTR szSymbolSearchPath,
		/*[in]*/ LPCOLESTR szSymbolCachePath,
		/*[in]*/ LOAD_SYMBOLS_FLAGS Flags)
	{
		VSL_DEFINE_MOCK_METHOD(SetSymbolPath)

		VSL_CHECK_VALIDVALUE_STRINGW(szSymbolSearchPath);

		VSL_CHECK_VALIDVALUE_STRINGW(szSymbolCachePath);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadSymbolsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LoadSymbols)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LoadSymbols)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetJustMyCodeStateValidValues
	{
		/*[in]*/ BOOL fUpdate;
		/*[in]*/ DWORD dwModules;
		/*[in,size_is(dwModules),ptr]*/ JMC_CODE_SPEC* rgJMCSpec;
		HRESULT retValue;
	};

	STDMETHOD(SetJustMyCodeState)(
		/*[in]*/ BOOL fUpdate,
		/*[in]*/ DWORD dwModules,
		/*[in,size_is(dwModules),ptr]*/ JMC_CODE_SPEC* rgJMCSpec)
	{
		VSL_DEFINE_MOCK_METHOD(SetJustMyCodeState)

		VSL_CHECK_VALIDVALUE(fUpdate);

		VSL_CHECK_VALIDVALUE(dwModules);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgJMCSpec, dwModules*sizeof(rgJMCSpec[0]), validValues.dwModules*sizeof(validValues.rgJMCSpec[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEngineGuidValidValues
	{
		/*[in]*/ GUID* guidEngine;
		HRESULT retValue;
	};

	STDMETHOD(SetEngineGuid)(
		/*[in]*/ GUID* guidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(SetEngineGuid)

		VSL_CHECK_VALIDVALUE_POINTER(guidEngine);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAllExceptionsValidValues
	{
		/*[in]*/ EXCEPTION_STATE dwState;
		HRESULT retValue;
	};

	STDMETHOD(SetAllExceptions)(
		/*[in]*/ EXCEPTION_STATE dwState)
	{
		VSL_DEFINE_MOCK_METHOD(SetAllExceptions)

		VSL_CHECK_VALIDVALUE(dwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProgramsValidValues
	{
		/*[out]*/ IEnumDebugPrograms2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPrograms)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachValidValues
	{
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgram2** rgpPrograms;
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgramNode2** rgpProgramNodes;
		/*[in]*/ DWORD celtPrograms;
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in]*/ ATTACH_REASON dwReason;
		HRESULT retValue;
	};

	STDMETHOD(Attach)(
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgram2** rgpPrograms,
		/*[in,size_is(celtPrograms),length_is(celtPrograms)]*/ IDebugProgramNode2** rgpProgramNodes,
		/*[in]*/ DWORD celtPrograms,
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in]*/ ATTACH_REASON dwReason)
	{
		VSL_DEFINE_MOCK_METHOD(Attach)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpPrograms, celtPrograms, validValues.celtPrograms);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProgramNodes, celtPrograms, validValues.celtPrograms);

		VSL_CHECK_VALIDVALUE(celtPrograms);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE(dwReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePendingBreakpointValidValues
	{
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest;
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP;
		HRESULT retValue;
	};

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest,
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePendingBreakpoint)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBPRequest);

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBP);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(SetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveSetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveSetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllSetExceptionsValidValues
	{
		/*[in]*/ REFGUID guidType;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID guidType)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAllSetExceptions)

		VSL_CHECK_VALIDVALUE(guidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineIdValidValues
	{
		/*[out]*/ GUID* pguidEngine;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineId)(
		/*[out]*/ GUID* pguidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineId)

		VSL_SET_VALIDVALUE(pguidEngine);

		VSL_RETURN_VALIDVALUES();
	}
	struct DestroyProgramValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		HRESULT retValue;
	};

	STDMETHOD(DestroyProgram)(
		/*[in]*/ IDebugProgram2* pProgram)
	{
		VSL_DEFINE_MOCK_METHOD(DestroyProgram)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContinueFromSynchronousEventValidValues
	{
		/*[in]*/ IDebugEvent2* pEvent;
		HRESULT retValue;
	};

	STDMETHOD(ContinueFromSynchronousEvent)(
		/*[in]*/ IDebugEvent2* pEvent)
	{
		VSL_DEFINE_MOCK_METHOD(ContinueFromSynchronousEvent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvent);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLocaleValidValues
	{
		/*[in]*/ WORD wLangID;
		HRESULT retValue;
	};

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD wLangID)
	{
		VSL_DEFINE_MOCK_METHOD(SetLocale)

		VSL_CHECK_VALIDVALUE(wLangID);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRegistryRootValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot;
		HRESULT retValue;
	};

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot)
	{
		VSL_DEFINE_MOCK_METHOD(SetRegistryRoot)

		VSL_CHECK_VALIDVALUE_STRINGW(pszRegistryRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMetricValidValues
	{
		/*[in]*/ LPCOLESTR pszMetric;
		/*[in]*/ VARIANT varValue;
		HRESULT retValue;
	};

	STDMETHOD(SetMetric)(
		/*[in]*/ LPCOLESTR pszMetric,
		/*[in]*/ VARIANT varValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetMetric)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENGINE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEngineCreateEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENGINECREATEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENGINECREATEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEngineCreateEvent2NotImpl :
	public IDebugEngineCreateEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngineCreateEvent2NotImpl)

public:

	typedef IDebugEngineCreateEvent2 Interface;

	STDMETHOD(GetEngine)(
		/*[out]*/ IDebugEngine2** /*pEngine*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugEngineCreateEvent2MockImpl :
	public IDebugEngineCreateEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngineCreateEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEngineCreateEvent2MockImpl)

	typedef IDebugEngineCreateEvent2 Interface;
	struct GetEngineValidValues
	{
		/*[out]*/ IDebugEngine2** pEngine;
		HRESULT retValue;
	};

	STDMETHOD(GetEngine)(
		/*[out]*/ IDebugEngine2** pEngine)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngine)

		VSL_SET_VALIDVALUE_INTERFACE(pEngine);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENGINECREATEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEngineLaunch2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENGINELAUNCH2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENGINELAUNCH2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEngineLaunch2NotImpl :
	public IDebugEngineLaunch2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngineLaunch2NotImpl)

public:

	typedef IDebugEngineLaunch2 Interface;

	STDMETHOD(LaunchSuspended)(
		/*[in,ptr]*/ LPCOLESTR /*pszServer*/,
		/*[in]*/ IDebugPort2* /*pPort*/,
		/*[in,ptr]*/ LPCOLESTR /*pszExe*/,
		/*[in,ptr]*/ LPCOLESTR /*pszArgs*/,
		/*[in,ptr]*/ LPCOLESTR /*pszDir*/,
		/*[in,ptr]*/ BSTR /*bstrEnv*/,
		/*[in,ptr]*/ LPCOLESTR /*pszOptions*/,
		/*[in]*/ LAUNCH_FLAGS /*dwLaunchFlags*/,
		/*[in]*/ DWORD /*hStdInput*/,
		/*[in]*/ DWORD /*hStdOutput*/,
		/*[in]*/ DWORD /*hStdError*/,
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResumeProcess)(
		/*[in]*/ IDebugProcess2* /*pProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanTerminateProcess)(
		/*[in]*/ IDebugProcess2* /*pProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TerminateProcess)(
		/*[in]*/ IDebugProcess2* /*pProcess*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugEngineLaunch2MockImpl :
	public IDebugEngineLaunch2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngineLaunch2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEngineLaunch2MockImpl)

	typedef IDebugEngineLaunch2 Interface;
	struct LaunchSuspendedValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszServer;
		/*[in]*/ IDebugPort2* pPort;
		/*[in,ptr]*/ LPCOLESTR pszExe;
		/*[in,ptr]*/ LPCOLESTR pszArgs;
		/*[in,ptr]*/ LPCOLESTR pszDir;
		/*[in,ptr]*/ BSTR bstrEnv;
		/*[in,ptr]*/ LPCOLESTR pszOptions;
		/*[in]*/ LAUNCH_FLAGS dwLaunchFlags;
		/*[in]*/ DWORD hStdInput;
		/*[in]*/ DWORD hStdOutput;
		/*[in]*/ DWORD hStdError;
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(LaunchSuspended)(
		/*[in,ptr]*/ LPCOLESTR pszServer,
		/*[in]*/ IDebugPort2* pPort,
		/*[in,ptr]*/ LPCOLESTR pszExe,
		/*[in,ptr]*/ LPCOLESTR pszArgs,
		/*[in,ptr]*/ LPCOLESTR pszDir,
		/*[in,ptr]*/ BSTR bstrEnv,
		/*[in,ptr]*/ LPCOLESTR pszOptions,
		/*[in]*/ LAUNCH_FLAGS dwLaunchFlags,
		/*[in]*/ DWORD hStdInput,
		/*[in]*/ DWORD hStdOutput,
		/*[in]*/ DWORD hStdError,
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(LaunchSuspended)

		VSL_CHECK_VALIDVALUE_STRINGW(pszServer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExe);

		VSL_CHECK_VALIDVALUE_STRINGW(pszArgs);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDir);

		VSL_CHECK_VALIDVALUE_BSTR(bstrEnv);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOptions);

		VSL_CHECK_VALIDVALUE(dwLaunchFlags);

		VSL_CHECK_VALIDVALUE(hStdInput);

		VSL_CHECK_VALIDVALUE(hStdOutput);

		VSL_CHECK_VALIDVALUE(hStdError);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResumeProcessValidValues
	{
		/*[in]*/ IDebugProcess2* pProcess;
		HRESULT retValue;
	};

	STDMETHOD(ResumeProcess)(
		/*[in]*/ IDebugProcess2* pProcess)
	{
		VSL_DEFINE_MOCK_METHOD(ResumeProcess)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanTerminateProcessValidValues
	{
		/*[in]*/ IDebugProcess2* pProcess;
		HRESULT retValue;
	};

	STDMETHOD(CanTerminateProcess)(
		/*[in]*/ IDebugProcess2* pProcess)
	{
		VSL_DEFINE_MOCK_METHOD(CanTerminateProcess)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateProcessValidValues
	{
		/*[in]*/ IDebugProcess2* pProcess;
		HRESULT retValue;
	};

	STDMETHOD(TerminateProcess)(
		/*[in]*/ IDebugProcess2* pProcess)
	{
		VSL_DEFINE_MOCK_METHOD(TerminateProcess)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENGINELAUNCH2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEngineProgram2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGENGINEPROGRAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGENGINEPROGRAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEngineProgram2NotImpl :
	public IDebugEngineProgram2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngineProgram2NotImpl)

public:

	typedef IDebugEngineProgram2 Interface;

	STDMETHOD(Stop)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WatchForThreadStep)(
		/*[in]*/ IDebugProgram2* /*pOriginatingProgram*/,
		/*[in]*/ DWORD /*dwTid*/,
		/*[in]*/ BOOL /*fWatch*/,
		/*[in]*/ DWORD /*dwFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WatchForExpressionEvaluationOnThread)(
		/*[in]*/ IDebugProgram2* /*pOriginatingProgram*/,
		/*[in]*/ DWORD /*dwTid*/,
		/*[in]*/ DWORD /*dwEvalFlags*/,
		/*[in]*/ IDebugEventCallback2* /*pExprCallback*/,
		/*[in]*/ BOOL /*fWatch*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugEngineProgram2MockImpl :
	public IDebugEngineProgram2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEngineProgram2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEngineProgram2MockImpl)

	typedef IDebugEngineProgram2 Interface;
	struct StopValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Stop)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Stop)

		VSL_RETURN_VALIDVALUES();
	}
	struct WatchForThreadStepValidValues
	{
		/*[in]*/ IDebugProgram2* pOriginatingProgram;
		/*[in]*/ DWORD dwTid;
		/*[in]*/ BOOL fWatch;
		/*[in]*/ DWORD dwFrame;
		HRESULT retValue;
	};

	STDMETHOD(WatchForThreadStep)(
		/*[in]*/ IDebugProgram2* pOriginatingProgram,
		/*[in]*/ DWORD dwTid,
		/*[in]*/ BOOL fWatch,
		/*[in]*/ DWORD dwFrame)
	{
		VSL_DEFINE_MOCK_METHOD(WatchForThreadStep)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOriginatingProgram);

		VSL_CHECK_VALIDVALUE(dwTid);

		VSL_CHECK_VALIDVALUE(fWatch);

		VSL_CHECK_VALIDVALUE(dwFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct WatchForExpressionEvaluationOnThreadValidValues
	{
		/*[in]*/ IDebugProgram2* pOriginatingProgram;
		/*[in]*/ DWORD dwTid;
		/*[in]*/ DWORD dwEvalFlags;
		/*[in]*/ IDebugEventCallback2* pExprCallback;
		/*[in]*/ BOOL fWatch;
		HRESULT retValue;
	};

	STDMETHOD(WatchForExpressionEvaluationOnThread)(
		/*[in]*/ IDebugProgram2* pOriginatingProgram,
		/*[in]*/ DWORD dwTid,
		/*[in]*/ DWORD dwEvalFlags,
		/*[in]*/ IDebugEventCallback2* pExprCallback,
		/*[in]*/ BOOL fWatch)
	{
		VSL_DEFINE_MOCK_METHOD(WatchForExpressionEvaluationOnThread)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOriginatingProgram);

		VSL_CHECK_VALIDVALUE(dwTid);

		VSL_CHECK_VALIDVALUE(dwEvalFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExprCallback);

		VSL_CHECK_VALIDVALUE(fWatch);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGENGINEPROGRAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugErrorBreakpointResolution2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGERRORBREAKPOINTRESOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGERRORBREAKPOINTRESOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugErrorBreakpointResolution2NotImpl :
	public IDebugErrorBreakpointResolution2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugErrorBreakpointResolution2NotImpl)

public:

	typedef IDebugErrorBreakpointResolution2 Interface;

	STDMETHOD(GetBreakpointType)(
		/*[out]*/ BP_TYPE* /*pBPType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetResolutionInfo)(
		/*[in]*/ BPERESI_FIELDS /*dwFields*/,
		/*[out]*/ BP_ERROR_RESOLUTION_INFO* /*pErrorResolutionInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugErrorBreakpointResolution2MockImpl :
	public IDebugErrorBreakpointResolution2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugErrorBreakpointResolution2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugErrorBreakpointResolution2MockImpl)

	typedef IDebugErrorBreakpointResolution2 Interface;
	struct GetBreakpointTypeValidValues
	{
		/*[out]*/ BP_TYPE* pBPType;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpointType)(
		/*[out]*/ BP_TYPE* pBPType)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpointType)

		VSL_SET_VALIDVALUE(pBPType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetResolutionInfoValidValues
	{
		/*[in]*/ BPERESI_FIELDS dwFields;
		/*[out]*/ BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetResolutionInfo)(
		/*[in]*/ BPERESI_FIELDS dwFields,
		/*[out]*/ BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetResolutionInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pErrorResolutionInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGERRORBREAKPOINTRESOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugErrorEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGERROREVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGERROREVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugErrorEvent2NotImpl :
	public IDebugErrorEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugErrorEvent2NotImpl)

public:

	typedef IDebugErrorEvent2 Interface;

	STDMETHOD(GetErrorMessage)(
		/*[out]*/ MESSAGETYPE* /*pMessageType*/,
		/*[out]*/ BSTR* /*pbstrErrorFormat*/,
		/*[out]*/ HRESULT* /*phrErrorReason*/,
		/*[out]*/ DWORD* /*pdwType*/,
		/*[out]*/ BSTR* /*pbstrHelpFileName*/,
		/*[out]*/ DWORD* /*pdwHelpId*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugErrorEvent2MockImpl :
	public IDebugErrorEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugErrorEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugErrorEvent2MockImpl)

	typedef IDebugErrorEvent2 Interface;
	struct GetErrorMessageValidValues
	{
		/*[out]*/ MESSAGETYPE* pMessageType;
		/*[out]*/ BSTR* pbstrErrorFormat;
		/*[out]*/ HRESULT* phrErrorReason;
		/*[out]*/ DWORD* pdwType;
		/*[out]*/ BSTR* pbstrHelpFileName;
		/*[out]*/ DWORD* pdwHelpId;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorMessage)(
		/*[out]*/ MESSAGETYPE* pMessageType,
		/*[out]*/ BSTR* pbstrErrorFormat,
		/*[out]*/ HRESULT* phrErrorReason,
		/*[out]*/ DWORD* pdwType,
		/*[out]*/ BSTR* pbstrHelpFileName,
		/*[out]*/ DWORD* pdwHelpId)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorMessage)

		VSL_SET_VALIDVALUE(pMessageType);

		VSL_SET_VALIDVALUE_BSTR(pbstrErrorFormat);

		VSL_SET_VALIDVALUE(phrErrorReason);

		VSL_SET_VALIDVALUE(pdwType);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpFileName);

		VSL_SET_VALIDVALUE(pdwHelpId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGERROREVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugErrorBreakpoint2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGERRORBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGERRORBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugErrorBreakpoint2NotImpl :
	public IDebugErrorBreakpoint2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugErrorBreakpoint2NotImpl)

public:

	typedef IDebugErrorBreakpoint2 Interface;

	STDMETHOD(GetPendingBreakpoint)(
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBreakpoint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBreakpointResolution)(
		/*[out]*/ IDebugErrorBreakpointResolution2** /*ppErrorResolution*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugErrorBreakpoint2MockImpl :
	public IDebugErrorBreakpoint2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugErrorBreakpoint2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugErrorBreakpoint2MockImpl)

	typedef IDebugErrorBreakpoint2 Interface;
	struct GetPendingBreakpointValidValues
	{
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBreakpoint;
		HRESULT retValue;
	};

	STDMETHOD(GetPendingBreakpoint)(
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBreakpoint)
	{
		VSL_DEFINE_MOCK_METHOD(GetPendingBreakpoint)

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBreakpoint);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBreakpointResolutionValidValues
	{
		/*[out]*/ IDebugErrorBreakpointResolution2** ppErrorResolution;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpointResolution)(
		/*[out]*/ IDebugErrorBreakpointResolution2** ppErrorResolution)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpointResolution)

		VSL_SET_VALIDVALUE_INTERFACE(ppErrorResolution);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGERRORBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEvent2NotImpl :
	public IDebugEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEvent2NotImpl)

public:

	typedef IDebugEvent2 Interface;

	STDMETHOD(GetAttributes)(
		/*[out]*/ DWORD* /*pdwAttrib*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugEvent2MockImpl :
	public IDebugEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEvent2MockImpl)

	typedef IDebugEvent2 Interface;
	struct GetAttributesValidValues
	{
		/*[out]*/ DWORD* pdwAttrib;
		HRESULT retValue;
	};

	STDMETHOD(GetAttributes)(
		/*[out]*/ DWORD* pdwAttrib)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttributes)

		VSL_SET_VALIDVALUE(pdwAttrib);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugExceptionCallback2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEXCEPTIONCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEXCEPTIONCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugExceptionCallback2NotImpl :
	public IDebugExceptionCallback2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExceptionCallback2NotImpl)

public:

	typedef IDebugExceptionCallback2 Interface;

	STDMETHOD(QueryStopOnException)(
		/*[in]*/ IDebugProcess2* /*pProcess*/,
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in]*/ IDebugThread2* /*pThread*/,
		/*[in]*/ IDebugExceptionEvent2* /*pEvent*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugExceptionCallback2MockImpl :
	public IDebugExceptionCallback2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExceptionCallback2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugExceptionCallback2MockImpl)

	typedef IDebugExceptionCallback2 Interface;
	struct QueryStopOnExceptionValidValues
	{
		/*[in]*/ IDebugProcess2* pProcess;
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in]*/ IDebugThread2* pThread;
		/*[in]*/ IDebugExceptionEvent2* pEvent;
		HRESULT retValue;
	};

	STDMETHOD(QueryStopOnException)(
		/*[in]*/ IDebugProcess2* pProcess,
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in]*/ IDebugThread2* pThread,
		/*[in]*/ IDebugExceptionEvent2* pEvent)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStopOnException)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvent);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEXCEPTIONCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugExceptionEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEXCEPTIONEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEXCEPTIONEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugExceptionEvent2NotImpl :
	public IDebugExceptionEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExceptionEvent2NotImpl)

public:

	typedef IDebugExceptionEvent2 Interface;

	STDMETHOD(GetException)(
		/*[out]*/ EXCEPTION_INFO* /*pExceptionInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExceptionDescription)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanPassToDebuggee)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PassToDebuggee)(
		/*[in]*/ BOOL /*fPass*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugExceptionEvent2MockImpl :
	public IDebugExceptionEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExceptionEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugExceptionEvent2MockImpl)

	typedef IDebugExceptionEvent2 Interface;
	struct GetExceptionValidValues
	{
		/*[out]*/ EXCEPTION_INFO* pExceptionInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetException)(
		/*[out]*/ EXCEPTION_INFO* pExceptionInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetException)

		VSL_SET_VALIDVALUE(pExceptionInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExceptionDescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionDescription)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionDescription)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanPassToDebuggeeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanPassToDebuggee)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanPassToDebuggee)

		VSL_RETURN_VALIDVALUES();
	}
	struct PassToDebuggeeValidValues
	{
		/*[in]*/ BOOL fPass;
		HRESULT retValue;
	};

	STDMETHOD(PassToDebuggee)(
		/*[in]*/ BOOL fPass)
	{
		VSL_DEFINE_MOCK_METHOD(PassToDebuggee)

		VSL_CHECK_VALIDVALUE(fPass);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEXCEPTIONEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugEventCallback2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEVENTCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEVENTCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugEventCallback2NotImpl :
	public IDebugEventCallback2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEventCallback2NotImpl)

public:

	typedef IDebugEventCallback2 Interface;

	STDMETHOD(Event)(
		/*[in]*/ IDebugEngine2* /*pEngine*/,
		/*[in]*/ IDebugProcess2* /*pProcess*/,
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in]*/ IDebugThread2* /*pThread*/,
		/*[in]*/ IDebugEvent2* /*pEvent*/,
		/*[in]*/ REFIID /*riidEvent*/,
		/*[in]*/ DWORD /*dwAttrib*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugEventCallback2MockImpl :
	public IDebugEventCallback2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugEventCallback2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugEventCallback2MockImpl)

	typedef IDebugEventCallback2 Interface;
	struct EventValidValues
	{
		/*[in]*/ IDebugEngine2* pEngine;
		/*[in]*/ IDebugProcess2* pProcess;
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in]*/ IDebugThread2* pThread;
		/*[in]*/ IDebugEvent2* pEvent;
		/*[in]*/ REFIID riidEvent;
		/*[in]*/ DWORD dwAttrib;
		HRESULT retValue;
	};

	STDMETHOD(Event)(
		/*[in]*/ IDebugEngine2* pEngine,
		/*[in]*/ IDebugProcess2* pProcess,
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in]*/ IDebugThread2* pThread,
		/*[in]*/ IDebugEvent2* pEvent,
		/*[in]*/ REFIID riidEvent,
		/*[in]*/ DWORD dwAttrib)
	{
		VSL_DEFINE_MOCK_METHOD(Event)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEngine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvent);

		VSL_CHECK_VALIDVALUE(riidEvent);

		VSL_CHECK_VALIDVALUE(dwAttrib);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEVENTCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugExpressionEvaluationCompleteEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEXPRESSIONEVALUATIONCOMPLETEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEXPRESSIONEVALUATIONCOMPLETEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugExpressionEvaluationCompleteEvent2NotImpl :
	public IDebugExpressionEvaluationCompleteEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExpressionEvaluationCompleteEvent2NotImpl)

public:

	typedef IDebugExpressionEvaluationCompleteEvent2 Interface;

	STDMETHOD(GetExpression)(
		/*[out]*/ IDebugExpression2** /*ppExpr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetResult)(
		/*[out]*/ IDebugProperty2** /*ppResult*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugExpressionEvaluationCompleteEvent2MockImpl :
	public IDebugExpressionEvaluationCompleteEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExpressionEvaluationCompleteEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugExpressionEvaluationCompleteEvent2MockImpl)

	typedef IDebugExpressionEvaluationCompleteEvent2 Interface;
	struct GetExpressionValidValues
	{
		/*[out]*/ IDebugExpression2** ppExpr;
		HRESULT retValue;
	};

	STDMETHOD(GetExpression)(
		/*[out]*/ IDebugExpression2** ppExpr)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpression)

		VSL_SET_VALIDVALUE_INTERFACE(ppExpr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetResultValidValues
	{
		/*[out]*/ IDebugProperty2** ppResult;
		HRESULT retValue;
	};

	STDMETHOD(GetResult)(
		/*[out]*/ IDebugProperty2** ppResult)
	{
		VSL_DEFINE_MOCK_METHOD(GetResult)

		VSL_SET_VALIDVALUE_INTERFACE(ppResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEXPRESSIONEVALUATIONCOMPLETEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugExpressionContext2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEXPRESSIONCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEXPRESSIONCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugExpressionContext2NotImpl :
	public IDebugExpressionContext2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExpressionContext2NotImpl)

public:

	typedef IDebugExpressionContext2 Interface;

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseText)(
		/*[in]*/ LPCOLESTR /*pszCode*/,
		/*[in]*/ PARSEFLAGS /*dwFlags*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[out]*/ IDebugExpression2** /*ppExpr*/,
		/*[out]*/ BSTR* /*pbstrError*/,
		/*[out]*/ UINT* /*pichError*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugExpressionContext2MockImpl :
	public IDebugExpressionContext2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExpressionContext2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugExpressionContext2MockImpl)

	typedef IDebugExpressionContext2 Interface;
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseTextValidValues
	{
		/*[in]*/ LPCOLESTR pszCode;
		/*[in]*/ PARSEFLAGS dwFlags;
		/*[in]*/ UINT nRadix;
		/*[out]*/ IDebugExpression2** ppExpr;
		/*[out]*/ BSTR* pbstrError;
		/*[out]*/ UINT* pichError;
		HRESULT retValue;
	};

	STDMETHOD(ParseText)(
		/*[in]*/ LPCOLESTR pszCode,
		/*[in]*/ PARSEFLAGS dwFlags,
		/*[in]*/ UINT nRadix,
		/*[out]*/ IDebugExpression2** ppExpr,
		/*[out]*/ BSTR* pbstrError,
		/*[out]*/ UINT* pichError)
	{
		VSL_DEFINE_MOCK_METHOD(ParseText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCode);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_SET_VALIDVALUE_INTERFACE(ppExpr);

		VSL_SET_VALIDVALUE_BSTR(pbstrError);

		VSL_SET_VALIDVALUE(pichError);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEXPRESSIONCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugFirewallConfigurationCallback2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGFIREWALLCONFIGURATIONCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGFIREWALLCONFIGURATIONCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugFirewallConfigurationCallback2NotImpl :
	public IDebugFirewallConfigurationCallback2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugFirewallConfigurationCallback2NotImpl)

public:

	typedef IDebugFirewallConfigurationCallback2 Interface;

	STDMETHOD(EnsureDCOMUnblocked)()VSL_STDMETHOD_NOTIMPL
};

class IDebugFirewallConfigurationCallback2MockImpl :
	public IDebugFirewallConfigurationCallback2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugFirewallConfigurationCallback2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugFirewallConfigurationCallback2MockImpl)

	typedef IDebugFirewallConfigurationCallback2 Interface;
	struct EnsureDCOMUnblockedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EnsureDCOMUnblocked)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EnsureDCOMUnblocked)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGFIREWALLCONFIGURATIONCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugExpression2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGEXPRESSION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGEXPRESSION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugExpression2NotImpl :
	public IDebugExpression2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExpression2NotImpl)

public:

	typedef IDebugExpression2 Interface;

	STDMETHOD(EvaluateAsync)(
		/*[in]*/ EVALFLAGS /*dwFlags*/,
		/*[in]*/ IDebugEventCallback2* /*pExprCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Abort)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EvaluateSync)(
		/*[in]*/ EVALFLAGS /*dwFlags*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[in]*/ IDebugEventCallback2* /*pExprCallback*/,
		/*[out]*/ IDebugProperty2** /*ppResult*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugExpression2MockImpl :
	public IDebugExpression2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugExpression2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugExpression2MockImpl)

	typedef IDebugExpression2 Interface;
	struct EvaluateAsyncValidValues
	{
		/*[in]*/ EVALFLAGS dwFlags;
		/*[in]*/ IDebugEventCallback2* pExprCallback;
		HRESULT retValue;
	};

	STDMETHOD(EvaluateAsync)(
		/*[in]*/ EVALFLAGS dwFlags,
		/*[in]*/ IDebugEventCallback2* pExprCallback)
	{
		VSL_DEFINE_MOCK_METHOD(EvaluateAsync)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExprCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct AbortValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Abort)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Abort)

		VSL_RETURN_VALIDVALUES();
	}
	struct EvaluateSyncValidValues
	{
		/*[in]*/ EVALFLAGS dwFlags;
		/*[in]*/ DWORD dwTimeout;
		/*[in]*/ IDebugEventCallback2* pExprCallback;
		/*[out]*/ IDebugProperty2** ppResult;
		HRESULT retValue;
	};

	STDMETHOD(EvaluateSync)(
		/*[in]*/ EVALFLAGS dwFlags,
		/*[in]*/ DWORD dwTimeout,
		/*[in]*/ IDebugEventCallback2* pExprCallback,
		/*[out]*/ IDebugProperty2** ppResult)
	{
		VSL_DEFINE_MOCK_METHOD(EvaluateSync)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExprCallback);

		VSL_SET_VALIDVALUE_INTERFACE(ppResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGEXPRESSION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugFuncEvalAbortedEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGFUNCEVALABORTEDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGFUNCEVALABORTEDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugFuncEvalAbortedEvent2NotImpl :
	public IDebugFuncEvalAbortedEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugFuncEvalAbortedEvent2NotImpl)

public:

	typedef IDebugFuncEvalAbortedEvent2 Interface;

	STDMETHOD(GetAbortResult)(
		/*[out]*/ FUNC_EVAL_ABORT_RESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFunctionName)(
		/*[out]*/ BSTR* /*pbstrFunctionName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugFuncEvalAbortedEvent2MockImpl :
	public IDebugFuncEvalAbortedEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugFuncEvalAbortedEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugFuncEvalAbortedEvent2MockImpl)

	typedef IDebugFuncEvalAbortedEvent2 Interface;
	struct GetAbortResultValidValues
	{
		/*[out]*/ FUNC_EVAL_ABORT_RESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(GetAbortResult)(
		/*[out]*/ FUNC_EVAL_ABORT_RESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(GetAbortResult)

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFunctionNameValidValues
	{
		/*[out]*/ BSTR* pbstrFunctionName;
		HRESULT retValue;
	};

	STDMETHOD(GetFunctionName)(
		/*[out]*/ BSTR* pbstrFunctionName)
	{
		VSL_DEFINE_MOCK_METHOD(GetFunctionName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFunctionName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGFUNCEVALABORTEDEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugInterceptExceptionCompleteEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGINTERCEPTEXCEPTIONCOMPLETEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGINTERCEPTEXCEPTIONCOMPLETEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugInterceptExceptionCompleteEvent2NotImpl :
	public IDebugInterceptExceptionCompleteEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugInterceptExceptionCompleteEvent2NotImpl)

public:

	typedef IDebugInterceptExceptionCompleteEvent2 Interface;

	STDMETHOD(GetInterceptCookie)(
		/*[out]*/ UINT64* /*pqwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugInterceptExceptionCompleteEvent2MockImpl :
	public IDebugInterceptExceptionCompleteEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugInterceptExceptionCompleteEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugInterceptExceptionCompleteEvent2MockImpl)

	typedef IDebugInterceptExceptionCompleteEvent2 Interface;
	struct GetInterceptCookieValidValues
	{
		/*[out]*/ UINT64* pqwCookie;
		HRESULT retValue;
	};

	STDMETHOD(GetInterceptCookie)(
		/*[out]*/ UINT64* pqwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(GetInterceptCookie)

		VSL_SET_VALIDVALUE(pqwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGINTERCEPTEXCEPTIONCOMPLETEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugLogicalThread2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGLOGICALTHREAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGLOGICALTHREAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugLogicalThread2NotImpl :
	public IDebugLogicalThread2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugLogicalThread2NotImpl)

public:

	typedef IDebugLogicalThread2 Interface;

	STDMETHOD(EnumFrameInfo)(
		/*[in]*/ FRAMEINFO_FLAGS /*dwFieldSpec*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[out]*/ IEnumDebugFrameInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugLogicalThread2MockImpl :
	public IDebugLogicalThread2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugLogicalThread2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugLogicalThread2MockImpl)

	typedef IDebugLogicalThread2 Interface;
	struct EnumFrameInfoValidValues
	{
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec;
		/*[in]*/ UINT nRadix;
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumFrameInfo)(
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec,
		/*[in]*/ UINT nRadix,
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumFrameInfo)

		VSL_CHECK_VALIDVALUE(dwFieldSpec);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGLOGICALTHREAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugFunctionPosition2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGFUNCTIONPOSITION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGFUNCTIONPOSITION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugFunctionPosition2NotImpl :
	public IDebugFunctionPosition2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugFunctionPosition2NotImpl)

public:

	typedef IDebugFunctionPosition2 Interface;

	STDMETHOD(GetFunctionName)(
		/*[out]*/ BSTR* /*pbstrFunctionName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOffset)(
		/*[in,out,ptr]*/ TEXT_POSITION* /*pPosition*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugFunctionPosition2MockImpl :
	public IDebugFunctionPosition2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugFunctionPosition2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugFunctionPosition2MockImpl)

	typedef IDebugFunctionPosition2 Interface;
	struct GetFunctionNameValidValues
	{
		/*[out]*/ BSTR* pbstrFunctionName;
		HRESULT retValue;
	};

	STDMETHOD(GetFunctionName)(
		/*[out]*/ BSTR* pbstrFunctionName)
	{
		VSL_DEFINE_MOCK_METHOD(GetFunctionName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFunctionName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOffsetValidValues
	{
		/*[in,out,ptr]*/ TEXT_POSITION* pPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetOffset)(
		/*[in,out,ptr]*/ TEXT_POSITION* pPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetOffset)

		VSL_SET_VALIDVALUE(pPosition);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGFUNCTIONPOSITION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugMemoryBytes2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMEMORYBYTES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMEMORYBYTES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugMemoryBytes2NotImpl :
	public IDebugMemoryBytes2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMemoryBytes2NotImpl)

public:

	typedef IDebugMemoryBytes2 Interface;

	STDMETHOD(ReadAt)(
		/*[in]*/ IDebugMemoryContext2* /*pStartContext*/,
		/*[in]*/ DWORD /*dwCount*/,
		/*[out,size_is(dwCount),length_is(*pdwRead)]*/ BYTE* /*rgbMemory*/,
		/*[out]*/ DWORD* /*pdwRead*/,
		/*[in,out,ptr]*/ DWORD* /*pdwUnreadable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteAt)(
		/*[in]*/ IDebugMemoryContext2* /*pStartContext*/,
		/*[in]*/ DWORD /*dwCount*/,
		/*[in,size_is(dwCount),length_is(dwCount)]*/ BYTE* /*rgbMemory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ UINT64* /*pqwSize*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugMemoryBytes2MockImpl :
	public IDebugMemoryBytes2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMemoryBytes2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugMemoryBytes2MockImpl)

	typedef IDebugMemoryBytes2 Interface;
	struct ReadAtValidValues
	{
		/*[in]*/ IDebugMemoryContext2* pStartContext;
		/*[in]*/ DWORD dwCount;
		/*[out,size_is(dwCount),length_is(*pdwRead)]*/ BYTE* rgbMemory;
		/*[out]*/ DWORD* pdwRead;
		/*[in,out,ptr]*/ DWORD* pdwUnreadable;
		HRESULT retValue;
	};

	STDMETHOD(ReadAt)(
		/*[in]*/ IDebugMemoryContext2* pStartContext,
		/*[in]*/ DWORD dwCount,
		/*[out,size_is(dwCount),length_is(*pdwRead)]*/ BYTE* rgbMemory,
		/*[out]*/ DWORD* pdwRead,
		/*[in,out,ptr]*/ DWORD* pdwUnreadable)
	{
		VSL_DEFINE_MOCK_METHOD(ReadAt)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStartContext);

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_MEMCPY(rgbMemory, dwCount*sizeof(rgbMemory[0]), *(validValues.pdwRead)*sizeof(validValues.rgbMemory[0]));

		VSL_SET_VALIDVALUE(pdwRead);

		VSL_SET_VALIDVALUE(pdwUnreadable);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteAtValidValues
	{
		/*[in]*/ IDebugMemoryContext2* pStartContext;
		/*[in]*/ DWORD dwCount;
		/*[in,size_is(dwCount),length_is(dwCount)]*/ BYTE* rgbMemory;
		HRESULT retValue;
	};

	STDMETHOD(WriteAt)(
		/*[in]*/ IDebugMemoryContext2* pStartContext,
		/*[in]*/ DWORD dwCount,
		/*[in,size_is(dwCount),length_is(dwCount)]*/ BYTE* rgbMemory)
	{
		VSL_DEFINE_MOCK_METHOD(WriteAt)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStartContext);

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgbMemory, dwCount*sizeof(rgbMemory[0]), validValues.dwCount*sizeof(validValues.rgbMemory[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ UINT64* pqwSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ UINT64* pqwSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pqwSize);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMEMORYBYTES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugMemoryContext2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMEMORYCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMEMORYCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugMemoryContext2NotImpl :
	public IDebugMemoryContext2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMemoryContext2NotImpl)

public:

	typedef IDebugMemoryContext2 Interface;

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ CONTEXT_INFO_FIELDS /*dwFields*/,
		/*[out]*/ CONTEXT_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ UINT64 /*dwCount*/,
		/*[out]*/ IDebugMemoryContext2** /*ppMemCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Subtract)(
		/*[in]*/ UINT64 /*dwCount*/,
		/*[out]*/ IDebugMemoryContext2** /*ppMemCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Compare)(
		/*[in]*/ CONTEXT_COMPARE /*compare*/,
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** /*rgpMemoryContextSet*/,
		/*[in]*/ DWORD /*dwMemoryContextSetLen*/,
		/*[out]*/ DWORD* /*pdwMemoryContext*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugMemoryContext2MockImpl :
	public IDebugMemoryContext2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMemoryContext2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugMemoryContext2MockImpl)

	typedef IDebugMemoryContext2 Interface;
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ CONTEXT_INFO_FIELDS dwFields;
		/*[out]*/ CONTEXT_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ CONTEXT_INFO_FIELDS dwFields,
		/*[out]*/ CONTEXT_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ UINT64 dwCount;
		/*[out]*/ IDebugMemoryContext2** ppMemCxt;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ UINT64 dwCount,
		/*[out]*/ IDebugMemoryContext2** ppMemCxt)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppMemCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct SubtractValidValues
	{
		/*[in]*/ UINT64 dwCount;
		/*[out]*/ IDebugMemoryContext2** ppMemCxt;
		HRESULT retValue;
	};

	STDMETHOD(Subtract)(
		/*[in]*/ UINT64 dwCount,
		/*[out]*/ IDebugMemoryContext2** ppMemCxt)
	{
		VSL_DEFINE_MOCK_METHOD(Subtract)

		VSL_CHECK_VALIDVALUE(dwCount);

		VSL_SET_VALIDVALUE_INTERFACE(ppMemCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct CompareValidValues
	{
		/*[in]*/ CONTEXT_COMPARE compare;
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** rgpMemoryContextSet;
		/*[in]*/ DWORD dwMemoryContextSetLen;
		/*[out]*/ DWORD* pdwMemoryContext;
		HRESULT retValue;
	};

	STDMETHOD(Compare)(
		/*[in]*/ CONTEXT_COMPARE compare,
		/*[in,size_is(dwMemoryContextSetLen),length_is(dwMemoryContextSetLen)]*/ IDebugMemoryContext2** rgpMemoryContextSet,
		/*[in]*/ DWORD dwMemoryContextSetLen,
		/*[out]*/ DWORD* pdwMemoryContext)
	{
		VSL_DEFINE_MOCK_METHOD(Compare)

		VSL_CHECK_VALIDVALUE(compare);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpMemoryContextSet, dwMemoryContextSetLen, validValues.dwMemoryContextSetLen);

		VSL_CHECK_VALIDVALUE(dwMemoryContextSetLen);

		VSL_SET_VALIDVALUE(pdwMemoryContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMEMORYCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugManagedExceptionInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMANAGEDEXCEPTIONINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMANAGEDEXCEPTIONINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugManagedExceptionInfo2NotImpl :
	public IDebugManagedExceptionInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugManagedExceptionInfo2NotImpl)

public:

	typedef IDebugManagedExceptionInfo2 Interface;

	STDMETHOD(GetExceptionMessage)(
		/*[out]*/ BSTR* /*pbstrExceptionMessage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExceptionBoundaryType)(
		/*[out]*/ EXCEPTION_BOUNDARY_TYPE* /*pType*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugManagedExceptionInfo2MockImpl :
	public IDebugManagedExceptionInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugManagedExceptionInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugManagedExceptionInfo2MockImpl)

	typedef IDebugManagedExceptionInfo2 Interface;
	struct GetExceptionMessageValidValues
	{
		/*[out]*/ BSTR* pbstrExceptionMessage;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionMessage)(
		/*[out]*/ BSTR* pbstrExceptionMessage)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionMessage)

		VSL_SET_VALIDVALUE_BSTR(pbstrExceptionMessage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExceptionBoundaryTypeValidValues
	{
		/*[out]*/ EXCEPTION_BOUNDARY_TYPE* pType;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionBoundaryType)(
		/*[out]*/ EXCEPTION_BOUNDARY_TYPE* pType)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionBoundaryType)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMANAGEDEXCEPTIONINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugMDMUtil3_V7.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMDMUTIL3_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMDMUTIL3_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugMDMUtil3_V7NotImpl :
	public IDebugMDMUtil3_V7
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMDMUtil3_V7NotImpl)

public:

	typedef IDebugMDMUtil3_V7 Interface;

	STDMETHOD(DiagnoseScriptDebuggingError)(
		/*[in]*/ DWORD /*dwDebuggeeProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiagnoseWebDebuggingError)(
		/*[in]*/ WEB_DEBUG_TYPE /*dwWebType*/,
		/*[in,ptr]*/ LPCWSTR /*pszUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiagnoseASPDebugging)(
		/*[in,ptr]*/ LPCWSTR /*szASPUserAccount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddPIDToIgnore)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemovePIDToIgnore)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddPIDToDebug)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemovePIDToDebug)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DYNDEBUGFLAGS /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[out]*/ DYNDEBUGFLAGS* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDefaultJITServer)(
		/*[in]*/ REFCLSID /*clsidJITServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultJITServer)(
		/*[out]*/ CLSID* /*pClsidJITServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterJITDebugEngines)(
		/*[in]*/ REFCLSID /*clsidJITServer*/,
		/*[in,size_is(celtEngs)]*/ GUID* /*arrguidEngines*/,
		/*[in,ptr,size_is(celtEngs)]*/ BOOL* /*arrRemoteFlags*/,
		/*[in]*/ DWORD /*celtEngs*/,
		/*[in]*/ BOOL /*fRegister*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDebugPID)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*pid*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugMDMUtil3_V7MockImpl :
	public IDebugMDMUtil3_V7,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMDMUtil3_V7MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugMDMUtil3_V7MockImpl)

	typedef IDebugMDMUtil3_V7 Interface;
	struct DiagnoseScriptDebuggingErrorValidValues
	{
		/*[in]*/ DWORD dwDebuggeeProcessId;
		HRESULT retValue;
	};

	STDMETHOD(DiagnoseScriptDebuggingError)(
		/*[in]*/ DWORD dwDebuggeeProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(DiagnoseScriptDebuggingError)

		VSL_CHECK_VALIDVALUE(dwDebuggeeProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiagnoseWebDebuggingErrorValidValues
	{
		/*[in]*/ WEB_DEBUG_TYPE dwWebType;
		/*[in,ptr]*/ LPCWSTR pszUrl;
		HRESULT retValue;
	};

	STDMETHOD(DiagnoseWebDebuggingError)(
		/*[in]*/ WEB_DEBUG_TYPE dwWebType,
		/*[in,ptr]*/ LPCWSTR pszUrl)
	{
		VSL_DEFINE_MOCK_METHOD(DiagnoseWebDebuggingError)

		VSL_CHECK_VALIDVALUE(dwWebType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiagnoseASPDebuggingValidValues
	{
		/*[in,ptr]*/ LPCWSTR szASPUserAccount;
		HRESULT retValue;
	};

	STDMETHOD(DiagnoseASPDebugging)(
		/*[in,ptr]*/ LPCWSTR szASPUserAccount)
	{
		VSL_DEFINE_MOCK_METHOD(DiagnoseASPDebugging)

		VSL_CHECK_VALIDVALUE_STRINGW(szASPUserAccount);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddPIDToIgnoreValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(AddPIDToIgnore)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(AddPIDToIgnore)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePIDToIgnoreValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(RemovePIDToIgnore)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(RemovePIDToIgnore)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddPIDToDebugValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(AddPIDToDebug)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(AddPIDToDebug)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePIDToDebugValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(RemovePIDToDebug)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(RemovePIDToDebug)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDynamicDebuggingFlagsValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DYNDEBUGFLAGS dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DYNDEBUGFLAGS dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetDynamicDebuggingFlags)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDynamicDebuggingFlagsValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[out]*/ DYNDEBUGFLAGS* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID guidEngine,
		/*[out]*/ DYNDEBUGFLAGS* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetDynamicDebuggingFlags)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDefaultJITServerValidValues
	{
		/*[in]*/ REFCLSID clsidJITServer;
		HRESULT retValue;
	};

	STDMETHOD(SetDefaultJITServer)(
		/*[in]*/ REFCLSID clsidJITServer)
	{
		VSL_DEFINE_MOCK_METHOD(SetDefaultJITServer)

		VSL_CHECK_VALIDVALUE(clsidJITServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultJITServerValidValues
	{
		/*[out]*/ CLSID* pClsidJITServer;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultJITServer)(
		/*[out]*/ CLSID* pClsidJITServer)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultJITServer)

		VSL_SET_VALIDVALUE(pClsidJITServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterJITDebugEnginesValidValues
	{
		/*[in]*/ REFCLSID clsidJITServer;
		/*[in,size_is(celtEngs)]*/ GUID* arrguidEngines;
		/*[in,ptr,size_is(celtEngs)]*/ BOOL* arrRemoteFlags;
		/*[in]*/ DWORD celtEngs;
		/*[in]*/ BOOL fRegister;
		HRESULT retValue;
	};

	STDMETHOD(RegisterJITDebugEngines)(
		/*[in]*/ REFCLSID clsidJITServer,
		/*[in,size_is(celtEngs)]*/ GUID* arrguidEngines,
		/*[in,ptr,size_is(celtEngs)]*/ BOOL* arrRemoteFlags,
		/*[in]*/ DWORD celtEngs,
		/*[in]*/ BOOL fRegister)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterJITDebugEngines)

		VSL_CHECK_VALIDVALUE(clsidJITServer);

		VSL_CHECK_VALIDVALUE_MEMCMP(arrguidEngines, celtEngs*sizeof(arrguidEngines[0]), validValues.celtEngs*sizeof(validValues.arrguidEngines[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(arrRemoteFlags, celtEngs*sizeof(arrRemoteFlags[0]), validValues.celtEngs*sizeof(validValues.arrRemoteFlags[0]));

		VSL_CHECK_VALIDVALUE(celtEngs);

		VSL_CHECK_VALIDVALUE(fRegister);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDebugPIDValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD pid;
		HRESULT retValue;
	};

	STDMETHOD(CanDebugPID)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD pid)
	{
		VSL_DEFINE_MOCK_METHOD(CanDebugPID)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(pid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMDMUTIL3_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugMDMUtil2_V7.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMDMUTIL2_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMDMUTIL2_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugMDMUtil2_V7NotImpl :
	public IDebugMDMUtil2_V7
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMDMUtil2_V7NotImpl)

public:

	typedef IDebugMDMUtil2_V7 Interface;

	STDMETHOD(AddPIDToIgnore)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemovePIDToIgnore)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddPIDToDebug)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemovePIDToDebug)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*dwPid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DYNDEBUGFLAGS /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[out]*/ DYNDEBUGFLAGS* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDefaultJITServer)(
		/*[in]*/ REFCLSID /*clsidJITServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultJITServer)(
		/*[out]*/ CLSID* /*pClsidJITServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterJITDebugEngines)(
		/*[in]*/ REFCLSID /*clsidJITServer*/,
		/*[in,size_is(celtEngs)]*/ GUID* /*arrguidEngines*/,
		/*[in,ptr,size_is(celtEngs)]*/ BOOL* /*arrRemoteFlags*/,
		/*[in]*/ DWORD /*celtEngs*/,
		/*[in]*/ BOOL /*fRegister*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDebugPID)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ DWORD /*pid*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugMDMUtil2_V7MockImpl :
	public IDebugMDMUtil2_V7,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMDMUtil2_V7MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugMDMUtil2_V7MockImpl)

	typedef IDebugMDMUtil2_V7 Interface;
	struct AddPIDToIgnoreValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(AddPIDToIgnore)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(AddPIDToIgnore)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePIDToIgnoreValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(RemovePIDToIgnore)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(RemovePIDToIgnore)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddPIDToDebugValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(AddPIDToDebug)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(AddPIDToDebug)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePIDToDebugValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD dwPid;
		HRESULT retValue;
	};

	STDMETHOD(RemovePIDToDebug)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD dwPid)
	{
		VSL_DEFINE_MOCK_METHOD(RemovePIDToDebug)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDynamicDebuggingFlagsValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DYNDEBUGFLAGS dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DYNDEBUGFLAGS dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetDynamicDebuggingFlags)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDynamicDebuggingFlagsValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[out]*/ DYNDEBUGFLAGS* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetDynamicDebuggingFlags)(
		/*[in]*/ REFGUID guidEngine,
		/*[out]*/ DYNDEBUGFLAGS* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetDynamicDebuggingFlags)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDefaultJITServerValidValues
	{
		/*[in]*/ REFCLSID clsidJITServer;
		HRESULT retValue;
	};

	STDMETHOD(SetDefaultJITServer)(
		/*[in]*/ REFCLSID clsidJITServer)
	{
		VSL_DEFINE_MOCK_METHOD(SetDefaultJITServer)

		VSL_CHECK_VALIDVALUE(clsidJITServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultJITServerValidValues
	{
		/*[out]*/ CLSID* pClsidJITServer;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultJITServer)(
		/*[out]*/ CLSID* pClsidJITServer)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultJITServer)

		VSL_SET_VALIDVALUE(pClsidJITServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterJITDebugEnginesValidValues
	{
		/*[in]*/ REFCLSID clsidJITServer;
		/*[in,size_is(celtEngs)]*/ GUID* arrguidEngines;
		/*[in,ptr,size_is(celtEngs)]*/ BOOL* arrRemoteFlags;
		/*[in]*/ DWORD celtEngs;
		/*[in]*/ BOOL fRegister;
		HRESULT retValue;
	};

	STDMETHOD(RegisterJITDebugEngines)(
		/*[in]*/ REFCLSID clsidJITServer,
		/*[in,size_is(celtEngs)]*/ GUID* arrguidEngines,
		/*[in,ptr,size_is(celtEngs)]*/ BOOL* arrRemoteFlags,
		/*[in]*/ DWORD celtEngs,
		/*[in]*/ BOOL fRegister)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterJITDebugEngines)

		VSL_CHECK_VALIDVALUE(clsidJITServer);

		VSL_CHECK_VALIDVALUE_MEMCMP(arrguidEngines, celtEngs*sizeof(arrguidEngines[0]), validValues.celtEngs*sizeof(validValues.arrguidEngines[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(arrRemoteFlags, celtEngs*sizeof(arrRemoteFlags[0]), validValues.celtEngs*sizeof(validValues.arrRemoteFlags[0]));

		VSL_CHECK_VALIDVALUE(celtEngs);

		VSL_CHECK_VALIDVALUE(fRegister);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDebugPIDValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ DWORD pid;
		HRESULT retValue;
	};

	STDMETHOD(CanDebugPID)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ DWORD pid)
	{
		VSL_DEFINE_MOCK_METHOD(CanDebugPID)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(pid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMDMUTIL2_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugMachineEx2_V7.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMACHINEEX2_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMACHINEEX2_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugMachineEx2_V7NotImpl :
	public IDebugMachineEx2_V7
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMachineEx2_V7NotImpl)

public:

	typedef IDebugMachineEx2_V7 Interface;

	STDMETHOD(EnableAutoAttachOnProgramCreate)(
		/*[in]*/ LPCWSTR /*pszProcessNames*/,
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ LPCWSTR /*pszSessionId*/,
		/*[out]*/ DWORD* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisableAutoAttachOnEvent)(
		/*[in]*/ DWORD /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplierEx)(
		/*[in]*/ LPCOLESTR /*wstrRegistryRoot*/,
		/*[in]*/ REFGUID /*guidPortSupplier*/,
		/*[out]*/ IDebugPortSupplier2** /*ppPortSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortEx)(
		/*[in]*/ LPCOLESTR /*wstrRegistryRoot*/,
		/*[in]*/ REFGUID /*guidPort*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPortsEx)(
		/*[in]*/ LPCOLESTR /*wstrRegistryRoot*/,
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPortSuppliersEx)(
		/*[in]*/ LPCOLESTR /*wstrRegistryRoot*/,
		/*[out]*/ IEnumDebugPortSuppliers2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugMachineEx2_V7MockImpl :
	public IDebugMachineEx2_V7,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMachineEx2_V7MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugMachineEx2_V7MockImpl)

	typedef IDebugMachineEx2_V7 Interface;
	struct EnableAutoAttachOnProgramCreateValidValues
	{
		/*[in]*/ LPCWSTR pszProcessNames;
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ LPCWSTR pszSessionId;
		/*[out]*/ DWORD* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(EnableAutoAttachOnProgramCreate)(
		/*[in]*/ LPCWSTR pszProcessNames,
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ LPCWSTR pszSessionId,
		/*[out]*/ DWORD* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(EnableAutoAttachOnProgramCreate)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProcessNames);

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSessionId);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisableAutoAttachOnEventValidValues
	{
		/*[in]*/ DWORD dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(DisableAutoAttachOnEvent)(
		/*[in]*/ DWORD dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(DisableAutoAttachOnEvent)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierExValidValues
	{
		/*[in]*/ LPCOLESTR wstrRegistryRoot;
		/*[in]*/ REFGUID guidPortSupplier;
		/*[out]*/ IDebugPortSupplier2** ppPortSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplierEx)(
		/*[in]*/ LPCOLESTR wstrRegistryRoot,
		/*[in]*/ REFGUID guidPortSupplier,
		/*[out]*/ IDebugPortSupplier2** ppPortSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplierEx)

		VSL_CHECK_VALIDVALUE_STRINGW(wstrRegistryRoot);

		VSL_CHECK_VALIDVALUE(guidPortSupplier);

		VSL_SET_VALIDVALUE_INTERFACE(ppPortSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortExValidValues
	{
		/*[in]*/ LPCOLESTR wstrRegistryRoot;
		/*[in]*/ REFGUID guidPort;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPortEx)(
		/*[in]*/ LPCOLESTR wstrRegistryRoot,
		/*[in]*/ REFGUID guidPort,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortEx)

		VSL_CHECK_VALIDVALUE_STRINGW(wstrRegistryRoot);

		VSL_CHECK_VALIDVALUE(guidPort);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortsExValidValues
	{
		/*[in]*/ LPCOLESTR wstrRegistryRoot;
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPortsEx)(
		/*[in]*/ LPCOLESTR wstrRegistryRoot,
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPortsEx)

		VSL_CHECK_VALIDVALUE_STRINGW(wstrRegistryRoot);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortSuppliersExValidValues
	{
		/*[in]*/ LPCOLESTR wstrRegistryRoot;
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPortSuppliersEx)(
		/*[in]*/ LPCOLESTR wstrRegistryRoot,
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPortSuppliersEx)

		VSL_CHECK_VALIDVALUE_STRINGW(wstrRegistryRoot);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMACHINEEX2_V7_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugMessageEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMESSAGEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMESSAGEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugMessageEvent2NotImpl :
	public IDebugMessageEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMessageEvent2NotImpl)

public:

	typedef IDebugMessageEvent2 Interface;

	STDMETHOD(GetMessage)(
		/*[out]*/ MESSAGETYPE* /*pMessageType*/,
		/*[out]*/ BSTR* /*pbstrMessage*/,
		/*[out]*/ DWORD* /*pdwType*/,
		/*[out]*/ BSTR* /*pbstrHelpFileName*/,
		/*[out]*/ DWORD* /*pdwHelpId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetResponse)(
		/*[in]*/ DWORD /*dwResponse*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugMessageEvent2MockImpl :
	public IDebugMessageEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugMessageEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugMessageEvent2MockImpl)

	typedef IDebugMessageEvent2 Interface;
	struct GetMessageValidValues
	{
		/*[out]*/ MESSAGETYPE* pMessageType;
		/*[out]*/ BSTR* pbstrMessage;
		/*[out]*/ DWORD* pdwType;
		/*[out]*/ BSTR* pbstrHelpFileName;
		/*[out]*/ DWORD* pdwHelpId;
		HRESULT retValue;
	};

	STDMETHOD(GetMessage)(
		/*[out]*/ MESSAGETYPE* pMessageType,
		/*[out]*/ BSTR* pbstrMessage,
		/*[out]*/ DWORD* pdwType,
		/*[out]*/ BSTR* pbstrHelpFileName,
		/*[out]*/ DWORD* pdwHelpId)
	{
		VSL_DEFINE_MOCK_METHOD(GetMessage)

		VSL_SET_VALIDVALUE(pMessageType);

		VSL_SET_VALIDVALUE_BSTR(pbstrMessage);

		VSL_SET_VALIDVALUE(pdwType);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpFileName);

		VSL_SET_VALIDVALUE(pdwHelpId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetResponseValidValues
	{
		/*[in]*/ DWORD dwResponse;
		HRESULT retValue;
	};

	STDMETHOD(SetResponse)(
		/*[in]*/ DWORD dwResponse)
	{
		VSL_DEFINE_MOCK_METHOD(SetResponse)

		VSL_CHECK_VALIDVALUE(dwResponse);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMESSAGEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugModule2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMODULE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMODULE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugModule2NotImpl :
	public IDebugModule2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModule2NotImpl)

public:

	typedef IDebugModule2 Interface;

	STDMETHOD(GetInfo)(
		/*[in]*/ MODULE_INFO_FIELDS /*dwFields*/,
		/*[out]*/ MODULE_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReloadSymbols_Deprecated)(
		/*[in,ptr]*/ LPCOLESTR /*pszUrlToSymbols*/,
		/*[out]*/ BSTR* /*pbstrDebugMessage*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugModule2MockImpl :
	public IDebugModule2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModule2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugModule2MockImpl)

	typedef IDebugModule2 Interface;
	struct GetInfoValidValues
	{
		/*[in]*/ MODULE_INFO_FIELDS dwFields;
		/*[out]*/ MODULE_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ MODULE_INFO_FIELDS dwFields,
		/*[out]*/ MODULE_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadSymbols_DeprecatedValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszUrlToSymbols;
		/*[out]*/ BSTR* pbstrDebugMessage;
		HRESULT retValue;
	};

	STDMETHOD(ReloadSymbols_Deprecated)(
		/*[in,ptr]*/ LPCOLESTR pszUrlToSymbols,
		/*[out]*/ BSTR* pbstrDebugMessage)
	{
		VSL_DEFINE_MOCK_METHOD(ReloadSymbols_Deprecated)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrlToSymbols);

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugMessage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMODULE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugModuleManaged.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMODULEMANAGED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMODULEMANAGED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugModuleManagedNotImpl :
	public IDebugModuleManaged
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModuleManagedNotImpl)

public:

	typedef IDebugModuleManaged Interface;

	STDMETHOD(GetMvid)(
		/*[out]*/ GUID* /*mvid*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugModuleManagedMockImpl :
	public IDebugModuleManaged,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModuleManagedMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugModuleManagedMockImpl)

	typedef IDebugModuleManaged Interface;
	struct GetMvidValidValues
	{
		/*[out]*/ GUID* mvid;
		HRESULT retValue;
	};

	STDMETHOD(GetMvid)(
		/*[out]*/ GUID* mvid)
	{
		VSL_DEFINE_MOCK_METHOD(GetMvid)

		VSL_SET_VALIDVALUE(mvid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMODULEMANAGED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugOutputStringEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGOUTPUTSTRINGEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGOUTPUTSTRINGEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugOutputStringEvent2NotImpl :
	public IDebugOutputStringEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugOutputStringEvent2NotImpl)

public:

	typedef IDebugOutputStringEvent2 Interface;

	STDMETHOD(GetString)(
		/*[out]*/ BSTR* /*pbstrString*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugOutputStringEvent2MockImpl :
	public IDebugOutputStringEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugOutputStringEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugOutputStringEvent2MockImpl)

	typedef IDebugOutputStringEvent2 Interface;
	struct GetStringValidValues
	{
		/*[out]*/ BSTR* pbstrString;
		HRESULT retValue;
	};

	STDMETHOD(GetString)(
		/*[out]*/ BSTR* pbstrString)
	{
		VSL_DEFINE_MOCK_METHOD(GetString)

		VSL_SET_VALIDVALUE_BSTR(pbstrString);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGOUTPUTSTRINGEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPendingBreakpoint2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPENDINGBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPENDINGBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPendingBreakpoint2NotImpl :
	public IDebugPendingBreakpoint2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPendingBreakpoint2NotImpl)

public:

	typedef IDebugPendingBreakpoint2 Interface;

	STDMETHOD(CanBind)(
		/*[out]*/ IEnumDebugErrorBreakpoints2** /*ppErrorEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Bind)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[out]*/ PENDING_BP_STATE_INFO* /*pState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBreakpointRequest)(
		/*[out]*/ IDebugBreakpointRequest2** /*ppBPRequest*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Virtualize)(
		/*[in]*/ BOOL /*fVirtualize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Enable)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCondition)(
		/*[in]*/ BP_CONDITION /*bpCondition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPassCount)(
		/*[in]*/ BP_PASSCOUNT /*bpPassCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumBoundBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumErrorBreakpoints)(
		/*[in]*/ BP_ERROR_TYPE /*bpErrorType*/,
		/*[out]*/ IEnumDebugErrorBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Delete)()VSL_STDMETHOD_NOTIMPL
};

class IDebugPendingBreakpoint2MockImpl :
	public IDebugPendingBreakpoint2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPendingBreakpoint2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPendingBreakpoint2MockImpl)

	typedef IDebugPendingBreakpoint2 Interface;
	struct CanBindValidValues
	{
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppErrorEnum;
		HRESULT retValue;
	};

	STDMETHOD(CanBind)(
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppErrorEnum)
	{
		VSL_DEFINE_MOCK_METHOD(CanBind)

		VSL_SET_VALIDVALUE_INTERFACE(ppErrorEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct BindValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Bind)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Bind)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[out]*/ PENDING_BP_STATE_INFO* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[out]*/ PENDING_BP_STATE_INFO* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBreakpointRequestValidValues
	{
		/*[out]*/ IDebugBreakpointRequest2** ppBPRequest;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpointRequest)(
		/*[out]*/ IDebugBreakpointRequest2** ppBPRequest)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpointRequest)

		VSL_SET_VALIDVALUE_INTERFACE(ppBPRequest);

		VSL_RETURN_VALIDVALUES();
	}
	struct VirtualizeValidValues
	{
		/*[in]*/ BOOL fVirtualize;
		HRESULT retValue;
	};

	STDMETHOD(Virtualize)(
		/*[in]*/ BOOL fVirtualize)
	{
		VSL_DEFINE_MOCK_METHOD(Virtualize)

		VSL_CHECK_VALIDVALUE(fVirtualize);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(Enable)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(Enable)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetConditionValidValues
	{
		/*[in]*/ BP_CONDITION bpCondition;
		HRESULT retValue;
	};

	STDMETHOD(SetCondition)(
		/*[in]*/ BP_CONDITION bpCondition)
	{
		VSL_DEFINE_MOCK_METHOD(SetCondition)

		VSL_CHECK_VALIDVALUE(bpCondition);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPassCountValidValues
	{
		/*[in]*/ BP_PASSCOUNT bpPassCount;
		HRESULT retValue;
	};

	STDMETHOD(SetPassCount)(
		/*[in]*/ BP_PASSCOUNT bpPassCount)
	{
		VSL_DEFINE_MOCK_METHOD(SetPassCount)

		VSL_CHECK_VALIDVALUE(bpPassCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumBoundBreakpointsValidValues
	{
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumBoundBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumBoundBreakpoints)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumErrorBreakpointsValidValues
	{
		/*[in]*/ BP_ERROR_TYPE bpErrorType;
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumErrorBreakpoints)(
		/*[in]*/ BP_ERROR_TYPE bpErrorType,
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumErrorBreakpoints)

		VSL_CHECK_VALIDVALUE(bpErrorType);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Delete)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Delete)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPENDINGBREAKPOINT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPendingBreakpoint3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPENDINGBREAKPOINT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPENDINGBREAKPOINT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPendingBreakpoint3NotImpl :
	public IDebugPendingBreakpoint3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPendingBreakpoint3NotImpl)

public:

	typedef IDebugPendingBreakpoint3 Interface;

	STDMETHOD(GetErrorResolutionInfo)(
		/*[in]*/ BPERESI_FIELDS /*dwFields*/,
		/*[out]*/ BP_ERROR_RESOLUTION_INFO* /*pErrorResolutionInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanBind)(
		/*[out]*/ IEnumDebugErrorBreakpoints2** /*ppErrorEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Bind)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[out]*/ PENDING_BP_STATE_INFO* /*pState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBreakpointRequest)(
		/*[out]*/ IDebugBreakpointRequest2** /*ppBPRequest*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Virtualize)(
		/*[in]*/ BOOL /*fVirtualize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Enable)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCondition)(
		/*[in]*/ BP_CONDITION /*bpCondition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPassCount)(
		/*[in]*/ BP_PASSCOUNT /*bpPassCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumBoundBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumErrorBreakpoints)(
		/*[in]*/ BP_ERROR_TYPE /*bpErrorType*/,
		/*[out]*/ IEnumDebugErrorBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Delete)()VSL_STDMETHOD_NOTIMPL
};

class IDebugPendingBreakpoint3MockImpl :
	public IDebugPendingBreakpoint3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPendingBreakpoint3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPendingBreakpoint3MockImpl)

	typedef IDebugPendingBreakpoint3 Interface;
	struct GetErrorResolutionInfoValidValues
	{
		/*[in]*/ BPERESI_FIELDS dwFields;
		/*[out]*/ BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorResolutionInfo)(
		/*[in]*/ BPERESI_FIELDS dwFields,
		/*[out]*/ BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorResolutionInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pErrorResolutionInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanBindValidValues
	{
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppErrorEnum;
		HRESULT retValue;
	};

	STDMETHOD(CanBind)(
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppErrorEnum)
	{
		VSL_DEFINE_MOCK_METHOD(CanBind)

		VSL_SET_VALIDVALUE_INTERFACE(ppErrorEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct BindValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Bind)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Bind)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[out]*/ PENDING_BP_STATE_INFO* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[out]*/ PENDING_BP_STATE_INFO* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBreakpointRequestValidValues
	{
		/*[out]*/ IDebugBreakpointRequest2** ppBPRequest;
		HRESULT retValue;
	};

	STDMETHOD(GetBreakpointRequest)(
		/*[out]*/ IDebugBreakpointRequest2** ppBPRequest)
	{
		VSL_DEFINE_MOCK_METHOD(GetBreakpointRequest)

		VSL_SET_VALIDVALUE_INTERFACE(ppBPRequest);

		VSL_RETURN_VALIDVALUES();
	}
	struct VirtualizeValidValues
	{
		/*[in]*/ BOOL fVirtualize;
		HRESULT retValue;
	};

	STDMETHOD(Virtualize)(
		/*[in]*/ BOOL fVirtualize)
	{
		VSL_DEFINE_MOCK_METHOD(Virtualize)

		VSL_CHECK_VALIDVALUE(fVirtualize);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(Enable)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(Enable)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetConditionValidValues
	{
		/*[in]*/ BP_CONDITION bpCondition;
		HRESULT retValue;
	};

	STDMETHOD(SetCondition)(
		/*[in]*/ BP_CONDITION bpCondition)
	{
		VSL_DEFINE_MOCK_METHOD(SetCondition)

		VSL_CHECK_VALIDVALUE(bpCondition);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPassCountValidValues
	{
		/*[in]*/ BP_PASSCOUNT bpPassCount;
		HRESULT retValue;
	};

	STDMETHOD(SetPassCount)(
		/*[in]*/ BP_PASSCOUNT bpPassCount)
	{
		VSL_DEFINE_MOCK_METHOD(SetPassCount)

		VSL_CHECK_VALIDVALUE(bpPassCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumBoundBreakpointsValidValues
	{
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumBoundBreakpoints)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumBoundBreakpoints)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumErrorBreakpointsValidValues
	{
		/*[in]*/ BP_ERROR_TYPE bpErrorType;
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumErrorBreakpoints)(
		/*[in]*/ BP_ERROR_TYPE bpErrorType,
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumErrorBreakpoints)

		VSL_CHECK_VALIDVALUE(bpErrorType);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Delete)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Delete)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPENDINGBREAKPOINT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugModuleLoadEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMODULELOADEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMODULELOADEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugModuleLoadEvent2NotImpl :
	public IDebugModuleLoadEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModuleLoadEvent2NotImpl)

public:

	typedef IDebugModuleLoadEvent2 Interface;

	STDMETHOD(GetModule)(
		/*[out]*/ IDebugModule2** /*pModule*/,
		/*[in,out]*/ BSTR* /*pbstrDebugMessage*/,
		/*[in,out]*/ BOOL* /*pbLoad*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugModuleLoadEvent2MockImpl :
	public IDebugModuleLoadEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModuleLoadEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugModuleLoadEvent2MockImpl)

	typedef IDebugModuleLoadEvent2 Interface;
	struct GetModuleValidValues
	{
		/*[out]*/ IDebugModule2** pModule;
		/*[in,out]*/ BSTR* pbstrDebugMessage;
		/*[in,out]*/ BOOL* pbLoad;
		HRESULT retValue;
	};

	STDMETHOD(GetModule)(
		/*[out]*/ IDebugModule2** pModule,
		/*[in,out]*/ BSTR* pbstrDebugMessage,
		/*[in,out]*/ BOOL* pbLoad)
	{
		VSL_DEFINE_MOCK_METHOD(GetModule)

		VSL_SET_VALIDVALUE_INTERFACE(pModule);

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugMessage);

		VSL_SET_VALIDVALUE(pbLoad);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMODULELOADEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugModule3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGMODULE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGMODULE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugModule3NotImpl :
	public IDebugModule3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModule3NotImpl)

public:

	typedef IDebugModule3 Interface;

	STDMETHOD(GetSymbolInfo)(
		/*[in]*/ SYMBOL_SEARCH_INFO_FIELDS /*dwFields*/,
		/*[out]*/ MODULE_SYMBOL_SEARCH_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadSymbols)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsUserCode)(
		/*[out]*/ BOOL* /*pfUser*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetJustMyCodeState)(
		/*[in]*/ BOOL /*fIsUserCode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ MODULE_INFO_FIELDS /*dwFields*/,
		/*[out]*/ MODULE_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReloadSymbols_Deprecated)(
		/*[in,ptr]*/ LPCOLESTR /*pszUrlToSymbols*/,
		/*[out]*/ BSTR* /*pbstrDebugMessage*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugModule3MockImpl :
	public IDebugModule3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugModule3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugModule3MockImpl)

	typedef IDebugModule3 Interface;
	struct GetSymbolInfoValidValues
	{
		/*[in]*/ SYMBOL_SEARCH_INFO_FIELDS dwFields;
		/*[out]*/ MODULE_SYMBOL_SEARCH_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetSymbolInfo)(
		/*[in]*/ SYMBOL_SEARCH_INFO_FIELDS dwFields,
		/*[out]*/ MODULE_SYMBOL_SEARCH_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetSymbolInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadSymbolsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LoadSymbols)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LoadSymbols)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsUserCodeValidValues
	{
		/*[out]*/ BOOL* pfUser;
		HRESULT retValue;
	};

	STDMETHOD(IsUserCode)(
		/*[out]*/ BOOL* pfUser)
	{
		VSL_DEFINE_MOCK_METHOD(IsUserCode)

		VSL_SET_VALIDVALUE(pfUser);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetJustMyCodeStateValidValues
	{
		/*[in]*/ BOOL fIsUserCode;
		HRESULT retValue;
	};

	STDMETHOD(SetJustMyCodeState)(
		/*[in]*/ BOOL fIsUserCode)
	{
		VSL_DEFINE_MOCK_METHOD(SetJustMyCodeState)

		VSL_CHECK_VALIDVALUE(fIsUserCode);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ MODULE_INFO_FIELDS dwFields;
		/*[out]*/ MODULE_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ MODULE_INFO_FIELDS dwFields,
		/*[out]*/ MODULE_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadSymbols_DeprecatedValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszUrlToSymbols;
		/*[out]*/ BSTR* pbstrDebugMessage;
		HRESULT retValue;
	};

	STDMETHOD(ReloadSymbols_Deprecated)(
		/*[in,ptr]*/ LPCOLESTR pszUrlToSymbols,
		/*[out]*/ BSTR* pbstrDebugMessage)
	{
		VSL_DEFINE_MOCK_METHOD(ReloadSymbols_Deprecated)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrlToSymbols);

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugMessage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGMODULE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugNativeExceptionInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGNATIVEEXCEPTIONINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGNATIVEEXCEPTIONINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugNativeExceptionInfoNotImpl :
	public IDebugNativeExceptionInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugNativeExceptionInfoNotImpl)

public:

	typedef IDebugNativeExceptionInfo Interface;

	STDMETHOD(GetNativeException)(
		/*[out]*/ NATIVE_EXCEPTION_INFO* /*pExceptionInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugNativeExceptionInfoMockImpl :
	public IDebugNativeExceptionInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugNativeExceptionInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugNativeExceptionInfoMockImpl)

	typedef IDebugNativeExceptionInfo Interface;
	struct GetNativeExceptionValidValues
	{
		/*[out]*/ NATIVE_EXCEPTION_INFO* pExceptionInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetNativeException)(
		/*[out]*/ NATIVE_EXCEPTION_INFO* pExceptionInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetNativeException)

		VSL_SET_VALIDVALUE(pExceptionInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGNATIVEEXCEPTIONINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortNotify2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTNOTIFY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTNOTIFY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortNotify2NotImpl :
	public IDebugPortNotify2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortNotify2NotImpl)

public:

	typedef IDebugPortNotify2 Interface;

	STDMETHOD(AddProgramNode)(
		/*[in]*/ IDebugProgramNode2* /*pProgramNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveProgramNode)(
		/*[in]*/ IDebugProgramNode2* /*pProgramNode*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortNotify2MockImpl :
	public IDebugPortNotify2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortNotify2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortNotify2MockImpl)

	typedef IDebugPortNotify2 Interface;
	struct AddProgramNodeValidValues
	{
		/*[in]*/ IDebugProgramNode2* pProgramNode;
		HRESULT retValue;
	};

	STDMETHOD(AddProgramNode)(
		/*[in]*/ IDebugProgramNode2* pProgramNode)
	{
		VSL_DEFINE_MOCK_METHOD(AddProgramNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgramNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveProgramNodeValidValues
	{
		/*[in]*/ IDebugProgramNode2* pProgramNode;
		HRESULT retValue;
	};

	STDMETHOD(RemoveProgramNode)(
		/*[in]*/ IDebugProgramNode2* pProgramNode)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveProgramNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgramNode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTNOTIFY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortRequest2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortRequest2NotImpl :
	public IDebugPortRequest2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortRequest2NotImpl)

public:

	typedef IDebugPortRequest2 Interface;

	STDMETHOD(GetPortName)(
		/*[out]*/ BSTR* /*pbstrPortName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortRequest2MockImpl :
	public IDebugPortRequest2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortRequest2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortRequest2MockImpl)

	typedef IDebugPortRequest2 Interface;
	struct GetPortNameValidValues
	{
		/*[out]*/ BSTR* pbstrPortName;
		HRESULT retValue;
	};

	STDMETHOD(GetPortName)(
		/*[out]*/ BSTR* pbstrPortName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortName)

		VSL_SET_VALIDVALUE_BSTR(pbstrPortName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTREQUEST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPort2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPort2NotImpl :
	public IDebugPort2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPort2NotImpl)

public:

	typedef IDebugPort2 Interface;

	STDMETHOD(GetPortName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortId)(
		/*[out]*/ GUID* /*pguidPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortRequest)(
		/*[out]*/ IDebugPortRequest2** /*ppRequest*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplier)(
		/*[out]*/ IDebugPortSupplier2** /*ppSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcess)(
		/*[in]*/ AD_PROCESS_ID /*ProcessId*/,
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPort2MockImpl :
	public IDebugPort2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPort2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPort2MockImpl)

	typedef IDebugPort2 Interface;
	struct GetPortNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetPortName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortIdValidValues
	{
		/*[out]*/ GUID* pguidPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPortId)(
		/*[out]*/ GUID* pguidPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortId)

		VSL_SET_VALIDVALUE(pguidPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortRequestValidValues
	{
		/*[out]*/ IDebugPortRequest2** ppRequest;
		HRESULT retValue;
	};

	STDMETHOD(GetPortRequest)(
		/*[out]*/ IDebugPortRequest2** ppRequest)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortRequest)

		VSL_SET_VALIDVALUE_INTERFACE(ppRequest);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierValidValues
	{
		/*[out]*/ IDebugPortSupplier2** ppSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplier)(
		/*[out]*/ IDebugPortSupplier2** ppSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplier)

		VSL_SET_VALIDVALUE_INTERFACE(ppSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessValidValues
	{
		/*[in]*/ AD_PROCESS_ID ProcessId;
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(GetProcess)(
		/*[in]*/ AD_PROCESS_ID ProcessId,
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcess)

		VSL_CHECK_VALIDVALUE(ProcessId);

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProcessesValidValues
	{
		/*[out]*/ IEnumDebugProcesses2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProcesses)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortEvents2NotImpl :
	public IDebugPortEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortEvents2NotImpl)

public:

	typedef IDebugPortEvents2 Interface;

	STDMETHOD(Event)(
		/*[in]*/ IDebugCoreServer2* /*pServer*/,
		/*[in]*/ IDebugPort2* /*pPort*/,
		/*[in]*/ IDebugProcess2* /*pProcess*/,
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in]*/ IDebugEvent2* /*pEvent*/,
		/*[in]*/ REFIID /*riidEvent*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortEvents2MockImpl :
	public IDebugPortEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortEvents2MockImpl)

	typedef IDebugPortEvents2 Interface;
	struct EventValidValues
	{
		/*[in]*/ IDebugCoreServer2* pServer;
		/*[in]*/ IDebugPort2* pPort;
		/*[in]*/ IDebugProcess2* pProcess;
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in]*/ IDebugEvent2* pEvent;
		/*[in]*/ REFIID riidEvent;
		HRESULT retValue;
	};

	STDMETHOD(Event)(
		/*[in]*/ IDebugCoreServer2* pServer,
		/*[in]*/ IDebugPort2* pPort,
		/*[in]*/ IDebugProcess2* pProcess,
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in]*/ IDebugEvent2* pEvent,
		/*[in]*/ REFIID riidEvent)
	{
		VSL_DEFINE_MOCK_METHOD(Event)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pServer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvent);

		VSL_CHECK_VALIDVALUE(riidEvent);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortSupplierDescription2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTSUPPLIERDESCRIPTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTSUPPLIERDESCRIPTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortSupplierDescription2NotImpl :
	public IDebugPortSupplierDescription2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortSupplierDescription2NotImpl)

public:

	typedef IDebugPortSupplierDescription2 Interface;

	STDMETHOD(GetDescription)(
		/*[out]*/ PORT_SUPPLIER_DESCRIPTION_FLAGS* /*pdwFlags*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortSupplierDescription2MockImpl :
	public IDebugPortSupplierDescription2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortSupplierDescription2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortSupplierDescription2MockImpl)

	typedef IDebugPortSupplierDescription2 Interface;
	struct GetDescriptionValidValues
	{
		/*[out]*/ PORT_SUPPLIER_DESCRIPTION_FLAGS* pdwFlags;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ PORT_SUPPLIER_DESCRIPTION_FLAGS* pdwFlags,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTSUPPLIERDESCRIPTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortSupplier3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTSUPPLIER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTSUPPLIER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortSupplier3NotImpl :
	public IDebugPortSupplier3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortSupplier3NotImpl)

public:

	typedef IDebugPortSupplier3 Interface;

	STDMETHOD(CanPersistPorts)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPersistedPorts)(
		/*[in]*/ BSTR_ARRAY /*PortNames*/,
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplierName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplierId)(
		/*[out]*/ GUID* /*pguidPortSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID /*guidPort*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanAddPort)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddPort)(
		/*[in]*/ IDebugPortRequest2* /*pRequest*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemovePort)(
		/*[in]*/ IDebugPort2* /*pPort*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortSupplier3MockImpl :
	public IDebugPortSupplier3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortSupplier3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortSupplier3MockImpl)

	typedef IDebugPortSupplier3 Interface;
	struct CanPersistPortsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanPersistPorts)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanPersistPorts)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPersistedPortsValidValues
	{
		/*[in]*/ BSTR_ARRAY PortNames;
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPersistedPorts)(
		/*[in]*/ BSTR_ARRAY PortNames,
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPersistedPorts)

		VSL_CHECK_VALIDVALUE(PortNames);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplierName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplierName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierIdValidValues
	{
		/*[out]*/ GUID* pguidPortSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplierId)(
		/*[out]*/ GUID* pguidPortSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplierId)

		VSL_SET_VALIDVALUE(pguidPortSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortValidValues
	{
		/*[in]*/ REFGUID guidPort;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID guidPort,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPort)

		VSL_CHECK_VALIDVALUE(guidPort);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortsValidValues
	{
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPorts)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanAddPortValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanAddPort)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanAddPort)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddPortValidValues
	{
		/*[in]*/ IDebugPortRequest2* pRequest;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(AddPort)(
		/*[in]*/ IDebugPortRequest2* pRequest,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(AddPort)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRequest);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePortValidValues
	{
		/*[in]*/ IDebugPort2* pPort;
		HRESULT retValue;
	};

	STDMETHOD(RemovePort)(
		/*[in]*/ IDebugPort2* pPort)
	{
		VSL_DEFINE_MOCK_METHOD(RemovePort)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTSUPPLIER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortPicker.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTPICKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTPICKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortPickerNotImpl :
	public IDebugPortPicker
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortPickerNotImpl)

public:

	typedef IDebugPortPicker Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayPortPicker)(
		/*[in]*/ HWND /*hwndParentDialog*/,
		/*[out]*/ BSTR* /*pbstrPortId*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortPickerMockImpl :
	public IDebugPortPicker,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortPickerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortPickerMockImpl)

	typedef IDebugPortPicker Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayPortPickerValidValues
	{
		/*[in]*/ HWND hwndParentDialog;
		/*[out]*/ BSTR* pbstrPortId;
		HRESULT retValue;
	};

	STDMETHOD(DisplayPortPicker)(
		/*[in]*/ HWND hwndParentDialog,
		/*[out]*/ BSTR* pbstrPortId)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayPortPicker)

		VSL_CHECK_VALIDVALUE(hwndParentDialog);

		VSL_SET_VALIDVALUE_BSTR(pbstrPortId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTPICKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPortSupplier2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPORTSUPPLIER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPORTSUPPLIER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPortSupplier2NotImpl :
	public IDebugPortSupplier2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortSupplier2NotImpl)

public:

	typedef IDebugPortSupplier2 Interface;

	STDMETHOD(GetPortSupplierName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPortSupplierId)(
		/*[out]*/ GUID* /*pguidPortSupplier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID /*guidPort*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanAddPort)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddPort)(
		/*[in]*/ IDebugPortRequest2* /*pRequest*/,
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemovePort)(
		/*[in]*/ IDebugPort2* /*pPort*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPortSupplier2MockImpl :
	public IDebugPortSupplier2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPortSupplier2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPortSupplier2MockImpl)

	typedef IDebugPortSupplier2 Interface;
	struct GetPortSupplierNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplierName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplierName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortSupplierIdValidValues
	{
		/*[out]*/ GUID* pguidPortSupplier;
		HRESULT retValue;
	};

	STDMETHOD(GetPortSupplierId)(
		/*[out]*/ GUID* pguidPortSupplier)
	{
		VSL_DEFINE_MOCK_METHOD(GetPortSupplierId)

		VSL_SET_VALIDVALUE(pguidPortSupplier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortValidValues
	{
		/*[in]*/ REFGUID guidPort;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPort)(
		/*[in]*/ REFGUID guidPort,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPort)

		VSL_CHECK_VALIDVALUE(guidPort);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPortsValidValues
	{
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPorts)(
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPorts)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanAddPortValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanAddPort)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanAddPort)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddPortValidValues
	{
		/*[in]*/ IDebugPortRequest2* pRequest;
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(AddPort)(
		/*[in]*/ IDebugPortRequest2* pRequest,
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(AddPort)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRequest);

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePortValidValues
	{
		/*[in]*/ IDebugPort2* pPort;
		HRESULT retValue;
	};

	STDMETHOD(RemovePort)(
		/*[in]*/ IDebugPort2* pPort)
	{
		VSL_DEFINE_MOCK_METHOD(RemovePort)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPORTSUPPLIER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProcess2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROCESS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROCESS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProcess2NotImpl :
	public IDebugProcess2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcess2NotImpl)

public:

	typedef IDebugProcess2 Interface;

	STDMETHOD(GetInfo)(
		/*[in]*/ PROCESS_INFO_FIELDS /*Fields*/,
		/*[out]*/ PROCESS_INFO* /*pProcessInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE /*gnType*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetServer)(
		/*[out]*/ IDebugCoreServer2** /*ppServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[out,size_is(celtSpecificEngines),length_is(celtSpecificEngines)]*/ HRESULT* /*rghrEngineAttach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDetach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPhysicalProcessId)(
		/*[out]*/ AD_PROCESS_ID* /*pProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcessId)(
		/*[out]*/ GUID* /*pguidProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttachedSessionName)(
		/*[out]*/ BSTR* /*pbstrSessionName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPort)(
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProcess2MockImpl :
	public IDebugProcess2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcess2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProcess2MockImpl)

	typedef IDebugProcess2 Interface;
	struct GetInfoValidValues
	{
		/*[in]*/ PROCESS_INFO_FIELDS Fields;
		/*[out]*/ PROCESS_INFO* pProcessInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ PROCESS_INFO_FIELDS Fields,
		/*[out]*/ PROCESS_INFO* pProcessInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(Fields);

		VSL_SET_VALIDVALUE(pProcessInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProgramsValidValues
	{
		/*[out]*/ IEnumDebugPrograms2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPrograms)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[in]*/ GETNAME_TYPE gnType;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE gnType,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE(gnType);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetServerValidValues
	{
		/*[out]*/ IDebugCoreServer2** ppServer;
		HRESULT retValue;
	};

	STDMETHOD(GetServer)(
		/*[out]*/ IDebugCoreServer2** ppServer)
	{
		VSL_DEFINE_MOCK_METHOD(GetServer)

		VSL_SET_VALIDVALUE_INTERFACE(ppServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Terminate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Terminate)

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[out,size_is(celtSpecificEngines),length_is(celtSpecificEngines)]*/ HRESULT* rghrEngineAttach;
		HRESULT retValue;
	};

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[out,size_is(celtSpecificEngines),length_is(celtSpecificEngines)]*/ HRESULT* rghrEngineAttach)
	{
		VSL_DEFINE_MOCK_METHOD(Attach)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_SET_VALIDVALUE_MEMCPY(rghrEngineAttach, celtSpecificEngines*sizeof(rghrEngineAttach[0]), validValues.celtSpecificEngines*sizeof(validValues.rghrEngineAttach[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanDetach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanDetach)

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPhysicalProcessIdValidValues
	{
		/*[out]*/ AD_PROCESS_ID* pProcessId;
		HRESULT retValue;
	};

	STDMETHOD(GetPhysicalProcessId)(
		/*[out]*/ AD_PROCESS_ID* pProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(GetPhysicalProcessId)

		VSL_SET_VALIDVALUE(pProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessIdValidValues
	{
		/*[out]*/ GUID* pguidProcessId;
		HRESULT retValue;
	};

	STDMETHOD(GetProcessId)(
		/*[out]*/ GUID* pguidProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcessId)

		VSL_SET_VALIDVALUE(pguidProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttachedSessionNameValidValues
	{
		/*[out]*/ BSTR* pbstrSessionName;
		HRESULT retValue;
	};

	STDMETHOD(GetAttachedSessionName)(
		/*[out]*/ BSTR* pbstrSessionName)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttachedSessionName)

		VSL_SET_VALIDVALUE_BSTR(pbstrSessionName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumThreadsValidValues
	{
		/*[out]*/ IEnumDebugThreads2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumThreads)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortValidValues
	{
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPort)(
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPort)

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROCESS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProcess3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROCESS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROCESS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProcess3NotImpl :
	public IDebugProcess3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcess3NotImpl)

public:

	typedef IDebugProcess3 Interface;

	STDMETHOD(Execute)(
		/*[in]*/ IDebugThread2* /*pThread*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Continue)(
		/*[in]*/ IDebugThread2* /*pThread*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Step)(
		/*[in]*/ IDebugThread2* /*pThread*/,
		/*[in]*/ STEPKIND /*sk*/,
		/*[in]*/ STEPUNIT /*step*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDebugReason)(
		/*[out]*/ DEBUG_REASON* /*pReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHostingProcessLanguage)(
		/*[in]*/ REFGUID /*guidLang*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostingProcessLanguage)(
		/*[out]*/ GUID* /*pguidLang*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisableENC)(
		/*[in]*/ EncUnavailableReason /*reason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCAvailableState)(
		/*[out]*/ EncUnavailableReason* /*preason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineFilter)(
		/*[out]*/ GUID_ARRAY* /*pEngineArray*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ PROCESS_INFO_FIELDS /*Fields*/,
		/*[out]*/ PROCESS_INFO* /*pProcessInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE /*gnType*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetServer)(
		/*[out]*/ IDebugCoreServer2** /*ppServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[out,size_is(celtSpecificEngines),length_is(celtSpecificEngines)]*/ HRESULT* /*rghrEngineAttach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDetach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPhysicalProcessId)(
		/*[out]*/ AD_PROCESS_ID* /*pProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcessId)(
		/*[out]*/ GUID* /*pguidProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttachedSessionName)(
		/*[out]*/ BSTR* /*pbstrSessionName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPort)(
		/*[out]*/ IDebugPort2** /*ppPort*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProcess3MockImpl :
	public IDebugProcess3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcess3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProcess3MockImpl)

	typedef IDebugProcess3 Interface;
	struct ExecuteValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		HRESULT retValue;
	};

	STDMETHOD(Execute)(
		/*[in]*/ IDebugThread2* pThread)
	{
		VSL_DEFINE_MOCK_METHOD(Execute)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContinueValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		HRESULT retValue;
	};

	STDMETHOD(Continue)(
		/*[in]*/ IDebugThread2* pThread)
	{
		VSL_DEFINE_MOCK_METHOD(Continue)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_RETURN_VALIDVALUES();
	}
	struct StepValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		/*[in]*/ STEPKIND sk;
		/*[in]*/ STEPUNIT step;
		HRESULT retValue;
	};

	STDMETHOD(Step)(
		/*[in]*/ IDebugThread2* pThread,
		/*[in]*/ STEPKIND sk,
		/*[in]*/ STEPUNIT step)
	{
		VSL_DEFINE_MOCK_METHOD(Step)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_CHECK_VALIDVALUE(sk);

		VSL_CHECK_VALIDVALUE(step);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDebugReasonValidValues
	{
		/*[out]*/ DEBUG_REASON* pReason;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugReason)(
		/*[out]*/ DEBUG_REASON* pReason)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugReason)

		VSL_SET_VALIDVALUE(pReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHostingProcessLanguageValidValues
	{
		/*[in]*/ REFGUID guidLang;
		HRESULT retValue;
	};

	STDMETHOD(SetHostingProcessLanguage)(
		/*[in]*/ REFGUID guidLang)
	{
		VSL_DEFINE_MOCK_METHOD(SetHostingProcessLanguage)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostingProcessLanguageValidValues
	{
		/*[out]*/ GUID* pguidLang;
		HRESULT retValue;
	};

	STDMETHOD(GetHostingProcessLanguage)(
		/*[out]*/ GUID* pguidLang)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostingProcessLanguage)

		VSL_SET_VALIDVALUE(pguidLang);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisableENCValidValues
	{
		/*[in]*/ EncUnavailableReason reason;
		HRESULT retValue;
	};

	STDMETHOD(DisableENC)(
		/*[in]*/ EncUnavailableReason reason)
	{
		VSL_DEFINE_MOCK_METHOD(DisableENC)

		VSL_CHECK_VALIDVALUE(reason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCAvailableStateValidValues
	{
		/*[out]*/ EncUnavailableReason* preason;
		HRESULT retValue;
	};

	STDMETHOD(GetENCAvailableState)(
		/*[out]*/ EncUnavailableReason* preason)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCAvailableState)

		VSL_SET_VALIDVALUE(preason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineFilterValidValues
	{
		/*[out]*/ GUID_ARRAY* pEngineArray;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineFilter)(
		/*[out]*/ GUID_ARRAY* pEngineArray)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineFilter)

		VSL_SET_VALIDVALUE(pEngineArray);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ PROCESS_INFO_FIELDS Fields;
		/*[out]*/ PROCESS_INFO* pProcessInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ PROCESS_INFO_FIELDS Fields,
		/*[out]*/ PROCESS_INFO* pProcessInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(Fields);

		VSL_SET_VALIDVALUE(pProcessInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProgramsValidValues
	{
		/*[out]*/ IEnumDebugPrograms2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPrograms)(
		/*[out]*/ IEnumDebugPrograms2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPrograms)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[in]*/ GETNAME_TYPE gnType;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ GETNAME_TYPE gnType,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE(gnType);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetServerValidValues
	{
		/*[out]*/ IDebugCoreServer2** ppServer;
		HRESULT retValue;
	};

	STDMETHOD(GetServer)(
		/*[out]*/ IDebugCoreServer2** ppServer)
	{
		VSL_DEFINE_MOCK_METHOD(GetServer)

		VSL_SET_VALIDVALUE_INTERFACE(ppServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Terminate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Terminate)

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[out,size_is(celtSpecificEngines),length_is(celtSpecificEngines)]*/ HRESULT* rghrEngineAttach;
		HRESULT retValue;
	};

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[out,size_is(celtSpecificEngines),length_is(celtSpecificEngines)]*/ HRESULT* rghrEngineAttach)
	{
		VSL_DEFINE_MOCK_METHOD(Attach)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_SET_VALIDVALUE_MEMCPY(rghrEngineAttach, celtSpecificEngines*sizeof(rghrEngineAttach[0]), validValues.celtSpecificEngines*sizeof(validValues.rghrEngineAttach[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanDetach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanDetach)

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPhysicalProcessIdValidValues
	{
		/*[out]*/ AD_PROCESS_ID* pProcessId;
		HRESULT retValue;
	};

	STDMETHOD(GetPhysicalProcessId)(
		/*[out]*/ AD_PROCESS_ID* pProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(GetPhysicalProcessId)

		VSL_SET_VALIDVALUE(pProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessIdValidValues
	{
		/*[out]*/ GUID* pguidProcessId;
		HRESULT retValue;
	};

	STDMETHOD(GetProcessId)(
		/*[out]*/ GUID* pguidProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcessId)

		VSL_SET_VALIDVALUE(pguidProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttachedSessionNameValidValues
	{
		/*[out]*/ BSTR* pbstrSessionName;
		HRESULT retValue;
	};

	STDMETHOD(GetAttachedSessionName)(
		/*[out]*/ BSTR* pbstrSessionName)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttachedSessionName)

		VSL_SET_VALIDVALUE_BSTR(pbstrSessionName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumThreadsValidValues
	{
		/*[out]*/ IEnumDebugThreads2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumThreads)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPortValidValues
	{
		/*[out]*/ IDebugPort2** ppPort;
		HRESULT retValue;
	};

	STDMETHOD(GetPort)(
		/*[out]*/ IDebugPort2** ppPort)
	{
		VSL_DEFINE_MOCK_METHOD(GetPort)

		VSL_SET_VALIDVALUE_INTERFACE(ppPort);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROCESS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProcessQueryProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROCESSQUERYPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROCESSQUERYPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProcessQueryPropertiesNotImpl :
	public IDebugProcessQueryProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcessQueryPropertiesNotImpl)

public:

	typedef IDebugProcessQueryProperties Interface;

	STDMETHOD(QueryProperty)(
		/*[in]*/ PROCESS_PROPERTY_TYPE /*dwPropType*/,
		/*[out]*/ VARIANT* /*pvarPropValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryProperties)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,size_is(celt)]*/ PROCESS_PROPERTY_TYPE* /*rgdwPropTypes*/,
		/*[out,size_is(celt)]*/ VARIANT* /*rgtPropValues*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProcessQueryPropertiesMockImpl :
	public IDebugProcessQueryProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcessQueryPropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProcessQueryPropertiesMockImpl)

	typedef IDebugProcessQueryProperties Interface;
	struct QueryPropertyValidValues
	{
		/*[in]*/ PROCESS_PROPERTY_TYPE dwPropType;
		/*[out]*/ VARIANT* pvarPropValue;
		HRESULT retValue;
	};

	STDMETHOD(QueryProperty)(
		/*[in]*/ PROCESS_PROPERTY_TYPE dwPropType,
		/*[out]*/ VARIANT* pvarPropValue)
	{
		VSL_DEFINE_MOCK_METHOD(QueryProperty)

		VSL_CHECK_VALIDVALUE(dwPropType);

		VSL_SET_VALIDVALUE_VARIANT(pvarPropValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryPropertiesValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,size_is(celt)]*/ PROCESS_PROPERTY_TYPE* rgdwPropTypes;
		/*[out,size_is(celt)]*/ VARIANT* rgtPropValues;
		HRESULT retValue;
	};

	STDMETHOD(QueryProperties)(
		/*[in]*/ ULONG celt,
		/*[in,size_is(celt)]*/ PROCESS_PROPERTY_TYPE* rgdwPropTypes,
		/*[out,size_is(celt)]*/ VARIANT* rgtPropValues)
	{
		VSL_DEFINE_MOCK_METHOD(QueryProperties)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwPropTypes, celt*sizeof(rgdwPropTypes[0]), validValues.celt*sizeof(validValues.rgdwPropTypes[0]));

		VSL_SET_VALIDVALUE_MEMCPY(rgtPropValues, celt*sizeof(rgtPropValues[0]), validValues.celt*sizeof(validValues.rgtPropValues[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROCESSQUERYPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramDestroyEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramDestroyEvent2NotImpl :
	public IDebugProgramDestroyEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramDestroyEvent2NotImpl)

public:

	typedef IDebugProgramDestroyEvent2 Interface;

	STDMETHOD(GetExitCode)(
		/*[out]*/ DWORD* /*pdwExit*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramDestroyEvent2MockImpl :
	public IDebugProgramDestroyEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramDestroyEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramDestroyEvent2MockImpl)

	typedef IDebugProgramDestroyEvent2 Interface;
	struct GetExitCodeValidValues
	{
		/*[out]*/ DWORD* pdwExit;
		HRESULT retValue;
	};

	STDMETHOD(GetExitCode)(
		/*[out]*/ DWORD* pdwExit)
	{
		VSL_DEFINE_MOCK_METHOD(GetExitCode)

		VSL_SET_VALIDVALUE(pdwExit);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgram3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAM3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAM3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgram3NotImpl :
	public IDebugProgram3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgram3NotImpl)

public:

	typedef IDebugProgram3 Interface;

	STDMETHOD(ExecuteOnThread)(
		/*[in]*/ IDebugThread2* /*pThread*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcess)(
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDetach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProgramId)(
		/*[out]*/ GUID* /*pguidProgramId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Execute)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Continue)(
		/*[in]*/ IDebugThread2* /*pThread*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Step)(
		/*[in]*/ IDebugThread2* /*pThread*/,
		/*[in]*/ STEPKIND /*sk*/,
		/*[in]*/ STEPUNIT /*step*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineInfo)(
		/*[out]*/ BSTR* /*pbstrEngine*/,
		/*[out]*/ GUID* /*pguidEngine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugDocumentPosition2* /*pDocPos*/,
		/*[out]*/ IEnumDebugCodeContexts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisassemblyStream)(
		/*[in]*/ DISASSEMBLY_STREAM_SCOPE /*dwScope*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/,
		/*[out]*/ IDebugDisassemblyStream2** /*ppDisassemblyStream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumModules)(
		/*[out]*/ IEnumDebugModules2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCUpdate)(
		/*[out]*/ IDebugENCUpdate** /*ppUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodePaths)(
		/*[in,ptr]*/ LPCOLESTR /*pszHint*/,
		/*[in]*/ IDebugCodeContext2* /*pStart*/,
		/*[in]*/ IDebugStackFrame2* /*pFrame*/,
		/*[in]*/ BOOL /*fSource*/,
		/*[out]*/ IEnumCodePaths2** /*ppEnum*/,
		/*[out]*/ IDebugCodeContext2** /*ppSafety*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteDump)(
		/*[in]*/ DUMPTYPE /*DumpType*/,
		/*[in]*/ LPCOLESTR /*pszDumpUrl*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgram3MockImpl :
	public IDebugProgram3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgram3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgram3MockImpl)

	typedef IDebugProgram3 Interface;
	struct ExecuteOnThreadValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		HRESULT retValue;
	};

	STDMETHOD(ExecuteOnThread)(
		/*[in]*/ IDebugThread2* pThread)
	{
		VSL_DEFINE_MOCK_METHOD(ExecuteOnThread)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumThreadsValidValues
	{
		/*[out]*/ IEnumDebugThreads2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumThreads)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessValidValues
	{
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(GetProcess)(
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcess)

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Terminate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Terminate)

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		HRESULT retValue;
	};

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* pCallback)
	{
		VSL_DEFINE_MOCK_METHOD(Attach)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanDetach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanDetach)

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProgramIdValidValues
	{
		/*[out]*/ GUID* pguidProgramId;
		HRESULT retValue;
	};

	STDMETHOD(GetProgramId)(
		/*[out]*/ GUID* pguidProgramId)
	{
		VSL_DEFINE_MOCK_METHOD(GetProgramId)

		VSL_SET_VALIDVALUE(pguidProgramId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDebugPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecuteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Execute)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Execute)

		VSL_RETURN_VALIDVALUES();
	}
	struct ContinueValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		HRESULT retValue;
	};

	STDMETHOD(Continue)(
		/*[in]*/ IDebugThread2* pThread)
	{
		VSL_DEFINE_MOCK_METHOD(Continue)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_RETURN_VALIDVALUES();
	}
	struct StepValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		/*[in]*/ STEPKIND sk;
		/*[in]*/ STEPUNIT step;
		HRESULT retValue;
	};

	STDMETHOD(Step)(
		/*[in]*/ IDebugThread2* pThread,
		/*[in]*/ STEPKIND sk,
		/*[in]*/ STEPUNIT step)
	{
		VSL_DEFINE_MOCK_METHOD(Step)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_CHECK_VALIDVALUE(sk);

		VSL_CHECK_VALIDVALUE(step);

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineInfoValidValues
	{
		/*[out]*/ BSTR* pbstrEngine;
		/*[out]*/ GUID* pguidEngine;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineInfo)(
		/*[out]*/ BSTR* pbstrEngine,
		/*[out]*/ GUID* pguidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrEngine);

		VSL_SET_VALIDVALUE(pguidEngine);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodeContextsValidValues
	{
		/*[in]*/ IDebugDocumentPosition2* pDocPos;
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugDocumentPosition2* pDocPos,
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodeContexts)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDocPos);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisassemblyStreamValidValues
	{
		/*[in]*/ DISASSEMBLY_STREAM_SCOPE dwScope;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		/*[out]*/ IDebugDisassemblyStream2** ppDisassemblyStream;
		HRESULT retValue;
	};

	STDMETHOD(GetDisassemblyStream)(
		/*[in]*/ DISASSEMBLY_STREAM_SCOPE dwScope,
		/*[in]*/ IDebugCodeContext2* pCodeContext,
		/*[out]*/ IDebugDisassemblyStream2** ppDisassemblyStream)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisassemblyStream)

		VSL_CHECK_VALIDVALUE(dwScope);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_SET_VALIDVALUE_INTERFACE(ppDisassemblyStream);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumModulesValidValues
	{
		/*[out]*/ IEnumDebugModules2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumModules)(
		/*[out]*/ IEnumDebugModules2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumModules)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCUpdateValidValues
	{
		/*[out]*/ IDebugENCUpdate** ppUpdate;
		HRESULT retValue;
	};

	STDMETHOD(GetENCUpdate)(
		/*[out]*/ IDebugENCUpdate** ppUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCUpdate)

		VSL_SET_VALIDVALUE_INTERFACE(ppUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodePathsValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszHint;
		/*[in]*/ IDebugCodeContext2* pStart;
		/*[in]*/ IDebugStackFrame2* pFrame;
		/*[in]*/ BOOL fSource;
		/*[out]*/ IEnumCodePaths2** ppEnum;
		/*[out]*/ IDebugCodeContext2** ppSafety;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodePaths)(
		/*[in,ptr]*/ LPCOLESTR pszHint,
		/*[in]*/ IDebugCodeContext2* pStart,
		/*[in]*/ IDebugStackFrame2* pFrame,
		/*[in]*/ BOOL fSource,
		/*[out]*/ IEnumCodePaths2** ppEnum,
		/*[out]*/ IDebugCodeContext2** ppSafety)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodePaths)

		VSL_CHECK_VALIDVALUE_STRINGW(pszHint);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStart);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_CHECK_VALIDVALUE(fSource);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_SET_VALIDVALUE_INTERFACE(ppSafety);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteDumpValidValues
	{
		/*[in]*/ DUMPTYPE DumpType;
		/*[in]*/ LPCOLESTR pszDumpUrl;
		HRESULT retValue;
	};

	STDMETHOD(WriteDump)(
		/*[in]*/ DUMPTYPE DumpType,
		/*[in]*/ LPCOLESTR pszDumpUrl)
	{
		VSL_DEFINE_MOCK_METHOD(WriteDump)

		VSL_CHECK_VALIDVALUE(DumpType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDumpUrl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAM3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramDestroyEventFlags2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMDESTROYEVENTFLAGS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMDESTROYEVENTFLAGS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramDestroyEventFlags2NotImpl :
	public IDebugProgramDestroyEventFlags2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramDestroyEventFlags2NotImpl)

public:

	typedef IDebugProgramDestroyEventFlags2 Interface;

	STDMETHOD(GetFlags)(
		/*[out]*/ PROGRAM_DESTROY_FLAGS* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramDestroyEventFlags2MockImpl :
	public IDebugProgramDestroyEventFlags2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramDestroyEventFlags2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramDestroyEventFlags2MockImpl)

	typedef IDebugProgramDestroyEventFlags2 Interface;
	struct GetFlagsValidValues
	{
		/*[out]*/ PROGRAM_DESTROY_FLAGS* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ PROGRAM_DESTROY_FLAGS* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMDESTROYEVENTFLAGS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProcessSecurity2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROCESSSECURITY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROCESSSECURITY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProcessSecurity2NotImpl :
	public IDebugProcessSecurity2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcessSecurity2NotImpl)

public:

	typedef IDebugProcessSecurity2 Interface;

	STDMETHOD(QueryCanSafelyAttach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserName)(
		/*[out]*/ BSTR* /*pbstrUserName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProcessSecurity2MockImpl :
	public IDebugProcessSecurity2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProcessSecurity2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProcessSecurity2MockImpl)

	typedef IDebugProcessSecurity2 Interface;
	struct QueryCanSafelyAttachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(QueryCanSafelyAttach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(QueryCanSafelyAttach)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserNameValidValues
	{
		/*[out]*/ BSTR* pbstrUserName;
		HRESULT retValue;
	};

	STDMETHOD(GetUserName)(
		/*[out]*/ BSTR* pbstrUserName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserName)

		VSL_SET_VALIDVALUE_BSTR(pbstrUserName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROCESSSECURITY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgram2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgram2NotImpl :
	public IDebugProgram2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgram2NotImpl)

public:

	typedef IDebugProgram2 Interface;

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProcess)(
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDetach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProgramId)(
		/*[out]*/ GUID* /*pguidProgramId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Execute)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Continue)(
		/*[in]*/ IDebugThread2* /*pThread*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Step)(
		/*[in]*/ IDebugThread2* /*pThread*/,
		/*[in]*/ STEPKIND /*sk*/,
		/*[in]*/ STEPUNIT /*step*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineInfo)(
		/*[out]*/ BSTR* /*pbstrEngine*/,
		/*[out]*/ GUID* /*pguidEngine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugDocumentPosition2* /*pDocPos*/,
		/*[out]*/ IEnumDebugCodeContexts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisassemblyStream)(
		/*[in]*/ DISASSEMBLY_STREAM_SCOPE /*dwScope*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/,
		/*[out]*/ IDebugDisassemblyStream2** /*ppDisassemblyStream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumModules)(
		/*[out]*/ IEnumDebugModules2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCUpdate)(
		/*[out]*/ IDebugENCUpdate** /*ppUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodePaths)(
		/*[in,ptr]*/ LPCOLESTR /*pszHint*/,
		/*[in]*/ IDebugCodeContext2* /*pStart*/,
		/*[in]*/ IDebugStackFrame2* /*pFrame*/,
		/*[in]*/ BOOL /*fSource*/,
		/*[out]*/ IEnumCodePaths2** /*ppEnum*/,
		/*[out]*/ IDebugCodeContext2** /*ppSafety*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteDump)(
		/*[in]*/ DUMPTYPE /*DumpType*/,
		/*[in]*/ LPCOLESTR /*pszDumpUrl*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgram2MockImpl :
	public IDebugProgram2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgram2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgram2MockImpl)

	typedef IDebugProgram2 Interface;
	struct EnumThreadsValidValues
	{
		/*[out]*/ IEnumDebugThreads2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumThreads)(
		/*[out]*/ IEnumDebugThreads2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumThreads)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProcessValidValues
	{
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(GetProcess)(
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(GetProcess)

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Terminate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Terminate)

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		HRESULT retValue;
	};

	STDMETHOD(Attach)(
		/*[in]*/ IDebugEventCallback2* pCallback)
	{
		VSL_DEFINE_MOCK_METHOD(Attach)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanDetach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanDetach)

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProgramIdValidValues
	{
		/*[out]*/ GUID* pguidProgramId;
		HRESULT retValue;
	};

	STDMETHOD(GetProgramId)(
		/*[out]*/ GUID* pguidProgramId)
	{
		VSL_DEFINE_MOCK_METHOD(GetProgramId)

		VSL_SET_VALIDVALUE(pguidProgramId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDebugPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecuteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Execute)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Execute)

		VSL_RETURN_VALIDVALUES();
	}
	struct ContinueValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		HRESULT retValue;
	};

	STDMETHOD(Continue)(
		/*[in]*/ IDebugThread2* pThread)
	{
		VSL_DEFINE_MOCK_METHOD(Continue)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_RETURN_VALIDVALUES();
	}
	struct StepValidValues
	{
		/*[in]*/ IDebugThread2* pThread;
		/*[in]*/ STEPKIND sk;
		/*[in]*/ STEPUNIT step;
		HRESULT retValue;
	};

	STDMETHOD(Step)(
		/*[in]*/ IDebugThread2* pThread,
		/*[in]*/ STEPKIND sk,
		/*[in]*/ STEPUNIT step)
	{
		VSL_DEFINE_MOCK_METHOD(Step)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pThread);

		VSL_CHECK_VALIDVALUE(sk);

		VSL_CHECK_VALIDVALUE(step);

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineInfoValidValues
	{
		/*[out]*/ BSTR* pbstrEngine;
		/*[out]*/ GUID* pguidEngine;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineInfo)(
		/*[out]*/ BSTR* pbstrEngine,
		/*[out]*/ GUID* pguidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrEngine);

		VSL_SET_VALIDVALUE(pguidEngine);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodeContextsValidValues
	{
		/*[in]*/ IDebugDocumentPosition2* pDocPos;
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugDocumentPosition2* pDocPos,
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodeContexts)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDocPos);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisassemblyStreamValidValues
	{
		/*[in]*/ DISASSEMBLY_STREAM_SCOPE dwScope;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		/*[out]*/ IDebugDisassemblyStream2** ppDisassemblyStream;
		HRESULT retValue;
	};

	STDMETHOD(GetDisassemblyStream)(
		/*[in]*/ DISASSEMBLY_STREAM_SCOPE dwScope,
		/*[in]*/ IDebugCodeContext2* pCodeContext,
		/*[out]*/ IDebugDisassemblyStream2** ppDisassemblyStream)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisassemblyStream)

		VSL_CHECK_VALIDVALUE(dwScope);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_SET_VALIDVALUE_INTERFACE(ppDisassemblyStream);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumModulesValidValues
	{
		/*[out]*/ IEnumDebugModules2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumModules)(
		/*[out]*/ IEnumDebugModules2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumModules)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCUpdateValidValues
	{
		/*[out]*/ IDebugENCUpdate** ppUpdate;
		HRESULT retValue;
	};

	STDMETHOD(GetENCUpdate)(
		/*[out]*/ IDebugENCUpdate** ppUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCUpdate)

		VSL_SET_VALIDVALUE_INTERFACE(ppUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodePathsValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszHint;
		/*[in]*/ IDebugCodeContext2* pStart;
		/*[in]*/ IDebugStackFrame2* pFrame;
		/*[in]*/ BOOL fSource;
		/*[out]*/ IEnumCodePaths2** ppEnum;
		/*[out]*/ IDebugCodeContext2** ppSafety;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodePaths)(
		/*[in,ptr]*/ LPCOLESTR pszHint,
		/*[in]*/ IDebugCodeContext2* pStart,
		/*[in]*/ IDebugStackFrame2* pFrame,
		/*[in]*/ BOOL fSource,
		/*[out]*/ IEnumCodePaths2** ppEnum,
		/*[out]*/ IDebugCodeContext2** ppSafety)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodePaths)

		VSL_CHECK_VALIDVALUE_STRINGW(pszHint);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStart);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_CHECK_VALIDVALUE(fSource);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_SET_VALIDVALUE_INTERFACE(ppSafety);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteDumpValidValues
	{
		/*[in]*/ DUMPTYPE DumpType;
		/*[in]*/ LPCOLESTR pszDumpUrl;
		HRESULT retValue;
	};

	STDMETHOD(WriteDump)(
		/*[in]*/ DUMPTYPE DumpType,
		/*[in]*/ LPCOLESTR pszDumpUrl)
	{
		VSL_DEFINE_MOCK_METHOD(WriteDump)

		VSL_CHECK_VALIDVALUE(DumpType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDumpUrl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramEngines2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMENGINES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMENGINES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramEngines2NotImpl :
	public IDebugProgramEngines2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramEngines2NotImpl)

public:

	typedef IDebugProgramEngines2 Interface;

	STDMETHOD(EnumPossibleEngines)(
		/*[in]*/ DWORD /*celtBuffer*/,
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEngines)]*/ GUID* /*rgguidEngines*/,
		/*[in,out]*/ DWORD* /*pceltEngines*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEngine)(
		/*[in]*/ REFGUID /*guidEngine*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramEngines2MockImpl :
	public IDebugProgramEngines2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramEngines2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramEngines2MockImpl)

	typedef IDebugProgramEngines2 Interface;
	struct EnumPossibleEnginesValidValues
	{
		/*[in]*/ DWORD celtBuffer;
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEngines)]*/ GUID* rgguidEngines;
		/*[in,out]*/ DWORD* pceltEngines;
		HRESULT retValue;
	};

	STDMETHOD(EnumPossibleEngines)(
		/*[in]*/ DWORD celtBuffer,
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEngines)]*/ GUID* rgguidEngines,
		/*[in,out]*/ DWORD* pceltEngines)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPossibleEngines)

		VSL_CHECK_VALIDVALUE(celtBuffer);

		VSL_SET_VALIDVALUE_MEMCPY(rgguidEngines, celtBuffer*sizeof(rgguidEngines[0]), *(validValues.pceltEngines)*sizeof(validValues.rgguidEngines[0]));

		VSL_SET_VALIDVALUE(pceltEngines);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEngineValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		HRESULT retValue;
	};

	STDMETHOD(SetEngine)(
		/*[in]*/ REFGUID guidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(SetEngine)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMENGINES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramHost2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMHOST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMHOST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramHost2NotImpl :
	public IDebugProgramHost2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramHost2NotImpl)

public:

	typedef IDebugProgramHost2 Interface;

	STDMETHOD(GetHostName)(
		/*[in]*/ DWORD /*dwType*/,
		/*[out]*/ BSTR* /*pbstrHostName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostId)(
		/*[out]*/ AD_PROCESS_ID* /*pProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostMachineName)(
		/*[out]*/ BSTR* /*pbstrHostMachineName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramHost2MockImpl :
	public IDebugProgramHost2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramHost2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramHost2MockImpl)

	typedef IDebugProgramHost2 Interface;
	struct GetHostNameValidValues
	{
		/*[in]*/ DWORD dwType;
		/*[out]*/ BSTR* pbstrHostName;
		HRESULT retValue;
	};

	STDMETHOD(GetHostName)(
		/*[in]*/ DWORD dwType,
		/*[out]*/ BSTR* pbstrHostName)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostName)

		VSL_CHECK_VALIDVALUE(dwType);

		VSL_SET_VALIDVALUE_BSTR(pbstrHostName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostIdValidValues
	{
		/*[out]*/ AD_PROCESS_ID* pProcessId;
		HRESULT retValue;
	};

	STDMETHOD(GetHostId)(
		/*[out]*/ AD_PROCESS_ID* pProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostId)

		VSL_SET_VALIDVALUE(pProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostMachineNameValidValues
	{
		/*[out]*/ BSTR* pbstrHostMachineName;
		HRESULT retValue;
	};

	STDMETHOD(GetHostMachineName)(
		/*[out]*/ BSTR* pbstrHostMachineName)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostMachineName)

		VSL_SET_VALIDVALUE_BSTR(pbstrHostMachineName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMHOST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramNodeAttach2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMNODEATTACH2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMNODEATTACH2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramNodeAttach2NotImpl :
	public IDebugProgramNodeAttach2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramNodeAttach2NotImpl)

public:

	typedef IDebugProgramNodeAttach2 Interface;

	STDMETHOD(OnAttach)(
		/*[in]*/ REFGUID /*guidProgramId*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramNodeAttach2MockImpl :
	public IDebugProgramNodeAttach2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramNodeAttach2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramNodeAttach2MockImpl)

	typedef IDebugProgramNodeAttach2 Interface;
	struct OnAttachValidValues
	{
		/*[in]*/ REFGUID guidProgramId;
		HRESULT retValue;
	};

	STDMETHOD(OnAttach)(
		/*[in]*/ REFGUID guidProgramId)
	{
		VSL_DEFINE_MOCK_METHOD(OnAttach)

		VSL_CHECK_VALIDVALUE(guidProgramId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMNODEATTACH2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramNode2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramNode2NotImpl :
	public IDebugProgramNode2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramNode2NotImpl)

public:

	typedef IDebugProgramNode2 Interface;

	STDMETHOD(GetProgramName)(
		/*[out]*/ BSTR* /*pbstrProgramName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostName)(
		/*[in]*/ GETHOSTNAME_TYPE /*dwHostNameType*/,
		/*[out]*/ BSTR* /*pbstrHostName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostPid)(
		/*[out]*/ AD_PROCESS_ID* /*pHostProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostMachineName_V7)(
		/*[out]*/ BSTR* /*pbstrHostMachineName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Attach_V7)(
		/*[in]*/ IDebugProgram2* /*pMDMProgram*/,
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in]*/ DWORD /*dwReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineInfo)(
		/*[out]*/ BSTR* /*pbstrEngine*/,
		/*[out]*/ GUID* /*pguidEngine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DetachDebugger_V7)()VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramNode2MockImpl :
	public IDebugProgramNode2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramNode2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramNode2MockImpl)

	typedef IDebugProgramNode2 Interface;
	struct GetProgramNameValidValues
	{
		/*[out]*/ BSTR* pbstrProgramName;
		HRESULT retValue;
	};

	STDMETHOD(GetProgramName)(
		/*[out]*/ BSTR* pbstrProgramName)
	{
		VSL_DEFINE_MOCK_METHOD(GetProgramName)

		VSL_SET_VALIDVALUE_BSTR(pbstrProgramName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostNameValidValues
	{
		/*[in]*/ GETHOSTNAME_TYPE dwHostNameType;
		/*[out]*/ BSTR* pbstrHostName;
		HRESULT retValue;
	};

	STDMETHOD(GetHostName)(
		/*[in]*/ GETHOSTNAME_TYPE dwHostNameType,
		/*[out]*/ BSTR* pbstrHostName)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostName)

		VSL_CHECK_VALIDVALUE(dwHostNameType);

		VSL_SET_VALIDVALUE_BSTR(pbstrHostName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostPidValidValues
	{
		/*[out]*/ AD_PROCESS_ID* pHostProcessId;
		HRESULT retValue;
	};

	STDMETHOD(GetHostPid)(
		/*[out]*/ AD_PROCESS_ID* pHostProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostPid)

		VSL_SET_VALIDVALUE(pHostProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostMachineName_V7ValidValues
	{
		/*[out]*/ BSTR* pbstrHostMachineName;
		HRESULT retValue;
	};

	STDMETHOD(GetHostMachineName_V7)(
		/*[out]*/ BSTR* pbstrHostMachineName)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostMachineName_V7)

		VSL_SET_VALIDVALUE_BSTR(pbstrHostMachineName);

		VSL_RETURN_VALIDVALUES();
	}
	struct Attach_V7ValidValues
	{
		/*[in]*/ IDebugProgram2* pMDMProgram;
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in]*/ DWORD dwReason;
		HRESULT retValue;
	};

	STDMETHOD(Attach_V7)(
		/*[in]*/ IDebugProgram2* pMDMProgram,
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in]*/ DWORD dwReason)
	{
		VSL_DEFINE_MOCK_METHOD(Attach_V7)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMDMProgram);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE(dwReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineInfoValidValues
	{
		/*[out]*/ BSTR* pbstrEngine;
		/*[out]*/ GUID* pguidEngine;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineInfo)(
		/*[out]*/ BSTR* pbstrEngine,
		/*[out]*/ GUID* pguidEngine)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrEngine);

		VSL_SET_VALIDVALUE(pguidEngine);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachDebugger_V7ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DetachDebugger_V7)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DetachDebugger_V7)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramProvider2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramProvider2NotImpl :
	public IDebugProgramProvider2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramProvider2NotImpl)

public:

	typedef IDebugProgramProvider2 Interface;

	STDMETHOD(GetProviderProcessData)(
		/*[in]*/ PROVIDER_FLAGS /*Flags*/,
		/*[in]*/ IDebugDefaultPort2* /*pPort*/,
		/*[in]*/ AD_PROCESS_ID /*processId*/,
		/*[in]*/ CONST_GUID_ARRAY /*EngineFilter*/,
		/*[out]*/ PROVIDER_PROCESS_DATA* /*pProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderProgramNode)(
		/*[in]*/ PROVIDER_FLAGS /*Flags*/,
		/*[in]*/ IDebugDefaultPort2* /*pPort*/,
		/*[in]*/ AD_PROCESS_ID /*processId*/,
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ UINT64 /*programId*/,
		/*[out]*/ IDebugProgramNode2** /*ppProgramNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WatchForProviderEvents)(
		/*[in]*/ PROVIDER_FLAGS /*Flags*/,
		/*[in]*/ IDebugDefaultPort2* /*pPort*/,
		/*[in]*/ AD_PROCESS_ID /*processId*/,
		/*[in]*/ CONST_GUID_ARRAY /*EngineFilter*/,
		/*[in]*/ REFGUID /*guidLaunchingEngine*/,
		/*[in]*/ IDebugPortNotify2* /*pEventCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD /*wLangID*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramProvider2MockImpl :
	public IDebugProgramProvider2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramProvider2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramProvider2MockImpl)

	typedef IDebugProgramProvider2 Interface;
	struct GetProviderProcessDataValidValues
	{
		/*[in]*/ PROVIDER_FLAGS Flags;
		/*[in]*/ IDebugDefaultPort2* pPort;
		/*[in]*/ AD_PROCESS_ID processId;
		/*[in]*/ CONST_GUID_ARRAY EngineFilter;
		/*[out]*/ PROVIDER_PROCESS_DATA* pProcess;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderProcessData)(
		/*[in]*/ PROVIDER_FLAGS Flags,
		/*[in]*/ IDebugDefaultPort2* pPort,
		/*[in]*/ AD_PROCESS_ID processId,
		/*[in]*/ CONST_GUID_ARRAY EngineFilter,
		/*[out]*/ PROVIDER_PROCESS_DATA* pProcess)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderProcessData)

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE(processId);

		VSL_CHECK_VALIDVALUE(EngineFilter);

		VSL_SET_VALIDVALUE(pProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderProgramNodeValidValues
	{
		/*[in]*/ PROVIDER_FLAGS Flags;
		/*[in]*/ IDebugDefaultPort2* pPort;
		/*[in]*/ AD_PROCESS_ID processId;
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ UINT64 programId;
		/*[out]*/ IDebugProgramNode2** ppProgramNode;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderProgramNode)(
		/*[in]*/ PROVIDER_FLAGS Flags,
		/*[in]*/ IDebugDefaultPort2* pPort,
		/*[in]*/ AD_PROCESS_ID processId,
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ UINT64 programId,
		/*[out]*/ IDebugProgramNode2** ppProgramNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderProgramNode)

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE(processId);

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(programId);

		VSL_SET_VALIDVALUE_INTERFACE(ppProgramNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct WatchForProviderEventsValidValues
	{
		/*[in]*/ PROVIDER_FLAGS Flags;
		/*[in]*/ IDebugDefaultPort2* pPort;
		/*[in]*/ AD_PROCESS_ID processId;
		/*[in]*/ CONST_GUID_ARRAY EngineFilter;
		/*[in]*/ REFGUID guidLaunchingEngine;
		/*[in]*/ IDebugPortNotify2* pEventCallback;
		HRESULT retValue;
	};

	STDMETHOD(WatchForProviderEvents)(
		/*[in]*/ PROVIDER_FLAGS Flags,
		/*[in]*/ IDebugDefaultPort2* pPort,
		/*[in]*/ AD_PROCESS_ID processId,
		/*[in]*/ CONST_GUID_ARRAY EngineFilter,
		/*[in]*/ REFGUID guidLaunchingEngine,
		/*[in]*/ IDebugPortNotify2* pEventCallback)
	{
		VSL_DEFINE_MOCK_METHOD(WatchForProviderEvents)

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE(processId);

		VSL_CHECK_VALIDVALUE(EngineFilter);

		VSL_CHECK_VALIDVALUE(guidLaunchingEngine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEventCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLocaleValidValues
	{
		/*[in]*/ WORD wLangID;
		HRESULT retValue;
	};

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD wLangID)
	{
		VSL_DEFINE_MOCK_METHOD(SetLocale)

		VSL_CHECK_VALIDVALUE(wLangID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProgramPublisher2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROGRAMPUBLISHER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROGRAMPUBLISHER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProgramPublisher2NotImpl :
	public IDebugProgramPublisher2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramPublisher2NotImpl)

public:

	typedef IDebugProgramPublisher2 Interface;

	STDMETHOD(PublishProgramNode)(
		/*[in]*/ IDebugProgramNode2* /*pProgramNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnpublishProgramNode)(
		/*[in]*/ IDebugProgramNode2* /*pProgramNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PublishProgram)(
		/*[in]*/ CONST_GUID_ARRAY /*Engines*/,
		/*[in,ptr]*/ LPCOLESTR /*szFriendlyName*/,
		/*[in]*/ IUnknown* /*pDebuggeeInterface*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnpublishProgram)(
		/*[in]*/ IUnknown* /*pDebuggeeInterface*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDebuggerPresent)(
		/*[in]*/ BOOL /*fDebuggerPresent*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProgramPublisher2MockImpl :
	public IDebugProgramPublisher2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProgramPublisher2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProgramPublisher2MockImpl)

	typedef IDebugProgramPublisher2 Interface;
	struct PublishProgramNodeValidValues
	{
		/*[in]*/ IDebugProgramNode2* pProgramNode;
		HRESULT retValue;
	};

	STDMETHOD(PublishProgramNode)(
		/*[in]*/ IDebugProgramNode2* pProgramNode)
	{
		VSL_DEFINE_MOCK_METHOD(PublishProgramNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgramNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnpublishProgramNodeValidValues
	{
		/*[in]*/ IDebugProgramNode2* pProgramNode;
		HRESULT retValue;
	};

	STDMETHOD(UnpublishProgramNode)(
		/*[in]*/ IDebugProgramNode2* pProgramNode)
	{
		VSL_DEFINE_MOCK_METHOD(UnpublishProgramNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgramNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct PublishProgramValidValues
	{
		/*[in]*/ CONST_GUID_ARRAY Engines;
		/*[in,ptr]*/ LPCOLESTR szFriendlyName;
		/*[in]*/ IUnknown* pDebuggeeInterface;
		HRESULT retValue;
	};

	STDMETHOD(PublishProgram)(
		/*[in]*/ CONST_GUID_ARRAY Engines,
		/*[in,ptr]*/ LPCOLESTR szFriendlyName,
		/*[in]*/ IUnknown* pDebuggeeInterface)
	{
		VSL_DEFINE_MOCK_METHOD(PublishProgram)

		VSL_CHECK_VALIDVALUE(Engines);

		VSL_CHECK_VALIDVALUE_STRINGW(szFriendlyName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDebuggeeInterface);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnpublishProgramValidValues
	{
		/*[in]*/ IUnknown* pDebuggeeInterface;
		HRESULT retValue;
	};

	STDMETHOD(UnpublishProgram)(
		/*[in]*/ IUnknown* pDebuggeeInterface)
	{
		VSL_DEFINE_MOCK_METHOD(UnpublishProgram)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDebuggeeInterface);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDebuggerPresentValidValues
	{
		/*[in]*/ BOOL fDebuggerPresent;
		HRESULT retValue;
	};

	STDMETHOD(SetDebuggerPresent)(
		/*[in]*/ BOOL fDebuggerPresent)
	{
		VSL_DEFINE_MOCK_METHOD(SetDebuggerPresent)

		VSL_CHECK_VALIDVALUE(fDebuggerPresent);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROGRAMPUBLISHER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProperty2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROPERTY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROPERTY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProperty2NotImpl :
	public IDebugProperty2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProperty2NotImpl)

public:

	typedef IDebugProperty2 Interface;

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[out]*/ DEBUG_PROPERTY_INFO* /*pPropertyInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[in]*/ IDebugReference2* /*pValue*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ REFGUID /*guidFilter*/,
		/*[in]*/ DBG_ATTRIB_FLAGS /*dwAttribFilter*/,
		/*[in,ptr]*/ LPCOLESTR /*pszNameFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** /*ppParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** /*ppDerivedMost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** /*ppMemory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** /*ppReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID /*guidExtendedInfo*/,
		/*[out]*/ VARIANT* /*pExtendedInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProperty2MockImpl :
	public IDebugProperty2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProperty2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProperty2MockImpl)

	typedef IDebugProperty2 Interface;
	struct GetPropertyInfoValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_SET_VALIDVALUE(pPropertyInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsReferenceValidValues
	{
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[in]*/ IDebugReference2* pValue;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[in]*/ IDebugReference2* pValue,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsReference)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pValue);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumChildrenValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ REFGUID guidFilter;
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter;
		/*[in,ptr]*/ LPCOLESTR pszNameFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ REFGUID guidFilter,
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter,
		/*[in,ptr]*/ LPCOLESTR pszNameFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumChildren)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(guidFilter);

		VSL_CHECK_VALIDVALUE(dwAttribFilter);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentValidValues
	{
		/*[out]*/ IDebugProperty2** ppParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** ppParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParent)

		VSL_SET_VALIDVALUE_INTERFACE(ppParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDerivedMostPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppDerivedMost;
		HRESULT retValue;
	};

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** ppDerivedMost)
	{
		VSL_DEFINE_MOCK_METHOD(GetDerivedMostProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppDerivedMost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryContextValidValues
	{
		/*[out]*/ IDebugMemoryContext2** ppMemory;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** ppMemory)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ DWORD* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceValidValues
	{
		/*[out]*/ IDebugReference2** ppReference;
		HRESULT retValue;
	};

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** ppReference)
	{
		VSL_DEFINE_MOCK_METHOD(GetReference)

		VSL_SET_VALIDVALUE_INTERFACE(ppReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedInfoValidValues
	{
		/*[in]*/ REFGUID guidExtendedInfo;
		/*[out]*/ VARIANT* pExtendedInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID guidExtendedInfo,
		/*[out]*/ VARIANT* pExtendedInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedInfo)

		VSL_CHECK_VALIDVALUE(guidExtendedInfo);

		VSL_SET_VALIDVALUE_VARIANT(pExtendedInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROPERTY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProperty3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROPERTY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROPERTY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProperty3NotImpl :
	public IDebugProperty3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProperty3NotImpl)

public:

	typedef IDebugProperty3 Interface;

	STDMETHOD(GetStringCharLength)(
		/*[out]*/ ULONG* /*pLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStringChars)(
		/*[in]*/ ULONG /*buflen*/,
		/*[out,size_is(buflen),length_is(*pceltFetched)]*/ WCHAR* /*rgString*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateObjectID)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DestroyObjectID)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomViewerCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomViewerList)(
		/*[in]*/ ULONG /*celtSkip*/,
		/*[in]*/ ULONG /*celtRequested*/,
		/*[out,size_is(celtRequested),length_is(*pceltFetched)]*/ DEBUG_CUSTOM_VIEWER* /*rgViewers*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsStringWithError)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ BSTR* /*errorString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[out]*/ DEBUG_PROPERTY_INFO* /*pPropertyInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[in]*/ IDebugReference2* /*pValue*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ REFGUID /*guidFilter*/,
		/*[in]*/ DBG_ATTRIB_FLAGS /*dwAttribFilter*/,
		/*[in,ptr]*/ LPCOLESTR /*pszNameFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** /*ppParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** /*ppDerivedMost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** /*ppMemory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** /*ppReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID /*guidExtendedInfo*/,
		/*[out]*/ VARIANT* /*pExtendedInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProperty3MockImpl :
	public IDebugProperty3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProperty3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProperty3MockImpl)

	typedef IDebugProperty3 Interface;
	struct GetStringCharLengthValidValues
	{
		/*[out]*/ ULONG* pLen;
		HRESULT retValue;
	};

	STDMETHOD(GetStringCharLength)(
		/*[out]*/ ULONG* pLen)
	{
		VSL_DEFINE_MOCK_METHOD(GetStringCharLength)

		VSL_SET_VALIDVALUE(pLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStringCharsValidValues
	{
		/*[in]*/ ULONG buflen;
		/*[out,size_is(buflen),length_is(*pceltFetched)]*/ WCHAR* rgString;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetStringChars)(
		/*[in]*/ ULONG buflen,
		/*[out,size_is(buflen),length_is(*pceltFetched)]*/ WCHAR* rgString,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetStringChars)

		VSL_CHECK_VALIDVALUE(buflen);

		VSL_SET_VALIDVALUE_STRINGW(rgString, buflen);

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateObjectIDValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CreateObjectID)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CreateObjectID)

		VSL_RETURN_VALIDVALUES();
	}
	struct DestroyObjectIDValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DestroyObjectID)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DestroyObjectID)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomViewerCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomViewerCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomViewerCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomViewerListValidValues
	{
		/*[in]*/ ULONG celtSkip;
		/*[in]*/ ULONG celtRequested;
		/*[out,size_is(celtRequested),length_is(*pceltFetched)]*/ DEBUG_CUSTOM_VIEWER* rgViewers;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomViewerList)(
		/*[in]*/ ULONG celtSkip,
		/*[in]*/ ULONG celtRequested,
		/*[out,size_is(celtRequested),length_is(*pceltFetched)]*/ DEBUG_CUSTOM_VIEWER* rgViewers,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomViewerList)

		VSL_CHECK_VALIDVALUE(celtSkip);

		VSL_CHECK_VALIDVALUE(celtRequested);

		VSL_SET_VALIDVALUE_MEMCPY(rgViewers, celtRequested*sizeof(rgViewers[0]), *(validValues.pceltFetched)*sizeof(validValues.rgViewers[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringWithErrorValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ BSTR* errorString;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsStringWithError)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ BSTR* errorString)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsStringWithError)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_BSTR(errorString);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyInfoValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_SET_VALIDVALUE(pPropertyInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsReferenceValidValues
	{
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[in]*/ IDebugReference2* pValue;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[in]*/ IDebugReference2* pValue,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsReference)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pValue);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumChildrenValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ REFGUID guidFilter;
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter;
		/*[in,ptr]*/ LPCOLESTR pszNameFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ REFGUID guidFilter,
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter,
		/*[in,ptr]*/ LPCOLESTR pszNameFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumChildren)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(guidFilter);

		VSL_CHECK_VALIDVALUE(dwAttribFilter);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentValidValues
	{
		/*[out]*/ IDebugProperty2** ppParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** ppParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParent)

		VSL_SET_VALIDVALUE_INTERFACE(ppParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDerivedMostPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppDerivedMost;
		HRESULT retValue;
	};

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** ppDerivedMost)
	{
		VSL_DEFINE_MOCK_METHOD(GetDerivedMostProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppDerivedMost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryContextValidValues
	{
		/*[out]*/ IDebugMemoryContext2** ppMemory;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** ppMemory)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ DWORD* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceValidValues
	{
		/*[out]*/ IDebugReference2** ppReference;
		HRESULT retValue;
	};

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** ppReference)
	{
		VSL_DEFINE_MOCK_METHOD(GetReference)

		VSL_SET_VALIDVALUE_INTERFACE(ppReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedInfoValidValues
	{
		/*[in]*/ REFGUID guidExtendedInfo;
		/*[out]*/ VARIANT* pExtendedInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID guidExtendedInfo,
		/*[out]*/ VARIANT* pExtendedInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedInfo)

		VSL_CHECK_VALIDVALUE(guidExtendedInfo);

		VSL_SET_VALIDVALUE_VARIANT(pExtendedInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROPERTY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPropertyClose2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROPERTYCLOSE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROPERTYCLOSE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPropertyClose2NotImpl :
	public IDebugPropertyClose2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertyClose2NotImpl)

public:

	typedef IDebugPropertyClose2 Interface;

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[out]*/ DEBUG_PROPERTY_INFO* /*pPropertyInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[in]*/ IDebugReference2* /*pValue*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ REFGUID /*guidFilter*/,
		/*[in]*/ DBG_ATTRIB_FLAGS /*dwAttribFilter*/,
		/*[in,ptr]*/ LPCOLESTR /*pszNameFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** /*ppParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** /*ppDerivedMost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** /*ppMemory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** /*ppReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID /*guidExtendedInfo*/,
		/*[out]*/ VARIANT* /*pExtendedInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPropertyClose2MockImpl :
	public IDebugPropertyClose2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertyClose2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPropertyClose2MockImpl)

	typedef IDebugPropertyClose2 Interface;
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyInfoValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_SET_VALIDVALUE(pPropertyInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsReferenceValidValues
	{
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[in]*/ IDebugReference2* pValue;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[in]*/ IDebugReference2* pValue,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsReference)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pValue);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumChildrenValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ REFGUID guidFilter;
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter;
		/*[in,ptr]*/ LPCOLESTR pszNameFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ REFGUID guidFilter,
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter,
		/*[in,ptr]*/ LPCOLESTR pszNameFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumChildren)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(guidFilter);

		VSL_CHECK_VALIDVALUE(dwAttribFilter);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentValidValues
	{
		/*[out]*/ IDebugProperty2** ppParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** ppParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParent)

		VSL_SET_VALIDVALUE_INTERFACE(ppParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDerivedMostPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppDerivedMost;
		HRESULT retValue;
	};

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** ppDerivedMost)
	{
		VSL_DEFINE_MOCK_METHOD(GetDerivedMostProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppDerivedMost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryContextValidValues
	{
		/*[out]*/ IDebugMemoryContext2** ppMemory;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** ppMemory)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ DWORD* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceValidValues
	{
		/*[out]*/ IDebugReference2** ppReference;
		HRESULT retValue;
	};

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** ppReference)
	{
		VSL_DEFINE_MOCK_METHOD(GetReference)

		VSL_SET_VALIDVALUE_INTERFACE(ppReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedInfoValidValues
	{
		/*[in]*/ REFGUID guidExtendedInfo;
		/*[out]*/ VARIANT* pExtendedInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID guidExtendedInfo,
		/*[out]*/ VARIANT* pExtendedInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedInfo)

		VSL_CHECK_VALIDVALUE(guidExtendedInfo);

		VSL_SET_VALIDVALUE_VARIANT(pExtendedInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROPERTYCLOSE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPropertyCreateEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROPERTYCREATEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROPERTYCREATEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPropertyCreateEvent2NotImpl :
	public IDebugPropertyCreateEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertyCreateEvent2NotImpl)

public:

	typedef IDebugPropertyCreateEvent2 Interface;

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPropertyCreateEvent2MockImpl :
	public IDebugPropertyCreateEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertyCreateEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPropertyCreateEvent2MockImpl)

	typedef IDebugPropertyCreateEvent2 Interface;
	struct GetDebugPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROPERTYCREATEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPropertySafetyWrapper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROPERTYSAFETYWRAPPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROPERTYSAFETYWRAPPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPropertySafetyWrapperNotImpl :
	public IDebugPropertySafetyWrapper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertySafetyWrapperNotImpl)

public:

	typedef IDebugPropertySafetyWrapper Interface;

	STDMETHOD(BeforePropertyCall)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AfterPropertyCall)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRawProperty)(
		/*[out]*/ IDebugProperty3** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPropertySafetyWrapperMockImpl :
	public IDebugPropertySafetyWrapper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertySafetyWrapperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPropertySafetyWrapperMockImpl)

	typedef IDebugPropertySafetyWrapper Interface;
	struct BeforePropertyCallValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeforePropertyCall)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeforePropertyCall)

		VSL_RETURN_VALIDVALUES();
	}
	struct AfterPropertyCallValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AfterPropertyCall)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AfterPropertyCall)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRawPropertyValidValues
	{
		/*[out]*/ IDebugProperty3** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetRawProperty)(
		/*[out]*/ IDebugProperty3** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetRawProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROPERTYSAFETYWRAPPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugPropertyDestroyEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROPERTYDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROPERTYDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugPropertyDestroyEvent2NotImpl :
	public IDebugPropertyDestroyEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertyDestroyEvent2NotImpl)

public:

	typedef IDebugPropertyDestroyEvent2 Interface;

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugPropertyDestroyEvent2MockImpl :
	public IDebugPropertyDestroyEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugPropertyDestroyEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugPropertyDestroyEvent2MockImpl)

	typedef IDebugPropertyDestroyEvent2 Interface;
	struct GetDebugPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROPERTYDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugProviderProgramNode2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGPROVIDERPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGPROVIDERPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugProviderProgramNode2NotImpl :
	public IDebugProviderProgramNode2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProviderProgramNode2NotImpl)

public:

	typedef IDebugProviderProgramNode2 Interface;

	STDMETHOD(UnmarshalDebuggeeInterface)(
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugProviderProgramNode2MockImpl :
	public IDebugProviderProgramNode2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugProviderProgramNode2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugProviderProgramNode2MockImpl)

	typedef IDebugProviderProgramNode2 Interface;
	struct UnmarshalDebuggeeInterfaceValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(UnmarshalDebuggeeInterface)(
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(UnmarshalDebuggeeInterface)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGPROVIDERPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugRemoteServerFactory2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGREMOTESERVERFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGREMOTESERVERFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugRemoteServerFactory2NotImpl :
	public IDebugRemoteServerFactory2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugRemoteServerFactory2NotImpl)

public:

	typedef IDebugRemoteServerFactory2 Interface;

	STDMETHOD(CreateServer)(
		/*[in]*/ IDebugSession2* /*pSession*/,
		/*[out]*/ IDebugRemoteServer2** /*ppRemoteServer*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugRemoteServerFactory2MockImpl :
	public IDebugRemoteServerFactory2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugRemoteServerFactory2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugRemoteServerFactory2MockImpl)

	typedef IDebugRemoteServerFactory2 Interface;
	struct CreateServerValidValues
	{
		/*[in]*/ IDebugSession2* pSession;
		/*[out]*/ IDebugRemoteServer2** ppRemoteServer;
		HRESULT retValue;
	};

	STDMETHOD(CreateServer)(
		/*[in]*/ IDebugSession2* pSession,
		/*[out]*/ IDebugRemoteServer2** ppRemoteServer)
	{
		VSL_DEFINE_MOCK_METHOD(CreateServer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSession);

		VSL_SET_VALIDVALUE_INTERFACE(ppRemoteServer);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGREMOTESERVERFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugRemoteServer2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGREMOTESERVER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGREMOTESERVER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugRemoteServer2NotImpl :
	public IDebugRemoteServer2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugRemoteServer2NotImpl)

public:

	typedef IDebugRemoteServer2 Interface;

	STDMETHOD(GetRemoteServerName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRemoteComputerInfo)(
		/*[out]*/ COMPUTER_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumRemoteProcesses)(
		/*[out]*/ ENUMERATED_PROCESS_ARRAY* /*pProcessArray*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRemoteProcessInfo)(
		/*[in]*/ DWORD /*dwProcessId*/,
		/*[in]*/ REMOTE_PROCESS_INFO_FIELDS /*Fields*/,
		/*[out]*/ REMOTE_PROCESS_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateRemoteInstance)(
		/*[in,ptr]*/ LPCWSTR /*szDll*/,
		/*[in]*/ WORD /*wLangId*/,
		/*[in]*/ REFCLSID /*clsidObject*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WatchForRemoteProcessDestroy)(
		/*[in]*/ IDebugPortEvents2* /*pCallback*/,
		/*[in]*/ IDebugProcess2* /*pProcess*/,
		/*[out]*/ WATCH_COOKIE* /*pWatchCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseRemoteWatchCookie)(
		/*[in]*/ WATCH_COOKIE /*WatchCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TerminateRemoteProcess)(
		/*[in]*/ DWORD /*dwProcessId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LaunchRemoteProcess)(
		/*[in]*/ PROCESS_LAUNCH_INFO /*LaunchInfo*/,
		/*[out]*/ DWORD* /*pdwProcessId*/,
		/*[out]*/ RESUME_COOKIE* /*pResumeCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseRemoteResumeCookie)(
		/*[in]*/ RESUME_COOKIE /*ResumeCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiagnoseRemoteWebDebuggingError)(
		/*[in,ptr]*/ LPCWSTR /*szUrl*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugRemoteServer2MockImpl :
	public IDebugRemoteServer2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugRemoteServer2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugRemoteServer2MockImpl)

	typedef IDebugRemoteServer2 Interface;
	struct GetRemoteServerNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetRemoteServerName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetRemoteServerName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRemoteComputerInfoValidValues
	{
		/*[out]*/ COMPUTER_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRemoteComputerInfo)(
		/*[out]*/ COMPUTER_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRemoteComputerInfo)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumRemoteProcessesValidValues
	{
		/*[out]*/ ENUMERATED_PROCESS_ARRAY* pProcessArray;
		HRESULT retValue;
	};

	STDMETHOD(EnumRemoteProcesses)(
		/*[out]*/ ENUMERATED_PROCESS_ARRAY* pProcessArray)
	{
		VSL_DEFINE_MOCK_METHOD(EnumRemoteProcesses)

		VSL_SET_VALIDVALUE(pProcessArray);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRemoteProcessInfoValidValues
	{
		/*[in]*/ DWORD dwProcessId;
		/*[in]*/ REMOTE_PROCESS_INFO_FIELDS Fields;
		/*[out]*/ REMOTE_PROCESS_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRemoteProcessInfo)(
		/*[in]*/ DWORD dwProcessId,
		/*[in]*/ REMOTE_PROCESS_INFO_FIELDS Fields,
		/*[out]*/ REMOTE_PROCESS_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRemoteProcessInfo)

		VSL_CHECK_VALIDVALUE(dwProcessId);

		VSL_CHECK_VALIDVALUE(Fields);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateRemoteInstanceValidValues
	{
		/*[in,ptr]*/ LPCWSTR szDll;
		/*[in]*/ WORD wLangId;
		/*[in]*/ REFCLSID clsidObject;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(CreateRemoteInstance)(
		/*[in,ptr]*/ LPCWSTR szDll,
		/*[in]*/ WORD wLangId,
		/*[in]*/ REFCLSID clsidObject,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateRemoteInstance)

		VSL_CHECK_VALIDVALUE_STRINGW(szDll);

		VSL_CHECK_VALIDVALUE(wLangId);

		VSL_CHECK_VALIDVALUE(clsidObject);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct WatchForRemoteProcessDestroyValidValues
	{
		/*[in]*/ IDebugPortEvents2* pCallback;
		/*[in]*/ IDebugProcess2* pProcess;
		/*[out]*/ WATCH_COOKIE* pWatchCookie;
		HRESULT retValue;
	};

	STDMETHOD(WatchForRemoteProcessDestroy)(
		/*[in]*/ IDebugPortEvents2* pCallback,
		/*[in]*/ IDebugProcess2* pProcess,
		/*[out]*/ WATCH_COOKIE* pWatchCookie)
	{
		VSL_DEFINE_MOCK_METHOD(WatchForRemoteProcessDestroy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcess);

		VSL_SET_VALIDVALUE(pWatchCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseRemoteWatchCookieValidValues
	{
		/*[in]*/ WATCH_COOKIE WatchCookie;
		HRESULT retValue;
	};

	STDMETHOD(CloseRemoteWatchCookie)(
		/*[in]*/ WATCH_COOKIE WatchCookie)
	{
		VSL_DEFINE_MOCK_METHOD(CloseRemoteWatchCookie)

		VSL_CHECK_VALIDVALUE(WatchCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateRemoteProcessValidValues
	{
		/*[in]*/ DWORD dwProcessId;
		HRESULT retValue;
	};

	STDMETHOD(TerminateRemoteProcess)(
		/*[in]*/ DWORD dwProcessId)
	{
		VSL_DEFINE_MOCK_METHOD(TerminateRemoteProcess)

		VSL_CHECK_VALIDVALUE(dwProcessId);

		VSL_RETURN_VALIDVALUES();
	}
	struct LaunchRemoteProcessValidValues
	{
		/*[in]*/ PROCESS_LAUNCH_INFO LaunchInfo;
		/*[out]*/ DWORD* pdwProcessId;
		/*[out]*/ RESUME_COOKIE* pResumeCookie;
		HRESULT retValue;
	};

	STDMETHOD(LaunchRemoteProcess)(
		/*[in]*/ PROCESS_LAUNCH_INFO LaunchInfo,
		/*[out]*/ DWORD* pdwProcessId,
		/*[out]*/ RESUME_COOKIE* pResumeCookie)
	{
		VSL_DEFINE_MOCK_METHOD(LaunchRemoteProcess)

		VSL_CHECK_VALIDVALUE(LaunchInfo);

		VSL_SET_VALIDVALUE(pdwProcessId);

		VSL_SET_VALIDVALUE(pResumeCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseRemoteResumeCookieValidValues
	{
		/*[in]*/ RESUME_COOKIE ResumeCookie;
		HRESULT retValue;
	};

	STDMETHOD(CloseRemoteResumeCookie)(
		/*[in]*/ RESUME_COOKIE ResumeCookie)
	{
		VSL_DEFINE_MOCK_METHOD(CloseRemoteResumeCookie)

		VSL_CHECK_VALIDVALUE(ResumeCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiagnoseRemoteWebDebuggingErrorValidValues
	{
		/*[in,ptr]*/ LPCWSTR szUrl;
		HRESULT retValue;
	};

	STDMETHOD(DiagnoseRemoteWebDebuggingError)(
		/*[in,ptr]*/ LPCWSTR szUrl)
	{
		VSL_DEFINE_MOCK_METHOD(DiagnoseRemoteWebDebuggingError)

		VSL_CHECK_VALIDVALUE_STRINGW(szUrl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGREMOTESERVER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugQueryEngine2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGQUERYENGINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGQUERYENGINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugQueryEngine2NotImpl :
	public IDebugQueryEngine2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugQueryEngine2NotImpl)

public:

	typedef IDebugQueryEngine2 Interface;

	STDMETHOD(GetEngineInterface)(
		/*[out]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugQueryEngine2MockImpl :
	public IDebugQueryEngine2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugQueryEngine2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugQueryEngine2MockImpl)

	typedef IDebugQueryEngine2 Interface;
	struct GetEngineInterfaceValidValues
	{
		/*[out]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineInterface)(
		/*[out]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineInterface)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGQUERYENGINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugReturnValueEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGRETURNVALUEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGRETURNVALUEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugReturnValueEvent2NotImpl :
	public IDebugReturnValueEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugReturnValueEvent2NotImpl)

public:

	typedef IDebugReturnValueEvent2 Interface;

	STDMETHOD(GetReturnValue)(
		/*[out]*/ IDebugProperty2** /*ppReturnValue*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugReturnValueEvent2MockImpl :
	public IDebugReturnValueEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugReturnValueEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugReturnValueEvent2MockImpl)

	typedef IDebugReturnValueEvent2 Interface;
	struct GetReturnValueValidValues
	{
		/*[out]*/ IDebugProperty2** ppReturnValue;
		HRESULT retValue;
	};

	STDMETHOD(GetReturnValue)(
		/*[out]*/ IDebugProperty2** ppReturnValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetReturnValue)

		VSL_SET_VALIDVALUE_INTERFACE(ppReturnValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGRETURNVALUEEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugReference2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGREFERENCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGREFERENCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugReference2NotImpl :
	public IDebugReference2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugReference2NotImpl)

public:

	typedef IDebugReference2 Interface;

	STDMETHOD(GetReferenceInfo)(
		/*[in]*/ DEBUGREF_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[in,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[out]*/ DEBUG_REFERENCE_INFO* /*pReferenceInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsReference)(
		/*[in,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[in]*/ IDebugReference2* /*pValue*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGREF_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DBG_ATTRIB_FLAGS /*dwAttribFilter*/,
		/*[in,ptr]*/ LPCOLESTR /*pszNameFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ IEnumDebugReferenceInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugReference2** /*ppParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDerivedMostReference)(
		/*[out]*/ IDebugReference2** /*ppDerivedMost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** /*ppMemory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetReferenceType)(
		/*[in]*/ REFERENCE_TYPE /*dwRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Compare)(
		/*[in]*/ REFERENCE_COMPARE /*dwCompare*/,
		/*[in]*/ IDebugReference2* /*pReference*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugReference2MockImpl :
	public IDebugReference2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugReference2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugReference2MockImpl)

	typedef IDebugReference2 Interface;
	struct GetReferenceInfoValidValues
	{
		/*[in]*/ DEBUGREF_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[in,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[out]*/ DEBUG_REFERENCE_INFO* pReferenceInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetReferenceInfo)(
		/*[in]*/ DEBUGREF_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[in,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[out]*/ DEBUG_REFERENCE_INFO* pReferenceInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetReferenceInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_SET_VALIDVALUE(pReferenceInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsReferenceValidValues
	{
		/*[in,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[in]*/ IDebugReference2* pValue;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsReference)(
		/*[in,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[in]*/ IDebugReference2* pValue,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsReference)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pValue);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumChildrenValidValues
	{
		/*[in]*/ DEBUGREF_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter;
		/*[in,ptr]*/ LPCOLESTR pszNameFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ IEnumDebugReferenceInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGREF_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter,
		/*[in,ptr]*/ LPCOLESTR pszNameFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ IEnumDebugReferenceInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumChildren)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwAttribFilter);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentValidValues
	{
		/*[out]*/ IDebugReference2** ppParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugReference2** ppParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParent)

		VSL_SET_VALIDVALUE_INTERFACE(ppParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDerivedMostReferenceValidValues
	{
		/*[out]*/ IDebugReference2** ppDerivedMost;
		HRESULT retValue;
	};

	STDMETHOD(GetDerivedMostReference)(
		/*[out]*/ IDebugReference2** ppDerivedMost)
	{
		VSL_DEFINE_MOCK_METHOD(GetDerivedMostReference)

		VSL_SET_VALIDVALUE_INTERFACE(ppDerivedMost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryContextValidValues
	{
		/*[out]*/ IDebugMemoryContext2** ppMemory;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** ppMemory)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ DWORD* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetReferenceTypeValidValues
	{
		/*[in]*/ REFERENCE_TYPE dwRefType;
		HRESULT retValue;
	};

	STDMETHOD(SetReferenceType)(
		/*[in]*/ REFERENCE_TYPE dwRefType)
	{
		VSL_DEFINE_MOCK_METHOD(SetReferenceType)

		VSL_CHECK_VALIDVALUE(dwRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct CompareValidValues
	{
		/*[in]*/ REFERENCE_COMPARE dwCompare;
		/*[in]*/ IDebugReference2* pReference;
		HRESULT retValue;
	};

	STDMETHOD(Compare)(
		/*[in]*/ REFERENCE_COMPARE dwCompare,
		/*[in]*/ IDebugReference2* pReference)
	{
		VSL_DEFINE_MOCK_METHOD(Compare)

		VSL_CHECK_VALIDVALUE(dwCompare);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pReference);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGREFERENCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSession2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSESSION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSESSION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSession2NotImpl :
	public IDebugSession2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSession2NotImpl)

public:

	typedef IDebugSession2 Interface;

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ LPCOLESTR /*pszName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Launch)(
		/*[in,ptr]*/ LPCOLESTR /*pszMachine*/,
		/*[in]*/ IDebugPort2* /*pPort*/,
		/*[in,ptr]*/ LPCOLESTR /*pszExe*/,
		/*[in,ptr]*/ LPCOLESTR /*pszArgs*/,
		/*[in,ptr]*/ LPCOLESTR /*pszDir*/,
		/*[in,ptr]*/ BSTR /*bstrEnv*/,
		/*[in,ptr]*/ LPCOLESTR /*pszOptions*/,
		/*[in]*/ LAUNCH_FLAGS /*dwLaunchFlags*/,
		/*[in]*/ DWORD /*hStdInput*/,
		/*[in]*/ DWORD /*hStdOutput*/,
		/*[in]*/ DWORD /*hStdError*/,
		/*[in]*/ REFGUID /*guidLaunchingEngine*/,
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterJITServer)(
		/*[in]*/ REFCLSID /*clsidJITServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)(
		/*[in]*/ BOOL /*fForce*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* /*pBPRequest*/,
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPendingBreakpoints)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in,ptr]*/ LPCOLESTR /*pszProgram*/,
		/*[out]*/ IEnumDebugPendingBreakpoints2** /*ppEnumBPs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumMachines__deprecated)(
		/*[out]*/ IEnumDebugMachines2__deprecated** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConnectToServer)(
		/*[in,ptr]*/ LPCOLESTR /*szServerName*/,
		/*[out]*/ IDebugCoreServer2** /*ppServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisconnectServer)(
		/*[in]*/ IDebugCoreServer2* /*pServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShutdownSession)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in]*/ IDebugDocumentPosition2* /*pDocPos*/,
		/*[out]*/ IEnumDebugCodeContexts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumSetExceptions)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in,ptr]*/ LPCOLESTR /*pszProgram*/,
		/*[in]*/ REFGUID /*guidType*/,
		/*[out]*/ IEnumDebugExceptionInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID /*guidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumDefaultExceptions)(
		/*[in,ptr]*/ EXCEPTION_INFO* /*pParentException*/,
		/*[out]*/ IEnumDebugExceptionInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCUpdate)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[out]*/ IDebugENCUpdate** /*ppUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD /*wLangID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR /*pszRegistryRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsAlive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearAllSessionThreadStackFrames)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(__deprecated_GetSessionId)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[in,ptr]*/ LPCOLESTR /*pszStartPageUrl*/,
		/*[out]*/ BSTR* /*pbstrSessionId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEngineMetric)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ LPCOLESTR /*pszMetric*/,
		/*[in]*/ VARIANT /*varValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStoppingModel)(
		/*[in]*/ STOPPING_MODEL /*dwStoppingModel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoppingModel)(
		/*[out]*/ STOPPING_MODEL* /*pdwStoppingModel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(__deprecated_RegisterSessionWithServer)(
		/*[in]*/ LPCOLESTR /*pwszServerName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSession2MockImpl :
	public IDebugSession2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSession2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSession2MockImpl)

	typedef IDebugSession2 Interface;
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ LPCOLESTR pszName)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProcessesValidValues
	{
		/*[out]*/ IEnumDebugProcesses2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProcesses)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct LaunchValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszMachine;
		/*[in]*/ IDebugPort2* pPort;
		/*[in,ptr]*/ LPCOLESTR pszExe;
		/*[in,ptr]*/ LPCOLESTR pszArgs;
		/*[in,ptr]*/ LPCOLESTR pszDir;
		/*[in,ptr]*/ BSTR bstrEnv;
		/*[in,ptr]*/ LPCOLESTR pszOptions;
		/*[in]*/ LAUNCH_FLAGS dwLaunchFlags;
		/*[in]*/ DWORD hStdInput;
		/*[in]*/ DWORD hStdOutput;
		/*[in]*/ DWORD hStdError;
		/*[in]*/ REFGUID guidLaunchingEngine;
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(Launch)(
		/*[in,ptr]*/ LPCOLESTR pszMachine,
		/*[in]*/ IDebugPort2* pPort,
		/*[in,ptr]*/ LPCOLESTR pszExe,
		/*[in,ptr]*/ LPCOLESTR pszArgs,
		/*[in,ptr]*/ LPCOLESTR pszDir,
		/*[in,ptr]*/ BSTR bstrEnv,
		/*[in,ptr]*/ LPCOLESTR pszOptions,
		/*[in]*/ LAUNCH_FLAGS dwLaunchFlags,
		/*[in]*/ DWORD hStdInput,
		/*[in]*/ DWORD hStdOutput,
		/*[in]*/ DWORD hStdError,
		/*[in]*/ REFGUID guidLaunchingEngine,
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(Launch)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMachine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExe);

		VSL_CHECK_VALIDVALUE_STRINGW(pszArgs);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDir);

		VSL_CHECK_VALIDVALUE_BSTR(bstrEnv);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOptions);

		VSL_CHECK_VALIDVALUE(dwLaunchFlags);

		VSL_CHECK_VALIDVALUE(hStdInput);

		VSL_CHECK_VALIDVALUE(hStdOutput);

		VSL_CHECK_VALIDVALUE(hStdError);

		VSL_CHECK_VALIDVALUE(guidLaunchingEngine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterJITServerValidValues
	{
		/*[in]*/ REFCLSID clsidJITServer;
		HRESULT retValue;
	};

	STDMETHOD(RegisterJITServer)(
		/*[in]*/ REFCLSID clsidJITServer)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterJITServer)

		VSL_CHECK_VALIDVALUE(clsidJITServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		/*[in]*/ BOOL fForce;
		HRESULT retValue;
	};

	STDMETHOD(Terminate)(
		/*[in]*/ BOOL fForce)
	{
		VSL_DEFINE_MOCK_METHOD(Terminate)

		VSL_CHECK_VALIDVALUE(fForce);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePendingBreakpointValidValues
	{
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest;
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP;
		HRESULT retValue;
	};

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest,
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePendingBreakpoint)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBPRequest);

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBP);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPendingBreakpointsValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in,ptr]*/ LPCOLESTR pszProgram;
		/*[out]*/ IEnumDebugPendingBreakpoints2** ppEnumBPs;
		HRESULT retValue;
	};

	STDMETHOD(EnumPendingBreakpoints)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in,ptr]*/ LPCOLESTR pszProgram,
		/*[out]*/ IEnumDebugPendingBreakpoints2** ppEnumBPs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPendingBreakpoints)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProgram);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumBPs);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumMachines__deprecatedValidValues
	{
		/*[out]*/ IEnumDebugMachines2__deprecated** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumMachines__deprecated)(
		/*[out]*/ IEnumDebugMachines2__deprecated** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumMachines__deprecated)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConnectToServerValidValues
	{
		/*[in,ptr]*/ LPCOLESTR szServerName;
		/*[out]*/ IDebugCoreServer2** ppServer;
		HRESULT retValue;
	};

	STDMETHOD(ConnectToServer)(
		/*[in,ptr]*/ LPCOLESTR szServerName,
		/*[out]*/ IDebugCoreServer2** ppServer)
	{
		VSL_DEFINE_MOCK_METHOD(ConnectToServer)

		VSL_CHECK_VALIDVALUE_STRINGW(szServerName);

		VSL_SET_VALIDVALUE_INTERFACE(ppServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisconnectServerValidValues
	{
		/*[in]*/ IDebugCoreServer2* pServer;
		HRESULT retValue;
	};

	STDMETHOD(DisconnectServer)(
		/*[in]*/ IDebugCoreServer2* pServer)
	{
		VSL_DEFINE_MOCK_METHOD(DisconnectServer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShutdownSessionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShutdownSession)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShutdownSession)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodeContextsValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in]*/ IDebugDocumentPosition2* pDocPos;
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in]*/ IDebugDocumentPosition2* pDocPos,
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodeContexts)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDocPos);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(SetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumSetExceptionsValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in,ptr]*/ LPCOLESTR pszProgram;
		/*[in]*/ REFGUID guidType;
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumSetExceptions)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in,ptr]*/ LPCOLESTR pszProgram,
		/*[in]*/ REFGUID guidType,
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSetExceptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProgram);

		VSL_CHECK_VALIDVALUE(guidType);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveSetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveSetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllSetExceptionsValidValues
	{
		/*[in]*/ REFGUID guidType;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID guidType)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAllSetExceptions)

		VSL_CHECK_VALIDVALUE(guidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumDefaultExceptionsValidValues
	{
		/*[in,ptr]*/ EXCEPTION_INFO* pParentException;
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumDefaultExceptions)(
		/*[in,ptr]*/ EXCEPTION_INFO* pParentException,
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumDefaultExceptions)

		VSL_CHECK_VALIDVALUE_POINTER(pParentException);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCUpdateValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[out]*/ IDebugENCUpdate** ppUpdate;
		HRESULT retValue;
	};

	STDMETHOD(GetENCUpdate)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[out]*/ IDebugENCUpdate** ppUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCUpdate)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_SET_VALIDVALUE_INTERFACE(ppUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLocaleValidValues
	{
		/*[in]*/ WORD wLangID;
		HRESULT retValue;
	};

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD wLangID)
	{
		VSL_DEFINE_MOCK_METHOD(SetLocale)

		VSL_CHECK_VALIDVALUE(wLangID);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRegistryRootValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot;
		HRESULT retValue;
	};

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot)
	{
		VSL_DEFINE_MOCK_METHOD(SetRegistryRoot)

		VSL_CHECK_VALIDVALUE_STRINGW(pszRegistryRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsAliveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsAlive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsAlive)

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearAllSessionThreadStackFramesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearAllSessionThreadStackFrames)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearAllSessionThreadStackFrames)

		VSL_RETURN_VALIDVALUES();
	}
	struct __deprecated_GetSessionIdValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[in,ptr]*/ LPCOLESTR pszStartPageUrl;
		/*[out]*/ BSTR* pbstrSessionId;
		HRESULT retValue;
	};

	STDMETHOD(__deprecated_GetSessionId)(
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[in,ptr]*/ LPCOLESTR pszStartPageUrl,
		/*[out]*/ BSTR* pbstrSessionId)
	{
		VSL_DEFINE_MOCK_METHOD(__deprecated_GetSessionId)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_CHECK_VALIDVALUE_STRINGW(pszStartPageUrl);

		VSL_SET_VALIDVALUE_BSTR(pbstrSessionId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEngineMetricValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ LPCOLESTR pszMetric;
		/*[in]*/ VARIANT varValue;
		HRESULT retValue;
	};

	STDMETHOD(SetEngineMetric)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ LPCOLESTR pszMetric,
		/*[in]*/ VARIANT varValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetEngineMetric)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStoppingModelValidValues
	{
		/*[in]*/ STOPPING_MODEL dwStoppingModel;
		HRESULT retValue;
	};

	STDMETHOD(SetStoppingModel)(
		/*[in]*/ STOPPING_MODEL dwStoppingModel)
	{
		VSL_DEFINE_MOCK_METHOD(SetStoppingModel)

		VSL_CHECK_VALIDVALUE(dwStoppingModel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoppingModelValidValues
	{
		/*[out]*/ STOPPING_MODEL* pdwStoppingModel;
		HRESULT retValue;
	};

	STDMETHOD(GetStoppingModel)(
		/*[out]*/ STOPPING_MODEL* pdwStoppingModel)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoppingModel)

		VSL_SET_VALIDVALUE(pdwStoppingModel);

		VSL_RETURN_VALIDVALUES();
	}
	struct __deprecated_RegisterSessionWithServerValidValues
	{
		/*[in]*/ LPCOLESTR pwszServerName;
		HRESULT retValue;
	};

	STDMETHOD(__deprecated_RegisterSessionWithServer)(
		/*[in]*/ LPCOLESTR pwszServerName)
	{
		VSL_DEFINE_MOCK_METHOD(__deprecated_RegisterSessionWithServer)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszServerName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSESSION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSessionEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSESSIONEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSESSIONEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSessionEvent2NotImpl :
	public IDebugSessionEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSessionEvent2NotImpl)

public:

	typedef IDebugSessionEvent2 Interface;

	STDMETHOD(GetSession)(
		/*[out]*/ IDebugSession2** /*ppSession*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSessionEvent2MockImpl :
	public IDebugSessionEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSessionEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSessionEvent2MockImpl)

	typedef IDebugSessionEvent2 Interface;
	struct GetSessionValidValues
	{
		/*[out]*/ IDebugSession2** ppSession;
		HRESULT retValue;
	};

	STDMETHOD(GetSession)(
		/*[out]*/ IDebugSession2** ppSession)
	{
		VSL_DEFINE_MOCK_METHOD(GetSession)

		VSL_SET_VALIDVALUE_INTERFACE(ppSession);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSESSIONEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSettingsCallback2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSETTINGSCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSETTINGSCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSettingsCallback2NotImpl :
	public IDebugSettingsCallback2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSettingsCallback2NotImpl)

public:

	typedef IDebugSettingsCallback2 Interface;

	STDMETHOD(GetMetricGuid)(
		/*[in]*/ LPCWSTR /*pszType*/,
		/*[in]*/ REFGUID /*guidSection*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ GUID* /*pguidValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMetricDword)(
		/*[in]*/ LPCWSTR /*pszType*/,
		/*[in]*/ REFGUID /*guidSection*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ DWORD* /*pdwValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEEMetricString)(
		/*[in]*/ REFGUID /*guidLang*/,
		/*[in]*/ REFGUID /*guidVendor*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEEMetricGuid)(
		/*[in]*/ REFGUID /*guidLang*/,
		/*[in]*/ REFGUID /*guidVendor*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ GUID* /*pguidValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEEMetricFile)(
		/*[in]*/ REFGUID /*guidLang*/,
		/*[in]*/ REFGUID /*guidVendor*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumEEs)(
		/*[in]*/ DWORD /*celtBuffer*/,
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEEs)]*/ GUID* /*rgguidLang*/,
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEEs)]*/ GUID* /*rgguidVendor*/,
		/*[in,out]*/ DWORD* /*pceltEEs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEEMetricDword)(
		/*[in]*/ REFGUID /*guidLang*/,
		/*[in]*/ REFGUID /*guidVendor*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ DWORD* /*pdwValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEELocalObject)(
		/*[in]*/ REFGUID /*guidLang*/,
		/*[in]*/ REFGUID /*guidVendor*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMetricString)(
		/*[in]*/ LPCWSTR /*pszType*/,
		/*[in]*/ REFGUID /*guidSection*/,
		/*[in]*/ LPCWSTR /*pszMetric*/,
		/*[out]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSettingsCallback2MockImpl :
	public IDebugSettingsCallback2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSettingsCallback2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSettingsCallback2MockImpl)

	typedef IDebugSettingsCallback2 Interface;
	struct GetMetricGuidValidValues
	{
		/*[in]*/ LPCWSTR pszType;
		/*[in]*/ REFGUID guidSection;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ GUID* pguidValue;
		HRESULT retValue;
	};

	STDMETHOD(GetMetricGuid)(
		/*[in]*/ LPCWSTR pszType,
		/*[in]*/ REFGUID guidSection,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ GUID* pguidValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetMetricGuid)

		VSL_CHECK_VALIDVALUE_STRINGW(pszType);

		VSL_CHECK_VALIDVALUE(guidSection);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE(pguidValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMetricDwordValidValues
	{
		/*[in]*/ LPCWSTR pszType;
		/*[in]*/ REFGUID guidSection;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ DWORD* pdwValue;
		HRESULT retValue;
	};

	STDMETHOD(GetMetricDword)(
		/*[in]*/ LPCWSTR pszType,
		/*[in]*/ REFGUID guidSection,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ DWORD* pdwValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetMetricDword)

		VSL_CHECK_VALIDVALUE_STRINGW(pszType);

		VSL_CHECK_VALIDVALUE(guidSection);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE(pdwValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEEMetricStringValidValues
	{
		/*[in]*/ REFGUID guidLang;
		/*[in]*/ REFGUID guidVendor;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetEEMetricString)(
		/*[in]*/ REFGUID guidLang,
		/*[in]*/ REFGUID guidVendor,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetEEMetricString)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(guidVendor);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEEMetricGuidValidValues
	{
		/*[in]*/ REFGUID guidLang;
		/*[in]*/ REFGUID guidVendor;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ GUID* pguidValue;
		HRESULT retValue;
	};

	STDMETHOD(GetEEMetricGuid)(
		/*[in]*/ REFGUID guidLang,
		/*[in]*/ REFGUID guidVendor,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ GUID* pguidValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetEEMetricGuid)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(guidVendor);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE(pguidValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEEMetricFileValidValues
	{
		/*[in]*/ REFGUID guidLang;
		/*[in]*/ REFGUID guidVendor;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetEEMetricFile)(
		/*[in]*/ REFGUID guidLang,
		/*[in]*/ REFGUID guidVendor,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetEEMetricFile)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(guidVendor);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumEEsValidValues
	{
		/*[in]*/ DWORD celtBuffer;
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEEs)]*/ GUID* rgguidLang;
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEEs)]*/ GUID* rgguidVendor;
		/*[in,out]*/ DWORD* pceltEEs;
		HRESULT retValue;
	};

	STDMETHOD(EnumEEs)(
		/*[in]*/ DWORD celtBuffer,
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEEs)]*/ GUID* rgguidLang,
		/*[in,out,ptr,size_is(celtBuffer),length_is(*pceltEEs)]*/ GUID* rgguidVendor,
		/*[in,out]*/ DWORD* pceltEEs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumEEs)

		VSL_CHECK_VALIDVALUE(celtBuffer);

		VSL_SET_VALIDVALUE_MEMCPY(rgguidLang, celtBuffer*sizeof(rgguidLang[0]), *(validValues.pceltEEs)*sizeof(validValues.rgguidLang[0]));

		VSL_SET_VALIDVALUE_MEMCPY(rgguidVendor, celtBuffer*sizeof(rgguidVendor[0]), *(validValues.pceltEEs)*sizeof(validValues.rgguidVendor[0]));

		VSL_SET_VALIDVALUE(pceltEEs);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEEMetricDwordValidValues
	{
		/*[in]*/ REFGUID guidLang;
		/*[in]*/ REFGUID guidVendor;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ DWORD* pdwValue;
		HRESULT retValue;
	};

	STDMETHOD(GetEEMetricDword)(
		/*[in]*/ REFGUID guidLang,
		/*[in]*/ REFGUID guidVendor,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ DWORD* pdwValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetEEMetricDword)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(guidVendor);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE(pdwValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEELocalObjectValidValues
	{
		/*[in]*/ REFGUID guidLang;
		/*[in]*/ REFGUID guidVendor;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(GetEELocalObject)(
		/*[in]*/ REFGUID guidLang,
		/*[in]*/ REFGUID guidVendor,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(GetEELocalObject)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(guidVendor);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMetricStringValidValues
	{
		/*[in]*/ LPCWSTR pszType;
		/*[in]*/ REFGUID guidSection;
		/*[in]*/ LPCWSTR pszMetric;
		/*[out]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetMetricString)(
		/*[in]*/ LPCWSTR pszType,
		/*[in]*/ REFGUID guidSection,
		/*[in]*/ LPCWSTR pszMetric,
		/*[out]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetMetricString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszType);

		VSL_CHECK_VALIDVALUE(guidSection);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSETTINGSCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSessionProperty2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSESSIONPROPERTY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSESSIONPROPERTY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSessionProperty2NotImpl :
	public IDebugSessionProperty2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSessionProperty2NotImpl)

public:

	typedef IDebugSessionProperty2 Interface;

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThread)(
		/*[out]*/ IDebugThread3** /*ppThread*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStringCharLength)(
		/*[out]*/ ULONG* /*pLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStringChars)(
		/*[in]*/ ULONG /*buflen*/,
		/*[out,size_is(buflen),length_is(*pceltFetched)]*/ WCHAR* /*rgString*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateObjectID)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DestroyObjectID)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomViewerCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomViewerList)(
		/*[in]*/ ULONG /*celtSkip*/,
		/*[in]*/ ULONG /*celtRequested*/,
		/*[out,size_is(celtRequested),length_is(*pceltFetched)]*/ DEBUG_CUSTOM_VIEWER* /*rgViewers*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsStringWithError)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ BSTR* /*errorString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[out]*/ DEBUG_PROPERTY_INFO* /*pPropertyInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR /*pszValue*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** /*rgpArgs*/,
		/*[in]*/ DWORD /*dwArgCount*/,
		/*[in]*/ IDebugReference2* /*pValue*/,
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ DWORD /*dwRadix*/,
		/*[in]*/ REFGUID /*guidFilter*/,
		/*[in]*/ DBG_ATTRIB_FLAGS /*dwAttribFilter*/,
		/*[in,ptr]*/ LPCOLESTR /*pszNameFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** /*ppParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** /*ppDerivedMost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** /*ppMemoryBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** /*ppMemory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** /*ppReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID /*guidExtendedInfo*/,
		/*[out]*/ VARIANT* /*pExtendedInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSessionProperty2MockImpl :
	public IDebugSessionProperty2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSessionProperty2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSessionProperty2MockImpl)

	typedef IDebugSessionProperty2 Interface;
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadValidValues
	{
		/*[out]*/ IDebugThread3** ppThread;
		HRESULT retValue;
	};

	STDMETHOD(GetThread)(
		/*[out]*/ IDebugThread3** ppThread)
	{
		VSL_DEFINE_MOCK_METHOD(GetThread)

		VSL_SET_VALIDVALUE_INTERFACE(ppThread);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStringCharLengthValidValues
	{
		/*[out]*/ ULONG* pLen;
		HRESULT retValue;
	};

	STDMETHOD(GetStringCharLength)(
		/*[out]*/ ULONG* pLen)
	{
		VSL_DEFINE_MOCK_METHOD(GetStringCharLength)

		VSL_SET_VALIDVALUE(pLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStringCharsValidValues
	{
		/*[in]*/ ULONG buflen;
		/*[out,size_is(buflen),length_is(*pceltFetched)]*/ WCHAR* rgString;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetStringChars)(
		/*[in]*/ ULONG buflen,
		/*[out,size_is(buflen),length_is(*pceltFetched)]*/ WCHAR* rgString,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetStringChars)

		VSL_CHECK_VALIDVALUE(buflen);

		VSL_SET_VALIDVALUE_STRINGW(rgString, buflen);

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateObjectIDValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CreateObjectID)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CreateObjectID)

		VSL_RETURN_VALIDVALUES();
	}
	struct DestroyObjectIDValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DestroyObjectID)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DestroyObjectID)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomViewerCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomViewerCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomViewerCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomViewerListValidValues
	{
		/*[in]*/ ULONG celtSkip;
		/*[in]*/ ULONG celtRequested;
		/*[out,size_is(celtRequested),length_is(*pceltFetched)]*/ DEBUG_CUSTOM_VIEWER* rgViewers;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomViewerList)(
		/*[in]*/ ULONG celtSkip,
		/*[in]*/ ULONG celtRequested,
		/*[out,size_is(celtRequested),length_is(*pceltFetched)]*/ DEBUG_CUSTOM_VIEWER* rgViewers,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomViewerList)

		VSL_CHECK_VALIDVALUE(celtSkip);

		VSL_CHECK_VALIDVALUE(celtRequested);

		VSL_SET_VALIDVALUE_MEMCPY(rgViewers, celtRequested*sizeof(rgViewers[0]), *(validValues.pceltFetched)*sizeof(validValues.rgViewers[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringWithErrorValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ BSTR* errorString;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsStringWithError)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ BSTR* errorString)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsStringWithError)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_BSTR(errorString);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyInfoValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout,
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[out]*/ DEBUG_PROPERTY_INFO* pPropertyInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyInfo)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_SET_VALIDVALUE(pPropertyInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsStringValidValues
	{
		/*[in]*/ LPCOLESTR pszValue;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsString)(
		/*[in]*/ LPCOLESTR pszValue,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszValue);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueAsReferenceValidValues
	{
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs;
		/*[in]*/ DWORD dwArgCount;
		/*[in]*/ IDebugReference2* pValue;
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(SetValueAsReference)(
		/*[in,ptr,size_is(dwArgCount),length_is(dwArgCount)]*/ IDebugReference2** rgpArgs,
		/*[in]*/ DWORD dwArgCount,
		/*[in]*/ IDebugReference2* pValue,
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(SetValueAsReference)

		VSL_CHECK_VALIDVALUE_ARRAY(rgpArgs, dwArgCount, validValues.dwArgCount);

		VSL_CHECK_VALIDVALUE(dwArgCount);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pValue);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumChildrenValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ DWORD dwRadix;
		/*[in]*/ REFGUID guidFilter;
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter;
		/*[in,ptr]*/ LPCOLESTR pszNameFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumChildren)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ DWORD dwRadix,
		/*[in]*/ REFGUID guidFilter,
		/*[in]*/ DBG_ATTRIB_FLAGS dwAttribFilter,
		/*[in,ptr]*/ LPCOLESTR pszNameFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumChildren)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(dwRadix);

		VSL_CHECK_VALIDVALUE(guidFilter);

		VSL_CHECK_VALIDVALUE(dwAttribFilter);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentValidValues
	{
		/*[out]*/ IDebugProperty2** ppParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParent)(
		/*[out]*/ IDebugProperty2** ppParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParent)

		VSL_SET_VALIDVALUE_INTERFACE(ppParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDerivedMostPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppDerivedMost;
		HRESULT retValue;
	};

	STDMETHOD(GetDerivedMostProperty)(
		/*[out]*/ IDebugProperty2** ppDerivedMost)
	{
		VSL_DEFINE_MOCK_METHOD(GetDerivedMostProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppDerivedMost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryBytesValidValues
	{
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryBytes)(
		/*[out]*/ IDebugMemoryBytes2** ppMemoryBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryBytes)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemoryBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemoryContextValidValues
	{
		/*[out]*/ IDebugMemoryContext2** ppMemory;
		HRESULT retValue;
	};

	STDMETHOD(GetMemoryContext)(
		/*[out]*/ IDebugMemoryContext2** ppMemory)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemoryContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppMemory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ DWORD* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ DWORD* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceValidValues
	{
		/*[out]*/ IDebugReference2** ppReference;
		HRESULT retValue;
	};

	STDMETHOD(GetReference)(
		/*[out]*/ IDebugReference2** ppReference)
	{
		VSL_DEFINE_MOCK_METHOD(GetReference)

		VSL_SET_VALIDVALUE_INTERFACE(ppReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedInfoValidValues
	{
		/*[in]*/ REFGUID guidExtendedInfo;
		/*[out]*/ VARIANT* pExtendedInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedInfo)(
		/*[in]*/ REFGUID guidExtendedInfo,
		/*[out]*/ VARIANT* pExtendedInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedInfo)

		VSL_CHECK_VALIDVALUE(guidExtendedInfo);

		VSL_SET_VALIDVALUE_VARIANT(pExtendedInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSESSIONPROPERTY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSQLCLRProgramNode2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSQLCLRPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSQLCLRPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSQLCLRProgramNode2NotImpl :
	public IDebugSQLCLRProgramNode2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSQLCLRProgramNode2NotImpl)

public:

	typedef IDebugSQLCLRProgramNode2 Interface;

	STDMETHOD(GetConnectionId)(
		/*[out]*/ DWORD* /*pdwId*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSQLCLRProgramNode2MockImpl :
	public IDebugSQLCLRProgramNode2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSQLCLRProgramNode2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSQLCLRProgramNode2MockImpl)

	typedef IDebugSQLCLRProgramNode2 Interface;
	struct GetConnectionIdValidValues
	{
		/*[out]*/ DWORD* pdwId;
		HRESULT retValue;
	};

	STDMETHOD(GetConnectionId)(
		/*[out]*/ DWORD* pdwId)
	{
		VSL_DEFINE_MOCK_METHOD(GetConnectionId)

		VSL_SET_VALIDVALUE(pdwId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSQLCLRPROGRAMNODE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSession3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSESSION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSESSION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSession3NotImpl :
	public IDebugSession3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSession3NotImpl)

public:

	typedef IDebugSession3 Interface;

	STDMETHOD(SetSymbolPath)(
		/*[in,ptr]*/ LPCOLESTR /*szSymbolSearchPath*/,
		/*[in,ptr]*/ LPCOLESTR /*szSymbolCachePath*/,
		/*[in]*/ LOAD_SYMBOLS_FLAGS /*Flags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadSymbols)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterCallback)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConnectToServerEx)(
		/*[in,ptr]*/ LPCOLESTR /*szServerName*/,
		/*[in]*/ CONNECT_REASON /*ConnectReason*/,
		/*[out]*/ IDebugCoreServer3** /*ppServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetJustMyCodeState)(
		/*[in]*/ BOOL /*fUpdate*/,
		/*[in]*/ DWORD /*dwModules*/,
		/*[in,size_is(dwModules),ptr]*/ JMC_CODE_SPEC* /*rgJMCSpec*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRecentServerNames)(
		/*[out]*/ BSTR_ARRAY* /*pServers*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMaxRecentServerNames)(
		/*[in]*/ DWORD /*dwNewMax*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeFeatures)(
		/*[in]*/ SESSION_FEATURES /*EnabledFeatures*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAllExceptions)(
		/*[in]*/ EXCEPTION_STATE /*dwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStateForAllExceptions)(
		/*[out]*/ EXCEPTION_STATE* /*pdwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddExceptionCallback)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/,
		/*[in]*/ IDebugExceptionCallback2* /*pCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveExceptionCallback)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/,
		/*[in]*/ IDebugExceptionCallback2* /*pCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BlockingShutdownSession)(
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ LPCOLESTR /*pszName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Launch)(
		/*[in,ptr]*/ LPCOLESTR /*pszMachine*/,
		/*[in]*/ IDebugPort2* /*pPort*/,
		/*[in,ptr]*/ LPCOLESTR /*pszExe*/,
		/*[in,ptr]*/ LPCOLESTR /*pszArgs*/,
		/*[in,ptr]*/ LPCOLESTR /*pszDir*/,
		/*[in,ptr]*/ BSTR /*bstrEnv*/,
		/*[in,ptr]*/ LPCOLESTR /*pszOptions*/,
		/*[in]*/ LAUNCH_FLAGS /*dwLaunchFlags*/,
		/*[in]*/ DWORD /*hStdInput*/,
		/*[in]*/ DWORD /*hStdOutput*/,
		/*[in]*/ DWORD /*hStdError*/,
		/*[in]*/ REFGUID /*guidLaunchingEngine*/,
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[out]*/ IDebugProcess2** /*ppProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterJITServer)(
		/*[in]*/ REFCLSID /*clsidJITServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)(
		/*[in]*/ BOOL /*fForce*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CauseBreak)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* /*pBPRequest*/,
		/*[out]*/ IDebugPendingBreakpoint2** /*ppPendingBP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPendingBreakpoints)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in,ptr]*/ LPCOLESTR /*pszProgram*/,
		/*[out]*/ IEnumDebugPendingBreakpoints2** /*ppEnumBPs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumMachines__deprecated)(
		/*[out]*/ IEnumDebugMachines2__deprecated** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConnectToServer)(
		/*[in,ptr]*/ LPCOLESTR /*szServerName*/,
		/*[out]*/ IDebugCoreServer2** /*ppServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisconnectServer)(
		/*[in]*/ IDebugCoreServer2* /*pServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShutdownSession)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in]*/ IDebugDocumentPosition2* /*pDocPos*/,
		/*[out]*/ IEnumDebugCodeContexts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumSetExceptions)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[in,ptr]*/ LPCOLESTR /*pszProgram*/,
		/*[in]*/ REFGUID /*guidType*/,
		/*[out]*/ IEnumDebugExceptionInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* /*pException*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID /*guidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumDefaultExceptions)(
		/*[in,ptr]*/ EXCEPTION_INFO* /*pParentException*/,
		/*[out]*/ IEnumDebugExceptionInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCUpdate)(
		/*[in]*/ IDebugProgram2* /*pProgram*/,
		/*[out]*/ IDebugENCUpdate** /*ppUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD /*wLangID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR /*pszRegistryRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsAlive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearAllSessionThreadStackFrames)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(__deprecated_GetSessionId)(
		/*[in]*/ IDebugEventCallback2* /*pCallback*/,
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* /*rgguidSpecificEngines*/,
		/*[in]*/ DWORD /*celtSpecificEngines*/,
		/*[in,ptr]*/ LPCOLESTR /*pszStartPageUrl*/,
		/*[out]*/ BSTR* /*pbstrSessionId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEngineMetric)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ LPCOLESTR /*pszMetric*/,
		/*[in]*/ VARIANT /*varValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStoppingModel)(
		/*[in]*/ STOPPING_MODEL /*dwStoppingModel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoppingModel)(
		/*[out]*/ STOPPING_MODEL* /*pdwStoppingModel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(__deprecated_RegisterSessionWithServer)(
		/*[in]*/ LPCOLESTR /*pwszServerName*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSession3MockImpl :
	public IDebugSession3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSession3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSession3MockImpl)

	typedef IDebugSession3 Interface;
	struct SetSymbolPathValidValues
	{
		/*[in,ptr]*/ LPCOLESTR szSymbolSearchPath;
		/*[in,ptr]*/ LPCOLESTR szSymbolCachePath;
		/*[in]*/ LOAD_SYMBOLS_FLAGS Flags;
		HRESULT retValue;
	};

	STDMETHOD(SetSymbolPath)(
		/*[in,ptr]*/ LPCOLESTR szSymbolSearchPath,
		/*[in,ptr]*/ LPCOLESTR szSymbolCachePath,
		/*[in]*/ LOAD_SYMBOLS_FLAGS Flags)
	{
		VSL_DEFINE_MOCK_METHOD(SetSymbolPath)

		VSL_CHECK_VALIDVALUE_STRINGW(szSymbolSearchPath);

		VSL_CHECK_VALIDVALUE_STRINGW(szSymbolCachePath);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadSymbolsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LoadSymbols)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LoadSymbols)

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterCallbackValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		HRESULT retValue;
	};

	STDMETHOD(RegisterCallback)(
		/*[in]*/ IDebugEventCallback2* pCallback)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConnectToServerExValidValues
	{
		/*[in,ptr]*/ LPCOLESTR szServerName;
		/*[in]*/ CONNECT_REASON ConnectReason;
		/*[out]*/ IDebugCoreServer3** ppServer;
		HRESULT retValue;
	};

	STDMETHOD(ConnectToServerEx)(
		/*[in,ptr]*/ LPCOLESTR szServerName,
		/*[in]*/ CONNECT_REASON ConnectReason,
		/*[out]*/ IDebugCoreServer3** ppServer)
	{
		VSL_DEFINE_MOCK_METHOD(ConnectToServerEx)

		VSL_CHECK_VALIDVALUE_STRINGW(szServerName);

		VSL_CHECK_VALIDVALUE(ConnectReason);

		VSL_SET_VALIDVALUE_INTERFACE(ppServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetJustMyCodeStateValidValues
	{
		/*[in]*/ BOOL fUpdate;
		/*[in]*/ DWORD dwModules;
		/*[in,size_is(dwModules),ptr]*/ JMC_CODE_SPEC* rgJMCSpec;
		HRESULT retValue;
	};

	STDMETHOD(SetJustMyCodeState)(
		/*[in]*/ BOOL fUpdate,
		/*[in]*/ DWORD dwModules,
		/*[in,size_is(dwModules),ptr]*/ JMC_CODE_SPEC* rgJMCSpec)
	{
		VSL_DEFINE_MOCK_METHOD(SetJustMyCodeState)

		VSL_CHECK_VALIDVALUE(fUpdate);

		VSL_CHECK_VALIDVALUE(dwModules);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgJMCSpec, dwModules*sizeof(rgJMCSpec[0]), validValues.dwModules*sizeof(validValues.rgJMCSpec[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRecentServerNamesValidValues
	{
		/*[out]*/ BSTR_ARRAY* pServers;
		HRESULT retValue;
	};

	STDMETHOD(GetRecentServerNames)(
		/*[out]*/ BSTR_ARRAY* pServers)
	{
		VSL_DEFINE_MOCK_METHOD(GetRecentServerNames)

		VSL_SET_VALIDVALUE(pServers);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMaxRecentServerNamesValidValues
	{
		/*[in]*/ DWORD dwNewMax;
		HRESULT retValue;
	};

	STDMETHOD(SetMaxRecentServerNames)(
		/*[in]*/ DWORD dwNewMax)
	{
		VSL_DEFINE_MOCK_METHOD(SetMaxRecentServerNames)

		VSL_CHECK_VALIDVALUE(dwNewMax);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeFeaturesValidValues
	{
		/*[in]*/ SESSION_FEATURES EnabledFeatures;
		HRESULT retValue;
	};

	STDMETHOD(InitializeFeatures)(
		/*[in]*/ SESSION_FEATURES EnabledFeatures)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeFeatures)

		VSL_CHECK_VALIDVALUE(EnabledFeatures);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAllExceptionsValidValues
	{
		/*[in]*/ EXCEPTION_STATE dwState;
		HRESULT retValue;
	};

	STDMETHOD(SetAllExceptions)(
		/*[in]*/ EXCEPTION_STATE dwState)
	{
		VSL_DEFINE_MOCK_METHOD(SetAllExceptions)

		VSL_CHECK_VALIDVALUE(dwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateForAllExceptionsValidValues
	{
		/*[out]*/ EXCEPTION_STATE* pdwState;
		HRESULT retValue;
	};

	STDMETHOD(GetStateForAllExceptions)(
		/*[out]*/ EXCEPTION_STATE* pdwState)
	{
		VSL_DEFINE_MOCK_METHOD(GetStateForAllExceptions)

		VSL_SET_VALIDVALUE(pdwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddExceptionCallbackValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		/*[in]*/ IDebugExceptionCallback2* pCallback;
		HRESULT retValue;
	};

	STDMETHOD(AddExceptionCallback)(
		/*[in]*/ EXCEPTION_INFO* pException,
		/*[in]*/ IDebugExceptionCallback2* pCallback)
	{
		VSL_DEFINE_MOCK_METHOD(AddExceptionCallback)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveExceptionCallbackValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		/*[in]*/ IDebugExceptionCallback2* pCallback;
		HRESULT retValue;
	};

	STDMETHOD(RemoveExceptionCallback)(
		/*[in]*/ EXCEPTION_INFO* pException,
		/*[in]*/ IDebugExceptionCallback2* pCallback)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveExceptionCallback)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct BlockingShutdownSessionValidValues
	{
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(BlockingShutdownSession)(
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(BlockingShutdownSession)

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ LPCOLESTR pszName)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumProcessesValidValues
	{
		/*[out]*/ IEnumDebugProcesses2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumProcesses)(
		/*[out]*/ IEnumDebugProcesses2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProcesses)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct LaunchValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszMachine;
		/*[in]*/ IDebugPort2* pPort;
		/*[in,ptr]*/ LPCOLESTR pszExe;
		/*[in,ptr]*/ LPCOLESTR pszArgs;
		/*[in,ptr]*/ LPCOLESTR pszDir;
		/*[in,ptr]*/ BSTR bstrEnv;
		/*[in,ptr]*/ LPCOLESTR pszOptions;
		/*[in]*/ LAUNCH_FLAGS dwLaunchFlags;
		/*[in]*/ DWORD hStdInput;
		/*[in]*/ DWORD hStdOutput;
		/*[in]*/ DWORD hStdError;
		/*[in]*/ REFGUID guidLaunchingEngine;
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[out]*/ IDebugProcess2** ppProcess;
		HRESULT retValue;
	};

	STDMETHOD(Launch)(
		/*[in,ptr]*/ LPCOLESTR pszMachine,
		/*[in]*/ IDebugPort2* pPort,
		/*[in,ptr]*/ LPCOLESTR pszExe,
		/*[in,ptr]*/ LPCOLESTR pszArgs,
		/*[in,ptr]*/ LPCOLESTR pszDir,
		/*[in,ptr]*/ BSTR bstrEnv,
		/*[in,ptr]*/ LPCOLESTR pszOptions,
		/*[in]*/ LAUNCH_FLAGS dwLaunchFlags,
		/*[in]*/ DWORD hStdInput,
		/*[in]*/ DWORD hStdOutput,
		/*[in]*/ DWORD hStdError,
		/*[in]*/ REFGUID guidLaunchingEngine,
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in,size_is(celtSpecificEngines)]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[out]*/ IDebugProcess2** ppProcess)
	{
		VSL_DEFINE_MOCK_METHOD(Launch)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMachine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPort);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExe);

		VSL_CHECK_VALIDVALUE_STRINGW(pszArgs);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDir);

		VSL_CHECK_VALIDVALUE_BSTR(bstrEnv);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOptions);

		VSL_CHECK_VALIDVALUE(dwLaunchFlags);

		VSL_CHECK_VALIDVALUE(hStdInput);

		VSL_CHECK_VALIDVALUE(hStdOutput);

		VSL_CHECK_VALIDVALUE(hStdError);

		VSL_CHECK_VALIDVALUE(guidLaunchingEngine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_SET_VALIDVALUE_INTERFACE(ppProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterJITServerValidValues
	{
		/*[in]*/ REFCLSID clsidJITServer;
		HRESULT retValue;
	};

	STDMETHOD(RegisterJITServer)(
		/*[in]*/ REFCLSID clsidJITServer)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterJITServer)

		VSL_CHECK_VALIDVALUE(clsidJITServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		/*[in]*/ BOOL fForce;
		HRESULT retValue;
	};

	STDMETHOD(Terminate)(
		/*[in]*/ BOOL fForce)
	{
		VSL_DEFINE_MOCK_METHOD(Terminate)

		VSL_CHECK_VALIDVALUE(fForce);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct CauseBreakValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CauseBreak)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CauseBreak)

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePendingBreakpointValidValues
	{
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest;
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP;
		HRESULT retValue;
	};

	STDMETHOD(CreatePendingBreakpoint)(
		/*[in]*/ IDebugBreakpointRequest2* pBPRequest,
		/*[out]*/ IDebugPendingBreakpoint2** ppPendingBP)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePendingBreakpoint)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBPRequest);

		VSL_SET_VALIDVALUE_INTERFACE(ppPendingBP);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPendingBreakpointsValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in,ptr]*/ LPCOLESTR pszProgram;
		/*[out]*/ IEnumDebugPendingBreakpoints2** ppEnumBPs;
		HRESULT retValue;
	};

	STDMETHOD(EnumPendingBreakpoints)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in,ptr]*/ LPCOLESTR pszProgram,
		/*[out]*/ IEnumDebugPendingBreakpoints2** ppEnumBPs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPendingBreakpoints)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProgram);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumBPs);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumMachines__deprecatedValidValues
	{
		/*[out]*/ IEnumDebugMachines2__deprecated** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumMachines__deprecated)(
		/*[out]*/ IEnumDebugMachines2__deprecated** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumMachines__deprecated)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConnectToServerValidValues
	{
		/*[in,ptr]*/ LPCOLESTR szServerName;
		/*[out]*/ IDebugCoreServer2** ppServer;
		HRESULT retValue;
	};

	STDMETHOD(ConnectToServer)(
		/*[in,ptr]*/ LPCOLESTR szServerName,
		/*[out]*/ IDebugCoreServer2** ppServer)
	{
		VSL_DEFINE_MOCK_METHOD(ConnectToServer)

		VSL_CHECK_VALIDVALUE_STRINGW(szServerName);

		VSL_SET_VALIDVALUE_INTERFACE(ppServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisconnectServerValidValues
	{
		/*[in]*/ IDebugCoreServer2* pServer;
		HRESULT retValue;
	};

	STDMETHOD(DisconnectServer)(
		/*[in]*/ IDebugCoreServer2* pServer)
	{
		VSL_DEFINE_MOCK_METHOD(DisconnectServer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShutdownSessionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShutdownSession)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShutdownSession)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCodeContextsValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in]*/ IDebugDocumentPosition2* pDocPos;
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumCodeContexts)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in]*/ IDebugDocumentPosition2* pDocPos,
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCodeContexts)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDocPos);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(SetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(SetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumSetExceptionsValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[in,ptr]*/ LPCOLESTR pszProgram;
		/*[in]*/ REFGUID guidType;
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumSetExceptions)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[in,ptr]*/ LPCOLESTR pszProgram,
		/*[in]*/ REFGUID guidType,
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSetExceptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProgram);

		VSL_CHECK_VALIDVALUE(guidType);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveSetExceptionValidValues
	{
		/*[in]*/ EXCEPTION_INFO* pException;
		HRESULT retValue;
	};

	STDMETHOD(RemoveSetException)(
		/*[in]*/ EXCEPTION_INFO* pException)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveSetException)

		VSL_CHECK_VALIDVALUE_POINTER(pException);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllSetExceptionsValidValues
	{
		/*[in]*/ REFGUID guidType;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllSetExceptions)(
		/*[in]*/ REFGUID guidType)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAllSetExceptions)

		VSL_CHECK_VALIDVALUE(guidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumDefaultExceptionsValidValues
	{
		/*[in,ptr]*/ EXCEPTION_INFO* pParentException;
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumDefaultExceptions)(
		/*[in,ptr]*/ EXCEPTION_INFO* pParentException,
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumDefaultExceptions)

		VSL_CHECK_VALIDVALUE_POINTER(pParentException);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCUpdateValidValues
	{
		/*[in]*/ IDebugProgram2* pProgram;
		/*[out]*/ IDebugENCUpdate** ppUpdate;
		HRESULT retValue;
	};

	STDMETHOD(GetENCUpdate)(
		/*[in]*/ IDebugProgram2* pProgram,
		/*[out]*/ IDebugENCUpdate** ppUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCUpdate)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProgram);

		VSL_SET_VALIDVALUE_INTERFACE(ppUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLocaleValidValues
	{
		/*[in]*/ WORD wLangID;
		HRESULT retValue;
	};

	STDMETHOD(SetLocale)(
		/*[in]*/ WORD wLangID)
	{
		VSL_DEFINE_MOCK_METHOD(SetLocale)

		VSL_CHECK_VALIDVALUE(wLangID);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRegistryRootValidValues
	{
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot;
		HRESULT retValue;
	};

	STDMETHOD(SetRegistryRoot)(
		/*[in,ptr]*/ LPCOLESTR pszRegistryRoot)
	{
		VSL_DEFINE_MOCK_METHOD(SetRegistryRoot)

		VSL_CHECK_VALIDVALUE_STRINGW(pszRegistryRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsAliveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsAlive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsAlive)

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearAllSessionThreadStackFramesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearAllSessionThreadStackFrames)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearAllSessionThreadStackFrames)

		VSL_RETURN_VALIDVALUES();
	}
	struct __deprecated_GetSessionIdValidValues
	{
		/*[in]*/ IDebugEventCallback2* pCallback;
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* rgguidSpecificEngines;
		/*[in]*/ DWORD celtSpecificEngines;
		/*[in,ptr]*/ LPCOLESTR pszStartPageUrl;
		/*[out]*/ BSTR* pbstrSessionId;
		HRESULT retValue;
	};

	STDMETHOD(__deprecated_GetSessionId)(
		/*[in]*/ IDebugEventCallback2* pCallback,
		/*[in,size_is(celtSpecificEngines),ptr]*/ GUID* rgguidSpecificEngines,
		/*[in]*/ DWORD celtSpecificEngines,
		/*[in,ptr]*/ LPCOLESTR pszStartPageUrl,
		/*[out]*/ BSTR* pbstrSessionId)
	{
		VSL_DEFINE_MOCK_METHOD(__deprecated_GetSessionId)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidSpecificEngines, celtSpecificEngines*sizeof(rgguidSpecificEngines[0]), validValues.celtSpecificEngines*sizeof(validValues.rgguidSpecificEngines[0]));

		VSL_CHECK_VALIDVALUE(celtSpecificEngines);

		VSL_CHECK_VALIDVALUE_STRINGW(pszStartPageUrl);

		VSL_SET_VALIDVALUE_BSTR(pbstrSessionId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEngineMetricValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ LPCOLESTR pszMetric;
		/*[in]*/ VARIANT varValue;
		HRESULT retValue;
	};

	STDMETHOD(SetEngineMetric)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ LPCOLESTR pszMetric,
		/*[in]*/ VARIANT varValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetEngineMetric)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMetric);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStoppingModelValidValues
	{
		/*[in]*/ STOPPING_MODEL dwStoppingModel;
		HRESULT retValue;
	};

	STDMETHOD(SetStoppingModel)(
		/*[in]*/ STOPPING_MODEL dwStoppingModel)
	{
		VSL_DEFINE_MOCK_METHOD(SetStoppingModel)

		VSL_CHECK_VALIDVALUE(dwStoppingModel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoppingModelValidValues
	{
		/*[out]*/ STOPPING_MODEL* pdwStoppingModel;
		HRESULT retValue;
	};

	STDMETHOD(GetStoppingModel)(
		/*[out]*/ STOPPING_MODEL* pdwStoppingModel)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoppingModel)

		VSL_SET_VALIDVALUE(pdwStoppingModel);

		VSL_RETURN_VALIDVALUES();
	}
	struct __deprecated_RegisterSessionWithServerValidValues
	{
		/*[in]*/ LPCOLESTR pwszServerName;
		HRESULT retValue;
	};

	STDMETHOD(__deprecated_RegisterSessionWithServer)(
		/*[in]*/ LPCOLESTR pwszServerName)
	{
		VSL_DEFINE_MOCK_METHOD(__deprecated_RegisterSessionWithServer)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszServerName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSESSION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSourceServerModule.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSOURCESERVERMODULE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSOURCESERVERMODULE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSourceServerModuleNotImpl :
	public IDebugSourceServerModule
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSourceServerModuleNotImpl)

public:

	typedef IDebugSourceServerModule Interface;

	STDMETHOD(GetSourceServerData)(
		/*[out]*/ ULONG* /*pDataByteCount*/,
		/*[out,size_is(,*pDataByteCount)]*/ BYTE** /*ppData*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSourceServerModuleMockImpl :
	public IDebugSourceServerModule,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSourceServerModuleMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSourceServerModuleMockImpl)

	typedef IDebugSourceServerModule Interface;
	struct GetSourceServerDataValidValues
	{
		/*[out]*/ ULONG* pDataByteCount;
		/*[out,size_is(,*pDataByteCount)]*/ BYTE** ppData;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceServerData)(
		/*[out]*/ ULONG* pDataByteCount,
		/*[out,size_is(,*pDataByteCount)]*/ BYTE** ppData)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceServerData)

		VSL_SET_VALIDVALUE(pDataByteCount);

		VSL_SET_VALIDVALUE_MEMCPY(ppData, *pDataByteCount*sizeof(ppData[0]), *(validValues.pDataByteCount)*sizeof(validValues.ppData[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSOURCESERVERMODULE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugStackFrame3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSTACKFRAME3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSTACKFRAME3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugStackFrame3NotImpl :
	public IDebugStackFrame3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugStackFrame3NotImpl)

public:

	typedef IDebugStackFrame3 Interface;

	STDMETHOD(InterceptCurrentException)(
		/*[in]*/ INTERCEPT_EXCEPTION_ACTION /*dwFlags*/,
		/*[out]*/ UINT64* /*pqwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUnwindCodeContext)(
		/*[out]*/ IDebugCodeContext2** /*ppCodeContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeContext)(
		/*[out]*/ IDebugCodeContext2** /*ppCodeCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** /*ppCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ FRAMEINFO_FLAGS /*dwFieldSpec*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[out]*/ FRAMEINFO* /*pFrameInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPhysicalStackRange)(
		/*[out]*/ UINT64* /*paddrMin*/,
		/*[out]*/ UINT64* /*paddrMax*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpressionContext)(
		/*[out]*/ IDebugExpressionContext2** /*ppExprCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* /*pbstrLanguage*/,
		/*[in,out,ptr]*/ GUID* /*pguidLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumProperties)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[in]*/ REFGUID /*guidFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ ULONG* /*pcelt*/,
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThread)(
		/*[out]*/ IDebugThread2** /*ppThread*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugStackFrame3MockImpl :
	public IDebugStackFrame3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugStackFrame3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugStackFrame3MockImpl)

	typedef IDebugStackFrame3 Interface;
	struct InterceptCurrentExceptionValidValues
	{
		/*[in]*/ INTERCEPT_EXCEPTION_ACTION dwFlags;
		/*[out]*/ UINT64* pqwCookie;
		HRESULT retValue;
	};

	STDMETHOD(InterceptCurrentException)(
		/*[in]*/ INTERCEPT_EXCEPTION_ACTION dwFlags,
		/*[out]*/ UINT64* pqwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(InterceptCurrentException)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(pqwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUnwindCodeContextValidValues
	{
		/*[out]*/ IDebugCodeContext2** ppCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(GetUnwindCodeContext)(
		/*[out]*/ IDebugCodeContext2** ppCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnwindCodeContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeContextValidValues
	{
		/*[out]*/ IDebugCodeContext2** ppCodeCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeContext)(
		/*[out]*/ IDebugCodeContext2** ppCodeCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentContextValidValues
	{
		/*[out]*/ IDebugDocumentContext2** ppCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** ppCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec;
		/*[in]*/ UINT nRadix;
		/*[out]*/ FRAMEINFO* pFrameInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec,
		/*[in]*/ UINT nRadix,
		/*[out]*/ FRAMEINFO* pFrameInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFieldSpec);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_SET_VALIDVALUE(pFrameInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPhysicalStackRangeValidValues
	{
		/*[out]*/ UINT64* paddrMin;
		/*[out]*/ UINT64* paddrMax;
		HRESULT retValue;
	};

	STDMETHOD(GetPhysicalStackRange)(
		/*[out]*/ UINT64* paddrMin,
		/*[out]*/ UINT64* paddrMax)
	{
		VSL_DEFINE_MOCK_METHOD(GetPhysicalStackRange)

		VSL_SET_VALIDVALUE(paddrMin);

		VSL_SET_VALIDVALUE(paddrMax);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpressionContextValidValues
	{
		/*[out]*/ IDebugExpressionContext2** ppExprCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetExpressionContext)(
		/*[out]*/ IDebugExpressionContext2** ppExprCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpressionContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppExprCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageInfoValidValues
	{
		/*[in,out,ptr]*/ BSTR* pbstrLanguage;
		/*[in,out,ptr]*/ GUID* pguidLanguage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* pbstrLanguage,
		/*[in,out,ptr]*/ GUID* pguidLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrLanguage);

		VSL_SET_VALIDVALUE(pguidLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDebugPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPropertiesValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ UINT nRadix;
		/*[in]*/ REFGUID guidFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ ULONG* pcelt;
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumProperties)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ UINT nRadix,
		/*[in]*/ REFGUID guidFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ ULONG* pcelt,
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProperties)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_CHECK_VALIDVALUE(guidFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE(pcelt);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadValidValues
	{
		/*[out]*/ IDebugThread2** ppThread;
		HRESULT retValue;
	};

	STDMETHOD(GetThread)(
		/*[out]*/ IDebugThread2** ppThread)
	{
		VSL_DEFINE_MOCK_METHOD(GetThread)

		VSL_SET_VALIDVALUE_INTERFACE(ppThread);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSTACKFRAME3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugStackFrame2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSTACKFRAME2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSTACKFRAME2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugStackFrame2NotImpl :
	public IDebugStackFrame2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugStackFrame2NotImpl)

public:

	typedef IDebugStackFrame2 Interface;

	STDMETHOD(GetCodeContext)(
		/*[out]*/ IDebugCodeContext2** /*ppCodeCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** /*ppCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfo)(
		/*[in]*/ FRAMEINFO_FLAGS /*dwFieldSpec*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[out]*/ FRAMEINFO* /*pFrameInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPhysicalStackRange)(
		/*[out]*/ UINT64* /*paddrMin*/,
		/*[out]*/ UINT64* /*paddrMax*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpressionContext)(
		/*[out]*/ IDebugExpressionContext2** /*ppExprCxt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* /*pbstrLanguage*/,
		/*[in,out,ptr]*/ GUID* /*pguidLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** /*ppProperty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumProperties)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS /*dwFields*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[in]*/ REFGUID /*guidFilter*/,
		/*[in]*/ DWORD /*dwTimeout*/,
		/*[out]*/ ULONG* /*pcelt*/,
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThread)(
		/*[out]*/ IDebugThread2** /*ppThread*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugStackFrame2MockImpl :
	public IDebugStackFrame2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugStackFrame2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugStackFrame2MockImpl)

	typedef IDebugStackFrame2 Interface;
	struct GetCodeContextValidValues
	{
		/*[out]*/ IDebugCodeContext2** ppCodeCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeContext)(
		/*[out]*/ IDebugCodeContext2** ppCodeCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentContextValidValues
	{
		/*[out]*/ IDebugDocumentContext2** ppCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentContext)(
		/*[out]*/ IDebugDocumentContext2** ppCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoValidValues
	{
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec;
		/*[in]*/ UINT nRadix;
		/*[out]*/ FRAMEINFO* pFrameInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetInfo)(
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec,
		/*[in]*/ UINT nRadix,
		/*[out]*/ FRAMEINFO* pFrameInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfo)

		VSL_CHECK_VALIDVALUE(dwFieldSpec);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_SET_VALIDVALUE(pFrameInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPhysicalStackRangeValidValues
	{
		/*[out]*/ UINT64* paddrMin;
		/*[out]*/ UINT64* paddrMax;
		HRESULT retValue;
	};

	STDMETHOD(GetPhysicalStackRange)(
		/*[out]*/ UINT64* paddrMin,
		/*[out]*/ UINT64* paddrMax)
	{
		VSL_DEFINE_MOCK_METHOD(GetPhysicalStackRange)

		VSL_SET_VALIDVALUE(paddrMin);

		VSL_SET_VALIDVALUE(paddrMax);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpressionContextValidValues
	{
		/*[out]*/ IDebugExpressionContext2** ppExprCxt;
		HRESULT retValue;
	};

	STDMETHOD(GetExpressionContext)(
		/*[out]*/ IDebugExpressionContext2** ppExprCxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpressionContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppExprCxt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageInfoValidValues
	{
		/*[in,out,ptr]*/ BSTR* pbstrLanguage;
		/*[in,out,ptr]*/ GUID* pguidLanguage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageInfo)(
		/*[in,out,ptr]*/ BSTR* pbstrLanguage,
		/*[in,out,ptr]*/ GUID* pguidLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrLanguage);

		VSL_SET_VALIDVALUE(pguidLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDebugPropertyValidValues
	{
		/*[out]*/ IDebugProperty2** ppProperty;
		HRESULT retValue;
	};

	STDMETHOD(GetDebugProperty)(
		/*[out]*/ IDebugProperty2** ppProperty)
	{
		VSL_DEFINE_MOCK_METHOD(GetDebugProperty)

		VSL_SET_VALIDVALUE_INTERFACE(ppProperty);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPropertiesValidValues
	{
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields;
		/*[in]*/ UINT nRadix;
		/*[in]*/ REFGUID guidFilter;
		/*[in]*/ DWORD dwTimeout;
		/*[out]*/ ULONG* pcelt;
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumProperties)(
		/*[in]*/ DEBUGPROP_INFO_FLAGS dwFields,
		/*[in]*/ UINT nRadix,
		/*[in]*/ REFGUID guidFilter,
		/*[in]*/ DWORD dwTimeout,
		/*[out]*/ ULONG* pcelt,
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProperties)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_CHECK_VALIDVALUE(guidFilter);

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_SET_VALIDVALUE(pcelt);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadValidValues
	{
		/*[out]*/ IDebugThread2** ppThread;
		HRESULT retValue;
	};

	STDMETHOD(GetThread)(
		/*[out]*/ IDebugThread2** ppThread)
	{
		VSL_DEFINE_MOCK_METHOD(GetThread)

		VSL_SET_VALIDVALUE_INTERFACE(ppThread);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSTACKFRAME2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugSymbolSearchEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGSYMBOLSEARCHEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGSYMBOLSEARCHEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugSymbolSearchEvent2NotImpl :
	public IDebugSymbolSearchEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSymbolSearchEvent2NotImpl)

public:

	typedef IDebugSymbolSearchEvent2 Interface;

	STDMETHOD(GetSymbolSearchInfo)(
		/*[out]*/ IDebugModule3** /*pModule*/,
		/*[in,out]*/ BSTR* /*pbstrDebugMessage*/,
		/*[out]*/ MODULE_INFO_FLAGS* /*pdwModuleInfoFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugSymbolSearchEvent2MockImpl :
	public IDebugSymbolSearchEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugSymbolSearchEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugSymbolSearchEvent2MockImpl)

	typedef IDebugSymbolSearchEvent2 Interface;
	struct GetSymbolSearchInfoValidValues
	{
		/*[out]*/ IDebugModule3** pModule;
		/*[in,out]*/ BSTR* pbstrDebugMessage;
		/*[out]*/ MODULE_INFO_FLAGS* pdwModuleInfoFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetSymbolSearchInfo)(
		/*[out]*/ IDebugModule3** pModule,
		/*[in,out]*/ BSTR* pbstrDebugMessage,
		/*[out]*/ MODULE_INFO_FLAGS* pdwModuleInfoFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetSymbolSearchInfo)

		VSL_SET_VALIDVALUE_INTERFACE(pModule);

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugMessage);

		VSL_SET_VALIDVALUE(pdwModuleInfoFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGSYMBOLSEARCHEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugThread2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGTHREAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGTHREAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugThread2NotImpl :
	public IDebugThread2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugThread2NotImpl)

public:

	typedef IDebugThread2 Interface;

	STDMETHOD(EnumFrameInfo)(
		/*[in]*/ FRAMEINFO_FLAGS /*dwFieldSpec*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[out]*/ IEnumDebugFrameInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetThreadName)(
		/*[in]*/ LPCOLESTR /*pszName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProgram)(
		/*[out]*/ IDebugProgram2** /*ppProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanSetNextStatement)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetNextStatement)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThreadId)(
		/*[out]*/ DWORD* /*pdwThreadId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Suspend)(
		/*[out]*/ DWORD* /*pdwSuspendCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Resume)(
		/*[out]*/ DWORD* /*pdwSuspendCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThreadProperties)(
		/*[in]*/ THREADPROPERTY_FIELDS /*dwFields*/,
		/*[out]*/ THREADPROPERTIES* /*ptp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLogicalThread)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[out]*/ IDebugLogicalThread2** /*ppLogicalThread*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugThread2MockImpl :
	public IDebugThread2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugThread2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugThread2MockImpl)

	typedef IDebugThread2 Interface;
	struct EnumFrameInfoValidValues
	{
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec;
		/*[in]*/ UINT nRadix;
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumFrameInfo)(
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec,
		/*[in]*/ UINT nRadix,
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumFrameInfo)

		VSL_CHECK_VALIDVALUE(dwFieldSpec);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetThreadNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		HRESULT retValue;
	};

	STDMETHOD(SetThreadName)(
		/*[in]*/ LPCOLESTR pszName)
	{
		VSL_DEFINE_MOCK_METHOD(SetThreadName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProgramValidValues
	{
		/*[out]*/ IDebugProgram2** ppProgram;
		HRESULT retValue;
	};

	STDMETHOD(GetProgram)(
		/*[out]*/ IDebugProgram2** ppProgram)
	{
		VSL_DEFINE_MOCK_METHOD(GetProgram)

		VSL_SET_VALIDVALUE_INTERFACE(ppProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanSetNextStatementValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(CanSetNextStatement)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[in]*/ IDebugCodeContext2* pCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(CanSetNextStatement)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNextStatementValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(SetNextStatement)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[in]*/ IDebugCodeContext2* pCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetNextStatement)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadIdValidValues
	{
		/*[out]*/ DWORD* pdwThreadId;
		HRESULT retValue;
	};

	STDMETHOD(GetThreadId)(
		/*[out]*/ DWORD* pdwThreadId)
	{
		VSL_DEFINE_MOCK_METHOD(GetThreadId)

		VSL_SET_VALIDVALUE(pdwThreadId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SuspendValidValues
	{
		/*[out]*/ DWORD* pdwSuspendCount;
		HRESULT retValue;
	};

	STDMETHOD(Suspend)(
		/*[out]*/ DWORD* pdwSuspendCount)
	{
		VSL_DEFINE_MOCK_METHOD(Suspend)

		VSL_SET_VALIDVALUE(pdwSuspendCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResumeValidValues
	{
		/*[out]*/ DWORD* pdwSuspendCount;
		HRESULT retValue;
	};

	STDMETHOD(Resume)(
		/*[out]*/ DWORD* pdwSuspendCount)
	{
		VSL_DEFINE_MOCK_METHOD(Resume)

		VSL_SET_VALIDVALUE(pdwSuspendCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadPropertiesValidValues
	{
		/*[in]*/ THREADPROPERTY_FIELDS dwFields;
		/*[out]*/ THREADPROPERTIES* ptp;
		HRESULT retValue;
	};

	STDMETHOD(GetThreadProperties)(
		/*[in]*/ THREADPROPERTY_FIELDS dwFields,
		/*[out]*/ THREADPROPERTIES* ptp)
	{
		VSL_DEFINE_MOCK_METHOD(GetThreadProperties)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(ptp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLogicalThreadValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[out]*/ IDebugLogicalThread2** ppLogicalThread;
		HRESULT retValue;
	};

	STDMETHOD(GetLogicalThread)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[out]*/ IDebugLogicalThread2** ppLogicalThread)
	{
		VSL_DEFINE_MOCK_METHOD(GetLogicalThread)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_SET_VALIDVALUE_INTERFACE(ppLogicalThread);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGTHREAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugThread3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGTHREAD3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGTHREAD3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugThread3NotImpl :
	public IDebugThread3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugThread3NotImpl)

public:

	typedef IDebugThread3 Interface;

	STDMETHOD(IsCurrentException)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanRemapLeafFrame)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemapLeafFrame)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumFrameInfo)(
		/*[in]*/ FRAMEINFO_FLAGS /*dwFieldSpec*/,
		/*[in]*/ UINT /*nRadix*/,
		/*[out]*/ IEnumDebugFrameInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetThreadName)(
		/*[in]*/ LPCOLESTR /*pszName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProgram)(
		/*[out]*/ IDebugProgram2** /*ppProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanSetNextStatement)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetNextStatement)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[in]*/ IDebugCodeContext2* /*pCodeContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThreadId)(
		/*[out]*/ DWORD* /*pdwThreadId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Suspend)(
		/*[out]*/ DWORD* /*pdwSuspendCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Resume)(
		/*[out]*/ DWORD* /*pdwSuspendCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetThreadProperties)(
		/*[in]*/ THREADPROPERTY_FIELDS /*dwFields*/,
		/*[out]*/ THREADPROPERTIES* /*ptp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLogicalThread)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[out]*/ IDebugLogicalThread2** /*ppLogicalThread*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugThread3MockImpl :
	public IDebugThread3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugThread3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugThread3MockImpl)

	typedef IDebugThread3 Interface;
	struct IsCurrentExceptionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsCurrentException)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsCurrentException)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanRemapLeafFrameValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanRemapLeafFrame)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanRemapLeafFrame)

		VSL_RETURN_VALIDVALUES();
	}
	struct RemapLeafFrameValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemapLeafFrame)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemapLeafFrame)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumFrameInfoValidValues
	{
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec;
		/*[in]*/ UINT nRadix;
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumFrameInfo)(
		/*[in]*/ FRAMEINFO_FLAGS dwFieldSpec,
		/*[in]*/ UINT nRadix,
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumFrameInfo)

		VSL_CHECK_VALIDVALUE(dwFieldSpec);

		VSL_CHECK_VALIDVALUE(nRadix);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetThreadNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		HRESULT retValue;
	};

	STDMETHOD(SetThreadName)(
		/*[in]*/ LPCOLESTR pszName)
	{
		VSL_DEFINE_MOCK_METHOD(SetThreadName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProgramValidValues
	{
		/*[out]*/ IDebugProgram2** ppProgram;
		HRESULT retValue;
	};

	STDMETHOD(GetProgram)(
		/*[out]*/ IDebugProgram2** ppProgram)
	{
		VSL_DEFINE_MOCK_METHOD(GetProgram)

		VSL_SET_VALIDVALUE_INTERFACE(ppProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanSetNextStatementValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(CanSetNextStatement)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[in]*/ IDebugCodeContext2* pCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(CanSetNextStatement)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNextStatementValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[in]*/ IDebugCodeContext2* pCodeContext;
		HRESULT retValue;
	};

	STDMETHOD(SetNextStatement)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[in]*/ IDebugCodeContext2* pCodeContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetNextStatement)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadIdValidValues
	{
		/*[out]*/ DWORD* pdwThreadId;
		HRESULT retValue;
	};

	STDMETHOD(GetThreadId)(
		/*[out]*/ DWORD* pdwThreadId)
	{
		VSL_DEFINE_MOCK_METHOD(GetThreadId)

		VSL_SET_VALIDVALUE(pdwThreadId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SuspendValidValues
	{
		/*[out]*/ DWORD* pdwSuspendCount;
		HRESULT retValue;
	};

	STDMETHOD(Suspend)(
		/*[out]*/ DWORD* pdwSuspendCount)
	{
		VSL_DEFINE_MOCK_METHOD(Suspend)

		VSL_SET_VALIDVALUE(pdwSuspendCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResumeValidValues
	{
		/*[out]*/ DWORD* pdwSuspendCount;
		HRESULT retValue;
	};

	STDMETHOD(Resume)(
		/*[out]*/ DWORD* pdwSuspendCount)
	{
		VSL_DEFINE_MOCK_METHOD(Resume)

		VSL_SET_VALIDVALUE(pdwSuspendCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetThreadPropertiesValidValues
	{
		/*[in]*/ THREADPROPERTY_FIELDS dwFields;
		/*[out]*/ THREADPROPERTIES* ptp;
		HRESULT retValue;
	};

	STDMETHOD(GetThreadProperties)(
		/*[in]*/ THREADPROPERTY_FIELDS dwFields,
		/*[out]*/ THREADPROPERTIES* ptp)
	{
		VSL_DEFINE_MOCK_METHOD(GetThreadProperties)

		VSL_CHECK_VALIDVALUE(dwFields);

		VSL_SET_VALIDVALUE(ptp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLogicalThreadValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[out]*/ IDebugLogicalThread2** ppLogicalThread;
		HRESULT retValue;
	};

	STDMETHOD(GetLogicalThread)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[out]*/ IDebugLogicalThread2** ppLogicalThread)
	{
		VSL_DEFINE_MOCK_METHOD(GetLogicalThread)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_SET_VALIDVALUE_INTERFACE(ppLogicalThread);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGTHREAD3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDiscoverUrlCallBack.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISCOVERURLCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISCOVERURLCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDiscoverUrlCallBackNotImpl :
	public IDiscoverUrlCallBack
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoverUrlCallBackNotImpl)

public:

	typedef IDiscoverUrlCallBack Interface;

	STDMETHOD(NotifyDiscoverComplete)(
		/*[in]*/ int /*cookie*/,
		/*[in]*/ IDiscoveryResult* /*pIDiscoveryResult*/)VSL_STDMETHOD_NOTIMPL
};

class IDiscoverUrlCallBackMockImpl :
	public IDiscoverUrlCallBack,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoverUrlCallBackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDiscoverUrlCallBackMockImpl)

	typedef IDiscoverUrlCallBack Interface;
	struct NotifyDiscoverCompleteValidValues
	{
		/*[in]*/ int cookie;
		/*[in]*/ IDiscoveryResult* pIDiscoveryResult;
		HRESULT retValue;
	};

	STDMETHOD(NotifyDiscoverComplete)(
		/*[in]*/ int cookie,
		/*[in]*/ IDiscoveryResult* pIDiscoveryResult)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyDiscoverComplete)

		VSL_CHECK_VALIDVALUE(cookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIDiscoveryResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISCOVERURLCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDiscoveryClientResult.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISCOVERYCLIENTRESULT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISCOVERYCLIENTRESULT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDiscoveryClientResultNotImpl :
	public IDiscoveryClientResult
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryClientResultNotImpl)

public:

	typedef IDiscoveryClientResult Interface;

	STDMETHOD(GetFileName)(
		/*[out,retval]*/ BSTR* /*pbstrFilename*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReferenceTypeName)(
		/*[out,retval]*/ BSTR* /*pbstrReferenceTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUrl)(
		/*[out,retval]*/ BSTR* /*pbstrUrl*/)VSL_STDMETHOD_NOTIMPL
};

class IDiscoveryClientResultMockImpl :
	public IDiscoveryClientResult,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryClientResultMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDiscoveryClientResultMockImpl)

	typedef IDiscoveryClientResult Interface;
	struct GetFileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFilename;
		HRESULT retValue;
	};

	STDMETHOD(GetFileName)(
		/*[out,retval]*/ BSTR* pbstrFilename)
	{
		VSL_DEFINE_MOCK_METHOD(GetFileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilename);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceTypeNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrReferenceTypeName;
		HRESULT retValue;
	};

	STDMETHOD(GetReferenceTypeName)(
		/*[out,retval]*/ BSTR* pbstrReferenceTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(GetReferenceTypeName)

		VSL_SET_VALIDVALUE_BSTR(pbstrReferenceTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUrlValidValues
	{
		/*[out,retval]*/ BSTR* pbstrUrl;
		HRESULT retValue;
	};

	STDMETHOD(GetUrl)(
		/*[out,retval]*/ BSTR* pbstrUrl)
	{
		VSL_DEFINE_MOCK_METHOD(GetUrl)

		VSL_SET_VALIDVALUE_BSTR(pbstrUrl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISCOVERYCLIENTRESULT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDirectWriterLock.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDIRECTWRITERLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDIRECTWRITERLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDirectWriterLockNotImpl :
	public IDirectWriterLock
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDirectWriterLockNotImpl)

public:

	typedef IDirectWriterLock Interface;

	STDMETHOD(WaitForWriteAccess)(
		/*[in]*/ DWORD /*dwTimeout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseWriteAccess)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HaveWriteAccess)()VSL_STDMETHOD_NOTIMPL
};

class IDirectWriterLockMockImpl :
	public IDirectWriterLock,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDirectWriterLockMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDirectWriterLockMockImpl)

	typedef IDirectWriterLock Interface;
	struct WaitForWriteAccessValidValues
	{
		/*[in]*/ DWORD dwTimeout;
		HRESULT retValue;
	};

	STDMETHOD(WaitForWriteAccess)(
		/*[in]*/ DWORD dwTimeout)
	{
		VSL_DEFINE_MOCK_METHOD(WaitForWriteAccess)

		VSL_CHECK_VALIDVALUE(dwTimeout);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseWriteAccessValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ReleaseWriteAccess)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReleaseWriteAccess)

		VSL_RETURN_VALIDVALUES();
	}
	struct HaveWriteAccessValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HaveWriteAccess)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HaveWriteAccess)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDIRECTWRITERLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugWindowsComputerPort2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGWINDOWSCOMPUTERPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGWINDOWSCOMPUTERPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugWindowsComputerPort2NotImpl :
	public IDebugWindowsComputerPort2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugWindowsComputerPort2NotImpl)

public:

	typedef IDebugWindowsComputerPort2 Interface;

	STDMETHOD(GetComputerInfo)(
		/*[out]*/ COMPUTER_INFO* /*pInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugWindowsComputerPort2MockImpl :
	public IDebugWindowsComputerPort2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugWindowsComputerPort2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugWindowsComputerPort2MockImpl)

	typedef IDebugWindowsComputerPort2 Interface;
	struct GetComputerInfoValidValues
	{
		/*[out]*/ COMPUTER_INFO* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetComputerInfo)(
		/*[out]*/ COMPUTER_INFO* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetComputerInfo)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGWINDOWSCOMPUTERPORT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDebugThreadDestroyEvent2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDEBUGTHREADDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDEBUGTHREADDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDebugThreadDestroyEvent2NotImpl :
	public IDebugThreadDestroyEvent2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugThreadDestroyEvent2NotImpl)

public:

	typedef IDebugThreadDestroyEvent2 Interface;

	STDMETHOD(GetExitCode)(
		/*[out]*/ DWORD* /*pdwExit*/)VSL_STDMETHOD_NOTIMPL
};

class IDebugThreadDestroyEvent2MockImpl :
	public IDebugThreadDestroyEvent2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDebugThreadDestroyEvent2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDebugThreadDestroyEvent2MockImpl)

	typedef IDebugThreadDestroyEvent2 Interface;
	struct GetExitCodeValidValues
	{
		/*[out]*/ DWORD* pdwExit;
		HRESULT retValue;
	};

	STDMETHOD(GetExitCode)(
		/*[out]*/ DWORD* pdwExit)
	{
		VSL_DEFINE_MOCK_METHOD(GetExitCode)

		VSL_SET_VALIDVALUE(pdwExit);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDEBUGTHREADDESTROYEVENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDiscoveryClientResultCollection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISCOVERYCLIENTRESULTCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISCOVERYCLIENTRESULTCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDiscoveryClientResultCollectionNotImpl :
	public IDiscoveryClientResultCollection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryClientResultCollectionNotImpl)

public:

	typedef IDiscoveryClientResultCollection Interface;

	STDMETHOD(GetResultCount)(
		/*[out,retval]*/ int* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetResult)(
		/*[in]*/ int /*pIndex*/,
		/*[out,retval]*/ IDiscoveryClientResult** /*ppIDiscoveryClientResult*/)VSL_STDMETHOD_NOTIMPL
};

class IDiscoveryClientResultCollectionMockImpl :
	public IDiscoveryClientResultCollection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryClientResultCollectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDiscoveryClientResultCollectionMockImpl)

	typedef IDiscoveryClientResultCollection Interface;
	struct GetResultCountValidValues
	{
		/*[out,retval]*/ int* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetResultCount)(
		/*[out,retval]*/ int* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetResultCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetResultValidValues
	{
		/*[in]*/ int pIndex;
		/*[out,retval]*/ IDiscoveryClientResult** ppIDiscoveryClientResult;
		HRESULT retValue;
	};

	STDMETHOD(GetResult)(
		/*[in]*/ int pIndex,
		/*[out,retval]*/ IDiscoveryClientResult** ppIDiscoveryClientResult)
	{
		VSL_DEFINE_MOCK_METHOD(GetResult)

		VSL_CHECK_VALIDVALUE(pIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppIDiscoveryClientResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISCOVERYCLIENTRESULTCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDiscoveryResult2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISCOVERYRESULT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISCOVERYRESULT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDiscoveryResult2NotImpl :
	public IDiscoveryResult2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryResult2NotImpl)

public:

	typedef IDiscoveryResult2 Interface;

	STDMETHOD(DownloadServiceDocument)(
		/*[in]*/ BSTR /*bstrDestinationPath*/,
		/*[in]*/ BSTR /*bstrDiscomapFileName*/,
		/*[out,retval]*/ IDiscoveryClientResultCollection** /*ppIDiscoveryClientResultCollection*/)VSL_STDMETHOD_NOTIMPL
};

class IDiscoveryResult2MockImpl :
	public IDiscoveryResult2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryResult2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDiscoveryResult2MockImpl)

	typedef IDiscoveryResult2 Interface;
	struct DownloadServiceDocumentValidValues
	{
		/*[in]*/ BSTR bstrDestinationPath;
		/*[in]*/ BSTR bstrDiscomapFileName;
		/*[out,retval]*/ IDiscoveryClientResultCollection** ppIDiscoveryClientResultCollection;
		HRESULT retValue;
	};

	STDMETHOD(DownloadServiceDocument)(
		/*[in]*/ BSTR bstrDestinationPath,
		/*[in]*/ BSTR bstrDiscomapFileName,
		/*[out,retval]*/ IDiscoveryClientResultCollection** ppIDiscoveryClientResultCollection)
	{
		VSL_DEFINE_MOCK_METHOD(DownloadServiceDocument)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestinationPath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDiscomapFileName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIDiscoveryClientResultCollection);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISCOVERYRESULT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDispatch.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISPATCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISPATCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDispatchNotImpl :
	public IDispatch
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDispatchNotImpl)

public:

	typedef IDispatch Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IDispatchMockImpl :
	public IDispatch,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDispatchMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDispatchMockImpl)

	typedef IDispatch Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISPATCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDocumentSite2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDOCUMENTSITE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDOCUMENTSITE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDocumentSite2NotImpl :
	public IDocumentSite2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDocumentSite2NotImpl)

public:

	typedef IDocumentSite2 Interface;

	STDMETHOD(GetObject)(
		/*[out]*/ IDispatch** /*ppDisp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** /*ppSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompiler)(
		/*[in]*/ REFIID /*iid*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ActivateObject)(
		/*[in]*/ ACTFLAG /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsObjectShowable)()VSL_STDMETHOD_NOTIMPL
};

class IDocumentSite2MockImpl :
	public IDocumentSite2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDocumentSite2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDocumentSite2MockImpl)

	typedef IDocumentSite2 Interface;
	struct GetObjectValidValues
	{
		/*[out]*/ IDispatch** ppDisp;
		HRESULT retValue;
	};

	STDMETHOD(GetObject)(
		/*[out]*/ IDispatch** ppDisp)
	{
		VSL_DEFINE_MOCK_METHOD(GetObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppDisp);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSite;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSiteValidValues
	{
		/*[out]*/ IServiceProvider** ppSite;
		HRESULT retValue;
	};

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** ppSite)
	{
		VSL_DEFINE_MOCK_METHOD(GetSite)

		VSL_SET_VALIDVALUE_INTERFACE(ppSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompilerValidValues
	{
		/*[in]*/ REFIID iid;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(GetCompiler)(
		/*[in]*/ REFIID iid,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompiler)

		VSL_CHECK_VALIDVALUE(iid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateObjectValidValues
	{
		/*[in]*/ ACTFLAG dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(ActivateObject)(
		/*[in]*/ ACTFLAG dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ActivateObject)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsObjectShowableValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsObjectShowable)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsObjectShowable)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDOCUMENTSITE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDiscoveryResult.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISCOVERYRESULT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISCOVERYRESULT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDiscoveryResultNotImpl :
	public IDiscoveryResult
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryResultNotImpl)

public:

	typedef IDiscoveryResult Interface;

	STDMETHOD(GetRawXml)(
		/*[out,retval]*/ BSTR* /*pbstrXml*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentXml)(
		/*[in]*/ BSTR /*url*/,
		/*[out,retval]*/ BSTR* /*pbstrXml*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReferenceCount)(
		/*[out,retval]*/ int* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReferenceInfo)(
		/*[in]*/ int /*pIndex*/,
		/*[out,retval]*/ IReferenceInfo** /*ppIReferenceInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDiscoverySession)(
		/*[out,retval]*/ IDiscoverySession** /*discoverySession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUrl)(
		/*[out,retval]*/ BSTR* /*pbstrUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddWebReference)(
		/*[in]*/ IUnknown* /*punkWebReferenceFolder*/,
		/*[in]*/ BSTR /*bstrDestinationPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddWebReferenceTo)(
		/*[in]*/ IUnknown* /*punkWebReferenceFolder*/,
		/*[in]*/ BSTR /*bstrDestinationPath*/,
		/*[in]*/ BSTR /*bstrDiscomapFilename*/)VSL_STDMETHOD_NOTIMPL
};

class IDiscoveryResultMockImpl :
	public IDiscoveryResult,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoveryResultMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDiscoveryResultMockImpl)

	typedef IDiscoveryResult Interface;
	struct GetRawXmlValidValues
	{
		/*[out,retval]*/ BSTR* pbstrXml;
		HRESULT retValue;
	};

	STDMETHOD(GetRawXml)(
		/*[out,retval]*/ BSTR* pbstrXml)
	{
		VSL_DEFINE_MOCK_METHOD(GetRawXml)

		VSL_SET_VALIDVALUE_BSTR(pbstrXml);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentXmlValidValues
	{
		/*[in]*/ BSTR url;
		/*[out,retval]*/ BSTR* pbstrXml;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentXml)(
		/*[in]*/ BSTR url,
		/*[out,retval]*/ BSTR* pbstrXml)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentXml)

		VSL_CHECK_VALIDVALUE_BSTR(url);

		VSL_SET_VALIDVALUE_BSTR(pbstrXml);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceCountValidValues
	{
		/*[out,retval]*/ int* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetReferenceCount)(
		/*[out,retval]*/ int* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetReferenceCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceInfoValidValues
	{
		/*[in]*/ int pIndex;
		/*[out,retval]*/ IReferenceInfo** ppIReferenceInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetReferenceInfo)(
		/*[in]*/ int pIndex,
		/*[out,retval]*/ IReferenceInfo** ppIReferenceInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetReferenceInfo)

		VSL_CHECK_VALIDVALUE(pIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppIReferenceInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDiscoverySessionValidValues
	{
		/*[out,retval]*/ IDiscoverySession** discoverySession;
		HRESULT retValue;
	};

	STDMETHOD(GetDiscoverySession)(
		/*[out,retval]*/ IDiscoverySession** discoverySession)
	{
		VSL_DEFINE_MOCK_METHOD(GetDiscoverySession)

		VSL_SET_VALIDVALUE_INTERFACE(discoverySession);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUrlValidValues
	{
		/*[out,retval]*/ BSTR* pbstrUrl;
		HRESULT retValue;
	};

	STDMETHOD(GetUrl)(
		/*[out,retval]*/ BSTR* pbstrUrl)
	{
		VSL_DEFINE_MOCK_METHOD(GetUrl)

		VSL_SET_VALIDVALUE_BSTR(pbstrUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddWebReferenceValidValues
	{
		/*[in]*/ IUnknown* punkWebReferenceFolder;
		/*[in]*/ BSTR bstrDestinationPath;
		HRESULT retValue;
	};

	STDMETHOD(AddWebReference)(
		/*[in]*/ IUnknown* punkWebReferenceFolder,
		/*[in]*/ BSTR bstrDestinationPath)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebReference)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWebReferenceFolder);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestinationPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddWebReferenceToValidValues
	{
		/*[in]*/ IUnknown* punkWebReferenceFolder;
		/*[in]*/ BSTR bstrDestinationPath;
		/*[in]*/ BSTR bstrDiscomapFilename;
		HRESULT retValue;
	};

	STDMETHOD(AddWebReferenceTo)(
		/*[in]*/ IUnknown* punkWebReferenceFolder,
		/*[in]*/ BSTR bstrDestinationPath,
		/*[in]*/ BSTR bstrDiscomapFilename)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebReferenceTo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWebReferenceFolder);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestinationPath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDiscomapFilename);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISCOVERYRESULT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDocumentSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDOCUMENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDOCUMENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDocumentSiteNotImpl :
	public IDocumentSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDocumentSiteNotImpl)

public:

	typedef IDocumentSite Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** /*ppSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompiler)(
		/*[in]*/ REFIID /*iid*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ActivateObject)(
		/*[in]*/ ACTFLAG /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsObjectShowable)()VSL_STDMETHOD_NOTIMPL
};

class IDocumentSiteMockImpl :
	public IDocumentSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDocumentSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDocumentSiteMockImpl)

	typedef IDocumentSite Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSite;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSiteValidValues
	{
		/*[out]*/ IServiceProvider** ppSite;
		HRESULT retValue;
	};

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** ppSite)
	{
		VSL_DEFINE_MOCK_METHOD(GetSite)

		VSL_SET_VALIDVALUE_INTERFACE(ppSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompilerValidValues
	{
		/*[in]*/ REFIID iid;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(GetCompiler)(
		/*[in]*/ REFIID iid,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompiler)

		VSL_CHECK_VALIDVALUE(iid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateObjectValidValues
	{
		/*[in]*/ ACTFLAG dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(ActivateObject)(
		/*[in]*/ ACTFLAG dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ActivateObject)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsObjectShowableValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsObjectShowable)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsObjectShowable)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDOCUMENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDropSource.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDROPSOURCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDROPSOURCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDropSourceNotImpl :
	public IDropSource
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDropSourceNotImpl)

public:

	typedef IDropSource Interface;

	STDMETHOD(QueryContinueDrag)(
		/*[in]*/ BOOL /*fEscapePressed*/,
		/*[in]*/ DWORD /*grfKeyState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GiveFeedback)(
		/*[in]*/ DWORD /*dwEffect*/)VSL_STDMETHOD_NOTIMPL
};

class IDropSourceMockImpl :
	public IDropSource,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDropSourceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDropSourceMockImpl)

	typedef IDropSource Interface;
	struct QueryContinueDragValidValues
	{
		/*[in]*/ BOOL fEscapePressed;
		/*[in]*/ DWORD grfKeyState;
		HRESULT retValue;
	};

	STDMETHOD(QueryContinueDrag)(
		/*[in]*/ BOOL fEscapePressed,
		/*[in]*/ DWORD grfKeyState)
	{
		VSL_DEFINE_MOCK_METHOD(QueryContinueDrag)

		VSL_CHECK_VALIDVALUE(fEscapePressed);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GiveFeedbackValidValues
	{
		/*[in]*/ DWORD dwEffect;
		HRESULT retValue;
	};

	STDMETHOD(GiveFeedback)(
		/*[in]*/ DWORD dwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(GiveFeedback)

		VSL_CHECK_VALIDVALUE(dwEffect);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDROPSOURCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDiscoverySession.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDISCOVERYSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDISCOVERYSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDiscoverySessionNotImpl :
	public IDiscoverySession
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoverySessionNotImpl)

public:

	typedef IDiscoverySession Interface;

	STDMETHOD(DiscoverUrl)(
		/*[in]*/ BSTR /*pbstrUrl*/,
		/*[out,retval]*/ IDiscoveryResult** /*pIDiscoveryResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiscoverUrlAsync)(
		/*[in]*/ BSTR /*url*/,
		/*[in]*/ IDiscoverUrlCallBack* /*pDiscoverUrlCallBack*/,
		/*[out,retval]*/ int* /*cookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelDiscoverUrl)(
		/*[in]*/ int /*cookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDiscoverError)(
		/*[in]*/ int /*cookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateWebReference)(
		/*[in]*/ IUnknown* /*punkWebReferenceFolder*/,
		/*[in]*/ BSTR /*bstrUrl*/,
		/*[in]*/ BSTR /*bstrDestinationPath*/)VSL_STDMETHOD_NOTIMPL
};

class IDiscoverySessionMockImpl :
	public IDiscoverySession,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDiscoverySessionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDiscoverySessionMockImpl)

	typedef IDiscoverySession Interface;
	struct DiscoverUrlValidValues
	{
		/*[in]*/ BSTR pbstrUrl;
		/*[out,retval]*/ IDiscoveryResult** pIDiscoveryResult;
		HRESULT retValue;
	};

	STDMETHOD(DiscoverUrl)(
		/*[in]*/ BSTR pbstrUrl,
		/*[out,retval]*/ IDiscoveryResult** pIDiscoveryResult)
	{
		VSL_DEFINE_MOCK_METHOD(DiscoverUrl)

		VSL_CHECK_VALIDVALUE_BSTR(pbstrUrl);

		VSL_SET_VALIDVALUE_INTERFACE(pIDiscoveryResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiscoverUrlAsyncValidValues
	{
		/*[in]*/ BSTR url;
		/*[in]*/ IDiscoverUrlCallBack* pDiscoverUrlCallBack;
		/*[out,retval]*/ int* cookie;
		HRESULT retValue;
	};

	STDMETHOD(DiscoverUrlAsync)(
		/*[in]*/ BSTR url,
		/*[in]*/ IDiscoverUrlCallBack* pDiscoverUrlCallBack,
		/*[out,retval]*/ int* cookie)
	{
		VSL_DEFINE_MOCK_METHOD(DiscoverUrlAsync)

		VSL_CHECK_VALIDVALUE_BSTR(url);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDiscoverUrlCallBack);

		VSL_SET_VALIDVALUE(cookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelDiscoverUrlValidValues
	{
		/*[in]*/ int cookie;
		HRESULT retValue;
	};

	STDMETHOD(CancelDiscoverUrl)(
		/*[in]*/ int cookie)
	{
		VSL_DEFINE_MOCK_METHOD(CancelDiscoverUrl)

		VSL_CHECK_VALIDVALUE(cookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDiscoverErrorValidValues
	{
		/*[in]*/ int cookie;
		HRESULT retValue;
	};

	STDMETHOD(GetDiscoverError)(
		/*[in]*/ int cookie)
	{
		VSL_DEFINE_MOCK_METHOD(GetDiscoverError)

		VSL_CHECK_VALIDVALUE(cookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateWebReferenceValidValues
	{
		/*[in]*/ IUnknown* punkWebReferenceFolder;
		/*[in]*/ BSTR bstrUrl;
		/*[in]*/ BSTR bstrDestinationPath;
		HRESULT retValue;
	};

	STDMETHOD(UpdateWebReference)(
		/*[in]*/ IUnknown* punkWebReferenceFolder,
		/*[in]*/ BSTR bstrUrl,
		/*[in]*/ BSTR bstrDestinationPath)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateWebReference)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWebReferenceFolder);

		VSL_CHECK_VALIDVALUE_BSTR(bstrUrl);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestinationPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDISCOVERYSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDummyHICONIncluder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDUMMYHICONINCLUDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDUMMYHICONINCLUDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDummyHICONIncluderNotImpl :
	public IDummyHICONIncluder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDummyHICONIncluderNotImpl)

public:

	typedef IDummyHICONIncluder Interface;

	STDMETHOD(Dummy)(
		/*[in]*/ HICON /*h1*/,
		/*[in]*/ HDC /*h2*/)VSL_STDMETHOD_NOTIMPL
};

class IDummyHICONIncluderMockImpl :
	public IDummyHICONIncluder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDummyHICONIncluderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDummyHICONIncluderMockImpl)

	typedef IDummyHICONIncluder Interface;
	struct DummyValidValues
	{
		/*[in]*/ HICON h1;
		/*[in]*/ HDC h2;
		HRESULT retValue;
	};

	STDMETHOD(Dummy)(
		/*[in]*/ HICON h1,
		/*[in]*/ HDC h2)
	{
		VSL_DEFINE_MOCK_METHOD(Dummy)

		VSL_CHECK_VALIDVALUE(h1);

		VSL_CHECK_VALIDVALUE(h2);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDUMMYHICONINCLUDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIDropTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IDROPTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IDROPTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IDropTargetNotImpl :
	public IDropTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDropTargetNotImpl)

public:

	typedef IDropTarget Interface;

	STDMETHOD(DragEnter)(
		/*[in,unique]*/ IDataObject* /*pDataObj*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in]*/ POINTL /*pt*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DragOver)(
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in]*/ POINTL /*pt*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DragLeave)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Drop)(
		/*[in,unique]*/ IDataObject* /*pDataObj*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in]*/ POINTL /*pt*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL
};

class IDropTargetMockImpl :
	public IDropTarget,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IDropTargetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IDropTargetMockImpl)

	typedef IDropTarget Interface;
	struct DragEnterValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObj;
		/*[in]*/ DWORD grfKeyState;
		/*[in]*/ POINTL pt;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DragEnter)(
		/*[in,unique]*/ IDataObject* pDataObj,
		/*[in]*/ DWORD grfKeyState,
		/*[in]*/ POINTL pt,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DragEnter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObj);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_CHECK_VALIDVALUE(pt);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DragOverValidValues
	{
		/*[in]*/ DWORD grfKeyState;
		/*[in]*/ POINTL pt;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DragOver)(
		/*[in]*/ DWORD grfKeyState,
		/*[in]*/ POINTL pt,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DragOver)

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_CHECK_VALIDVALUE(pt);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DragLeaveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DragLeave)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DragLeave)

		VSL_RETURN_VALIDVALUES();
	}
	struct DropValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObj;
		/*[in]*/ DWORD grfKeyState;
		/*[in]*/ POINTL pt;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(Drop)(
		/*[in,unique]*/ IDataObject* pDataObj,
		/*[in]*/ DWORD grfKeyState,
		/*[in]*/ POINTL pt,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(Drop)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObj);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_CHECK_VALIDVALUE(pt);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IDROPTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEEAssemblyRefResolveComparer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEEASSEMBLYREFRESOLVECOMPARER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEEASSEMBLYREFRESOLVECOMPARER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEEAssemblyRefResolveComparerNotImpl :
	public IEEAssemblyRefResolveComparer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEAssemblyRefResolveComparerNotImpl)

public:

	typedef IEEAssemblyRefResolveComparer Interface;

	STDMETHOD(CompareRef)(
		/*[in]*/ DWORD /*cookieFirst*/,
		/*[in]*/ DWORD /*cookieSecond*/,
		/*[in]*/ DWORD /*cookieTarget*/,
		/*[out]*/ BOOL* /*firstIsBetter*/)VSL_STDMETHOD_NOTIMPL
};

class IEEAssemblyRefResolveComparerMockImpl :
	public IEEAssemblyRefResolveComparer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEAssemblyRefResolveComparerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEEAssemblyRefResolveComparerMockImpl)

	typedef IEEAssemblyRefResolveComparer Interface;
	struct CompareRefValidValues
	{
		/*[in]*/ DWORD cookieFirst;
		/*[in]*/ DWORD cookieSecond;
		/*[in]*/ DWORD cookieTarget;
		/*[out]*/ BOOL* firstIsBetter;
		HRESULT retValue;
	};

	STDMETHOD(CompareRef)(
		/*[in]*/ DWORD cookieFirst,
		/*[in]*/ DWORD cookieSecond,
		/*[in]*/ DWORD cookieTarget,
		/*[out]*/ BOOL* firstIsBetter)
	{
		VSL_DEFINE_MOCK_METHOD(CompareRef)

		VSL_CHECK_VALIDVALUE(cookieFirst);

		VSL_CHECK_VALIDVALUE(cookieSecond);

		VSL_CHECK_VALIDVALUE(cookieTarget);

		VSL_SET_VALIDVALUE(firstIsBetter);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEEASSEMBLYREFRESOLVECOMPARER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEEDataStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEEDATASTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEEDATASTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEEDataStorageNotImpl :
	public IEEDataStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEDataStorageNotImpl)

public:

	typedef IEEDataStorage Interface;

	STDMETHOD(GetSize)(
		/*[out]*/ ULONG* /*size*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetData)(
		/*[in]*/ ULONG /*dataSize*/,
		/*[out]*/ ULONG* /*sizeGotten*/,
		/*[out,size_is(dataSize),length_is(*sizeGotten)]*/ BYTE* /*data*/)VSL_STDMETHOD_NOTIMPL
};

class IEEDataStorageMockImpl :
	public IEEDataStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEDataStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEEDataStorageMockImpl)

	typedef IEEDataStorage Interface;
	struct GetSizeValidValues
	{
		/*[out]*/ ULONG* size;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ ULONG* size)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(size);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDataValidValues
	{
		/*[in]*/ ULONG dataSize;
		/*[out]*/ ULONG* sizeGotten;
		/*[out,size_is(dataSize),length_is(*sizeGotten)]*/ BYTE* data;
		HRESULT retValue;
	};

	STDMETHOD(GetData)(
		/*[in]*/ ULONG dataSize,
		/*[out]*/ ULONG* sizeGotten,
		/*[out,size_is(dataSize),length_is(*sizeGotten)]*/ BYTE* data)
	{
		VSL_DEFINE_MOCK_METHOD(GetData)

		VSL_CHECK_VALIDVALUE(dataSize);

		VSL_SET_VALIDVALUE(sizeGotten);

		VSL_SET_VALIDVALUE_MEMCPY(data, dataSize*sizeof(data[0]), *(validValues.sizeGotten)*sizeof(validValues.data[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEEDATASTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEEHelperObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEEHELPEROBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEEHELPEROBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEEHelperObjectNotImpl :
	public IEEHelperObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEHelperObjectNotImpl)

public:

	typedef IEEHelperObject Interface;

	STDMETHOD(InitCache)(
		/*[in]*/ IEEAssemblyRefResolveComparer* /*pResolver*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTargetClass)(
		/*[in]*/ LPCOLESTR /*name*/,
		/*[in]*/ DWORD /*assemblyCookie*/,
		/*[out]*/ DWORD* /*cookie*/,
		/*[out]*/ ULONG* /*valueAttrCount*/,
		/*[out]*/ ULONG* /*viewerAttrCount*/,
		/*[out]*/ ULONG* /*visualizerAttrCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTargetAssembly)(
		/*[in]*/ LPCOLESTR /*name*/,
		/*[out]*/ DWORD* /*cookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAssembly)(
		/*[in]*/ DWORD /*assemblyCookie*/,
		/*[in]*/ GETASSEMBLY /*flags*/,
		/*[out]*/ ASSEMBLYFLAGS* /*flagsOut*/,
		/*[out]*/ BSTR* /*name*/,
		/*[out]*/ IEEDataStorage** /*assemBytes*/,
		/*[out]*/ IEEDataStorage** /*pdbBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostAssembly)(
		/*[in]*/ GETASSEMBLY /*flags*/,
		/*[out]*/ IEEDataStorage** /*assemBytes*/,
		/*[out]*/ IEEDataStorage** /*pdbBytes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetValueAttributeProps)(
		/*[in]*/ DWORD /*classCookie*/,
		/*[in]*/ ULONG /*ordinal*/,
		/*[out]*/ BSTR* /*targetedAssembly*/,
		/*[out]*/ DWORD* /*assemLocation*/,
		/*[out]*/ BSTR* /*name*/,
		/*[out]*/ BSTR* /*value*/,
		/*[out]*/ BSTR* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetViewerAttributeProps)(
		/*[in]*/ DWORD /*classCookie*/,
		/*[in]*/ ULONG /*ordinal*/,
		/*[out]*/ BSTR* /*targetedAssembly*/,
		/*[out]*/ DWORD* /*assemLocation*/,
		/*[out]*/ BSTR* /*className*/,
		/*[out]*/ DWORD* /*classAssemLocation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVisualizerAttributeProps)(
		/*[in]*/ DWORD /*classCookie*/,
		/*[in]*/ ULONG /*ordinal*/,
		/*[out]*/ BSTR* /*targetedAssembly*/,
		/*[out]*/ DWORD* /*assemLocation*/,
		/*[out]*/ BSTR* /*displayClassName*/,
		/*[out]*/ DWORD* /*displayClassAssemLocation*/,
		/*[out]*/ BSTR* /*proxyClassName*/,
		/*[out]*/ DWORD* /*proxyClassAssemLocation*/,
		/*[out]*/ BSTR* /*description*/,
		/*[out]*/ ULONG* /*uiType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAssemblyRefForCookie)(
		/*[in]*/ DWORD /*cookie*/,
		/*[out]*/ IEEAssemblyRef** /*ppAssemRef*/)VSL_STDMETHOD_NOTIMPL
};

class IEEHelperObjectMockImpl :
	public IEEHelperObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEHelperObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEEHelperObjectMockImpl)

	typedef IEEHelperObject Interface;
	struct InitCacheValidValues
	{
		/*[in]*/ IEEAssemblyRefResolveComparer* pResolver;
		HRESULT retValue;
	};

	STDMETHOD(InitCache)(
		/*[in]*/ IEEAssemblyRefResolveComparer* pResolver)
	{
		VSL_DEFINE_MOCK_METHOD(InitCache)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pResolver);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTargetClassValidValues
	{
		/*[in]*/ LPCOLESTR name;
		/*[in]*/ DWORD assemblyCookie;
		/*[out]*/ DWORD* cookie;
		/*[out]*/ ULONG* valueAttrCount;
		/*[out]*/ ULONG* viewerAttrCount;
		/*[out]*/ ULONG* visualizerAttrCount;
		HRESULT retValue;
	};

	STDMETHOD(GetTargetClass)(
		/*[in]*/ LPCOLESTR name,
		/*[in]*/ DWORD assemblyCookie,
		/*[out]*/ DWORD* cookie,
		/*[out]*/ ULONG* valueAttrCount,
		/*[out]*/ ULONG* viewerAttrCount,
		/*[out]*/ ULONG* visualizerAttrCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetTargetClass)

		VSL_CHECK_VALIDVALUE_STRINGW(name);

		VSL_CHECK_VALIDVALUE(assemblyCookie);

		VSL_SET_VALIDVALUE(cookie);

		VSL_SET_VALIDVALUE(valueAttrCount);

		VSL_SET_VALIDVALUE(viewerAttrCount);

		VSL_SET_VALIDVALUE(visualizerAttrCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTargetAssemblyValidValues
	{
		/*[in]*/ LPCOLESTR name;
		/*[out]*/ DWORD* cookie;
		HRESULT retValue;
	};

	STDMETHOD(GetTargetAssembly)(
		/*[in]*/ LPCOLESTR name,
		/*[out]*/ DWORD* cookie)
	{
		VSL_DEFINE_MOCK_METHOD(GetTargetAssembly)

		VSL_CHECK_VALIDVALUE_STRINGW(name);

		VSL_SET_VALIDVALUE(cookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAssemblyValidValues
	{
		/*[in]*/ DWORD assemblyCookie;
		/*[in]*/ GETASSEMBLY flags;
		/*[out]*/ ASSEMBLYFLAGS* flagsOut;
		/*[out]*/ BSTR* name;
		/*[out]*/ IEEDataStorage** assemBytes;
		/*[out]*/ IEEDataStorage** pdbBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetAssembly)(
		/*[in]*/ DWORD assemblyCookie,
		/*[in]*/ GETASSEMBLY flags,
		/*[out]*/ ASSEMBLYFLAGS* flagsOut,
		/*[out]*/ BSTR* name,
		/*[out]*/ IEEDataStorage** assemBytes,
		/*[out]*/ IEEDataStorage** pdbBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetAssembly)

		VSL_CHECK_VALIDVALUE(assemblyCookie);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE(flagsOut);

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_INTERFACE(assemBytes);

		VSL_SET_VALIDVALUE_INTERFACE(pdbBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostAssemblyValidValues
	{
		/*[in]*/ GETASSEMBLY flags;
		/*[out]*/ IEEDataStorage** assemBytes;
		/*[out]*/ IEEDataStorage** pdbBytes;
		HRESULT retValue;
	};

	STDMETHOD(GetHostAssembly)(
		/*[in]*/ GETASSEMBLY flags,
		/*[out]*/ IEEDataStorage** assemBytes,
		/*[out]*/ IEEDataStorage** pdbBytes)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostAssembly)

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE_INTERFACE(assemBytes);

		VSL_SET_VALIDVALUE_INTERFACE(pdbBytes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetValueAttributePropsValidValues
	{
		/*[in]*/ DWORD classCookie;
		/*[in]*/ ULONG ordinal;
		/*[out]*/ BSTR* targetedAssembly;
		/*[out]*/ DWORD* assemLocation;
		/*[out]*/ BSTR* name;
		/*[out]*/ BSTR* value;
		/*[out]*/ BSTR* type;
		HRESULT retValue;
	};

	STDMETHOD(GetValueAttributeProps)(
		/*[in]*/ DWORD classCookie,
		/*[in]*/ ULONG ordinal,
		/*[out]*/ BSTR* targetedAssembly,
		/*[out]*/ DWORD* assemLocation,
		/*[out]*/ BSTR* name,
		/*[out]*/ BSTR* value,
		/*[out]*/ BSTR* type)
	{
		VSL_DEFINE_MOCK_METHOD(GetValueAttributeProps)

		VSL_CHECK_VALIDVALUE(classCookie);

		VSL_CHECK_VALIDVALUE(ordinal);

		VSL_SET_VALIDVALUE_BSTR(targetedAssembly);

		VSL_SET_VALIDVALUE(assemLocation);

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_BSTR(value);

		VSL_SET_VALIDVALUE_BSTR(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetViewerAttributePropsValidValues
	{
		/*[in]*/ DWORD classCookie;
		/*[in]*/ ULONG ordinal;
		/*[out]*/ BSTR* targetedAssembly;
		/*[out]*/ DWORD* assemLocation;
		/*[out]*/ BSTR* className;
		/*[out]*/ DWORD* classAssemLocation;
		HRESULT retValue;
	};

	STDMETHOD(GetViewerAttributeProps)(
		/*[in]*/ DWORD classCookie,
		/*[in]*/ ULONG ordinal,
		/*[out]*/ BSTR* targetedAssembly,
		/*[out]*/ DWORD* assemLocation,
		/*[out]*/ BSTR* className,
		/*[out]*/ DWORD* classAssemLocation)
	{
		VSL_DEFINE_MOCK_METHOD(GetViewerAttributeProps)

		VSL_CHECK_VALIDVALUE(classCookie);

		VSL_CHECK_VALIDVALUE(ordinal);

		VSL_SET_VALIDVALUE_BSTR(targetedAssembly);

		VSL_SET_VALIDVALUE(assemLocation);

		VSL_SET_VALIDVALUE_BSTR(className);

		VSL_SET_VALIDVALUE(classAssemLocation);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVisualizerAttributePropsValidValues
	{
		/*[in]*/ DWORD classCookie;
		/*[in]*/ ULONG ordinal;
		/*[out]*/ BSTR* targetedAssembly;
		/*[out]*/ DWORD* assemLocation;
		/*[out]*/ BSTR* displayClassName;
		/*[out]*/ DWORD* displayClassAssemLocation;
		/*[out]*/ BSTR* proxyClassName;
		/*[out]*/ DWORD* proxyClassAssemLocation;
		/*[out]*/ BSTR* description;
		/*[out]*/ ULONG* uiType;
		HRESULT retValue;
	};

	STDMETHOD(GetVisualizerAttributeProps)(
		/*[in]*/ DWORD classCookie,
		/*[in]*/ ULONG ordinal,
		/*[out]*/ BSTR* targetedAssembly,
		/*[out]*/ DWORD* assemLocation,
		/*[out]*/ BSTR* displayClassName,
		/*[out]*/ DWORD* displayClassAssemLocation,
		/*[out]*/ BSTR* proxyClassName,
		/*[out]*/ DWORD* proxyClassAssemLocation,
		/*[out]*/ BSTR* description,
		/*[out]*/ ULONG* uiType)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisualizerAttributeProps)

		VSL_CHECK_VALIDVALUE(classCookie);

		VSL_CHECK_VALIDVALUE(ordinal);

		VSL_SET_VALIDVALUE_BSTR(targetedAssembly);

		VSL_SET_VALIDVALUE(assemLocation);

		VSL_SET_VALIDVALUE_BSTR(displayClassName);

		VSL_SET_VALIDVALUE(displayClassAssemLocation);

		VSL_SET_VALIDVALUE_BSTR(proxyClassName);

		VSL_SET_VALIDVALUE(proxyClassAssemLocation);

		VSL_SET_VALIDVALUE_BSTR(description);

		VSL_SET_VALIDVALUE(uiType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAssemblyRefForCookieValidValues
	{
		/*[in]*/ DWORD cookie;
		/*[out]*/ IEEAssemblyRef** ppAssemRef;
		HRESULT retValue;
	};

	STDMETHOD(GetAssemblyRefForCookie)(
		/*[in]*/ DWORD cookie,
		/*[out]*/ IEEAssemblyRef** ppAssemRef)
	{
		VSL_DEFINE_MOCK_METHOD(GetAssemblyRefForCookie)

		VSL_CHECK_VALIDVALUE(cookie);

		VSL_SET_VALIDVALUE_INTERFACE(ppAssemRef);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEEHELPEROBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEEAssemblyRef.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEEASSEMBLYREF_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEEASSEMBLYREF_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEEAssemblyRefNotImpl :
	public IEEAssemblyRef
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEAssemblyRefNotImpl)

public:

	typedef IEEAssemblyRef Interface;

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*bstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVersion)(
		/*[out]*/ USHORT* /*major*/,
		/*[out]*/ USHORT* /*minor*/,
		/*[out]*/ USHORT* /*build*/,
		/*[out]*/ USHORT* /*revision*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCulture)(
		/*[out]*/ BSTR* /*bstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPublicKey)(
		/*[out]*/ BSTR* /*key*/)VSL_STDMETHOD_NOTIMPL
};

class IEEAssemblyRefMockImpl :
	public IEEAssemblyRef,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEAssemblyRefMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEEAssemblyRefMockImpl)

	typedef IEEAssemblyRef Interface;
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* bstr;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* bstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(bstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVersionValidValues
	{
		/*[out]*/ USHORT* major;
		/*[out]*/ USHORT* minor;
		/*[out]*/ USHORT* build;
		/*[out]*/ USHORT* revision;
		HRESULT retValue;
	};

	STDMETHOD(GetVersion)(
		/*[out]*/ USHORT* major,
		/*[out]*/ USHORT* minor,
		/*[out]*/ USHORT* build,
		/*[out]*/ USHORT* revision)
	{
		VSL_DEFINE_MOCK_METHOD(GetVersion)

		VSL_SET_VALIDVALUE(major);

		VSL_SET_VALIDVALUE(minor);

		VSL_SET_VALIDVALUE(build);

		VSL_SET_VALIDVALUE(revision);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCultureValidValues
	{
		/*[out]*/ BSTR* bstr;
		HRESULT retValue;
	};

	STDMETHOD(GetCulture)(
		/*[out]*/ BSTR* bstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetCulture)

		VSL_SET_VALIDVALUE_BSTR(bstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPublicKeyValidValues
	{
		/*[out]*/ BSTR* key;
		HRESULT retValue;
	};

	STDMETHOD(GetPublicKey)(
		/*[out]*/ BSTR* key)
	{
		VSL_DEFINE_MOCK_METHOD(GetPublicKey)

		VSL_SET_VALIDVALUE_BSTR(key);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEEASSEMBLYREF_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEEHostServices.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEEHOSTSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEEHOSTSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEEHostServicesNotImpl :
	public IEEHostServices
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEHostServicesNotImpl)

public:

	typedef IEEHostServices Interface;

	STDMETHOD(GetHostValue)(
		/*[in]*/ LPCOLESTR /*valueCatagory*/,
		/*[in]*/ LPCOLESTR /*valueKind*/,
		/*[out]*/ VARIANT* /*result*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHostValue)(
		/*[in]*/ LPCOLESTR /*valueCatagory*/,
		/*[in]*/ LPCOLESTR /*valueKind*/,
		/*[in]*/ VARIANT /*newValue*/)VSL_STDMETHOD_NOTIMPL
};

class IEEHostServicesMockImpl :
	public IEEHostServices,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEEHostServicesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEEHostServicesMockImpl)

	typedef IEEHostServices Interface;
	struct GetHostValueValidValues
	{
		/*[in]*/ LPCOLESTR valueCatagory;
		/*[in]*/ LPCOLESTR valueKind;
		/*[out]*/ VARIANT* result;
		HRESULT retValue;
	};

	STDMETHOD(GetHostValue)(
		/*[in]*/ LPCOLESTR valueCatagory,
		/*[in]*/ LPCOLESTR valueKind,
		/*[out]*/ VARIANT* result)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostValue)

		VSL_CHECK_VALIDVALUE_STRINGW(valueCatagory);

		VSL_CHECK_VALIDVALUE_STRINGW(valueKind);

		VSL_SET_VALIDVALUE_VARIANT(result);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHostValueValidValues
	{
		/*[in]*/ LPCOLESTR valueCatagory;
		/*[in]*/ LPCOLESTR valueKind;
		/*[in]*/ VARIANT newValue;
		HRESULT retValue;
	};

	STDMETHOD(SetHostValue)(
		/*[in]*/ LPCOLESTR valueCatagory,
		/*[in]*/ LPCOLESTR valueKind,
		/*[in]*/ VARIANT newValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetHostValue)

		VSL_CHECK_VALIDVALUE_STRINGW(valueCatagory);

		VSL_CHECK_VALIDVALUE_STRINGW(valueKind);

		VSL_CHECK_VALIDVALUE(newValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEEHOSTSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumActions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMACTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMACTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "undoredo.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumActionsNotImpl :
	public IEnumActions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumActionsNotImpl)

public:

	typedef IEnumActions Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[in]*/ IAction** /*rgelt*/,
		/*[in]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[in]*/ IEnumActions** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumActionsMockImpl :
	public IEnumActions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumActionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumActionsMockImpl)

	typedef IEnumActions Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in]*/ IAction** rgelt;
		/*[in]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[in]*/ IAction** rgelt,
		/*[in]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(rgelt);

		VSL_CHECK_VALIDVALUE_POINTER(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[in]*/ IEnumActions** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[in]*/ IEnumActions** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMACTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEELocalObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEELOCALOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEELOCALOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEELocalObjectNotImpl :
	public IEELocalObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEELocalObjectNotImpl)

public:

	typedef IEELocalObject Interface;

	STDMETHOD(SetCallback)(
		/*[in]*/ IDebugSettingsCallback2* /*pCallback*/)VSL_STDMETHOD_NOTIMPL
};

class IEELocalObjectMockImpl :
	public IEELocalObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEELocalObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEELocalObjectMockImpl)

	typedef IEELocalObject Interface;
	struct SetCallbackValidValues
	{
		/*[in]*/ IDebugSettingsCallback2* pCallback;
		HRESULT retValue;
	};

	STDMETHOD(SetCallback)(
		/*[in]*/ IDebugSettingsCallback2* pCallback)
	{
		VSL_DEFINE_MOCK_METHOD(SetCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEELOCALOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumComponents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMCOMPONENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMCOMPONENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumComponentsNotImpl :
	public IEnumComponents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumComponentsNotImpl)

public:

	typedef IEnumComponents Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSCOMPONENTSELECTORDATA* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumComponents** /*ppIEnumComponents*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumComponentsMockImpl :
	public IEnumComponents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumComponentsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumComponentsMockImpl)

	typedef IEnumComponents Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSCOMPONENTSELECTORDATA* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSCOMPONENTSELECTORDATA* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumComponents** ppIEnumComponents;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumComponents** ppIEnumComponents)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppIEnumComponents);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMCOMPONENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumCodePaths2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMCODEPATHS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMCODEPATHS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumCodePaths2NotImpl :
	public IEnumCodePaths2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumCodePaths2NotImpl)

public:

	typedef IEnumCodePaths2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ CODE_PATH* /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumCodePaths2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumCodePaths2MockImpl :
	public IEnumCodePaths2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumCodePaths2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumCodePaths2MockImpl)

	typedef IEnumCodePaths2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ CODE_PATH* rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ CODE_PATH* rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumCodePaths2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumCodePaths2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMCODEPATHS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumComReferences.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMCOMREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMCOMREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumComReferencesNotImpl :
	public IEnumComReferences
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumComReferencesNotImpl)

public:

	typedef IEnumComReferences Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ PCOMREFERENCE /*rgRefs*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumComReferences** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumComReferencesMockImpl :
	public IEnumComReferences,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumComReferencesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumComReferencesMockImpl)

	typedef IEnumComReferences Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ PCOMREFERENCE rgRefs;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ PCOMREFERENCE rgRefs,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgRefs, celt*sizeof(rgRefs[0]), *(validValues.pceltFetched)*sizeof(validValues.rgRefs[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumComReferences** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumComReferences** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMCOMREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumConnectionPoints.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMCONNECTIONPOINTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMCONNECTIONPOINTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumConnectionPointsNotImpl :
	public IEnumConnectionPoints
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumConnectionPointsNotImpl)

public:

	typedef IEnumConnectionPoints Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cConnections*/,
		/*[out,size_is(cConnections),length_is(*pcFetched)]*/ LPCONNECTIONPOINT* /*ppCP*/,
		/*[out]*/ ULONG* /*pcFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*cConnections*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumConnectionPoints** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumConnectionPointsMockImpl :
	public IEnumConnectionPoints,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumConnectionPointsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumConnectionPointsMockImpl)

	typedef IEnumConnectionPoints Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG cConnections;
		/*[out,size_is(cConnections),length_is(*pcFetched)]*/ LPCONNECTIONPOINT* ppCP;
		/*[out]*/ ULONG* pcFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cConnections,
		/*[out,size_is(cConnections),length_is(*pcFetched)]*/ LPCONNECTIONPOINT* ppCP,
		/*[out]*/ ULONG* pcFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cConnections);

		VSL_SET_VALIDVALUE_MEMCPY(ppCP, cConnections*sizeof(ppCP[0]), *(validValues.pcFetched)*sizeof(validValues.ppCP[0]));

		VSL_SET_VALIDVALUE(pcFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG cConnections;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG cConnections)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(cConnections);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumConnectionPoints** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumConnectionPoints** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMCONNECTIONPOINTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumConnections.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMCONNECTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMCONNECTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumConnectionsNotImpl :
	public IEnumConnections
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumConnectionsNotImpl)

public:

	typedef IEnumConnections Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cConnections*/,
		/*[out,size_is(cConnections),length_is(*pcFetched)]*/ LPCONNECTDATA /*rgcd*/,
		/*[out]*/ ULONG* /*pcFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*cConnections*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumConnections** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumConnectionsMockImpl :
	public IEnumConnections,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumConnectionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumConnectionsMockImpl)

	typedef IEnumConnections Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG cConnections;
		/*[out,size_is(cConnections),length_is(*pcFetched)]*/ LPCONNECTDATA rgcd;
		/*[out]*/ ULONG* pcFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cConnections,
		/*[out,size_is(cConnections),length_is(*pcFetched)]*/ LPCONNECTDATA rgcd,
		/*[out]*/ ULONG* pcFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cConnections);

		VSL_SET_VALIDVALUE_MEMCPY(rgcd, cConnections*sizeof(rgcd[0]), *(validValues.pcFetched)*sizeof(validValues.rgcd[0]));

		VSL_SET_VALIDVALUE(pcFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG cConnections;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG cConnections)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(cConnections);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumConnections** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumConnections** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMCONNECTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugBoundBreakpoints2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGBOUNDBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGBOUNDBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugBoundBreakpoints2NotImpl :
	public IEnumDebugBoundBreakpoints2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugBoundBreakpoints2NotImpl)

public:

	typedef IEnumDebugBoundBreakpoints2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugBoundBreakpoint2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugBoundBreakpoints2MockImpl :
	public IEnumDebugBoundBreakpoints2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugBoundBreakpoints2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugBoundBreakpoints2MockImpl)

	typedef IEnumDebugBoundBreakpoints2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugBoundBreakpoint2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugBoundBreakpoint2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugBoundBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGBOUNDBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugErrorBreakpoints2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGERRORBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGERRORBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugErrorBreakpoints2NotImpl :
	public IEnumDebugErrorBreakpoints2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugErrorBreakpoints2NotImpl)

public:

	typedef IEnumDebugErrorBreakpoints2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugErrorBreakpoint2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugErrorBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugErrorBreakpoints2MockImpl :
	public IEnumDebugErrorBreakpoints2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugErrorBreakpoints2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugErrorBreakpoints2MockImpl)

	typedef IEnumDebugErrorBreakpoints2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugErrorBreakpoint2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugErrorBreakpoint2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugErrorBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGERRORBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugExceptionInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGEXCEPTIONINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGEXCEPTIONINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugExceptionInfo2NotImpl :
	public IEnumDebugExceptionInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugExceptionInfo2NotImpl)

public:

	typedef IEnumDebugExceptionInfo2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ EXCEPTION_INFO* /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugExceptionInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugExceptionInfo2MockImpl :
	public IEnumDebugExceptionInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugExceptionInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugExceptionInfo2MockImpl)

	typedef IEnumDebugExceptionInfo2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ EXCEPTION_INFO* rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ EXCEPTION_INFO* rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugExceptionInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGEXCEPTIONINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugFrameInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGFRAMEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGFRAMEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugFrameInfo2NotImpl :
	public IEnumDebugFrameInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugFrameInfo2NotImpl)

public:

	typedef IEnumDebugFrameInfo2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugFrameInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugFrameInfo2MockImpl :
	public IEnumDebugFrameInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugFrameInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugFrameInfo2MockImpl)

	typedef IEnumDebugFrameInfo2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGFRAMEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugCodeContexts2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGCODECONTEXTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGCODECONTEXTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugCodeContexts2NotImpl :
	public IEnumDebugCodeContexts2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugCodeContexts2NotImpl)

public:

	typedef IEnumDebugCodeContexts2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugCodeContext2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugCodeContexts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugCodeContexts2MockImpl :
	public IEnumDebugCodeContexts2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugCodeContexts2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugCodeContexts2MockImpl)

	typedef IEnumDebugCodeContexts2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugCodeContext2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugCodeContext2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugCodeContexts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGCODECONTEXTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugFrameInfoFilter2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGFRAMEINFOFILTER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGFRAMEINFOFILTER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugFrameInfoFilter2NotImpl :
	public IEnumDebugFrameInfoFilter2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugFrameInfoFilter2NotImpl)

public:

	typedef IEnumDebugFrameInfoFilter2 Interface;

	STDMETHOD(CanFilter)(
		/*[out]*/ BOOL* /*pfCanFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsFiltered)(
		/*[out]*/ BOOL* /*pfIsFiltered*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugFrameInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugFrameInfoFilter2MockImpl :
	public IEnumDebugFrameInfoFilter2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugFrameInfoFilter2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugFrameInfoFilter2MockImpl)

	typedef IEnumDebugFrameInfoFilter2 Interface;
	struct CanFilterValidValues
	{
		/*[out]*/ BOOL* pfCanFilter;
		HRESULT retValue;
	};

	STDMETHOD(CanFilter)(
		/*[out]*/ BOOL* pfCanFilter)
	{
		VSL_DEFINE_MOCK_METHOD(CanFilter)

		VSL_SET_VALIDVALUE(pfCanFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsFilteredValidValues
	{
		/*[out]*/ BOOL* pfIsFiltered;
		HRESULT retValue;
	};

	STDMETHOD(IsFiltered)(
		/*[out]*/ BOOL* pfIsFiltered)
	{
		VSL_DEFINE_MOCK_METHOD(IsFiltered)

		VSL_SET_VALIDVALUE(pfIsFiltered);

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGFRAMEINFOFILTER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugMachines2__deprecated.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGMACHINES2__DEPRECATED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGMACHINES2__DEPRECATED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugMachines2__deprecatedNotImpl :
	public IEnumDebugMachines2__deprecated
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugMachines2__deprecatedNotImpl)

public:

	typedef IEnumDebugMachines2__deprecated Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugCoreServer2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugMachines2__deprecated** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugMachines2__deprecatedMockImpl :
	public IEnumDebugMachines2__deprecated,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugMachines2__deprecatedMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugMachines2__deprecatedMockImpl)

	typedef IEnumDebugMachines2__deprecated Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugCoreServer2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugCoreServer2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugMachines2__deprecated** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugMachines2__deprecated** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGMACHINES2__DEPRECATED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugModules2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGMODULES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGMODULES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugModules2NotImpl :
	public IEnumDebugModules2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugModules2NotImpl)

public:

	typedef IEnumDebugModules2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugModule2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugModules2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugModules2MockImpl :
	public IEnumDebugModules2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugModules2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugModules2MockImpl)

	typedef IEnumDebugModules2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugModule2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugModule2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugModules2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugModules2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGMODULES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugPendingBreakpoints2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGPENDINGBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGPENDINGBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugPendingBreakpoints2NotImpl :
	public IEnumDebugPendingBreakpoints2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPendingBreakpoints2NotImpl)

public:

	typedef IEnumDebugPendingBreakpoints2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPendingBreakpoint2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPendingBreakpoints2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugPendingBreakpoints2MockImpl :
	public IEnumDebugPendingBreakpoints2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPendingBreakpoints2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugPendingBreakpoints2MockImpl)

	typedef IEnumDebugPendingBreakpoints2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPendingBreakpoint2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPendingBreakpoint2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugPendingBreakpoints2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPendingBreakpoints2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGPENDINGBREAKPOINTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugPorts2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGPORTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGPORTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugPorts2NotImpl :
	public IEnumDebugPorts2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPorts2NotImpl)

public:

	typedef IEnumDebugPorts2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPort2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPorts2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugPorts2MockImpl :
	public IEnumDebugPorts2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPorts2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugPorts2MockImpl)

	typedef IEnumDebugPorts2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPort2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPort2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugPorts2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPorts2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGPORTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugPortSuppliers2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGPORTSUPPLIERS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGPORTSUPPLIERS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugPortSuppliers2NotImpl :
	public IEnumDebugPortSuppliers2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPortSuppliers2NotImpl)

public:

	typedef IEnumDebugPortSuppliers2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPortSupplier2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPortSuppliers2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugPortSuppliers2MockImpl :
	public IEnumDebugPortSuppliers2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPortSuppliers2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugPortSuppliers2MockImpl)

	typedef IEnumDebugPortSuppliers2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPortSupplier2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugPortSupplier2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPortSuppliers2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGPORTSUPPLIERS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugProcesses2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGPROCESSES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGPROCESSES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugProcesses2NotImpl :
	public IEnumDebugProcesses2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugProcesses2NotImpl)

public:

	typedef IEnumDebugProcesses2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugProcess2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugProcesses2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugProcesses2MockImpl :
	public IEnumDebugProcesses2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugProcesses2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugProcesses2MockImpl)

	typedef IEnumDebugProcesses2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugProcess2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugProcess2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugProcesses2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugProcesses2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGPROCESSES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugPropertyInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGPROPERTYINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGPROPERTYINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugPropertyInfo2NotImpl :
	public IEnumDebugPropertyInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPropertyInfo2NotImpl)

public:

	typedef IEnumDebugPropertyInfo2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ DEBUG_PROPERTY_INFO* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPropertyInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugPropertyInfo2MockImpl :
	public IEnumDebugPropertyInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPropertyInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugPropertyInfo2MockImpl)

	typedef IEnumDebugPropertyInfo2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ DEBUG_PROPERTY_INFO* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ DEBUG_PROPERTY_INFO* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPropertyInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGPROPERTYINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugPrograms2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGPROGRAMS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGPROGRAMS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugPrograms2NotImpl :
	public IEnumDebugPrograms2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPrograms2NotImpl)

public:

	typedef IEnumDebugPrograms2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugProgram2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPrograms2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugPrograms2MockImpl :
	public IEnumDebugPrograms2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugPrograms2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugPrograms2MockImpl)

	typedef IEnumDebugPrograms2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugProgram2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugProgram2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugPrograms2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugPrograms2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGPROGRAMS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumFORMATETC.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMFORMATETC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMFORMATETC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumFORMATETCNotImpl :
	public IEnumFORMATETC
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumFORMATETCNotImpl)

public:

	typedef IEnumFORMATETC Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FORMATETC* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumFORMATETC** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumFORMATETCMockImpl :
	public IEnumFORMATETC,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumFORMATETCMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumFORMATETCMockImpl)

	typedef IEnumFORMATETC Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FORMATETC* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FORMATETC* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumFORMATETC** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumFORMATETC** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMFORMATETC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugReferenceInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGREFERENCEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGREFERENCEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugReferenceInfo2NotImpl :
	public IEnumDebugReferenceInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugReferenceInfo2NotImpl)

public:

	typedef IEnumDebugReferenceInfo2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ DEBUG_REFERENCE_INFO* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugReferenceInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugReferenceInfo2MockImpl :
	public IEnumDebugReferenceInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugReferenceInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugReferenceInfo2MockImpl)

	typedef IEnumDebugReferenceInfo2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ DEBUG_REFERENCE_INFO* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ DEBUG_REFERENCE_INFO* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugReferenceInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugReferenceInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGREFERENCEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugThreads2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGTHREADS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGTHREADS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugThreads2NotImpl :
	public IEnumDebugThreads2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugThreads2NotImpl)

public:

	typedef IEnumDebugThreads2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugThread2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugThreads2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugThreads2MockImpl :
	public IEnumDebugThreads2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugThreads2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugThreads2MockImpl)

	typedef IEnumDebugThreads2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugThread2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugThread2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugThreads2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugThreads2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGTHREADS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugStackFrames2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGSTACKFRAMES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGSTACKFRAMES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugStackFrames2NotImpl :
	public IEnumDebugStackFrames2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugStackFrames2NotImpl)

public:

	typedef IEnumDebugStackFrames2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugStackFrame2** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugStackFrames2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIndex)(
		/*[in]*/ IDebugStackFrame2* /*pStackFrame*/,
		/*[in,out]*/ ULONG* /*pIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugStackFrames2MockImpl :
	public IEnumDebugStackFrames2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugStackFrames2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugStackFrames2MockImpl)

	typedef IEnumDebugStackFrames2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugStackFrame2** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDebugStackFrame2** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugStackFrames2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugStackFrames2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIndexValidValues
	{
		/*[in]*/ IDebugStackFrame2* pStackFrame;
		/*[in,out]*/ ULONG* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetIndex)(
		/*[in]*/ IDebugStackFrame2* pStackFrame,
		/*[in,out]*/ ULONG* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetIndex)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStackFrame);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGSTACKFRAMES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumDebugSessionFrameInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMDEBUGSESSIONFRAMEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMDEBUGSESSIONFRAMEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumDebugSessionFrameInfo2NotImpl :
	public IEnumDebugSessionFrameInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugSessionFrameInfo2NotImpl)

public:

	typedef IEnumDebugSessionFrameInfo2 Interface;

	STDMETHOD(SetCachePriority)(
		/*[in]*/ SESSION_CACHE_PRIORITY /*cachePriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugFrameInfo2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumDebugSessionFrameInfo2MockImpl :
	public IEnumDebugSessionFrameInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumDebugSessionFrameInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumDebugSessionFrameInfo2MockImpl)

	typedef IEnumDebugSessionFrameInfo2 Interface;
	struct SetCachePriorityValidValues
	{
		/*[in]*/ SESSION_CACHE_PRIORITY cachePriority;
		HRESULT retValue;
	};

	STDMETHOD(SetCachePriority)(
		/*[in]*/ SESSION_CACHE_PRIORITY cachePriority)
	{
		VSL_DEFINE_MOCK_METHOD(SetCachePriority)

		VSL_CHECK_VALIDVALUE(cachePriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ FRAMEINFO* rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumDebugFrameInfo2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMDEBUGSESSIONFRAMEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumHierarchies.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMHIERARCHIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMHIERARCHIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumHierarchiesNotImpl :
	public IEnumHierarchies
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumHierarchiesNotImpl)

public:

	typedef IEnumHierarchies Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsHierarchy** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumHierarchies** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumHierarchiesMockImpl :
	public IEnumHierarchies,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumHierarchiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumHierarchiesMockImpl)

	typedef IEnumHierarchies Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsHierarchy** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsHierarchy** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumHierarchies** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumHierarchies** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMHIERARCHIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumHierarchyItems.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMHIERARCHYITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMHIERARCHYITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumHierarchyItemsNotImpl :
	public IEnumHierarchyItems
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumHierarchyItemsNotImpl)

public:

	typedef IEnumHierarchyItems Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSITEMSELECTION* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumHierarchyItems** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumHierarchyItemsMockImpl :
	public IEnumHierarchyItems,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumHierarchyItemsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumHierarchyItemsMockImpl)

	typedef IEnumHierarchyItems Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSITEMSELECTION* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSITEMSELECTION* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumHierarchyItems** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumHierarchyItems** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMHIERARCHYITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumMoniker.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMMONIKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMMONIKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumMonikerNotImpl :
	public IEnumMoniker
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumMonikerNotImpl)

public:

	typedef IEnumMoniker Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IMoniker** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumMoniker** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumMonikerMockImpl :
	public IEnumMoniker,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumMonikerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumMonikerMockImpl)

	typedef IEnumMoniker Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IMoniker** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IMoniker** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumMoniker** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumMoniker** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMMONIKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumOleDocumentViews.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMOLEDOCUMENTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMOLEDOCUMENTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumOleDocumentViewsNotImpl :
	public IEnumOleDocumentViews
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumOleDocumentViewsNotImpl)

public:

	typedef IEnumOleDocumentViews Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cViews*/,
		/*[out]*/ IOleDocumentView** /*rgpView*/,
		/*[out]*/ ULONG* /*pcFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*cViews*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumOleDocumentViews** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumOleDocumentViewsMockImpl :
	public IEnumOleDocumentViews,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumOleDocumentViewsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumOleDocumentViewsMockImpl)

	typedef IEnumOleDocumentViews Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG cViews;
		/*[out]*/ IOleDocumentView** rgpView;
		/*[out]*/ ULONG* pcFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cViews,
		/*[out]*/ IOleDocumentView** rgpView,
		/*[out]*/ ULONG* pcFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cViews);

		VSL_SET_VALIDVALUE_INTERFACE(rgpView);

		VSL_SET_VALIDVALUE(pcFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG cViews;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG cViews)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(cViews);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumOleDocumentViews** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumOleDocumentViews** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMOLEDOCUMENTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumPackages.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMPACKAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMPACKAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumPackagesNotImpl :
	public IEnumPackages
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumPackagesNotImpl)

public:

	typedef IEnumPackages Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsPackage** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumPackages** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumPackagesMockImpl :
	public IEnumPackages,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumPackagesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumPackagesMockImpl)

	typedef IEnumPackages Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsPackage** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsPackage** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumPackages** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumPackages** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMPACKAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumOleUndoUnits.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMOLEUNDOUNITS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMOLEUNDOUNITS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumOleUndoUnitsNotImpl :
	public IEnumOleUndoUnits
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumOleUndoUnitsNotImpl)

public:

	typedef IEnumOleUndoUnits Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cElt*/,
		/*[out,size_is(cElt),length_is(*pcEltFetched)]*/ IOleUndoUnit** /*rgElt*/,
		/*[out]*/ ULONG* /*pcEltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*cElt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumOleUndoUnits** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumOleUndoUnitsMockImpl :
	public IEnumOleUndoUnits,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumOleUndoUnitsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumOleUndoUnitsMockImpl)

	typedef IEnumOleUndoUnits Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG cElt;
		/*[out,size_is(cElt),length_is(*pcEltFetched)]*/ IOleUndoUnit** rgElt;
		/*[out]*/ ULONG* pcEltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cElt,
		/*[out,size_is(cElt),length_is(*pcEltFetched)]*/ IOleUndoUnit** rgElt,
		/*[out]*/ ULONG* pcEltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cElt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgElt, cElt, *(validValues.pcEltFetched));

		VSL_SET_VALIDVALUE(pcEltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG cElt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG cElt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(cElt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumOleUndoUnits** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumOleUndoUnits** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMOLEUNDOUNITS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumOLEVERB.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMOLEVERB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMOLEVERB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumOLEVERBNotImpl :
	public IEnumOLEVERB
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumOLEVERBNotImpl)

public:

	typedef IEnumOLEVERB Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ LPOLEVERB /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumOLEVERB** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumOLEVERBMockImpl :
	public IEnumOLEVERB,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumOLEVERBMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumOLEVERBMockImpl)

	typedef IEnumOLEVERB Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ LPOLEVERB rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ LPOLEVERB rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumOLEVERB** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumOLEVERB** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMOLEVERB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumProjectStartupServices.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMPROJECTSTARTUPSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMPROJECTSTARTUPSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumProjectStartupServicesNotImpl :
	public IEnumProjectStartupServices
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumProjectStartupServicesNotImpl)

public:

	typedef IEnumProjectStartupServices Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ GUID* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumProjectStartupServices** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumProjectStartupServicesMockImpl :
	public IEnumProjectStartupServices,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumProjectStartupServicesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumProjectStartupServicesMockImpl)

	typedef IEnumProjectStartupServices Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ GUID* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ GUID* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumProjectStartupServices** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumProjectStartupServices** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMPROJECTSTARTUPSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumSTATDATA.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMSTATDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMSTATDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumSTATDATANotImpl :
	public IEnumSTATDATA
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumSTATDATANotImpl)

public:

	typedef IEnumSTATDATA Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ STATDATA* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumSTATDATA** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumSTATDATAMockImpl :
	public IEnumSTATDATA,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumSTATDATAMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumSTATDATAMockImpl)

	typedef IEnumSTATDATA Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ STATDATA* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ STATDATA* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumSTATDATA** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMSTATDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumString.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMSTRING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMSTRING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumStringNotImpl :
	public IEnumString
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumStringNotImpl)

public:

	typedef IEnumString Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ LPOLESTR* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumString** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumStringMockImpl :
	public IEnumString,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumStringMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumStringMockImpl)

	typedef IEnumString Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ LPOLESTR* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ LPOLESTR* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumString** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumString** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMSTRING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumSTATSTG.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMSTATSTG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMSTATSTG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumSTATSTGNotImpl :
	public IEnumSTATSTG
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumSTATSTGNotImpl)

public:

	typedef IEnumSTATSTG Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ STATSTG* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumSTATSTG** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumSTATSTGMockImpl :
	public IEnumSTATSTG,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumSTATSTGMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumSTATSTGMockImpl)

	typedef IEnumSTATSTG Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ STATSTG* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ STATSTG* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumSTATSTG** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumSTATSTG** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMSTATSTG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumRunningDocuments.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMRUNNINGDOCUMENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMRUNNINGDOCUMENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumRunningDocumentsNotImpl :
	public IEnumRunningDocuments
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumRunningDocumentsNotImpl)

public:

	typedef IEnumRunningDocuments Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSCOOKIE* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumRunningDocuments** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumRunningDocumentsMockImpl :
	public IEnumRunningDocuments,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumRunningDocumentsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumRunningDocumentsMockImpl)

	typedef IEnumRunningDocuments Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSCOOKIE* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VSCOOKIE* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumRunningDocuments** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumRunningDocuments** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMRUNNINGDOCUMENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumToolboxItems.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMTOOLBOXITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMTOOLBOXITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumToolboxItemsNotImpl :
	public IEnumToolboxItems
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumToolboxItemsNotImpl)

public:

	typedef IEnumToolboxItems Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDataObject** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumToolboxItems** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumToolboxItemsMockImpl :
	public IEnumToolboxItems,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumToolboxItemsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumToolboxItemsMockImpl)

	typedef IEnumToolboxItems Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDataObject** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IDataObject** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumToolboxItems** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumToolboxItems** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMTOOLBOXITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumVARIANT.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMVARIANT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMVARIANT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumVARIANTNotImpl :
	public IEnumVARIANT
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumVARIANTNotImpl)

public:

	typedef IEnumVARIANT Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pCeltFetched)]*/ VARIANT* /*rgVar*/,
		/*[out]*/ ULONG* /*pCeltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumVARIANT** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumVARIANTMockImpl :
	public IEnumVARIANT,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumVARIANTMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumVARIANTMockImpl)

	typedef IEnumVARIANT Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pCeltFetched)]*/ VARIANT* rgVar;
		/*[out]*/ ULONG* pCeltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pCeltFetched)]*/ VARIANT* rgVar,
		/*[out]*/ ULONG* pCeltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgVar, celt*sizeof(rgVar[0]), *(validValues.pCeltFetched)*sizeof(validValues.rgVar[0]));

		VSL_SET_VALIDVALUE(pCeltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumVARIANT** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumVARIANT** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMVARIANT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumToolboxTabs.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMTOOLBOXTABS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMTOOLBOXTABS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumToolboxTabsNotImpl :
	public IEnumToolboxTabs
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumToolboxTabsNotImpl)

public:

	typedef IEnumToolboxTabs Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumToolboxTabs** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumToolboxTabsMockImpl :
	public IEnumToolboxTabs,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumToolboxTabsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumToolboxTabsMockImpl)

	typedef IEnumToolboxTabs Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumToolboxTabs** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumToolboxTabs** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMTOOLBOXTABS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumUnknown.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumUnknownNotImpl :
	public IEnumUnknown
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumUnknownNotImpl)

public:

	typedef IEnumUnknown Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out]*/ IUnknown** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumUnknown** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumUnknownMockImpl :
	public IEnumUnknown,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumUnknownMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumUnknownMockImpl)

	typedef IEnumUnknown Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out]*/ IUnknown** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out]*/ IUnknown** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACE(rgelt);

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumUnknown** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumUnknown** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumVsENCRebuildableProjectCfgs.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMVSENCREBUILDABLEPROJECTCFGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMVSENCREBUILDABLEPROJECTCFGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "encbuild.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumVsENCRebuildableProjectCfgsNotImpl :
	public IEnumVsENCRebuildableProjectCfgs
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumVsENCRebuildableProjectCfgsNotImpl)

public:

	typedef IEnumVsENCRebuildableProjectCfgs Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsENCRebuildableProjectCfg** /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumVsENCRebuildableProjectCfgs** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcelt*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumVsENCRebuildableProjectCfgsMockImpl :
	public IEnumVsENCRebuildableProjectCfgs,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumVsENCRebuildableProjectCfgsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumVsENCRebuildableProjectCfgsMockImpl)

	typedef IEnumVsENCRebuildableProjectCfgs Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsENCRebuildableProjectCfg** rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsENCRebuildableProjectCfg** rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumVsENCRebuildableProjectCfgs** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumVsENCRebuildableProjectCfgs** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcelt;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcelt)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcelt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMVSENCREBUILDABLEPROJECTCFGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIErrorInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IErrorInfoNotImpl :
	public IErrorInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IErrorInfoNotImpl)

public:

	typedef IErrorInfo Interface;

	STDMETHOD(GetGUID)(
		/*[out]*/ GUID* /*pGUID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSource)(
		/*[out]*/ BSTR* /*pBstrSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pBstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHelpFile)(
		/*[out]*/ BSTR* /*pBstrHelpFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHelpContext)(
		/*[out]*/ DWORD* /*pdwHelpContext*/)VSL_STDMETHOD_NOTIMPL
};

class IErrorInfoMockImpl :
	public IErrorInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IErrorInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IErrorInfoMockImpl)

	typedef IErrorInfo Interface;
	struct GetGUIDValidValues
	{
		/*[out]*/ GUID* pGUID;
		HRESULT retValue;
	};

	STDMETHOD(GetGUID)(
		/*[out]*/ GUID* pGUID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGUID)

		VSL_SET_VALIDVALUE(pGUID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceValidValues
	{
		/*[out]*/ BSTR* pBstrSource;
		HRESULT retValue;
	};

	STDMETHOD(GetSource)(
		/*[out]*/ BSTR* pBstrSource)
	{
		VSL_DEFINE_MOCK_METHOD(GetSource)

		VSL_SET_VALIDVALUE_BSTR(pBstrSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pBstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pBstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pBstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHelpFileValidValues
	{
		/*[out]*/ BSTR* pBstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(GetHelpFile)(
		/*[out]*/ BSTR* pBstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetHelpFile)

		VSL_SET_VALIDVALUE_BSTR(pBstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHelpContextValidValues
	{
		/*[out]*/ DWORD* pdwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(GetHelpContext)(
		/*[out]*/ DWORD* pdwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetHelpContext)

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumWindowFrames.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMWINDOWFRAMES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMWINDOWFRAMES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumWindowFramesNotImpl :
	public IEnumWindowFrames
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumWindowFramesNotImpl)

public:

	typedef IEnumWindowFrames Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsWindowFrame** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumWindowFrames** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumWindowFramesMockImpl :
	public IEnumWindowFrames,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumWindowFramesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumWindowFramesMockImpl)

	typedef IEnumWindowFrames Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsWindowFrame** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsWindowFrame** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumWindowFrames** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumWindowFrames** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMWINDOWFRAMES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIEnumWebServices.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IENUMWEBSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IENUMWEBSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsWebServices.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IEnumWebServicesNotImpl :
	public IEnumWebServices
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumWebServicesNotImpl)

public:

	typedef IEnumWebServices Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsWebService** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IEnumWebServices** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IEnumWebServicesMockImpl :
	public IEnumWebServices,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IEnumWebServicesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IEnumWebServicesMockImpl)

	typedef IEnumWebServices Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsWebService** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsWebService** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IEnumWebServices** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IEnumWebServices** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IENUMWEBSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIErrorLog.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IERRORLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IERRORLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IErrorLogNotImpl :
	public IErrorLog
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IErrorLogNotImpl)

public:

	typedef IErrorLog Interface;

	STDMETHOD(AddError)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[in]*/ EXCEPINFO* /*pExcepInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IErrorLogMockImpl :
	public IErrorLog,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IErrorLogMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IErrorLogMockImpl)

	typedef IErrorLog Interface;
	struct AddErrorValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[in]*/ EXCEPINFO* pExcepInfo;
		HRESULT retValue;
	};

	STDMETHOD(AddError)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[in]*/ EXCEPINFO* pExcepInfo)
	{
		VSL_DEFINE_MOCK_METHOD(AddError)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_CHECK_VALIDVALUE_POINTER(pExcepInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IERRORLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIExternalConnection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEXTERNALCONNECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEXTERNALCONNECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IExternalConnectionNotImpl :
	public IExternalConnection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IExternalConnectionNotImpl)

public:

	typedef IExternalConnection Interface;

	virtual DWORD STDMETHODCALLTYPE AddConnection(
		/*[in]*/ DWORD /*extconn*/,
		/*[in]*/ DWORD /*reserved*/){ return DWORD(); }

	virtual DWORD STDMETHODCALLTYPE ReleaseConnection(
		/*[in]*/ DWORD /*extconn*/,
		/*[in]*/ DWORD /*reserved*/,
		/*[in]*/ BOOL /*fLastReleaseCloses*/){ return DWORD(); }
};

class IExternalConnectionMockImpl :
	public IExternalConnection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IExternalConnectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IExternalConnectionMockImpl)

	typedef IExternalConnection Interface;
	struct AddConnectionValidValues
	{
		/*[in]*/ DWORD extconn;
		/*[in]*/ DWORD reserved;
		DWORD retValue;
	};

	virtual DWORD _stdcall AddConnection(
		/*[in]*/ DWORD extconn,
		/*[in]*/ DWORD reserved)
	{
		VSL_DEFINE_MOCK_METHOD(AddConnection)

		VSL_CHECK_VALIDVALUE(extconn);

		VSL_CHECK_VALIDVALUE(reserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseConnectionValidValues
	{
		/*[in]*/ DWORD extconn;
		/*[in]*/ DWORD reserved;
		/*[in]*/ BOOL fLastReleaseCloses;
		DWORD retValue;
	};

	virtual DWORD _stdcall ReleaseConnection(
		/*[in]*/ DWORD extconn,
		/*[in]*/ DWORD reserved,
		/*[in]*/ BOOL fLastReleaseCloses)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseConnection)

		VSL_CHECK_VALIDVALUE(extconn);

		VSL_CHECK_VALIDVALUE(reserved);

		VSL_CHECK_VALIDVALUE(fLastReleaseCloses);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEXTERNALCONNECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIFillLockBytes.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IFILLLOCKBYTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IFILLLOCKBYTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IFillLockBytesNotImpl :
	public IFillLockBytes
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFillLockBytesNotImpl)

public:

	typedef IFillLockBytes Interface;

	STDMETHOD(FillAppend)(
		/*[in,size_is(cb)]*/ const void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FillAt)(
		/*[in]*/ ULARGE_INTEGER /*ulOffset*/,
		/*[in,size_is(cb)]*/ const void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFillSize)(
		/*[in]*/ ULARGE_INTEGER /*ulSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)(
		/*[in]*/ BOOL /*bCanceled*/)VSL_STDMETHOD_NOTIMPL
};

class IFillLockBytesMockImpl :
	public IFillLockBytes,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFillLockBytesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IFillLockBytesMockImpl)

	typedef IFillLockBytes Interface;
	struct FillAppendValidValues
	{
		/*[in,size_is(cb)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbWritten;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(FillAppend)(
		/*[in,size_is(cb)]*/ const void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(FillAppend)

		VSL_CHECK_VALIDVALUE_MEMCMP(pv, cb, validValues.cb);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
	struct FillAtValidValues
	{
		/*[in]*/ ULARGE_INTEGER ulOffset;
		/*[in,size_is(cb)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbWritten;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(FillAt)(
		/*[in]*/ ULARGE_INTEGER ulOffset,
		/*[in,size_is(cb)]*/ const void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(FillAt)

		VSL_CHECK_VALIDVALUE(ulOffset);

		VSL_CHECK_VALIDVALUE_MEMCMP(pv, cb, validValues.cb);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFillSizeValidValues
	{
		/*[in]*/ ULARGE_INTEGER ulSize;
		HRESULT retValue;
	};

	STDMETHOD(SetFillSize)(
		/*[in]*/ ULARGE_INTEGER ulSize)
	{
		VSL_DEFINE_MOCK_METHOD(SetFillSize)

		VSL_CHECK_VALIDVALUE(ulSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		/*[in]*/ BOOL bCanceled;
		HRESULT retValue;
	};

	STDMETHOD(Terminate)(
		/*[in]*/ BOOL bCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(Terminate)

		VSL_CHECK_VALIDVALUE(bCanceled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IFILLLOCKBYTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIFontEventsDisp.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IFONTEVENTSDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IFONTEVENTSDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IFontEventsDispNotImpl :
	public IFontEventsDisp
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFontEventsDispNotImpl)

public:

	typedef IFontEventsDisp Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IFontEventsDispMockImpl :
	public IFontEventsDisp,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFontEventsDispMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IFontEventsDispMockImpl)

	typedef IFontEventsDisp Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IFONTEVENTSDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIExtendedObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEXTENDEDOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEXTENDEDOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IExtendedObjectNotImpl :
	public IExtendedObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IExtendedObjectNotImpl)

public:

	typedef IExtendedObject Interface;

	STDMETHOD(GetInnerObject)(
		/*[in]*/ REFIID /*iid*/,
		/*[out,iid_is(iid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL
};

class IExtendedObjectMockImpl :
	public IExtendedObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IExtendedObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IExtendedObjectMockImpl)

	typedef IExtendedObject Interface;
	struct GetInnerObjectValidValues
	{
		/*[in]*/ REFIID iid;
		/*[out,iid_is(iid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(GetInnerObject)(
		/*[in]*/ REFIID iid,
		/*[out,iid_is(iid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetInnerObject)

		VSL_CHECK_VALIDVALUE(iid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEXTENDEDOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIFontDisp.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IFONTDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IFONTDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IFontDispNotImpl :
	public IFontDisp
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFontDispNotImpl)

public:

	typedef IFontDisp Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IFontDispMockImpl :
	public IFontDisp,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFontDispMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IFontDispMockImpl)

	typedef IFontDisp Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IFONTDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIExtendedTypeLib.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IEXTENDEDTYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IEXTENDEDTYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IExtendedTypeLibNotImpl :
	public IExtendedTypeLib
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IExtendedTypeLibNotImpl)

public:

	typedef IExtendedTypeLib Interface;

	STDMETHOD(CreateExtendedTypeLib)(
		/*[in]*/ LPCOLESTR /*lpstrCtrlLibFileName*/,
		/*[in]*/ LPCOLESTR /*lpstrLibNamePrepend*/,
		/*[in]*/ ITypeInfo* /*ptinfoExtender*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPCOLESTR /*lpstrDirectoryName*/,
		/*[out]*/ ITypeLib** /*pptLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddRefExtendedTypeLib)(
		/*[in]*/ LPCOLESTR /*lpstrCtrlLibFileName*/,
		/*[in]*/ LPCOLESTR /*lpstrLibNamePrepend*/,
		/*[in]*/ ITypeInfo* /*ptinfoExtender*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPCOLESTR /*lpstrDirectoryName*/,
		/*[out]*/ ITypeLib** /*pptLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddRefExtendedTypeLibOfClsid)(
		/*[in]*/ REFCLSID /*rclsidControl*/,
		/*[in]*/ LPCOLESTR /*lpstrLibNamePrepend*/,
		/*[in]*/ ITypeInfo* /*ptinfoExtender*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPCOLESTR /*lpstrDirectoryName*/,
		/*[out]*/ ITypeInfo** /*pptinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetExtenderInfo)(
		/*[in]*/ LPCOLESTR /*lpstrDirectoryName*/,
		/*[in]*/ ITypeInfo* /*ptinfoExtender*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IExtendedTypeLibMockImpl :
	public IExtendedTypeLib,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IExtendedTypeLibMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IExtendedTypeLibMockImpl)

	typedef IExtendedTypeLib Interface;
	struct CreateExtendedTypeLibValidValues
	{
		/*[in]*/ LPCOLESTR lpstrCtrlLibFileName;
		/*[in]*/ LPCOLESTR lpstrLibNamePrepend;
		/*[in]*/ ITypeInfo* ptinfoExtender;
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPCOLESTR lpstrDirectoryName;
		/*[out]*/ ITypeLib** pptLib;
		HRESULT retValue;
	};

	STDMETHOD(CreateExtendedTypeLib)(
		/*[in]*/ LPCOLESTR lpstrCtrlLibFileName,
		/*[in]*/ LPCOLESTR lpstrLibNamePrepend,
		/*[in]*/ ITypeInfo* ptinfoExtender,
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPCOLESTR lpstrDirectoryName,
		/*[out]*/ ITypeLib** pptLib)
	{
		VSL_DEFINE_MOCK_METHOD(CreateExtendedTypeLib)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrCtrlLibFileName);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrLibNamePrepend);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ptinfoExtender);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrDirectoryName);

		VSL_SET_VALIDVALUE_INTERFACE(pptLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddRefExtendedTypeLibValidValues
	{
		/*[in]*/ LPCOLESTR lpstrCtrlLibFileName;
		/*[in]*/ LPCOLESTR lpstrLibNamePrepend;
		/*[in]*/ ITypeInfo* ptinfoExtender;
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPCOLESTR lpstrDirectoryName;
		/*[out]*/ ITypeLib** pptLib;
		HRESULT retValue;
	};

	STDMETHOD(AddRefExtendedTypeLib)(
		/*[in]*/ LPCOLESTR lpstrCtrlLibFileName,
		/*[in]*/ LPCOLESTR lpstrLibNamePrepend,
		/*[in]*/ ITypeInfo* ptinfoExtender,
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPCOLESTR lpstrDirectoryName,
		/*[out]*/ ITypeLib** pptLib)
	{
		VSL_DEFINE_MOCK_METHOD(AddRefExtendedTypeLib)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrCtrlLibFileName);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrLibNamePrepend);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ptinfoExtender);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrDirectoryName);

		VSL_SET_VALIDVALUE_INTERFACE(pptLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddRefExtendedTypeLibOfClsidValidValues
	{
		/*[in]*/ REFCLSID rclsidControl;
		/*[in]*/ LPCOLESTR lpstrLibNamePrepend;
		/*[in]*/ ITypeInfo* ptinfoExtender;
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPCOLESTR lpstrDirectoryName;
		/*[out]*/ ITypeInfo** pptinfo;
		HRESULT retValue;
	};

	STDMETHOD(AddRefExtendedTypeLibOfClsid)(
		/*[in]*/ REFCLSID rclsidControl,
		/*[in]*/ LPCOLESTR lpstrLibNamePrepend,
		/*[in]*/ ITypeInfo* ptinfoExtender,
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPCOLESTR lpstrDirectoryName,
		/*[out]*/ ITypeInfo** pptinfo)
	{
		VSL_DEFINE_MOCK_METHOD(AddRefExtendedTypeLibOfClsid)

		VSL_CHECK_VALIDVALUE(rclsidControl);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrLibNamePrepend);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ptinfoExtender);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrDirectoryName);

		VSL_SET_VALIDVALUE_INTERFACE(pptinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExtenderInfoValidValues
	{
		/*[in]*/ LPCOLESTR lpstrDirectoryName;
		/*[in]*/ ITypeInfo* ptinfoExtender;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(SetExtenderInfo)(
		/*[in]*/ LPCOLESTR lpstrDirectoryName,
		/*[in]*/ ITypeInfo* ptinfoExtender,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(SetExtenderInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrDirectoryName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ptinfoExtender);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IEXTENDEDTYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIFont.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IFontNotImpl :
	public IFont
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFontNotImpl)

public:

	typedef IFont Interface;

	STDMETHOD(get_Name)(
		/*[out]*/ BSTR* /*pName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Name)(
		/*[in]*/ BSTR /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Size)(
		/*[out]*/ CY* /*pSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Size)(
		/*[in]*/ CY /*size*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Bold)(
		/*[out]*/ BOOL* /*pBold*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Bold)(
		/*[in]*/ BOOL /*bold*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Italic)(
		/*[out]*/ BOOL* /*pItalic*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Italic)(
		/*[in]*/ BOOL /*italic*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Underline)(
		/*[out]*/ BOOL* /*pUnderline*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Underline)(
		/*[in]*/ BOOL /*underline*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Strikethrough)(
		/*[out]*/ BOOL* /*pStrikethrough*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Strikethrough)(
		/*[in]*/ BOOL /*strikethrough*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Weight)(
		/*[out]*/ SHORT* /*pWeight*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Weight)(
		/*[in]*/ SHORT /*weight*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Charset)(
		/*[out]*/ SHORT* /*pCharset*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Charset)(
		/*[in]*/ SHORT /*charset*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_hFont)(
		/*[out]*/ HFONT* /*phFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IFont** /*ppFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in]*/ IFont* /*pFontOther*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRatio)(
		/*[in]*/ LONG /*cyLogical*/,
		/*[in]*/ LONG /*cyHimetric*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryTextMetrics)(
		/*[out]*/ TEXTMETRICOLE* /*pTM*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddRefHfont)(
		/*[in]*/ HFONT /*hFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseHfont)(
		/*[in]*/ HFONT /*hFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHdc)(
		/*[in]*/ HDC /*hDC*/)VSL_STDMETHOD_NOTIMPL
};

class IFontMockImpl :
	public IFont,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IFontMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IFontMockImpl)

	typedef IFont Interface;
	struct get_NameValidValues
	{
		/*[out]*/ BSTR* pName;
		HRESULT retValue;
	};

	STDMETHOD(get_Name)(
		/*[out]*/ BSTR* pName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Name)

		VSL_SET_VALIDVALUE_BSTR(pName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NameValidValues
	{
		/*[in]*/ BSTR name;
		HRESULT retValue;
	};

	STDMETHOD(put_Name)(
		/*[in]*/ BSTR name)
	{
		VSL_DEFINE_MOCK_METHOD(put_Name)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SizeValidValues
	{
		/*[out]*/ CY* pSize;
		HRESULT retValue;
	};

	STDMETHOD(get_Size)(
		/*[out]*/ CY* pSize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Size)

		VSL_SET_VALIDVALUE(pSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SizeValidValues
	{
		/*[in]*/ CY size;
		HRESULT retValue;
	};

	STDMETHOD(put_Size)(
		/*[in]*/ CY size)
	{
		VSL_DEFINE_MOCK_METHOD(put_Size)

		VSL_CHECK_VALIDVALUE(size);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BoldValidValues
	{
		/*[out]*/ BOOL* pBold;
		HRESULT retValue;
	};

	STDMETHOD(get_Bold)(
		/*[out]*/ BOOL* pBold)
	{
		VSL_DEFINE_MOCK_METHOD(get_Bold)

		VSL_SET_VALIDVALUE(pBold);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BoldValidValues
	{
		/*[in]*/ BOOL bold;
		HRESULT retValue;
	};

	STDMETHOD(put_Bold)(
		/*[in]*/ BOOL bold)
	{
		VSL_DEFINE_MOCK_METHOD(put_Bold)

		VSL_CHECK_VALIDVALUE(bold);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ItalicValidValues
	{
		/*[out]*/ BOOL* pItalic;
		HRESULT retValue;
	};

	STDMETHOD(get_Italic)(
		/*[out]*/ BOOL* pItalic)
	{
		VSL_DEFINE_MOCK_METHOD(get_Italic)

		VSL_SET_VALIDVALUE(pItalic);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ItalicValidValues
	{
		/*[in]*/ BOOL italic;
		HRESULT retValue;
	};

	STDMETHOD(put_Italic)(
		/*[in]*/ BOOL italic)
	{
		VSL_DEFINE_MOCK_METHOD(put_Italic)

		VSL_CHECK_VALIDVALUE(italic);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UnderlineValidValues
	{
		/*[out]*/ BOOL* pUnderline;
		HRESULT retValue;
	};

	STDMETHOD(get_Underline)(
		/*[out]*/ BOOL* pUnderline)
	{
		VSL_DEFINE_MOCK_METHOD(get_Underline)

		VSL_SET_VALIDVALUE(pUnderline);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_UnderlineValidValues
	{
		/*[in]*/ BOOL underline;
		HRESULT retValue;
	};

	STDMETHOD(put_Underline)(
		/*[in]*/ BOOL underline)
	{
		VSL_DEFINE_MOCK_METHOD(put_Underline)

		VSL_CHECK_VALIDVALUE(underline);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StrikethroughValidValues
	{
		/*[out]*/ BOOL* pStrikethrough;
		HRESULT retValue;
	};

	STDMETHOD(get_Strikethrough)(
		/*[out]*/ BOOL* pStrikethrough)
	{
		VSL_DEFINE_MOCK_METHOD(get_Strikethrough)

		VSL_SET_VALIDVALUE(pStrikethrough);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StrikethroughValidValues
	{
		/*[in]*/ BOOL strikethrough;
		HRESULT retValue;
	};

	STDMETHOD(put_Strikethrough)(
		/*[in]*/ BOOL strikethrough)
	{
		VSL_DEFINE_MOCK_METHOD(put_Strikethrough)

		VSL_CHECK_VALIDVALUE(strikethrough);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WeightValidValues
	{
		/*[out]*/ SHORT* pWeight;
		HRESULT retValue;
	};

	STDMETHOD(get_Weight)(
		/*[out]*/ SHORT* pWeight)
	{
		VSL_DEFINE_MOCK_METHOD(get_Weight)

		VSL_SET_VALIDVALUE(pWeight);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WeightValidValues
	{
		/*[in]*/ SHORT weight;
		HRESULT retValue;
	};

	STDMETHOD(put_Weight)(
		/*[in]*/ SHORT weight)
	{
		VSL_DEFINE_MOCK_METHOD(put_Weight)

		VSL_CHECK_VALIDVALUE(weight);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CharsetValidValues
	{
		/*[out]*/ SHORT* pCharset;
		HRESULT retValue;
	};

	STDMETHOD(get_Charset)(
		/*[out]*/ SHORT* pCharset)
	{
		VSL_DEFINE_MOCK_METHOD(get_Charset)

		VSL_SET_VALIDVALUE(pCharset);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CharsetValidValues
	{
		/*[in]*/ SHORT charset;
		HRESULT retValue;
	};

	STDMETHOD(put_Charset)(
		/*[in]*/ SHORT charset)
	{
		VSL_DEFINE_MOCK_METHOD(put_Charset)

		VSL_CHECK_VALIDVALUE(charset);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_hFontValidValues
	{
		/*[out]*/ HFONT* phFont;
		HRESULT retValue;
	};

	STDMETHOD(get_hFont)(
		/*[out]*/ HFONT* phFont)
	{
		VSL_DEFINE_MOCK_METHOD(get_hFont)

		VSL_SET_VALIDVALUE(phFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IFont** ppFont;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IFont** ppFont)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in]*/ IFont* pFontOther;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in]*/ IFont* pFontOther)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFontOther);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRatioValidValues
	{
		/*[in]*/ LONG cyLogical;
		/*[in]*/ LONG cyHimetric;
		HRESULT retValue;
	};

	STDMETHOD(SetRatio)(
		/*[in]*/ LONG cyLogical,
		/*[in]*/ LONG cyHimetric)
	{
		VSL_DEFINE_MOCK_METHOD(SetRatio)

		VSL_CHECK_VALIDVALUE(cyLogical);

		VSL_CHECK_VALIDVALUE(cyHimetric);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryTextMetricsValidValues
	{
		/*[out]*/ TEXTMETRICOLE* pTM;
		HRESULT retValue;
	};

	STDMETHOD(QueryTextMetrics)(
		/*[out]*/ TEXTMETRICOLE* pTM)
	{
		VSL_DEFINE_MOCK_METHOD(QueryTextMetrics)

		VSL_SET_VALIDVALUE(pTM);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddRefHfontValidValues
	{
		/*[in]*/ HFONT hFont;
		HRESULT retValue;
	};

	STDMETHOD(AddRefHfont)(
		/*[in]*/ HFONT hFont)
	{
		VSL_DEFINE_MOCK_METHOD(AddRefHfont)

		VSL_CHECK_VALIDVALUE(hFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseHfontValidValues
	{
		/*[in]*/ HFONT hFont;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseHfont)(
		/*[in]*/ HFONT hFont)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseHfont)

		VSL_CHECK_VALIDVALUE(hFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHdcValidValues
	{
		/*[in]*/ HDC hDC;
		HRESULT retValue;
	};

	STDMETHOD(SetHdc)(
		/*[in]*/ HDC hDC)
	{
		VSL_DEFINE_MOCK_METHOD(SetHdc)

		VSL_CHECK_VALIDVALUE(hDC);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIForegroundTransfer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IFOREGROUNDTRANSFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IFOREGROUNDTRANSFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IForegroundTransferNotImpl :
	public IForegroundTransfer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IForegroundTransferNotImpl)

public:

	typedef IForegroundTransfer Interface;

	STDMETHOD(AllowForegroundTransfer)(
		/*[in]*/ void* /*lpvReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IForegroundTransferMockImpl :
	public IForegroundTransfer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IForegroundTransferMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IForegroundTransferMockImpl)

	typedef IForegroundTransfer Interface;
	struct AllowForegroundTransferValidValues
	{
		/*[in]*/ void* lpvReserved;
		HRESULT retValue;
		size_t lpvReserved_size_in_bytes;
	};

	STDMETHOD(AllowForegroundTransfer)(
		/*[in]*/ void* lpvReserved)
	{
		VSL_DEFINE_MOCK_METHOD(AllowForegroundTransfer)

		VSL_CHECK_VALIDVALUE_PVOID(lpvReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IFOREGROUNDTRANSFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIInternalUnknown.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IINTERNALUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IINTERNALUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IInternalUnknownNotImpl :
	public IInternalUnknown
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IInternalUnknownNotImpl)

public:

	typedef IInternalUnknown Interface;

	STDMETHOD(QueryInternalInterface)(
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppv*/)VSL_STDMETHOD_NOTIMPL
};

class IInternalUnknownMockImpl :
	public IInternalUnknown,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IInternalUnknownMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IInternalUnknownMockImpl)

	typedef IInternalUnknown Interface;
	struct QueryInternalInterfaceValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppv;
		HRESULT retValue;
	};

	STDMETHOD(QueryInternalInterface)(
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(QueryInternalInterface)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IINTERNALUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIHelp.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IHELP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IHELP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IHelpNotImpl :
	public IHelp
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IHelpNotImpl)

public:

	typedef IHelp Interface;

	STDMETHOD(GetHelpFile)(
		/*[out]*/ BSTR* /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHelpInfo)(
		/*[out]*/ DWORD* /*pdwHelpInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowHelp)(
		/*[in]*/ LPOLESTR /*szHelp*/,
		/*[in]*/ UINT /*fuCommand*/,
		/*[in]*/ DWORD /*dwHelpContext*/)VSL_STDMETHOD_NOTIMPL
};

class IHelpMockImpl :
	public IHelp,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IHelpMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IHelpMockImpl)

	typedef IHelp Interface;
	struct GetHelpFileValidValues
	{
		/*[out]*/ BSTR* pbstr;
		HRESULT retValue;
	};

	STDMETHOD(GetHelpFile)(
		/*[out]*/ BSTR* pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetHelpFile)

		VSL_SET_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHelpInfoValidValues
	{
		/*[out]*/ DWORD* pdwHelpInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetHelpInfo)(
		/*[out]*/ DWORD* pdwHelpInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetHelpInfo)

		VSL_SET_VALIDVALUE(pdwHelpInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowHelpValidValues
	{
		/*[in]*/ LPOLESTR szHelp;
		/*[in]*/ UINT fuCommand;
		/*[in]*/ DWORD dwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(ShowHelp)(
		/*[in]*/ LPOLESTR szHelp,
		/*[in]*/ UINT fuCommand,
		/*[in]*/ DWORD dwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(ShowHelp)

		VSL_CHECK_VALIDVALUE_STRINGW(szHelp);

		VSL_CHECK_VALIDVALUE(fuCommand);

		VSL_CHECK_VALIDVALUE(dwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IHELP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockILayoutStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ILAYOUTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ILAYOUTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ILayoutStorageNotImpl :
	public ILayoutStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILayoutStorageNotImpl)

public:

	typedef ILayoutStorage Interface;

	STDMETHOD(LayoutScript)(
		/*[in]*/ StorageLayout* /*pStorageLayout*/,
		/*[in]*/ DWORD /*nEntries*/,
		/*[in]*/ DWORD /*glfInterleavedFlag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginMonitor)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndMonitor)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReLayoutDocfile)(
		/*[in]*/ OLECHAR* /*pwcsNewDfName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReLayoutDocfileOnILockBytes)(
		/*[in]*/ ILockBytes* /*pILockBytes*/)VSL_STDMETHOD_NOTIMPL
};

class ILayoutStorageMockImpl :
	public ILayoutStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILayoutStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ILayoutStorageMockImpl)

	typedef ILayoutStorage Interface;
	struct LayoutScriptValidValues
	{
		/*[in]*/ StorageLayout* pStorageLayout;
		/*[in]*/ DWORD nEntries;
		/*[in]*/ DWORD glfInterleavedFlag;
		HRESULT retValue;
	};

	STDMETHOD(LayoutScript)(
		/*[in]*/ StorageLayout* pStorageLayout,
		/*[in]*/ DWORD nEntries,
		/*[in]*/ DWORD glfInterleavedFlag)
	{
		VSL_DEFINE_MOCK_METHOD(LayoutScript)

		VSL_CHECK_VALIDVALUE_POINTER(pStorageLayout);

		VSL_CHECK_VALIDVALUE(nEntries);

		VSL_CHECK_VALIDVALUE(glfInterleavedFlag);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginMonitorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginMonitor)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginMonitor)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndMonitorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndMonitor)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndMonitor)

		VSL_RETURN_VALIDVALUES();
	}
	struct ReLayoutDocfileValidValues
	{
		/*[in]*/ OLECHAR* pwcsNewDfName;
		HRESULT retValue;
	};

	STDMETHOD(ReLayoutDocfile)(
		/*[in]*/ OLECHAR* pwcsNewDfName)
	{
		VSL_DEFINE_MOCK_METHOD(ReLayoutDocfile)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsNewDfName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReLayoutDocfileOnILockBytesValidValues
	{
		/*[in]*/ ILockBytes* pILockBytes;
		HRESULT retValue;
	};

	STDMETHOD(ReLayoutDocfileOnILockBytes)(
		/*[in]*/ ILockBytes* pILockBytes)
	{
		VSL_DEFINE_MOCK_METHOD(ReLayoutDocfileOnILockBytes)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pILockBytes);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ILAYOUTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockILicensedClassManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ILICENSEDCLASSMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ILICENSEDCLASSMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ILicensedClassManagerNotImpl :
	public ILicensedClassManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILicensedClassManagerNotImpl)

public:

	typedef ILicensedClassManager Interface;

	STDMETHOD(OnChangeInRequiredClasses)(
		/*[in]*/ IRequireClasses* /*pirc*/)VSL_STDMETHOD_NOTIMPL
};

class ILicensedClassManagerMockImpl :
	public ILicensedClassManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILicensedClassManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ILicensedClassManagerMockImpl)

	typedef ILicensedClassManager Interface;
	struct OnChangeInRequiredClassesValidValues
	{
		/*[in]*/ IRequireClasses* pirc;
		HRESULT retValue;
	};

	STDMETHOD(OnChangeInRequiredClasses)(
		/*[in]*/ IRequireClasses* pirc)
	{
		VSL_DEFINE_MOCK_METHOD(OnChangeInRequiredClasses)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pirc);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ILICENSEDCLASSMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIGlobalInterfaceTable.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IGLOBALINTERFACETABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IGLOBALINTERFACETABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IGlobalInterfaceTableNotImpl :
	public IGlobalInterfaceTable
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IGlobalInterfaceTableNotImpl)

public:

	typedef IGlobalInterfaceTable Interface;

	STDMETHOD(RegisterInterfaceInGlobal)(
		/*[in]*/ IUnknown* /*pUnk*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ DWORD* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevokeInterfaceFromGlobal)(
		/*[in]*/ DWORD /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInterfaceFromGlobal)(
		/*[in]*/ DWORD /*dwCookie*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppv*/)VSL_STDMETHOD_NOTIMPL
};

class IGlobalInterfaceTableMockImpl :
	public IGlobalInterfaceTable,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IGlobalInterfaceTableMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IGlobalInterfaceTableMockImpl)

	typedef IGlobalInterfaceTable Interface;
	struct RegisterInterfaceInGlobalValidValues
	{
		/*[in]*/ IUnknown* pUnk;
		/*[in]*/ REFIID riid;
		/*[out]*/ DWORD* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterInterfaceInGlobal)(
		/*[in]*/ IUnknown* pUnk,
		/*[in]*/ REFIID riid,
		/*[out]*/ DWORD* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterInterfaceInGlobal)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnk);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevokeInterfaceFromGlobalValidValues
	{
		/*[in]*/ DWORD dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RevokeInterfaceFromGlobal)(
		/*[in]*/ DWORD dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RevokeInterfaceFromGlobal)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInterfaceFromGlobalValidValues
	{
		/*[in]*/ DWORD dwCookie;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppv;
		HRESULT retValue;
	};

	STDMETHOD(GetInterfaceFromGlobal)(
		/*[in]*/ DWORD dwCookie,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(GetInterfaceFromGlobal)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IGLOBALINTERFACETABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIInitializeSpy.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IINITIALIZESPY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IINITIALIZESPY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IInitializeSpyNotImpl :
	public IInitializeSpy
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IInitializeSpyNotImpl)

public:

	typedef IInitializeSpy Interface;

	STDMETHOD(PreInitialize)(
		/*[in]*/ DWORD /*dwCoInit*/,
		/*[in]*/ DWORD /*dwCurThreadAptRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PostInitialize)(
		/*[in]*/ HRESULT /*hrCoInit*/,
		/*[in]*/ DWORD /*dwCoInit*/,
		/*[in]*/ DWORD /*dwNewThreadAptRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PreUninitialize)(
		/*[in]*/ DWORD /*dwCurThreadAptRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PostUninitialize)(
		/*[in]*/ DWORD /*dwNewThreadAptRefs*/)VSL_STDMETHOD_NOTIMPL
};

class IInitializeSpyMockImpl :
	public IInitializeSpy,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IInitializeSpyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IInitializeSpyMockImpl)

	typedef IInitializeSpy Interface;
	struct PreInitializeValidValues
	{
		/*[in]*/ DWORD dwCoInit;
		/*[in]*/ DWORD dwCurThreadAptRefs;
		HRESULT retValue;
	};

	STDMETHOD(PreInitialize)(
		/*[in]*/ DWORD dwCoInit,
		/*[in]*/ DWORD dwCurThreadAptRefs)
	{
		VSL_DEFINE_MOCK_METHOD(PreInitialize)

		VSL_CHECK_VALIDVALUE(dwCoInit);

		VSL_CHECK_VALIDVALUE(dwCurThreadAptRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostInitializeValidValues
	{
		/*[in]*/ HRESULT hrCoInit;
		/*[in]*/ DWORD dwCoInit;
		/*[in]*/ DWORD dwNewThreadAptRefs;
		HRESULT retValue;
	};

	STDMETHOD(PostInitialize)(
		/*[in]*/ HRESULT hrCoInit,
		/*[in]*/ DWORD dwCoInit,
		/*[in]*/ DWORD dwNewThreadAptRefs)
	{
		VSL_DEFINE_MOCK_METHOD(PostInitialize)

		VSL_CHECK_VALIDVALUE(hrCoInit);

		VSL_CHECK_VALIDVALUE(dwCoInit);

		VSL_CHECK_VALIDVALUE(dwNewThreadAptRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct PreUninitializeValidValues
	{
		/*[in]*/ DWORD dwCurThreadAptRefs;
		HRESULT retValue;
	};

	STDMETHOD(PreUninitialize)(
		/*[in]*/ DWORD dwCurThreadAptRefs)
	{
		VSL_DEFINE_MOCK_METHOD(PreUninitialize)

		VSL_CHECK_VALIDVALUE(dwCurThreadAptRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostUninitializeValidValues
	{
		/*[in]*/ DWORD dwNewThreadAptRefs;
		HRESULT retValue;
	};

	STDMETHOD(PostUninitialize)(
		/*[in]*/ DWORD dwNewThreadAptRefs)
	{
		VSL_DEFINE_MOCK_METHOD(PostUninitialize)

		VSL_CHECK_VALIDVALUE(dwNewThreadAptRefs);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IINITIALIZESPY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockILocalRegistry.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ILOCALREGISTRY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ILOCALREGISTRY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ILocalRegistryNotImpl :
	public ILocalRegistry
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILocalRegistryNotImpl)

public:

	typedef ILocalRegistry Interface;

	STDMETHOD(CreateInstance)(
		/*[in]*/ CLSID /*clsid*/,
		/*[in]*/ IUnknown* /*punkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeLibOfClsid)(
		/*[in]*/ CLSID /*clsid*/,
		/*[out]*/ ITypeLib** /*pptlib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassObjectOfClsid)(
		/*[in]*/ REFCLSID /*clsid*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPVOID /*lpReserved*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ void** /*ppvClassObject*/)VSL_STDMETHOD_NOTIMPL
};

class ILocalRegistryMockImpl :
	public ILocalRegistry,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILocalRegistryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ILocalRegistryMockImpl)

	typedef ILocalRegistry Interface;
	struct CreateInstanceValidValues
	{
		/*[in]*/ CLSID clsid;
		/*[in]*/ IUnknown* punkOuter;
		/*[in]*/ REFIID riid;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in]*/ CLSID clsid,
		/*[in]*/ IUnknown* punkOuter,
		/*[in]*/ REFIID riid,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeLibOfClsidValidValues
	{
		/*[in]*/ CLSID clsid;
		/*[out]*/ ITypeLib** pptlib;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeLibOfClsid)(
		/*[in]*/ CLSID clsid,
		/*[out]*/ ITypeLib** pptlib)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeLibOfClsid)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_SET_VALIDVALUE_INTERFACE(pptlib);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassObjectOfClsidValidValues
	{
		/*[in]*/ REFCLSID clsid;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPVOID lpReserved;
		/*[in]*/ REFIID riid;
		/*[in]*/ void** ppvClassObject;
		HRESULT retValue;
		size_t lpReserved_size_in_bytes;
	};

	STDMETHOD(GetClassObjectOfClsid)(
		/*[in]*/ REFCLSID clsid,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPVOID lpReserved,
		/*[in]*/ REFIID riid,
		/*[in]*/ void** ppvClassObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassObjectOfClsid)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_PVOID(lpReserved);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_POINTER(ppvClassObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ILOCALREGISTRY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockILocalRegistry3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ILOCALREGISTRY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ILOCALREGISTRY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ILocalRegistry3NotImpl :
	public ILocalRegistry3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILocalRegistry3NotImpl)

public:

	typedef ILocalRegistry3 Interface;

	STDMETHOD(CreateManagedInstance)(
		/*[in]*/ LPCWSTR /*codeBase*/,
		/*[in]*/ LPCWSTR /*assemblyName*/,
		/*[in]*/ LPCWSTR /*typeName*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassObjectOfManagedClass)(
		/*[in]*/ LPCWSTR /*codeBase*/,
		/*[in]*/ LPCWSTR /*assemblyName*/,
		/*[in]*/ LPCWSTR /*typeName*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppvClassObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLocalRegistryRoot)(
		/*[out]*/ BSTR* /*pbstrRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstance)(
		/*[in]*/ CLSID /*clsid*/,
		/*[in]*/ IUnknown* /*punkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeLibOfClsid)(
		/*[in]*/ CLSID /*clsid*/,
		/*[out]*/ ITypeLib** /*pptlib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassObjectOfClsid)(
		/*[in]*/ REFCLSID /*clsid*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPVOID /*lpReserved*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ void** /*ppvClassObject*/)VSL_STDMETHOD_NOTIMPL
};

class ILocalRegistry3MockImpl :
	public ILocalRegistry3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILocalRegistry3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ILocalRegistry3MockImpl)

	typedef ILocalRegistry3 Interface;
	struct CreateManagedInstanceValidValues
	{
		/*[in]*/ LPCWSTR codeBase;
		/*[in]*/ LPCWSTR assemblyName;
		/*[in]*/ LPCWSTR typeName;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateManagedInstance)(
		/*[in]*/ LPCWSTR codeBase,
		/*[in]*/ LPCWSTR assemblyName,
		/*[in]*/ LPCWSTR typeName,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateManagedInstance)

		VSL_CHECK_VALIDVALUE_STRINGW(codeBase);

		VSL_CHECK_VALIDVALUE_STRINGW(assemblyName);

		VSL_CHECK_VALIDVALUE_STRINGW(typeName);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassObjectOfManagedClassValidValues
	{
		/*[in]*/ LPCWSTR codeBase;
		/*[in]*/ LPCWSTR assemblyName;
		/*[in]*/ LPCWSTR typeName;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppvClassObject;
		HRESULT retValue;
	};

	STDMETHOD(GetClassObjectOfManagedClass)(
		/*[in]*/ LPCWSTR codeBase,
		/*[in]*/ LPCWSTR assemblyName,
		/*[in]*/ LPCWSTR typeName,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppvClassObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassObjectOfManagedClass)

		VSL_CHECK_VALIDVALUE_STRINGW(codeBase);

		VSL_CHECK_VALIDVALUE_STRINGW(assemblyName);

		VSL_CHECK_VALIDVALUE_STRINGW(typeName);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvClassObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLocalRegistryRootValidValues
	{
		/*[out]*/ BSTR* pbstrRoot;
		HRESULT retValue;
	};

	STDMETHOD(GetLocalRegistryRoot)(
		/*[out]*/ BSTR* pbstrRoot)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocalRegistryRoot)

		VSL_SET_VALIDVALUE_BSTR(pbstrRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceValidValues
	{
		/*[in]*/ CLSID clsid;
		/*[in]*/ IUnknown* punkOuter;
		/*[in]*/ REFIID riid;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in]*/ CLSID clsid,
		/*[in]*/ IUnknown* punkOuter,
		/*[in]*/ REFIID riid,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeLibOfClsidValidValues
	{
		/*[in]*/ CLSID clsid;
		/*[out]*/ ITypeLib** pptlib;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeLibOfClsid)(
		/*[in]*/ CLSID clsid,
		/*[out]*/ ITypeLib** pptlib)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeLibOfClsid)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_SET_VALIDVALUE_INTERFACE(pptlib);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassObjectOfClsidValidValues
	{
		/*[in]*/ REFCLSID clsid;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPVOID lpReserved;
		/*[in]*/ REFIID riid;
		/*[in]*/ void** ppvClassObject;
		HRESULT retValue;
		size_t lpReserved_size_in_bytes;
	};

	STDMETHOD(GetClassObjectOfClsid)(
		/*[in]*/ REFCLSID clsid,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPVOID lpReserved,
		/*[in]*/ REFIID riid,
		/*[in]*/ void** ppvClassObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassObjectOfClsid)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_PVOID(lpReserved);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_POINTER(ppvClassObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ILOCALREGISTRY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockILocalRegistry2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ILOCALREGISTRY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ILOCALREGISTRY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ILocalRegistry2NotImpl :
	public ILocalRegistry2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILocalRegistry2NotImpl)

public:

	typedef ILocalRegistry2 Interface;

	STDMETHOD(GetLocalRegistryRoot)(
		/*[out]*/ BSTR* /*pbstrRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstance)(
		/*[in]*/ CLSID /*clsid*/,
		/*[in]*/ IUnknown* /*punkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeLibOfClsid)(
		/*[in]*/ CLSID /*clsid*/,
		/*[out]*/ ITypeLib** /*pptlib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassObjectOfClsid)(
		/*[in]*/ REFCLSID /*clsid*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPVOID /*lpReserved*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ void** /*ppvClassObject*/)VSL_STDMETHOD_NOTIMPL
};

class ILocalRegistry2MockImpl :
	public ILocalRegistry2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILocalRegistry2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ILocalRegistry2MockImpl)

	typedef ILocalRegistry2 Interface;
	struct GetLocalRegistryRootValidValues
	{
		/*[out]*/ BSTR* pbstrRoot;
		HRESULT retValue;
	};

	STDMETHOD(GetLocalRegistryRoot)(
		/*[out]*/ BSTR* pbstrRoot)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocalRegistryRoot)

		VSL_SET_VALIDVALUE_BSTR(pbstrRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceValidValues
	{
		/*[in]*/ CLSID clsid;
		/*[in]*/ IUnknown* punkOuter;
		/*[in]*/ REFIID riid;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in]*/ CLSID clsid,
		/*[in]*/ IUnknown* punkOuter,
		/*[in]*/ REFIID riid,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeLibOfClsidValidValues
	{
		/*[in]*/ CLSID clsid;
		/*[out]*/ ITypeLib** pptlib;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeLibOfClsid)(
		/*[in]*/ CLSID clsid,
		/*[out]*/ ITypeLib** pptlib)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeLibOfClsid)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_SET_VALIDVALUE_INTERFACE(pptlib);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassObjectOfClsidValidValues
	{
		/*[in]*/ REFCLSID clsid;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPVOID lpReserved;
		/*[in]*/ REFIID riid;
		/*[in]*/ void** ppvClassObject;
		HRESULT retValue;
		size_t lpReserved_size_in_bytes;
	};

	STDMETHOD(GetClassObjectOfClsid)(
		/*[in]*/ REFCLSID clsid,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPVOID lpReserved,
		/*[in]*/ REFIID riid,
		/*[in]*/ void** ppvClassObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassObjectOfClsid)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_PVOID(lpReserved);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_POINTER(ppvClassObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ILOCALREGISTRY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMalloc.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMALLOC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMALLOC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMallocNotImpl :
	public IMalloc
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMallocNotImpl)

public:

	typedef IMalloc Interface;

	virtual void* STDMETHODCALLTYPE Alloc(
		/*[in]*/ SIZE_T /*cb*/){ return NULL; }

	virtual void* STDMETHODCALLTYPE Realloc(
		/*[in]*/ void* /*pv*/,
		/*[in]*/ SIZE_T /*cb*/){ return NULL; }

	virtual void STDMETHODCALLTYPE Free(
		/*[in]*/ void* /*pv*/){ return ; }

	virtual SIZE_T STDMETHODCALLTYPE GetSize(
		/*[in]*/ void* /*pv*/){ return SIZE_T(); }

	virtual int STDMETHODCALLTYPE DidAlloc(
		/*[in]*/ void* /*pv*/){ return int(); }

	virtual void STDMETHODCALLTYPE HeapMinimize(){ return ; }
};

class IMallocMockImpl :
	public IMalloc,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMallocMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMallocMockImpl)

	typedef IMalloc Interface;
	struct AllocValidValues
	{
		/*[in]*/ SIZE_T cb;
		void* retValue;
	};

	virtual void* _stdcall Alloc(
		/*[in]*/ SIZE_T cb)
	{
		VSL_DEFINE_MOCK_METHOD(Alloc)

		VSL_CHECK_VALIDVALUE(cb);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReallocValidValues
	{
		/*[in]*/ void* pv;
		/*[in]*/ SIZE_T cb;
		void* retValue;
		size_t pv_size_in_bytes;
	};

	virtual void* _stdcall Realloc(
		/*[in]*/ void* pv,
		/*[in]*/ SIZE_T cb)
	{
		VSL_DEFINE_MOCK_METHOD(Realloc)

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeValidValues
	{
		/*[in]*/ void* pv;
		size_t pv_size_in_bytes;
	};

	virtual void _stdcall Free(
		/*[in]*/ void* pv)
	{
		VSL_DEFINE_MOCK_METHOD(Free)

		VSL_CHECK_VALIDVALUE_PVOID(pv);

	}
	struct GetSizeValidValues
	{
		/*[in]*/ void* pv;
		SIZE_T retValue;
		size_t pv_size_in_bytes;
	};

	virtual SIZE_T _stdcall GetSize(
		/*[in]*/ void* pv)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_RETURN_VALIDVALUES();
	}
	struct DidAllocValidValues
	{
		/*[in]*/ void* pv;
		int retValue;
		size_t pv_size_in_bytes;
	};

	virtual int _stdcall DidAlloc(
		/*[in]*/ void* pv)
	{
		VSL_DEFINE_MOCK_METHOD(DidAlloc)

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall HeapMinimize()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(HeapMinimize)

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMALLOC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMallocSpy.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMALLOCSPY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMALLOCSPY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMallocSpyNotImpl :
	public IMallocSpy
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMallocSpyNotImpl)

public:

	typedef IMallocSpy Interface;

	virtual SIZE_T STDMETHODCALLTYPE PreAlloc(
		/*[in]*/ SIZE_T /*cbRequest*/){ return SIZE_T(); }

	virtual void* STDMETHODCALLTYPE PostAlloc(
		/*[in]*/ void* /*pActual*/){ return NULL; }

	virtual void* STDMETHODCALLTYPE PreFree(
		/*[in]*/ void* /*pRequest*/,
		/*[in]*/ BOOL /*fSpyed*/){ return NULL; }

	virtual void STDMETHODCALLTYPE PostFree(
		/*[in]*/ BOOL /*fSpyed*/){ return ; }

	virtual SIZE_T STDMETHODCALLTYPE PreRealloc(
		/*[in]*/ void* /*pRequest*/,
		/*[in]*/ SIZE_T /*cbRequest*/,
		/*[out]*/ void** /*ppNewRequest*/,
		/*[in]*/ BOOL /*fSpyed*/){ return SIZE_T(); }

	virtual void* STDMETHODCALLTYPE PostRealloc(
		/*[in]*/ void* /*pActual*/,
		/*[in]*/ BOOL /*fSpyed*/){ return NULL; }

	virtual void* STDMETHODCALLTYPE PreGetSize(
		/*[in]*/ void* /*pRequest*/,
		/*[in]*/ BOOL /*fSpyed*/){ return NULL; }

	virtual SIZE_T STDMETHODCALLTYPE PostGetSize(
		/*[in]*/ SIZE_T /*cbActual*/,
		/*[in]*/ BOOL /*fSpyed*/){ return SIZE_T(); }

	virtual void* STDMETHODCALLTYPE PreDidAlloc(
		/*[in]*/ void* /*pRequest*/,
		/*[in]*/ BOOL /*fSpyed*/){ return NULL; }

	virtual int STDMETHODCALLTYPE PostDidAlloc(
		/*[in]*/ void* /*pRequest*/,
		/*[in]*/ BOOL /*fSpyed*/,
		/*[in]*/ int /*fActual*/){ return int(); }

	virtual void STDMETHODCALLTYPE PreHeapMinimize(){ return ; }

	virtual void STDMETHODCALLTYPE PostHeapMinimize(){ return ; }
};

class IMallocSpyMockImpl :
	public IMallocSpy,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMallocSpyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMallocSpyMockImpl)

	typedef IMallocSpy Interface;
	struct PreAllocValidValues
	{
		/*[in]*/ SIZE_T cbRequest;
		SIZE_T retValue;
	};

	virtual SIZE_T _stdcall PreAlloc(
		/*[in]*/ SIZE_T cbRequest)
	{
		VSL_DEFINE_MOCK_METHOD(PreAlloc)

		VSL_CHECK_VALIDVALUE(cbRequest);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostAllocValidValues
	{
		/*[in]*/ void* pActual;
		void* retValue;
		size_t pActual_size_in_bytes;
	};

	virtual void* _stdcall PostAlloc(
		/*[in]*/ void* pActual)
	{
		VSL_DEFINE_MOCK_METHOD(PostAlloc)

		VSL_CHECK_VALIDVALUE_PVOID(pActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct PreFreeValidValues
	{
		/*[in]*/ void* pRequest;
		/*[in]*/ BOOL fSpyed;
		void* retValue;
		size_t pRequest_size_in_bytes;
	};

	virtual void* _stdcall PreFree(
		/*[in]*/ void* pRequest,
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PreFree)

		VSL_CHECK_VALIDVALUE_PVOID(pRequest);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostFreeValidValues
	{
		/*[in]*/ BOOL fSpyed;
	};

	virtual void _stdcall PostFree(
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PostFree)

		VSL_CHECK_VALIDVALUE(fSpyed);

	}
	struct PreReallocValidValues
	{
		/*[in]*/ void* pRequest;
		/*[in]*/ SIZE_T cbRequest;
		/*[out]*/ void** ppNewRequest;
		/*[in]*/ BOOL fSpyed;
		SIZE_T retValue;
		size_t pRequest_size_in_bytes;
	};

	virtual SIZE_T _stdcall PreRealloc(
		/*[in]*/ void* pRequest,
		/*[in]*/ SIZE_T cbRequest,
		/*[out]*/ void** ppNewRequest,
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PreRealloc)

		VSL_CHECK_VALIDVALUE_PVOID(pRequest);

		VSL_CHECK_VALIDVALUE(cbRequest);

		VSL_SET_VALIDVALUE(ppNewRequest);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostReallocValidValues
	{
		/*[in]*/ void* pActual;
		/*[in]*/ BOOL fSpyed;
		void* retValue;
		size_t pActual_size_in_bytes;
	};

	virtual void* _stdcall PostRealloc(
		/*[in]*/ void* pActual,
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PostRealloc)

		VSL_CHECK_VALIDVALUE_PVOID(pActual);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_RETURN_VALIDVALUES();
	}
	struct PreGetSizeValidValues
	{
		/*[in]*/ void* pRequest;
		/*[in]*/ BOOL fSpyed;
		void* retValue;
		size_t pRequest_size_in_bytes;
	};

	virtual void* _stdcall PreGetSize(
		/*[in]*/ void* pRequest,
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PreGetSize)

		VSL_CHECK_VALIDVALUE_PVOID(pRequest);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostGetSizeValidValues
	{
		/*[in]*/ SIZE_T cbActual;
		/*[in]*/ BOOL fSpyed;
		SIZE_T retValue;
	};

	virtual SIZE_T _stdcall PostGetSize(
		/*[in]*/ SIZE_T cbActual,
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PostGetSize)

		VSL_CHECK_VALIDVALUE(cbActual);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_RETURN_VALIDVALUES();
	}
	struct PreDidAllocValidValues
	{
		/*[in]*/ void* pRequest;
		/*[in]*/ BOOL fSpyed;
		void* retValue;
		size_t pRequest_size_in_bytes;
	};

	virtual void* _stdcall PreDidAlloc(
		/*[in]*/ void* pRequest,
		/*[in]*/ BOOL fSpyed)
	{
		VSL_DEFINE_MOCK_METHOD(PreDidAlloc)

		VSL_CHECK_VALIDVALUE_PVOID(pRequest);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostDidAllocValidValues
	{
		/*[in]*/ void* pRequest;
		/*[in]*/ BOOL fSpyed;
		/*[in]*/ int fActual;
		int retValue;
		size_t pRequest_size_in_bytes;
	};

	virtual int _stdcall PostDidAlloc(
		/*[in]*/ void* pRequest,
		/*[in]*/ BOOL fSpyed,
		/*[in]*/ int fActual)
	{
		VSL_DEFINE_MOCK_METHOD(PostDidAlloc)

		VSL_CHECK_VALIDVALUE_PVOID(pRequest);

		VSL_CHECK_VALIDVALUE(fSpyed);

		VSL_CHECK_VALIDVALUE(fActual);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall PreHeapMinimize()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(PreHeapMinimize)

	}

	virtual void _stdcall PostHeapMinimize()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(PostHeapMinimize)

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMALLOCSPY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIManagedViewerHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMANAGEDVIEWERHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMANAGEDVIEWERHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IManagedViewerHostNotImpl :
	public IManagedViewerHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IManagedViewerHostNotImpl)

public:

	typedef IManagedViewerHost Interface;

	STDMETHOD(CreateViewer)(
		/*[in]*/ ULONG /*hwnd*/,
		/*[in]*/ IUnknown* /*hostServices*/,
		/*[in]*/ IPropertyProxyEESide* /*property*/)VSL_STDMETHOD_NOTIMPL
};

class IManagedViewerHostMockImpl :
	public IManagedViewerHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IManagedViewerHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IManagedViewerHostMockImpl)

	typedef IManagedViewerHost Interface;
	struct CreateViewerValidValues
	{
		/*[in]*/ ULONG hwnd;
		/*[in]*/ IUnknown* hostServices;
		/*[in]*/ IPropertyProxyEESide* property;
		HRESULT retValue;
	};

	STDMETHOD(CreateViewer)(
		/*[in]*/ ULONG hwnd,
		/*[in]*/ IUnknown* hostServices,
		/*[in]*/ IPropertyProxyEESide* property)
	{
		VSL_DEFINE_MOCK_METHOD(CreateViewer)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(hostServices);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(property);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMANAGEDVIEWERHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockILockBytes.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ILOCKBYTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ILOCKBYTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ILockBytesNotImpl :
	public ILockBytes
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILockBytesNotImpl)

public:

	typedef ILockBytes Interface;

	STDMETHOD(ReadAt)(
		/*[in]*/ ULARGE_INTEGER /*ulOffset*/,
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbRead*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteAt)(
		/*[in]*/ ULARGE_INTEGER /*ulOffset*/,
		/*[in,size_is(cb)]*/ const void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Flush)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSize)(
		/*[in]*/ ULARGE_INTEGER /*cb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockRegion)(
		/*[in]*/ ULARGE_INTEGER /*libOffset*/,
		/*[in]*/ ULARGE_INTEGER /*cb*/,
		/*[in]*/ DWORD /*dwLockType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockRegion)(
		/*[in]*/ ULARGE_INTEGER /*libOffset*/,
		/*[in]*/ ULARGE_INTEGER /*cb*/,
		/*[in]*/ DWORD /*dwLockType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Stat)(
		/*[out]*/ STATSTG* /*pstatstg*/,
		/*[in]*/ DWORD /*grfStatFlag*/)VSL_STDMETHOD_NOTIMPL
};

class ILockBytesMockImpl :
	public ILockBytes,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ILockBytesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ILockBytesMockImpl)

	typedef ILockBytes Interface;
	struct ReadAtValidValues
	{
		/*[in]*/ ULARGE_INTEGER ulOffset;
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbRead;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(ReadAt)(
		/*[in]*/ ULARGE_INTEGER ulOffset,
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbRead)
	{
		VSL_DEFINE_MOCK_METHOD(ReadAt)

		VSL_CHECK_VALIDVALUE(ulOffset);

		VSL_SET_VALIDVALUE_MEMCPY(pv, cb, *(validValues.pcbRead));

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbRead);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteAtValidValues
	{
		/*[in]*/ ULARGE_INTEGER ulOffset;
		/*[in,size_is(cb)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbWritten;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(WriteAt)(
		/*[in]*/ ULARGE_INTEGER ulOffset,
		/*[in,size_is(cb)]*/ const void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(WriteAt)

		VSL_CHECK_VALIDVALUE(ulOffset);

		VSL_CHECK_VALIDVALUE_MEMCMP(pv, cb, validValues.cb);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Flush)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Flush)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSizeValidValues
	{
		/*[in]*/ ULARGE_INTEGER cb;
		HRESULT retValue;
	};

	STDMETHOD(SetSize)(
		/*[in]*/ ULARGE_INTEGER cb)
	{
		VSL_DEFINE_MOCK_METHOD(SetSize)

		VSL_CHECK_VALIDVALUE(cb);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockRegionValidValues
	{
		/*[in]*/ ULARGE_INTEGER libOffset;
		/*[in]*/ ULARGE_INTEGER cb;
		/*[in]*/ DWORD dwLockType;
		HRESULT retValue;
	};

	STDMETHOD(LockRegion)(
		/*[in]*/ ULARGE_INTEGER libOffset,
		/*[in]*/ ULARGE_INTEGER cb,
		/*[in]*/ DWORD dwLockType)
	{
		VSL_DEFINE_MOCK_METHOD(LockRegion)

		VSL_CHECK_VALIDVALUE(libOffset);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_CHECK_VALIDVALUE(dwLockType);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockRegionValidValues
	{
		/*[in]*/ ULARGE_INTEGER libOffset;
		/*[in]*/ ULARGE_INTEGER cb;
		/*[in]*/ DWORD dwLockType;
		HRESULT retValue;
	};

	STDMETHOD(UnlockRegion)(
		/*[in]*/ ULARGE_INTEGER libOffset,
		/*[in]*/ ULARGE_INTEGER cb,
		/*[in]*/ DWORD dwLockType)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockRegion)

		VSL_CHECK_VALIDVALUE(libOffset);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_CHECK_VALIDVALUE(dwLockType);

		VSL_RETURN_VALIDVALUES();
	}
	struct StatValidValues
	{
		/*[out]*/ STATSTG* pstatstg;
		/*[in]*/ DWORD grfStatFlag;
		HRESULT retValue;
	};

	STDMETHOD(Stat)(
		/*[out]*/ STATSTG* pstatstg,
		/*[in]*/ DWORD grfStatFlag)
	{
		VSL_DEFINE_MOCK_METHOD(Stat)

		VSL_SET_VALIDVALUE(pstatstg);

		VSL_CHECK_VALIDVALUE(grfStatFlag);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ILOCKBYTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMarshal.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMARSHAL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMARSHAL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMarshalNotImpl :
	public IMarshal
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMarshalNotImpl)

public:

	typedef IMarshal Interface;

	STDMETHOD(GetUnmarshalClass)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,unique]*/ void* /*pv*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[in]*/ DWORD /*mshlflags*/,
		/*[out]*/ CLSID* /*pCid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarshalSizeMax)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,unique]*/ void* /*pv*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[in]*/ DWORD /*mshlflags*/,
		/*[out]*/ DWORD* /*pSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MarshalInterface)(
		/*[in,unique]*/ IStream* /*pStm*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in,unique]*/ void* /*pv*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[in]*/ DWORD /*mshlflags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnmarshalInterface)(
		/*[in,unique]*/ IStream* /*pStm*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseMarshalData)(
		/*[in,unique]*/ IStream* /*pStm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisconnectObject)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IMarshalMockImpl :
	public IMarshal,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMarshalMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMarshalMockImpl)

	typedef IMarshal Interface;
	struct GetUnmarshalClassValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,unique]*/ void* pv;
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[in]*/ DWORD mshlflags;
		/*[out]*/ CLSID* pCid;
		HRESULT retValue;
		size_t pv_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(GetUnmarshalClass)(
		/*[in]*/ REFIID riid,
		/*[in,unique]*/ void* pv,
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[in]*/ DWORD mshlflags,
		/*[out]*/ CLSID* pCid)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnmarshalClass)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(mshlflags);

		VSL_SET_VALIDVALUE(pCid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarshalSizeMaxValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,unique]*/ void* pv;
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[in]*/ DWORD mshlflags;
		/*[out]*/ DWORD* pSize;
		HRESULT retValue;
		size_t pv_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(GetMarshalSizeMax)(
		/*[in]*/ REFIID riid,
		/*[in,unique]*/ void* pv,
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[in]*/ DWORD mshlflags,
		/*[out]*/ DWORD* pSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarshalSizeMax)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(mshlflags);

		VSL_SET_VALIDVALUE(pSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct MarshalInterfaceValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		/*[in]*/ REFIID riid;
		/*[in,unique]*/ void* pv;
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[in]*/ DWORD mshlflags;
		HRESULT retValue;
		size_t pv_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(MarshalInterface)(
		/*[in,unique]*/ IStream* pStm,
		/*[in]*/ REFIID riid,
		/*[in,unique]*/ void* pv,
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[in]*/ DWORD mshlflags)
	{
		VSL_DEFINE_MOCK_METHOD(MarshalInterface)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(mshlflags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnmarshalInterfaceValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppv;
		HRESULT retValue;
	};

	STDMETHOD(UnmarshalInterface)(
		/*[in,unique]*/ IStream* pStm,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(UnmarshalInterface)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseMarshalDataValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseMarshalData)(
		/*[in,unique]*/ IStream* pStm)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseMarshalData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisconnectObjectValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(DisconnectObject)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(DisconnectObject)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMARSHAL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMarshal2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMARSHAL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMARSHAL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMarshal2NotImpl :
	public IMarshal2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMarshal2NotImpl)

public:

	typedef IMarshal2 Interface;

	STDMETHOD(GetUnmarshalClass)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,unique]*/ void* /*pv*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[in]*/ DWORD /*mshlflags*/,
		/*[out]*/ CLSID* /*pCid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarshalSizeMax)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,unique]*/ void* /*pv*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[in]*/ DWORD /*mshlflags*/,
		/*[out]*/ DWORD* /*pSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MarshalInterface)(
		/*[in,unique]*/ IStream* /*pStm*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in,unique]*/ void* /*pv*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[in]*/ DWORD /*mshlflags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnmarshalInterface)(
		/*[in,unique]*/ IStream* /*pStm*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseMarshalData)(
		/*[in,unique]*/ IStream* /*pStm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisconnectObject)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IMarshal2MockImpl :
	public IMarshal2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMarshal2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMarshal2MockImpl)

	typedef IMarshal2 Interface;
	struct GetUnmarshalClassValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,unique]*/ void* pv;
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[in]*/ DWORD mshlflags;
		/*[out]*/ CLSID* pCid;
		HRESULT retValue;
		size_t pv_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(GetUnmarshalClass)(
		/*[in]*/ REFIID riid,
		/*[in,unique]*/ void* pv,
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[in]*/ DWORD mshlflags,
		/*[out]*/ CLSID* pCid)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnmarshalClass)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(mshlflags);

		VSL_SET_VALIDVALUE(pCid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarshalSizeMaxValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,unique]*/ void* pv;
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[in]*/ DWORD mshlflags;
		/*[out]*/ DWORD* pSize;
		HRESULT retValue;
		size_t pv_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(GetMarshalSizeMax)(
		/*[in]*/ REFIID riid,
		/*[in,unique]*/ void* pv,
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[in]*/ DWORD mshlflags,
		/*[out]*/ DWORD* pSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarshalSizeMax)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(mshlflags);

		VSL_SET_VALIDVALUE(pSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct MarshalInterfaceValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		/*[in]*/ REFIID riid;
		/*[in,unique]*/ void* pv;
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[in]*/ DWORD mshlflags;
		HRESULT retValue;
		size_t pv_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(MarshalInterface)(
		/*[in,unique]*/ IStream* pStm,
		/*[in]*/ REFIID riid,
		/*[in,unique]*/ void* pv,
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[in]*/ DWORD mshlflags)
	{
		VSL_DEFINE_MOCK_METHOD(MarshalInterface)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_PVOID(pv);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(mshlflags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnmarshalInterfaceValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppv;
		HRESULT retValue;
	};

	STDMETHOD(UnmarshalInterface)(
		/*[in,unique]*/ IStream* pStm,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(UnmarshalInterface)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseMarshalDataValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseMarshalData)(
		/*[in,unique]*/ IStream* pStm)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseMarshalData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisconnectObjectValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(DisconnectObject)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(DisconnectObject)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMARSHAL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMessageFilter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMESSAGEFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMESSAGEFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMessageFilterNotImpl :
	public IMessageFilter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMessageFilterNotImpl)

public:

	typedef IMessageFilter Interface;

	virtual DWORD STDMETHODCALLTYPE HandleInComingCall(
		/*[in]*/ DWORD /*dwCallType*/,
		/*[in]*/ HTASK /*htaskCaller*/,
		/*[in]*/ DWORD /*dwTickCount*/,
		/*[in]*/ LPINTERFACEINFO /*lpInterfaceInfo*/){ return DWORD(); }

	virtual DWORD STDMETHODCALLTYPE RetryRejectedCall(
		/*[in]*/ HTASK /*htaskCallee*/,
		/*[in]*/ DWORD /*dwTickCount*/,
		/*[in]*/ DWORD /*dwRejectType*/){ return DWORD(); }

	virtual DWORD STDMETHODCALLTYPE MessagePending(
		/*[in]*/ HTASK /*htaskCallee*/,
		/*[in]*/ DWORD /*dwTickCount*/,
		/*[in]*/ DWORD /*dwPendingType*/){ return DWORD(); }
};

class IMessageFilterMockImpl :
	public IMessageFilter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMessageFilterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMessageFilterMockImpl)

	typedef IMessageFilter Interface;
	struct HandleInComingCallValidValues
	{
		/*[in]*/ DWORD dwCallType;
		/*[in]*/ HTASK htaskCaller;
		/*[in]*/ DWORD dwTickCount;
		/*[in]*/ LPINTERFACEINFO lpInterfaceInfo;
		DWORD retValue;
	};

	virtual DWORD _stdcall HandleInComingCall(
		/*[in]*/ DWORD dwCallType,
		/*[in]*/ HTASK htaskCaller,
		/*[in]*/ DWORD dwTickCount,
		/*[in]*/ LPINTERFACEINFO lpInterfaceInfo)
	{
		VSL_DEFINE_MOCK_METHOD(HandleInComingCall)

		VSL_CHECK_VALIDVALUE(dwCallType);

		VSL_CHECK_VALIDVALUE(htaskCaller);

		VSL_CHECK_VALIDVALUE(dwTickCount);

		VSL_CHECK_VALIDVALUE(lpInterfaceInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct RetryRejectedCallValidValues
	{
		/*[in]*/ HTASK htaskCallee;
		/*[in]*/ DWORD dwTickCount;
		/*[in]*/ DWORD dwRejectType;
		DWORD retValue;
	};

	virtual DWORD _stdcall RetryRejectedCall(
		/*[in]*/ HTASK htaskCallee,
		/*[in]*/ DWORD dwTickCount,
		/*[in]*/ DWORD dwRejectType)
	{
		VSL_DEFINE_MOCK_METHOD(RetryRejectedCall)

		VSL_CHECK_VALIDVALUE(htaskCallee);

		VSL_CHECK_VALIDVALUE(dwTickCount);

		VSL_CHECK_VALIDVALUE(dwRejectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct MessagePendingValidValues
	{
		/*[in]*/ HTASK htaskCallee;
		/*[in]*/ DWORD dwTickCount;
		/*[in]*/ DWORD dwPendingType;
		DWORD retValue;
	};

	virtual DWORD _stdcall MessagePending(
		/*[in]*/ HTASK htaskCallee,
		/*[in]*/ DWORD dwTickCount,
		/*[in]*/ DWORD dwPendingType)
	{
		VSL_DEFINE_MOCK_METHOD(MessagePending)

		VSL_CHECK_VALIDVALUE(htaskCallee);

		VSL_CHECK_VALIDVALUE(dwTickCount);

		VSL_CHECK_VALIDVALUE(dwPendingType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMESSAGEFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMultiQI.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMULTIQI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMULTIQI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMultiQINotImpl :
	public IMultiQI
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMultiQINotImpl)

public:

	typedef IMultiQI Interface;

	STDMETHOD(QueryMultipleInterfaces)(
		/*[in]*/ ULONG /*cMQIs*/,
		/*[in,out]*/ MULTI_QI* /*pMQIs*/)VSL_STDMETHOD_NOTIMPL
};

class IMultiQIMockImpl :
	public IMultiQI,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMultiQIMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMultiQIMockImpl)

	typedef IMultiQI Interface;
	struct QueryMultipleInterfacesValidValues
	{
		/*[in]*/ ULONG cMQIs;
		/*[in,out]*/ MULTI_QI* pMQIs;
		HRESULT retValue;
	};

	STDMETHOD(QueryMultipleInterfaces)(
		/*[in]*/ ULONG cMQIs,
		/*[in,out]*/ MULTI_QI* pMQIs)
	{
		VSL_DEFINE_MOCK_METHOD(QueryMultipleInterfaces)

		VSL_CHECK_VALIDVALUE(cMQIs);

		VSL_SET_VALIDVALUE(pMQIs);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMULTIQI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleCache.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECACHE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECACHE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleCacheNotImpl :
	public IOleCache
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCacheNotImpl)

public:

	typedef IOleCache Interface;

	STDMETHOD(Cache)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/,
		/*[in]*/ DWORD /*advf*/,
		/*[out]*/ DWORD* /*pdwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Uncache)(
		/*[in]*/ DWORD /*dwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCache)(
		/*[out]*/ IEnumSTATDATA** /*ppenumSTATDATA*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitCache)(
		/*[in,unique]*/ IDataObject* /*pDataObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetData)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/,
		/*[in,unique]*/ STGMEDIUM* /*pmedium*/,
		/*[in]*/ BOOL /*fRelease*/)VSL_STDMETHOD_NOTIMPL
};

class IOleCacheMockImpl :
	public IOleCache,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCacheMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleCacheMockImpl)

	typedef IOleCache Interface;
	struct CacheValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		/*[in]*/ DWORD advf;
		/*[out]*/ DWORD* pdwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Cache)(
		/*[in,unique]*/ FORMATETC* pformatetc,
		/*[in]*/ DWORD advf,
		/*[out]*/ DWORD* pdwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Cache)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_CHECK_VALIDVALUE(advf);

		VSL_SET_VALIDVALUE(pdwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct UncacheValidValues
	{
		/*[in]*/ DWORD dwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Uncache)(
		/*[in]*/ DWORD dwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Uncache)

		VSL_CHECK_VALIDVALUE(dwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCacheValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenumSTATDATA;
		HRESULT retValue;
	};

	STDMETHOD(EnumCache)(
		/*[out]*/ IEnumSTATDATA** ppenumSTATDATA)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCache)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumSTATDATA);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitCacheValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObject;
		HRESULT retValue;
	};

	STDMETHOD(InitCache)(
		/*[in,unique]*/ IDataObject* pDataObject)
	{
		VSL_DEFINE_MOCK_METHOD(InitCache)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDataValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		/*[in,unique]*/ STGMEDIUM* pmedium;
		/*[in]*/ BOOL fRelease;
		HRESULT retValue;
	};

	STDMETHOD(SetData)(
		/*[in,unique]*/ FORMATETC* pformatetc,
		/*[in,unique]*/ STGMEDIUM* pmedium,
		/*[in]*/ BOOL fRelease)
	{
		VSL_DEFINE_MOCK_METHOD(SetData)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pmedium);

		VSL_CHECK_VALIDVALUE(fRelease);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECACHE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIMoniker.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMONIKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMONIKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IMonikerNotImpl :
	public IMoniker
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMonikerNotImpl)

public:

	typedef IMoniker Interface;

	STDMETHOD(BindToObject)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in,unique]*/ IMoniker* /*pmkToLeft*/,
		/*[in]*/ REFIID /*riidResult*/,
		/*[out,iid_is(riidResult)]*/ void** /*ppvResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BindToStorage)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in,unique]*/ IMoniker* /*pmkToLeft*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reduce)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in]*/ DWORD /*dwReduceHowFar*/,
		/*[in,out,unique]*/ IMoniker** /*ppmkToLeft*/,
		/*[out]*/ IMoniker** /*ppmkReduced*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ComposeWith)(
		/*[in,unique]*/ IMoniker* /*pmkRight*/,
		/*[in]*/ BOOL /*fOnlyIfNotGeneric*/,
		/*[out]*/ IMoniker** /*ppmkComposite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Enum)(
		/*[in]*/ BOOL /*fForward*/,
		/*[out]*/ IEnumMoniker** /*ppenumMoniker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in,unique]*/ IMoniker* /*pmkOtherMoniker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hash)(
		/*[out]*/ DWORD* /*pdwHash*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsRunning)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in,unique]*/ IMoniker* /*pmkToLeft*/,
		/*[in,unique]*/ IMoniker* /*pmkNewlyRunning*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTimeOfLastChange)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in,unique]*/ IMoniker* /*pmkToLeft*/,
		/*[out]*/ FILETIME* /*pFileTime*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Inverse)(
		/*[out]*/ IMoniker** /*ppmk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CommonPrefixWith)(
		/*[in,unique]*/ IMoniker* /*pmkOther*/,
		/*[out]*/ IMoniker** /*ppmkPrefix*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RelativePathTo)(
		/*[in,unique]*/ IMoniker* /*pmkOther*/,
		/*[out]*/ IMoniker** /*ppmkRelPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayName)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in,unique]*/ IMoniker* /*pmkToLeft*/,
		/*[out]*/ LPOLESTR* /*ppszDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in,unique]*/ IMoniker* /*pmkToLeft*/,
		/*[in]*/ LPOLESTR /*pszDisplayName*/,
		/*[out]*/ ULONG* /*pchEaten*/,
		/*[out]*/ IMoniker** /*ppmkOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsSystemMoniker)(
		/*[out]*/ DWORD* /*pdwMksys*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in,unique]*/ IStream* /*pStm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in,unique]*/ IStream* /*pStm*/,
		/*[in]*/ BOOL /*fClearDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULARGE_INTEGER* /*pcbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IMonikerMockImpl :
	public IMoniker,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IMonikerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IMonikerMockImpl)

	typedef IMoniker Interface;
	struct BindToObjectValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in,unique]*/ IMoniker* pmkToLeft;
		/*[in]*/ REFIID riidResult;
		/*[out,iid_is(riidResult)]*/ void** ppvResult;
		HRESULT retValue;
	};

	STDMETHOD(BindToObject)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in,unique]*/ IMoniker* pmkToLeft,
		/*[in]*/ REFIID riidResult,
		/*[out,iid_is(riidResult)]*/ void** ppvResult)
	{
		VSL_DEFINE_MOCK_METHOD(BindToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkToLeft);

		VSL_CHECK_VALIDVALUE(riidResult);

		VSL_SET_VALIDVALUE(ppvResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct BindToStorageValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in,unique]*/ IMoniker* pmkToLeft;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(BindToStorage)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in,unique]*/ IMoniker* pmkToLeft,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(BindToStorage)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkToLeft);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReduceValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in]*/ DWORD dwReduceHowFar;
		/*[in,out,unique]*/ IMoniker** ppmkToLeft;
		/*[out]*/ IMoniker** ppmkReduced;
		HRESULT retValue;
	};

	STDMETHOD(Reduce)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in]*/ DWORD dwReduceHowFar,
		/*[in,out,unique]*/ IMoniker** ppmkToLeft,
		/*[out]*/ IMoniker** ppmkReduced)
	{
		VSL_DEFINE_MOCK_METHOD(Reduce)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE(dwReduceHowFar);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkToLeft);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkReduced);

		VSL_RETURN_VALIDVALUES();
	}
	struct ComposeWithValidValues
	{
		/*[in,unique]*/ IMoniker* pmkRight;
		/*[in]*/ BOOL fOnlyIfNotGeneric;
		/*[out]*/ IMoniker** ppmkComposite;
		HRESULT retValue;
	};

	STDMETHOD(ComposeWith)(
		/*[in,unique]*/ IMoniker* pmkRight,
		/*[in]*/ BOOL fOnlyIfNotGeneric,
		/*[out]*/ IMoniker** ppmkComposite)
	{
		VSL_DEFINE_MOCK_METHOD(ComposeWith)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkRight);

		VSL_CHECK_VALIDVALUE(fOnlyIfNotGeneric);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkComposite);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumValidValues
	{
		/*[in]*/ BOOL fForward;
		/*[out]*/ IEnumMoniker** ppenumMoniker;
		HRESULT retValue;
	};

	STDMETHOD(Enum)(
		/*[in]*/ BOOL fForward,
		/*[out]*/ IEnumMoniker** ppenumMoniker)
	{
		VSL_DEFINE_MOCK_METHOD(Enum)

		VSL_CHECK_VALIDVALUE(fForward);

		VSL_SET_VALIDVALUE_INTERFACE(ppenumMoniker);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in,unique]*/ IMoniker* pmkOtherMoniker;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in,unique]*/ IMoniker* pmkOtherMoniker)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkOtherMoniker);

		VSL_RETURN_VALIDVALUES();
	}
	struct HashValidValues
	{
		/*[out]*/ DWORD* pdwHash;
		HRESULT retValue;
	};

	STDMETHOD(Hash)(
		/*[out]*/ DWORD* pdwHash)
	{
		VSL_DEFINE_MOCK_METHOD(Hash)

		VSL_SET_VALIDVALUE(pdwHash);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsRunningValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in,unique]*/ IMoniker* pmkToLeft;
		/*[in,unique]*/ IMoniker* pmkNewlyRunning;
		HRESULT retValue;
	};

	STDMETHOD(IsRunning)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in,unique]*/ IMoniker* pmkToLeft,
		/*[in,unique]*/ IMoniker* pmkNewlyRunning)
	{
		VSL_DEFINE_MOCK_METHOD(IsRunning)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkToLeft);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkNewlyRunning);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTimeOfLastChangeValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in,unique]*/ IMoniker* pmkToLeft;
		/*[out]*/ FILETIME* pFileTime;
		HRESULT retValue;
	};

	STDMETHOD(GetTimeOfLastChange)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in,unique]*/ IMoniker* pmkToLeft,
		/*[out]*/ FILETIME* pFileTime)
	{
		VSL_DEFINE_MOCK_METHOD(GetTimeOfLastChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkToLeft);

		VSL_SET_VALIDVALUE(pFileTime);

		VSL_RETURN_VALIDVALUES();
	}
	struct InverseValidValues
	{
		/*[out]*/ IMoniker** ppmk;
		HRESULT retValue;
	};

	STDMETHOD(Inverse)(
		/*[out]*/ IMoniker** ppmk)
	{
		VSL_DEFINE_MOCK_METHOD(Inverse)

		VSL_SET_VALIDVALUE_INTERFACE(ppmk);

		VSL_RETURN_VALIDVALUES();
	}
	struct CommonPrefixWithValidValues
	{
		/*[in,unique]*/ IMoniker* pmkOther;
		/*[out]*/ IMoniker** ppmkPrefix;
		HRESULT retValue;
	};

	STDMETHOD(CommonPrefixWith)(
		/*[in,unique]*/ IMoniker* pmkOther,
		/*[out]*/ IMoniker** ppmkPrefix)
	{
		VSL_DEFINE_MOCK_METHOD(CommonPrefixWith)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkOther);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkPrefix);

		VSL_RETURN_VALIDVALUES();
	}
	struct RelativePathToValidValues
	{
		/*[in,unique]*/ IMoniker* pmkOther;
		/*[out]*/ IMoniker** ppmkRelPath;
		HRESULT retValue;
	};

	STDMETHOD(RelativePathTo)(
		/*[in,unique]*/ IMoniker* pmkOther,
		/*[out]*/ IMoniker** ppmkRelPath)
	{
		VSL_DEFINE_MOCK_METHOD(RelativePathTo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkOther);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkRelPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayNameValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in,unique]*/ IMoniker* pmkToLeft;
		/*[out]*/ LPOLESTR* ppszDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayName)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in,unique]*/ IMoniker* pmkToLeft,
		/*[out]*/ LPOLESTR* ppszDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayName)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkToLeft);

		VSL_SET_VALIDVALUE(ppszDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseDisplayNameValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in,unique]*/ IMoniker* pmkToLeft;
		/*[in]*/ LPOLESTR pszDisplayName;
		/*[out]*/ ULONG* pchEaten;
		/*[out]*/ IMoniker** ppmkOut;
		HRESULT retValue;
	};

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in,unique]*/ IMoniker* pmkToLeft,
		/*[in]*/ LPOLESTR pszDisplayName,
		/*[out]*/ ULONG* pchEaten,
		/*[out]*/ IMoniker** ppmkOut)
	{
		VSL_DEFINE_MOCK_METHOD(ParseDisplayName)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkToLeft);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDisplayName);

		VSL_SET_VALIDVALUE(pchEaten);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsSystemMonikerValidValues
	{
		/*[out]*/ DWORD* pdwMksys;
		HRESULT retValue;
	};

	STDMETHOD(IsSystemMoniker)(
		/*[out]*/ DWORD* pdwMksys)
	{
		VSL_DEFINE_MOCK_METHOD(IsSystemMoniker)

		VSL_SET_VALIDVALUE(pdwMksys);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in,unique]*/ IStream* pStm)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		/*[in]*/ BOOL fClearDirty;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in,unique]*/ IStream* pStm,
		/*[in]*/ BOOL fClearDirty)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeMaxValidValues
	{
		/*[out]*/ ULARGE_INTEGER* pcbSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULARGE_INTEGER* pcbSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeMax)

		VSL_SET_VALIDVALUE(pcbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMONIKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIObjectWithSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOBJECTWITHSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOBJECTWITHSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IObjectWithSiteNotImpl :
	public IObjectWithSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IObjectWithSiteNotImpl)

public:

	typedef IObjectWithSite Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IUnknown* /*pUnkSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSite)(
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvSite*/)VSL_STDMETHOD_NOTIMPL
};

class IObjectWithSiteMockImpl :
	public IObjectWithSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IObjectWithSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IObjectWithSiteMockImpl)

	typedef IObjectWithSite Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IUnknown* pUnkSite;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IUnknown* pUnkSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSiteValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvSite;
		HRESULT retValue;
	};

	STDMETHOD(GetSite)(
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvSite)
	{
		VSL_DEFINE_MOCK_METHOD(GetSite)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvSite);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOBJECTWITHSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockImports.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IMPORTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IMPORTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ImportsNotImpl :
	public Imports
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ImportsNotImpl)

public:

	typedef Imports Interface;

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Parent)(
		/*[out,retval]*/ IDispatch** /*ppdispParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* /*plCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Item)(
		/*[in]*/ long /*lIndex*/,
		/*[out,retval]*/ BSTR* /*pbstrImport*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ BSTR /*bstrImport*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Remove)(
		/*[in]*/ VARIANT /*index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(_NewEnum)(
		/*[out,retval]*/ IUnknown** /*ppiuReturn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ImportsMockImpl :
	public Imports,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ImportsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ImportsMockImpl)

	typedef Imports Interface;
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ParentValidValues
	{
		/*[out,retval]*/ IDispatch** ppdispParent;
		HRESULT retValue;
	};

	STDMETHOD(get_Parent)(
		/*[out,retval]*/ IDispatch** ppdispParent)
	{
		VSL_DEFINE_MOCK_METHOD(get_Parent)

		VSL_SET_VALIDVALUE_INTERFACE(ppdispParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CountValidValues
	{
		/*[out,retval]*/ long* plCount;
		HRESULT retValue;
	};

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* plCount)
	{
		VSL_DEFINE_MOCK_METHOD(get_Count)

		VSL_SET_VALIDVALUE(plCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct ItemValidValues
	{
		/*[in]*/ long lIndex;
		/*[out,retval]*/ BSTR* pbstrImport;
		HRESULT retValue;
	};

	STDMETHOD(Item)(
		/*[in]*/ long lIndex,
		/*[out,retval]*/ BSTR* pbstrImport)
	{
		VSL_DEFINE_MOCK_METHOD(Item)

		VSL_CHECK_VALIDVALUE(lIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrImport);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ BSTR bstrImport;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ BSTR bstrImport)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE_BSTR(bstrImport);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveValidValues
	{
		/*[in]*/ VARIANT index;
		HRESULT retValue;
	};

	STDMETHOD(Remove)(
		/*[in]*/ VARIANT index)
	{
		VSL_DEFINE_MOCK_METHOD(Remove)

		VSL_CHECK_VALIDVALUE(index);

		VSL_RETURN_VALIDVALUES();
	}
	struct _NewEnumValidValues
	{
		/*[out,retval]*/ IUnknown** ppiuReturn;
		HRESULT retValue;
	};

	STDMETHOD(_NewEnum)(
		/*[out,retval]*/ IUnknown** ppiuReturn)
	{
		VSL_DEFINE_MOCK_METHOD(_NewEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppiuReturn);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IMPORTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleAdviseHolder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEADVISEHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEADVISEHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleAdviseHolderNotImpl :
	public IOleAdviseHolder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleAdviseHolderNotImpl)

public:

	typedef IOleAdviseHolder Interface;

	STDMETHOD(Advise)(
		/*[in,unique]*/ IAdviseSink* /*pAdvise*/,
		/*[out]*/ DWORD* /*pdwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD /*dwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumAdvise)(
		/*[out]*/ IEnumSTATDATA** /*ppenumAdvise*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendOnRename)(
		/*[in,unique]*/ IMoniker* /*pmk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendOnSave)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendOnClose)()VSL_STDMETHOD_NOTIMPL
};

class IOleAdviseHolderMockImpl :
	public IOleAdviseHolder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleAdviseHolderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleAdviseHolderMockImpl)

	typedef IOleAdviseHolder Interface;
	struct AdviseValidValues
	{
		/*[in,unique]*/ IAdviseSink* pAdvise;
		/*[out]*/ DWORD* pdwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Advise)(
		/*[in,unique]*/ IAdviseSink* pAdvise,
		/*[out]*/ DWORD* pdwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Advise)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAdvise);

		VSL_SET_VALIDVALUE(pdwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseValidValues
	{
		/*[in]*/ DWORD dwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD dwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Unadvise)

		VSL_CHECK_VALIDVALUE(dwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumAdviseValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenumAdvise;
		HRESULT retValue;
	};

	STDMETHOD(EnumAdvise)(
		/*[out]*/ IEnumSTATDATA** ppenumAdvise)
	{
		VSL_DEFINE_MOCK_METHOD(EnumAdvise)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumAdvise);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendOnRenameValidValues
	{
		/*[in,unique]*/ IMoniker* pmk;
		HRESULT retValue;
	};

	STDMETHOD(SendOnRename)(
		/*[in,unique]*/ IMoniker* pmk)
	{
		VSL_DEFINE_MOCK_METHOD(SendOnRename)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendOnSaveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SendOnSave)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SendOnSave)

		VSL_RETURN_VALIDVALUES();
	}
	struct SendOnCloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SendOnClose)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SendOnClose)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEADVISEHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleCacheControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECACHECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECACHECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleCacheControlNotImpl :
	public IOleCacheControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCacheControlNotImpl)

public:

	typedef IOleCacheControl Interface;

	STDMETHOD(OnRun)(
		/*[in]*/ LPDATAOBJECT /*pDataObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnStop)()VSL_STDMETHOD_NOTIMPL
};

class IOleCacheControlMockImpl :
	public IOleCacheControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCacheControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleCacheControlMockImpl)

	typedef IOleCacheControl Interface;
	struct OnRunValidValues
	{
		/*[in]*/ LPDATAOBJECT pDataObject;
		HRESULT retValue;
	};

	STDMETHOD(OnRun)(
		/*[in]*/ LPDATAOBJECT pDataObject)
	{
		VSL_DEFINE_MOCK_METHOD(OnRun)

		VSL_CHECK_VALIDVALUE(pDataObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnStopValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnStop)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnStop)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECACHECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleCache2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECACHE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECACHE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleCache2NotImpl :
	public IOleCache2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCache2NotImpl)

public:

	typedef IOleCache2 Interface;

	STDMETHOD(UpdateCache)(
		/*[in]*/ LPDATAOBJECT /*pDataObject*/,
		/*[in]*/ DWORD /*grfUpdf*/,
		/*[in]*/ LPVOID /*pReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiscardCache)(
		/*[in]*/ DWORD /*dwDiscardOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Cache)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/,
		/*[in]*/ DWORD /*advf*/,
		/*[out]*/ DWORD* /*pdwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Uncache)(
		/*[in]*/ DWORD /*dwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCache)(
		/*[out]*/ IEnumSTATDATA** /*ppenumSTATDATA*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitCache)(
		/*[in,unique]*/ IDataObject* /*pDataObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetData)(
		/*[in,unique]*/ FORMATETC* /*pformatetc*/,
		/*[in,unique]*/ STGMEDIUM* /*pmedium*/,
		/*[in]*/ BOOL /*fRelease*/)VSL_STDMETHOD_NOTIMPL
};

class IOleCache2MockImpl :
	public IOleCache2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCache2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleCache2MockImpl)

	typedef IOleCache2 Interface;
	struct UpdateCacheValidValues
	{
		/*[in]*/ LPDATAOBJECT pDataObject;
		/*[in]*/ DWORD grfUpdf;
		/*[in]*/ LPVOID pReserved;
		HRESULT retValue;
		size_t pReserved_size_in_bytes;
	};

	STDMETHOD(UpdateCache)(
		/*[in]*/ LPDATAOBJECT pDataObject,
		/*[in]*/ DWORD grfUpdf,
		/*[in]*/ LPVOID pReserved)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCache)

		VSL_CHECK_VALIDVALUE(pDataObject);

		VSL_CHECK_VALIDVALUE(grfUpdf);

		VSL_CHECK_VALIDVALUE_PVOID(pReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiscardCacheValidValues
	{
		/*[in]*/ DWORD dwDiscardOptions;
		HRESULT retValue;
	};

	STDMETHOD(DiscardCache)(
		/*[in]*/ DWORD dwDiscardOptions)
	{
		VSL_DEFINE_MOCK_METHOD(DiscardCache)

		VSL_CHECK_VALIDVALUE(dwDiscardOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct CacheValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		/*[in]*/ DWORD advf;
		/*[out]*/ DWORD* pdwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Cache)(
		/*[in,unique]*/ FORMATETC* pformatetc,
		/*[in]*/ DWORD advf,
		/*[out]*/ DWORD* pdwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Cache)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_CHECK_VALIDVALUE(advf);

		VSL_SET_VALIDVALUE(pdwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct UncacheValidValues
	{
		/*[in]*/ DWORD dwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Uncache)(
		/*[in]*/ DWORD dwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Uncache)

		VSL_CHECK_VALIDVALUE(dwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCacheValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenumSTATDATA;
		HRESULT retValue;
	};

	STDMETHOD(EnumCache)(
		/*[out]*/ IEnumSTATDATA** ppenumSTATDATA)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCache)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumSTATDATA);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitCacheValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObject;
		HRESULT retValue;
	};

	STDMETHOD(InitCache)(
		/*[in,unique]*/ IDataObject* pDataObject)
	{
		VSL_DEFINE_MOCK_METHOD(InitCache)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDataValidValues
	{
		/*[in,unique]*/ FORMATETC* pformatetc;
		/*[in,unique]*/ STGMEDIUM* pmedium;
		/*[in]*/ BOOL fRelease;
		HRESULT retValue;
	};

	STDMETHOD(SetData)(
		/*[in,unique]*/ FORMATETC* pformatetc,
		/*[in,unique]*/ STGMEDIUM* pmedium,
		/*[in]*/ BOOL fRelease)
	{
		VSL_DEFINE_MOCK_METHOD(SetData)

		VSL_CHECK_VALIDVALUE_POINTER(pformatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pmedium);

		VSL_CHECK_VALIDVALUE(fRelease);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECACHE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleClientSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECLIENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECLIENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleClientSiteNotImpl :
	public IOleClientSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleClientSiteNotImpl)

public:

	typedef IOleClientSite Interface;

	STDMETHOD(SaveObject)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMoniker)(
		/*[in]*/ DWORD /*dwAssign*/,
		/*[in]*/ DWORD /*dwWhichMoniker*/,
		/*[out]*/ IMoniker** /*ppmk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContainer)(
		/*[out]*/ IOleContainer** /*ppContainer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowObject)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnShowWindow)(
		/*[in]*/ BOOL /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RequestNewObjectLayout)()VSL_STDMETHOD_NOTIMPL
};

class IOleClientSiteMockImpl :
	public IOleClientSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleClientSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleClientSiteMockImpl)

	typedef IOleClientSite Interface;
	struct SaveObjectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SaveObject)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SaveObject)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMonikerValidValues
	{
		/*[in]*/ DWORD dwAssign;
		/*[in]*/ DWORD dwWhichMoniker;
		/*[out]*/ IMoniker** ppmk;
		HRESULT retValue;
	};

	STDMETHOD(GetMoniker)(
		/*[in]*/ DWORD dwAssign,
		/*[in]*/ DWORD dwWhichMoniker,
		/*[out]*/ IMoniker** ppmk)
	{
		VSL_DEFINE_MOCK_METHOD(GetMoniker)

		VSL_CHECK_VALIDVALUE(dwAssign);

		VSL_CHECK_VALIDVALUE(dwWhichMoniker);

		VSL_SET_VALIDVALUE_INTERFACE(ppmk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContainerValidValues
	{
		/*[out]*/ IOleContainer** ppContainer;
		HRESULT retValue;
	};

	STDMETHOD(GetContainer)(
		/*[out]*/ IOleContainer** ppContainer)
	{
		VSL_DEFINE_MOCK_METHOD(GetContainer)

		VSL_SET_VALIDVALUE_INTERFACE(ppContainer);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowObjectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowObject)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowObject)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnShowWindowValidValues
	{
		/*[in]*/ BOOL fShow;
		HRESULT retValue;
	};

	STDMETHOD(OnShowWindow)(
		/*[in]*/ BOOL fShow)
	{
		VSL_DEFINE_MOCK_METHOD(OnShowWindow)

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct RequestNewObjectLayoutValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RequestNewObjectLayout)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RequestNewObjectLayout)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECLIENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleComponentUIManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECOMPONENTUIMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECOMPONENTUIMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "oleipc.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleComponentUIManagerNotImpl :
	public IOleComponentUIManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleComponentUIManagerNotImpl)

public:

	typedef IOleComponentUIManager Interface;

	STDMETHOD(Deleted1)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Deleted2)()VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE OnUIEvent(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidComp*/,
		/*[in]*/ const GUID* /*pguidUIEventGroup*/,
		/*[in]*/ DWORD /*nUIEventId*/,
		/*[in]*/ DWORD /*dwUIEventStatus*/,
		/*[in]*/ DWORD /*dwEventFreq*/,
		/*[in]*/ RECT* /*prcEventRegion*/,
		/*[in]*/ VARIANT* /*pvarEventArg*/){ return ; }

	STDMETHOD(OnUIEventProgress)(
		/*[in,out]*/ DWORD_PTR* /*pdwCookie*/,
		/*[in]*/ BOOL /*fInProgress*/,
		/*[in]*/ _In_ LPOLESTR /*pwszLabel*/,
		/*[in]*/ ULONG /*nComplete*/,
		/*[in]*/ ULONG /*nTotal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStatus)(
		/*[in]*/ LPCOLESTR /*pwszStatusText*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowContextMenu)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidActive*/,
		/*[in]*/ LONG /*nMenuId*/,
		/*[in]*/ REFPOINTS /*pos*/,
		/*[in]*/ IOleCommandTarget* /*pCmdTrgtActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowHelp)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidComp*/,
		/*[in]*/ POINT /*posMouse*/,
		/*[in]*/ DWORD /*dwHelpCmd*/,
		/*[in]*/ _In_ LPOLESTR /*pszHelpFile*/,
		/*[in]*/ DWORD /*dwData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowMessage)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidComp*/,
		/*[in]*/ _In_z_ LPOLESTR /*pszTitle*/,
		/*[in]*/ _In_z_ LPOLESTR /*pszText*/,
		/*[in]*/ _In_z_ LPOLESTR /*pszHelpFile*/,
		/*[in]*/ DWORD /*dwHelpContextID*/,
		/*[in]*/ OLEMSGBUTTON /*msgbtn*/,
		/*[in]*/ OLEMSGDEFBUTTON /*msgdefbtn*/,
		/*[in]*/ OLEMSGICON /*msgicon*/,
		/*[in]*/ BOOL /*fSysAlert*/,
		/*[out,retval]*/ LONG* /*pnResult*/)VSL_STDMETHOD_NOTIMPL
};

class IOleComponentUIManagerMockImpl :
	public IOleComponentUIManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleComponentUIManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleComponentUIManagerMockImpl)

	typedef IOleComponentUIManager Interface;
	struct Deleted1ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Deleted1)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Deleted1)

		VSL_RETURN_VALIDVALUES();
	}
	struct Deleted2ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Deleted2)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Deleted2)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIEventValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidComp;
		/*[in]*/ GUID* pguidUIEventGroup;
		/*[in]*/ DWORD nUIEventId;
		/*[in]*/ DWORD dwUIEventStatus;
		/*[in]*/ DWORD dwEventFreq;
		/*[in]*/ RECT* prcEventRegion;
		/*[in]*/ VARIANT* pvarEventArg;
	};

	virtual void _stdcall OnUIEvent(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidComp,
		/*[in]*/ const GUID* pguidUIEventGroup,
		/*[in]*/ DWORD nUIEventId,
		/*[in]*/ DWORD dwUIEventStatus,
		/*[in]*/ DWORD dwEventFreq,
		/*[in]*/ RECT* prcEventRegion,
		/*[in]*/ VARIANT* pvarEventArg)
	{
		VSL_DEFINE_MOCK_METHOD(OnUIEvent)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidComp);

		VSL_CHECK_VALIDVALUE_POINTER(pguidUIEventGroup);

		VSL_CHECK_VALIDVALUE(nUIEventId);

		VSL_CHECK_VALIDVALUE(dwUIEventStatus);

		VSL_CHECK_VALIDVALUE(dwEventFreq);

		VSL_CHECK_VALIDVALUE_POINTER(prcEventRegion);

		VSL_CHECK_VALIDVALUE_POINTER(pvarEventArg);

	}
	struct OnUIEventProgressValidValues
	{
		/*[in,out]*/ DWORD_PTR* pdwCookie;
		/*[in]*/ BOOL fInProgress;
		/*[in]*/ LPOLESTR pwszLabel;
		/*[in]*/ ULONG nComplete;
		/*[in]*/ ULONG nTotal;
		HRESULT retValue;
	};

	STDMETHOD(OnUIEventProgress)(
		/*[in,out]*/ DWORD_PTR* pdwCookie,
		/*[in]*/ BOOL fInProgress,
		/*[in]*/ _In_ LPOLESTR pwszLabel,
		/*[in]*/ ULONG nComplete,
		/*[in]*/ ULONG nTotal)
	{
		VSL_DEFINE_MOCK_METHOD(OnUIEventProgress)

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_CHECK_VALIDVALUE(fInProgress);

		VSL_CHECK_VALIDVALUE_STRINGW(pwszLabel);

		VSL_CHECK_VALIDVALUE(nComplete);

		VSL_CHECK_VALIDVALUE(nTotal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStatusValidValues
	{
		/*[in]*/ LPCOLESTR pwszStatusText;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(SetStatus)(
		/*[in]*/ LPCOLESTR pwszStatusText,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(SetStatus)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszStatusText);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowContextMenuValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidActive;
		/*[in]*/ LONG nMenuId;
		/*[in]*/ REFPOINTS pos;
		/*[in]*/ IOleCommandTarget* pCmdTrgtActive;
		HRESULT retValue;
	};

	STDMETHOD(ShowContextMenu)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidActive,
		/*[in]*/ LONG nMenuId,
		/*[in]*/ REFPOINTS pos,
		/*[in]*/ IOleCommandTarget* pCmdTrgtActive)
	{
		VSL_DEFINE_MOCK_METHOD(ShowContextMenu)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidActive);

		VSL_CHECK_VALIDVALUE(nMenuId);

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdTrgtActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowHelpValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidComp;
		/*[in]*/ POINT posMouse;
		/*[in]*/ DWORD dwHelpCmd;
		/*[in]*/ LPOLESTR pszHelpFile;
		/*[in]*/ DWORD dwData;
		HRESULT retValue;
	};

	STDMETHOD(ShowHelp)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidComp,
		/*[in]*/ POINT posMouse,
		/*[in]*/ DWORD dwHelpCmd,
		/*[in]*/ _In_ LPOLESTR pszHelpFile,
		/*[in]*/ DWORD dwData)
	{
		VSL_DEFINE_MOCK_METHOD(ShowHelp)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidComp);

		VSL_CHECK_VALIDVALUE(posMouse);

		VSL_CHECK_VALIDVALUE(dwHelpCmd);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpFile);

		VSL_CHECK_VALIDVALUE(dwData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowMessageValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidComp;
		/*[in]*/ LPOLESTR pszTitle;
		/*[in]*/ LPOLESTR pszText;
		/*[in]*/ LPOLESTR pszHelpFile;
		/*[in]*/ DWORD dwHelpContextID;
		/*[in]*/ OLEMSGBUTTON msgbtn;
		/*[in]*/ OLEMSGDEFBUTTON msgdefbtn;
		/*[in]*/ OLEMSGICON msgicon;
		/*[in]*/ BOOL fSysAlert;
		/*[out,retval]*/ LONG* pnResult;
		HRESULT retValue;
	};

	STDMETHOD(ShowMessage)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidComp,
		/*[in]*/ _In_z_ LPOLESTR pszTitle,
		/*[in]*/ _In_z_ LPOLESTR pszText,
		/*[in]*/ _In_z_ LPOLESTR pszHelpFile,
		/*[in]*/ DWORD dwHelpContextID,
		/*[in]*/ OLEMSGBUTTON msgbtn,
		/*[in]*/ OLEMSGDEFBUTTON msgdefbtn,
		/*[in]*/ OLEMSGICON msgicon,
		/*[in]*/ BOOL fSysAlert,
		/*[out,retval]*/ LONG* pnResult)
	{
		VSL_DEFINE_MOCK_METHOD(ShowMessage)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidComp);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpFile);

		VSL_CHECK_VALIDVALUE(dwHelpContextID);

		VSL_CHECK_VALIDVALUE(msgbtn);

		VSL_CHECK_VALIDVALUE(msgdefbtn);

		VSL_CHECK_VALIDVALUE(msgicon);

		VSL_CHECK_VALIDVALUE(fSysAlert);

		VSL_SET_VALIDVALUE(pnResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECOMPONENTUIMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleContainerNotImpl :
	public IOleContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleContainerNotImpl)

public:

	typedef IOleContainer Interface;

	STDMETHOD(EnumObjects)(
		/*[in]*/ DWORD /*grfFlags*/,
		/*[out]*/ IEnumUnknown** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockContainer)(
		/*[in]*/ BOOL /*fLock*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in]*/ LPOLESTR /*pszDisplayName*/,
		/*[out]*/ ULONG* /*pchEaten*/,
		/*[out]*/ IMoniker** /*ppmkOut*/)VSL_STDMETHOD_NOTIMPL
};

class IOleContainerMockImpl :
	public IOleContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleContainerMockImpl)

	typedef IOleContainer Interface;
	struct EnumObjectsValidValues
	{
		/*[in]*/ DWORD grfFlags;
		/*[out]*/ IEnumUnknown** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumObjects)(
		/*[in]*/ DWORD grfFlags,
		/*[out]*/ IEnumUnknown** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumObjects)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockContainerValidValues
	{
		/*[in]*/ BOOL fLock;
		HRESULT retValue;
	};

	STDMETHOD(LockContainer)(
		/*[in]*/ BOOL fLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockContainer)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseDisplayNameValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in]*/ LPOLESTR pszDisplayName;
		/*[out]*/ ULONG* pchEaten;
		/*[out]*/ IMoniker** ppmkOut;
		HRESULT retValue;
	};

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in]*/ LPOLESTR pszDisplayName,
		/*[out]*/ ULONG* pchEaten,
		/*[out]*/ IMoniker** ppmkOut)
	{
		VSL_DEFINE_MOCK_METHOD(ParseDisplayName)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDisplayName);

		VSL_SET_VALIDVALUE(pchEaten);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleCommandTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECOMMANDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECOMMANDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleCommandTargetNotImpl :
	public IOleCommandTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCommandTargetNotImpl)

public:

	typedef IOleCommandTarget Interface;

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ ULONG /*cCmds*/,
		/*[size_is(cCmds),in,out]*/ OLECMD[] /*prgCmds*/,
		/*[in,out,unique]*/ OLECMDTEXT* /*pCmdText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[in,unique]*/ VARIANT* /*pvaIn*/,
		/*[in,out,unique]*/ VARIANT* /*pvaOut*/)VSL_STDMETHOD_NOTIMPL
};

class IOleCommandTargetMockImpl :
	public IOleCommandTarget,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCommandTargetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleCommandTargetMockImpl)

	typedef IOleCommandTarget Interface;
	struct QueryStatusValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ ULONG cCmds;
		/*[size_is(cCmds),in,out]*/ OLECMD* prgCmds;
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ ULONG cCmds,
		/*[size_is(cCmds),in,out]*/ OLECMD prgCmds[],
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatus)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(cCmds);

		VSL_SET_VALIDVALUE_MEMCPY(prgCmds, cCmds*sizeof(prgCmds[0]), validValues.cCmds*sizeof(validValues.prgCmds[0]));

		VSL_SET_VALIDVALUE(pCmdText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[in,unique]*/ VARIANT* pvaIn;
		/*[in,out,unique]*/ VARIANT* pvaOut;
		HRESULT retValue;
	};

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[in,unique]*/ VARIANT* pvaIn,
		/*[in,out,unique]*/ VARIANT* pvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(Exec)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_SET_VALIDVALUE_VARIANT(pvaOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECOMMANDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleComponentManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECOMPONENTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECOMPONENTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "olecm.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleComponentManagerNotImpl :
	public IOleComponentManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleComponentManagerNotImpl)

public:

	typedef IOleComponentManager Interface;

	STDMETHOD(QueryService)(
		/*[in]*/ REFGUID /*guidService*/,
		/*[in]*/ REFIID /*iid*/,
		/*[out]*/ void** /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	virtual BOOL STDMETHODCALLTYPE FReserved1(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ UINT /*message*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FRegisterComponent(
		/*[in]*/ IOleComponent* /*piComponent*/,
		/*[in]*/ const OLECRINFO* /*pcrinfo*/,
		/*[out]*/ DWORD_PTR* /*pdwComponentID*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FRevokeComponent(
		/*[in]*/ DWORD_PTR /*dwComponentID*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FUpdateComponentRegistration(
		/*[in]*/ DWORD_PTR /*dwComponentID*/,
		/*[in]*/ const OLECRINFO* /*pcrinfo*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FOnComponentActivate(
		/*[in]*/ DWORD_PTR /*dwComponentID*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FSetTrackingComponent(
		/*[in]*/ DWORD_PTR /*dwComponentID*/,
		/*[in]*/ BOOL /*fTrack*/){ return BOOL(); }

	virtual void STDMETHODCALLTYPE OnComponentEnterState(
		/*[in]*/ DWORD_PTR /*dwComponentID*/,
		/*[in]*/ OLECSTATE /*uStateID*/,
		/*[in]*/ OLECCONTEXT /*uContext*/,
		/*[in]*/ ULONG /*cpicmExclude*/,
		/*[in]*/ IOleComponentManager** /*rgpicmExclude*/,
		/*[in]*/ DWORD /*dwReserved*/){ return ; }

	virtual BOOL STDMETHODCALLTYPE FOnComponentExitState(
		/*[in]*/ DWORD_PTR /*dwComponentID*/,
		/*[in]*/ OLECSTATE /*uStateID*/,
		/*[in]*/ OLECCONTEXT /*uContext*/,
		/*[in]*/ ULONG /*cpicmExclude*/,
		/*[in]*/ IOleComponentManager** /*rgpicmExclude*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FInState(
		/*[in]*/ OLECSTATE /*uStateID*/,
		/*[in]*/ void* /*pvoid*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FContinueIdle(){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FPushMessageLoop(
		/*[in]*/ DWORD_PTR /*dwComponentID*/,
		/*[in]*/ OLELOOP /*uReason*/,
		/*[in]*/ void* /*pvLoopData*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FCreateSubComponentManager(
		/*[in]*/ IUnknown* /*piunkOuter*/,
		/*[in]*/ IUnknown* /*piunkServProv*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppvObj*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FGetParentComponentManager(
		/*[out]*/ IOleComponentManager** /*ppicm*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FGetActiveComponent(
		/*[in]*/ OLEGAC /*dwgac*/,
		/*[out]*/ IOleComponent** /*ppic*/,
		/*[in,out]*/ OLECRINFO* /*pcrinfo*/,
		/*[in]*/ DWORD /*dwReserved*/){ return BOOL(); }
};

class IOleComponentManagerMockImpl :
	public IOleComponentManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleComponentManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleComponentManagerMockImpl)

	typedef IOleComponentManager Interface;
	struct QueryServiceValidValues
	{
		/*[in]*/ REFGUID guidService;
		/*[in]*/ REFIID iid;
		/*[out]*/ void** ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(QueryService)(
		/*[in]*/ REFGUID guidService,
		/*[in]*/ REFIID iid,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(QueryService)

		VSL_CHECK_VALIDVALUE(guidService);

		VSL_CHECK_VALIDVALUE(iid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct FReserved1ValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ UINT message;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		BOOL retValue;
	};

	virtual BOOL _stdcall FReserved1(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ UINT message,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(FReserved1)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(message);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct FRegisterComponentValidValues
	{
		/*[in]*/ IOleComponent* piComponent;
		/*[in]*/ OLECRINFO* pcrinfo;
		/*[out]*/ DWORD_PTR* pdwComponentID;
		BOOL retValue;
	};

	virtual BOOL _stdcall FRegisterComponent(
		/*[in]*/ IOleComponent* piComponent,
		/*[in]*/ const OLECRINFO* pcrinfo,
		/*[out]*/ DWORD_PTR* pdwComponentID)
	{
		VSL_DEFINE_MOCK_METHOD(FRegisterComponent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(piComponent);

		VSL_CHECK_VALIDVALUE_POINTER(pcrinfo);

		VSL_SET_VALIDVALUE(pdwComponentID);

		VSL_RETURN_VALIDVALUES();
	}
	struct FRevokeComponentValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		BOOL retValue;
	};

	virtual BOOL _stdcall FRevokeComponent(
		/*[in]*/ DWORD_PTR dwComponentID)
	{
		VSL_DEFINE_MOCK_METHOD(FRevokeComponent)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_RETURN_VALIDVALUES();
	}
	struct FUpdateComponentRegistrationValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		/*[in]*/ OLECRINFO* pcrinfo;
		BOOL retValue;
	};

	virtual BOOL _stdcall FUpdateComponentRegistration(
		/*[in]*/ DWORD_PTR dwComponentID,
		/*[in]*/ const OLECRINFO* pcrinfo)
	{
		VSL_DEFINE_MOCK_METHOD(FUpdateComponentRegistration)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_CHECK_VALIDVALUE_POINTER(pcrinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct FOnComponentActivateValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		BOOL retValue;
	};

	virtual BOOL _stdcall FOnComponentActivate(
		/*[in]*/ DWORD_PTR dwComponentID)
	{
		VSL_DEFINE_MOCK_METHOD(FOnComponentActivate)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_RETURN_VALIDVALUES();
	}
	struct FSetTrackingComponentValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		/*[in]*/ BOOL fTrack;
		BOOL retValue;
	};

	virtual BOOL _stdcall FSetTrackingComponent(
		/*[in]*/ DWORD_PTR dwComponentID,
		/*[in]*/ BOOL fTrack)
	{
		VSL_DEFINE_MOCK_METHOD(FSetTrackingComponent)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_CHECK_VALIDVALUE(fTrack);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnComponentEnterStateValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		/*[in]*/ OLECSTATE uStateID;
		/*[in]*/ OLECCONTEXT uContext;
		/*[in]*/ ULONG cpicmExclude;
		/*[in]*/ IOleComponentManager** rgpicmExclude;
		/*[in]*/ DWORD dwReserved;
	};

	virtual void _stdcall OnComponentEnterState(
		/*[in]*/ DWORD_PTR dwComponentID,
		/*[in]*/ OLECSTATE uStateID,
		/*[in]*/ OLECCONTEXT uContext,
		/*[in]*/ ULONG cpicmExclude,
		/*[in]*/ IOleComponentManager** rgpicmExclude,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnComponentEnterState)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_CHECK_VALIDVALUE(uStateID);

		VSL_CHECK_VALIDVALUE(uContext);

		VSL_CHECK_VALIDVALUE(cpicmExclude);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(rgpicmExclude);

		VSL_CHECK_VALIDVALUE(dwReserved);

	}
	struct FOnComponentExitStateValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		/*[in]*/ OLECSTATE uStateID;
		/*[in]*/ OLECCONTEXT uContext;
		/*[in]*/ ULONG cpicmExclude;
		/*[in]*/ IOleComponentManager** rgpicmExclude;
		BOOL retValue;
	};

	virtual BOOL _stdcall FOnComponentExitState(
		/*[in]*/ DWORD_PTR dwComponentID,
		/*[in]*/ OLECSTATE uStateID,
		/*[in]*/ OLECCONTEXT uContext,
		/*[in]*/ ULONG cpicmExclude,
		/*[in]*/ IOleComponentManager** rgpicmExclude)
	{
		VSL_DEFINE_MOCK_METHOD(FOnComponentExitState)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_CHECK_VALIDVALUE(uStateID);

		VSL_CHECK_VALIDVALUE(uContext);

		VSL_CHECK_VALIDVALUE(cpicmExclude);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(rgpicmExclude);

		VSL_RETURN_VALIDVALUES();
	}
	struct FInStateValidValues
	{
		/*[in]*/ OLECSTATE uStateID;
		/*[in]*/ void* pvoid;
		BOOL retValue;
		size_t pvoid_size_in_bytes;
	};

	virtual BOOL _stdcall FInState(
		/*[in]*/ OLECSTATE uStateID,
		/*[in]*/ void* pvoid)
	{
		VSL_DEFINE_MOCK_METHOD(FInState)

		VSL_CHECK_VALIDVALUE(uStateID);

		VSL_CHECK_VALIDVALUE_PVOID(pvoid);

		VSL_RETURN_VALIDVALUES();
	}
	struct FContinueIdleValidValues
	{
		BOOL retValue;
	};

	virtual BOOL _stdcall FContinueIdle()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FContinueIdle)

		VSL_RETURN_VALIDVALUES();
	}
	struct FPushMessageLoopValidValues
	{
		/*[in]*/ DWORD_PTR dwComponentID;
		/*[in]*/ OLELOOP uReason;
		/*[in]*/ void* pvLoopData;
		BOOL retValue;
		size_t pvLoopData_size_in_bytes;
	};

	virtual BOOL _stdcall FPushMessageLoop(
		/*[in]*/ DWORD_PTR dwComponentID,
		/*[in]*/ OLELOOP uReason,
		/*[in]*/ void* pvLoopData)
	{
		VSL_DEFINE_MOCK_METHOD(FPushMessageLoop)

		VSL_CHECK_VALIDVALUE(dwComponentID);

		VSL_CHECK_VALIDVALUE(uReason);

		VSL_CHECK_VALIDVALUE_PVOID(pvLoopData);

		VSL_RETURN_VALIDVALUES();
	}
	struct FCreateSubComponentManagerValidValues
	{
		/*[in]*/ IUnknown* piunkOuter;
		/*[in]*/ IUnknown* piunkServProv;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppvObj;
		BOOL retValue;
	};

	virtual BOOL _stdcall FCreateSubComponentManager(
		/*[in]*/ IUnknown* piunkOuter,
		/*[in]*/ IUnknown* piunkServProv,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(FCreateSubComponentManager)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(piunkOuter);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(piunkServProv);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct FGetParentComponentManagerValidValues
	{
		/*[out]*/ IOleComponentManager** ppicm;
		BOOL retValue;
	};

	virtual BOOL _stdcall FGetParentComponentManager(
		/*[out]*/ IOleComponentManager** ppicm)
	{
		VSL_DEFINE_MOCK_METHOD(FGetParentComponentManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppicm);

		VSL_RETURN_VALIDVALUES();
	}
	struct FGetActiveComponentValidValues
	{
		/*[in]*/ OLEGAC dwgac;
		/*[out]*/ IOleComponent** ppic;
		/*[in,out]*/ OLECRINFO* pcrinfo;
		/*[in]*/ DWORD dwReserved;
		BOOL retValue;
	};

	virtual BOOL _stdcall FGetActiveComponent(
		/*[in]*/ OLEGAC dwgac,
		/*[out]*/ IOleComponent** ppic,
		/*[in,out]*/ OLECRINFO* pcrinfo,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(FGetActiveComponent)

		VSL_CHECK_VALIDVALUE(dwgac);

		VSL_SET_VALIDVALUE_INTERFACE(ppic);

		VSL_SET_VALIDVALUE(pcrinfo);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECOMPONENTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleComponent.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECOMPONENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECOMPONENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "olecm.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleComponentNotImpl :
	public IOleComponent
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleComponentNotImpl)

public:

	typedef IOleComponent Interface;

	virtual BOOL STDMETHODCALLTYPE FReserved1(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ UINT /*message*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FPreTranslateMessage(
		/*[in,out]*/ MSG* /*pMsg*/){ return BOOL(); }

	virtual void STDMETHODCALLTYPE OnEnterState(
		/*[in]*/ OLECSTATE /*uStateID*/,
		/*[in]*/ BOOL /*fEnter*/){ return ; }

	virtual void STDMETHODCALLTYPE OnAppActivate(
		/*[in]*/ BOOL /*fActive*/,
		/*[in]*/ DWORD /*dwOtherThreadID*/){ return ; }

	virtual void STDMETHODCALLTYPE OnLoseActivation(){ return ; }

	virtual void STDMETHODCALLTYPE OnActivationChange(
		/*[in]*/ IOleComponent* /*pic*/,
		/*[in]*/ BOOL /*fSameComponent*/,
		/*[in]*/ const OLECRINFO* /*pcrinfo*/,
		/*[in]*/ BOOL /*fHostIsActivating*/,
		/*[in]*/ const OLECHOSTINFO* /*pchostinfo*/,
		/*[in]*/ DWORD /*dwReserved*/){ return ; }

	virtual BOOL STDMETHODCALLTYPE FDoIdle(
		/*[in]*/ OLEIDLEF /*grfidlef*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FContinueMessageLoop(
		/*[in]*/ OLELOOP /*uReason*/,
		/*[in]*/ void* /*pvLoopData*/,
		/*[in]*/ MSG* /*pMsgPeeked*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FQueryTerminate(
		/*[in]*/ BOOL /*fPromptUser*/){ return BOOL(); }

	virtual void STDMETHODCALLTYPE Terminate(){ return ; }

	virtual HWND STDMETHODCALLTYPE HwndGetWindow(
		/*[in]*/ OLECWINDOW /*dwWhich*/,
		/*[in]*/ DWORD /*dwReserved*/){ return HWND(); }
};

class IOleComponentMockImpl :
	public IOleComponent,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleComponentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleComponentMockImpl)

	typedef IOleComponent Interface;
	struct FReserved1ValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ UINT message;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		BOOL retValue;
	};

	virtual BOOL _stdcall FReserved1(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ UINT message,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(FReserved1)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(message);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct FPreTranslateMessageValidValues
	{
		/*[in,out]*/ MSG* pMsg;
		BOOL retValue;
	};

	virtual BOOL _stdcall FPreTranslateMessage(
		/*[in,out]*/ MSG* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(FPreTranslateMessage)

		VSL_SET_VALIDVALUE(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEnterStateValidValues
	{
		/*[in]*/ OLECSTATE uStateID;
		/*[in]*/ BOOL fEnter;
	};

	virtual void _stdcall OnEnterState(
		/*[in]*/ OLECSTATE uStateID,
		/*[in]*/ BOOL fEnter)
	{
		VSL_DEFINE_MOCK_METHOD(OnEnterState)

		VSL_CHECK_VALIDVALUE(uStateID);

		VSL_CHECK_VALIDVALUE(fEnter);

	}
	struct OnAppActivateValidValues
	{
		/*[in]*/ BOOL fActive;
		/*[in]*/ DWORD dwOtherThreadID;
	};

	virtual void _stdcall OnAppActivate(
		/*[in]*/ BOOL fActive,
		/*[in]*/ DWORD dwOtherThreadID)
	{
		VSL_DEFINE_MOCK_METHOD(OnAppActivate)

		VSL_CHECK_VALIDVALUE(fActive);

		VSL_CHECK_VALIDVALUE(dwOtherThreadID);

	}

	virtual void _stdcall OnLoseActivation()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnLoseActivation)

	}
	struct OnActivationChangeValidValues
	{
		/*[in]*/ IOleComponent* pic;
		/*[in]*/ BOOL fSameComponent;
		/*[in]*/ OLECRINFO* pcrinfo;
		/*[in]*/ BOOL fHostIsActivating;
		/*[in]*/ OLECHOSTINFO* pchostinfo;
		/*[in]*/ DWORD dwReserved;
	};

	virtual void _stdcall OnActivationChange(
		/*[in]*/ IOleComponent* pic,
		/*[in]*/ BOOL fSameComponent,
		/*[in]*/ const OLECRINFO* pcrinfo,
		/*[in]*/ BOOL fHostIsActivating,
		/*[in]*/ const OLECHOSTINFO* pchostinfo,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnActivationChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pic);

		VSL_CHECK_VALIDVALUE(fSameComponent);

		VSL_CHECK_VALIDVALUE_POINTER(pcrinfo);

		VSL_CHECK_VALIDVALUE(fHostIsActivating);

		VSL_CHECK_VALIDVALUE_POINTER(pchostinfo);

		VSL_CHECK_VALIDVALUE(dwReserved);

	}
	struct FDoIdleValidValues
	{
		/*[in]*/ OLEIDLEF grfidlef;
		BOOL retValue;
	};

	virtual BOOL _stdcall FDoIdle(
		/*[in]*/ OLEIDLEF grfidlef)
	{
		VSL_DEFINE_MOCK_METHOD(FDoIdle)

		VSL_CHECK_VALIDVALUE(grfidlef);

		VSL_RETURN_VALIDVALUES();
	}
	struct FContinueMessageLoopValidValues
	{
		/*[in]*/ OLELOOP uReason;
		/*[in]*/ void* pvLoopData;
		/*[in]*/ MSG* pMsgPeeked;
		BOOL retValue;
		size_t pvLoopData_size_in_bytes;
	};

	virtual BOOL _stdcall FContinueMessageLoop(
		/*[in]*/ OLELOOP uReason,
		/*[in]*/ void* pvLoopData,
		/*[in]*/ MSG* pMsgPeeked)
	{
		VSL_DEFINE_MOCK_METHOD(FContinueMessageLoop)

		VSL_CHECK_VALIDVALUE(uReason);

		VSL_CHECK_VALIDVALUE_PVOID(pvLoopData);

		VSL_CHECK_VALIDVALUE_POINTER(pMsgPeeked);

		VSL_RETURN_VALIDVALUES();
	}
	struct FQueryTerminateValidValues
	{
		/*[in]*/ BOOL fPromptUser;
		BOOL retValue;
	};

	virtual BOOL _stdcall FQueryTerminate(
		/*[in]*/ BOOL fPromptUser)
	{
		VSL_DEFINE_MOCK_METHOD(FQueryTerminate)

		VSL_CHECK_VALIDVALUE(fPromptUser);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall Terminate()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Terminate)

	}
	struct HwndGetWindowValidValues
	{
		/*[in]*/ OLECWINDOW dwWhich;
		/*[in]*/ DWORD dwReserved;
		HWND retValue;
	};

	virtual HWND _stdcall HwndGetWindow(
		/*[in]*/ OLECWINDOW dwWhich,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(HwndGetWindow)

		VSL_CHECK_VALIDVALUE(dwWhich);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECOMPONENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleDocument.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleDocumentNotImpl :
	public IOleDocument
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleDocumentNotImpl)

public:

	typedef IOleDocument Interface;

	STDMETHOD(CreateView)(
		/*[in,unique]*/ IOleInPlaceSite* /*pIPSite*/,
		/*[in,unique]*/ IStream* /*pstm*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[out]*/ IOleDocumentView** /*ppView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocMiscStatus)(
		/*[out]*/ DWORD* /*pdwStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumViews)(
		/*[out]*/ IEnumOleDocumentViews** /*ppEnum*/,
		/*[out]*/ IOleDocumentView** /*ppView*/)VSL_STDMETHOD_NOTIMPL
};

class IOleDocumentMockImpl :
	public IOleDocument,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleDocumentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleDocumentMockImpl)

	typedef IOleDocument Interface;
	struct CreateViewValidValues
	{
		/*[in,unique]*/ IOleInPlaceSite* pIPSite;
		/*[in,unique]*/ IStream* pstm;
		/*[in]*/ DWORD dwReserved;
		/*[out]*/ IOleDocumentView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(CreateView)(
		/*[in,unique]*/ IOleInPlaceSite* pIPSite,
		/*[in,unique]*/ IStream* pstm,
		/*[in]*/ DWORD dwReserved,
		/*[out]*/ IOleDocumentView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(CreateView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIPSite);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstm);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocMiscStatusValidValues
	{
		/*[out]*/ DWORD* pdwStatus;
		HRESULT retValue;
	};

	STDMETHOD(GetDocMiscStatus)(
		/*[out]*/ DWORD* pdwStatus)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocMiscStatus)

		VSL_SET_VALIDVALUE(pdwStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumViewsValidValues
	{
		/*[out]*/ IEnumOleDocumentViews** ppEnum;
		/*[out]*/ IOleDocumentView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(EnumViews)(
		/*[out]*/ IEnumOleDocumentViews** ppEnum,
		/*[out]*/ IOleDocumentView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(EnumViews)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleControlNotImpl :
	public IOleControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleControlNotImpl)

public:

	typedef IOleControl Interface;

	STDMETHOD(GetControlInfo)(
		/*[out]*/ CONTROLINFO* /*pCI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnMnemonic)(
		/*[in]*/ MSG* /*pMsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAmbientPropertyChange)(
		/*[in]*/ DISPID /*dispID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreezeEvents)(
		/*[in]*/ BOOL /*bFreeze*/)VSL_STDMETHOD_NOTIMPL
};

class IOleControlMockImpl :
	public IOleControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleControlMockImpl)

	typedef IOleControl Interface;
	struct GetControlInfoValidValues
	{
		/*[out]*/ CONTROLINFO* pCI;
		HRESULT retValue;
	};

	STDMETHOD(GetControlInfo)(
		/*[out]*/ CONTROLINFO* pCI)
	{
		VSL_DEFINE_MOCK_METHOD(GetControlInfo)

		VSL_SET_VALIDVALUE(pCI);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnMnemonicValidValues
	{
		/*[in]*/ MSG* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(OnMnemonic)(
		/*[in]*/ MSG* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(OnMnemonic)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAmbientPropertyChangeValidValues
	{
		/*[in]*/ DISPID dispID;
		HRESULT retValue;
	};

	STDMETHOD(OnAmbientPropertyChange)(
		/*[in]*/ DISPID dispID)
	{
		VSL_DEFINE_MOCK_METHOD(OnAmbientPropertyChange)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreezeEventsValidValues
	{
		/*[in]*/ BOOL bFreeze;
		HRESULT retValue;
	};

	STDMETHOD(FreezeEvents)(
		/*[in]*/ BOOL bFreeze)
	{
		VSL_DEFINE_MOCK_METHOD(FreezeEvents)

		VSL_CHECK_VALIDVALUE(bFreeze);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleDocumentSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEDOCUMENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEDOCUMENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleDocumentSiteNotImpl :
	public IOleDocumentSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleDocumentSiteNotImpl)

public:

	typedef IOleDocumentSite Interface;

	STDMETHOD(ActivateMe)(
		/*[in]*/ IOleDocumentView* /*pViewToActivate*/)VSL_STDMETHOD_NOTIMPL
};

class IOleDocumentSiteMockImpl :
	public IOleDocumentSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleDocumentSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleDocumentSiteMockImpl)

	typedef IOleDocumentSite Interface;
	struct ActivateMeValidValues
	{
		/*[in]*/ IOleDocumentView* pViewToActivate;
		HRESULT retValue;
	};

	STDMETHOD(ActivateMe)(
		/*[in]*/ IOleDocumentView* pViewToActivate)
	{
		VSL_DEFINE_MOCK_METHOD(ActivateMe)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pViewToActivate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEDOCUMENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleControlSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLECONTROLSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLECONTROLSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleControlSiteNotImpl :
	public IOleControlSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleControlSiteNotImpl)

public:

	typedef IOleControlSite Interface;

	STDMETHOD(OnControlInfoChanged)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockInPlaceActive)(
		/*[in]*/ BOOL /*fLock*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedControl)(
		/*[out]*/ IDispatch** /*ppDisp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TransformCoords)(
		/*[in,out]*/ POINTL* /*pPtlHimetric*/,
		/*[in,out]*/ POINTF* /*pPtfContainer*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* /*pMsg*/,
		/*[in]*/ DWORD /*grfModifiers*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnFocus)(
		/*[in]*/ BOOL /*fGotFocus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowPropertyFrame)()VSL_STDMETHOD_NOTIMPL
};

class IOleControlSiteMockImpl :
	public IOleControlSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleControlSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleControlSiteMockImpl)

	typedef IOleControlSite Interface;
	struct OnControlInfoChangedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnControlInfoChanged)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnControlInfoChanged)

		VSL_RETURN_VALIDVALUES();
	}
	struct LockInPlaceActiveValidValues
	{
		/*[in]*/ BOOL fLock;
		HRESULT retValue;
	};

	STDMETHOD(LockInPlaceActive)(
		/*[in]*/ BOOL fLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockInPlaceActive)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedControlValidValues
	{
		/*[out]*/ IDispatch** ppDisp;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedControl)(
		/*[out]*/ IDispatch** ppDisp)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedControl)

		VSL_SET_VALIDVALUE_INTERFACE(ppDisp);

		VSL_RETURN_VALIDVALUES();
	}
	struct TransformCoordsValidValues
	{
		/*[in,out]*/ POINTL* pPtlHimetric;
		/*[in,out]*/ POINTF* pPtfContainer;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(TransformCoords)(
		/*[in,out]*/ POINTL* pPtlHimetric,
		/*[in,out]*/ POINTF* pPtfContainer,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(TransformCoords)

		VSL_SET_VALIDVALUE(pPtlHimetric);

		VSL_SET_VALIDVALUE(pPtfContainer);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ MSG* pMsg;
		/*[in]*/ DWORD grfModifiers;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* pMsg,
		/*[in]*/ DWORD grfModifiers)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_CHECK_VALIDVALUE(grfModifiers);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnFocusValidValues
	{
		/*[in]*/ BOOL fGotFocus;
		HRESULT retValue;
	};

	STDMETHOD(OnFocus)(
		/*[in]*/ BOOL fGotFocus)
	{
		VSL_DEFINE_MOCK_METHOD(OnFocus)

		VSL_CHECK_VALIDVALUE(fGotFocus);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowPropertyFrameValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowPropertyFrame)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowPropertyFrame)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLECONTROLSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleDocumentView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEDOCUMENTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEDOCUMENTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleDocumentViewNotImpl :
	public IOleDocumentView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleDocumentViewNotImpl)

public:

	typedef IOleDocumentView Interface;

	STDMETHOD(SetInPlaceSite)(
		/*[in,unique]*/ IOleInPlaceSite* /*pIPSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInPlaceSite)(
		/*[out]*/ IOleInPlaceSite** /*ppIPSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocument)(
		/*[out]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRect)(
		/*[in]*/ LPRECT /*prcView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRect)(
		/*[out]*/ LPRECT /*prcView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRectComplex)(
		/*[in,unique]*/ LPRECT /*prcView*/,
		/*[in,unique]*/ LPRECT /*prcHScroll*/,
		/*[in,unique]*/ LPRECT /*prcVScroll*/,
		/*[in,unique]*/ LPRECT /*prcSizeBox*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Show)(
		/*[in]*/ BOOL /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UIActivate)(
		/*[in]*/ BOOL /*fUIActivate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Open)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseView)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveViewState)(
		/*[in]*/ LPSTREAM /*pstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ApplyViewState)(
		/*[in]*/ LPSTREAM /*pstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[in]*/ IOleInPlaceSite* /*pIPSiteNew*/,
		/*[out]*/ IOleDocumentView** /*ppViewNew*/)VSL_STDMETHOD_NOTIMPL
};

class IOleDocumentViewMockImpl :
	public IOleDocumentView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleDocumentViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleDocumentViewMockImpl)

	typedef IOleDocumentView Interface;
	struct SetInPlaceSiteValidValues
	{
		/*[in,unique]*/ IOleInPlaceSite* pIPSite;
		HRESULT retValue;
	};

	STDMETHOD(SetInPlaceSite)(
		/*[in,unique]*/ IOleInPlaceSite* pIPSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetInPlaceSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIPSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInPlaceSiteValidValues
	{
		/*[out]*/ IOleInPlaceSite** ppIPSite;
		HRESULT retValue;
	};

	STDMETHOD(GetInPlaceSite)(
		/*[out]*/ IOleInPlaceSite** ppIPSite)
	{
		VSL_DEFINE_MOCK_METHOD(GetInPlaceSite)

		VSL_SET_VALIDVALUE_INTERFACE(ppIPSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentValidValues
	{
		/*[out]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetDocument)(
		/*[out]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocument)

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRectValidValues
	{
		/*[in]*/ LPRECT prcView;
		HRESULT retValue;
	};

	STDMETHOD(SetRect)(
		/*[in]*/ LPRECT prcView)
	{
		VSL_DEFINE_MOCK_METHOD(SetRect)

		VSL_CHECK_VALIDVALUE(prcView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRectValidValues
	{
		/*[out]*/ LPRECT prcView;
		HRESULT retValue;
	};

	STDMETHOD(GetRect)(
		/*[out]*/ LPRECT prcView)
	{
		VSL_DEFINE_MOCK_METHOD(GetRect)

		VSL_SET_VALIDVALUE(prcView);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRectComplexValidValues
	{
		/*[in,unique]*/ LPRECT prcView;
		/*[in,unique]*/ LPRECT prcHScroll;
		/*[in,unique]*/ LPRECT prcVScroll;
		/*[in,unique]*/ LPRECT prcSizeBox;
		HRESULT retValue;
	};

	STDMETHOD(SetRectComplex)(
		/*[in,unique]*/ LPRECT prcView,
		/*[in,unique]*/ LPRECT prcHScroll,
		/*[in,unique]*/ LPRECT prcVScroll,
		/*[in,unique]*/ LPRECT prcSizeBox)
	{
		VSL_DEFINE_MOCK_METHOD(SetRectComplex)

		VSL_CHECK_VALIDVALUE(prcView);

		VSL_CHECK_VALIDVALUE(prcHScroll);

		VSL_CHECK_VALIDVALUE(prcVScroll);

		VSL_CHECK_VALIDVALUE(prcSizeBox);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowValidValues
	{
		/*[in]*/ BOOL fShow;
		HRESULT retValue;
	};

	STDMETHOD(Show)(
		/*[in]*/ BOOL fShow)
	{
		VSL_DEFINE_MOCK_METHOD(Show)

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct UIActivateValidValues
	{
		/*[in]*/ BOOL fUIActivate;
		HRESULT retValue;
	};

	STDMETHOD(UIActivate)(
		/*[in]*/ BOOL fUIActivate)
	{
		VSL_DEFINE_MOCK_METHOD(UIActivate)

		VSL_CHECK_VALIDVALUE(fUIActivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Open)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Open)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseViewValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(CloseView)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(CloseView)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveViewStateValidValues
	{
		/*[in]*/ LPSTREAM pstm;
		HRESULT retValue;
	};

	STDMETHOD(SaveViewState)(
		/*[in]*/ LPSTREAM pstm)
	{
		VSL_DEFINE_MOCK_METHOD(SaveViewState)

		VSL_CHECK_VALIDVALUE(pstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplyViewStateValidValues
	{
		/*[in]*/ LPSTREAM pstm;
		HRESULT retValue;
	};

	STDMETHOD(ApplyViewState)(
		/*[in]*/ LPSTREAM pstm)
	{
		VSL_DEFINE_MOCK_METHOD(ApplyViewState)

		VSL_CHECK_VALIDVALUE(pstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[in]*/ IOleInPlaceSite* pIPSiteNew;
		/*[out]*/ IOleDocumentView** ppViewNew;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[in]*/ IOleInPlaceSite* pIPSiteNew,
		/*[out]*/ IOleDocumentView** ppViewNew)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIPSiteNew);

		VSL_SET_VALIDVALUE_INTERFACE(ppViewNew);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEDOCUMENTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceActiveObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACEACTIVEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACEACTIVEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceActiveObjectNotImpl :
	public IOleInPlaceActiveObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceActiveObjectNotImpl)

public:

	typedef IOleInPlaceActiveObject Interface;

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG /*lpmsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnFrameWindowActivate)(
		/*[in]*/ BOOL /*fActivate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDocWindowActivate)(
		/*[in]*/ BOOL /*fActivate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResizeBorder)(
		/*[in]*/ LPCRECT /*prcBorder*/,
		/*[in,unique]*/ IOleInPlaceUIWindow* /*pUIWindow*/,
		/*[in]*/ BOOL /*fFrameWindow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceActiveObjectMockImpl :
	public IOleInPlaceActiveObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceActiveObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceActiveObjectMockImpl)

	typedef IOleInPlaceActiveObject Interface;
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ LPMSG lpmsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG lpmsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE(lpmsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnFrameWindowActivateValidValues
	{
		/*[in]*/ BOOL fActivate;
		HRESULT retValue;
	};

	STDMETHOD(OnFrameWindowActivate)(
		/*[in]*/ BOOL fActivate)
	{
		VSL_DEFINE_MOCK_METHOD(OnFrameWindowActivate)

		VSL_CHECK_VALIDVALUE(fActivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDocWindowActivateValidValues
	{
		/*[in]*/ BOOL fActivate;
		HRESULT retValue;
	};

	STDMETHOD(OnDocWindowActivate)(
		/*[in]*/ BOOL fActivate)
	{
		VSL_DEFINE_MOCK_METHOD(OnDocWindowActivate)

		VSL_CHECK_VALIDVALUE(fActivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResizeBorderValidValues
	{
		/*[in]*/ LPCRECT prcBorder;
		/*[in,unique]*/ IOleInPlaceUIWindow* pUIWindow;
		/*[in]*/ BOOL fFrameWindow;
		HRESULT retValue;
	};

	STDMETHOD(ResizeBorder)(
		/*[in]*/ LPCRECT prcBorder,
		/*[in,unique]*/ IOleInPlaceUIWindow* pUIWindow,
		/*[in]*/ BOOL fFrameWindow)
	{
		VSL_DEFINE_MOCK_METHOD(ResizeBorder)

		VSL_CHECK_VALIDVALUE(prcBorder);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIWindow);

		VSL_CHECK_VALIDVALUE(fFrameWindow);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableModelessValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(EnableModeless)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACEACTIVEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceComponentUIManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACECOMPONENTUIMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACECOMPONENTUIMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "oleipc.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceComponentUIManagerNotImpl :
	public IOleInPlaceComponentUIManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceComponentUIManagerNotImpl)

public:

	typedef IOleInPlaceComponentUIManager Interface;

	STDMETHOD(UIActivateForMe)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidActive*/,
		/*[in]*/ IOleInPlaceActiveObject* /*pIPActObj*/,
		/*[in]*/ IOleCommandTarget* /*pCmdTrgtActive*/,
		/*[in]*/ ULONG /*cCmdGrpId*/,
		/*[in]*/ LONG* /*rgnCmdGrpId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateUI)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ BOOL /*fImmediateUpdate*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetActiveUI)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsid*/,
		/*[in]*/ ULONG /*cCmdGrpId*/,
		/*[in]*/ LONG* /*rgnCmdGrpId*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE OnUIComponentEnterState(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ DWORD /*dwStateId*/,
		/*[in]*/ DWORD /*dwReserved*/){ return ; }

	virtual BOOL STDMETHODCALLTYPE FOnUIComponentExitState(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ DWORD /*dwStateId*/,
		/*[in]*/ DWORD /*dwReserved*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FUIComponentInState(
		/*[in]*/ DWORD /*dwStateId*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FContinueIdle(){ return BOOL(); }
};

class IOleInPlaceComponentUIManagerMockImpl :
	public IOleInPlaceComponentUIManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceComponentUIManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceComponentUIManagerMockImpl)

	typedef IOleInPlaceComponentUIManager Interface;
	struct UIActivateForMeValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidActive;
		/*[in]*/ IOleInPlaceActiveObject* pIPActObj;
		/*[in]*/ IOleCommandTarget* pCmdTrgtActive;
		/*[in]*/ ULONG cCmdGrpId;
		/*[in]*/ LONG* rgnCmdGrpId;
		HRESULT retValue;
	};

	STDMETHOD(UIActivateForMe)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidActive,
		/*[in]*/ IOleInPlaceActiveObject* pIPActObj,
		/*[in]*/ IOleCommandTarget* pCmdTrgtActive,
		/*[in]*/ ULONG cCmdGrpId,
		/*[in]*/ LONG* rgnCmdGrpId)
	{
		VSL_DEFINE_MOCK_METHOD(UIActivateForMe)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidActive);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIPActObj);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdTrgtActive);

		VSL_CHECK_VALIDVALUE(cCmdGrpId);

		VSL_CHECK_VALIDVALUE_POINTER(rgnCmdGrpId);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateUIValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ BOOL fImmediateUpdate;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(UpdateUI)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ BOOL fImmediateUpdate,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateUI)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(fImmediateUpdate);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetActiveUIValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsid;
		/*[in]*/ ULONG cCmdGrpId;
		/*[in]*/ LONG* rgnCmdGrpId;
		HRESULT retValue;
	};

	STDMETHOD(SetActiveUI)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsid,
		/*[in]*/ ULONG cCmdGrpId,
		/*[in]*/ LONG* rgnCmdGrpId)
	{
		VSL_DEFINE_MOCK_METHOD(SetActiveUI)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsid);

		VSL_CHECK_VALIDVALUE(cCmdGrpId);

		VSL_CHECK_VALIDVALUE_POINTER(rgnCmdGrpId);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIComponentEnterStateValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ DWORD dwStateId;
		/*[in]*/ DWORD dwReserved;
	};

	virtual void _stdcall OnUIComponentEnterState(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ DWORD dwStateId,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnUIComponentEnterState)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(dwStateId);

		VSL_CHECK_VALIDVALUE(dwReserved);

	}
	struct FOnUIComponentExitStateValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ DWORD dwStateId;
		/*[in]*/ DWORD dwReserved;
		BOOL retValue;
	};

	virtual BOOL _stdcall FOnUIComponentExitState(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ DWORD dwStateId,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(FOnUIComponentExitState)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(dwStateId);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct FUIComponentInStateValidValues
	{
		/*[in]*/ DWORD dwStateId;
		BOOL retValue;
	};

	virtual BOOL _stdcall FUIComponentInState(
		/*[in]*/ DWORD dwStateId)
	{
		VSL_DEFINE_MOCK_METHOD(FUIComponentInState)

		VSL_CHECK_VALIDVALUE(dwStateId);

		VSL_RETURN_VALIDVALUES();
	}
	struct FContinueIdleValidValues
	{
		BOOL retValue;
	};

	virtual BOOL _stdcall FContinueIdle()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FContinueIdle)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACECOMPONENTUIMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceObjectWindowless.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACEOBJECTWINDOWLESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACEOBJECTWINDOWLESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceObjectWindowlessNotImpl :
	public IOleInPlaceObjectWindowless
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceObjectWindowlessNotImpl)

public:

	typedef IOleInPlaceObjectWindowless Interface;

	STDMETHOD(OnWindowMessage)(
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/,
		/*[out]*/ LRESULT* /*plResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDropTarget)(
		/*[out]*/ IDropTarget** /*ppDropTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InPlaceDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UIDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetObjectRects)(
		/*[in]*/ LPCRECT /*lprcPosRect*/,
		/*[in]*/ LPCRECT /*lprcClipRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReactivateAndUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceObjectWindowlessMockImpl :
	public IOleInPlaceObjectWindowless,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceObjectWindowlessMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceObjectWindowlessMockImpl)

	typedef IOleInPlaceObjectWindowless Interface;
	struct OnWindowMessageValidValues
	{
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		/*[out]*/ LRESULT* plResult;
		HRESULT retValue;
	};

	STDMETHOD(OnWindowMessage)(
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam,
		/*[out]*/ LRESULT* plResult)
	{
		VSL_DEFINE_MOCK_METHOD(OnWindowMessage)

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_SET_VALIDVALUE(plResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDropTargetValidValues
	{
		/*[out]*/ IDropTarget** ppDropTarget;
		HRESULT retValue;
	};

	STDMETHOD(GetDropTarget)(
		/*[out]*/ IDropTarget** ppDropTarget)
	{
		VSL_DEFINE_MOCK_METHOD(GetDropTarget)

		VSL_SET_VALIDVALUE_INTERFACE(ppDropTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct InPlaceDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(InPlaceDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(InPlaceDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct UIDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UIDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UIDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetObjectRectsValidValues
	{
		/*[in]*/ LPCRECT lprcPosRect;
		/*[in]*/ LPCRECT lprcClipRect;
		HRESULT retValue;
	};

	STDMETHOD(SetObjectRects)(
		/*[in]*/ LPCRECT lprcPosRect,
		/*[in]*/ LPCRECT lprcClipRect)
	{
		VSL_DEFINE_MOCK_METHOD(SetObjectRects)

		VSL_CHECK_VALIDVALUE(lprcPosRect);

		VSL_CHECK_VALIDVALUE(lprcClipRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReactivateAndUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ReactivateAndUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReactivateAndUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACEOBJECTWINDOWLESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceObjectNotImpl :
	public IOleInPlaceObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceObjectNotImpl)

public:

	typedef IOleInPlaceObject Interface;

	STDMETHOD(InPlaceDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UIDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetObjectRects)(
		/*[in]*/ LPCRECT /*lprcPosRect*/,
		/*[in]*/ LPCRECT /*lprcClipRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReactivateAndUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceObjectMockImpl :
	public IOleInPlaceObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceObjectMockImpl)

	typedef IOleInPlaceObject Interface;
	struct InPlaceDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(InPlaceDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(InPlaceDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct UIDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UIDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UIDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetObjectRectsValidValues
	{
		/*[in]*/ LPCRECT lprcPosRect;
		/*[in]*/ LPCRECT lprcClipRect;
		HRESULT retValue;
	};

	STDMETHOD(SetObjectRects)(
		/*[in]*/ LPCRECT lprcPosRect,
		/*[in]*/ LPCRECT lprcClipRect)
	{
		VSL_DEFINE_MOCK_METHOD(SetObjectRects)

		VSL_CHECK_VALIDVALUE(lprcPosRect);

		VSL_CHECK_VALIDVALUE(lprcClipRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReactivateAndUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ReactivateAndUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReactivateAndUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceFrame.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACEFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACEFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceFrameNotImpl :
	public IOleInPlaceFrame
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceFrameNotImpl)

public:

	typedef IOleInPlaceFrame Interface;

	STDMETHOD(InsertMenus)(
		/*[in]*/ HMENU /*hmenuShared*/,
		/*[in,out]*/ LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMenu)(
		/*[in]*/ HMENU /*hmenuShared*/,
		/*[in]*/ HOLEMENU /*holemenu*/,
		/*[in]*/ HWND /*hwndActiveObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveMenus)(
		/*[in]*/ HMENU /*hmenuShared*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStatusText)(
		/*[in,unique]*/ LPCOLESTR /*pszStatusText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG /*lpmsg*/,
		/*[in]*/ WORD /*wID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBorder)(
		/*[out]*/ LPRECT /*lprectBorder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RequestBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS /*pborderwidths*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS /*pborderwidths*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetActiveObject)(
		/*[in,unique]*/ IOleInPlaceActiveObject* /*pActiveObject*/,
		/*[in,string,unique]*/ LPCOLESTR /*pszObjName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceFrameMockImpl :
	public IOleInPlaceFrame,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceFrameMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceFrameMockImpl)

	typedef IOleInPlaceFrame Interface;
	struct InsertMenusValidValues
	{
		/*[in]*/ HMENU hmenuShared;
		/*[in,out]*/ LPOLEMENUGROUPWIDTHS lpMenuWidths;
		HRESULT retValue;
	};

	STDMETHOD(InsertMenus)(
		/*[in]*/ HMENU hmenuShared,
		/*[in,out]*/ LPOLEMENUGROUPWIDTHS lpMenuWidths)
	{
		VSL_DEFINE_MOCK_METHOD(InsertMenus)

		VSL_CHECK_VALIDVALUE(hmenuShared);

		VSL_SET_VALIDVALUE(lpMenuWidths);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMenuValidValues
	{
		/*[in]*/ HMENU hmenuShared;
		/*[in]*/ HOLEMENU holemenu;
		/*[in]*/ HWND hwndActiveObject;
		HRESULT retValue;
	};

	STDMETHOD(SetMenu)(
		/*[in]*/ HMENU hmenuShared,
		/*[in]*/ HOLEMENU holemenu,
		/*[in]*/ HWND hwndActiveObject)
	{
		VSL_DEFINE_MOCK_METHOD(SetMenu)

		VSL_CHECK_VALIDVALUE(hmenuShared);

		VSL_CHECK_VALIDVALUE(holemenu);

		VSL_CHECK_VALIDVALUE(hwndActiveObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveMenusValidValues
	{
		/*[in]*/ HMENU hmenuShared;
		HRESULT retValue;
	};

	STDMETHOD(RemoveMenus)(
		/*[in]*/ HMENU hmenuShared)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveMenus)

		VSL_CHECK_VALIDVALUE(hmenuShared);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStatusTextValidValues
	{
		/*[in,unique]*/ LPCOLESTR pszStatusText;
		HRESULT retValue;
	};

	STDMETHOD(SetStatusText)(
		/*[in,unique]*/ LPCOLESTR pszStatusText)
	{
		VSL_DEFINE_MOCK_METHOD(SetStatusText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszStatusText);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableModelessValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(EnableModeless)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ LPMSG lpmsg;
		/*[in]*/ WORD wID;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG lpmsg,
		/*[in]*/ WORD wID)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE(lpmsg);

		VSL_CHECK_VALIDVALUE(wID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBorderValidValues
	{
		/*[out]*/ LPRECT lprectBorder;
		HRESULT retValue;
	};

	STDMETHOD(GetBorder)(
		/*[out]*/ LPRECT lprectBorder)
	{
		VSL_DEFINE_MOCK_METHOD(GetBorder)

		VSL_SET_VALIDVALUE(lprectBorder);

		VSL_RETURN_VALIDVALUES();
	}
	struct RequestBorderSpaceValidValues
	{
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths;
		HRESULT retValue;
	};

	STDMETHOD(RequestBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths)
	{
		VSL_DEFINE_MOCK_METHOD(RequestBorderSpace)

		VSL_CHECK_VALIDVALUE(pborderwidths);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBorderSpaceValidValues
	{
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths;
		HRESULT retValue;
	};

	STDMETHOD(SetBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths)
	{
		VSL_DEFINE_MOCK_METHOD(SetBorderSpace)

		VSL_CHECK_VALIDVALUE(pborderwidths);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetActiveObjectValidValues
	{
		/*[in,unique]*/ IOleInPlaceActiveObject* pActiveObject;
		/*[in,string,unique]*/ LPCOLESTR pszObjName;
		HRESULT retValue;
	};

	STDMETHOD(SetActiveObject)(
		/*[in,unique]*/ IOleInPlaceActiveObject* pActiveObject,
		/*[in,string,unique]*/ LPCOLESTR pszObjName)
	{
		VSL_DEFINE_MOCK_METHOD(SetActiveObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pActiveObject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACEFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceSiteWindowless.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACESITEWINDOWLESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACESITEWINDOWLESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceSiteWindowlessNotImpl :
	public IOleInPlaceSiteWindowless
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceSiteWindowlessNotImpl)

public:

	typedef IOleInPlaceSiteWindowless Interface;

	STDMETHOD(CanWindowlessActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCapture)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCapture)(
		/*[in]*/ BOOL /*fCapture*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFocus)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFocus)(
		/*[in]*/ BOOL /*fFocus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDC)(
		/*[in]*/ LPCRECT /*pRect*/,
		/*[in]*/ DWORD /*grfFlags*/,
		/*[out]*/ HDC* /*phDC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseDC)(
		/*[in]*/ HDC /*hDC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InvalidateRect)(
		/*[in]*/ LPCRECT /*pRect*/,
		/*[in]*/ BOOL /*fErase*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InvalidateRgn)(
		/*[in]*/ HRGN /*hRGN*/,
		/*[in]*/ BOOL /*fErase*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ScrollRect)(
		/*[in]*/ INT /*dx*/,
		/*[in]*/ INT /*dy*/,
		/*[in]*/ LPCRECT /*pRectScroll*/,
		/*[in]*/ LPCRECT /*pRectClip*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdjustRect)(
		/*[in,out]*/ LPRECT /*prc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDefWindowMessage)(
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/,
		/*[out]*/ LRESULT* /*plResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceActivateEx)(
		/*[out]*/ BOOL* /*pfNoRedraw*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceDeactivateEx)(
		/*[in]*/ BOOL /*fNoRedraw*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RequestUIActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanInPlaceActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUIActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindowContext)(
		/*[out]*/ IOleInPlaceFrame** /*ppFrame*/,
		/*[out]*/ IOleInPlaceUIWindow** /*ppDoc*/,
		/*[out]*/ LPRECT /*lprcPosRect*/,
		/*[out]*/ LPRECT /*lprcClipRect*/,
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO /*lpFrameInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Scroll)(
		/*[in]*/ SIZE /*scrollExtant*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUIDeactivate)(
		/*[in]*/ BOOL /*fUndoable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiscardUndoState)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeactivateAndUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPosRectChange)(
		/*[in]*/ LPCRECT /*lprcPosRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceSiteWindowlessMockImpl :
	public IOleInPlaceSiteWindowless,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceSiteWindowlessMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceSiteWindowlessMockImpl)

	typedef IOleInPlaceSiteWindowless Interface;
	struct CanWindowlessActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanWindowlessActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanWindowlessActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCaptureValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(GetCapture)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetCapture)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCaptureValidValues
	{
		/*[in]*/ BOOL fCapture;
		HRESULT retValue;
	};

	STDMETHOD(SetCapture)(
		/*[in]*/ BOOL fCapture)
	{
		VSL_DEFINE_MOCK_METHOD(SetCapture)

		VSL_CHECK_VALIDVALUE(fCapture);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFocusValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(GetFocus)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetFocus)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFocusValidValues
	{
		/*[in]*/ BOOL fFocus;
		HRESULT retValue;
	};

	STDMETHOD(SetFocus)(
		/*[in]*/ BOOL fFocus)
	{
		VSL_DEFINE_MOCK_METHOD(SetFocus)

		VSL_CHECK_VALIDVALUE(fFocus);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDCValidValues
	{
		/*[in]*/ LPCRECT pRect;
		/*[in]*/ DWORD grfFlags;
		/*[out]*/ HDC* phDC;
		HRESULT retValue;
	};

	STDMETHOD(GetDC)(
		/*[in]*/ LPCRECT pRect,
		/*[in]*/ DWORD grfFlags,
		/*[out]*/ HDC* phDC)
	{
		VSL_DEFINE_MOCK_METHOD(GetDC)

		VSL_CHECK_VALIDVALUE(pRect);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_SET_VALIDVALUE(phDC);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseDCValidValues
	{
		/*[in]*/ HDC hDC;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseDC)(
		/*[in]*/ HDC hDC)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseDC)

		VSL_CHECK_VALIDVALUE(hDC);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateRectValidValues
	{
		/*[in]*/ LPCRECT pRect;
		/*[in]*/ BOOL fErase;
		HRESULT retValue;
	};

	STDMETHOD(InvalidateRect)(
		/*[in]*/ LPCRECT pRect,
		/*[in]*/ BOOL fErase)
	{
		VSL_DEFINE_MOCK_METHOD(InvalidateRect)

		VSL_CHECK_VALIDVALUE(pRect);

		VSL_CHECK_VALIDVALUE(fErase);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateRgnValidValues
	{
		/*[in]*/ HRGN hRGN;
		/*[in]*/ BOOL fErase;
		HRESULT retValue;
	};

	STDMETHOD(InvalidateRgn)(
		/*[in]*/ HRGN hRGN,
		/*[in]*/ BOOL fErase)
	{
		VSL_DEFINE_MOCK_METHOD(InvalidateRgn)

		VSL_CHECK_VALIDVALUE(hRGN);

		VSL_CHECK_VALIDVALUE(fErase);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollRectValidValues
	{
		/*[in]*/ INT dx;
		/*[in]*/ INT dy;
		/*[in]*/ LPCRECT pRectScroll;
		/*[in]*/ LPCRECT pRectClip;
		HRESULT retValue;
	};

	STDMETHOD(ScrollRect)(
		/*[in]*/ INT dx,
		/*[in]*/ INT dy,
		/*[in]*/ LPCRECT pRectScroll,
		/*[in]*/ LPCRECT pRectClip)
	{
		VSL_DEFINE_MOCK_METHOD(ScrollRect)

		VSL_CHECK_VALIDVALUE(dx);

		VSL_CHECK_VALIDVALUE(dy);

		VSL_CHECK_VALIDVALUE(pRectScroll);

		VSL_CHECK_VALIDVALUE(pRectClip);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdjustRectValidValues
	{
		/*[in,out]*/ LPRECT prc;
		HRESULT retValue;
	};

	STDMETHOD(AdjustRect)(
		/*[in,out]*/ LPRECT prc)
	{
		VSL_DEFINE_MOCK_METHOD(AdjustRect)

		VSL_SET_VALIDVALUE(prc);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDefWindowMessageValidValues
	{
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		/*[out]*/ LRESULT* plResult;
		HRESULT retValue;
	};

	STDMETHOD(OnDefWindowMessage)(
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam,
		/*[out]*/ LRESULT* plResult)
	{
		VSL_DEFINE_MOCK_METHOD(OnDefWindowMessage)

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_SET_VALIDVALUE(plResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceActivateExValidValues
	{
		/*[out]*/ BOOL* pfNoRedraw;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceActivateEx)(
		/*[out]*/ BOOL* pfNoRedraw,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(OnInPlaceActivateEx)

		VSL_SET_VALIDVALUE(pfNoRedraw);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceDeactivateExValidValues
	{
		/*[in]*/ BOOL fNoRedraw;
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceDeactivateEx)(
		/*[in]*/ BOOL fNoRedraw)
	{
		VSL_DEFINE_MOCK_METHOD(OnInPlaceDeactivateEx)

		VSL_CHECK_VALIDVALUE(fNoRedraw);

		VSL_RETURN_VALIDVALUES();
	}
	struct RequestUIActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RequestUIActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RequestUIActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanInPlaceActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanInPlaceActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanInPlaceActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInPlaceActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnUIActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnUIActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowContextValidValues
	{
		/*[out]*/ IOleInPlaceFrame** ppFrame;
		/*[out]*/ IOleInPlaceUIWindow** ppDoc;
		/*[out]*/ LPRECT lprcPosRect;
		/*[out]*/ LPRECT lprcClipRect;
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO lpFrameInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowContext)(
		/*[out]*/ IOleInPlaceFrame** ppFrame,
		/*[out]*/ IOleInPlaceUIWindow** ppDoc,
		/*[out]*/ LPRECT lprcPosRect,
		/*[out]*/ LPRECT lprcClipRect,
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO lpFrameInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_SET_VALIDVALUE_INTERFACE(ppDoc);

		VSL_SET_VALIDVALUE(lprcPosRect);

		VSL_SET_VALIDVALUE(lprcClipRect);

		VSL_SET_VALIDVALUE(lpFrameInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollValidValues
	{
		/*[in]*/ SIZE scrollExtant;
		HRESULT retValue;
	};

	STDMETHOD(Scroll)(
		/*[in]*/ SIZE scrollExtant)
	{
		VSL_DEFINE_MOCK_METHOD(Scroll)

		VSL_CHECK_VALIDVALUE(scrollExtant);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIDeactivateValidValues
	{
		/*[in]*/ BOOL fUndoable;
		HRESULT retValue;
	};

	STDMETHOD(OnUIDeactivate)(
		/*[in]*/ BOOL fUndoable)
	{
		VSL_DEFINE_MOCK_METHOD(OnUIDeactivate)

		VSL_CHECK_VALIDVALUE(fUndoable);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInPlaceDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct DiscardUndoStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DiscardUndoState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DiscardUndoState)

		VSL_RETURN_VALIDVALUES();
	}
	struct DeactivateAndUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DeactivateAndUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DeactivateAndUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPosRectChangeValidValues
	{
		/*[in]*/ LPCRECT lprcPosRect;
		HRESULT retValue;
	};

	STDMETHOD(OnPosRectChange)(
		/*[in]*/ LPCRECT lprcPosRect)
	{
		VSL_DEFINE_MOCK_METHOD(OnPosRectChange)

		VSL_CHECK_VALIDVALUE(lprcPosRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACESITEWINDOWLESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceSiteEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACESITEEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACESITEEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceSiteExNotImpl :
	public IOleInPlaceSiteEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceSiteExNotImpl)

public:

	typedef IOleInPlaceSiteEx Interface;

	STDMETHOD(OnInPlaceActivateEx)(
		/*[out]*/ BOOL* /*pfNoRedraw*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceDeactivateEx)(
		/*[in]*/ BOOL /*fNoRedraw*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RequestUIActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanInPlaceActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUIActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindowContext)(
		/*[out]*/ IOleInPlaceFrame** /*ppFrame*/,
		/*[out]*/ IOleInPlaceUIWindow** /*ppDoc*/,
		/*[out]*/ LPRECT /*lprcPosRect*/,
		/*[out]*/ LPRECT /*lprcClipRect*/,
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO /*lpFrameInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Scroll)(
		/*[in]*/ SIZE /*scrollExtant*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUIDeactivate)(
		/*[in]*/ BOOL /*fUndoable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiscardUndoState)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeactivateAndUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPosRectChange)(
		/*[in]*/ LPCRECT /*lprcPosRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceSiteExMockImpl :
	public IOleInPlaceSiteEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceSiteExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceSiteExMockImpl)

	typedef IOleInPlaceSiteEx Interface;
	struct OnInPlaceActivateExValidValues
	{
		/*[out]*/ BOOL* pfNoRedraw;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceActivateEx)(
		/*[out]*/ BOOL* pfNoRedraw,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(OnInPlaceActivateEx)

		VSL_SET_VALIDVALUE(pfNoRedraw);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceDeactivateExValidValues
	{
		/*[in]*/ BOOL fNoRedraw;
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceDeactivateEx)(
		/*[in]*/ BOOL fNoRedraw)
	{
		VSL_DEFINE_MOCK_METHOD(OnInPlaceDeactivateEx)

		VSL_CHECK_VALIDVALUE(fNoRedraw);

		VSL_RETURN_VALIDVALUES();
	}
	struct RequestUIActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RequestUIActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RequestUIActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanInPlaceActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanInPlaceActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanInPlaceActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInPlaceActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnUIActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnUIActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowContextValidValues
	{
		/*[out]*/ IOleInPlaceFrame** ppFrame;
		/*[out]*/ IOleInPlaceUIWindow** ppDoc;
		/*[out]*/ LPRECT lprcPosRect;
		/*[out]*/ LPRECT lprcClipRect;
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO lpFrameInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowContext)(
		/*[out]*/ IOleInPlaceFrame** ppFrame,
		/*[out]*/ IOleInPlaceUIWindow** ppDoc,
		/*[out]*/ LPRECT lprcPosRect,
		/*[out]*/ LPRECT lprcClipRect,
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO lpFrameInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_SET_VALIDVALUE_INTERFACE(ppDoc);

		VSL_SET_VALIDVALUE(lprcPosRect);

		VSL_SET_VALIDVALUE(lprcClipRect);

		VSL_SET_VALIDVALUE(lpFrameInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollValidValues
	{
		/*[in]*/ SIZE scrollExtant;
		HRESULT retValue;
	};

	STDMETHOD(Scroll)(
		/*[in]*/ SIZE scrollExtant)
	{
		VSL_DEFINE_MOCK_METHOD(Scroll)

		VSL_CHECK_VALIDVALUE(scrollExtant);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIDeactivateValidValues
	{
		/*[in]*/ BOOL fUndoable;
		HRESULT retValue;
	};

	STDMETHOD(OnUIDeactivate)(
		/*[in]*/ BOOL fUndoable)
	{
		VSL_DEFINE_MOCK_METHOD(OnUIDeactivate)

		VSL_CHECK_VALIDVALUE(fUndoable);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInPlaceDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct DiscardUndoStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DiscardUndoState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DiscardUndoState)

		VSL_RETURN_VALIDVALUES();
	}
	struct DeactivateAndUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DeactivateAndUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DeactivateAndUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPosRectChangeValidValues
	{
		/*[in]*/ LPCRECT lprcPosRect;
		HRESULT retValue;
	};

	STDMETHOD(OnPosRectChange)(
		/*[in]*/ LPCRECT lprcPosRect)
	{
		VSL_DEFINE_MOCK_METHOD(OnPosRectChange)

		VSL_CHECK_VALIDVALUE(lprcPosRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACESITEEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceSiteNotImpl :
	public IOleInPlaceSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceSiteNotImpl)

public:

	typedef IOleInPlaceSite Interface;

	STDMETHOD(CanInPlaceActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUIActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindowContext)(
		/*[out]*/ IOleInPlaceFrame** /*ppFrame*/,
		/*[out]*/ IOleInPlaceUIWindow** /*ppDoc*/,
		/*[out]*/ LPRECT /*lprcPosRect*/,
		/*[out]*/ LPRECT /*lprcClipRect*/,
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO /*lpFrameInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Scroll)(
		/*[in]*/ SIZE /*scrollExtant*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUIDeactivate)(
		/*[in]*/ BOOL /*fUndoable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInPlaceDeactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiscardUndoState)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeactivateAndUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPosRectChange)(
		/*[in]*/ LPCRECT /*lprcPosRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceSiteMockImpl :
	public IOleInPlaceSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceSiteMockImpl)

	typedef IOleInPlaceSite Interface;
	struct CanInPlaceActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanInPlaceActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanInPlaceActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInPlaceActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnUIActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnUIActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowContextValidValues
	{
		/*[out]*/ IOleInPlaceFrame** ppFrame;
		/*[out]*/ IOleInPlaceUIWindow** ppDoc;
		/*[out]*/ LPRECT lprcPosRect;
		/*[out]*/ LPRECT lprcClipRect;
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO lpFrameInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowContext)(
		/*[out]*/ IOleInPlaceFrame** ppFrame,
		/*[out]*/ IOleInPlaceUIWindow** ppDoc,
		/*[out]*/ LPRECT lprcPosRect,
		/*[out]*/ LPRECT lprcClipRect,
		/*[in,out]*/ LPOLEINPLACEFRAMEINFO lpFrameInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_SET_VALIDVALUE_INTERFACE(ppDoc);

		VSL_SET_VALIDVALUE(lprcPosRect);

		VSL_SET_VALIDVALUE(lprcClipRect);

		VSL_SET_VALIDVALUE(lpFrameInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollValidValues
	{
		/*[in]*/ SIZE scrollExtant;
		HRESULT retValue;
	};

	STDMETHOD(Scroll)(
		/*[in]*/ SIZE scrollExtant)
	{
		VSL_DEFINE_MOCK_METHOD(Scroll)

		VSL_CHECK_VALIDVALUE(scrollExtant);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUIDeactivateValidValues
	{
		/*[in]*/ BOOL fUndoable;
		HRESULT retValue;
	};

	STDMETHOD(OnUIDeactivate)(
		/*[in]*/ BOOL fUndoable)
	{
		VSL_DEFINE_MOCK_METHOD(OnUIDeactivate)

		VSL_CHECK_VALIDVALUE(fUndoable);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInPlaceDeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInPlaceDeactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInPlaceDeactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct DiscardUndoStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DiscardUndoState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DiscardUndoState)

		VSL_RETURN_VALIDVALUES();
	}
	struct DeactivateAndUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DeactivateAndUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DeactivateAndUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPosRectChangeValidValues
	{
		/*[in]*/ LPCRECT lprcPosRect;
		HRESULT retValue;
	};

	STDMETHOD(OnPosRectChange)(
		/*[in]*/ LPCRECT lprcPosRect)
	{
		VSL_DEFINE_MOCK_METHOD(OnPosRectChange)

		VSL_CHECK_VALIDVALUE(lprcPosRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleItemContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEITEMCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEITEMCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleItemContainerNotImpl :
	public IOleItemContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleItemContainerNotImpl)

public:

	typedef IOleItemContainer Interface;

	STDMETHOD(GetObject)(
		/*[in]*/ LPOLESTR /*pszItem*/,
		/*[in]*/ DWORD /*dwSpeedNeeded*/,
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetObjectStorage)(
		/*[in]*/ LPOLESTR /*pszItem*/,
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppvStorage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsRunning)(
		/*[in]*/ LPOLESTR /*pszItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumObjects)(
		/*[in]*/ DWORD /*grfFlags*/,
		/*[out]*/ IEnumUnknown** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockContainer)(
		/*[in]*/ BOOL /*fLock*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in]*/ LPOLESTR /*pszDisplayName*/,
		/*[out]*/ ULONG* /*pchEaten*/,
		/*[out]*/ IMoniker** /*ppmkOut*/)VSL_STDMETHOD_NOTIMPL
};

class IOleItemContainerMockImpl :
	public IOleItemContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleItemContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleItemContainerMockImpl)

	typedef IOleItemContainer Interface;
	struct GetObjectValidValues
	{
		/*[in]*/ LPOLESTR pszItem;
		/*[in]*/ DWORD dwSpeedNeeded;
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(GetObject)(
		/*[in]*/ LPOLESTR pszItem,
		/*[in]*/ DWORD dwSpeedNeeded,
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetObject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszItem);

		VSL_CHECK_VALIDVALUE(dwSpeedNeeded);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetObjectStorageValidValues
	{
		/*[in]*/ LPOLESTR pszItem;
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppvStorage;
		HRESULT retValue;
	};

	STDMETHOD(GetObjectStorage)(
		/*[in]*/ LPOLESTR pszItem,
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppvStorage)
	{
		VSL_DEFINE_MOCK_METHOD(GetObjectStorage)

		VSL_CHECK_VALIDVALUE_STRINGW(pszItem);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvStorage);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsRunningValidValues
	{
		/*[in]*/ LPOLESTR pszItem;
		HRESULT retValue;
	};

	STDMETHOD(IsRunning)(
		/*[in]*/ LPOLESTR pszItem)
	{
		VSL_DEFINE_MOCK_METHOD(IsRunning)

		VSL_CHECK_VALIDVALUE_STRINGW(pszItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumObjectsValidValues
	{
		/*[in]*/ DWORD grfFlags;
		/*[out]*/ IEnumUnknown** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumObjects)(
		/*[in]*/ DWORD grfFlags,
		/*[out]*/ IEnumUnknown** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumObjects)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockContainerValidValues
	{
		/*[in]*/ BOOL fLock;
		HRESULT retValue;
	};

	STDMETHOD(LockContainer)(
		/*[in]*/ BOOL fLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockContainer)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseDisplayNameValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in]*/ LPOLESTR pszDisplayName;
		/*[out]*/ ULONG* pchEaten;
		/*[out]*/ IMoniker** ppmkOut;
		HRESULT retValue;
	};

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in]*/ LPOLESTR pszDisplayName,
		/*[out]*/ ULONG* pchEaten,
		/*[out]*/ IMoniker** ppmkOut)
	{
		VSL_DEFINE_MOCK_METHOD(ParseDisplayName)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDisplayName);

		VSL_SET_VALIDVALUE(pchEaten);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEITEMCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceUIWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACEUIWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACEUIWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceUIWindowNotImpl :
	public IOleInPlaceUIWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceUIWindowNotImpl)

public:

	typedef IOleInPlaceUIWindow Interface;

	STDMETHOD(GetBorder)(
		/*[out]*/ LPRECT /*lprectBorder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RequestBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS /*pborderwidths*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS /*pborderwidths*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetActiveObject)(
		/*[in,unique]*/ IOleInPlaceActiveObject* /*pActiveObject*/,
		/*[in,string,unique]*/ LPCOLESTR /*pszObjName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceUIWindowMockImpl :
	public IOleInPlaceUIWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceUIWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceUIWindowMockImpl)

	typedef IOleInPlaceUIWindow Interface;
	struct GetBorderValidValues
	{
		/*[out]*/ LPRECT lprectBorder;
		HRESULT retValue;
	};

	STDMETHOD(GetBorder)(
		/*[out]*/ LPRECT lprectBorder)
	{
		VSL_DEFINE_MOCK_METHOD(GetBorder)

		VSL_SET_VALIDVALUE(lprectBorder);

		VSL_RETURN_VALIDVALUES();
	}
	struct RequestBorderSpaceValidValues
	{
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths;
		HRESULT retValue;
	};

	STDMETHOD(RequestBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths)
	{
		VSL_DEFINE_MOCK_METHOD(RequestBorderSpace)

		VSL_CHECK_VALIDVALUE(pborderwidths);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBorderSpaceValidValues
	{
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths;
		HRESULT retValue;
	};

	STDMETHOD(SetBorderSpace)(
		/*[in,unique]*/ LPCBORDERWIDTHS pborderwidths)
	{
		VSL_DEFINE_MOCK_METHOD(SetBorderSpace)

		VSL_CHECK_VALIDVALUE(pborderwidths);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetActiveObjectValidValues
	{
		/*[in,unique]*/ IOleInPlaceActiveObject* pActiveObject;
		/*[in,string,unique]*/ LPCOLESTR pszObjName;
		HRESULT retValue;
	};

	STDMETHOD(SetActiveObject)(
		/*[in,unique]*/ IOleInPlaceActiveObject* pActiveObject,
		/*[in,string,unique]*/ LPCOLESTR pszObjName)
	{
		VSL_DEFINE_MOCK_METHOD(SetActiveObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pActiveObject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACEUIWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleParentUndoUnit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEPARENTUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEPARENTUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleParentUndoUnitNotImpl :
	public IOleParentUndoUnit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleParentUndoUnitNotImpl)

public:

	typedef IOleParentUndoUnit Interface;

	STDMETHOD(Open)(
		/*[in]*/ IOleParentUndoUnit* /*pPUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)(
		/*[in]*/ IOleParentUndoUnit* /*pPUU*/,
		/*[in]*/ BOOL /*fCommit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ IOleUndoUnit* /*pUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindUnit)(
		/*[in]*/ IOleUndoUnit* /*pUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParentState)(
		/*[out]*/ DWORD* /*pdwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Do)(
		/*[in]*/ IOleUndoManager* /*pUndoManager*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pBstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUnitType)(
		/*[out]*/ CLSID* /*pClsid*/,
		/*[out]*/ LONG* /*plID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnNextAdd)()VSL_STDMETHOD_NOTIMPL
};

class IOleParentUndoUnitMockImpl :
	public IOleParentUndoUnit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleParentUndoUnitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleParentUndoUnitMockImpl)

	typedef IOleParentUndoUnit Interface;
	struct OpenValidValues
	{
		/*[in]*/ IOleParentUndoUnit* pPUU;
		HRESULT retValue;
	};

	STDMETHOD(Open)(
		/*[in]*/ IOleParentUndoUnit* pPUU)
	{
		VSL_DEFINE_MOCK_METHOD(Open)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		/*[in]*/ IOleParentUndoUnit* pPUU;
		/*[in]*/ BOOL fCommit;
		HRESULT retValue;
	};

	STDMETHOD(Close)(
		/*[in]*/ IOleParentUndoUnit* pPUU,
		/*[in]*/ BOOL fCommit)
	{
		VSL_DEFINE_MOCK_METHOD(Close)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPUU);

		VSL_CHECK_VALIDVALUE(fCommit);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ IOleUndoUnit* pUU;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ IOleUndoUnit* pUU)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindUnitValidValues
	{
		/*[in]*/ IOleUndoUnit* pUU;
		HRESULT retValue;
	};

	STDMETHOD(FindUnit)(
		/*[in]*/ IOleUndoUnit* pUU)
	{
		VSL_DEFINE_MOCK_METHOD(FindUnit)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentStateValidValues
	{
		/*[out]*/ DWORD* pdwState;
		HRESULT retValue;
	};

	STDMETHOD(GetParentState)(
		/*[out]*/ DWORD* pdwState)
	{
		VSL_DEFINE_MOCK_METHOD(GetParentState)

		VSL_SET_VALIDVALUE(pdwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoValidValues
	{
		/*[in]*/ IOleUndoManager* pUndoManager;
		HRESULT retValue;
	};

	STDMETHOD(Do)(
		/*[in]*/ IOleUndoManager* pUndoManager)
	{
		VSL_DEFINE_MOCK_METHOD(Do)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUndoManager);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pBstr;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pBstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pBstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUnitTypeValidValues
	{
		/*[out]*/ CLSID* pClsid;
		/*[out]*/ LONG* plID;
		HRESULT retValue;
	};

	STDMETHOD(GetUnitType)(
		/*[out]*/ CLSID* pClsid,
		/*[out]*/ LONG* plID)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnitType)

		VSL_SET_VALIDVALUE(pClsid);

		VSL_SET_VALIDVALUE(plID);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnNextAddValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnNextAdd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnNextAdd)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEPARENTUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleUndoManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleUndoManagerNotImpl :
	public IOleUndoManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleUndoManagerNotImpl)

public:

	typedef IOleUndoManager Interface;

	STDMETHOD(Open)(
		/*[in]*/ IOleParentUndoUnit* /*pPUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)(
		/*[in]*/ IOleParentUndoUnit* /*pPUU*/,
		/*[in]*/ BOOL /*fCommit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ IOleUndoUnit* /*pUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOpenParentState)(
		/*[out]*/ DWORD* /*pdwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DiscardFrom)(
		/*[in]*/ IOleUndoUnit* /*pUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UndoTo)(
		/*[in]*/ IOleUndoUnit* /*pUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RedoTo)(
		/*[in]*/ IOleUndoUnit* /*pUU*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumUndoable)(
		/*[out]*/ IEnumOleUndoUnits** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumRedoable)(
		/*[out]*/ IEnumOleUndoUnits** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastUndoDescription)(
		/*[out]*/ BSTR* /*pBstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastRedoDescription)(
		/*[out]*/ BSTR* /*pBstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Enable)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL
};

class IOleUndoManagerMockImpl :
	public IOleUndoManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleUndoManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleUndoManagerMockImpl)

	typedef IOleUndoManager Interface;
	struct OpenValidValues
	{
		/*[in]*/ IOleParentUndoUnit* pPUU;
		HRESULT retValue;
	};

	STDMETHOD(Open)(
		/*[in]*/ IOleParentUndoUnit* pPUU)
	{
		VSL_DEFINE_MOCK_METHOD(Open)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		/*[in]*/ IOleParentUndoUnit* pPUU;
		/*[in]*/ BOOL fCommit;
		HRESULT retValue;
	};

	STDMETHOD(Close)(
		/*[in]*/ IOleParentUndoUnit* pPUU,
		/*[in]*/ BOOL fCommit)
	{
		VSL_DEFINE_MOCK_METHOD(Close)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPUU);

		VSL_CHECK_VALIDVALUE(fCommit);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ IOleUndoUnit* pUU;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ IOleUndoUnit* pUU)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOpenParentStateValidValues
	{
		/*[out]*/ DWORD* pdwState;
		HRESULT retValue;
	};

	STDMETHOD(GetOpenParentState)(
		/*[out]*/ DWORD* pdwState)
	{
		VSL_DEFINE_MOCK_METHOD(GetOpenParentState)

		VSL_SET_VALIDVALUE(pdwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct DiscardFromValidValues
	{
		/*[in]*/ IOleUndoUnit* pUU;
		HRESULT retValue;
	};

	STDMETHOD(DiscardFrom)(
		/*[in]*/ IOleUndoUnit* pUU)
	{
		VSL_DEFINE_MOCK_METHOD(DiscardFrom)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct UndoToValidValues
	{
		/*[in]*/ IOleUndoUnit* pUU;
		HRESULT retValue;
	};

	STDMETHOD(UndoTo)(
		/*[in]*/ IOleUndoUnit* pUU)
	{
		VSL_DEFINE_MOCK_METHOD(UndoTo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct RedoToValidValues
	{
		/*[in]*/ IOleUndoUnit* pUU;
		HRESULT retValue;
	};

	STDMETHOD(RedoTo)(
		/*[in]*/ IOleUndoUnit* pUU)
	{
		VSL_DEFINE_MOCK_METHOD(RedoTo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUU);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumUndoableValidValues
	{
		/*[out]*/ IEnumOleUndoUnits** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumUndoable)(
		/*[out]*/ IEnumOleUndoUnits** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumUndoable)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumRedoableValidValues
	{
		/*[out]*/ IEnumOleUndoUnits** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumRedoable)(
		/*[out]*/ IEnumOleUndoUnits** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumRedoable)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastUndoDescriptionValidValues
	{
		/*[out]*/ BSTR* pBstr;
		HRESULT retValue;
	};

	STDMETHOD(GetLastUndoDescription)(
		/*[out]*/ BSTR* pBstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastUndoDescription)

		VSL_SET_VALIDVALUE_BSTR(pBstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastRedoDescriptionValidValues
	{
		/*[out]*/ BSTR* pBstr;
		HRESULT retValue;
	};

	STDMETHOD(GetLastRedoDescription)(
		/*[out]*/ BSTR* pBstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastRedoDescription)

		VSL_SET_VALIDVALUE_BSTR(pBstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(Enable)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(Enable)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleObjectNotImpl :
	public IOleObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleObjectNotImpl)

public:

	typedef IOleObject Interface;

	STDMETHOD(SetClientSite)(
		/*[in,unique]*/ IOleClientSite* /*pClientSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClientSite)(
		/*[out]*/ IOleClientSite** /*ppClientSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHostNames)(
		/*[in]*/ LPCOLESTR /*szContainerApp*/,
		/*[in,unique]*/ LPCOLESTR /*szContainerObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)(
		/*[in]*/ DWORD /*dwSaveOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMoniker)(
		/*[in]*/ DWORD /*dwWhichMoniker*/,
		/*[in,unique]*/ IMoniker* /*pmk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMoniker)(
		/*[in]*/ DWORD /*dwAssign*/,
		/*[in]*/ DWORD /*dwWhichMoniker*/,
		/*[out]*/ IMoniker** /*ppmk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitFromData)(
		/*[in,unique]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ BOOL /*fCreation*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClipboardData)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[out]*/ IDataObject** /*ppDataObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoVerb)(
		/*[in]*/ LONG /*iVerb*/,
		/*[in,unique]*/ LPMSG /*lpmsg*/,
		/*[in,unique]*/ IOleClientSite* /*pActiveSite*/,
		/*[in]*/ LONG /*lindex*/,
		/*[in]*/ HWND /*hwndParent*/,
		/*[in,unique]*/ LPCRECT /*lprcPosRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumVerbs)(
		/*[out]*/ IEnumOLEVERB** /*ppEnumOleVerb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Update)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsUpToDate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserClassID)(
		/*[out]*/ CLSID* /*pClsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserType)(
		/*[in]*/ DWORD /*dwFormOfType*/,
		/*[out]*/ LPOLESTR* /*pszUserType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetExtent)(
		/*[in]*/ DWORD /*dwDrawAspect*/,
		/*[in]*/ SIZEL* /*psizel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtent)(
		/*[in]*/ DWORD /*dwDrawAspect*/,
		/*[out]*/ SIZEL* /*psizel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Advise)(
		/*[in,unique]*/ IAdviseSink* /*pAdvSink*/,
		/*[out]*/ DWORD* /*pdwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD /*dwConnection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumAdvise)(
		/*[out]*/ IEnumSTATDATA** /*ppenumAdvise*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMiscStatus)(
		/*[in]*/ DWORD /*dwAspect*/,
		/*[out]*/ DWORD* /*pdwStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetColorScheme)(
		/*[in]*/ LOGPALETTE* /*pLogpal*/)VSL_STDMETHOD_NOTIMPL
};

class IOleObjectMockImpl :
	public IOleObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleObjectMockImpl)

	typedef IOleObject Interface;
	struct SetClientSiteValidValues
	{
		/*[in,unique]*/ IOleClientSite* pClientSite;
		HRESULT retValue;
	};

	STDMETHOD(SetClientSite)(
		/*[in,unique]*/ IOleClientSite* pClientSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetClientSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClientSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClientSiteValidValues
	{
		/*[out]*/ IOleClientSite** ppClientSite;
		HRESULT retValue;
	};

	STDMETHOD(GetClientSite)(
		/*[out]*/ IOleClientSite** ppClientSite)
	{
		VSL_DEFINE_MOCK_METHOD(GetClientSite)

		VSL_SET_VALIDVALUE_INTERFACE(ppClientSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHostNamesValidValues
	{
		/*[in]*/ LPCOLESTR szContainerApp;
		/*[in,unique]*/ LPCOLESTR szContainerObj;
		HRESULT retValue;
	};

	STDMETHOD(SetHostNames)(
		/*[in]*/ LPCOLESTR szContainerApp,
		/*[in,unique]*/ LPCOLESTR szContainerObj)
	{
		VSL_DEFINE_MOCK_METHOD(SetHostNames)

		VSL_CHECK_VALIDVALUE_STRINGW(szContainerApp);

		VSL_CHECK_VALIDVALUE_STRINGW(szContainerObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		/*[in]*/ DWORD dwSaveOption;
		HRESULT retValue;
	};

	STDMETHOD(Close)(
		/*[in]*/ DWORD dwSaveOption)
	{
		VSL_DEFINE_MOCK_METHOD(Close)

		VSL_CHECK_VALIDVALUE(dwSaveOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMonikerValidValues
	{
		/*[in]*/ DWORD dwWhichMoniker;
		/*[in,unique]*/ IMoniker* pmk;
		HRESULT retValue;
	};

	STDMETHOD(SetMoniker)(
		/*[in]*/ DWORD dwWhichMoniker,
		/*[in,unique]*/ IMoniker* pmk)
	{
		VSL_DEFINE_MOCK_METHOD(SetMoniker)

		VSL_CHECK_VALIDVALUE(dwWhichMoniker);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMonikerValidValues
	{
		/*[in]*/ DWORD dwAssign;
		/*[in]*/ DWORD dwWhichMoniker;
		/*[out]*/ IMoniker** ppmk;
		HRESULT retValue;
	};

	STDMETHOD(GetMoniker)(
		/*[in]*/ DWORD dwAssign,
		/*[in]*/ DWORD dwWhichMoniker,
		/*[out]*/ IMoniker** ppmk)
	{
		VSL_DEFINE_MOCK_METHOD(GetMoniker)

		VSL_CHECK_VALIDVALUE(dwAssign);

		VSL_CHECK_VALIDVALUE(dwWhichMoniker);

		VSL_SET_VALIDVALUE_INTERFACE(ppmk);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitFromDataValidValues
	{
		/*[in,unique]*/ IDataObject* pDataObject;
		/*[in]*/ BOOL fCreation;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(InitFromData)(
		/*[in,unique]*/ IDataObject* pDataObject,
		/*[in]*/ BOOL fCreation,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(InitFromData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(fCreation);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClipboardDataValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[out]*/ IDataObject** ppDataObject;
		HRESULT retValue;
	};

	STDMETHOD(GetClipboardData)(
		/*[in]*/ DWORD dwReserved,
		/*[out]*/ IDataObject** ppDataObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetClipboardData)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE_INTERFACE(ppDataObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoVerbValidValues
	{
		/*[in]*/ LONG iVerb;
		/*[in,unique]*/ LPMSG lpmsg;
		/*[in,unique]*/ IOleClientSite* pActiveSite;
		/*[in]*/ LONG lindex;
		/*[in]*/ HWND hwndParent;
		/*[in,unique]*/ LPCRECT lprcPosRect;
		HRESULT retValue;
	};

	STDMETHOD(DoVerb)(
		/*[in]*/ LONG iVerb,
		/*[in,unique]*/ LPMSG lpmsg,
		/*[in,unique]*/ IOleClientSite* pActiveSite,
		/*[in]*/ LONG lindex,
		/*[in]*/ HWND hwndParent,
		/*[in,unique]*/ LPCRECT lprcPosRect)
	{
		VSL_DEFINE_MOCK_METHOD(DoVerb)

		VSL_CHECK_VALIDVALUE(iVerb);

		VSL_CHECK_VALIDVALUE(lpmsg);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pActiveSite);

		VSL_CHECK_VALIDVALUE(lindex);

		VSL_CHECK_VALIDVALUE(hwndParent);

		VSL_CHECK_VALIDVALUE(lprcPosRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumVerbsValidValues
	{
		/*[out]*/ IEnumOLEVERB** ppEnumOleVerb;
		HRESULT retValue;
	};

	STDMETHOD(EnumVerbs)(
		/*[out]*/ IEnumOLEVERB** ppEnumOleVerb)
	{
		VSL_DEFINE_MOCK_METHOD(EnumVerbs)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumOleVerb);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Update)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Update)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsUpToDateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsUpToDate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsUpToDate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserClassIDValidValues
	{
		/*[out]*/ CLSID* pClsid;
		HRESULT retValue;
	};

	STDMETHOD(GetUserClassID)(
		/*[out]*/ CLSID* pClsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserClassID)

		VSL_SET_VALIDVALUE(pClsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserTypeValidValues
	{
		/*[in]*/ DWORD dwFormOfType;
		/*[out]*/ LPOLESTR* pszUserType;
		HRESULT retValue;
	};

	STDMETHOD(GetUserType)(
		/*[in]*/ DWORD dwFormOfType,
		/*[out]*/ LPOLESTR* pszUserType)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserType)

		VSL_CHECK_VALIDVALUE(dwFormOfType);

		VSL_SET_VALIDVALUE(pszUserType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExtentValidValues
	{
		/*[in]*/ DWORD dwDrawAspect;
		/*[in]*/ SIZEL* psizel;
		HRESULT retValue;
	};

	STDMETHOD(SetExtent)(
		/*[in]*/ DWORD dwDrawAspect,
		/*[in]*/ SIZEL* psizel)
	{
		VSL_DEFINE_MOCK_METHOD(SetExtent)

		VSL_CHECK_VALIDVALUE(dwDrawAspect);

		VSL_CHECK_VALIDVALUE_POINTER(psizel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtentValidValues
	{
		/*[in]*/ DWORD dwDrawAspect;
		/*[out]*/ SIZEL* psizel;
		HRESULT retValue;
	};

	STDMETHOD(GetExtent)(
		/*[in]*/ DWORD dwDrawAspect,
		/*[out]*/ SIZEL* psizel)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtent)

		VSL_CHECK_VALIDVALUE(dwDrawAspect);

		VSL_SET_VALIDVALUE(psizel);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseValidValues
	{
		/*[in,unique]*/ IAdviseSink* pAdvSink;
		/*[out]*/ DWORD* pdwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Advise)(
		/*[in,unique]*/ IAdviseSink* pAdvSink,
		/*[out]*/ DWORD* pdwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Advise)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAdvSink);

		VSL_SET_VALIDVALUE(pdwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseValidValues
	{
		/*[in]*/ DWORD dwConnection;
		HRESULT retValue;
	};

	STDMETHOD(Unadvise)(
		/*[in]*/ DWORD dwConnection)
	{
		VSL_DEFINE_MOCK_METHOD(Unadvise)

		VSL_CHECK_VALIDVALUE(dwConnection);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumAdviseValidValues
	{
		/*[out]*/ IEnumSTATDATA** ppenumAdvise;
		HRESULT retValue;
	};

	STDMETHOD(EnumAdvise)(
		/*[out]*/ IEnumSTATDATA** ppenumAdvise)
	{
		VSL_DEFINE_MOCK_METHOD(EnumAdvise)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumAdvise);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMiscStatusValidValues
	{
		/*[in]*/ DWORD dwAspect;
		/*[out]*/ DWORD* pdwStatus;
		HRESULT retValue;
	};

	STDMETHOD(GetMiscStatus)(
		/*[in]*/ DWORD dwAspect,
		/*[out]*/ DWORD* pdwStatus)
	{
		VSL_DEFINE_MOCK_METHOD(GetMiscStatus)

		VSL_CHECK_VALIDVALUE(dwAspect);

		VSL_SET_VALIDVALUE(pdwStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetColorSchemeValidValues
	{
		/*[in]*/ LOGPALETTE* pLogpal;
		HRESULT retValue;
	};

	STDMETHOD(SetColorScheme)(
		/*[in]*/ LOGPALETTE* pLogpal)
	{
		VSL_DEFINE_MOCK_METHOD(SetColorScheme)

		VSL_CHECK_VALIDVALUE_POINTER(pLogpal);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceComponentSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACECOMPONENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACECOMPONENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "oleipc.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceComponentSiteNotImpl :
	public IOleInPlaceComponentSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceComponentSiteNotImpl)

public:

	typedef IOleInPlaceComponentSite Interface;

	STDMETHOD(SetUIMode)(
		/*[in]*/ DWORD /*dwUIMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceComponentSiteMockImpl :
	public IOleInPlaceComponentSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceComponentSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceComponentSiteMockImpl)

	typedef IOleInPlaceComponentSite Interface;
	struct SetUIModeValidValues
	{
		/*[in]*/ DWORD dwUIMode;
		HRESULT retValue;
	};

	STDMETHOD(SetUIMode)(
		/*[in]*/ DWORD dwUIMode)
	{
		VSL_DEFINE_MOCK_METHOD(SetUIMode)

		VSL_CHECK_VALIDVALUE(dwUIMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACECOMPONENTSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleInPlaceComponent.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEINPLACECOMPONENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEINPLACECOMPONENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "oleipc.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleInPlaceComponentNotImpl :
	public IOleInPlaceComponent
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceComponentNotImpl)

public:

	typedef IOleInPlaceComponent Interface;

	STDMETHOD(UseComponentUIManager)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[out]*/ DWORD* /*pgrfCompFlags*/,
		/*[in]*/ IOleComponentUIManager* /*pCompUIMgr*/,
		/*[in]*/ IOleInPlaceComponentSite* /*pIPCompSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnWindowActivate)(
		/*[in]*/ DWORD /*dwWindowType*/,
		/*[in]*/ BOOL /*fActivate*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE OnEnterState(
		/*[in]*/ DWORD /*dwStateId*/,
		/*[in]*/ BOOL /*fEnter*/){ return ; }

	virtual BOOL STDMETHODCALLTYPE FDoIdle(
		/*[in]*/ DWORD /*grfidlef*/){ return BOOL(); }

	virtual BOOL STDMETHODCALLTYPE FQueryClose(
		/*[in]*/ BOOL /*fPromptUser*/){ return BOOL(); }

	STDMETHOD(TranslateCntrAccelerator)(
		/*[in]*/ MSG* /*pMsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCntrContextMenu)(
		/*[in]*/ DWORD /*dwRoleActiveObj*/,
		/*[in]*/ REFCLSID /*rclsidActiveObj*/,
		/*[in]*/ LONG /*nMenuIdActiveObj*/,
		/*[in]*/ REFPOINTS /*pos*/,
		/*[out]*/ CLSID* /*pclsidCntr*/,
		/*[out]*/ OLEMENUID* /*menuid*/,
		/*[out]*/ DWORD* /*pgrf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCntrHelp)(
		/*[in,out]*/ DWORD* /*pdwRole*/,
		/*[in,out]*/ CLSID* /*pclsid*/,
		/*[in]*/ POINT /*posMouse*/,
		/*[in]*/ DWORD /*dwHelpCmd*/,
		/*[in]*/ LPOLESTR /*pszHelpFileIn*/,
		/*[out]*/ LPOLESTR* /*ppszHelpFileOut*/,
		/*[in]*/ DWORD /*dwDataIn*/,
		/*[out]*/ DWORD* /*pdwDataOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCntrMessage)(
		/*[in,out]*/ DWORD* /*pdwRole*/,
		/*[in,out]*/ CLSID* /*pclsid*/,
		/*[in]*/ LPOLESTR /*pszTitleIn*/,
		/*[in]*/ LPOLESTR /*pszTextIn*/,
		/*[in]*/ LPOLESTR /*pszHelpFileIn*/,
		/*[out]*/ LPOLESTR* /*ppszTitleOut*/,
		/*[out]*/ LPOLESTR* /*ppszTextOut*/,
		/*[out]*/ LPOLESTR* /*ppszHelpFileOut*/,
		/*[in,out]*/ DWORD* /*pdwHelpContextID*/,
		/*[in,out]*/ OLEMSGBUTTON* /*pmsgbtn*/,
		/*[in,out]*/ OLEMSGDEFBUTTON* /*pmsgdefbtn*/,
		/*[in,out]*/ OLEMSGICON* /*pmsgicon*/,
		/*[in,out]*/ BOOL* /*pfSysAlert*/)VSL_STDMETHOD_NOTIMPL
};

class IOleInPlaceComponentMockImpl :
	public IOleInPlaceComponent,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleInPlaceComponentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleInPlaceComponentMockImpl)

	typedef IOleInPlaceComponent Interface;
	struct UseComponentUIManagerValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[out]*/ DWORD* pgrfCompFlags;
		/*[in]*/ IOleComponentUIManager* pCompUIMgr;
		/*[in]*/ IOleInPlaceComponentSite* pIPCompSite;
		HRESULT retValue;
	};

	STDMETHOD(UseComponentUIManager)(
		/*[in]*/ DWORD dwCompRole,
		/*[out]*/ DWORD* pgrfCompFlags,
		/*[in]*/ IOleComponentUIManager* pCompUIMgr,
		/*[in]*/ IOleInPlaceComponentSite* pIPCompSite)
	{
		VSL_DEFINE_MOCK_METHOD(UseComponentUIManager)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_SET_VALIDVALUE(pgrfCompFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCompUIMgr);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIPCompSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnWindowActivateValidValues
	{
		/*[in]*/ DWORD dwWindowType;
		/*[in]*/ BOOL fActivate;
		HRESULT retValue;
	};

	STDMETHOD(OnWindowActivate)(
		/*[in]*/ DWORD dwWindowType,
		/*[in]*/ BOOL fActivate)
	{
		VSL_DEFINE_MOCK_METHOD(OnWindowActivate)

		VSL_CHECK_VALIDVALUE(dwWindowType);

		VSL_CHECK_VALIDVALUE(fActivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEnterStateValidValues
	{
		/*[in]*/ DWORD dwStateId;
		/*[in]*/ BOOL fEnter;
	};

	virtual void _stdcall OnEnterState(
		/*[in]*/ DWORD dwStateId,
		/*[in]*/ BOOL fEnter)
	{
		VSL_DEFINE_MOCK_METHOD(OnEnterState)

		VSL_CHECK_VALIDVALUE(dwStateId);

		VSL_CHECK_VALIDVALUE(fEnter);

	}
	struct FDoIdleValidValues
	{
		/*[in]*/ DWORD grfidlef;
		BOOL retValue;
	};

	virtual BOOL _stdcall FDoIdle(
		/*[in]*/ DWORD grfidlef)
	{
		VSL_DEFINE_MOCK_METHOD(FDoIdle)

		VSL_CHECK_VALIDVALUE(grfidlef);

		VSL_RETURN_VALIDVALUES();
	}
	struct FQueryCloseValidValues
	{
		/*[in]*/ BOOL fPromptUser;
		BOOL retValue;
	};

	virtual BOOL _stdcall FQueryClose(
		/*[in]*/ BOOL fPromptUser)
	{
		VSL_DEFINE_MOCK_METHOD(FQueryClose)

		VSL_CHECK_VALIDVALUE(fPromptUser);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateCntrAcceleratorValidValues
	{
		/*[in]*/ MSG* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateCntrAccelerator)(
		/*[in]*/ MSG* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateCntrAccelerator)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCntrContextMenuValidValues
	{
		/*[in]*/ DWORD dwRoleActiveObj;
		/*[in]*/ REFCLSID rclsidActiveObj;
		/*[in]*/ LONG nMenuIdActiveObj;
		/*[in]*/ REFPOINTS pos;
		/*[out]*/ CLSID* pclsidCntr;
		/*[out]*/ OLEMENUID* menuid;
		/*[out]*/ DWORD* pgrf;
		HRESULT retValue;
	};

	STDMETHOD(GetCntrContextMenu)(
		/*[in]*/ DWORD dwRoleActiveObj,
		/*[in]*/ REFCLSID rclsidActiveObj,
		/*[in]*/ LONG nMenuIdActiveObj,
		/*[in]*/ REFPOINTS pos,
		/*[out]*/ CLSID* pclsidCntr,
		/*[out]*/ OLEMENUID* menuid,
		/*[out]*/ DWORD* pgrf)
	{
		VSL_DEFINE_MOCK_METHOD(GetCntrContextMenu)

		VSL_CHECK_VALIDVALUE(dwRoleActiveObj);

		VSL_CHECK_VALIDVALUE(rclsidActiveObj);

		VSL_CHECK_VALIDVALUE(nMenuIdActiveObj);

		VSL_CHECK_VALIDVALUE(pos);

		VSL_SET_VALIDVALUE(pclsidCntr);

		VSL_SET_VALIDVALUE(menuid);

		VSL_SET_VALIDVALUE(pgrf);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCntrHelpValidValues
	{
		/*[in,out]*/ DWORD* pdwRole;
		/*[in,out]*/ CLSID* pclsid;
		/*[in]*/ POINT posMouse;
		/*[in]*/ DWORD dwHelpCmd;
		/*[in]*/ LPOLESTR pszHelpFileIn;
		/*[out]*/ LPOLESTR* ppszHelpFileOut;
		/*[in]*/ DWORD dwDataIn;
		/*[out]*/ DWORD* pdwDataOut;
		HRESULT retValue;
	};

	STDMETHOD(GetCntrHelp)(
		/*[in,out]*/ DWORD* pdwRole,
		/*[in,out]*/ CLSID* pclsid,
		/*[in]*/ POINT posMouse,
		/*[in]*/ DWORD dwHelpCmd,
		/*[in]*/ LPOLESTR pszHelpFileIn,
		/*[out]*/ LPOLESTR* ppszHelpFileOut,
		/*[in]*/ DWORD dwDataIn,
		/*[out]*/ DWORD* pdwDataOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetCntrHelp)

		VSL_SET_VALIDVALUE(pdwRole);

		VSL_SET_VALIDVALUE(pclsid);

		VSL_CHECK_VALIDVALUE(posMouse);

		VSL_CHECK_VALIDVALUE(dwHelpCmd);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpFileIn);

		VSL_SET_VALIDVALUE(ppszHelpFileOut);

		VSL_CHECK_VALIDVALUE(dwDataIn);

		VSL_SET_VALIDVALUE(pdwDataOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCntrMessageValidValues
	{
		/*[in,out]*/ DWORD* pdwRole;
		/*[in,out]*/ CLSID* pclsid;
		/*[in]*/ LPOLESTR pszTitleIn;
		/*[in]*/ LPOLESTR pszTextIn;
		/*[in]*/ LPOLESTR pszHelpFileIn;
		/*[out]*/ LPOLESTR* ppszTitleOut;
		/*[out]*/ LPOLESTR* ppszTextOut;
		/*[out]*/ LPOLESTR* ppszHelpFileOut;
		/*[in,out]*/ DWORD* pdwHelpContextID;
		/*[in,out]*/ OLEMSGBUTTON* pmsgbtn;
		/*[in,out]*/ OLEMSGDEFBUTTON* pmsgdefbtn;
		/*[in,out]*/ OLEMSGICON* pmsgicon;
		/*[in,out]*/ BOOL* pfSysAlert;
		HRESULT retValue;
	};

	STDMETHOD(GetCntrMessage)(
		/*[in,out]*/ DWORD* pdwRole,
		/*[in,out]*/ CLSID* pclsid,
		/*[in]*/ LPOLESTR pszTitleIn,
		/*[in]*/ LPOLESTR pszTextIn,
		/*[in]*/ LPOLESTR pszHelpFileIn,
		/*[out]*/ LPOLESTR* ppszTitleOut,
		/*[out]*/ LPOLESTR* ppszTextOut,
		/*[out]*/ LPOLESTR* ppszHelpFileOut,
		/*[in,out]*/ DWORD* pdwHelpContextID,
		/*[in,out]*/ OLEMSGBUTTON* pmsgbtn,
		/*[in,out]*/ OLEMSGDEFBUTTON* pmsgdefbtn,
		/*[in,out]*/ OLEMSGICON* pmsgicon,
		/*[in,out]*/ BOOL* pfSysAlert)
	{
		VSL_DEFINE_MOCK_METHOD(GetCntrMessage)

		VSL_SET_VALIDVALUE(pdwRole);

		VSL_SET_VALIDVALUE(pclsid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTitleIn);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTextIn);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpFileIn);

		VSL_SET_VALIDVALUE(ppszTitleOut);

		VSL_SET_VALIDVALUE(ppszTextOut);

		VSL_SET_VALIDVALUE(ppszHelpFileOut);

		VSL_SET_VALIDVALUE(pdwHelpContextID);

		VSL_SET_VALIDVALUE(pmsgbtn);

		VSL_SET_VALIDVALUE(pmsgdefbtn);

		VSL_SET_VALIDVALUE(pmsgicon);

		VSL_SET_VALIDVALUE(pfSysAlert);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEINPLACECOMPONENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleLink.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLELINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLELINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleLinkNotImpl :
	public IOleLink
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleLinkNotImpl)

public:

	typedef IOleLink Interface;

	STDMETHOD(SetUpdateOptions)(
		/*[in]*/ DWORD /*dwUpdateOpt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUpdateOptions)(
		/*[out]*/ DWORD* /*pdwUpdateOpt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSourceMoniker)(
		/*[in,unique]*/ IMoniker* /*pmk*/,
		/*[in]*/ REFCLSID /*rclsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSourceMoniker)(
		/*[out]*/ IMoniker** /*ppmk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSourceDisplayName)(
		/*[in]*/ LPCOLESTR /*pszStatusText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSourceDisplayName)(
		/*[out]*/ LPOLESTR* /*ppszDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BindToSource)(
		/*[in]*/ DWORD /*bindflags*/,
		/*[in,unique]*/ IBindCtx* /*pbc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BindIfRunning)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBoundSource)(
		/*[out]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnbindSource)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Update)(
		/*[in,unique]*/ IBindCtx* /*pbc*/)VSL_STDMETHOD_NOTIMPL
};

class IOleLinkMockImpl :
	public IOleLink,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleLinkMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleLinkMockImpl)

	typedef IOleLink Interface;
	struct SetUpdateOptionsValidValues
	{
		/*[in]*/ DWORD dwUpdateOpt;
		HRESULT retValue;
	};

	STDMETHOD(SetUpdateOptions)(
		/*[in]*/ DWORD dwUpdateOpt)
	{
		VSL_DEFINE_MOCK_METHOD(SetUpdateOptions)

		VSL_CHECK_VALIDVALUE(dwUpdateOpt);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUpdateOptionsValidValues
	{
		/*[out]*/ DWORD* pdwUpdateOpt;
		HRESULT retValue;
	};

	STDMETHOD(GetUpdateOptions)(
		/*[out]*/ DWORD* pdwUpdateOpt)
	{
		VSL_DEFINE_MOCK_METHOD(GetUpdateOptions)

		VSL_SET_VALIDVALUE(pdwUpdateOpt);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSourceMonikerValidValues
	{
		/*[in,unique]*/ IMoniker* pmk;
		/*[in]*/ REFCLSID rclsid;
		HRESULT retValue;
	};

	STDMETHOD(SetSourceMoniker)(
		/*[in,unique]*/ IMoniker* pmk,
		/*[in]*/ REFCLSID rclsid)
	{
		VSL_DEFINE_MOCK_METHOD(SetSourceMoniker)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmk);

		VSL_CHECK_VALIDVALUE(rclsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceMonikerValidValues
	{
		/*[out]*/ IMoniker** ppmk;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceMoniker)(
		/*[out]*/ IMoniker** ppmk)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceMoniker)

		VSL_SET_VALIDVALUE_INTERFACE(ppmk);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSourceDisplayNameValidValues
	{
		/*[in]*/ LPCOLESTR pszStatusText;
		HRESULT retValue;
	};

	STDMETHOD(SetSourceDisplayName)(
		/*[in]*/ LPCOLESTR pszStatusText)
	{
		VSL_DEFINE_MOCK_METHOD(SetSourceDisplayName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszStatusText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceDisplayNameValidValues
	{
		/*[out]*/ LPOLESTR* ppszDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceDisplayName)(
		/*[out]*/ LPOLESTR* ppszDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceDisplayName)

		VSL_SET_VALIDVALUE(ppszDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct BindToSourceValidValues
	{
		/*[in]*/ DWORD bindflags;
		/*[in,unique]*/ IBindCtx* pbc;
		HRESULT retValue;
	};

	STDMETHOD(BindToSource)(
		/*[in]*/ DWORD bindflags,
		/*[in,unique]*/ IBindCtx* pbc)
	{
		VSL_DEFINE_MOCK_METHOD(BindToSource)

		VSL_CHECK_VALIDVALUE(bindflags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_RETURN_VALIDVALUES();
	}
	struct BindIfRunningValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BindIfRunning)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BindIfRunning)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBoundSourceValidValues
	{
		/*[out]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetBoundSource)(
		/*[out]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetBoundSource)

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnbindSourceValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnbindSource)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnbindSource)

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		HRESULT retValue;
	};

	STDMETHOD(Update)(
		/*[in,unique]*/ IBindCtx* pbc)
	{
		VSL_DEFINE_MOCK_METHOD(Update)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLELINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleWindowNotImpl :
	public IOleWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleWindowNotImpl)

public:

	typedef IOleWindow Interface;

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL /*fEnterMode*/)VSL_STDMETHOD_NOTIMPL
};

class IOleWindowMockImpl :
	public IOleWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleWindowMockImpl)

	typedef IOleWindow Interface;
	struct GetWindowValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindow)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindow)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct ContextSensitiveHelpValidValues
	{
		/*[in]*/ BOOL fEnterMode;
		HRESULT retValue;
	};

	STDMETHOD(ContextSensitiveHelp)(
		/*[in]*/ BOOL fEnterMode)
	{
		VSL_DEFINE_MOCK_METHOD(ContextSensitiveHelp)

		VSL_CHECK_VALIDVALUE(fEnterMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOleUndoUnit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOLEUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOLEUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOleUndoUnitNotImpl :
	public IOleUndoUnit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleUndoUnitNotImpl)

public:

	typedef IOleUndoUnit Interface;

	STDMETHOD(Do)(
		/*[in]*/ IOleUndoManager* /*pUndoManager*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pBstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUnitType)(
		/*[out]*/ CLSID* /*pClsid*/,
		/*[out]*/ LONG* /*plID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnNextAdd)()VSL_STDMETHOD_NOTIMPL
};

class IOleUndoUnitMockImpl :
	public IOleUndoUnit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleUndoUnitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOleUndoUnitMockImpl)

	typedef IOleUndoUnit Interface;
	struct DoValidValues
	{
		/*[in]*/ IOleUndoManager* pUndoManager;
		HRESULT retValue;
	};

	STDMETHOD(Do)(
		/*[in]*/ IOleUndoManager* pUndoManager)
	{
		VSL_DEFINE_MOCK_METHOD(Do)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUndoManager);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pBstr;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pBstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pBstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUnitTypeValidValues
	{
		/*[out]*/ CLSID* pClsid;
		/*[out]*/ LONG* plID;
		HRESULT retValue;
	};

	STDMETHOD(GetUnitType)(
		/*[out]*/ CLSID* pClsid,
		/*[out]*/ LONG* plID)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnitType)

		VSL_SET_VALIDVALUE(pClsid);

		VSL_SET_VALIDVALUE(plID);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnNextAddValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnNextAdd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnNextAdd)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOLEUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIParseDisplayName.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPARSEDISPLAYNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPARSEDISPLAYNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OleIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IParseDisplayNameNotImpl :
	public IParseDisplayName
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IParseDisplayNameNotImpl)

public:

	typedef IParseDisplayName Interface;

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* /*pbc*/,
		/*[in]*/ LPOLESTR /*pszDisplayName*/,
		/*[out]*/ ULONG* /*pchEaten*/,
		/*[out]*/ IMoniker** /*ppmkOut*/)VSL_STDMETHOD_NOTIMPL
};

class IParseDisplayNameMockImpl :
	public IParseDisplayName,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IParseDisplayNameMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IParseDisplayNameMockImpl)

	typedef IParseDisplayName Interface;
	struct ParseDisplayNameValidValues
	{
		/*[in,unique]*/ IBindCtx* pbc;
		/*[in]*/ LPOLESTR pszDisplayName;
		/*[out]*/ ULONG* pchEaten;
		/*[out]*/ IMoniker** ppmkOut;
		HRESULT retValue;
	};

	STDMETHOD(ParseDisplayName)(
		/*[in,unique]*/ IBindCtx* pbc,
		/*[in]*/ LPOLESTR pszDisplayName,
		/*[out]*/ ULONG* pchEaten,
		/*[out]*/ IMoniker** ppmkOut)
	{
		VSL_DEFINE_MOCK_METHOD(ParseDisplayName)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDisplayName);

		VSL_SET_VALIDVALUE(pchEaten);

		VSL_SET_VALIDVALUE_INTERFACE(ppmkOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPARSEDISPLAYNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIOplockStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IOPLOCKSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IOPLOCKSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IOplockStorageNotImpl :
	public IOplockStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOplockStorageNotImpl)

public:

	typedef IOplockStorage Interface;

	STDMETHOD(CreateStorageEx)(
		/*[in]*/ LPCWSTR /*pwcsName*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in]*/ DWORD /*stgfmt*/,
		/*[in]*/ DWORD /*grfAttrs*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppstgOpen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenStorageEx)(
		/*[in]*/ LPCWSTR /*pwcsName*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in]*/ DWORD /*stgfmt*/,
		/*[in]*/ DWORD /*grfAttrs*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppstgOpen*/)VSL_STDMETHOD_NOTIMPL
};

class IOplockStorageMockImpl :
	public IOplockStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOplockStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IOplockStorageMockImpl)

	typedef IOplockStorage Interface;
	struct CreateStorageExValidValues
	{
		/*[in]*/ LPCWSTR pwcsName;
		/*[in]*/ DWORD grfMode;
		/*[in]*/ DWORD stgfmt;
		/*[in]*/ DWORD grfAttrs;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppstgOpen;
		HRESULT retValue;
	};

	STDMETHOD(CreateStorageEx)(
		/*[in]*/ LPCWSTR pwcsName,
		/*[in]*/ DWORD grfMode,
		/*[in]*/ DWORD stgfmt,
		/*[in]*/ DWORD grfAttrs,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppstgOpen)
	{
		VSL_DEFINE_MOCK_METHOD(CreateStorageEx)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(stgfmt);

		VSL_CHECK_VALIDVALUE(grfAttrs);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppstgOpen);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenStorageExValidValues
	{
		/*[in]*/ LPCWSTR pwcsName;
		/*[in]*/ DWORD grfMode;
		/*[in]*/ DWORD stgfmt;
		/*[in]*/ DWORD grfAttrs;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppstgOpen;
		HRESULT retValue;
	};

	STDMETHOD(OpenStorageEx)(
		/*[in]*/ LPCWSTR pwcsName,
		/*[in]*/ DWORD grfMode,
		/*[in]*/ DWORD stgfmt,
		/*[in]*/ DWORD grfAttrs,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppstgOpen)
	{
		VSL_DEFINE_MOCK_METHOD(OpenStorageEx)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(stgfmt);

		VSL_CHECK_VALIDVALUE(grfAttrs);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppstgOpen);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IOPLOCKSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPerPropertyBrowsing2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERPROPERTYBROWSING2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERPROPERTYBROWSING2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ocdesign.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPerPropertyBrowsing2NotImpl :
	public IPerPropertyBrowsing2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPerPropertyBrowsing2NotImpl)

public:

	typedef IPerPropertyBrowsing2 Interface;

	STDMETHOD(MapPropertyToBuilder)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out]*/ GUID* /*pguidBuilder*/,
		/*[out]*/ DWORD* /*pdwType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecuteBuilder)(
		/*[in]*/ DISPID /*dispid*/,
		/*[in]*/ REFGUID /*rguidBuilder*/,
		/*[in]*/ IDispatch* /*pdispApp*/,
		/*[in]*/ HWND /*hwndBuilderOwner*/,
		/*[in,out]*/ VARIANT* /*pvarValue*/)VSL_STDMETHOD_NOTIMPL
};

class IPerPropertyBrowsing2MockImpl :
	public IPerPropertyBrowsing2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPerPropertyBrowsing2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPerPropertyBrowsing2MockImpl)

	typedef IPerPropertyBrowsing2 Interface;
	struct MapPropertyToBuilderValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out]*/ GUID* pguidBuilder;
		/*[out]*/ DWORD* pdwType;
		HRESULT retValue;
	};

	STDMETHOD(MapPropertyToBuilder)(
		/*[in]*/ DISPID dispid,
		/*[out]*/ GUID* pguidBuilder,
		/*[out]*/ DWORD* pdwType)
	{
		VSL_DEFINE_MOCK_METHOD(MapPropertyToBuilder)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(pguidBuilder);

		VSL_SET_VALIDVALUE(pdwType);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecuteBuilderValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[in]*/ REFGUID rguidBuilder;
		/*[in]*/ IDispatch* pdispApp;
		/*[in]*/ HWND hwndBuilderOwner;
		/*[in,out]*/ VARIANT* pvarValue;
		HRESULT retValue;
	};

	STDMETHOD(ExecuteBuilder)(
		/*[in]*/ DISPID dispid,
		/*[in]*/ REFGUID rguidBuilder,
		/*[in]*/ IDispatch* pdispApp,
		/*[in]*/ HWND hwndBuilderOwner,
		/*[in,out]*/ VARIANT* pvarValue)
	{
		VSL_DEFINE_MOCK_METHOD(ExecuteBuilder)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_CHECK_VALIDVALUE(rguidBuilder);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pdispApp);

		VSL_CHECK_VALIDVALUE(hwndBuilderOwner);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERPROPERTYBROWSING2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersist.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistNotImpl :
	public IPersist
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistNotImpl)

public:

	typedef IPersist Interface;

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistMockImpl :
	public IPersist,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistMockImpl)

	typedef IPersist Interface;
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPerPropertyBrowsing.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPerPropertyBrowsingNotImpl :
	public IPerPropertyBrowsing
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPerPropertyBrowsingNotImpl)

public:

	typedef IPerPropertyBrowsing Interface;

	STDMETHOD(GetDisplayString)(
		/*[in]*/ DISPID /*dispID*/,
		/*[out]*/ BSTR* /*pBstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapPropertyToPage)(
		/*[in]*/ DISPID /*dispID*/,
		/*[out]*/ CLSID* /*pClsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPredefinedStrings)(
		/*[in]*/ DISPID /*dispID*/,
		/*[out]*/ CALPOLESTR* /*pCaStringsOut*/,
		/*[out]*/ CADWORD* /*pCaCookiesOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPredefinedValue)(
		/*[in]*/ DISPID /*dispID*/,
		/*[in]*/ DWORD /*dwCookie*/,
		/*[out]*/ VARIANT* /*pVarOut*/)VSL_STDMETHOD_NOTIMPL
};

class IPerPropertyBrowsingMockImpl :
	public IPerPropertyBrowsing,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPerPropertyBrowsingMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPerPropertyBrowsingMockImpl)

	typedef IPerPropertyBrowsing Interface;
	struct GetDisplayStringValidValues
	{
		/*[in]*/ DISPID dispID;
		/*[out]*/ BSTR* pBstr;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayString)(
		/*[in]*/ DISPID dispID,
		/*[out]*/ BSTR* pBstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayString)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_SET_VALIDVALUE_BSTR(pBstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapPropertyToPageValidValues
	{
		/*[in]*/ DISPID dispID;
		/*[out]*/ CLSID* pClsid;
		HRESULT retValue;
	};

	STDMETHOD(MapPropertyToPage)(
		/*[in]*/ DISPID dispID,
		/*[out]*/ CLSID* pClsid)
	{
		VSL_DEFINE_MOCK_METHOD(MapPropertyToPage)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_SET_VALIDVALUE(pClsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPredefinedStringsValidValues
	{
		/*[in]*/ DISPID dispID;
		/*[out]*/ CALPOLESTR* pCaStringsOut;
		/*[out]*/ CADWORD* pCaCookiesOut;
		HRESULT retValue;
	};

	STDMETHOD(GetPredefinedStrings)(
		/*[in]*/ DISPID dispID,
		/*[out]*/ CALPOLESTR* pCaStringsOut,
		/*[out]*/ CADWORD* pCaCookiesOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetPredefinedStrings)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_SET_VALIDVALUE(pCaStringsOut);

		VSL_SET_VALIDVALUE(pCaCookiesOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPredefinedValueValidValues
	{
		/*[in]*/ DISPID dispID;
		/*[in]*/ DWORD dwCookie;
		/*[out]*/ VARIANT* pVarOut;
		HRESULT retValue;
	};

	STDMETHOD(GetPredefinedValue)(
		/*[in]*/ DISPID dispID,
		/*[in]*/ DWORD dwCookie,
		/*[out]*/ VARIANT* pVarOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetPredefinedValue)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_SET_VALIDVALUE_VARIANT(pVarOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistFile.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTFILE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTFILE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistFileNotImpl :
	public IPersistFile
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistFileNotImpl)

public:

	typedef IPersistFile Interface;

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in]*/ LPCOLESTR /*pszFileName*/,
		/*[in]*/ DWORD /*dwMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in,unique]*/ LPCOLESTR /*pszFileName*/,
		/*[in]*/ BOOL /*fRemember*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveCompleted)(
		/*[in,unique]*/ LPCOLESTR /*pszFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurFile)(
		/*[out]*/ LPOLESTR* /*ppszFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistFileMockImpl :
	public IPersistFile,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistFileMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistFileMockImpl)

	typedef IPersistFile Interface;
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in]*/ LPCOLESTR pszFileName;
		/*[in]*/ DWORD dwMode;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in]*/ LPCOLESTR pszFileName,
		/*[in]*/ DWORD dwMode)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE(dwMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in,unique]*/ LPCOLESTR pszFileName;
		/*[in]*/ BOOL fRemember;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in,unique]*/ LPCOLESTR pszFileName,
		/*[in]*/ BOOL fRemember)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE(fRemember);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveCompletedValidValues
	{
		/*[in,unique]*/ LPCOLESTR pszFileName;
		HRESULT retValue;
	};

	STDMETHOD(SaveCompleted)(
		/*[in,unique]*/ LPCOLESTR pszFileName)
	{
		VSL_DEFINE_MOCK_METHOD(SaveCompleted)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurFileValidValues
	{
		/*[out]*/ LPOLESTR* ppszFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetCurFile)(
		/*[out]*/ LPOLESTR* ppszFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurFile)

		VSL_SET_VALIDVALUE(ppszFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTFILE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistFileCheckSum.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTFILECHECKSUM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTFILECHECKSUM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistFileCheckSumNotImpl :
	public IPersistFileCheckSum
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistFileCheckSumNotImpl)

public:

	typedef IPersistFileCheckSum Interface;

	STDMETHOD(CalculateCheckSum)(
		/*[in]*/ REFGUID /*guidCheckSumAlgorithm*/,
		/*[in]*/ DWORD /*cbBufferSize*/,
		/*[out,size_is(cbBufferSize)]*/ BYTE* /*pbHash*/,
		/*[out]*/ DWORD* /*pcbActualSize*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistFileCheckSumMockImpl :
	public IPersistFileCheckSum,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistFileCheckSumMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistFileCheckSumMockImpl)

	typedef IPersistFileCheckSum Interface;
	struct CalculateCheckSumValidValues
	{
		/*[in]*/ REFGUID guidCheckSumAlgorithm;
		/*[in]*/ DWORD cbBufferSize;
		/*[out,size_is(cbBufferSize)]*/ BYTE* pbHash;
		/*[out]*/ DWORD* pcbActualSize;
		HRESULT retValue;
	};

	STDMETHOD(CalculateCheckSum)(
		/*[in]*/ REFGUID guidCheckSumAlgorithm,
		/*[in]*/ DWORD cbBufferSize,
		/*[out,size_is(cbBufferSize)]*/ BYTE* pbHash,
		/*[out]*/ DWORD* pcbActualSize)
	{
		VSL_DEFINE_MOCK_METHOD(CalculateCheckSum)

		VSL_CHECK_VALIDVALUE(guidCheckSumAlgorithm);

		VSL_CHECK_VALIDVALUE(cbBufferSize);

		VSL_SET_VALIDVALUE_MEMCPY(pbHash, cbBufferSize*sizeof(pbHash[0]), validValues.cbBufferSize*sizeof(validValues.pbHash[0]));

		VSL_SET_VALIDVALUE(pcbActualSize);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTFILECHECKSUM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistPropertyBag.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTPROPERTYBAG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTPROPERTYBAG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistPropertyBagNotImpl :
	public IPersistPropertyBag
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistPropertyBagNotImpl)

public:

	typedef IPersistPropertyBag Interface;

	STDMETHOD(InitNew)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in]*/ IPropertyBag* /*pPropBag*/,
		/*[in]*/ IErrorLog* /*pErrorLog*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in]*/ IPropertyBag* /*pPropBag*/,
		/*[in]*/ BOOL /*fClearDirty*/,
		/*[in]*/ BOOL /*fSaveAllProperties*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistPropertyBagMockImpl :
	public IPersistPropertyBag,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistPropertyBagMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistPropertyBagMockImpl)

	typedef IPersistPropertyBag Interface;
	struct InitNewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(InitNew)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(InitNew)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in]*/ IPropertyBag* pPropBag;
		/*[in]*/ IErrorLog* pErrorLog;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in]*/ IPropertyBag* pPropBag,
		/*[in]*/ IErrorLog* pErrorLog)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPropBag);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrorLog);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in]*/ IPropertyBag* pPropBag;
		/*[in]*/ BOOL fClearDirty;
		/*[in]*/ BOOL fSaveAllProperties;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in]*/ IPropertyBag* pPropBag,
		/*[in]*/ BOOL fClearDirty,
		/*[in]*/ BOOL fSaveAllProperties)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPropBag);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_CHECK_VALIDVALUE(fSaveAllProperties);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTPROPERTYBAG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistMemory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTMEMORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTMEMORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistMemoryNotImpl :
	public IPersistMemory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistMemoryNotImpl)

public:

	typedef IPersistMemory Interface;

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in,size_is(cbSize)]*/ LPVOID /*pMem*/,
		/*[in]*/ ULONG /*cbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[out,size_is(cbSize)]*/ LPVOID /*pMem*/,
		/*[in]*/ BOOL /*fClearDirty*/,
		/*[in]*/ ULONG /*cbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULONG* /*pCbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitNew)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistMemoryMockImpl :
	public IPersistMemory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistMemoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistMemoryMockImpl)

	typedef IPersistMemory Interface;
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in,size_is(cbSize)]*/ LPVOID pMem;
		/*[in]*/ ULONG cbSize;
		HRESULT retValue;
		size_t pMem_size_in_bytes;
	};

	STDMETHOD(Load)(
		/*[in,size_is(cbSize)]*/ LPVOID pMem,
		/*[in]*/ ULONG cbSize)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_MEMCMP(pMem, cbSize, validValues.cbSize);

		VSL_CHECK_VALIDVALUE(cbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[out,size_is(cbSize)]*/ LPVOID pMem;
		/*[in]*/ BOOL fClearDirty;
		/*[in]*/ ULONG cbSize;
		HRESULT retValue;
		size_t pMem_size_in_bytes;
	};

	STDMETHOD(Save)(
		/*[out,size_is(cbSize)]*/ LPVOID pMem,
		/*[in]*/ BOOL fClearDirty,
		/*[in]*/ ULONG cbSize)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_SET_VALIDVALUE_MEMCPY(pMem, cbSize, validValues.cbSize);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_CHECK_VALIDVALUE(cbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeMaxValidValues
	{
		/*[out]*/ ULONG* pCbSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULONG* pCbSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeMax)

		VSL_SET_VALIDVALUE(pCbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitNewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(InitNew)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(InitNew)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTMEMORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistFileFormat.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTFILEFORMAT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTFILEFORMAT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "fpstfmt.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistFileFormatNotImpl :
	public IPersistFileFormat
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistFileFormatNotImpl)

public:

	typedef IPersistFileFormat Interface;

	STDMETHOD(IsDirty)(
		/*[out]*/ BOOL* /*pfIsDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitNew)(
		/*[in]*/ DWORD /*nFormatIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in]*/ BOOL /*fReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ BOOL /*fRemember*/,
		/*[in]*/ DWORD /*nFormatIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveCompleted)(
		/*[in]*/ LPCOLESTR /*pszFilename*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurFile)(
		/*[out]*/ LPOLESTR* /*ppszFilename*/,
		/*[out]*/ DWORD* /*pnFormatIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFormatList)(
		/*[out]*/ LPOLESTR* /*ppszFormatList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistFileFormatMockImpl :
	public IPersistFileFormat,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistFileFormatMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistFileFormatMockImpl)

	typedef IPersistFileFormat Interface;
	struct IsDirtyValidValues
	{
		/*[out]*/ BOOL* pfIsDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)(
		/*[out]*/ BOOL* pfIsDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsDirty)

		VSL_SET_VALIDVALUE(pfIsDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitNewValidValues
	{
		/*[in]*/ DWORD nFormatIndex;
		HRESULT retValue;
	};

	STDMETHOD(InitNew)(
		/*[in]*/ DWORD nFormatIndex)
	{
		VSL_DEFINE_MOCK_METHOD(InitNew)

		VSL_CHECK_VALIDVALUE(nFormatIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ DWORD grfMode;
		/*[in]*/ BOOL fReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ DWORD grfMode,
		/*[in]*/ BOOL fReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(fReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ BOOL fRemember;
		/*[in]*/ DWORD nFormatIndex;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ BOOL fRemember,
		/*[in]*/ DWORD nFormatIndex)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE(fRemember);

		VSL_CHECK_VALIDVALUE(nFormatIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveCompletedValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		HRESULT retValue;
	};

	STDMETHOD(SaveCompleted)(
		/*[in]*/ LPCOLESTR pszFilename)
	{
		VSL_DEFINE_MOCK_METHOD(SaveCompleted)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurFileValidValues
	{
		/*[out]*/ LPOLESTR* ppszFilename;
		/*[out]*/ DWORD* pnFormatIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetCurFile)(
		/*[out]*/ LPOLESTR* ppszFilename,
		/*[out]*/ DWORD* pnFormatIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurFile)

		VSL_SET_VALIDVALUE(ppszFilename);

		VSL_SET_VALIDVALUE(pnFormatIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFormatListValidValues
	{
		/*[out]*/ LPOLESTR* ppszFormatList;
		HRESULT retValue;
	};

	STDMETHOD(GetFormatList)(
		/*[out]*/ LPOLESTR* ppszFormatList)
	{
		VSL_DEFINE_MOCK_METHOD(GetFormatList)

		VSL_SET_VALIDVALUE(ppszFormatList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTFILEFORMAT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistStorageNotImpl :
	public IPersistStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistStorageNotImpl)

public:

	typedef IPersistStorage Interface;

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitNew)(
		/*[in,unique]*/ IStorage* /*pStg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in,unique]*/ IStorage* /*pStg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in,unique]*/ IStorage* /*pStgSave*/,
		/*[in]*/ BOOL /*fSameAsLoad*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveCompleted)(
		/*[in,unique]*/ IStorage* /*pStgNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandsOffStorage)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistStorageMockImpl :
	public IPersistStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistStorageMockImpl)

	typedef IPersistStorage Interface;
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct InitNewValidValues
	{
		/*[in,unique]*/ IStorage* pStg;
		HRESULT retValue;
	};

	STDMETHOD(InitNew)(
		/*[in,unique]*/ IStorage* pStg)
	{
		VSL_DEFINE_MOCK_METHOD(InitNew)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStg);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in,unique]*/ IStorage* pStg;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in,unique]*/ IStorage* pStg)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStg);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in,unique]*/ IStorage* pStgSave;
		/*[in]*/ BOOL fSameAsLoad;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in,unique]*/ IStorage* pStgSave,
		/*[in]*/ BOOL fSameAsLoad)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStgSave);

		VSL_CHECK_VALIDVALUE(fSameAsLoad);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveCompletedValidValues
	{
		/*[in,unique]*/ IStorage* pStgNew;
		HRESULT retValue;
	};

	STDMETHOD(SaveCompleted)(
		/*[in,unique]*/ IStorage* pStgNew)
	{
		VSL_DEFINE_MOCK_METHOD(SaveCompleted)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStgNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct HandsOffStorageValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HandsOffStorage)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HandsOffStorage)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistStreamInit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTSTREAMINIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTSTREAMINIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistStreamInitNotImpl :
	public IPersistStreamInit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistStreamInitNotImpl)

public:

	typedef IPersistStreamInit Interface;

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in]*/ LPSTREAM /*pStm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in]*/ LPSTREAM /*pStm*/,
		/*[in]*/ BOOL /*fClearDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULARGE_INTEGER* /*pCbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitNew)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistStreamInitMockImpl :
	public IPersistStreamInit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistStreamInitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistStreamInitMockImpl)

	typedef IPersistStreamInit Interface;
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in]*/ LPSTREAM pStm;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in]*/ LPSTREAM pStm)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE(pStm);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in]*/ LPSTREAM pStm;
		/*[in]*/ BOOL fClearDirty;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in]*/ LPSTREAM pStm,
		/*[in]*/ BOOL fClearDirty)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE(pStm);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeMaxValidValues
	{
		/*[out]*/ ULARGE_INTEGER* pCbSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULARGE_INTEGER* pCbSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeMax)

		VSL_SET_VALIDVALUE(pCbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitNewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(InitNew)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(InitNew)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTSTREAMINIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistPropertyBag2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTPROPERTYBAG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTPROPERTYBAG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistPropertyBag2NotImpl :
	public IPersistPropertyBag2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistPropertyBag2NotImpl)

public:

	typedef IPersistPropertyBag2 Interface;

	STDMETHOD(InitNew)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in]*/ IPropertyBag2* /*pPropBag*/,
		/*[in]*/ IErrorLog* /*pErrLog*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in]*/ IPropertyBag2* /*pPropBag*/,
		/*[in]*/ BOOL /*fClearDirty*/,
		/*[in]*/ BOOL /*fSaveAllProperties*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistPropertyBag2MockImpl :
	public IPersistPropertyBag2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistPropertyBag2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistPropertyBag2MockImpl)

	typedef IPersistPropertyBag2 Interface;
	struct InitNewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(InitNew)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(InitNew)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in]*/ IPropertyBag2* pPropBag;
		/*[in]*/ IErrorLog* pErrLog;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in]*/ IPropertyBag2* pPropBag,
		/*[in]*/ IErrorLog* pErrLog)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPropBag);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrLog);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in]*/ IPropertyBag2* pPropBag;
		/*[in]*/ BOOL fClearDirty;
		/*[in]*/ BOOL fSaveAllProperties;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in]*/ IPropertyBag2* pPropBag,
		/*[in]*/ BOOL fClearDirty,
		/*[in]*/ BOOL fSaveAllProperties)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPropBag);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_CHECK_VALIDVALUE(fSaveAllProperties);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTPROPERTYBAG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistStream.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTSTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTSTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistStreamNotImpl :
	public IPersistStream
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistStreamNotImpl)

public:

	typedef IPersistStream Interface;

	STDMETHOD(IsDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in,unique]*/ IStream* /*pStm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in,unique]*/ IStream* /*pStm*/,
		/*[in]*/ BOOL /*fClearDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULARGE_INTEGER* /*pcbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistStreamMockImpl :
	public IPersistStream,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistStreamMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistStreamMockImpl)

	typedef IPersistStream Interface;
	struct IsDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in,unique]*/ IStream* pStm)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in,unique]*/ IStream* pStm;
		/*[in]*/ BOOL fClearDirty;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in,unique]*/ IStream* pStm,
		/*[in]*/ BOOL fClearDirty)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStm);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeMaxValidValues
	{
		/*[out]*/ ULARGE_INTEGER* pcbSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeMax)(
		/*[out]*/ ULARGE_INTEGER* pcbSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeMax)

		VSL_SET_VALIDVALUE(pcbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassIDValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetClassID)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassID)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTSTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPicture.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPICTURE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPICTURE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPictureNotImpl :
	public IPicture
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPictureNotImpl)

public:

	typedef IPicture Interface;

	STDMETHOD(get_Handle)(
		/*[out]*/ OLE_HANDLE* /*pHandle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_hPal)(
		/*[out]*/ OLE_HANDLE* /*phPal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out]*/ SHORT* /*pType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Width)(
		/*[out]*/ OLE_XSIZE_HIMETRIC* /*pWidth*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Height)(
		/*[out]*/ OLE_YSIZE_HIMETRIC* /*pHeight*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Render)(
		/*[in]*/ HDC /*hDC*/,
		/*[in]*/ LONG /*x*/,
		/*[in]*/ LONG /*y*/,
		/*[in]*/ LONG /*cx*/,
		/*[in]*/ LONG /*cy*/,
		/*[in]*/ OLE_XPOS_HIMETRIC /*xSrc*/,
		/*[in]*/ OLE_YPOS_HIMETRIC /*ySrc*/,
		/*[in]*/ OLE_XSIZE_HIMETRIC /*cxSrc*/,
		/*[in]*/ OLE_YSIZE_HIMETRIC /*cySrc*/,
		/*[in]*/ LPCRECT /*pRcWBounds*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(set_hPal)(
		/*[in]*/ OLE_HANDLE /*hPal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CurDC)(
		/*[out]*/ HDC* /*phDC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectPicture)(
		/*[in]*/ HDC /*hDCIn*/,
		/*[out]*/ HDC* /*phDCOut*/,
		/*[out]*/ OLE_HANDLE* /*phBmpOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_KeepOriginalFormat)(
		/*[out]*/ BOOL* /*pKeep*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_KeepOriginalFormat)(
		/*[in]*/ BOOL /*keep*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PictureChanged)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveAsFile)(
		/*[in]*/ LPSTREAM /*pStream*/,
		/*[in]*/ BOOL /*fSaveMemCopy*/,
		/*[out]*/ LONG* /*pCbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Attributes)(
		/*[out]*/ DWORD* /*pDwAttr*/)VSL_STDMETHOD_NOTIMPL
};

class IPictureMockImpl :
	public IPicture,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPictureMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPictureMockImpl)

	typedef IPicture Interface;
	struct get_HandleValidValues
	{
		/*[out]*/ OLE_HANDLE* pHandle;
		HRESULT retValue;
	};

	STDMETHOD(get_Handle)(
		/*[out]*/ OLE_HANDLE* pHandle)
	{
		VSL_DEFINE_MOCK_METHOD(get_Handle)

		VSL_SET_VALIDVALUE(pHandle);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_hPalValidValues
	{
		/*[out]*/ OLE_HANDLE* phPal;
		HRESULT retValue;
	};

	STDMETHOD(get_hPal)(
		/*[out]*/ OLE_HANDLE* phPal)
	{
		VSL_DEFINE_MOCK_METHOD(get_hPal)

		VSL_SET_VALIDVALUE(phPal);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out]*/ SHORT* pType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ SHORT* pType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WidthValidValues
	{
		/*[out]*/ OLE_XSIZE_HIMETRIC* pWidth;
		HRESULT retValue;
	};

	STDMETHOD(get_Width)(
		/*[out]*/ OLE_XSIZE_HIMETRIC* pWidth)
	{
		VSL_DEFINE_MOCK_METHOD(get_Width)

		VSL_SET_VALIDVALUE(pWidth);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HeightValidValues
	{
		/*[out]*/ OLE_YSIZE_HIMETRIC* pHeight;
		HRESULT retValue;
	};

	STDMETHOD(get_Height)(
		/*[out]*/ OLE_YSIZE_HIMETRIC* pHeight)
	{
		VSL_DEFINE_MOCK_METHOD(get_Height)

		VSL_SET_VALIDVALUE(pHeight);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenderValidValues
	{
		/*[in]*/ HDC hDC;
		/*[in]*/ LONG x;
		/*[in]*/ LONG y;
		/*[in]*/ LONG cx;
		/*[in]*/ LONG cy;
		/*[in]*/ OLE_XPOS_HIMETRIC xSrc;
		/*[in]*/ OLE_YPOS_HIMETRIC ySrc;
		/*[in]*/ OLE_XSIZE_HIMETRIC cxSrc;
		/*[in]*/ OLE_YSIZE_HIMETRIC cySrc;
		/*[in]*/ LPCRECT pRcWBounds;
		HRESULT retValue;
	};

	STDMETHOD(Render)(
		/*[in]*/ HDC hDC,
		/*[in]*/ LONG x,
		/*[in]*/ LONG y,
		/*[in]*/ LONG cx,
		/*[in]*/ LONG cy,
		/*[in]*/ OLE_XPOS_HIMETRIC xSrc,
		/*[in]*/ OLE_YPOS_HIMETRIC ySrc,
		/*[in]*/ OLE_XSIZE_HIMETRIC cxSrc,
		/*[in]*/ OLE_YSIZE_HIMETRIC cySrc,
		/*[in]*/ LPCRECT pRcWBounds)
	{
		VSL_DEFINE_MOCK_METHOD(Render)

		VSL_CHECK_VALIDVALUE(hDC);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_CHECK_VALIDVALUE(xSrc);

		VSL_CHECK_VALIDVALUE(ySrc);

		VSL_CHECK_VALIDVALUE(cxSrc);

		VSL_CHECK_VALIDVALUE(cySrc);

		VSL_CHECK_VALIDVALUE(pRcWBounds);

		VSL_RETURN_VALIDVALUES();
	}
	struct set_hPalValidValues
	{
		/*[in]*/ OLE_HANDLE hPal;
		HRESULT retValue;
	};

	STDMETHOD(set_hPal)(
		/*[in]*/ OLE_HANDLE hPal)
	{
		VSL_DEFINE_MOCK_METHOD(set_hPal)

		VSL_CHECK_VALIDVALUE(hPal);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CurDCValidValues
	{
		/*[out]*/ HDC* phDC;
		HRESULT retValue;
	};

	STDMETHOD(get_CurDC)(
		/*[out]*/ HDC* phDC)
	{
		VSL_DEFINE_MOCK_METHOD(get_CurDC)

		VSL_SET_VALIDVALUE(phDC);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectPictureValidValues
	{
		/*[in]*/ HDC hDCIn;
		/*[out]*/ HDC* phDCOut;
		/*[out]*/ OLE_HANDLE* phBmpOut;
		HRESULT retValue;
	};

	STDMETHOD(SelectPicture)(
		/*[in]*/ HDC hDCIn,
		/*[out]*/ HDC* phDCOut,
		/*[out]*/ OLE_HANDLE* phBmpOut)
	{
		VSL_DEFINE_MOCK_METHOD(SelectPicture)

		VSL_CHECK_VALIDVALUE(hDCIn);

		VSL_SET_VALIDVALUE(phDCOut);

		VSL_SET_VALIDVALUE(phBmpOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_KeepOriginalFormatValidValues
	{
		/*[out]*/ BOOL* pKeep;
		HRESULT retValue;
	};

	STDMETHOD(get_KeepOriginalFormat)(
		/*[out]*/ BOOL* pKeep)
	{
		VSL_DEFINE_MOCK_METHOD(get_KeepOriginalFormat)

		VSL_SET_VALIDVALUE(pKeep);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_KeepOriginalFormatValidValues
	{
		/*[in]*/ BOOL keep;
		HRESULT retValue;
	};

	STDMETHOD(put_KeepOriginalFormat)(
		/*[in]*/ BOOL keep)
	{
		VSL_DEFINE_MOCK_METHOD(put_KeepOriginalFormat)

		VSL_CHECK_VALIDVALUE(keep);

		VSL_RETURN_VALIDVALUES();
	}
	struct PictureChangedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(PictureChanged)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(PictureChanged)

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveAsFileValidValues
	{
		/*[in]*/ LPSTREAM pStream;
		/*[in]*/ BOOL fSaveMemCopy;
		/*[out]*/ LONG* pCbSize;
		HRESULT retValue;
	};

	STDMETHOD(SaveAsFile)(
		/*[in]*/ LPSTREAM pStream,
		/*[in]*/ BOOL fSaveMemCopy,
		/*[out]*/ LONG* pCbSize)
	{
		VSL_DEFINE_MOCK_METHOD(SaveAsFile)

		VSL_CHECK_VALIDVALUE(pStream);

		VSL_CHECK_VALIDVALUE(fSaveMemCopy);

		VSL_SET_VALIDVALUE(pCbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AttributesValidValues
	{
		/*[out]*/ DWORD* pDwAttr;
		HRESULT retValue;
	};

	STDMETHOD(get_Attributes)(
		/*[out]*/ DWORD* pDwAttr)
	{
		VSL_DEFINE_MOCK_METHOD(get_Attributes)

		VSL_SET_VALIDVALUE(pDwAttr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPICTURE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPictureDisp.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPICTUREDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPICTUREDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPictureDispNotImpl :
	public IPictureDisp
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPictureDispNotImpl)

public:

	typedef IPictureDisp Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IPictureDispMockImpl :
	public IPictureDisp,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPictureDispMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPictureDispMockImpl)

	typedef IPictureDisp Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPICTUREDISP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPersistXMLFragment.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPERSISTXMLFRAGMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPERSISTXMLFRAGMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPersistXMLFragmentNotImpl :
	public IPersistXMLFragment
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistXMLFragmentNotImpl)

public:

	typedef IPersistXMLFragment Interface;

	STDMETHOD(InitNew)(
		/*[in]*/ REFGUID /*guidFlavor*/,
		/*[in]*/ PersistStorageType /*storage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsFragmentDirty)(
		/*[in]*/ PersistStorageType /*storage*/,
		/*[out]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Load)(
		/*[in]*/ REFGUID /*guidFlavor*/,
		/*[in]*/ PersistStorageType /*storage*/,
		/*[in]*/ LPCOLESTR /*pszXMLFragment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in]*/ REFGUID /*guidFlavor*/,
		/*[in]*/ PersistStorageType /*storage*/,
		/*[out]*/ BSTR* /*pbstrXMLFragment*/,
		/*[in]*/ BOOL /*fClearDirty*/)VSL_STDMETHOD_NOTIMPL
};

class IPersistXMLFragmentMockImpl :
	public IPersistXMLFragment,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPersistXMLFragmentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPersistXMLFragmentMockImpl)

	typedef IPersistXMLFragment Interface;
	struct InitNewValidValues
	{
		/*[in]*/ REFGUID guidFlavor;
		/*[in]*/ PersistStorageType storage;
		HRESULT retValue;
	};

	STDMETHOD(InitNew)(
		/*[in]*/ REFGUID guidFlavor,
		/*[in]*/ PersistStorageType storage)
	{
		VSL_DEFINE_MOCK_METHOD(InitNew)

		VSL_CHECK_VALIDVALUE(guidFlavor);

		VSL_CHECK_VALIDVALUE(storage);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsFragmentDirtyValidValues
	{
		/*[in]*/ PersistStorageType storage;
		/*[out]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsFragmentDirty)(
		/*[in]*/ PersistStorageType storage,
		/*[out]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsFragmentDirty)

		VSL_CHECK_VALIDVALUE(storage);

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadValidValues
	{
		/*[in]*/ REFGUID guidFlavor;
		/*[in]*/ PersistStorageType storage;
		/*[in]*/ LPCOLESTR pszXMLFragment;
		HRESULT retValue;
	};

	STDMETHOD(Load)(
		/*[in]*/ REFGUID guidFlavor,
		/*[in]*/ PersistStorageType storage,
		/*[in]*/ LPCOLESTR pszXMLFragment)
	{
		VSL_DEFINE_MOCK_METHOD(Load)

		VSL_CHECK_VALIDVALUE(guidFlavor);

		VSL_CHECK_VALIDVALUE(storage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszXMLFragment);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in]*/ REFGUID guidFlavor;
		/*[in]*/ PersistStorageType storage;
		/*[out]*/ BSTR* pbstrXMLFragment;
		/*[in]*/ BOOL fClearDirty;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in]*/ REFGUID guidFlavor,
		/*[in]*/ PersistStorageType storage,
		/*[out]*/ BSTR* pbstrXMLFragment,
		/*[in]*/ BOOL fClearDirty)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE(guidFlavor);

		VSL_CHECK_VALIDVALUE(storage);

		VSL_SET_VALIDVALUE_BSTR(pbstrXMLFragment);

		VSL_CHECK_VALIDVALUE(fClearDirty);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPERSISTXMLFRAGMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProcessLock.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROCESSLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROCESSLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProcessLockNotImpl :
	public IProcessLock
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProcessLockNotImpl)

public:

	typedef IProcessLock Interface;

	virtual ULONG STDMETHODCALLTYPE AddRefOnProcess(){ return ULONG(); }

	virtual ULONG STDMETHODCALLTYPE ReleaseRefOnProcess(){ return ULONG(); }
};

class IProcessLockMockImpl :
	public IProcessLock,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProcessLockMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProcessLockMockImpl)

	typedef IProcessLock Interface;
	struct AddRefOnProcessValidValues
	{
		ULONG retValue;
	};

	virtual ULONG _stdcall AddRefOnProcess()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AddRefOnProcess)

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseRefOnProcessValidValues
	{
		ULONG retValue;
	};

	virtual ULONG _stdcall ReleaseRefOnProcess()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReleaseRefOnProcess)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROCESSLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProfferService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROFFERSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROFFERSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "proffserv.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProfferServiceNotImpl :
	public IProfferService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProfferServiceNotImpl)

public:

	typedef IProfferService Interface;

	STDMETHOD(ProfferService)(
		/*[in]*/ REFGUID /*rguidService*/,
		/*[in]*/ IServiceProvider* /*psp*/,
		/*[out]*/ DWORD* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevokeService)(
		/*[in]*/ DWORD /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IProfferServiceMockImpl :
	public IProfferService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProfferServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProfferServiceMockImpl)

	typedef IProfferService Interface;
	struct ProfferServiceValidValues
	{
		/*[in]*/ REFGUID rguidService;
		/*[in]*/ IServiceProvider* psp;
		/*[out]*/ DWORD* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(ProfferService)(
		/*[in]*/ REFGUID rguidService,
		/*[in]*/ IServiceProvider* psp,
		/*[out]*/ DWORD* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(ProfferService)

		VSL_CHECK_VALIDVALUE(rguidService);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(psp);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevokeServiceValidValues
	{
		/*[in]*/ DWORD dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RevokeService)(
		/*[in]*/ DWORD dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RevokeService)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROFFERSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPointerInactive.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPOINTERINACTIVE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPOINTERINACTIVE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPointerInactiveNotImpl :
	public IPointerInactive
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPointerInactiveNotImpl)

public:

	typedef IPointerInactive Interface;

	STDMETHOD(GetActivationPolicy)(
		/*[out]*/ DWORD* /*pdwPolicy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInactiveMouseMove)(
		/*[in]*/ LPCRECT /*pRectBounds*/,
		/*[in]*/ LONG /*x*/,
		/*[in]*/ LONG /*y*/,
		/*[in]*/ DWORD /*grfKeyState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInactiveSetCursor)(
		/*[in]*/ LPCRECT /*pRectBounds*/,
		/*[in]*/ LONG /*x*/,
		/*[in]*/ LONG /*y*/,
		/*[in]*/ DWORD /*dwMouseMsg*/,
		/*[in]*/ BOOL /*fSetAlways*/)VSL_STDMETHOD_NOTIMPL
};

class IPointerInactiveMockImpl :
	public IPointerInactive,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPointerInactiveMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPointerInactiveMockImpl)

	typedef IPointerInactive Interface;
	struct GetActivationPolicyValidValues
	{
		/*[out]*/ DWORD* pdwPolicy;
		HRESULT retValue;
	};

	STDMETHOD(GetActivationPolicy)(
		/*[out]*/ DWORD* pdwPolicy)
	{
		VSL_DEFINE_MOCK_METHOD(GetActivationPolicy)

		VSL_SET_VALIDVALUE(pdwPolicy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInactiveMouseMoveValidValues
	{
		/*[in]*/ LPCRECT pRectBounds;
		/*[in]*/ LONG x;
		/*[in]*/ LONG y;
		/*[in]*/ DWORD grfKeyState;
		HRESULT retValue;
	};

	STDMETHOD(OnInactiveMouseMove)(
		/*[in]*/ LPCRECT pRectBounds,
		/*[in]*/ LONG x,
		/*[in]*/ LONG y,
		/*[in]*/ DWORD grfKeyState)
	{
		VSL_DEFINE_MOCK_METHOD(OnInactiveMouseMove)

		VSL_CHECK_VALIDVALUE(pRectBounds);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInactiveSetCursorValidValues
	{
		/*[in]*/ LPCRECT pRectBounds;
		/*[in]*/ LONG x;
		/*[in]*/ LONG y;
		/*[in]*/ DWORD dwMouseMsg;
		/*[in]*/ BOOL fSetAlways;
		HRESULT retValue;
	};

	STDMETHOD(OnInactiveSetCursor)(
		/*[in]*/ LPCRECT pRectBounds,
		/*[in]*/ LONG x,
		/*[in]*/ LONG y,
		/*[in]*/ DWORD dwMouseMsg,
		/*[in]*/ BOOL fSetAlways)
	{
		VSL_DEFINE_MOCK_METHOD(OnInactiveSetCursor)

		VSL_CHECK_VALIDVALUE(pRectBounds);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(dwMouseMsg);

		VSL_CHECK_VALIDVALUE(fSetAlways);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPOINTERINACTIVE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPrint.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPRINT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPRINT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DocObj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPrintNotImpl :
	public IPrint
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPrintNotImpl)

public:

	typedef IPrint Interface;

	STDMETHOD(SetInitialPageNum)(
		/*[in]*/ LONG /*nFirstPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPageInfo)(
		/*[out]*/ LONG* /*pnFirstPage*/,
		/*[out]*/ LONG* /*pcPages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Print)(
		/*[in]*/ DWORD /*grfFlags*/,
		/*[in,out]*/ DVTARGETDEVICE** /*pptd*/,
		/*[in,out]*/ PAGESET** /*ppPageSet*/,
		/*[in,out,unique]*/ STGMEDIUM* /*pstgmOptions*/,
		/*[in]*/ IContinueCallback* /*pcallback*/,
		/*[in]*/ LONG /*nFirstPage*/,
		/*[out]*/ LONG* /*pcPagesPrinted*/,
		/*[out]*/ LONG* /*pnLastPage*/)VSL_STDMETHOD_NOTIMPL
};

class IPrintMockImpl :
	public IPrint,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPrintMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPrintMockImpl)

	typedef IPrint Interface;
	struct SetInitialPageNumValidValues
	{
		/*[in]*/ LONG nFirstPage;
		HRESULT retValue;
	};

	STDMETHOD(SetInitialPageNum)(
		/*[in]*/ LONG nFirstPage)
	{
		VSL_DEFINE_MOCK_METHOD(SetInitialPageNum)

		VSL_CHECK_VALIDVALUE(nFirstPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPageInfoValidValues
	{
		/*[out]*/ LONG* pnFirstPage;
		/*[out]*/ LONG* pcPages;
		HRESULT retValue;
	};

	STDMETHOD(GetPageInfo)(
		/*[out]*/ LONG* pnFirstPage,
		/*[out]*/ LONG* pcPages)
	{
		VSL_DEFINE_MOCK_METHOD(GetPageInfo)

		VSL_SET_VALIDVALUE(pnFirstPage);

		VSL_SET_VALIDVALUE(pcPages);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrintValidValues
	{
		/*[in]*/ DWORD grfFlags;
		/*[in,out]*/ DVTARGETDEVICE** pptd;
		/*[in,out]*/ PAGESET** ppPageSet;
		/*[in,out,unique]*/ STGMEDIUM* pstgmOptions;
		/*[in]*/ IContinueCallback* pcallback;
		/*[in]*/ LONG nFirstPage;
		/*[out]*/ LONG* pcPagesPrinted;
		/*[out]*/ LONG* pnLastPage;
		HRESULT retValue;
	};

	STDMETHOD(Print)(
		/*[in]*/ DWORD grfFlags,
		/*[in,out]*/ DVTARGETDEVICE** pptd,
		/*[in,out]*/ PAGESET** ppPageSet,
		/*[in,out,unique]*/ STGMEDIUM* pstgmOptions,
		/*[in]*/ IContinueCallback* pcallback,
		/*[in]*/ LONG nFirstPage,
		/*[out]*/ LONG* pcPagesPrinted,
		/*[out]*/ LONG* pnLastPage)
	{
		VSL_DEFINE_MOCK_METHOD(Print)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_SET_VALIDVALUE(pptd);

		VSL_SET_VALIDVALUE(ppPageSet);

		VSL_SET_VALIDVALUE(pstgmOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pcallback);

		VSL_CHECK_VALIDVALUE(nFirstPage);

		VSL_SET_VALIDVALUE(pcPagesPrinted);

		VSL_SET_VALIDVALUE(pnLastPage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPRINT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProgressNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROGRESSNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROGRESSNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProgressNotifyNotImpl :
	public IProgressNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProgressNotifyNotImpl)

public:

	typedef IProgressNotify Interface;

	STDMETHOD(OnProgress)(
		/*[in]*/ DWORD /*dwProgressCurrent*/,
		/*[in]*/ DWORD /*dwProgressMaximum*/,
		/*[in]*/ BOOL /*fAccurate*/,
		/*[in]*/ BOOL /*fOwner*/)VSL_STDMETHOD_NOTIMPL
};

class IProgressNotifyMockImpl :
	public IProgressNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProgressNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProgressNotifyMockImpl)

	typedef IProgressNotify Interface;
	struct OnProgressValidValues
	{
		/*[in]*/ DWORD dwProgressCurrent;
		/*[in]*/ DWORD dwProgressMaximum;
		/*[in]*/ BOOL fAccurate;
		/*[in]*/ BOOL fOwner;
		HRESULT retValue;
	};

	STDMETHOD(OnProgress)(
		/*[in]*/ DWORD dwProgressCurrent,
		/*[in]*/ DWORD dwProgressMaximum,
		/*[in]*/ BOOL fAccurate,
		/*[in]*/ BOOL fOwner)
	{
		VSL_DEFINE_MOCK_METHOD(OnProgress)

		VSL_CHECK_VALIDVALUE(dwProgressCurrent);

		VSL_CHECK_VALIDVALUE(dwProgressMaximum);

		VSL_CHECK_VALIDVALUE(fAccurate);

		VSL_CHECK_VALIDVALUE(fOwner);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROGRESSNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProcessInitControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROCESSINITCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROCESSINITCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProcessInitControlNotImpl :
	public IProcessInitControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProcessInitControlNotImpl)

public:

	typedef IProcessInitControl Interface;

	STDMETHOD(ResetInitializerTimeout)(
		/*[in]*/ DWORD /*dwSecondsRemaining*/)VSL_STDMETHOD_NOTIMPL
};

class IProcessInitControlMockImpl :
	public IProcessInitControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProcessInitControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProcessInitControlMockImpl)

	typedef IProcessInitControl Interface;
	struct ResetInitializerTimeoutValidValues
	{
		/*[in]*/ DWORD dwSecondsRemaining;
		HRESULT retValue;
	};

	STDMETHOD(ResetInitializerTimeout)(
		/*[in]*/ DWORD dwSecondsRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(ResetInitializerTimeout)

		VSL_CHECK_VALIDVALUE(dwSecondsRemaining);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROCESSINITCONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProfferTypeLib.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROFFERTYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROFFERTYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProfferTypeLibNotImpl :
	public IProfferTypeLib
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProfferTypeLibNotImpl)

public:

	typedef IProfferTypeLib Interface;

	STDMETHOD(ProfferTypeLib)(
		/*[in]*/ REFGUID /*guidTypeLib*/,
		/*[in]*/ UINT /*uVerMaj*/,
		/*[in]*/ UINT /*uVerMin*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IProfferTypeLibMockImpl :
	public IProfferTypeLib,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProfferTypeLibMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProfferTypeLibMockImpl)

	typedef IProfferTypeLib Interface;
	struct ProfferTypeLibValidValues
	{
		/*[in]*/ REFGUID guidTypeLib;
		/*[in]*/ UINT uVerMaj;
		/*[in]*/ UINT uVerMin;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(ProfferTypeLib)(
		/*[in]*/ REFGUID guidTypeLib,
		/*[in]*/ UINT uVerMaj,
		/*[in]*/ UINT uVerMin,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ProfferTypeLib)

		VSL_CHECK_VALIDVALUE(guidTypeLib);

		VSL_CHECK_VALIDVALUE(uVerMaj);

		VSL_CHECK_VALIDVALUE(uVerMin);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROFFERTYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyBag2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYBAG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYBAG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyBag2NotImpl :
	public IPropertyBag2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyBag2NotImpl)

public:

	typedef IPropertyBag2 Interface;

	STDMETHOD(Read)(
		/*[in]*/ ULONG /*cProperties*/,
		/*[in]*/ PROPBAG2* /*pPropBag*/,
		/*[in]*/ IErrorLog* /*pErrLog*/,
		/*[out]*/ VARIANT* /*pvarValue*/,
		/*[out]*/ HRESULT* /*phrError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Write)(
		/*[in]*/ ULONG /*cProperties*/,
		/*[in]*/ PROPBAG2* /*pPropBag*/,
		/*[in]*/ VARIANT* /*pvarValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountProperties)(
		/*[out]*/ ULONG* /*pcProperties*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ ULONG /*iProperty*/,
		/*[in]*/ ULONG /*cProperties*/,
		/*[out]*/ PROPBAG2* /*pPropBag*/,
		/*[out]*/ ULONG* /*pcProperties*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadObject)(
		/*[in]*/ LPCOLESTR /*pstrName*/,
		/*[in]*/ DWORD /*dwHint*/,
		/*[in]*/ IUnknown* /*pUnkObject*/,
		/*[in]*/ IErrorLog* /*pErrLog*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyBag2MockImpl :
	public IPropertyBag2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyBag2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyBag2MockImpl)

	typedef IPropertyBag2 Interface;
	struct ReadValidValues
	{
		/*[in]*/ ULONG cProperties;
		/*[in]*/ PROPBAG2* pPropBag;
		/*[in]*/ IErrorLog* pErrLog;
		/*[out]*/ VARIANT* pvarValue;
		/*[out]*/ HRESULT* phrError;
		HRESULT retValue;
	};

	STDMETHOD(Read)(
		/*[in]*/ ULONG cProperties,
		/*[in]*/ PROPBAG2* pPropBag,
		/*[in]*/ IErrorLog* pErrLog,
		/*[out]*/ VARIANT* pvarValue,
		/*[out]*/ HRESULT* phrError)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_CHECK_VALIDVALUE(cProperties);

		VSL_CHECK_VALIDVALUE_POINTER(pPropBag);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrLog);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_SET_VALIDVALUE(phrError);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteValidValues
	{
		/*[in]*/ ULONG cProperties;
		/*[in]*/ PROPBAG2* pPropBag;
		/*[in]*/ VARIANT* pvarValue;
		HRESULT retValue;
	};

	STDMETHOD(Write)(
		/*[in]*/ ULONG cProperties,
		/*[in]*/ PROPBAG2* pPropBag,
		/*[in]*/ VARIANT* pvarValue)
	{
		VSL_DEFINE_MOCK_METHOD(Write)

		VSL_CHECK_VALIDVALUE(cProperties);

		VSL_CHECK_VALIDVALUE_POINTER(pPropBag);

		VSL_CHECK_VALIDVALUE_POINTER(pvarValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountPropertiesValidValues
	{
		/*[out]*/ ULONG* pcProperties;
		HRESULT retValue;
	};

	STDMETHOD(CountProperties)(
		/*[out]*/ ULONG* pcProperties)
	{
		VSL_DEFINE_MOCK_METHOD(CountProperties)

		VSL_SET_VALIDVALUE(pcProperties);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyInfoValidValues
	{
		/*[in]*/ ULONG iProperty;
		/*[in]*/ ULONG cProperties;
		/*[out]*/ PROPBAG2* pPropBag;
		/*[out]*/ ULONG* pcProperties;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ ULONG iProperty,
		/*[in]*/ ULONG cProperties,
		/*[out]*/ PROPBAG2* pPropBag,
		/*[out]*/ ULONG* pcProperties)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyInfo)

		VSL_CHECK_VALIDVALUE(iProperty);

		VSL_CHECK_VALIDVALUE(cProperties);

		VSL_SET_VALIDVALUE(pPropBag);

		VSL_SET_VALIDVALUE(pcProperties);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadObjectValidValues
	{
		/*[in]*/ LPCOLESTR pstrName;
		/*[in]*/ DWORD dwHint;
		/*[in]*/ IUnknown* pUnkObject;
		/*[in]*/ IErrorLog* pErrLog;
		HRESULT retValue;
	};

	STDMETHOD(LoadObject)(
		/*[in]*/ LPCOLESTR pstrName,
		/*[in]*/ DWORD dwHint,
		/*[in]*/ IUnknown* pUnkObject,
		/*[in]*/ IErrorLog* pErrLog)
	{
		VSL_DEFINE_MOCK_METHOD(LoadObject)

		VSL_CHECK_VALIDVALUE_STRINGW(pstrName);

		VSL_CHECK_VALIDVALUE(dwHint);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkObject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrLog);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYBAG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyBag.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYBAG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYBAG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyBagNotImpl :
	public IPropertyBag
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyBagNotImpl)

public:

	typedef IPropertyBag Interface;

	STDMETHOD(Read)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[in,out]*/ VARIANT* /*pVar*/,
		/*[in]*/ IErrorLog* /*pErrorLog*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Write)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[in]*/ VARIANT* /*pVar*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyBagMockImpl :
	public IPropertyBag,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyBagMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyBagMockImpl)

	typedef IPropertyBag Interface;
	struct ReadValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[in,out]*/ VARIANT* pVar;
		/*[in]*/ IErrorLog* pErrorLog;
		HRESULT retValue;
	};

	STDMETHOD(Read)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[in,out]*/ VARIANT* pVar,
		/*[in]*/ IErrorLog* pErrorLog)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_SET_VALIDVALUE_VARIANT(pVar);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrorLog);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[in]*/ VARIANT* pVar;
		HRESULT retValue;
	};

	STDMETHOD(Write)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[in]*/ VARIANT* pVar)
	{
		VSL_DEFINE_MOCK_METHOD(Write)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYBAG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyPageSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYPAGESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYPAGESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyPageSiteNotImpl :
	public IPropertyPageSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPageSiteNotImpl)

public:

	typedef IPropertyPageSite Interface;

	STDMETHOD(OnStatusChange)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLocaleID)(
		/*[out]*/ LCID* /*pLocaleID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPageContainer)(
		/*[out]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* /*pMsg*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyPageSiteMockImpl :
	public IPropertyPageSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPageSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyPageSiteMockImpl)

	typedef IPropertyPageSite Interface;
	struct OnStatusChangeValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnStatusChange)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(OnStatusChange)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLocaleIDValidValues
	{
		/*[out]*/ LCID* pLocaleID;
		HRESULT retValue;
	};

	STDMETHOD(GetLocaleID)(
		/*[out]*/ LCID* pLocaleID)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocaleID)

		VSL_SET_VALIDVALUE(pLocaleID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPageContainerValidValues
	{
		/*[out]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(GetPageContainer)(
		/*[out]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(GetPageContainer)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ MSG* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYPAGESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyPageUndoString.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYPAGEUNDOSTRING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYPAGEUNDOSTRING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ocdesign.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyPageUndoStringNotImpl :
	public IPropertyPageUndoString
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPageUndoStringNotImpl)

public:

	typedef IPropertyPageUndoString Interface;

	STDMETHOD(GetUndoString)(
		/*[out]*/ LPOLESTR* /*ppszUndo*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyPageUndoStringMockImpl :
	public IPropertyPageUndoString,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPageUndoStringMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyPageUndoStringMockImpl)

	typedef IPropertyPageUndoString Interface;
	struct GetUndoStringValidValues
	{
		/*[out]*/ LPOLESTR* ppszUndo;
		HRESULT retValue;
	};

	STDMETHOD(GetUndoString)(
		/*[out]*/ LPOLESTR* ppszUndo)
	{
		VSL_DEFINE_MOCK_METHOD(GetUndoString)

		VSL_SET_VALIDVALUE(ppszUndo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYPAGEUNDOSTRING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyNotifySink.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYNOTIFYSINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYNOTIFYSINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyNotifySinkNotImpl :
	public IPropertyNotifySink
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyNotifySinkNotImpl)

public:

	typedef IPropertyNotifySink Interface;

	STDMETHOD(OnChanged)(
		/*[in]*/ DISPID /*dispID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRequestEdit)(
		/*[in]*/ DISPID /*dispID*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyNotifySinkMockImpl :
	public IPropertyNotifySink,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyNotifySinkMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyNotifySinkMockImpl)

	typedef IPropertyNotifySink Interface;
	struct OnChangedValidValues
	{
		/*[in]*/ DISPID dispID;
		HRESULT retValue;
	};

	STDMETHOD(OnChanged)(
		/*[in]*/ DISPID dispID)
	{
		VSL_DEFINE_MOCK_METHOD(OnChanged)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRequestEditValidValues
	{
		/*[in]*/ DISPID dispID;
		HRESULT retValue;
	};

	STDMETHOD(OnRequestEdit)(
		/*[in]*/ DISPID dispID)
	{
		VSL_DEFINE_MOCK_METHOD(OnRequestEdit)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYNOTIFYSINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyPage2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYPAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYPAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyPage2NotImpl :
	public IPropertyPage2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPage2NotImpl)

public:

	typedef IPropertyPage2 Interface;

	STDMETHOD(EditProperty)(
		/*[in]*/ DISPID /*dispID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPageSite)(
		/*[in]*/ IPropertyPageSite* /*pPageSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Activate)(
		/*[in]*/ HWND /*hWndParent*/,
		/*[in]*/ LPCRECT /*pRect*/,
		/*[in]*/ BOOL /*bModal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Deactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPageInfo)(
		/*[out]*/ PROPPAGEINFO* /*pPageInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetObjects)(
		/*[in]*/ ULONG /*cObjects*/,
		/*[in,size_is(cObjects)]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Show)(
		/*[in]*/ UINT /*nCmdShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Move)(
		/*[in]*/ LPCRECT /*pRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPageDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Apply)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Help)(
		/*[in]*/ LPCOLESTR /*pszHelpDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* /*pMsg*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyPage2MockImpl :
	public IPropertyPage2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPage2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyPage2MockImpl)

	typedef IPropertyPage2 Interface;
	struct EditPropertyValidValues
	{
		/*[in]*/ DISPID dispID;
		HRESULT retValue;
	};

	STDMETHOD(EditProperty)(
		/*[in]*/ DISPID dispID)
	{
		VSL_DEFINE_MOCK_METHOD(EditProperty)

		VSL_CHECK_VALIDVALUE(dispID);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPageSiteValidValues
	{
		/*[in]*/ IPropertyPageSite* pPageSite;
		HRESULT retValue;
	};

	STDMETHOD(SetPageSite)(
		/*[in]*/ IPropertyPageSite* pPageSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetPageSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPageSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateValidValues
	{
		/*[in]*/ HWND hWndParent;
		/*[in]*/ LPCRECT pRect;
		/*[in]*/ BOOL bModal;
		HRESULT retValue;
	};

	STDMETHOD(Activate)(
		/*[in]*/ HWND hWndParent,
		/*[in]*/ LPCRECT pRect,
		/*[in]*/ BOOL bModal)
	{
		VSL_DEFINE_MOCK_METHOD(Activate)

		VSL_CHECK_VALIDVALUE(hWndParent);

		VSL_CHECK_VALIDVALUE(pRect);

		VSL_CHECK_VALIDVALUE(bModal);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Deactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Deactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPageInfoValidValues
	{
		/*[out]*/ PROPPAGEINFO* pPageInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetPageInfo)(
		/*[out]*/ PROPPAGEINFO* pPageInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetPageInfo)

		VSL_SET_VALIDVALUE(pPageInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetObjectsValidValues
	{
		/*[in]*/ ULONG cObjects;
		/*[in,size_is(cObjects)]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(SetObjects)(
		/*[in]*/ ULONG cObjects,
		/*[in,size_is(cObjects)]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(SetObjects)

		VSL_CHECK_VALIDVALUE(cObjects);

		VSL_CHECK_VALIDVALUE_ARRAY(ppUnk, cObjects, validValues.cObjects);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowValidValues
	{
		/*[in]*/ UINT nCmdShow;
		HRESULT retValue;
	};

	STDMETHOD(Show)(
		/*[in]*/ UINT nCmdShow)
	{
		VSL_DEFINE_MOCK_METHOD(Show)

		VSL_CHECK_VALIDVALUE(nCmdShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveValidValues
	{
		/*[in]*/ LPCRECT pRect;
		HRESULT retValue;
	};

	STDMETHOD(Move)(
		/*[in]*/ LPCRECT pRect)
	{
		VSL_DEFINE_MOCK_METHOD(Move)

		VSL_CHECK_VALIDVALUE(pRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPageDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsPageDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsPageDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Apply)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Apply)

		VSL_RETURN_VALIDVALUES();
	}
	struct HelpValidValues
	{
		/*[in]*/ LPCOLESTR pszHelpDir;
		HRESULT retValue;
	};

	STDMETHOD(Help)(
		/*[in]*/ LPCOLESTR pszHelpDir)
	{
		VSL_DEFINE_MOCK_METHOD(Help)

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ MSG* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYPAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyPage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYPAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYPAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyPageNotImpl :
	public IPropertyPage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPageNotImpl)

public:

	typedef IPropertyPage Interface;

	STDMETHOD(SetPageSite)(
		/*[in]*/ IPropertyPageSite* /*pPageSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Activate)(
		/*[in]*/ HWND /*hWndParent*/,
		/*[in]*/ LPCRECT /*pRect*/,
		/*[in]*/ BOOL /*bModal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Deactivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPageInfo)(
		/*[out]*/ PROPPAGEINFO* /*pPageInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetObjects)(
		/*[in]*/ ULONG /*cObjects*/,
		/*[in,size_is(cObjects)]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Show)(
		/*[in]*/ UINT /*nCmdShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Move)(
		/*[in]*/ LPCRECT /*pRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPageDirty)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Apply)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Help)(
		/*[in]*/ LPCOLESTR /*pszHelpDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* /*pMsg*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyPageMockImpl :
	public IPropertyPage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyPageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyPageMockImpl)

	typedef IPropertyPage Interface;
	struct SetPageSiteValidValues
	{
		/*[in]*/ IPropertyPageSite* pPageSite;
		HRESULT retValue;
	};

	STDMETHOD(SetPageSite)(
		/*[in]*/ IPropertyPageSite* pPageSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetPageSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPageSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateValidValues
	{
		/*[in]*/ HWND hWndParent;
		/*[in]*/ LPCRECT pRect;
		/*[in]*/ BOOL bModal;
		HRESULT retValue;
	};

	STDMETHOD(Activate)(
		/*[in]*/ HWND hWndParent,
		/*[in]*/ LPCRECT pRect,
		/*[in]*/ BOOL bModal)
	{
		VSL_DEFINE_MOCK_METHOD(Activate)

		VSL_CHECK_VALIDVALUE(hWndParent);

		VSL_CHECK_VALIDVALUE(pRect);

		VSL_CHECK_VALIDVALUE(bModal);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeactivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Deactivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Deactivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPageInfoValidValues
	{
		/*[out]*/ PROPPAGEINFO* pPageInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetPageInfo)(
		/*[out]*/ PROPPAGEINFO* pPageInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetPageInfo)

		VSL_SET_VALIDVALUE(pPageInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetObjectsValidValues
	{
		/*[in]*/ ULONG cObjects;
		/*[in,size_is(cObjects)]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(SetObjects)(
		/*[in]*/ ULONG cObjects,
		/*[in,size_is(cObjects)]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(SetObjects)

		VSL_CHECK_VALIDVALUE(cObjects);

		VSL_CHECK_VALIDVALUE_ARRAY(ppUnk, cObjects, validValues.cObjects);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowValidValues
	{
		/*[in]*/ UINT nCmdShow;
		HRESULT retValue;
	};

	STDMETHOD(Show)(
		/*[in]*/ UINT nCmdShow)
	{
		VSL_DEFINE_MOCK_METHOD(Show)

		VSL_CHECK_VALIDVALUE(nCmdShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveValidValues
	{
		/*[in]*/ LPCRECT pRect;
		HRESULT retValue;
	};

	STDMETHOD(Move)(
		/*[in]*/ LPCRECT pRect)
	{
		VSL_DEFINE_MOCK_METHOD(Move)

		VSL_CHECK_VALIDVALUE(pRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPageDirtyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsPageDirty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsPageDirty)

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Apply)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Apply)

		VSL_RETURN_VALIDVALUES();
	}
	struct HelpValidValues
	{
		/*[in]*/ LPCOLESTR pszHelpDir;
		HRESULT retValue;
	};

	STDMETHOD(Help)(
		/*[in]*/ LPCOLESTR pszHelpDir)
	{
		VSL_DEFINE_MOCK_METHOD(Help)

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ MSG* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ MSG* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYPAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyProxyEESide.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYPROXYEESIDE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYPROXYEESIDE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyProxyEESideNotImpl :
	public IPropertyProxyEESide
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyProxyEESideNotImpl)

public:

	typedef IPropertyProxyEESide Interface;

	STDMETHOD(InitSourceDataProvider)(
		/*[out]*/ IEEDataStorage** /*dataOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetManagedViewerCreationData)(
		/*[out]*/ BSTR* /*assemName*/,
		/*[out]*/ IEEDataStorage** /*assemBytes*/,
		/*[out]*/ IEEDataStorage** /*assemPdb*/,
		/*[out]*/ BSTR* /*className*/,
		/*[out]*/ ASSEMBLYLOCRESOLUTION* /*alr*/,
		/*[out]*/ BOOL* /*replacementOk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInitialData)(
		/*[out]*/ IEEDataStorage** /*dataOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateReplacementObject)(
		/*[in]*/ IEEDataStorage* /*dataIn*/,
		/*[out]*/ IEEDataStorage** /*dataOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InPlaceUpdateObject)(
		/*[in]*/ IEEDataStorage* /*dataIn*/,
		/*[out]*/ IEEDataStorage** /*dataOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResolveAssemblyReference)(
		/*[in]*/ LPCOLESTR /*assemName*/,
		/*[in]*/ GETASSEMBLY /*flags*/,
		/*[out]*/ IEEDataStorage** /*assemBytes*/,
		/*[out]*/ IEEDataStorage** /*assemPdb*/,
		/*[out]*/ BSTR* /*assemLocation*/,
		/*[out]*/ ASSEMBLYLOCRESOLUTION* /*alr*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyProxyEESideMockImpl :
	public IPropertyProxyEESide,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyProxyEESideMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyProxyEESideMockImpl)

	typedef IPropertyProxyEESide Interface;
	struct InitSourceDataProviderValidValues
	{
		/*[out]*/ IEEDataStorage** dataOut;
		HRESULT retValue;
	};

	STDMETHOD(InitSourceDataProvider)(
		/*[out]*/ IEEDataStorage** dataOut)
	{
		VSL_DEFINE_MOCK_METHOD(InitSourceDataProvider)

		VSL_SET_VALIDVALUE_INTERFACE(dataOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetManagedViewerCreationDataValidValues
	{
		/*[out]*/ BSTR* assemName;
		/*[out]*/ IEEDataStorage** assemBytes;
		/*[out]*/ IEEDataStorage** assemPdb;
		/*[out]*/ BSTR* className;
		/*[out]*/ ASSEMBLYLOCRESOLUTION* alr;
		/*[out]*/ BOOL* replacementOk;
		HRESULT retValue;
	};

	STDMETHOD(GetManagedViewerCreationData)(
		/*[out]*/ BSTR* assemName,
		/*[out]*/ IEEDataStorage** assemBytes,
		/*[out]*/ IEEDataStorage** assemPdb,
		/*[out]*/ BSTR* className,
		/*[out]*/ ASSEMBLYLOCRESOLUTION* alr,
		/*[out]*/ BOOL* replacementOk)
	{
		VSL_DEFINE_MOCK_METHOD(GetManagedViewerCreationData)

		VSL_SET_VALIDVALUE_BSTR(assemName);

		VSL_SET_VALIDVALUE_INTERFACE(assemBytes);

		VSL_SET_VALIDVALUE_INTERFACE(assemPdb);

		VSL_SET_VALIDVALUE_BSTR(className);

		VSL_SET_VALIDVALUE(alr);

		VSL_SET_VALIDVALUE(replacementOk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInitialDataValidValues
	{
		/*[out]*/ IEEDataStorage** dataOut;
		HRESULT retValue;
	};

	STDMETHOD(GetInitialData)(
		/*[out]*/ IEEDataStorage** dataOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetInitialData)

		VSL_SET_VALIDVALUE_INTERFACE(dataOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateReplacementObjectValidValues
	{
		/*[in]*/ IEEDataStorage* dataIn;
		/*[out]*/ IEEDataStorage** dataOut;
		HRESULT retValue;
	};

	STDMETHOD(CreateReplacementObject)(
		/*[in]*/ IEEDataStorage* dataIn,
		/*[out]*/ IEEDataStorage** dataOut)
	{
		VSL_DEFINE_MOCK_METHOD(CreateReplacementObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(dataIn);

		VSL_SET_VALIDVALUE_INTERFACE(dataOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct InPlaceUpdateObjectValidValues
	{
		/*[in]*/ IEEDataStorage* dataIn;
		/*[out]*/ IEEDataStorage** dataOut;
		HRESULT retValue;
	};

	STDMETHOD(InPlaceUpdateObject)(
		/*[in]*/ IEEDataStorage* dataIn,
		/*[out]*/ IEEDataStorage** dataOut)
	{
		VSL_DEFINE_MOCK_METHOD(InPlaceUpdateObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(dataIn);

		VSL_SET_VALIDVALUE_INTERFACE(dataOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResolveAssemblyReferenceValidValues
	{
		/*[in]*/ LPCOLESTR assemName;
		/*[in]*/ GETASSEMBLY flags;
		/*[out]*/ IEEDataStorage** assemBytes;
		/*[out]*/ IEEDataStorage** assemPdb;
		/*[out]*/ BSTR* assemLocation;
		/*[out]*/ ASSEMBLYLOCRESOLUTION* alr;
		HRESULT retValue;
	};

	STDMETHOD(ResolveAssemblyReference)(
		/*[in]*/ LPCOLESTR assemName,
		/*[in]*/ GETASSEMBLY flags,
		/*[out]*/ IEEDataStorage** assemBytes,
		/*[out]*/ IEEDataStorage** assemPdb,
		/*[out]*/ BSTR* assemLocation,
		/*[out]*/ ASSEMBLYLOCRESOLUTION* alr)
	{
		VSL_DEFINE_MOCK_METHOD(ResolveAssemblyReference)

		VSL_CHECK_VALIDVALUE_STRINGW(assemName);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE_INTERFACE(assemBytes);

		VSL_SET_VALIDVALUE_INTERFACE(assemPdb);

		VSL_SET_VALIDVALUE_BSTR(assemLocation);

		VSL_SET_VALIDVALUE(alr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYPROXYEESIDE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIPropertyProxyProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROPERTYPROXYPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROPERTYPROXYPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "msdbg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IPropertyProxyProviderNotImpl :
	public IPropertyProxyProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyProxyProviderNotImpl)

public:

	typedef IPropertyProxyProvider Interface;

	STDMETHOD(GetPropertyProxy)(
		/*[in]*/ DWORD /*dwID*/,
		/*[out]*/ IPropertyProxyEESide** /*proxy*/)VSL_STDMETHOD_NOTIMPL
};

class IPropertyProxyProviderMockImpl :
	public IPropertyProxyProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IPropertyProxyProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IPropertyProxyProviderMockImpl)

	typedef IPropertyProxyProvider Interface;
	struct GetPropertyProxyValidValues
	{
		/*[in]*/ DWORD dwID;
		/*[out]*/ IPropertyProxyEESide** proxy;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyProxy)(
		/*[in]*/ DWORD dwID,
		/*[out]*/ IPropertyProxyEESide** proxy)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyProxy)

		VSL_CHECK_VALIDVALUE(dwID);

		VSL_SET_VALIDVALUE_INTERFACE(proxy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROPERTYPROXYPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvideAltHTML.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDEALTHTML_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDEALTHTML_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ocdesign.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvideAltHTMLNotImpl :
	public IProvideAltHTML
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideAltHTMLNotImpl)

public:

	typedef IProvideAltHTML Interface;

	STDMETHOD(GetAltHTML)(
		/*[out,retval]*/ BSTR* /*pstrAltHTML*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsAltHTMLEditable)(
		/*[out,retval]*/ boolean* /*pfIsEditable*/)VSL_STDMETHOD_NOTIMPL
};

class IProvideAltHTMLMockImpl :
	public IProvideAltHTML,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideAltHTMLMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvideAltHTMLMockImpl)

	typedef IProvideAltHTML Interface;
	struct GetAltHTMLValidValues
	{
		/*[out,retval]*/ BSTR* pstrAltHTML;
		HRESULT retValue;
	};

	STDMETHOD(GetAltHTML)(
		/*[out,retval]*/ BSTR* pstrAltHTML)
	{
		VSL_DEFINE_MOCK_METHOD(GetAltHTML)

		VSL_SET_VALIDVALUE_BSTR(pstrAltHTML);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsAltHTMLEditableValidValues
	{
		/*[out,retval]*/ boolean* pfIsEditable;
		HRESULT retValue;
	};

	STDMETHOD(IsAltHTMLEditable)(
		/*[out,retval]*/ boolean* pfIsEditable)
	{
		VSL_DEFINE_MOCK_METHOD(IsAltHTMLEditable)

		VSL_SET_VALIDVALUE(pfIsEditable);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDEALTHTML_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvideClassInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDECLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDECLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvideClassInfoNotImpl :
	public IProvideClassInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideClassInfoNotImpl)

public:

	typedef IProvideClassInfo Interface;

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** /*ppTI*/)VSL_STDMETHOD_NOTIMPL
};

class IProvideClassInfoMockImpl :
	public IProvideClassInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideClassInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvideClassInfoMockImpl)

	typedef IProvideClassInfo Interface;
	struct GetClassInfoValidValues
	{
		/*[out]*/ ITypeInfo** ppTI;
		HRESULT retValue;
	};

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** ppTI)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppTI);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDECLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvideClassInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDECLASSINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDECLASSINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvideClassInfo2NotImpl :
	public IProvideClassInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideClassInfo2NotImpl)

public:

	typedef IProvideClassInfo2 Interface;

	STDMETHOD(GetGUID)(
		/*[in]*/ DWORD /*dwGuidKind*/,
		/*[out]*/ GUID* /*pGUID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** /*ppTI*/)VSL_STDMETHOD_NOTIMPL
};

class IProvideClassInfo2MockImpl :
	public IProvideClassInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideClassInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvideClassInfo2MockImpl)

	typedef IProvideClassInfo2 Interface;
	struct GetGUIDValidValues
	{
		/*[in]*/ DWORD dwGuidKind;
		/*[out]*/ GUID* pGUID;
		HRESULT retValue;
	};

	STDMETHOD(GetGUID)(
		/*[in]*/ DWORD dwGuidKind,
		/*[out]*/ GUID* pGUID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGUID)

		VSL_CHECK_VALIDVALUE(dwGuidKind);

		VSL_SET_VALIDVALUE(pGUID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassInfoValidValues
	{
		/*[out]*/ ITypeInfo** ppTI;
		HRESULT retValue;
	};

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** ppTI)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppTI);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDECLASSINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvideDynamicClassInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDEDYNAMICCLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDEDYNAMICCLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvideDynamicClassInfoNotImpl :
	public IProvideDynamicClassInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideDynamicClassInfoNotImpl)

public:

	typedef IProvideDynamicClassInfo Interface;

	STDMETHOD(GetDynamicClassInfo)(
		/*[out]*/ ITypeInfo** /*ppTI*/,
		/*[out]*/ DWORD_PTR* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreezeShape)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** /*ppTI*/)VSL_STDMETHOD_NOTIMPL
};

class IProvideDynamicClassInfoMockImpl :
	public IProvideDynamicClassInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideDynamicClassInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvideDynamicClassInfoMockImpl)

	typedef IProvideDynamicClassInfo Interface;
	struct GetDynamicClassInfoValidValues
	{
		/*[out]*/ ITypeInfo** ppTI;
		/*[out]*/ DWORD_PTR* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(GetDynamicClassInfo)(
		/*[out]*/ ITypeInfo** ppTI,
		/*[out]*/ DWORD_PTR* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(GetDynamicClassInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppTI);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreezeShapeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FreezeShape)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FreezeShape)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassInfoValidValues
	{
		/*[out]*/ ITypeInfo** ppTI;
		HRESULT retValue;
	};

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** ppTI)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppTI);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDEDYNAMICCLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvideMultipleClassInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDEMULTIPLECLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDEMULTIPLECLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvideMultipleClassInfoNotImpl :
	public IProvideMultipleClassInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideMultipleClassInfoNotImpl)

public:

	typedef IProvideMultipleClassInfo Interface;

	STDMETHOD(GetMultiTypeInfoCount)(
		/*[out]*/ ULONG* /*pcti*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInfoOfIndex)(
		/*[in]*/ ULONG /*iti*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ ITypeInfo** /*pptiCoClass*/,
		/*[out]*/ DWORD* /*pdwTIFlags*/,
		/*[out]*/ ULONG* /*pcdispidReserved*/,
		/*[out]*/ IID* /*piidPrimary*/,
		/*[out]*/ IID* /*piidSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGUID)(
		/*[in]*/ DWORD /*dwGuidKind*/,
		/*[out]*/ GUID* /*pGUID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** /*ppTI*/)VSL_STDMETHOD_NOTIMPL
};

class IProvideMultipleClassInfoMockImpl :
	public IProvideMultipleClassInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideMultipleClassInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvideMultipleClassInfoMockImpl)

	typedef IProvideMultipleClassInfo Interface;
	struct GetMultiTypeInfoCountValidValues
	{
		/*[out]*/ ULONG* pcti;
		HRESULT retValue;
	};

	STDMETHOD(GetMultiTypeInfoCount)(
		/*[out]*/ ULONG* pcti)
	{
		VSL_DEFINE_MOCK_METHOD(GetMultiTypeInfoCount)

		VSL_SET_VALIDVALUE(pcti);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInfoOfIndexValidValues
	{
		/*[in]*/ ULONG iti;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ ITypeInfo** pptiCoClass;
		/*[out]*/ DWORD* pdwTIFlags;
		/*[out]*/ ULONG* pcdispidReserved;
		/*[out]*/ IID* piidPrimary;
		/*[out]*/ IID* piidSource;
		HRESULT retValue;
	};

	STDMETHOD(GetInfoOfIndex)(
		/*[in]*/ ULONG iti,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ ITypeInfo** pptiCoClass,
		/*[out]*/ DWORD* pdwTIFlags,
		/*[out]*/ ULONG* pcdispidReserved,
		/*[out]*/ IID* piidPrimary,
		/*[out]*/ IID* piidSource)
	{
		VSL_DEFINE_MOCK_METHOD(GetInfoOfIndex)

		VSL_CHECK_VALIDVALUE(iti);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(pptiCoClass);

		VSL_SET_VALIDVALUE(pdwTIFlags);

		VSL_SET_VALIDVALUE(pcdispidReserved);

		VSL_SET_VALIDVALUE(piidPrimary);

		VSL_SET_VALIDVALUE(piidSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGUIDValidValues
	{
		/*[in]*/ DWORD dwGuidKind;
		/*[out]*/ GUID* pGUID;
		HRESULT retValue;
	};

	STDMETHOD(GetGUID)(
		/*[in]*/ DWORD dwGuidKind,
		/*[out]*/ GUID* pGUID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGUID)

		VSL_CHECK_VALIDVALUE(dwGuidKind);

		VSL_SET_VALIDVALUE(pGUID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassInfoValidValues
	{
		/*[out]*/ ITypeInfo** ppTI;
		HRESULT retValue;
	};

	STDMETHOD(GetClassInfo)(
		/*[out]*/ ITypeInfo** ppTI)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppTI);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDEMULTIPLECLASSINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIQuickActivate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IQUICKACTIVATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IQUICKACTIVATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IQuickActivateNotImpl :
	public IQuickActivate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IQuickActivateNotImpl)

public:

	typedef IQuickActivate Interface;

	STDMETHOD(QuickActivate)(
		/*[in]*/ QACONTAINER* /*pQaContainer*/,
		/*[in,out]*/ QACONTROL* /*pQaControl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContentExtent)(
		/*[in]*/ LPSIZEL /*pSizel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContentExtent)(
		/*[out]*/ LPSIZEL /*pSizel*/)VSL_STDMETHOD_NOTIMPL
};

class IQuickActivateMockImpl :
	public IQuickActivate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IQuickActivateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IQuickActivateMockImpl)

	typedef IQuickActivate Interface;
	struct QuickActivateValidValues
	{
		/*[in]*/ QACONTAINER* pQaContainer;
		/*[in,out]*/ QACONTROL* pQaControl;
		HRESULT retValue;
	};

	STDMETHOD(QuickActivate)(
		/*[in]*/ QACONTAINER* pQaContainer,
		/*[in,out]*/ QACONTROL* pQaControl)
	{
		VSL_DEFINE_MOCK_METHOD(QuickActivate)

		VSL_CHECK_VALIDVALUE_POINTER(pQaContainer);

		VSL_SET_VALIDVALUE(pQaControl);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContentExtentValidValues
	{
		/*[in]*/ LPSIZEL pSizel;
		HRESULT retValue;
	};

	STDMETHOD(SetContentExtent)(
		/*[in]*/ LPSIZEL pSizel)
	{
		VSL_DEFINE_MOCK_METHOD(SetContentExtent)

		VSL_CHECK_VALIDVALUE(pSizel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContentExtentValidValues
	{
		/*[out]*/ LPSIZEL pSizel;
		HRESULT retValue;
	};

	STDMETHOD(GetContentExtent)(
		/*[out]*/ LPSIZEL pSizel)
	{
		VSL_DEFINE_MOCK_METHOD(GetContentExtent)

		VSL_SET_VALIDVALUE(pSizel);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IQUICKACTIVATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvidePropertyBuilder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDEPROPERTYBUILDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDEPROPERTYBUILDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ocdesign.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvidePropertyBuilderNotImpl :
	public IProvidePropertyBuilder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvidePropertyBuilderNotImpl)

public:

	typedef IProvidePropertyBuilder Interface;

	STDMETHOD(MapPropertyToBuilder)(
		/*[in]*/ LONG /*dispid*/,
		/*[in,out]*/ LONG* /*pdwCtlBldType*/,
		/*[in,out]*/ BSTR* /*pbstrGuidBldr*/,
		/*[out,retval]*/ VARIANT_BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecuteBuilder)(
		/*[in]*/ LONG /*dispid*/,
		/*[in]*/ BSTR /*bstrGuidBldr*/,
		/*[in]*/ IDispatch* /*pdispApp*/,
		/*[in]*/ LONG_PTR /*hwndBldrOwner*/,
		/*[in,out]*/ VARIANT* /*pvarValue*/,
		/*[out,retval]*/ VARIANT_BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL
};

class IProvidePropertyBuilderMockImpl :
	public IProvidePropertyBuilder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvidePropertyBuilderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvidePropertyBuilderMockImpl)

	typedef IProvidePropertyBuilder Interface;
	struct MapPropertyToBuilderValidValues
	{
		/*[in]*/ LONG dispid;
		/*[in,out]*/ LONG* pdwCtlBldType;
		/*[in,out]*/ BSTR* pbstrGuidBldr;
		/*[out,retval]*/ VARIANT_BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(MapPropertyToBuilder)(
		/*[in]*/ LONG dispid,
		/*[in,out]*/ LONG* pdwCtlBldType,
		/*[in,out]*/ BSTR* pbstrGuidBldr,
		/*[out,retval]*/ VARIANT_BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(MapPropertyToBuilder)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(pdwCtlBldType);

		VSL_SET_VALIDVALUE_BSTR(pbstrGuidBldr);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecuteBuilderValidValues
	{
		/*[in]*/ LONG dispid;
		/*[in]*/ BSTR bstrGuidBldr;
		/*[in]*/ IDispatch* pdispApp;
		/*[in]*/ LONG_PTR hwndBldrOwner;
		/*[in,out]*/ VARIANT* pvarValue;
		/*[out,retval]*/ VARIANT_BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(ExecuteBuilder)(
		/*[in]*/ LONG dispid,
		/*[in]*/ BSTR bstrGuidBldr,
		/*[in]*/ IDispatch* pdispApp,
		/*[in]*/ LONG_PTR hwndBldrOwner,
		/*[in,out]*/ VARIANT* pvarValue,
		/*[out,retval]*/ VARIANT_BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(ExecuteBuilder)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_CHECK_VALIDVALUE_BSTR(bstrGuidBldr);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pdispApp);

		VSL_CHECK_VALIDVALUE(hwndBldrOwner);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDEPROPERTYBUILDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIReferenceInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IREFERENCEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IREFERENCEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IReferenceInfoNotImpl :
	public IReferenceInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IReferenceInfoNotImpl)

public:

	typedef IReferenceInfo Interface;

	STDMETHOD(GetNodeType)(
		/*[out,retval]*/ DiscoveryNodeType* /*pType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUrl)(
		/*[out,retval]*/ BSTR* /*ppbstrUrl*/)VSL_STDMETHOD_NOTIMPL
};

class IReferenceInfoMockImpl :
	public IReferenceInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IReferenceInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IReferenceInfoMockImpl)

	typedef IReferenceInfo Interface;
	struct GetNodeTypeValidValues
	{
		/*[out,retval]*/ DiscoveryNodeType* pType;
		HRESULT retValue;
	};

	STDMETHOD(GetNodeType)(
		/*[out,retval]*/ DiscoveryNodeType* pType)
	{
		VSL_DEFINE_MOCK_METHOD(GetNodeType)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUrlValidValues
	{
		/*[out,retval]*/ BSTR* ppbstrUrl;
		HRESULT retValue;
	};

	STDMETHOD(GetUrl)(
		/*[out,retval]*/ BSTR* ppbstrUrl)
	{
		VSL_DEFINE_MOCK_METHOD(GetUrl)

		VSL_SET_VALIDVALUE_BSTR(ppbstrUrl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IREFERENCEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRequireClasses.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IREQUIRECLASSES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IREQUIRECLASSES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRequireClassesNotImpl :
	public IRequireClasses
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRequireClassesNotImpl)

public:

	typedef IRequireClasses Interface;

	STDMETHOD(CountRequiredClasses)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRequiredClasses)(
		/*[in]*/ ULONG /*index*/,
		/*[in]*/ CLSID* /*pclsid*/)VSL_STDMETHOD_NOTIMPL
};

class IRequireClassesMockImpl :
	public IRequireClasses,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRequireClassesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRequireClassesMockImpl)

	typedef IRequireClasses Interface;
	struct CountRequiredClassesValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(CountRequiredClasses)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(CountRequiredClasses)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRequiredClassesValidValues
	{
		/*[in]*/ ULONG index;
		/*[in]*/ CLSID* pclsid;
		HRESULT retValue;
	};

	STDMETHOD(GetRequiredClasses)(
		/*[in]*/ ULONG index,
		/*[in]*/ CLSID* pclsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetRequiredClasses)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE_POINTER(pclsid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IREQUIRECLASSES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIProvideRuntimeHTML.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IPROVIDERUNTIMEHTML_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IPROVIDERUNTIMEHTML_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ocdesign.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IProvideRuntimeHTMLNotImpl :
	public IProvideRuntimeHTML
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideRuntimeHTMLNotImpl)

public:

	typedef IProvideRuntimeHTML Interface;

	STDMETHOD(GetRuntimeHTML)(
		/*[out,retval]*/ BSTR* /*pstrRuntimeHTML*/)VSL_STDMETHOD_NOTIMPL
};

class IProvideRuntimeHTMLMockImpl :
	public IProvideRuntimeHTML,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IProvideRuntimeHTMLMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IProvideRuntimeHTMLMockImpl)

	typedef IProvideRuntimeHTML Interface;
	struct GetRuntimeHTMLValidValues
	{
		/*[out,retval]*/ BSTR* pstrRuntimeHTML;
		HRESULT retValue;
	};

	STDMETHOD(GetRuntimeHTML)(
		/*[out,retval]*/ BSTR* pstrRuntimeHTML)
	{
		VSL_DEFINE_MOCK_METHOD(GetRuntimeHTML)

		VSL_SET_VALIDVALUE_BSTR(pstrRuntimeHTML);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IPROVIDERUNTIMEHTML_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIReleaseMarshalBuffers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRELEASEMARSHALBUFFERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRELEASEMARSHALBUFFERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IReleaseMarshalBuffersNotImpl :
	public IReleaseMarshalBuffers
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IReleaseMarshalBuffersNotImpl)

public:

	typedef IReleaseMarshalBuffers Interface;

	STDMETHOD(ReleaseMarshalBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in,unique]*/ IUnknown* /*pChnl*/)VSL_STDMETHOD_NOTIMPL
};

class IReleaseMarshalBuffersMockImpl :
	public IReleaseMarshalBuffers,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IReleaseMarshalBuffersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IReleaseMarshalBuffersMockImpl)

	typedef IReleaseMarshalBuffers Interface;
	struct ReleaseMarshalBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		/*[in]*/ DWORD dwFlags;
		/*[in,unique]*/ IUnknown* pChnl;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseMarshalBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMsg,
		/*[in]*/ DWORD dwFlags,
		/*[in,unique]*/ IUnknown* pChnl)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseMarshalBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pChnl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRELEASEMARSHALBUFFERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRecordInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRECORDINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRECORDINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRecordInfoNotImpl :
	public IRecordInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRecordInfoNotImpl)

public:

	typedef IRecordInfo Interface;

	STDMETHOD(RecordInit)(
		/*[out]*/ PVOID /*pvNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordClear)(
		/*[in]*/ PVOID /*pvExisting*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordCopy)(
		/*[in]*/ PVOID /*pvExisting*/,
		/*[out]*/ PVOID /*pvNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuid)(
		/*[out]*/ GUID* /*pguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ ULONG* /*pcbSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[out]*/ ITypeInfo** /*ppTypeInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetField)(
		/*[in]*/ PVOID /*pvData*/,
		/*[in]*/ LPCOLESTR /*szFieldName*/,
		/*[out]*/ VARIANT* /*pvarField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFieldNoCopy)(
		/*[in]*/ PVOID /*pvData*/,
		/*[in]*/ LPCOLESTR /*szFieldName*/,
		/*[out]*/ VARIANT* /*pvarField*/,
		/*[out]*/ PVOID* /*ppvDataCArray*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PutField)(
		/*[in]*/ ULONG /*wFlags*/,
		/*[in,out]*/ PVOID /*pvData*/,
		/*[in]*/ LPCOLESTR /*szFieldName*/,
		/*[in]*/ VARIANT* /*pvarField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PutFieldNoCopy)(
		/*[in]*/ ULONG /*wFlags*/,
		/*[in,out]*/ PVOID /*pvData*/,
		/*[in]*/ LPCOLESTR /*szFieldName*/,
		/*[in]*/ VARIANT* /*pvarField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFieldNames)(
		/*[in,out]*/ ULONG* /*pcNames*/,
		/*[out,size_is(*pcNames),length_is(*pcNames)]*/ BSTR* /*rgBstrNames*/)VSL_STDMETHOD_NOTIMPL

	virtual BOOL STDMETHODCALLTYPE IsMatchingType(
		/*[in]*/ IRecordInfo* /*pRecordInfo*/){ return BOOL(); }

	virtual PVOID STDMETHODCALLTYPE RecordCreate(){ return PVOID(); }

	STDMETHOD(RecordCreateCopy)(
		/*[in]*/ PVOID /*pvSource*/,
		/*[out]*/ PVOID* /*ppvDest*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordDestroy)(
		/*[in]*/ PVOID /*pvRecord*/)VSL_STDMETHOD_NOTIMPL
};

class IRecordInfoMockImpl :
	public IRecordInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRecordInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRecordInfoMockImpl)

	typedef IRecordInfo Interface;
	struct RecordInitValidValues
	{
		/*[out]*/ PVOID pvNew;
		HRESULT retValue;
		size_t pvNew_size_in_bytes;
	};

	STDMETHOD(RecordInit)(
		/*[out]*/ PVOID pvNew)
	{
		VSL_DEFINE_MOCK_METHOD(RecordInit)

		VSL_SET_VALIDVALUE_PVOID(pvNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordClearValidValues
	{
		/*[in]*/ PVOID pvExisting;
		HRESULT retValue;
		size_t pvExisting_size_in_bytes;
	};

	STDMETHOD(RecordClear)(
		/*[in]*/ PVOID pvExisting)
	{
		VSL_DEFINE_MOCK_METHOD(RecordClear)

		VSL_CHECK_VALIDVALUE_PVOID(pvExisting);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCopyValidValues
	{
		/*[in]*/ PVOID pvExisting;
		/*[out]*/ PVOID pvNew;
		HRESULT retValue;
		size_t pvExisting_size_in_bytes;
		size_t pvNew_size_in_bytes;
	};

	STDMETHOD(RecordCopy)(
		/*[in]*/ PVOID pvExisting,
		/*[out]*/ PVOID pvNew)
	{
		VSL_DEFINE_MOCK_METHOD(RecordCopy)

		VSL_CHECK_VALIDVALUE_PVOID(pvExisting);

		VSL_SET_VALIDVALUE_PVOID(pvNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidValidValues
	{
		/*[out]*/ GUID* pguid;
		HRESULT retValue;
	};

	STDMETHOD(GetGuid)(
		/*[out]*/ GUID* pguid)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuid)

		VSL_SET_VALIDVALUE(pguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ ULONG* pcbSize;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ ULONG* pcbSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pcbSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[out]*/ ITypeInfo** ppTypeInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[out]*/ ITypeInfo** ppTypeInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppTypeInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFieldValidValues
	{
		/*[in]*/ PVOID pvData;
		/*[in]*/ LPCOLESTR szFieldName;
		/*[out]*/ VARIANT* pvarField;
		HRESULT retValue;
		size_t pvData_size_in_bytes;
	};

	STDMETHOD(GetField)(
		/*[in]*/ PVOID pvData,
		/*[in]*/ LPCOLESTR szFieldName,
		/*[out]*/ VARIANT* pvarField)
	{
		VSL_DEFINE_MOCK_METHOD(GetField)

		VSL_CHECK_VALIDVALUE_PVOID(pvData);

		VSL_CHECK_VALIDVALUE_STRINGW(szFieldName);

		VSL_SET_VALIDVALUE_VARIANT(pvarField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFieldNoCopyValidValues
	{
		/*[in]*/ PVOID pvData;
		/*[in]*/ LPCOLESTR szFieldName;
		/*[out]*/ VARIANT* pvarField;
		/*[out]*/ PVOID* ppvDataCArray;
		HRESULT retValue;
		size_t pvData_size_in_bytes;
	};

	STDMETHOD(GetFieldNoCopy)(
		/*[in]*/ PVOID pvData,
		/*[in]*/ LPCOLESTR szFieldName,
		/*[out]*/ VARIANT* pvarField,
		/*[out]*/ PVOID* ppvDataCArray)
	{
		VSL_DEFINE_MOCK_METHOD(GetFieldNoCopy)

		VSL_CHECK_VALIDVALUE_PVOID(pvData);

		VSL_CHECK_VALIDVALUE_STRINGW(szFieldName);

		VSL_SET_VALIDVALUE_VARIANT(pvarField);

		VSL_SET_VALIDVALUE(ppvDataCArray);

		VSL_RETURN_VALIDVALUES();
	}
	struct PutFieldValidValues
	{
		/*[in]*/ ULONG wFlags;
		/*[in,out]*/ PVOID pvData;
		/*[in]*/ LPCOLESTR szFieldName;
		/*[in]*/ VARIANT* pvarField;
		HRESULT retValue;
		size_t pvData_size_in_bytes;
	};

	STDMETHOD(PutField)(
		/*[in]*/ ULONG wFlags,
		/*[in,out]*/ PVOID pvData,
		/*[in]*/ LPCOLESTR szFieldName,
		/*[in]*/ VARIANT* pvarField)
	{
		VSL_DEFINE_MOCK_METHOD(PutField)

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE_PVOID(pvData);

		VSL_CHECK_VALIDVALUE_STRINGW(szFieldName);

		VSL_CHECK_VALIDVALUE_POINTER(pvarField);

		VSL_RETURN_VALIDVALUES();
	}
	struct PutFieldNoCopyValidValues
	{
		/*[in]*/ ULONG wFlags;
		/*[in,out]*/ PVOID pvData;
		/*[in]*/ LPCOLESTR szFieldName;
		/*[in]*/ VARIANT* pvarField;
		HRESULT retValue;
		size_t pvData_size_in_bytes;
	};

	STDMETHOD(PutFieldNoCopy)(
		/*[in]*/ ULONG wFlags,
		/*[in,out]*/ PVOID pvData,
		/*[in]*/ LPCOLESTR szFieldName,
		/*[in]*/ VARIANT* pvarField)
	{
		VSL_DEFINE_MOCK_METHOD(PutFieldNoCopy)

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE_PVOID(pvData);

		VSL_CHECK_VALIDVALUE_STRINGW(szFieldName);

		VSL_CHECK_VALIDVALUE_POINTER(pvarField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFieldNamesValidValues
	{
		/*[in,out]*/ ULONG* pcNames;
		/*[out,size_is(*pcNames),length_is(*pcNames)]*/ BSTR* rgBstrNames;
		HRESULT retValue;
	};

	STDMETHOD(GetFieldNames)(
		/*[in,out]*/ ULONG* pcNames,
		/*[out,size_is(*pcNames),length_is(*pcNames)]*/ BSTR* rgBstrNames)
	{
		VSL_DEFINE_MOCK_METHOD(GetFieldNames)

		VSL_SET_VALIDVALUE(pcNames);

		VSL_SET_VALIDVALUE_MEMCPY(rgBstrNames, *pcNames*sizeof(rgBstrNames[0]), *(validValues.pcNames)*sizeof(validValues.rgBstrNames[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct IsMatchingTypeValidValues
	{
		/*[in]*/ IRecordInfo* pRecordInfo;
		BOOL retValue;
	};

	virtual BOOL _stdcall IsMatchingType(
		/*[in]*/ IRecordInfo* pRecordInfo)
	{
		VSL_DEFINE_MOCK_METHOD(IsMatchingType)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRecordInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCreateValidValues
	{
		PVOID retValue;
	};

	virtual PVOID _stdcall RecordCreate()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordCreate)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCreateCopyValidValues
	{
		/*[in]*/ PVOID pvSource;
		/*[out]*/ PVOID* ppvDest;
		HRESULT retValue;
		size_t pvSource_size_in_bytes;
	};

	STDMETHOD(RecordCreateCopy)(
		/*[in]*/ PVOID pvSource,
		/*[out]*/ PVOID* ppvDest)
	{
		VSL_DEFINE_MOCK_METHOD(RecordCreateCopy)

		VSL_CHECK_VALIDVALUE_PVOID(pvSource);

		VSL_SET_VALIDVALUE(ppvDest);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordDestroyValidValues
	{
		/*[in]*/ PVOID pvRecord;
		HRESULT retValue;
		size_t pvRecord_size_in_bytes;
	};

	STDMETHOD(RecordDestroy)(
		/*[in]*/ PVOID pvRecord)
	{
		VSL_DEFINE_MOCK_METHOD(RecordDestroy)

		VSL_CHECK_VALIDVALUE_PVOID(pvRecord);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRECORDINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcChannelBuffer2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCCHANNELBUFFER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCCHANNELBUFFER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcChannelBuffer2NotImpl :
	public IRpcChannelBuffer2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcChannelBuffer2NotImpl)

public:

	typedef IRpcChannelBuffer2 Interface;

	STDMETHOD(GetProtocolVersion)(
		/*[in,out]*/ DWORD* /*pdwVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[in]*/ REFIID /*riid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[out]*/ ULONG* /*pStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* /*pdwDestContext*/,
		/*[out]*/ void** /*ppvDestContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsConnected)()VSL_STDMETHOD_NOTIMPL
};

class IRpcChannelBuffer2MockImpl :
	public IRpcChannelBuffer2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcChannelBuffer2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcChannelBuffer2MockImpl)

	typedef IRpcChannelBuffer2 Interface;
	struct GetProtocolVersionValidValues
	{
		/*[in,out]*/ DWORD* pdwVersion;
		HRESULT retValue;
	};

	STDMETHOD(GetProtocolVersion)(
		/*[in,out]*/ DWORD* pdwVersion)
	{
		VSL_DEFINE_MOCK_METHOD(GetProtocolVersion)

		VSL_SET_VALIDVALUE(pdwVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		/*[in]*/ REFIID riid;
		HRESULT retValue;
	};

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage,
		/*[in]*/ REFIID riid)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendReceiveValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMessage;
		/*[out]*/ ULONG* pStatus;
		HRESULT retValue;
	};

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* pMessage,
		/*[out]*/ ULONG* pStatus)
	{
		VSL_DEFINE_MOCK_METHOD(SendReceive)

		VSL_SET_VALIDVALUE(pMessage);

		VSL_SET_VALIDVALUE(pStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		HRESULT retValue;
	};

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage)
	{
		VSL_DEFINE_MOCK_METHOD(FreeBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestCtxValidValues
	{
		/*[out]*/ DWORD* pdwDestContext;
		/*[out]*/ void** ppvDestContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* pdwDestContext,
		/*[out]*/ void** ppvDestContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestCtx)

		VSL_SET_VALIDVALUE(pdwDestContext);

		VSL_SET_VALIDVALUE(ppvDestContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsConnectedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsConnected)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsConnected)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCCHANNELBUFFER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIROTData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IROTDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IROTDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IROTDataNotImpl :
	public IROTData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IROTDataNotImpl)

public:

	typedef IROTData Interface;

	STDMETHOD(GetComparisonData)(
		/*[out,size_is(cbMax)]*/ byte* /*pbData*/,
		/*[in]*/ ULONG /*cbMax*/,
		/*[out]*/ ULONG* /*pcbData*/)VSL_STDMETHOD_NOTIMPL
};

class IROTDataMockImpl :
	public IROTData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IROTDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IROTDataMockImpl)

	typedef IROTData Interface;
	struct GetComparisonDataValidValues
	{
		/*[out,size_is(cbMax)]*/ byte* pbData;
		/*[in]*/ ULONG cbMax;
		/*[out]*/ ULONG* pcbData;
		HRESULT retValue;
	};

	STDMETHOD(GetComparisonData)(
		/*[out,size_is(cbMax)]*/ byte* pbData,
		/*[in]*/ ULONG cbMax,
		/*[out]*/ ULONG* pcbData)
	{
		VSL_DEFINE_MOCK_METHOD(GetComparisonData)

		VSL_SET_VALIDVALUE_MEMCPY(pbData, cbMax*sizeof(pbData[0]), validValues.cbMax*sizeof(validValues.pbData[0]));

		VSL_CHECK_VALIDVALUE(cbMax);

		VSL_SET_VALIDVALUE(pcbData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IROTDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRootStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IROOTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IROOTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRootStorageNotImpl :
	public IRootStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRootStorageNotImpl)

public:

	typedef IRootStorage Interface;

	STDMETHOD(SwitchToFile)(
		/*[in]*/ LPOLESTR /*pszFile*/)VSL_STDMETHOD_NOTIMPL
};

class IRootStorageMockImpl :
	public IRootStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRootStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRootStorageMockImpl)

	typedef IRootStorage Interface;
	struct SwitchToFileValidValues
	{
		/*[in]*/ LPOLESTR pszFile;
		HRESULT retValue;
	};

	STDMETHOD(SwitchToFile)(
		/*[in]*/ LPOLESTR pszFile)
	{
		VSL_DEFINE_MOCK_METHOD(SwitchToFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFile);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IROOTSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcHelper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcHelperNotImpl :
	public IRpcHelper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcHelperNotImpl)

public:

	typedef IRpcHelper Interface;

	STDMETHOD(GetDCOMProtocolVersion)(
		/*[out]*/ DWORD* /*pComVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIIDFromOBJREF)(
		/*[in]*/ void* /*pObjRef*/,
		/*[out]*/ IID** /*piid*/)VSL_STDMETHOD_NOTIMPL
};

class IRpcHelperMockImpl :
	public IRpcHelper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcHelperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcHelperMockImpl)

	typedef IRpcHelper Interface;
	struct GetDCOMProtocolVersionValidValues
	{
		/*[out]*/ DWORD* pComVersion;
		HRESULT retValue;
	};

	STDMETHOD(GetDCOMProtocolVersion)(
		/*[out]*/ DWORD* pComVersion)
	{
		VSL_DEFINE_MOCK_METHOD(GetDCOMProtocolVersion)

		VSL_SET_VALIDVALUE(pComVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIIDFromOBJREFValidValues
	{
		/*[in]*/ void* pObjRef;
		/*[out]*/ IID** piid;
		HRESULT retValue;
		size_t pObjRef_size_in_bytes;
	};

	STDMETHOD(GetIIDFromOBJREF)(
		/*[in]*/ void* pObjRef,
		/*[out]*/ IID** piid)
	{
		VSL_DEFINE_MOCK_METHOD(GetIIDFromOBJREF)

		VSL_CHECK_VALIDVALUE_PVOID(pObjRef);

		VSL_SET_VALIDVALUE(piid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcChannelBuffer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCCHANNELBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCCHANNELBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcChannelBufferNotImpl :
	public IRpcChannelBuffer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcChannelBufferNotImpl)

public:

	typedef IRpcChannelBuffer Interface;

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[in]*/ REFIID /*riid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[out]*/ ULONG* /*pStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* /*pdwDestContext*/,
		/*[out]*/ void** /*ppvDestContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsConnected)()VSL_STDMETHOD_NOTIMPL
};

class IRpcChannelBufferMockImpl :
	public IRpcChannelBuffer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcChannelBufferMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcChannelBufferMockImpl)

	typedef IRpcChannelBuffer Interface;
	struct GetBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		/*[in]*/ REFIID riid;
		HRESULT retValue;
	};

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage,
		/*[in]*/ REFIID riid)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendReceiveValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMessage;
		/*[out]*/ ULONG* pStatus;
		HRESULT retValue;
	};

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* pMessage,
		/*[out]*/ ULONG* pStatus)
	{
		VSL_DEFINE_MOCK_METHOD(SendReceive)

		VSL_SET_VALIDVALUE(pMessage);

		VSL_SET_VALIDVALUE(pStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		HRESULT retValue;
	};

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage)
	{
		VSL_DEFINE_MOCK_METHOD(FreeBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestCtxValidValues
	{
		/*[out]*/ DWORD* pdwDestContext;
		/*[out]*/ void** ppvDestContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* pdwDestContext,
		/*[out]*/ void** ppvDestContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestCtx)

		VSL_SET_VALIDVALUE(pdwDestContext);

		VSL_SET_VALIDVALUE(ppvDestContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsConnectedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsConnected)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsConnected)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCCHANNELBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcChannelBuffer3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCCHANNELBUFFER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCCHANNELBUFFER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcChannelBuffer3NotImpl :
	public IRpcChannelBuffer3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcChannelBuffer3NotImpl)

public:

	typedef IRpcChannelBuffer3 Interface;

	STDMETHOD(Send)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[out]*/ ULONG* /*pulStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Receive)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[in]*/ ULONG /*ulSize*/,
		/*[out]*/ ULONG* /*pulStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Cancel)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCallContext)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*pInterface*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestCtxEx)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[out]*/ DWORD* /*pdwDestContext*/,
		/*[out]*/ void** /*ppvDestContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[out]*/ DWORD* /*pState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterAsync)(
		/*[in]*/ RPCOLEMESSAGE* /*pMsg*/,
		/*[in]*/ IAsyncManager* /*pAsyncMgr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProtocolVersion)(
		/*[in,out]*/ DWORD* /*pdwVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[in]*/ REFIID /*riid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMessage*/,
		/*[out]*/ ULONG* /*pStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* /*pMessage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* /*pdwDestContext*/,
		/*[out]*/ void** /*ppvDestContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsConnected)()VSL_STDMETHOD_NOTIMPL
};

class IRpcChannelBuffer3MockImpl :
	public IRpcChannelBuffer3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcChannelBuffer3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcChannelBuffer3MockImpl)

	typedef IRpcChannelBuffer3 Interface;
	struct SendValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMsg;
		/*[out]*/ ULONG* pulStatus;
		HRESULT retValue;
	};

	STDMETHOD(Send)(
		/*[in,out]*/ RPCOLEMESSAGE* pMsg,
		/*[out]*/ ULONG* pulStatus)
	{
		VSL_DEFINE_MOCK_METHOD(Send)

		VSL_SET_VALIDVALUE(pMsg);

		VSL_SET_VALIDVALUE(pulStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReceiveValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMsg;
		/*[in]*/ ULONG ulSize;
		/*[out]*/ ULONG* pulStatus;
		HRESULT retValue;
	};

	STDMETHOD(Receive)(
		/*[in,out]*/ RPCOLEMESSAGE* pMsg,
		/*[in]*/ ULONG ulSize,
		/*[out]*/ ULONG* pulStatus)
	{
		VSL_DEFINE_MOCK_METHOD(Receive)

		VSL_SET_VALIDVALUE(pMsg);

		VSL_CHECK_VALIDVALUE(ulSize);

		VSL_SET_VALIDVALUE(pulStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(Cancel)(
		/*[in]*/ RPCOLEMESSAGE* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(Cancel)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCallContextValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** pInterface;
		HRESULT retValue;
	};

	STDMETHOD(GetCallContext)(
		/*[in]*/ RPCOLEMESSAGE* pMsg,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** pInterface)
	{
		VSL_DEFINE_MOCK_METHOD(GetCallContext)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(pInterface);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestCtxExValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		/*[out]*/ DWORD* pdwDestContext;
		/*[out]*/ void** ppvDestContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDestCtxEx)(
		/*[in]*/ RPCOLEMESSAGE* pMsg,
		/*[out]*/ DWORD* pdwDestContext,
		/*[out]*/ void** ppvDestContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestCtxEx)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_SET_VALIDVALUE(pdwDestContext);

		VSL_SET_VALIDVALUE(ppvDestContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		/*[out]*/ DWORD* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[in]*/ RPCOLEMESSAGE* pMsg,
		/*[out]*/ DWORD* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterAsyncValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMsg;
		/*[in]*/ IAsyncManager* pAsyncMgr;
		HRESULT retValue;
	};

	STDMETHOD(RegisterAsync)(
		/*[in]*/ RPCOLEMESSAGE* pMsg,
		/*[in]*/ IAsyncManager* pAsyncMgr)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterAsync)

		VSL_CHECK_VALIDVALUE_POINTER(pMsg);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAsyncMgr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProtocolVersionValidValues
	{
		/*[in,out]*/ DWORD* pdwVersion;
		HRESULT retValue;
	};

	STDMETHOD(GetProtocolVersion)(
		/*[in,out]*/ DWORD* pdwVersion)
	{
		VSL_DEFINE_MOCK_METHOD(GetProtocolVersion)

		VSL_SET_VALIDVALUE(pdwVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		/*[in]*/ REFIID riid;
		HRESULT retValue;
	};

	STDMETHOD(GetBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage,
		/*[in]*/ REFIID riid)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SendReceiveValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMessage;
		/*[out]*/ ULONG* pStatus;
		HRESULT retValue;
	};

	STDMETHOD(SendReceive)(
		/*[in,out]*/ RPCOLEMESSAGE* pMessage,
		/*[out]*/ ULONG* pStatus)
	{
		VSL_DEFINE_MOCK_METHOD(SendReceive)

		VSL_SET_VALIDVALUE(pMessage);

		VSL_SET_VALIDVALUE(pStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeBufferValidValues
	{
		/*[in]*/ RPCOLEMESSAGE* pMessage;
		HRESULT retValue;
	};

	STDMETHOD(FreeBuffer)(
		/*[in]*/ RPCOLEMESSAGE* pMessage)
	{
		VSL_DEFINE_MOCK_METHOD(FreeBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pMessage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestCtxValidValues
	{
		/*[out]*/ DWORD* pdwDestContext;
		/*[out]*/ void** ppvDestContext;
		HRESULT retValue;
	};

	STDMETHOD(GetDestCtx)(
		/*[out]*/ DWORD* pdwDestContext,
		/*[out]*/ void** ppvDestContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestCtx)

		VSL_SET_VALIDVALUE(pdwDestContext);

		VSL_SET_VALIDVALUE(ppvDestContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsConnectedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsConnected)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsConnected)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCCHANNELBUFFER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcOptions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcOptionsNotImpl :
	public IRpcOptions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcOptionsNotImpl)

public:

	typedef IRpcOptions Interface;

	STDMETHOD(Set)(
		/*[in]*/ IUnknown* /*pPrx*/,
		/*[in]*/ DWORD /*dwProperty*/,
		/*[in]*/ ULONG_PTR /*dwValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Query)(
		/*[in]*/ IUnknown* /*pPrx*/,
		/*[in]*/ DWORD /*dwProperty*/,
		/*[out]*/ ULONG_PTR* /*pdwValue*/)VSL_STDMETHOD_NOTIMPL
};

class IRpcOptionsMockImpl :
	public IRpcOptions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcOptionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcOptionsMockImpl)

	typedef IRpcOptions Interface;
	struct SetValidValues
	{
		/*[in]*/ IUnknown* pPrx;
		/*[in]*/ DWORD dwProperty;
		/*[in]*/ ULONG_PTR dwValue;
		HRESULT retValue;
	};

	STDMETHOD(Set)(
		/*[in]*/ IUnknown* pPrx,
		/*[in]*/ DWORD dwProperty,
		/*[in]*/ ULONG_PTR dwValue)
	{
		VSL_DEFINE_MOCK_METHOD(Set)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPrx);

		VSL_CHECK_VALIDVALUE(dwProperty);

		VSL_CHECK_VALIDVALUE(dwValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryValidValues
	{
		/*[in]*/ IUnknown* pPrx;
		/*[in]*/ DWORD dwProperty;
		/*[out]*/ ULONG_PTR* pdwValue;
		HRESULT retValue;
	};

	STDMETHOD(Query)(
		/*[in]*/ IUnknown* pPrx,
		/*[in]*/ DWORD dwProperty,
		/*[out]*/ ULONG_PTR* pdwValue)
	{
		VSL_DEFINE_MOCK_METHOD(Query)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPrx);

		VSL_CHECK_VALIDVALUE(dwProperty);

		VSL_SET_VALIDVALUE(pdwValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcProxyBuffer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCPROXYBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCPROXYBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcProxyBufferNotImpl :
	public IRpcProxyBuffer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcProxyBufferNotImpl)

public:

	typedef IRpcProxyBuffer Interface;

	STDMETHOD(Connect)(
		/*[in,unique]*/ IRpcChannelBuffer* /*pRpcChannelBuffer*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE Disconnect(){ return ; }
};

class IRpcProxyBufferMockImpl :
	public IRpcProxyBuffer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcProxyBufferMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcProxyBufferMockImpl)

	typedef IRpcProxyBuffer Interface;
	struct ConnectValidValues
	{
		/*[in,unique]*/ IRpcChannelBuffer* pRpcChannelBuffer;
		HRESULT retValue;
	};

	STDMETHOD(Connect)(
		/*[in,unique]*/ IRpcChannelBuffer* pRpcChannelBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(Connect)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRpcChannelBuffer);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall Disconnect()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Disconnect)

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCPROXYBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRpcSyntaxNegotiate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRPCSYNTAXNEGOTIATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRPCSYNTAXNEGOTIATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRpcSyntaxNegotiateNotImpl :
	public IRpcSyntaxNegotiate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcSyntaxNegotiateNotImpl)

public:

	typedef IRpcSyntaxNegotiate Interface;

	STDMETHOD(NegotiateSyntax)(
		/*[in,out]*/ RPCOLEMESSAGE* /*pMsg*/)VSL_STDMETHOD_NOTIMPL
};

class IRpcSyntaxNegotiateMockImpl :
	public IRpcSyntaxNegotiate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRpcSyntaxNegotiateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRpcSyntaxNegotiateMockImpl)

	typedef IRpcSyntaxNegotiate Interface;
	struct NegotiateSyntaxValidValues
	{
		/*[in,out]*/ RPCOLEMESSAGE* pMsg;
		HRESULT retValue;
	};

	STDMETHOD(NegotiateSyntax)(
		/*[in,out]*/ RPCOLEMESSAGE* pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(NegotiateSyntax)

		VSL_SET_VALIDVALUE(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRPCSYNTAXNEGOTIATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRunnableObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRUNNABLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRUNNABLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRunnableObjectNotImpl :
	public IRunnableObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRunnableObjectNotImpl)

public:

	typedef IRunnableObject Interface;

	STDMETHOD(GetRunningClass)(
		/*[out]*/ LPCLSID /*lpClsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Run)(
		/*[in]*/ LPBINDCTX /*pbc*/)VSL_STDMETHOD_NOTIMPL

	virtual BOOL STDMETHODCALLTYPE IsRunning(){ return BOOL(); }

	STDMETHOD(LockRunning)(
		/*[in]*/ BOOL /*fLock*/,
		/*[in]*/ BOOL /*fLastUnlockCloses*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContainedObject)(
		/*[in]*/ BOOL /*fContained*/)VSL_STDMETHOD_NOTIMPL
};

class IRunnableObjectMockImpl :
	public IRunnableObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRunnableObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRunnableObjectMockImpl)

	typedef IRunnableObject Interface;
	struct GetRunningClassValidValues
	{
		/*[out]*/ LPCLSID lpClsid;
		HRESULT retValue;
	};

	STDMETHOD(GetRunningClass)(
		/*[out]*/ LPCLSID lpClsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetRunningClass)

		VSL_SET_VALIDVALUE(lpClsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RunValidValues
	{
		/*[in]*/ LPBINDCTX pbc;
		HRESULT retValue;
	};

	STDMETHOD(Run)(
		/*[in]*/ LPBINDCTX pbc)
	{
		VSL_DEFINE_MOCK_METHOD(Run)

		VSL_CHECK_VALIDVALUE(pbc);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsRunningValidValues
	{
		BOOL retValue;
	};

	virtual BOOL _stdcall IsRunning()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsRunning)

		VSL_RETURN_VALIDVALUES();
	}
	struct LockRunningValidValues
	{
		/*[in]*/ BOOL fLock;
		/*[in]*/ BOOL fLastUnlockCloses;
		HRESULT retValue;
	};

	STDMETHOD(LockRunning)(
		/*[in]*/ BOOL fLock,
		/*[in]*/ BOOL fLastUnlockCloses)
	{
		VSL_DEFINE_MOCK_METHOD(LockRunning)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_CHECK_VALIDVALUE(fLastUnlockCloses);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContainedObjectValidValues
	{
		/*[in]*/ BOOL fContained;
		HRESULT retValue;
	};

	STDMETHOD(SetContainedObject)(
		/*[in]*/ BOOL fContained)
	{
		VSL_DEFINE_MOCK_METHOD(SetContainedObject)

		VSL_CHECK_VALIDVALUE(fContained);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRUNNABLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIServiceProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISERVICEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISERVICEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ServProv.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IServiceProviderNotImpl :
	public IServiceProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IServiceProviderNotImpl)

public:

	typedef IServiceProvider Interface;

	STDMETHOD(QueryService)(
		/*[in]*/ REFGUID /*guidService*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL
};

class IServiceProviderMockImpl :
	public IServiceProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IServiceProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IServiceProviderMockImpl)

	typedef IServiceProvider Interface;
	struct QueryServiceValidValues
	{
		/*[in]*/ REFGUID guidService;
		/*[in]*/ REFIID riid;
		/*[out]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(QueryService)(
		/*[in]*/ REFGUID guidService,
		/*[in]*/ REFIID riid,
		/*[out]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(QueryService)

		VSL_CHECK_VALIDVALUE(guidService);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISERVICEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIRunningObjectTable.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IRUNNINGOBJECTTABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IRUNNINGOBJECTTABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IRunningObjectTableNotImpl :
	public IRunningObjectTable
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRunningObjectTableNotImpl)

public:

	typedef IRunningObjectTable Interface;

	STDMETHOD(Register)(
		/*[in]*/ DWORD /*grfFlags*/,
		/*[in,unique]*/ IUnknown* /*punkObject*/,
		/*[in,unique]*/ IMoniker* /*pmkObjectName*/,
		/*[out]*/ DWORD* /*pdwRegister*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Revoke)(
		/*[in]*/ DWORD /*dwRegister*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsRunning)(
		/*[in,unique]*/ IMoniker* /*pmkObjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetObject)(
		/*[in,unique]*/ IMoniker* /*pmkObjectName*/,
		/*[out]*/ IUnknown** /*ppunkObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NoteChangeTime)(
		/*[in]*/ DWORD /*dwRegister*/,
		/*[in]*/ FILETIME* /*pfiletime*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTimeOfLastChange)(
		/*[in,unique]*/ IMoniker* /*pmkObjectName*/,
		/*[out]*/ FILETIME* /*pfiletime*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumRunning)(
		/*[out]*/ IEnumMoniker** /*ppenumMoniker*/)VSL_STDMETHOD_NOTIMPL
};

class IRunningObjectTableMockImpl :
	public IRunningObjectTable,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IRunningObjectTableMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IRunningObjectTableMockImpl)

	typedef IRunningObjectTable Interface;
	struct RegisterValidValues
	{
		/*[in]*/ DWORD grfFlags;
		/*[in,unique]*/ IUnknown* punkObject;
		/*[in,unique]*/ IMoniker* pmkObjectName;
		/*[out]*/ DWORD* pdwRegister;
		HRESULT retValue;
	};

	STDMETHOD(Register)(
		/*[in]*/ DWORD grfFlags,
		/*[in,unique]*/ IUnknown* punkObject,
		/*[in,unique]*/ IMoniker* pmkObjectName,
		/*[out]*/ DWORD* pdwRegister)
	{
		VSL_DEFINE_MOCK_METHOD(Register)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkObject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkObjectName);

		VSL_SET_VALIDVALUE(pdwRegister);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevokeValidValues
	{
		/*[in]*/ DWORD dwRegister;
		HRESULT retValue;
	};

	STDMETHOD(Revoke)(
		/*[in]*/ DWORD dwRegister)
	{
		VSL_DEFINE_MOCK_METHOD(Revoke)

		VSL_CHECK_VALIDVALUE(dwRegister);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsRunningValidValues
	{
		/*[in,unique]*/ IMoniker* pmkObjectName;
		HRESULT retValue;
	};

	STDMETHOD(IsRunning)(
		/*[in,unique]*/ IMoniker* pmkObjectName)
	{
		VSL_DEFINE_MOCK_METHOD(IsRunning)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkObjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetObjectValidValues
	{
		/*[in,unique]*/ IMoniker* pmkObjectName;
		/*[out]*/ IUnknown** ppunkObject;
		HRESULT retValue;
	};

	STDMETHOD(GetObject)(
		/*[in,unique]*/ IMoniker* pmkObjectName,
		/*[out]*/ IUnknown** ppunkObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkObjectName);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct NoteChangeTimeValidValues
	{
		/*[in]*/ DWORD dwRegister;
		/*[in]*/ FILETIME* pfiletime;
		HRESULT retValue;
	};

	STDMETHOD(NoteChangeTime)(
		/*[in]*/ DWORD dwRegister,
		/*[in]*/ FILETIME* pfiletime)
	{
		VSL_DEFINE_MOCK_METHOD(NoteChangeTime)

		VSL_CHECK_VALIDVALUE(dwRegister);

		VSL_CHECK_VALIDVALUE_POINTER(pfiletime);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTimeOfLastChangeValidValues
	{
		/*[in,unique]*/ IMoniker* pmkObjectName;
		/*[out]*/ FILETIME* pfiletime;
		HRESULT retValue;
	};

	STDMETHOD(GetTimeOfLastChange)(
		/*[in,unique]*/ IMoniker* pmkObjectName,
		/*[out]*/ FILETIME* pfiletime)
	{
		VSL_DEFINE_MOCK_METHOD(GetTimeOfLastChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pmkObjectName);

		VSL_SET_VALIDVALUE(pfiletime);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumRunningValidValues
	{
		/*[out]*/ IEnumMoniker** ppenumMoniker;
		HRESULT retValue;
	};

	STDMETHOD(EnumRunning)(
		/*[out]*/ IEnumMoniker** ppenumMoniker)
	{
		VSL_DEFINE_MOCK_METHOD(EnumRunning)

		VSL_SET_VALIDVALUE_INTERFACE(ppenumMoniker);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IRUNNINGOBJECTTABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISchemaReferenceInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISCHEMAREFERENCEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISCHEMAREFERENCEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISchemaReferenceInfoNotImpl :
	public ISchemaReferenceInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISchemaReferenceInfoNotImpl)

public:

	typedef ISchemaReferenceInfo Interface;

	STDMETHOD(GetTargetNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRef*/)VSL_STDMETHOD_NOTIMPL
};

class ISchemaReferenceInfoMockImpl :
	public ISchemaReferenceInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISchemaReferenceInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISchemaReferenceInfoMockImpl)

	typedef ISchemaReferenceInfo Interface;
	struct GetTargetNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRef;
		HRESULT retValue;
	};

	STDMETHOD(GetTargetNamespace)(
		/*[out,retval]*/ BSTR* pbstrRef)
	{
		VSL_DEFINE_MOCK_METHOD(GetTargetNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRef);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISCHEMAREFERENCEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISelectionContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISELECTIONCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISELECTIONCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISelectionContainerNotImpl :
	public ISelectionContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISelectionContainerNotImpl)

public:

	typedef ISelectionContainer Interface;

	STDMETHOD(CountObjects)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ ULONG* /*pc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetObjects)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ ULONG /*cObjects*/,
		/*[out,size_is(cObjects)]*/ IUnknown** /*apUnkObjects*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectObjects)(
		/*[in]*/ ULONG /*cSelect*/,
		/*[in,size_is(cSelect)]*/ IUnknown** /*apUnkSelect*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL
};

class ISelectionContainerMockImpl :
	public ISelectionContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISelectionContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISelectionContainerMockImpl)

	typedef ISelectionContainer Interface;
	struct CountObjectsValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ ULONG* pc;
		HRESULT retValue;
	};

	STDMETHOD(CountObjects)(
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ ULONG* pc)
	{
		VSL_DEFINE_MOCK_METHOD(CountObjects)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(pc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetObjectsValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ ULONG cObjects;
		/*[out,size_is(cObjects)]*/ IUnknown** apUnkObjects;
		HRESULT retValue;
	};

	STDMETHOD(GetObjects)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ ULONG cObjects,
		/*[out,size_is(cObjects)]*/ IUnknown** apUnkObjects)
	{
		VSL_DEFINE_MOCK_METHOD(GetObjects)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(cObjects);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(apUnkObjects, cObjects, validValues.cObjects);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectObjectsValidValues
	{
		/*[in]*/ ULONG cSelect;
		/*[in,size_is(cSelect)]*/ IUnknown** apUnkSelect;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(SelectObjects)(
		/*[in]*/ ULONG cSelect,
		/*[in,size_is(cSelect)]*/ IUnknown** apUnkSelect,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SelectObjects)

		VSL_CHECK_VALIDVALUE(cSelect);

		VSL_CHECK_VALIDVALUE_ARRAY(apUnkSelect, cSelect, validValues.cSelect);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISELECTIONCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIServerSecurity.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISERVERSECURITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISERVERSECURITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IServerSecurityNotImpl :
	public IServerSecurity
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IServerSecurityNotImpl)

public:

	typedef IServerSecurity Interface;

	STDMETHOD(QueryBlanket)(
		/*[out]*/ DWORD* /*pAuthnSvc*/,
		/*[out]*/ DWORD* /*pAuthzSvc*/,
		/*[out]*/ OLECHAR** /*pServerPrincName*/,
		/*[out]*/ DWORD* /*pAuthnLevel*/,
		/*[out]*/ DWORD* /*pImpLevel*/,
		/*[out]*/ void** /*pPrivs*/,
		/*[in,out]*/ DWORD* /*pCapabilities*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ImpersonateClient)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevertToSelf)()VSL_STDMETHOD_NOTIMPL

	virtual BOOL STDMETHODCALLTYPE IsImpersonating(){ return BOOL(); }
};

class IServerSecurityMockImpl :
	public IServerSecurity,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IServerSecurityMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IServerSecurityMockImpl)

	typedef IServerSecurity Interface;
	struct QueryBlanketValidValues
	{
		/*[out]*/ DWORD* pAuthnSvc;
		/*[out]*/ DWORD* pAuthzSvc;
		/*[out]*/ OLECHAR** pServerPrincName;
		/*[out]*/ DWORD* pAuthnLevel;
		/*[out]*/ DWORD* pImpLevel;
		/*[out]*/ void** pPrivs;
		/*[in,out]*/ DWORD* pCapabilities;
		HRESULT retValue;
	};

	STDMETHOD(QueryBlanket)(
		/*[out]*/ DWORD* pAuthnSvc,
		/*[out]*/ DWORD* pAuthzSvc,
		/*[out]*/ OLECHAR** pServerPrincName,
		/*[out]*/ DWORD* pAuthnLevel,
		/*[out]*/ DWORD* pImpLevel,
		/*[out]*/ void** pPrivs,
		/*[in,out]*/ DWORD* pCapabilities)
	{
		VSL_DEFINE_MOCK_METHOD(QueryBlanket)

		VSL_SET_VALIDVALUE(pAuthnSvc);

		VSL_SET_VALIDVALUE(pAuthzSvc);

		VSL_SET_VALIDVALUE(pServerPrincName);

		VSL_SET_VALIDVALUE(pAuthnLevel);

		VSL_SET_VALIDVALUE(pImpLevel);

		VSL_SET_VALIDVALUE(pPrivs);

		VSL_SET_VALIDVALUE(pCapabilities);

		VSL_RETURN_VALIDVALUES();
	}
	struct ImpersonateClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ImpersonateClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ImpersonateClient)

		VSL_RETURN_VALIDVALUES();
	}
	struct RevertToSelfValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RevertToSelf)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RevertToSelf)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsImpersonatingValidValues
	{
		BOOL retValue;
	};

	virtual BOOL _stdcall IsImpersonating()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsImpersonating)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISERVERSECURITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISequentialStream.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISEQUENTIALSTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISEQUENTIALSTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISequentialStreamNotImpl :
	public ISequentialStream
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISequentialStreamNotImpl)

public:

	typedef ISequentialStream Interface;

	STDMETHOD(Read)(
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbRead*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Write)(
		/*[in,size_is(cb)]*/ const void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL
};

class ISequentialStreamMockImpl :
	public ISequentialStream,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISequentialStreamMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISequentialStreamMockImpl)

	typedef ISequentialStream Interface;
	struct ReadValidValues
	{
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbRead;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(Read)(
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbRead)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_SET_VALIDVALUE_MEMCPY(pv, cb, *(validValues.pcbRead));

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbRead);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteValidValues
	{
		/*[in,size_is(cb)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbWritten;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(Write)(
		/*[in,size_is(cb)]*/ const void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(Write)

		VSL_CHECK_VALIDVALUE_MEMCMP(pv, cb, validValues.cb);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISEQUENTIALSTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISpecifyPropertyPages.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISPECIFYPROPERTYPAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISPECIFYPROPERTYPAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISpecifyPropertyPagesNotImpl :
	public ISpecifyPropertyPages
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISpecifyPropertyPagesNotImpl)

public:

	typedef ISpecifyPropertyPages Interface;

	STDMETHOD(GetPages)(
		/*[out]*/ CAUUID* /*pPages*/)VSL_STDMETHOD_NOTIMPL
};

class ISpecifyPropertyPagesMockImpl :
	public ISpecifyPropertyPages,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISpecifyPropertyPagesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISpecifyPropertyPagesMockImpl)

	typedef ISpecifyPropertyPages Interface;
	struct GetPagesValidValues
	{
		/*[out]*/ CAUUID* pPages;
		HRESULT retValue;
	};

	STDMETHOD(GetPages)(
		/*[out]*/ CAUUID* pPages)
	{
		VSL_DEFINE_MOCK_METHOD(GetPages)

		VSL_SET_VALIDVALUE(pPages);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISPECIFYPROPERTYPAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIStdMarshalInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISTDMARSHALINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISTDMARSHALINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IStdMarshalInfoNotImpl :
	public IStdMarshalInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IStdMarshalInfoNotImpl)

public:

	typedef IStdMarshalInfo Interface;

	STDMETHOD(GetClassForHandler)(
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in,unique]*/ void* /*pvDestContext*/,
		/*[out]*/ CLSID* /*pClsid*/)VSL_STDMETHOD_NOTIMPL
};

class IStdMarshalInfoMockImpl :
	public IStdMarshalInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IStdMarshalInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IStdMarshalInfoMockImpl)

	typedef IStdMarshalInfo Interface;
	struct GetClassForHandlerValidValues
	{
		/*[in]*/ DWORD dwDestContext;
		/*[in,unique]*/ void* pvDestContext;
		/*[out]*/ CLSID* pClsid;
		HRESULT retValue;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(GetClassForHandler)(
		/*[in]*/ DWORD dwDestContext,
		/*[in,unique]*/ void* pvDestContext,
		/*[out]*/ CLSID* pClsid)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassForHandler)

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_SET_VALIDVALUE(pClsid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISTDMARSHALINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISimpleFrameSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISIMPLEFRAMESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISIMPLEFRAMESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OCIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISimpleFrameSiteNotImpl :
	public ISimpleFrameSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISimpleFrameSiteNotImpl)

public:

	typedef ISimpleFrameSite Interface;

	STDMETHOD(PreMessageFilter)(
		/*[in]*/ HWND /*hWnd*/,
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wp*/,
		/*[in]*/ LPARAM /*lp*/,
		/*[out]*/ LRESULT* /*plResult*/,
		/*[out]*/ DWORD* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PostMessageFilter)(
		/*[in]*/ HWND /*hWnd*/,
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wp*/,
		/*[in]*/ LPARAM /*lp*/,
		/*[out]*/ LRESULT* /*plResult*/,
		/*[in]*/ DWORD /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class ISimpleFrameSiteMockImpl :
	public ISimpleFrameSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISimpleFrameSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISimpleFrameSiteMockImpl)

	typedef ISimpleFrameSite Interface;
	struct PreMessageFilterValidValues
	{
		/*[in]*/ HWND hWnd;
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wp;
		/*[in]*/ LPARAM lp;
		/*[out]*/ LRESULT* plResult;
		/*[out]*/ DWORD* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(PreMessageFilter)(
		/*[in]*/ HWND hWnd,
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wp,
		/*[in]*/ LPARAM lp,
		/*[out]*/ LRESULT* plResult,
		/*[out]*/ DWORD* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(PreMessageFilter)

		VSL_CHECK_VALIDVALUE(hWnd);

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wp);

		VSL_CHECK_VALIDVALUE(lp);

		VSL_SET_VALIDVALUE(plResult);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostMessageFilterValidValues
	{
		/*[in]*/ HWND hWnd;
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wp;
		/*[in]*/ LPARAM lp;
		/*[out]*/ LRESULT* plResult;
		/*[in]*/ DWORD dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(PostMessageFilter)(
		/*[in]*/ HWND hWnd,
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wp,
		/*[in]*/ LPARAM lp,
		/*[out]*/ LRESULT* plResult,
		/*[in]*/ DWORD dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(PostMessageFilter)

		VSL_CHECK_VALIDVALUE(hWnd);

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wp);

		VSL_CHECK_VALIDVALUE(lp);

		VSL_SET_VALIDVALUE(plResult);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISIMPLEFRAMESITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISupportErrorInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISUPPORTERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISUPPORTERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISupportErrorInfoNotImpl :
	public ISupportErrorInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISupportErrorInfoNotImpl)

public:

	typedef ISupportErrorInfo Interface;

	STDMETHOD(InterfaceSupportsErrorInfo)(
		/*[in]*/ REFIID /*riid*/)VSL_STDMETHOD_NOTIMPL
};

class ISupportErrorInfoMockImpl :
	public ISupportErrorInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISupportErrorInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISupportErrorInfoMockImpl)

	typedef ISupportErrorInfo Interface;
	struct InterfaceSupportsErrorInfoValidValues
	{
		/*[in]*/ REFIID riid;
		HRESULT retValue;
	};

	STDMETHOD(InterfaceSupportsErrorInfo)(
		/*[in]*/ REFIID riid)
	{
		VSL_DEFINE_MOCK_METHOD(InterfaceSupportsErrorInfo)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISUPPORTERRORINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISurrogate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISURROGATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISURROGATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISurrogateNotImpl :
	public ISurrogate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISurrogateNotImpl)

public:

	typedef ISurrogate Interface;

	STDMETHOD(LoadDllServer)(
		/*[in]*/ REFCLSID /*Clsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeSurrogate)()VSL_STDMETHOD_NOTIMPL
};

class ISurrogateMockImpl :
	public ISurrogate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISurrogateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISurrogateMockImpl)

	typedef ISurrogate Interface;
	struct LoadDllServerValidValues
	{
		/*[in]*/ REFCLSID Clsid;
		HRESULT retValue;
	};

	STDMETHOD(LoadDllServer)(
		/*[in]*/ REFCLSID Clsid)
	{
		VSL_DEFINE_MOCK_METHOD(LoadDllServer)

		VSL_CHECK_VALIDVALUE(Clsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeSurrogateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FreeSurrogate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FreeSurrogate)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISURROGATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIStream.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IStreamNotImpl :
	public IStream
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IStreamNotImpl)

public:

	typedef IStream Interface;

	STDMETHOD(Seek)(
		/*[in]*/ LARGE_INTEGER /*dlibMove*/,
		/*[in]*/ DWORD /*dwOrigin*/,
		/*[out]*/ ULARGE_INTEGER* /*plibNewPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSize)(
		/*[in]*/ ULARGE_INTEGER /*libNewSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyTo)(
		/*[in,unique]*/ IStream* /*pstm*/,
		/*[in]*/ ULARGE_INTEGER /*cb*/,
		/*[out]*/ ULARGE_INTEGER* /*pcbRead*/,
		/*[out]*/ ULARGE_INTEGER* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Commit)(
		/*[in]*/ DWORD /*grfCommitFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Revert)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockRegion)(
		/*[in]*/ ULARGE_INTEGER /*libOffset*/,
		/*[in]*/ ULARGE_INTEGER /*cb*/,
		/*[in]*/ DWORD /*dwLockType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockRegion)(
		/*[in]*/ ULARGE_INTEGER /*libOffset*/,
		/*[in]*/ ULARGE_INTEGER /*cb*/,
		/*[in]*/ DWORD /*dwLockType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Stat)(
		/*[out]*/ STATSTG* /*pstatstg*/,
		/*[in]*/ DWORD /*grfStatFlag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IStream** /*ppstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Read)(
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbRead*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Write)(
		/*[in,size_is(cb)]*/ const void* /*pv*/,
		/*[in]*/ ULONG /*cb*/,
		/*[out]*/ ULONG* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL
};

class IStreamMockImpl :
	public IStream,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IStreamMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IStreamMockImpl)

	typedef IStream Interface;
	struct SeekValidValues
	{
		/*[in]*/ LARGE_INTEGER dlibMove;
		/*[in]*/ DWORD dwOrigin;
		/*[out]*/ ULARGE_INTEGER* plibNewPosition;
		HRESULT retValue;
	};

	STDMETHOD(Seek)(
		/*[in]*/ LARGE_INTEGER dlibMove,
		/*[in]*/ DWORD dwOrigin,
		/*[out]*/ ULARGE_INTEGER* plibNewPosition)
	{
		VSL_DEFINE_MOCK_METHOD(Seek)

		VSL_CHECK_VALIDVALUE(dlibMove);

		VSL_CHECK_VALIDVALUE(dwOrigin);

		VSL_SET_VALIDVALUE(plibNewPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSizeValidValues
	{
		/*[in]*/ ULARGE_INTEGER libNewSize;
		HRESULT retValue;
	};

	STDMETHOD(SetSize)(
		/*[in]*/ ULARGE_INTEGER libNewSize)
	{
		VSL_DEFINE_MOCK_METHOD(SetSize)

		VSL_CHECK_VALIDVALUE(libNewSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyToValidValues
	{
		/*[in,unique]*/ IStream* pstm;
		/*[in]*/ ULARGE_INTEGER cb;
		/*[out]*/ ULARGE_INTEGER* pcbRead;
		/*[out]*/ ULARGE_INTEGER* pcbWritten;
		HRESULT retValue;
	};

	STDMETHOD(CopyTo)(
		/*[in,unique]*/ IStream* pstm,
		/*[in]*/ ULARGE_INTEGER cb,
		/*[out]*/ ULARGE_INTEGER* pcbRead,
		/*[out]*/ ULARGE_INTEGER* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(CopyTo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstm);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbRead);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
	struct CommitValidValues
	{
		/*[in]*/ DWORD grfCommitFlags;
		HRESULT retValue;
	};

	STDMETHOD(Commit)(
		/*[in]*/ DWORD grfCommitFlags)
	{
		VSL_DEFINE_MOCK_METHOD(Commit)

		VSL_CHECK_VALIDVALUE(grfCommitFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevertValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Revert)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Revert)

		VSL_RETURN_VALIDVALUES();
	}
	struct LockRegionValidValues
	{
		/*[in]*/ ULARGE_INTEGER libOffset;
		/*[in]*/ ULARGE_INTEGER cb;
		/*[in]*/ DWORD dwLockType;
		HRESULT retValue;
	};

	STDMETHOD(LockRegion)(
		/*[in]*/ ULARGE_INTEGER libOffset,
		/*[in]*/ ULARGE_INTEGER cb,
		/*[in]*/ DWORD dwLockType)
	{
		VSL_DEFINE_MOCK_METHOD(LockRegion)

		VSL_CHECK_VALIDVALUE(libOffset);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_CHECK_VALIDVALUE(dwLockType);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockRegionValidValues
	{
		/*[in]*/ ULARGE_INTEGER libOffset;
		/*[in]*/ ULARGE_INTEGER cb;
		/*[in]*/ DWORD dwLockType;
		HRESULT retValue;
	};

	STDMETHOD(UnlockRegion)(
		/*[in]*/ ULARGE_INTEGER libOffset,
		/*[in]*/ ULARGE_INTEGER cb,
		/*[in]*/ DWORD dwLockType)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockRegion)

		VSL_CHECK_VALIDVALUE(libOffset);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_CHECK_VALIDVALUE(dwLockType);

		VSL_RETURN_VALIDVALUES();
	}
	struct StatValidValues
	{
		/*[out]*/ STATSTG* pstatstg;
		/*[in]*/ DWORD grfStatFlag;
		HRESULT retValue;
	};

	STDMETHOD(Stat)(
		/*[out]*/ STATSTG* pstatstg,
		/*[in]*/ DWORD grfStatFlag)
	{
		VSL_DEFINE_MOCK_METHOD(Stat)

		VSL_SET_VALIDVALUE(pstatstg);

		VSL_CHECK_VALIDVALUE(grfStatFlag);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IStream** ppstm;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IStream** ppstm)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadValidValues
	{
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbRead;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(Read)(
		/*[out,size_is(cb),length_is(*pcbRead)]*/ void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbRead)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_SET_VALIDVALUE_MEMCPY(pv, cb, *(validValues.pcbRead));

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbRead);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteValidValues
	{
		/*[in,size_is(cb)]*/ void* pv;
		/*[in]*/ ULONG cb;
		/*[out]*/ ULONG* pcbWritten;
		HRESULT retValue;
		size_t pv_size_in_bytes;
	};

	STDMETHOD(Write)(
		/*[in,size_is(cb)]*/ const void* pv,
		/*[in]*/ ULONG cb,
		/*[out]*/ ULONG* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(Write)

		VSL_CHECK_VALIDVALUE_MEMCMP(pv, cb, validValues.cb);

		VSL_CHECK_VALIDVALUE(cb);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISTREAM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISurrogateService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISURROGATESERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISURROGATESERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISurrogateServiceNotImpl :
	public ISurrogateService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISurrogateServiceNotImpl)

public:

	typedef ISurrogateService Interface;

	STDMETHOD(Init)(
		/*[in]*/ REFGUID /*rguidProcessID*/,
		/*[in]*/ IProcessLock* /*pProcessLock*/,
		/*[out]*/ BOOL* /*pfApplicationAware*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ApplicationLaunch)(
		/*[in]*/ REFGUID /*rguidApplID*/,
		/*[in]*/ ApplicationType /*appType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ApplicationFree)(
		/*[in]*/ REFGUID /*rguidApplID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CatalogRefresh)(
		/*[in]*/ ULONG /*ulReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ProcessShutdown)(
		/*[in]*/ ShutdownType /*shutdownType*/)VSL_STDMETHOD_NOTIMPL
};

class ISurrogateServiceMockImpl :
	public ISurrogateService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISurrogateServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISurrogateServiceMockImpl)

	typedef ISurrogateService Interface;
	struct InitValidValues
	{
		/*[in]*/ REFGUID rguidProcessID;
		/*[in]*/ IProcessLock* pProcessLock;
		/*[out]*/ BOOL* pfApplicationAware;
		HRESULT retValue;
	};

	STDMETHOD(Init)(
		/*[in]*/ REFGUID rguidProcessID,
		/*[in]*/ IProcessLock* pProcessLock,
		/*[out]*/ BOOL* pfApplicationAware)
	{
		VSL_DEFINE_MOCK_METHOD(Init)

		VSL_CHECK_VALIDVALUE(rguidProcessID);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProcessLock);

		VSL_SET_VALIDVALUE(pfApplicationAware);

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplicationLaunchValidValues
	{
		/*[in]*/ REFGUID rguidApplID;
		/*[in]*/ ApplicationType appType;
		HRESULT retValue;
	};

	STDMETHOD(ApplicationLaunch)(
		/*[in]*/ REFGUID rguidApplID,
		/*[in]*/ ApplicationType appType)
	{
		VSL_DEFINE_MOCK_METHOD(ApplicationLaunch)

		VSL_CHECK_VALIDVALUE(rguidApplID);

		VSL_CHECK_VALIDVALUE(appType);

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplicationFreeValidValues
	{
		/*[in]*/ REFGUID rguidApplID;
		HRESULT retValue;
	};

	STDMETHOD(ApplicationFree)(
		/*[in]*/ REFGUID rguidApplID)
	{
		VSL_DEFINE_MOCK_METHOD(ApplicationFree)

		VSL_CHECK_VALIDVALUE(rguidApplID);

		VSL_RETURN_VALIDVALUES();
	}
	struct CatalogRefreshValidValues
	{
		/*[in]*/ ULONG ulReserved;
		HRESULT retValue;
	};

	STDMETHOD(CatalogRefresh)(
		/*[in]*/ ULONG ulReserved)
	{
		VSL_DEFINE_MOCK_METHOD(CatalogRefresh)

		VSL_CHECK_VALIDVALUE(ulReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct ProcessShutdownValidValues
	{
		/*[in]*/ ShutdownType shutdownType;
		HRESULT retValue;
	};

	STDMETHOD(ProcessShutdown)(
		/*[in]*/ ShutdownType shutdownType)
	{
		VSL_DEFINE_MOCK_METHOD(ProcessShutdown)

		VSL_CHECK_VALIDVALUE(shutdownType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISURROGATESERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IStorageNotImpl :
	public IStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IStorageNotImpl)

public:

	typedef IStorage Interface;

	STDMETHOD(CreateStream)(
		/*[in,string]*/ const OLECHAR* /*pwcsName*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in]*/ DWORD /*reserved1*/,
		/*[in]*/ DWORD /*reserved2*/,
		/*[out]*/ IStream** /*ppstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenStream)(
		/*[in,string]*/ const OLECHAR* /*pwcsName*/,
		/*[in,unique]*/ void* /*reserved1*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in]*/ DWORD /*reserved2*/,
		/*[out]*/ IStream** /*ppstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateStorage)(
		/*[in,string]*/ const OLECHAR* /*pwcsName*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in]*/ DWORD /*reserved1*/,
		/*[in]*/ DWORD /*reserved2*/,
		/*[out]*/ IStorage** /*ppstg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenStorage)(
		/*[in,unique,string]*/ const OLECHAR* /*pwcsName*/,
		/*[in,unique]*/ IStorage* /*pstgPriority*/,
		/*[in]*/ DWORD /*grfMode*/,
		/*[in,unique]*/ SNB /*snbExclude*/,
		/*[in]*/ DWORD /*reserved*/,
		/*[out]*/ IStorage** /*ppstg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyTo)(
		/*[in]*/ DWORD /*ciidExclude*/,
		/*[in,unique,size_is(ciidExclude)]*/ const IID* /*rgiidExclude*/,
		/*[in,unique]*/ SNB /*snbExclude*/,
		/*[in,unique]*/ IStorage* /*pstgDest*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveElementTo)(
		/*[in,string]*/ const OLECHAR* /*pwcsName*/,
		/*[in,unique]*/ IStorage* /*pstgDest*/,
		/*[in,string]*/ const OLECHAR* /*pwcsNewName*/,
		/*[in]*/ DWORD /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Commit)(
		/*[in]*/ DWORD /*grfCommitFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Revert)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumElements)(
		/*[in]*/ DWORD /*reserved1*/,
		/*[in,unique,size_is(1)]*/ void* /*reserved2*/,
		/*[in]*/ DWORD /*reserved3*/,
		/*[out]*/ IEnumSTATSTG** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DestroyElement)(
		/*[in,string]*/ const OLECHAR* /*pwcsName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameElement)(
		/*[in,string]*/ const OLECHAR* /*pwcsOldName*/,
		/*[in,string]*/ const OLECHAR* /*pwcsNewName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetElementTimes)(
		/*[in,unique,string]*/ const OLECHAR* /*pwcsName*/,
		/*[in,unique]*/ const FILETIME* /*pctime*/,
		/*[in,unique]*/ const FILETIME* /*patime*/,
		/*[in,unique]*/ const FILETIME* /*pmtime*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetClass)(
		/*[in]*/ REFCLSID /*clsid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStateBits)(
		/*[in]*/ DWORD /*grfStateBits*/,
		/*[in]*/ DWORD /*grfMask*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Stat)(
		/*[out]*/ STATSTG* /*pstatstg*/,
		/*[in]*/ DWORD /*grfStatFlag*/)VSL_STDMETHOD_NOTIMPL
};

class IStorageMockImpl :
	public IStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IStorageMockImpl)

	typedef IStorage Interface;
	struct CreateStreamValidValues
	{
		/*[in,string]*/ OLECHAR* pwcsName;
		/*[in]*/ DWORD grfMode;
		/*[in]*/ DWORD reserved1;
		/*[in]*/ DWORD reserved2;
		/*[out]*/ IStream** ppstm;
		HRESULT retValue;
	};

	STDMETHOD(CreateStream)(
		/*[in,string]*/ const OLECHAR* pwcsName,
		/*[in]*/ DWORD grfMode,
		/*[in]*/ DWORD reserved1,
		/*[in]*/ DWORD reserved2,
		/*[out]*/ IStream** ppstm)
	{
		VSL_DEFINE_MOCK_METHOD(CreateStream)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(reserved1);

		VSL_CHECK_VALIDVALUE(reserved2);

		VSL_SET_VALIDVALUE_INTERFACE(ppstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenStreamValidValues
	{
		/*[in,string]*/ OLECHAR* pwcsName;
		/*[in,unique]*/ void* reserved1;
		/*[in]*/ DWORD grfMode;
		/*[in]*/ DWORD reserved2;
		/*[out]*/ IStream** ppstm;
		HRESULT retValue;
		size_t reserved1_size_in_bytes;
	};

	STDMETHOD(OpenStream)(
		/*[in,string]*/ const OLECHAR* pwcsName,
		/*[in,unique]*/ void* reserved1,
		/*[in]*/ DWORD grfMode,
		/*[in]*/ DWORD reserved2,
		/*[out]*/ IStream** ppstm)
	{
		VSL_DEFINE_MOCK_METHOD(OpenStream)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE_PVOID(reserved1);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(reserved2);

		VSL_SET_VALIDVALUE_INTERFACE(ppstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateStorageValidValues
	{
		/*[in,string]*/ OLECHAR* pwcsName;
		/*[in]*/ DWORD grfMode;
		/*[in]*/ DWORD reserved1;
		/*[in]*/ DWORD reserved2;
		/*[out]*/ IStorage** ppstg;
		HRESULT retValue;
	};

	STDMETHOD(CreateStorage)(
		/*[in,string]*/ const OLECHAR* pwcsName,
		/*[in]*/ DWORD grfMode,
		/*[in]*/ DWORD reserved1,
		/*[in]*/ DWORD reserved2,
		/*[out]*/ IStorage** ppstg)
	{
		VSL_DEFINE_MOCK_METHOD(CreateStorage)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(reserved1);

		VSL_CHECK_VALIDVALUE(reserved2);

		VSL_SET_VALIDVALUE_INTERFACE(ppstg);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenStorageValidValues
	{
		/*[in,unique,string]*/ OLECHAR* pwcsName;
		/*[in,unique]*/ IStorage* pstgPriority;
		/*[in]*/ DWORD grfMode;
		/*[in,unique]*/ SNB snbExclude;
		/*[in]*/ DWORD reserved;
		/*[out]*/ IStorage** ppstg;
		HRESULT retValue;
	};

	STDMETHOD(OpenStorage)(
		/*[in,unique,string]*/ const OLECHAR* pwcsName,
		/*[in,unique]*/ IStorage* pstgPriority,
		/*[in]*/ DWORD grfMode,
		/*[in,unique]*/ SNB snbExclude,
		/*[in]*/ DWORD reserved,
		/*[out]*/ IStorage** ppstg)
	{
		VSL_DEFINE_MOCK_METHOD(OpenStorage)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstgPriority);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_CHECK_VALIDVALUE(snbExclude);

		VSL_CHECK_VALIDVALUE(reserved);

		VSL_SET_VALIDVALUE_INTERFACE(ppstg);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyToValidValues
	{
		/*[in]*/ DWORD ciidExclude;
		/*[in,unique,size_is(ciidExclude)]*/ IID* rgiidExclude;
		/*[in,unique]*/ SNB snbExclude;
		/*[in,unique]*/ IStorage* pstgDest;
		HRESULT retValue;
	};

	STDMETHOD(CopyTo)(
		/*[in]*/ DWORD ciidExclude,
		/*[in,unique,size_is(ciidExclude)]*/ const IID* rgiidExclude,
		/*[in,unique]*/ SNB snbExclude,
		/*[in,unique]*/ IStorage* pstgDest)
	{
		VSL_DEFINE_MOCK_METHOD(CopyTo)

		VSL_CHECK_VALIDVALUE(ciidExclude);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgiidExclude, ciidExclude*sizeof(rgiidExclude[0]), validValues.ciidExclude*sizeof(validValues.rgiidExclude[0]));

		VSL_CHECK_VALIDVALUE(snbExclude);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstgDest);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveElementToValidValues
	{
		/*[in,string]*/ OLECHAR* pwcsName;
		/*[in,unique]*/ IStorage* pstgDest;
		/*[in,string]*/ OLECHAR* pwcsNewName;
		/*[in]*/ DWORD grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(MoveElementTo)(
		/*[in,string]*/ const OLECHAR* pwcsName,
		/*[in,unique]*/ IStorage* pstgDest,
		/*[in,string]*/ const OLECHAR* pwcsNewName,
		/*[in]*/ DWORD grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(MoveElementTo)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstgDest);

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsNewName);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CommitValidValues
	{
		/*[in]*/ DWORD grfCommitFlags;
		HRESULT retValue;
	};

	STDMETHOD(Commit)(
		/*[in]*/ DWORD grfCommitFlags)
	{
		VSL_DEFINE_MOCK_METHOD(Commit)

		VSL_CHECK_VALIDVALUE(grfCommitFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevertValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Revert)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Revert)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumElementsValidValues
	{
		/*[in]*/ DWORD reserved1;
		/*[in,unique,size_is(1)]*/ void* reserved2;
		/*[in]*/ DWORD reserved3;
		/*[out]*/ IEnumSTATSTG** ppenum;
		HRESULT retValue;
		size_t reserved2_size_in_bytes;
	};

	STDMETHOD(EnumElements)(
		/*[in]*/ DWORD reserved1,
		/*[in,unique,size_is(1)]*/ void* reserved2,
		/*[in]*/ DWORD reserved3,
		/*[out]*/ IEnumSTATSTG** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumElements)

		VSL_CHECK_VALIDVALUE(reserved1);

		VSL_CHECK_VALIDVALUE_MEMCMP(reserved2, 1, 1);

		VSL_CHECK_VALIDVALUE(reserved3);

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct DestroyElementValidValues
	{
		/*[in,string]*/ OLECHAR* pwcsName;
		HRESULT retValue;
	};

	STDMETHOD(DestroyElement)(
		/*[in,string]*/ const OLECHAR* pwcsName)
	{
		VSL_DEFINE_MOCK_METHOD(DestroyElement)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameElementValidValues
	{
		/*[in,string]*/ OLECHAR* pwcsOldName;
		/*[in,string]*/ OLECHAR* pwcsNewName;
		HRESULT retValue;
	};

	STDMETHOD(RenameElement)(
		/*[in,string]*/ const OLECHAR* pwcsOldName,
		/*[in,string]*/ const OLECHAR* pwcsNewName)
	{
		VSL_DEFINE_MOCK_METHOD(RenameElement)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsNewName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetElementTimesValidValues
	{
		/*[in,unique,string]*/ OLECHAR* pwcsName;
		/*[in,unique]*/ FILETIME* pctime;
		/*[in,unique]*/ FILETIME* patime;
		/*[in,unique]*/ FILETIME* pmtime;
		HRESULT retValue;
	};

	STDMETHOD(SetElementTimes)(
		/*[in,unique,string]*/ const OLECHAR* pwcsName,
		/*[in,unique]*/ const FILETIME* pctime,
		/*[in,unique]*/ const FILETIME* patime,
		/*[in,unique]*/ const FILETIME* pmtime)
	{
		VSL_DEFINE_MOCK_METHOD(SetElementTimes)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcsName);

		VSL_CHECK_VALIDVALUE_POINTER(pctime);

		VSL_CHECK_VALIDVALUE_POINTER(patime);

		VSL_CHECK_VALIDVALUE_POINTER(pmtime);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetClassValidValues
	{
		/*[in]*/ REFCLSID clsid;
		HRESULT retValue;
	};

	STDMETHOD(SetClass)(
		/*[in]*/ REFCLSID clsid)
	{
		VSL_DEFINE_MOCK_METHOD(SetClass)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStateBitsValidValues
	{
		/*[in]*/ DWORD grfStateBits;
		/*[in]*/ DWORD grfMask;
		HRESULT retValue;
	};

	STDMETHOD(SetStateBits)(
		/*[in]*/ DWORD grfStateBits,
		/*[in]*/ DWORD grfMask)
	{
		VSL_DEFINE_MOCK_METHOD(SetStateBits)

		VSL_CHECK_VALIDVALUE(grfStateBits);

		VSL_CHECK_VALIDVALUE(grfMask);

		VSL_RETURN_VALIDVALUES();
	}
	struct StatValidValues
	{
		/*[out]*/ STATSTG* pstatstg;
		/*[in]*/ DWORD grfStatFlag;
		HRESULT retValue;
	};

	STDMETHOD(Stat)(
		/*[out]*/ STATSTG* pstatstg,
		/*[in]*/ DWORD grfStatFlag)
	{
		VSL_DEFINE_MOCK_METHOD(Stat)

		VSL_SET_VALIDVALUE(pstatstg);

		VSL_CHECK_VALIDVALUE(grfStatFlag);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISynchronize.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISYNCHRONIZE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISYNCHRONIZE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISynchronizeNotImpl :
	public ISynchronize
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeNotImpl)

public:

	typedef ISynchronize Interface;

	STDMETHOD(Wait)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwMilliseconds*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Signal)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL
};

class ISynchronizeMockImpl :
	public ISynchronize,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISynchronizeMockImpl)

	typedef ISynchronize Interface;
	struct WaitValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwMilliseconds;
		HRESULT retValue;
	};

	STDMETHOD(Wait)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwMilliseconds)
	{
		VSL_DEFINE_MOCK_METHOD(Wait)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwMilliseconds);

		VSL_RETURN_VALIDVALUES();
	}
	struct SignalValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Signal)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Signal)

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISYNCHRONIZE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISynchronizeHandle.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISYNCHRONIZEHANDLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISYNCHRONIZEHANDLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISynchronizeHandleNotImpl :
	public ISynchronizeHandle
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeHandleNotImpl)

public:

	typedef ISynchronizeHandle Interface;

	STDMETHOD(GetHandle)(
		/*[out]*/ HANDLE* /*ph*/)VSL_STDMETHOD_NOTIMPL
};

class ISynchronizeHandleMockImpl :
	public ISynchronizeHandle,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeHandleMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISynchronizeHandleMockImpl)

	typedef ISynchronizeHandle Interface;
	struct GetHandleValidValues
	{
		/*[out]*/ HANDLE* ph;
		HRESULT retValue;
	};

	STDMETHOD(GetHandle)(
		/*[out]*/ HANDLE* ph)
	{
		VSL_DEFINE_MOCK_METHOD(GetHandle)

		VSL_SET_VALIDVALUE(ph);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISYNCHRONIZEHANDLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISynchronizeMutex.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISYNCHRONIZEMUTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISYNCHRONIZEMUTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISynchronizeMutexNotImpl :
	public ISynchronizeMutex
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeMutexNotImpl)

public:

	typedef ISynchronizeMutex Interface;

	STDMETHOD(ReleaseMutex)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Wait)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwMilliseconds*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Signal)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL
};

class ISynchronizeMutexMockImpl :
	public ISynchronizeMutex,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeMutexMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISynchronizeMutexMockImpl)

	typedef ISynchronizeMutex Interface;
	struct ReleaseMutexValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ReleaseMutex)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReleaseMutex)

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwMilliseconds;
		HRESULT retValue;
	};

	STDMETHOD(Wait)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwMilliseconds)
	{
		VSL_DEFINE_MOCK_METHOD(Wait)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwMilliseconds);

		VSL_RETURN_VALIDVALUES();
	}
	struct SignalValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Signal)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Signal)

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISYNCHRONIZEMUTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITextDocument.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITEXTDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITEXTDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <TOM.h>

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITextDocumentNotImpl :
	public ITextDocument
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextDocumentNotImpl)

public:

	typedef ITextDocument Interface;

	STDMETHOD(GetName)(
		/*[out,retval]*/ BSTR* /*pName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSelection)(
		/*[out,retval]*/ ITextSelection** /*ppSel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoryCount)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoryRanges)(
		/*[out,retval]*/ ITextStoryRanges** /*ppStories*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSaved)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSaved)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultTabStop)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDefaultTabStop)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(New)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Open)(
		/*[in]*/ VARIANT* /*pVar*/,
		/*[in]*/ long /*Flags*/,
		/*[in]*/ long /*CodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)(
		/*[in]*/ VARIANT* /*pVar*/,
		/*[in]*/ long /*Flags*/,
		/*[in]*/ long /*CodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Freeze)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unfreeze)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginEditCollection)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndEditCollection)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Undo)(
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*prop*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Redo)(
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*prop*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Range)(
		/*[in]*/ long /*cp1*/,
		/*[in]*/ long /*cp2*/,
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RangeFromPoint)(
		/*[in]*/ long /*x*/,
		/*[in]*/ long /*y*/,
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ITextDocumentMockImpl :
	public ITextDocument,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextDocumentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITextDocumentMockImpl)

	typedef ITextDocument Interface;
	struct GetNameValidValues
	{
		/*[out,retval]*/ BSTR* pName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out,retval]*/ BSTR* pName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSelectionValidValues
	{
		/*[out,retval]*/ ITextSelection** ppSel;
		HRESULT retValue;
	};

	STDMETHOD(GetSelection)(
		/*[out,retval]*/ ITextSelection** ppSel)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelection)

		VSL_SET_VALIDVALUE_INTERFACE(ppSel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoryCountValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetStoryCount)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoryCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoryRangesValidValues
	{
		/*[out,retval]*/ ITextStoryRanges** ppStories;
		HRESULT retValue;
	};

	STDMETHOD(GetStoryRanges)(
		/*[out,retval]*/ ITextStoryRanges** ppStories)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoryRanges)

		VSL_SET_VALIDVALUE_INTERFACE(ppStories);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSavedValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSaved)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSaved)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSavedValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSaved)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSaved)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultTabStopValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultTabStop)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultTabStop)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDefaultTabStopValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetDefaultTabStop)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetDefaultTabStop)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct NewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(New)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(New)

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenValidValues
	{
		/*[in]*/ VARIANT* pVar;
		/*[in]*/ long Flags;
		/*[in]*/ long CodePage;
		HRESULT retValue;
	};

	STDMETHOD(Open)(
		/*[in]*/ VARIANT* pVar,
		/*[in]*/ long Flags,
		/*[in]*/ long CodePage)
	{
		VSL_DEFINE_MOCK_METHOD(Open)

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE(CodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		/*[in]*/ VARIANT* pVar;
		/*[in]*/ long Flags;
		/*[in]*/ long CodePage;
		HRESULT retValue;
	};

	STDMETHOD(Save)(
		/*[in]*/ VARIANT* pVar,
		/*[in]*/ long Flags,
		/*[in]*/ long CodePage)
	{
		VSL_DEFINE_MOCK_METHOD(Save)

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE(CodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreezeValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(Freeze)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(Freeze)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnfreezeValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(Unfreeze)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(Unfreeze)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginEditCollectionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginEditCollection)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginEditCollection)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndEditCollectionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndEditCollection)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndEditCollection)

		VSL_RETURN_VALIDVALUES();
	}
	struct UndoValidValues
	{
		/*[in]*/ long Count;
		/*[out,retval]*/ long* prop;
		HRESULT retValue;
	};

	STDMETHOD(Undo)(
		/*[in]*/ long Count,
		/*[out,retval]*/ long* prop)
	{
		VSL_DEFINE_MOCK_METHOD(Undo)

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(prop);

		VSL_RETURN_VALIDVALUES();
	}
	struct RedoValidValues
	{
		/*[in]*/ long Count;
		/*[out,retval]*/ long* prop;
		HRESULT retValue;
	};

	STDMETHOD(Redo)(
		/*[in]*/ long Count,
		/*[out,retval]*/ long* prop)
	{
		VSL_DEFINE_MOCK_METHOD(Redo)

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(prop);

		VSL_RETURN_VALIDVALUES();
	}
	struct RangeValidValues
	{
		/*[in]*/ long cp1;
		/*[in]*/ long cp2;
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(Range)(
		/*[in]*/ long cp1,
		/*[in]*/ long cp2,
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(Range)

		VSL_CHECK_VALIDVALUE(cp1);

		VSL_CHECK_VALIDVALUE(cp2);

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct RangeFromPointValidValues
	{
		/*[in]*/ long x;
		/*[in]*/ long y;
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(RangeFromPoint)(
		/*[in]*/ long x,
		/*[in]*/ long y,
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(RangeFromPoint)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITEXTDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITextFont.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITEXTFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITEXTFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <TOM.h>

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITextFontNotImpl :
	public ITextFont
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextFontNotImpl)

public:

	typedef ITextFont Interface;

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextFont** /*ppFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDuplicate)(
		/*[in]*/ ITextFont* /*ppFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanChange)(
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextFont* /*pFont*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)(
		/*[in]*/ long /*Value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStyle)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStyle)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllCaps)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAllCaps)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAnimation)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAnimation)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBackColor)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBackColor)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBold)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBold)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEmboss)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEmboss)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetForeColor)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetForeColor)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHidden)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHidden)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngrave)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEngrave)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItalic)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetItalic)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetKerning)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetKerning)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageID)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLanguageID)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out,retval]*/ BSTR* /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ BSTR /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOutline)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetOutline)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPosition)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPosition)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProtected)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProtected)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetShadow)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetShadow)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSize)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSmallCaps)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSmallCaps)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpacing)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSpacing)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStrikeThrough)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStrikeThrough)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubscript)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSubscript)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSuperscript)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSuperscript)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUnderline)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUnderline)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWeight)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetWeight)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ITextFontMockImpl :
	public ITextFont,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextFontMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITextFontMockImpl)

	typedef ITextFont Interface;
	struct GetDuplicateValidValues
	{
		/*[out,retval]*/ ITextFont** ppFont;
		HRESULT retValue;
	};

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextFont** ppFont)
	{
		VSL_DEFINE_MOCK_METHOD(GetDuplicate)

		VSL_SET_VALIDVALUE_INTERFACE(ppFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDuplicateValidValues
	{
		/*[in]*/ ITextFont* ppFont;
		HRESULT retValue;
	};

	STDMETHOD(SetDuplicate)(
		/*[in]*/ ITextFont* ppFont)
	{
		VSL_DEFINE_MOCK_METHOD(SetDuplicate)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanChangeValidValues
	{
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(CanChange)(
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(CanChange)

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in]*/ ITextFont* pFont;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextFont* pFont,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFont);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		/*[in]*/ long Value;
		HRESULT retValue;
	};

	STDMETHOD(Reset)(
		/*[in]*/ long Value)
	{
		VSL_DEFINE_MOCK_METHOD(Reset)

		VSL_CHECK_VALIDVALUE(Value);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStyleValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetStyle)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetStyle)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStyleValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetStyle)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetStyle)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllCapsValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAllCaps)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllCaps)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAllCapsValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetAllCaps)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetAllCaps)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAnimationValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAnimation)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAnimation)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAnimationValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetAnimation)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetAnimation)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBackColorValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetBackColor)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetBackColor)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBackColorValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetBackColor)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetBackColor)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBoldValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetBold)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetBold)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBoldValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetBold)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetBold)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEmbossValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetEmboss)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetEmboss)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEmbossValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetEmboss)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetEmboss)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetForeColorValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetForeColor)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetForeColor)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetForeColorValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetForeColor)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetForeColor)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHiddenValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetHidden)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetHidden)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHiddenValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetHidden)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetHidden)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngraveValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetEngrave)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngrave)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEngraveValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetEngrave)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetEngrave)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItalicValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetItalic)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetItalic)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetItalicValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetItalic)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetItalic)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetKerningValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetKerning)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetKerning)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetKerningValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetKerning)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetKerning)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageIDValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageID)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageID)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLanguageIDValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetLanguageID)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetLanguageID)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstr;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out,retval]*/ BSTR* pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ BSTR pbstr;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ BSTR pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOutlineValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetOutline)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetOutline)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetOutlineValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetOutline)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetOutline)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetPosition)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetPosition)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPositionValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetPosition)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetPosition)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProtectedValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetProtected)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetProtected)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetProtectedValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetProtected)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetProtected)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetShadowValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetShadow)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetShadow)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetShadowValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetShadow)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetShadow)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSizeValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSize)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSize)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSmallCapsValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSmallCaps)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSmallCaps)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSmallCapsValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSmallCaps)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSmallCaps)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpacingValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSpacing)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpacing)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSpacingValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSpacing)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSpacing)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStrikeThroughValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetStrikeThrough)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetStrikeThrough)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStrikeThroughValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetStrikeThrough)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetStrikeThrough)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubscriptValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSubscript)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubscript)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSubscriptValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSubscript)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSubscript)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSuperscriptValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSuperscript)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSuperscript)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSuperscriptValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSuperscript)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSuperscript)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUnderlineValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetUnderline)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnderline)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUnderlineValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetUnderline)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetUnderline)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWeightValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetWeight)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetWeight)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetWeightValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetWeight)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetWeight)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITEXTFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISynchronizeEvent.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISYNCHRONIZEEVENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISYNCHRONIZEEVENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISynchronizeEventNotImpl :
	public ISynchronizeEvent
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeEventNotImpl)

public:

	typedef ISynchronizeEvent Interface;

	STDMETHOD(SetEventHandle)(
		/*[in]*/ HANDLE* /*ph*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHandle)(
		/*[out]*/ HANDLE* /*ph*/)VSL_STDMETHOD_NOTIMPL
};

class ISynchronizeEventMockImpl :
	public ISynchronizeEvent,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeEventMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISynchronizeEventMockImpl)

	typedef ISynchronizeEvent Interface;
	struct SetEventHandleValidValues
	{
		/*[in]*/ HANDLE* ph;
		HRESULT retValue;
	};

	STDMETHOD(SetEventHandle)(
		/*[in]*/ HANDLE* ph)
	{
		VSL_DEFINE_MOCK_METHOD(SetEventHandle)

		VSL_CHECK_VALIDVALUE_POINTER(ph);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHandleValidValues
	{
		/*[out]*/ HANDLE* ph;
		HRESULT retValue;
	};

	STDMETHOD(GetHandle)(
		/*[out]*/ HANDLE* ph)
	{
		VSL_DEFINE_MOCK_METHOD(GetHandle)

		VSL_SET_VALIDVALUE(ph);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISYNCHRONIZEEVENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockISynchronizeContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ISYNCHRONIZECONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ISYNCHRONIZECONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ISynchronizeContainerNotImpl :
	public ISynchronizeContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeContainerNotImpl)

public:

	typedef ISynchronizeContainer Interface;

	STDMETHOD(AddSynchronize)(
		/*[in]*/ ISynchronize* /*pSync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitMultiple)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwTimeOut*/,
		/*[out]*/ ISynchronize** /*ppSync*/)VSL_STDMETHOD_NOTIMPL
};

class ISynchronizeContainerMockImpl :
	public ISynchronizeContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISynchronizeContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ISynchronizeContainerMockImpl)

	typedef ISynchronizeContainer Interface;
	struct AddSynchronizeValidValues
	{
		/*[in]*/ ISynchronize* pSync;
		HRESULT retValue;
	};

	STDMETHOD(AddSynchronize)(
		/*[in]*/ ISynchronize* pSync)
	{
		VSL_DEFINE_MOCK_METHOD(AddSynchronize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSync);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitMultipleValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwTimeOut;
		/*[out]*/ ISynchronize** ppSync;
		HRESULT retValue;
	};

	STDMETHOD(WaitMultiple)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwTimeOut,
		/*[out]*/ ISynchronize** ppSync)
	{
		VSL_DEFINE_MOCK_METHOD(WaitMultiple)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwTimeOut);

		VSL_SET_VALIDVALUE_INTERFACE(ppSync);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ISYNCHRONIZECONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITextPara.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITEXTPARA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITEXTPARA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <TOM.h>

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITextParaNotImpl :
	public ITextPara
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextParaNotImpl)

public:

	typedef ITextPara Interface;

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextPara** /*ppPara*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDuplicate)(
		/*[in]*/ ITextPara* /*ppPara*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanChange)(
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextPara* /*pPara*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)(
		/*[in]*/ long /*Value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStyle)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStyle)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAlignment)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAlignment)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHyphenation)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetHyphenation)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFirstLineIndent)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetKeepTogether)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetKeepTogether)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetKeepWithNext)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetKeepWithNext)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLeftIndent)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineSpacing)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineSpacingRule)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListAlignment)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetListAlignment)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListLevelIndex)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetListLevelIndex)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListStart)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetListStart)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListTab)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetListTab)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListType)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetListType)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNoLineNumber)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetNoLineNumber)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPageBreakBefore)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPageBreakBefore)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRightIndent)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRightIndent)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetIndents)(
		/*[in]*/ single /*StartIndent*/,
		/*[in]*/ single /*LeftIndent*/,
		/*[in]*/ single /*RightIndent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLineSpacing)(
		/*[in]*/ long /*LineSpacingRule*/,
		/*[in]*/ single /*LineSpacing*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpaceAfter)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSpaceAfter)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpaceBefore)(
		/*[out,retval]*/ single* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSpaceBefore)(
		/*[in]*/ single /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWidowControl)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetWidowControl)(
		/*[in]*/ long /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTabCount)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTab)(
		/*[in]*/ single /*tbPos*/,
		/*[in]*/ long /*tbAlign*/,
		/*[in]*/ long /*tbLeader*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearAllTabs)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteTab)(
		/*[in]*/ single /*tbPos*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTab)(
		/*[in]*/ long /*iTab*/,
		/*[out]*/ single* /*ptbPos*/,
		/*[out]*/ long* /*ptbAlign*/,
		/*[out]*/ long* /*ptbLeader*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ITextParaMockImpl :
	public ITextPara,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextParaMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITextParaMockImpl)

	typedef ITextPara Interface;
	struct GetDuplicateValidValues
	{
		/*[out,retval]*/ ITextPara** ppPara;
		HRESULT retValue;
	};

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextPara** ppPara)
	{
		VSL_DEFINE_MOCK_METHOD(GetDuplicate)

		VSL_SET_VALIDVALUE_INTERFACE(ppPara);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDuplicateValidValues
	{
		/*[in]*/ ITextPara* ppPara;
		HRESULT retValue;
	};

	STDMETHOD(SetDuplicate)(
		/*[in]*/ ITextPara* ppPara)
	{
		VSL_DEFINE_MOCK_METHOD(SetDuplicate)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppPara);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanChangeValidValues
	{
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(CanChange)(
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(CanChange)

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in]*/ ITextPara* pPara;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextPara* pPara,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPara);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		/*[in]*/ long Value;
		HRESULT retValue;
	};

	STDMETHOD(Reset)(
		/*[in]*/ long Value)
	{
		VSL_DEFINE_MOCK_METHOD(Reset)

		VSL_CHECK_VALIDVALUE(Value);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStyleValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetStyle)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetStyle)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStyleValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetStyle)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetStyle)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAlignmentValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAlignment)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAlignment)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAlignmentValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetAlignment)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetAlignment)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHyphenationValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetHyphenation)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetHyphenation)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetHyphenationValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetHyphenation)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetHyphenation)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFirstLineIndentValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetFirstLineIndent)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetFirstLineIndent)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetKeepTogetherValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetKeepTogether)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetKeepTogether)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetKeepTogetherValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetKeepTogether)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetKeepTogether)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetKeepWithNextValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetKeepWithNext)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetKeepWithNext)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetKeepWithNextValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetKeepWithNext)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetKeepWithNext)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLeftIndentValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetLeftIndent)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetLeftIndent)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineSpacingValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetLineSpacing)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineSpacing)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineSpacingRuleValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetLineSpacingRule)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineSpacingRule)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListAlignmentValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetListAlignment)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetListAlignment)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetListAlignmentValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetListAlignment)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetListAlignment)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListLevelIndexValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetListLevelIndex)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetListLevelIndex)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetListLevelIndexValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetListLevelIndex)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetListLevelIndex)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListStartValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetListStart)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetListStart)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetListStartValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetListStart)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetListStart)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListTabValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetListTab)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetListTab)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetListTabValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetListTab)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetListTab)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListTypeValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetListType)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetListType)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetListTypeValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetListType)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetListType)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNoLineNumberValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetNoLineNumber)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetNoLineNumber)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNoLineNumberValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetNoLineNumber)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetNoLineNumber)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPageBreakBeforeValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetPageBreakBefore)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetPageBreakBefore)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPageBreakBeforeValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetPageBreakBefore)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetPageBreakBefore)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRightIndentValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetRightIndent)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetRightIndent)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRightIndentValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetRightIndent)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetRightIndent)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetIndentsValidValues
	{
		/*[in]*/ single StartIndent;
		/*[in]*/ single LeftIndent;
		/*[in]*/ single RightIndent;
		HRESULT retValue;
	};

	STDMETHOD(SetIndents)(
		/*[in]*/ single StartIndent,
		/*[in]*/ single LeftIndent,
		/*[in]*/ single RightIndent)
	{
		VSL_DEFINE_MOCK_METHOD(SetIndents)

		VSL_CHECK_VALIDVALUE(StartIndent);

		VSL_CHECK_VALIDVALUE(LeftIndent);

		VSL_CHECK_VALIDVALUE(RightIndent);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLineSpacingValidValues
	{
		/*[in]*/ long LineSpacingRule;
		/*[in]*/ single LineSpacing;
		HRESULT retValue;
	};

	STDMETHOD(SetLineSpacing)(
		/*[in]*/ long LineSpacingRule,
		/*[in]*/ single LineSpacing)
	{
		VSL_DEFINE_MOCK_METHOD(SetLineSpacing)

		VSL_CHECK_VALIDVALUE(LineSpacingRule);

		VSL_CHECK_VALIDVALUE(LineSpacing);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpaceAfterValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSpaceAfter)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpaceAfter)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSpaceAfterValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSpaceAfter)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSpaceAfter)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpaceBeforeValidValues
	{
		/*[out,retval]*/ single* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSpaceBefore)(
		/*[out,retval]*/ single* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpaceBefore)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSpaceBeforeValidValues
	{
		/*[in]*/ single pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetSpaceBefore)(
		/*[in]*/ single pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetSpaceBefore)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWidowControlValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetWidowControl)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetWidowControl)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetWidowControlValidValues
	{
		/*[in]*/ long pValue;
		HRESULT retValue;
	};

	STDMETHOD(SetWidowControl)(
		/*[in]*/ long pValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetWidowControl)

		VSL_CHECK_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabCountValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetTabCount)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetTabCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTabValidValues
	{
		/*[in]*/ single tbPos;
		/*[in]*/ long tbAlign;
		/*[in]*/ long tbLeader;
		HRESULT retValue;
	};

	STDMETHOD(AddTab)(
		/*[in]*/ single tbPos,
		/*[in]*/ long tbAlign,
		/*[in]*/ long tbLeader)
	{
		VSL_DEFINE_MOCK_METHOD(AddTab)

		VSL_CHECK_VALIDVALUE(tbPos);

		VSL_CHECK_VALIDVALUE(tbAlign);

		VSL_CHECK_VALIDVALUE(tbLeader);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearAllTabsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearAllTabs)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearAllTabs)

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteTabValidValues
	{
		/*[in]*/ single tbPos;
		HRESULT retValue;
	};

	STDMETHOD(DeleteTab)(
		/*[in]*/ single tbPos)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteTab)

		VSL_CHECK_VALIDVALUE(tbPos);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabValidValues
	{
		/*[in]*/ long iTab;
		/*[out]*/ single* ptbPos;
		/*[out]*/ long* ptbAlign;
		/*[out]*/ long* ptbLeader;
		HRESULT retValue;
	};

	STDMETHOD(GetTab)(
		/*[in]*/ long iTab,
		/*[out]*/ single* ptbPos,
		/*[out]*/ long* ptbAlign,
		/*[out]*/ long* ptbLeader)
	{
		VSL_DEFINE_MOCK_METHOD(GetTab)

		VSL_CHECK_VALIDVALUE(iTab);

		VSL_SET_VALIDVALUE(ptbPos);

		VSL_SET_VALIDVALUE(ptbAlign);

		VSL_SET_VALIDVALUE(ptbLeader);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITEXTPARA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITextRange.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITEXTRANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITEXTRANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <TOM.h>

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITextRangeNotImpl :
	public ITextRange
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextRangeNotImpl)

public:

	typedef ITextRange Interface;

	STDMETHOD(GetText)(
		/*[out,retval]*/ BSTR* /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetText)(
		/*[in]*/ BSTR /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetChar)(
		/*[out,retval]*/ long* /*pch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetChar)(
		/*[in]*/ long /*pch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFormattedText)(
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFormattedText)(
		/*[in]*/ ITextRange* /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStart)(
		/*[out,retval]*/ long* /*pcpFirst*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStart)(
		/*[in]*/ long /*pcpFirst*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnd)(
		/*[out,retval]*/ long* /*pcpLim*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEnd)(
		/*[in]*/ long /*pcpLim*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFont)(
		/*[out,retval]*/ ITextFont** /*pFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFont)(
		/*[in]*/ ITextFont* /*pFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPara)(
		/*[out,retval]*/ ITextPara** /*pPara*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPara)(
		/*[in]*/ ITextPara* /*pPara*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoryLength)(
		/*[out,retval]*/ long* /*pcch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoryType)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Collapse)(
		/*[in]*/ long /*bStart*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Expand)(
		/*[in]*/ long /*Unit*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIndex)(
		/*[in]*/ long /*Unit*/,
		/*[out,retval]*/ long* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetIndex)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Index*/,
		/*[in]*/ long /*Extend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRange)(
		/*[in]*/ long /*cpActive*/,
		/*[in]*/ long /*cpOther*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InRange)(
		/*[in]*/ ITextRange* /*pRange*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InStory)(
		/*[in]*/ ITextRange* /*pRange*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextRange* /*pRange*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Select)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartOf)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndOf)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Move)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveStart)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveEnd)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveWhile)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveStartWhile)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveEndWhile)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveUntil)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveStartUntil)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveEndUntil)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindText)(
		/*[in]*/ BSTR /*bstr*/,
		/*[in]*/ long /*cch*/,
		/*[in]*/ long /*Flags*/,
		/*[out,retval]*/ long* /*pLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindTextStart)(
		/*[in]*/ BSTR /*bstr*/,
		/*[in]*/ long /*cch*/,
		/*[in]*/ long /*Flags*/,
		/*[out,retval]*/ long* /*pLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindTextEnd)(
		/*[in]*/ BSTR /*bstr*/,
		/*[in]*/ long /*cch*/,
		/*[in]*/ long /*Flags*/,
		/*[out,retval]*/ long* /*pLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Delete)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Cut)(
		/*[out]*/ VARIANT* /*pVar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Copy)(
		/*[out]*/ VARIANT* /*pVar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paste)(
		/*[in]*/ VARIANT* /*pVar*/,
		/*[in]*/ long /*Format*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanPaste)(
		/*[in]*/ VARIANT* /*pVar*/,
		/*[in]*/ long /*Format*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanEdit)(
		/*[out,retval]*/ long* /*pbCanEdit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ChangeCase)(
		/*[in]*/ long /*Type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPoint)(
		/*[in]*/ long /*Type*/,
		/*[out]*/ long* /*px*/,
		/*[out]*/ long* /*py*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPoint)(
		/*[in]*/ long /*x*/,
		/*[in]*/ long /*y*/,
		/*[in]*/ long /*Type*/,
		/*[in]*/ long /*Extend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ScrollIntoView)(
		/*[in]*/ long /*Value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEmbeddedObject)(
		/*[out,retval]*/ IUnknown** /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ITextRangeMockImpl :
	public ITextRange,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextRangeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITextRangeMockImpl)

	typedef ITextRange Interface;
	struct GetTextValidValues
	{
		/*[out,retval]*/ BSTR* pbstr;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[out,retval]*/ BSTR* pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_SET_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTextValidValues
	{
		/*[in]*/ BSTR pbstr;
		HRESULT retValue;
	};

	STDMETHOD(SetText)(
		/*[in]*/ BSTR pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(SetText)

		VSL_CHECK_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCharValidValues
	{
		/*[out,retval]*/ long* pch;
		HRESULT retValue;
	};

	STDMETHOD(GetChar)(
		/*[out,retval]*/ long* pch)
	{
		VSL_DEFINE_MOCK_METHOD(GetChar)

		VSL_SET_VALIDVALUE(pch);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCharValidValues
	{
		/*[in]*/ long pch;
		HRESULT retValue;
	};

	STDMETHOD(SetChar)(
		/*[in]*/ long pch)
	{
		VSL_DEFINE_MOCK_METHOD(SetChar)

		VSL_CHECK_VALIDVALUE(pch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDuplicateValidValues
	{
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(GetDuplicate)

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFormattedTextValidValues
	{
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(GetFormattedText)(
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(GetFormattedText)

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFormattedTextValidValues
	{
		/*[in]*/ ITextRange* ppRange;
		HRESULT retValue;
	};

	STDMETHOD(SetFormattedText)(
		/*[in]*/ ITextRange* ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(SetFormattedText)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStartValidValues
	{
		/*[out,retval]*/ long* pcpFirst;
		HRESULT retValue;
	};

	STDMETHOD(GetStart)(
		/*[out,retval]*/ long* pcpFirst)
	{
		VSL_DEFINE_MOCK_METHOD(GetStart)

		VSL_SET_VALIDVALUE(pcpFirst);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStartValidValues
	{
		/*[in]*/ long pcpFirst;
		HRESULT retValue;
	};

	STDMETHOD(SetStart)(
		/*[in]*/ long pcpFirst)
	{
		VSL_DEFINE_MOCK_METHOD(SetStart)

		VSL_CHECK_VALIDVALUE(pcpFirst);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEndValidValues
	{
		/*[out,retval]*/ long* pcpLim;
		HRESULT retValue;
	};

	STDMETHOD(GetEnd)(
		/*[out,retval]*/ long* pcpLim)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnd)

		VSL_SET_VALIDVALUE(pcpLim);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEndValidValues
	{
		/*[in]*/ long pcpLim;
		HRESULT retValue;
	};

	STDMETHOD(SetEnd)(
		/*[in]*/ long pcpLim)
	{
		VSL_DEFINE_MOCK_METHOD(SetEnd)

		VSL_CHECK_VALIDVALUE(pcpLim);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFontValidValues
	{
		/*[out,retval]*/ ITextFont** pFont;
		HRESULT retValue;
	};

	STDMETHOD(GetFont)(
		/*[out,retval]*/ ITextFont** pFont)
	{
		VSL_DEFINE_MOCK_METHOD(GetFont)

		VSL_SET_VALIDVALUE_INTERFACE(pFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFontValidValues
	{
		/*[in]*/ ITextFont* pFont;
		HRESULT retValue;
	};

	STDMETHOD(SetFont)(
		/*[in]*/ ITextFont* pFont)
	{
		VSL_DEFINE_MOCK_METHOD(SetFont)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParaValidValues
	{
		/*[out,retval]*/ ITextPara** pPara;
		HRESULT retValue;
	};

	STDMETHOD(GetPara)(
		/*[out,retval]*/ ITextPara** pPara)
	{
		VSL_DEFINE_MOCK_METHOD(GetPara)

		VSL_SET_VALIDVALUE_INTERFACE(pPara);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetParaValidValues
	{
		/*[in]*/ ITextPara* pPara;
		HRESULT retValue;
	};

	STDMETHOD(SetPara)(
		/*[in]*/ ITextPara* pPara)
	{
		VSL_DEFINE_MOCK_METHOD(SetPara)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPara);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoryLengthValidValues
	{
		/*[out,retval]*/ long* pcch;
		HRESULT retValue;
	};

	STDMETHOD(GetStoryLength)(
		/*[out,retval]*/ long* pcch)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoryLength)

		VSL_SET_VALIDVALUE(pcch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoryTypeValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetStoryType)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoryType)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct CollapseValidValues
	{
		/*[in]*/ long bStart;
		HRESULT retValue;
	};

	STDMETHOD(Collapse)(
		/*[in]*/ long bStart)
	{
		VSL_DEFINE_MOCK_METHOD(Collapse)

		VSL_CHECK_VALIDVALUE(bStart);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExpandValidValues
	{
		/*[in]*/ long Unit;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(Expand)(
		/*[in]*/ long Unit,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(Expand)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIndexValidValues
	{
		/*[in]*/ long Unit;
		/*[out,retval]*/ long* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetIndex)(
		/*[in]*/ long Unit,
		/*[out,retval]*/ long* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetIndex)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetIndexValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Index;
		/*[in]*/ long Extend;
		HRESULT retValue;
	};

	STDMETHOD(SetIndex)(
		/*[in]*/ long Unit,
		/*[in]*/ long Index,
		/*[in]*/ long Extend)
	{
		VSL_DEFINE_MOCK_METHOD(SetIndex)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRangeValidValues
	{
		/*[in]*/ long cpActive;
		/*[in]*/ long cpOther;
		HRESULT retValue;
	};

	STDMETHOD(SetRange)(
		/*[in]*/ long cpActive,
		/*[in]*/ long cpOther)
	{
		VSL_DEFINE_MOCK_METHOD(SetRange)

		VSL_CHECK_VALIDVALUE(cpActive);

		VSL_CHECK_VALIDVALUE(cpOther);

		VSL_RETURN_VALIDVALUES();
	}
	struct InRangeValidValues
	{
		/*[in]*/ ITextRange* pRange;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(InRange)(
		/*[in]*/ ITextRange* pRange,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(InRange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRange);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct InStoryValidValues
	{
		/*[in]*/ ITextRange* pRange;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(InStory)(
		/*[in]*/ ITextRange* pRange,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(InStory)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRange);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in]*/ ITextRange* pRange;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextRange* pRange,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRange);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Select)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Select)

		VSL_RETURN_VALIDVALUES();
	}
	struct StartOfValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(StartOf)(
		/*[in]*/ long Unit,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(StartOf)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndOfValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(EndOf)(
		/*[in]*/ long Unit,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(EndOf)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(Move)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(Move)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveStartValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveStart)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveStart)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveEndValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveEnd)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveEnd)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveWhileValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveWhile)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveWhile)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveStartWhileValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveStartWhile)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveStartWhile)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveEndWhileValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveEndWhile)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveEndWhile)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveUntilValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveUntil)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveUntil)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveStartUntilValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveStartUntil)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveStartUntil)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveEndUntilValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveEndUntil)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveEndUntil)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTextValidValues
	{
		/*[in]*/ BSTR bstr;
		/*[in]*/ long cch;
		/*[in]*/ long Flags;
		/*[out,retval]*/ long* pLength;
		HRESULT retValue;
	};

	STDMETHOD(FindText)(
		/*[in]*/ BSTR bstr,
		/*[in]*/ long cch,
		/*[in]*/ long Flags,
		/*[out,retval]*/ long* pLength)
	{
		VSL_DEFINE_MOCK_METHOD(FindText)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_SET_VALIDVALUE(pLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTextStartValidValues
	{
		/*[in]*/ BSTR bstr;
		/*[in]*/ long cch;
		/*[in]*/ long Flags;
		/*[out,retval]*/ long* pLength;
		HRESULT retValue;
	};

	STDMETHOD(FindTextStart)(
		/*[in]*/ BSTR bstr,
		/*[in]*/ long cch,
		/*[in]*/ long Flags,
		/*[out,retval]*/ long* pLength)
	{
		VSL_DEFINE_MOCK_METHOD(FindTextStart)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_SET_VALIDVALUE(pLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTextEndValidValues
	{
		/*[in]*/ BSTR bstr;
		/*[in]*/ long cch;
		/*[in]*/ long Flags;
		/*[out,retval]*/ long* pLength;
		HRESULT retValue;
	};

	STDMETHOD(FindTextEnd)(
		/*[in]*/ BSTR bstr,
		/*[in]*/ long cch,
		/*[in]*/ long Flags,
		/*[out,retval]*/ long* pLength)
	{
		VSL_DEFINE_MOCK_METHOD(FindTextEnd)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_SET_VALIDVALUE(pLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(Delete)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(Delete)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct CutValidValues
	{
		/*[out]*/ VARIANT* pVar;
		HRESULT retValue;
	};

	STDMETHOD(Cut)(
		/*[out]*/ VARIANT* pVar)
	{
		VSL_DEFINE_MOCK_METHOD(Cut)

		VSL_SET_VALIDVALUE_VARIANT(pVar);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyValidValues
	{
		/*[out]*/ VARIANT* pVar;
		HRESULT retValue;
	};

	STDMETHOD(Copy)(
		/*[out]*/ VARIANT* pVar)
	{
		VSL_DEFINE_MOCK_METHOD(Copy)

		VSL_SET_VALIDVALUE_VARIANT(pVar);

		VSL_RETURN_VALIDVALUES();
	}
	struct PasteValidValues
	{
		/*[in]*/ VARIANT* pVar;
		/*[in]*/ long Format;
		HRESULT retValue;
	};

	STDMETHOD(Paste)(
		/*[in]*/ VARIANT* pVar,
		/*[in]*/ long Format)
	{
		VSL_DEFINE_MOCK_METHOD(Paste)

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_CHECK_VALIDVALUE(Format);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanPasteValidValues
	{
		/*[in]*/ VARIANT* pVar;
		/*[in]*/ long Format;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(CanPaste)(
		/*[in]*/ VARIANT* pVar,
		/*[in]*/ long Format,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(CanPaste)

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_CHECK_VALIDVALUE(Format);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanEditValidValues
	{
		/*[out,retval]*/ long* pbCanEdit;
		HRESULT retValue;
	};

	STDMETHOD(CanEdit)(
		/*[out,retval]*/ long* pbCanEdit)
	{
		VSL_DEFINE_MOCK_METHOD(CanEdit)

		VSL_SET_VALIDVALUE(pbCanEdit);

		VSL_RETURN_VALIDVALUES();
	}
	struct ChangeCaseValidValues
	{
		/*[in]*/ long Type;
		HRESULT retValue;
	};

	STDMETHOD(ChangeCase)(
		/*[in]*/ long Type)
	{
		VSL_DEFINE_MOCK_METHOD(ChangeCase)

		VSL_CHECK_VALIDVALUE(Type);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPointValidValues
	{
		/*[in]*/ long Type;
		/*[out]*/ long* px;
		/*[out]*/ long* py;
		HRESULT retValue;
	};

	STDMETHOD(GetPoint)(
		/*[in]*/ long Type,
		/*[out]*/ long* px,
		/*[out]*/ long* py)
	{
		VSL_DEFINE_MOCK_METHOD(GetPoint)

		VSL_CHECK_VALIDVALUE(Type);

		VSL_SET_VALIDVALUE(px);

		VSL_SET_VALIDVALUE(py);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPointValidValues
	{
		/*[in]*/ long x;
		/*[in]*/ long y;
		/*[in]*/ long Type;
		/*[in]*/ long Extend;
		HRESULT retValue;
	};

	STDMETHOD(SetPoint)(
		/*[in]*/ long x,
		/*[in]*/ long y,
		/*[in]*/ long Type,
		/*[in]*/ long Extend)
	{
		VSL_DEFINE_MOCK_METHOD(SetPoint)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(Type);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollIntoViewValidValues
	{
		/*[in]*/ long Value;
		HRESULT retValue;
	};

	STDMETHOD(ScrollIntoView)(
		/*[in]*/ long Value)
	{
		VSL_DEFINE_MOCK_METHOD(ScrollIntoView)

		VSL_CHECK_VALIDVALUE(Value);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEmbeddedObjectValidValues
	{
		/*[out,retval]*/ IUnknown** ppv;
		HRESULT retValue;
	};

	STDMETHOD(GetEmbeddedObject)(
		/*[out,retval]*/ IUnknown** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(GetEmbeddedObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITEXTRANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITimeAndNoticeControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITIMEANDNOTICECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITIMEANDNOTICECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITimeAndNoticeControlNotImpl :
	public ITimeAndNoticeControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITimeAndNoticeControlNotImpl)

public:

	typedef ITimeAndNoticeControl Interface;

	STDMETHOD(SuppressChanges)(
		/*[in]*/ DWORD /*res1*/,
		/*[in]*/ DWORD /*res2*/)VSL_STDMETHOD_NOTIMPL
};

class ITimeAndNoticeControlMockImpl :
	public ITimeAndNoticeControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITimeAndNoticeControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITimeAndNoticeControlMockImpl)

	typedef ITimeAndNoticeControl Interface;
	struct SuppressChangesValidValues
	{
		/*[in]*/ DWORD res1;
		/*[in]*/ DWORD res2;
		HRESULT retValue;
	};

	STDMETHOD(SuppressChanges)(
		/*[in]*/ DWORD res1,
		/*[in]*/ DWORD res2)
	{
		VSL_DEFINE_MOCK_METHOD(SuppressChanges)

		VSL_CHECK_VALIDVALUE(res1);

		VSL_CHECK_VALIDVALUE(res2);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITIMEANDNOTICECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeComp.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPECOMP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPECOMP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeCompNotImpl :
	public ITypeComp
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeCompNotImpl)

public:

	typedef ITypeComp Interface;

	STDMETHOD(Bind)(
		/*[in]*/ LPOLESTR /*szName*/,
		/*[in]*/ ULONG /*lHashVal*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/,
		/*[out]*/ DESCKIND* /*pDescKind*/,
		/*[out]*/ BINDPTR* /*pBindPtr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BindType)(
		/*[in]*/ LPOLESTR /*szName*/,
		/*[in]*/ ULONG /*lHashVal*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/,
		/*[out]*/ ITypeComp** /*ppTComp*/)VSL_STDMETHOD_NOTIMPL
};

class ITypeCompMockImpl :
	public ITypeComp,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeCompMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeCompMockImpl)

	typedef ITypeComp Interface;
	struct BindValidValues
	{
		/*[in]*/ LPOLESTR szName;
		/*[in]*/ ULONG lHashVal;
		/*[in]*/ WORD wFlags;
		/*[out]*/ ITypeInfo** ppTInfo;
		/*[out]*/ DESCKIND* pDescKind;
		/*[out]*/ BINDPTR* pBindPtr;
		HRESULT retValue;
	};

	STDMETHOD(Bind)(
		/*[in]*/ LPOLESTR szName,
		/*[in]*/ ULONG lHashVal,
		/*[in]*/ WORD wFlags,
		/*[out]*/ ITypeInfo** ppTInfo,
		/*[out]*/ DESCKIND* pDescKind,
		/*[out]*/ BINDPTR* pBindPtr)
	{
		VSL_DEFINE_MOCK_METHOD(Bind)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE(lHashVal);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_SET_VALIDVALUE(pDescKind);

		VSL_SET_VALIDVALUE(pBindPtr);

		VSL_RETURN_VALIDVALUES();
	}
	struct BindTypeValidValues
	{
		/*[in]*/ LPOLESTR szName;
		/*[in]*/ ULONG lHashVal;
		/*[out]*/ ITypeInfo** ppTInfo;
		/*[out]*/ ITypeComp** ppTComp;
		HRESULT retValue;
	};

	STDMETHOD(BindType)(
		/*[in]*/ LPOLESTR szName,
		/*[in]*/ ULONG lHashVal,
		/*[out]*/ ITypeInfo** ppTInfo,
		/*[out]*/ ITypeComp** ppTComp)
	{
		VSL_DEFINE_MOCK_METHOD(BindType)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE(lHashVal);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_SET_VALIDVALUE_INTERFACE(ppTComp);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPECOMP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITextSelection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITEXTSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITEXTSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <TOM.h>

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITextSelectionNotImpl :
	public ITextSelection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextSelectionNotImpl)

public:

	typedef ITextSelection Interface;

	STDMETHOD(GetFlags)(
		/*[out,retval]*/ long* /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFlags)(
		/*[in]*/ long /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetType)(
		/*[out,retval]*/ long* /*pType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveLeft)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveRight)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveUp)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveDown)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HomeKey)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndKey)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TypeText)(
		/*[in]*/ BSTR /*bstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[out,retval]*/ BSTR* /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetText)(
		/*[in]*/ BSTR /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetChar)(
		/*[out,retval]*/ long* /*pch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetChar)(
		/*[in]*/ long /*pch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFormattedText)(
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFormattedText)(
		/*[in]*/ ITextRange* /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStart)(
		/*[out,retval]*/ long* /*pcpFirst*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStart)(
		/*[in]*/ long /*pcpFirst*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnd)(
		/*[out,retval]*/ long* /*pcpLim*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEnd)(
		/*[in]*/ long /*pcpLim*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFont)(
		/*[out,retval]*/ ITextFont** /*pFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFont)(
		/*[in]*/ ITextFont* /*pFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPara)(
		/*[out,retval]*/ ITextPara** /*pPara*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPara)(
		/*[in]*/ ITextPara* /*pPara*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoryLength)(
		/*[out,retval]*/ long* /*pcch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStoryType)(
		/*[out,retval]*/ long* /*pValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Collapse)(
		/*[in]*/ long /*bStart*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Expand)(
		/*[in]*/ long /*Unit*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIndex)(
		/*[in]*/ long /*Unit*/,
		/*[out,retval]*/ long* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetIndex)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Index*/,
		/*[in]*/ long /*Extend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRange)(
		/*[in]*/ long /*cpActive*/,
		/*[in]*/ long /*cpOther*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InRange)(
		/*[in]*/ ITextRange* /*pRange*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InStory)(
		/*[in]*/ ITextRange* /*pRange*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextRange* /*pRange*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Select)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartOf)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndOf)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Extend*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Move)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveStart)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveEnd)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveWhile)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveStartWhile)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveEndWhile)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveUntil)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveStartUntil)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveEndUntil)(
		/*[in]*/ VARIANT* /*Cset*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindText)(
		/*[in]*/ BSTR /*bstr*/,
		/*[in]*/ long /*cch*/,
		/*[in]*/ long /*Flags*/,
		/*[out,retval]*/ long* /*pLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindTextStart)(
		/*[in]*/ BSTR /*bstr*/,
		/*[in]*/ long /*cch*/,
		/*[in]*/ long /*Flags*/,
		/*[out,retval]*/ long* /*pLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindTextEnd)(
		/*[in]*/ BSTR /*bstr*/,
		/*[in]*/ long /*cch*/,
		/*[in]*/ long /*Flags*/,
		/*[out,retval]*/ long* /*pLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Delete)(
		/*[in]*/ long /*Unit*/,
		/*[in]*/ long /*Count*/,
		/*[out,retval]*/ long* /*pDelta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Cut)(
		/*[out]*/ VARIANT* /*pVar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Copy)(
		/*[out]*/ VARIANT* /*pVar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paste)(
		/*[in]*/ VARIANT* /*pVar*/,
		/*[in]*/ long /*Format*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanPaste)(
		/*[in]*/ VARIANT* /*pVar*/,
		/*[in]*/ long /*Format*/,
		/*[out,retval]*/ long* /*pb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanEdit)(
		/*[out,retval]*/ long* /*pbCanEdit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ChangeCase)(
		/*[in]*/ long /*Type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPoint)(
		/*[in]*/ long /*Type*/,
		/*[out]*/ long* /*px*/,
		/*[out]*/ long* /*py*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPoint)(
		/*[in]*/ long /*x*/,
		/*[in]*/ long /*y*/,
		/*[in]*/ long /*Type*/,
		/*[in]*/ long /*Extend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ScrollIntoView)(
		/*[in]*/ long /*Value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEmbeddedObject)(
		/*[out,retval]*/ IUnknown** /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ITextSelectionMockImpl :
	public ITextSelection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextSelectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITextSelectionMockImpl)

	typedef ITextSelection Interface;
	struct GetFlagsValidValues
	{
		/*[out,retval]*/ long* pFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out,retval]*/ long* pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFlagsValidValues
	{
		/*[in]*/ long pFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetFlags)(
		/*[in]*/ long pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetFlags)

		VSL_CHECK_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeValidValues
	{
		/*[out,retval]*/ long* pType;
		HRESULT retValue;
	};

	STDMETHOD(GetType)(
		/*[out,retval]*/ long* pType)
	{
		VSL_DEFINE_MOCK_METHOD(GetType)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveLeftValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveLeft)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveLeft)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveRightValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveRight)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveRight)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveUpValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveUp)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveUp)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveDownValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveDown)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveDown)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct HomeKeyValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(HomeKey)(
		/*[in]*/ long Unit,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(HomeKey)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndKeyValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(EndKey)(
		/*[in]*/ long Unit,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(EndKey)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct TypeTextValidValues
	{
		/*[in]*/ BSTR bstr;
		HRESULT retValue;
	};

	STDMETHOD(TypeText)(
		/*[in]*/ BSTR bstr)
	{
		VSL_DEFINE_MOCK_METHOD(TypeText)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[out,retval]*/ BSTR* pbstr;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[out,retval]*/ BSTR* pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_SET_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTextValidValues
	{
		/*[in]*/ BSTR pbstr;
		HRESULT retValue;
	};

	STDMETHOD(SetText)(
		/*[in]*/ BSTR pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(SetText)

		VSL_CHECK_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCharValidValues
	{
		/*[out,retval]*/ long* pch;
		HRESULT retValue;
	};

	STDMETHOD(GetChar)(
		/*[out,retval]*/ long* pch)
	{
		VSL_DEFINE_MOCK_METHOD(GetChar)

		VSL_SET_VALIDVALUE(pch);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCharValidValues
	{
		/*[in]*/ long pch;
		HRESULT retValue;
	};

	STDMETHOD(SetChar)(
		/*[in]*/ long pch)
	{
		VSL_DEFINE_MOCK_METHOD(SetChar)

		VSL_CHECK_VALIDVALUE(pch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDuplicateValidValues
	{
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(GetDuplicate)(
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(GetDuplicate)

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFormattedTextValidValues
	{
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(GetFormattedText)(
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(GetFormattedText)

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFormattedTextValidValues
	{
		/*[in]*/ ITextRange* ppRange;
		HRESULT retValue;
	};

	STDMETHOD(SetFormattedText)(
		/*[in]*/ ITextRange* ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(SetFormattedText)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStartValidValues
	{
		/*[out,retval]*/ long* pcpFirst;
		HRESULT retValue;
	};

	STDMETHOD(GetStart)(
		/*[out,retval]*/ long* pcpFirst)
	{
		VSL_DEFINE_MOCK_METHOD(GetStart)

		VSL_SET_VALIDVALUE(pcpFirst);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStartValidValues
	{
		/*[in]*/ long pcpFirst;
		HRESULT retValue;
	};

	STDMETHOD(SetStart)(
		/*[in]*/ long pcpFirst)
	{
		VSL_DEFINE_MOCK_METHOD(SetStart)

		VSL_CHECK_VALIDVALUE(pcpFirst);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEndValidValues
	{
		/*[out,retval]*/ long* pcpLim;
		HRESULT retValue;
	};

	STDMETHOD(GetEnd)(
		/*[out,retval]*/ long* pcpLim)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnd)

		VSL_SET_VALIDVALUE(pcpLim);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEndValidValues
	{
		/*[in]*/ long pcpLim;
		HRESULT retValue;
	};

	STDMETHOD(SetEnd)(
		/*[in]*/ long pcpLim)
	{
		VSL_DEFINE_MOCK_METHOD(SetEnd)

		VSL_CHECK_VALIDVALUE(pcpLim);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFontValidValues
	{
		/*[out,retval]*/ ITextFont** pFont;
		HRESULT retValue;
	};

	STDMETHOD(GetFont)(
		/*[out,retval]*/ ITextFont** pFont)
	{
		VSL_DEFINE_MOCK_METHOD(GetFont)

		VSL_SET_VALIDVALUE_INTERFACE(pFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFontValidValues
	{
		/*[in]*/ ITextFont* pFont;
		HRESULT retValue;
	};

	STDMETHOD(SetFont)(
		/*[in]*/ ITextFont* pFont)
	{
		VSL_DEFINE_MOCK_METHOD(SetFont)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParaValidValues
	{
		/*[out,retval]*/ ITextPara** pPara;
		HRESULT retValue;
	};

	STDMETHOD(GetPara)(
		/*[out,retval]*/ ITextPara** pPara)
	{
		VSL_DEFINE_MOCK_METHOD(GetPara)

		VSL_SET_VALIDVALUE_INTERFACE(pPara);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetParaValidValues
	{
		/*[in]*/ ITextPara* pPara;
		HRESULT retValue;
	};

	STDMETHOD(SetPara)(
		/*[in]*/ ITextPara* pPara)
	{
		VSL_DEFINE_MOCK_METHOD(SetPara)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPara);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoryLengthValidValues
	{
		/*[out,retval]*/ long* pcch;
		HRESULT retValue;
	};

	STDMETHOD(GetStoryLength)(
		/*[out,retval]*/ long* pcch)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoryLength)

		VSL_SET_VALIDVALUE(pcch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStoryTypeValidValues
	{
		/*[out,retval]*/ long* pValue;
		HRESULT retValue;
	};

	STDMETHOD(GetStoryType)(
		/*[out,retval]*/ long* pValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetStoryType)

		VSL_SET_VALIDVALUE(pValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct CollapseValidValues
	{
		/*[in]*/ long bStart;
		HRESULT retValue;
	};

	STDMETHOD(Collapse)(
		/*[in]*/ long bStart)
	{
		VSL_DEFINE_MOCK_METHOD(Collapse)

		VSL_CHECK_VALIDVALUE(bStart);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExpandValidValues
	{
		/*[in]*/ long Unit;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(Expand)(
		/*[in]*/ long Unit,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(Expand)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIndexValidValues
	{
		/*[in]*/ long Unit;
		/*[out,retval]*/ long* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetIndex)(
		/*[in]*/ long Unit,
		/*[out,retval]*/ long* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetIndex)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetIndexValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Index;
		/*[in]*/ long Extend;
		HRESULT retValue;
	};

	STDMETHOD(SetIndex)(
		/*[in]*/ long Unit,
		/*[in]*/ long Index,
		/*[in]*/ long Extend)
	{
		VSL_DEFINE_MOCK_METHOD(SetIndex)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRangeValidValues
	{
		/*[in]*/ long cpActive;
		/*[in]*/ long cpOther;
		HRESULT retValue;
	};

	STDMETHOD(SetRange)(
		/*[in]*/ long cpActive,
		/*[in]*/ long cpOther)
	{
		VSL_DEFINE_MOCK_METHOD(SetRange)

		VSL_CHECK_VALIDVALUE(cpActive);

		VSL_CHECK_VALIDVALUE(cpOther);

		VSL_RETURN_VALIDVALUES();
	}
	struct InRangeValidValues
	{
		/*[in]*/ ITextRange* pRange;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(InRange)(
		/*[in]*/ ITextRange* pRange,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(InRange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRange);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct InStoryValidValues
	{
		/*[in]*/ ITextRange* pRange;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(InStory)(
		/*[in]*/ ITextRange* pRange,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(InStory)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRange);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in]*/ ITextRange* pRange;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in]*/ ITextRange* pRange,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRange);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Select)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Select)

		VSL_RETURN_VALIDVALUES();
	}
	struct StartOfValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(StartOf)(
		/*[in]*/ long Unit,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(StartOf)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndOfValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Extend;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(EndOf)(
		/*[in]*/ long Unit,
		/*[in]*/ long Extend,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(EndOf)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(Move)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(Move)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveStartValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveStart)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveStart)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveEndValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveEnd)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveEnd)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveWhileValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveWhile)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveWhile)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveStartWhileValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveStartWhile)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveStartWhile)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveEndWhileValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveEndWhile)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveEndWhile)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveUntilValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveUntil)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveUntil)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveStartUntilValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveStartUntil)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveStartUntil)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveEndUntilValidValues
	{
		/*[in]*/ VARIANT* Cset;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(MoveEndUntil)(
		/*[in]*/ VARIANT* Cset,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(MoveEndUntil)

		VSL_CHECK_VALIDVALUE_POINTER(Cset);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTextValidValues
	{
		/*[in]*/ BSTR bstr;
		/*[in]*/ long cch;
		/*[in]*/ long Flags;
		/*[out,retval]*/ long* pLength;
		HRESULT retValue;
	};

	STDMETHOD(FindText)(
		/*[in]*/ BSTR bstr,
		/*[in]*/ long cch,
		/*[in]*/ long Flags,
		/*[out,retval]*/ long* pLength)
	{
		VSL_DEFINE_MOCK_METHOD(FindText)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_SET_VALIDVALUE(pLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTextStartValidValues
	{
		/*[in]*/ BSTR bstr;
		/*[in]*/ long cch;
		/*[in]*/ long Flags;
		/*[out,retval]*/ long* pLength;
		HRESULT retValue;
	};

	STDMETHOD(FindTextStart)(
		/*[in]*/ BSTR bstr,
		/*[in]*/ long cch,
		/*[in]*/ long Flags,
		/*[out,retval]*/ long* pLength)
	{
		VSL_DEFINE_MOCK_METHOD(FindTextStart)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_SET_VALIDVALUE(pLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTextEndValidValues
	{
		/*[in]*/ BSTR bstr;
		/*[in]*/ long cch;
		/*[in]*/ long Flags;
		/*[out,retval]*/ long* pLength;
		HRESULT retValue;
	};

	STDMETHOD(FindTextEnd)(
		/*[in]*/ BSTR bstr,
		/*[in]*/ long cch,
		/*[in]*/ long Flags,
		/*[out,retval]*/ long* pLength)
	{
		VSL_DEFINE_MOCK_METHOD(FindTextEnd)

		VSL_CHECK_VALIDVALUE_BSTR(bstr);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_SET_VALIDVALUE(pLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteValidValues
	{
		/*[in]*/ long Unit;
		/*[in]*/ long Count;
		/*[out,retval]*/ long* pDelta;
		HRESULT retValue;
	};

	STDMETHOD(Delete)(
		/*[in]*/ long Unit,
		/*[in]*/ long Count,
		/*[out,retval]*/ long* pDelta)
	{
		VSL_DEFINE_MOCK_METHOD(Delete)

		VSL_CHECK_VALIDVALUE(Unit);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_SET_VALIDVALUE(pDelta);

		VSL_RETURN_VALIDVALUES();
	}
	struct CutValidValues
	{
		/*[out]*/ VARIANT* pVar;
		HRESULT retValue;
	};

	STDMETHOD(Cut)(
		/*[out]*/ VARIANT* pVar)
	{
		VSL_DEFINE_MOCK_METHOD(Cut)

		VSL_SET_VALIDVALUE_VARIANT(pVar);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyValidValues
	{
		/*[out]*/ VARIANT* pVar;
		HRESULT retValue;
	};

	STDMETHOD(Copy)(
		/*[out]*/ VARIANT* pVar)
	{
		VSL_DEFINE_MOCK_METHOD(Copy)

		VSL_SET_VALIDVALUE_VARIANT(pVar);

		VSL_RETURN_VALIDVALUES();
	}
	struct PasteValidValues
	{
		/*[in]*/ VARIANT* pVar;
		/*[in]*/ long Format;
		HRESULT retValue;
	};

	STDMETHOD(Paste)(
		/*[in]*/ VARIANT* pVar,
		/*[in]*/ long Format)
	{
		VSL_DEFINE_MOCK_METHOD(Paste)

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_CHECK_VALIDVALUE(Format);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanPasteValidValues
	{
		/*[in]*/ VARIANT* pVar;
		/*[in]*/ long Format;
		/*[out,retval]*/ long* pb;
		HRESULT retValue;
	};

	STDMETHOD(CanPaste)(
		/*[in]*/ VARIANT* pVar,
		/*[in]*/ long Format,
		/*[out,retval]*/ long* pb)
	{
		VSL_DEFINE_MOCK_METHOD(CanPaste)

		VSL_CHECK_VALIDVALUE_POINTER(pVar);

		VSL_CHECK_VALIDVALUE(Format);

		VSL_SET_VALIDVALUE(pb);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanEditValidValues
	{
		/*[out,retval]*/ long* pbCanEdit;
		HRESULT retValue;
	};

	STDMETHOD(CanEdit)(
		/*[out,retval]*/ long* pbCanEdit)
	{
		VSL_DEFINE_MOCK_METHOD(CanEdit)

		VSL_SET_VALIDVALUE(pbCanEdit);

		VSL_RETURN_VALIDVALUES();
	}
	struct ChangeCaseValidValues
	{
		/*[in]*/ long Type;
		HRESULT retValue;
	};

	STDMETHOD(ChangeCase)(
		/*[in]*/ long Type)
	{
		VSL_DEFINE_MOCK_METHOD(ChangeCase)

		VSL_CHECK_VALIDVALUE(Type);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPointValidValues
	{
		/*[in]*/ long Type;
		/*[out]*/ long* px;
		/*[out]*/ long* py;
		HRESULT retValue;
	};

	STDMETHOD(GetPoint)(
		/*[in]*/ long Type,
		/*[out]*/ long* px,
		/*[out]*/ long* py)
	{
		VSL_DEFINE_MOCK_METHOD(GetPoint)

		VSL_CHECK_VALIDVALUE(Type);

		VSL_SET_VALIDVALUE(px);

		VSL_SET_VALIDVALUE(py);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPointValidValues
	{
		/*[in]*/ long x;
		/*[in]*/ long y;
		/*[in]*/ long Type;
		/*[in]*/ long Extend;
		HRESULT retValue;
	};

	STDMETHOD(SetPoint)(
		/*[in]*/ long x,
		/*[in]*/ long y,
		/*[in]*/ long Type,
		/*[in]*/ long Extend)
	{
		VSL_DEFINE_MOCK_METHOD(SetPoint)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(Type);

		VSL_CHECK_VALIDVALUE(Extend);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollIntoViewValidValues
	{
		/*[in]*/ long Value;
		HRESULT retValue;
	};

	STDMETHOD(ScrollIntoView)(
		/*[in]*/ long Value)
	{
		VSL_DEFINE_MOCK_METHOD(ScrollIntoView)

		VSL_CHECK_VALIDVALUE(Value);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEmbeddedObjectValidValues
	{
		/*[out,retval]*/ IUnknown** ppv;
		HRESULT retValue;
	};

	STDMETHOD(GetEmbeddedObject)(
		/*[out,retval]*/ IUnknown** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(GetEmbeddedObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ _In_ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITEXTSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITextStoryRanges.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITEXTSTORYRANGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITEXTSTORYRANGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "TextObjectModel.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITextStoryRangesNotImpl :
	public ITextStoryRanges
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextStoryRangesNotImpl)

public:

	typedef ITextStoryRanges Interface;

	STDMETHOD(_NewEnum)(
		/*[out,retval]*/ IUnknown** /*ppunkEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Item)(
		/*[in]*/ long /*Index*/,
		/*[out,retval]*/ ITextRange** /*ppRange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ITextStoryRangesMockImpl :
	public ITextStoryRanges,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITextStoryRangesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITextStoryRangesMockImpl)

	typedef ITextStoryRanges Interface;
	struct _NewEnumValidValues
	{
		/*[out,retval]*/ IUnknown** ppunkEnum;
		HRESULT retValue;
	};

	STDMETHOD(_NewEnum)(
		/*[out,retval]*/ IUnknown** ppunkEnum)
	{
		VSL_DEFINE_MOCK_METHOD(_NewEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppunkEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct ItemValidValues
	{
		/*[in]*/ long Index;
		/*[out,retval]*/ ITextRange** ppRange;
		HRESULT retValue;
	};

	STDMETHOD(Item)(
		/*[in]*/ long Index,
		/*[out,retval]*/ ITextRange** ppRange)
	{
		VSL_DEFINE_MOCK_METHOD(Item)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppRange);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CountValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(get_Count)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITEXTSTORYRANGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIThumbnailExtractor.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITHUMBNAILEXTRACTOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITHUMBNAILEXTRACTOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IThumbnailExtractorNotImpl :
	public IThumbnailExtractor
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IThumbnailExtractorNotImpl)

public:

	typedef IThumbnailExtractor Interface;

	STDMETHOD(ExtractThumbnail)(
		/*[in]*/ IStorage* /*pStg*/,
		/*[in]*/ ULONG /*ulLength*/,
		/*[in]*/ ULONG /*ulHeight*/,
		/*[out]*/ ULONG* /*pulOutputLength*/,
		/*[out]*/ ULONG* /*pulOutputHeight*/,
		/*[out]*/ HBITMAP* /*phOutputBitmap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnFileUpdated)(
		/*[in]*/ IStorage* /*pStg*/)VSL_STDMETHOD_NOTIMPL
};

class IThumbnailExtractorMockImpl :
	public IThumbnailExtractor,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IThumbnailExtractorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IThumbnailExtractorMockImpl)

	typedef IThumbnailExtractor Interface;
	struct ExtractThumbnailValidValues
	{
		/*[in]*/ IStorage* pStg;
		/*[in]*/ ULONG ulLength;
		/*[in]*/ ULONG ulHeight;
		/*[out]*/ ULONG* pulOutputLength;
		/*[out]*/ ULONG* pulOutputHeight;
		/*[out]*/ HBITMAP* phOutputBitmap;
		HRESULT retValue;
	};

	STDMETHOD(ExtractThumbnail)(
		/*[in]*/ IStorage* pStg,
		/*[in]*/ ULONG ulLength,
		/*[in]*/ ULONG ulHeight,
		/*[out]*/ ULONG* pulOutputLength,
		/*[out]*/ ULONG* pulOutputHeight,
		/*[out]*/ HBITMAP* phOutputBitmap)
	{
		VSL_DEFINE_MOCK_METHOD(ExtractThumbnail)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStg);

		VSL_CHECK_VALIDVALUE(ulLength);

		VSL_CHECK_VALIDVALUE(ulHeight);

		VSL_SET_VALIDVALUE(pulOutputLength);

		VSL_SET_VALIDVALUE(pulOutputHeight);

		VSL_SET_VALIDVALUE(phOutputBitmap);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnFileUpdatedValidValues
	{
		/*[in]*/ IStorage* pStg;
		HRESULT retValue;
	};

	STDMETHOD(OnFileUpdated)(
		/*[in]*/ IStorage* pStg)
	{
		VSL_DEFINE_MOCK_METHOD(OnFileUpdated)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITHUMBNAILEXTRACTOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeChangeEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPECHANGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPECHANGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeChangeEventsNotImpl :
	public ITypeChangeEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeChangeEventsNotImpl)

public:

	typedef ITypeChangeEvents Interface;

	STDMETHOD(RequestTypeChange)(
		/*[in]*/ CHANGEKIND /*changeKind*/,
		/*[in]*/ ITypeInfo* /*pTInfoBefore*/,
		/*[in]*/ LPOLESTR /*pStrName*/,
		/*[out]*/ INT* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AfterTypeChange)(
		/*[in]*/ CHANGEKIND /*changeKind*/,
		/*[in]*/ ITypeInfo* /*pTInfoAfter*/,
		/*[in]*/ LPOLESTR /*pStrName*/)VSL_STDMETHOD_NOTIMPL
};

class ITypeChangeEventsMockImpl :
	public ITypeChangeEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeChangeEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeChangeEventsMockImpl)

	typedef ITypeChangeEvents Interface;
	struct RequestTypeChangeValidValues
	{
		/*[in]*/ CHANGEKIND changeKind;
		/*[in]*/ ITypeInfo* pTInfoBefore;
		/*[in]*/ LPOLESTR pStrName;
		/*[out]*/ INT* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(RequestTypeChange)(
		/*[in]*/ CHANGEKIND changeKind,
		/*[in]*/ ITypeInfo* pTInfoBefore,
		/*[in]*/ LPOLESTR pStrName,
		/*[out]*/ INT* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(RequestTypeChange)

		VSL_CHECK_VALIDVALUE(changeKind);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTInfoBefore);

		VSL_CHECK_VALIDVALUE_STRINGW(pStrName);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct AfterTypeChangeValidValues
	{
		/*[in]*/ CHANGEKIND changeKind;
		/*[in]*/ ITypeInfo* pTInfoAfter;
		/*[in]*/ LPOLESTR pStrName;
		HRESULT retValue;
	};

	STDMETHOD(AfterTypeChange)(
		/*[in]*/ CHANGEKIND changeKind,
		/*[in]*/ ITypeInfo* pTInfoAfter,
		/*[in]*/ LPOLESTR pStrName)
	{
		VSL_DEFINE_MOCK_METHOD(AfterTypeChange)

		VSL_CHECK_VALIDVALUE(changeKind);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTInfoAfter);

		VSL_CHECK_VALIDVALUE_STRINGW(pStrName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPECHANGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITrackSelection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITRACKSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITRACKSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "designer.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITrackSelectionNotImpl :
	public ITrackSelection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITrackSelectionNotImpl)

public:

	typedef ITrackSelection Interface;

	STDMETHOD(OnSelectChange)(
		/*[in]*/ ISelectionContainer* /*pSC*/)VSL_STDMETHOD_NOTIMPL
};

class ITrackSelectionMockImpl :
	public ITrackSelection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITrackSelectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITrackSelectionMockImpl)

	typedef ITrackSelection Interface;
	struct OnSelectChangeValidValues
	{
		/*[in]*/ ISelectionContainer* pSC;
		HRESULT retValue;
	};

	STDMETHOD(OnSelectChange)(
		/*[in]*/ ISelectionContainer* pSC)
	{
		VSL_DEFINE_MOCK_METHOD(OnSelectChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSC);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITRACKSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeInfoNotImpl :
	public ITypeInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeInfoNotImpl)

public:

	typedef ITypeInfo Interface;

	STDMETHOD(GetTypeAttr)(
		/*[out]*/ TYPEATTR** /*ppTypeAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** /*ppTComp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFuncDesc)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ FUNCDESC** /*ppFuncDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVarDesc)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ VARDESC** /*ppVarDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNames)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out,size_is(cMaxNames),length_is(*pcNames)]*/ BSTR* /*rgBstrNames*/,
		/*[in]*/ UINT /*cMaxNames*/,
		/*[out]*/ UINT* /*pcNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRefTypeOfImplType)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ HREFTYPE* /*pRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImplTypeFlags)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ INT* /*pImplTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[out,size_is(cNames)]*/ MEMBERID* /*pMemId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ PVOID /*pvInstance*/,
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentation)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out]*/ BSTR* /*pBstrName*/,
		/*[out]*/ BSTR* /*pBstrDocString*/,
		/*[out]*/ DWORD* /*pdwHelpContext*/,
		/*[out]*/ BSTR* /*pBstrHelpFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDllEntry)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ INVOKEKIND /*invKind*/,
		/*[out]*/ BSTR* /*pBstrDllName*/,
		/*[out]*/ BSTR* /*pBstrName*/,
		/*[out]*/ WORD* /*pwOrdinal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRefTypeInfo)(
		/*[in]*/ HREFTYPE /*hRefType*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddressOfMember)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ INVOKEKIND /*invKind*/,
		/*[out]*/ PVOID* /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstance)(
		/*[in]*/ IUnknown* /*pUnkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ PVOID* /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMops)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out]*/ BSTR* /*pBstrMops*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContainingTypeLib)(
		/*[out]*/ ITypeLib** /*ppTLib*/,
		/*[out]*/ UINT* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE ReleaseTypeAttr(
		/*[in]*/ TYPEATTR* /*pTypeAttr*/){ return ; }

	virtual void STDMETHODCALLTYPE ReleaseFuncDesc(
		/*[in]*/ FUNCDESC* /*pFuncDesc*/){ return ; }

	virtual void STDMETHODCALLTYPE ReleaseVarDesc(
		/*[in]*/ VARDESC* /*pVarDesc*/){ return ; }
};

class ITypeInfoMockImpl :
	public ITypeInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeInfoMockImpl)

	typedef ITypeInfo Interface;
	struct GetTypeAttrValidValues
	{
		/*[out]*/ TYPEATTR** ppTypeAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeAttr)(
		/*[out]*/ TYPEATTR** ppTypeAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeAttr)

		VSL_SET_VALIDVALUE(ppTypeAttr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeCompValidValues
	{
		/*[out]*/ ITypeComp** ppTComp;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** ppTComp)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeComp)

		VSL_SET_VALIDVALUE_INTERFACE(ppTComp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFuncDescValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ FUNCDESC** ppFuncDesc;
		HRESULT retValue;
	};

	STDMETHOD(GetFuncDesc)(
		/*[in]*/ UINT index,
		/*[out]*/ FUNCDESC** ppFuncDesc)
	{
		VSL_DEFINE_MOCK_METHOD(GetFuncDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(ppFuncDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVarDescValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ VARDESC** ppVarDesc;
		HRESULT retValue;
	};

	STDMETHOD(GetVarDesc)(
		/*[in]*/ UINT index,
		/*[out]*/ VARDESC** ppVarDesc)
	{
		VSL_DEFINE_MOCK_METHOD(GetVarDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(ppVarDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNamesValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out,size_is(cMaxNames),length_is(*pcNames)]*/ BSTR* rgBstrNames;
		/*[in]*/ UINT cMaxNames;
		/*[out]*/ UINT* pcNames;
		HRESULT retValue;
	};

	STDMETHOD(GetNames)(
		/*[in]*/ MEMBERID memid,
		/*[out,size_is(cMaxNames),length_is(*pcNames)]*/ BSTR* rgBstrNames,
		/*[in]*/ UINT cMaxNames,
		/*[out]*/ UINT* pcNames)
	{
		VSL_DEFINE_MOCK_METHOD(GetNames)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE_MEMCPY(rgBstrNames, cMaxNames*sizeof(rgBstrNames[0]), *(validValues.pcNames)*sizeof(validValues.rgBstrNames[0]));

		VSL_CHECK_VALIDVALUE(cMaxNames);

		VSL_SET_VALIDVALUE(pcNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRefTypeOfImplTypeValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ HREFTYPE* pRefType;
		HRESULT retValue;
	};

	STDMETHOD(GetRefTypeOfImplType)(
		/*[in]*/ UINT index,
		/*[out]*/ HREFTYPE* pRefType)
	{
		VSL_DEFINE_MOCK_METHOD(GetRefTypeOfImplType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImplTypeFlagsValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ INT* pImplTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetImplTypeFlags)(
		/*[in]*/ UINT index,
		/*[out]*/ INT* pImplTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetImplTypeFlags)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pImplTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[out,size_is(cNames)]*/ MEMBERID* pMemId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[out,size_is(cNames)]*/ MEMBERID* pMemId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_SET_VALIDVALUE_MEMCPY(pMemId, cNames*sizeof(pMemId[0]), validValues.cNames*sizeof(validValues.pMemId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ PVOID pvInstance;
		/*[in]*/ MEMBERID memid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
		size_t pvInstance_size_in_bytes;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ PVOID pvInstance,
		/*[in]*/ MEMBERID memid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE_PVOID(pvInstance);

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentationValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out]*/ BSTR* pBstrName;
		/*[out]*/ BSTR* pBstrDocString;
		/*[out]*/ DWORD* pdwHelpContext;
		/*[out]*/ BSTR* pBstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentation)(
		/*[in]*/ MEMBERID memid,
		/*[out]*/ BSTR* pBstrName,
		/*[out]*/ BSTR* pBstrDocString,
		/*[out]*/ DWORD* pdwHelpContext,
		/*[out]*/ BSTR* pBstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentation)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE_BSTR(pBstrName);

		VSL_SET_VALIDVALUE_BSTR(pBstrDocString);

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_SET_VALIDVALUE_BSTR(pBstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDllEntryValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ INVOKEKIND invKind;
		/*[out]*/ BSTR* pBstrDllName;
		/*[out]*/ BSTR* pBstrName;
		/*[out]*/ WORD* pwOrdinal;
		HRESULT retValue;
	};

	STDMETHOD(GetDllEntry)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ INVOKEKIND invKind,
		/*[out]*/ BSTR* pBstrDllName,
		/*[out]*/ BSTR* pBstrName,
		/*[out]*/ WORD* pwOrdinal)
	{
		VSL_DEFINE_MOCK_METHOD(GetDllEntry)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(invKind);

		VSL_SET_VALIDVALUE_BSTR(pBstrDllName);

		VSL_SET_VALIDVALUE_BSTR(pBstrName);

		VSL_SET_VALIDVALUE(pwOrdinal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRefTypeInfoValidValues
	{
		/*[in]*/ HREFTYPE hRefType;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRefTypeInfo)(
		/*[in]*/ HREFTYPE hRefType,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRefTypeInfo)

		VSL_CHECK_VALIDVALUE(hRefType);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddressOfMemberValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ INVOKEKIND invKind;
		/*[out]*/ PVOID* ppv;
		HRESULT retValue;
	};

	STDMETHOD(AddressOfMember)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ INVOKEKIND invKind,
		/*[out]*/ PVOID* ppv)
	{
		VSL_DEFINE_MOCK_METHOD(AddressOfMember)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(invKind);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceValidValues
	{
		/*[in]*/ IUnknown* pUnkOuter;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ PVOID* ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in]*/ IUnknown* pUnkOuter,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ PVOID* ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMopsValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out]*/ BSTR* pBstrMops;
		HRESULT retValue;
	};

	STDMETHOD(GetMops)(
		/*[in]*/ MEMBERID memid,
		/*[out]*/ BSTR* pBstrMops)
	{
		VSL_DEFINE_MOCK_METHOD(GetMops)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE_BSTR(pBstrMops);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContainingTypeLibValidValues
	{
		/*[out]*/ ITypeLib** ppTLib;
		/*[out]*/ UINT* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetContainingTypeLib)(
		/*[out]*/ ITypeLib** ppTLib,
		/*[out]*/ UINT* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetContainingTypeLib)

		VSL_SET_VALIDVALUE_INTERFACE(ppTLib);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseTypeAttrValidValues
	{
		/*[in]*/ TYPEATTR* pTypeAttr;
	};

	virtual void _stdcall ReleaseTypeAttr(
		/*[in]*/ TYPEATTR* pTypeAttr)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseTypeAttr)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeAttr);

	}
	struct ReleaseFuncDescValidValues
	{
		/*[in]*/ FUNCDESC* pFuncDesc;
	};

	virtual void _stdcall ReleaseFuncDesc(
		/*[in]*/ FUNCDESC* pFuncDesc)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseFuncDesc)

		VSL_CHECK_VALIDVALUE_POINTER(pFuncDesc);

	}
	struct ReleaseVarDescValidValues
	{
		/*[in]*/ VARDESC* pVarDesc;
	};

	virtual void _stdcall ReleaseVarDesc(
		/*[in]*/ VARDESC* pVarDesc)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseVarDesc)

		VSL_CHECK_VALIDVALUE_POINTER(pVarDesc);

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPEFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPEFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeFactoryNotImpl :
	public ITypeFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeFactoryNotImpl)

public:

	typedef ITypeFactory Interface;

	STDMETHOD(CreateFromTypeInfo)(
		/*[in]*/ ITypeInfo* /*pTypeInfo*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ IUnknown** /*ppv*/)VSL_STDMETHOD_NOTIMPL
};

class ITypeFactoryMockImpl :
	public ITypeFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeFactoryMockImpl)

	typedef ITypeFactory Interface;
	struct CreateFromTypeInfoValidValues
	{
		/*[in]*/ ITypeInfo* pTypeInfo;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ IUnknown** ppv;
		HRESULT retValue;
	};

	STDMETHOD(CreateFromTypeInfo)(
		/*[in]*/ ITypeInfo* pTypeInfo,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ IUnknown** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(CreateFromTypeInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTypeInfo);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE_INTERFACE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPEFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeInfo2NotImpl :
	public ITypeInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeInfo2NotImpl)

public:

	typedef ITypeInfo2 Interface;

	STDMETHOD(GetTypeKind)(
		/*[out]*/ TYPEKIND* /*pTypeKind*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeFlags)(
		/*[out]*/ ULONG* /*pTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFuncIndexOfMemId)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ INVOKEKIND /*invKind*/,
		/*[out]*/ UINT* /*pFuncIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVarIndexOfMemId)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out]*/ UINT* /*pVarIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustData)(
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFuncCustData)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParamCustData)(
		/*[in]*/ UINT /*indexFunc*/,
		/*[in]*/ UINT /*indexParam*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVarCustData)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImplTypeCustData)(
		/*[in]*/ UINT /*index*/,
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentation2)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ BSTR* /*pbstrHelpString*/,
		/*[out]*/ DWORD* /*pdwHelpStringContext*/,
		/*[out]*/ BSTR* /*pbstrHelpStringDll*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllCustData)(
		/*[out]*/ CUSTDATA* /*pCustData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllFuncCustData)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ CUSTDATA* /*pCustData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllParamCustData)(
		/*[in]*/ UINT /*indexFunc*/,
		/*[in]*/ UINT /*indexParam*/,
		/*[out]*/ CUSTDATA* /*pCustData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllVarCustData)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ CUSTDATA* /*pCustData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllImplTypeCustData)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ CUSTDATA* /*pCustData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeAttr)(
		/*[out]*/ TYPEATTR** /*ppTypeAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** /*ppTComp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFuncDesc)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ FUNCDESC** /*ppFuncDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVarDesc)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ VARDESC** /*ppVarDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNames)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out,size_is(cMaxNames),length_is(*pcNames)]*/ BSTR* /*rgBstrNames*/,
		/*[in]*/ UINT /*cMaxNames*/,
		/*[out]*/ UINT* /*pcNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRefTypeOfImplType)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ HREFTYPE* /*pRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImplTypeFlags)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ INT* /*pImplTypeFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[out,size_is(cNames)]*/ MEMBERID* /*pMemId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ PVOID /*pvInstance*/,
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentation)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out]*/ BSTR* /*pBstrName*/,
		/*[out]*/ BSTR* /*pBstrDocString*/,
		/*[out]*/ DWORD* /*pdwHelpContext*/,
		/*[out]*/ BSTR* /*pBstrHelpFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDllEntry)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ INVOKEKIND /*invKind*/,
		/*[out]*/ BSTR* /*pBstrDllName*/,
		/*[out]*/ BSTR* /*pBstrName*/,
		/*[out]*/ WORD* /*pwOrdinal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRefTypeInfo)(
		/*[in]*/ HREFTYPE /*hRefType*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddressOfMember)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[in]*/ INVOKEKIND /*invKind*/,
		/*[out]*/ PVOID* /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateInstance)(
		/*[in]*/ IUnknown* /*pUnkOuter*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ PVOID* /*ppvObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMops)(
		/*[in]*/ MEMBERID /*memid*/,
		/*[out]*/ BSTR* /*pBstrMops*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContainingTypeLib)(
		/*[out]*/ ITypeLib** /*ppTLib*/,
		/*[out]*/ UINT* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE ReleaseTypeAttr(
		/*[in]*/ TYPEATTR* /*pTypeAttr*/){ return ; }

	virtual void STDMETHODCALLTYPE ReleaseFuncDesc(
		/*[in]*/ FUNCDESC* /*pFuncDesc*/){ return ; }

	virtual void STDMETHODCALLTYPE ReleaseVarDesc(
		/*[in]*/ VARDESC* /*pVarDesc*/){ return ; }
};

class ITypeInfo2MockImpl :
	public ITypeInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeInfo2MockImpl)

	typedef ITypeInfo2 Interface;
	struct GetTypeKindValidValues
	{
		/*[out]*/ TYPEKIND* pTypeKind;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeKind)(
		/*[out]*/ TYPEKIND* pTypeKind)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeKind)

		VSL_SET_VALIDVALUE(pTypeKind);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeFlagsValidValues
	{
		/*[out]*/ ULONG* pTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeFlags)(
		/*[out]*/ ULONG* pTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeFlags)

		VSL_SET_VALIDVALUE(pTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFuncIndexOfMemIdValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ INVOKEKIND invKind;
		/*[out]*/ UINT* pFuncIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetFuncIndexOfMemId)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ INVOKEKIND invKind,
		/*[out]*/ UINT* pFuncIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetFuncIndexOfMemId)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(invKind);

		VSL_SET_VALIDVALUE(pFuncIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVarIndexOfMemIdValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out]*/ UINT* pVarIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetVarIndexOfMemId)(
		/*[in]*/ MEMBERID memid,
		/*[out]*/ UINT* pVarIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetVarIndexOfMemId)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE(pVarIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustDataValidValues
	{
		/*[in]*/ REFGUID guid;
		/*[out]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(GetCustData)(
		/*[in]*/ REFGUID guid,
		/*[out]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustData)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_VARIANT(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFuncCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ REFGUID guid;
		/*[out]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(GetFuncCustData)(
		/*[in]*/ UINT index,
		/*[in]*/ REFGUID guid,
		/*[out]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetFuncCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_VARIANT(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamCustDataValidValues
	{
		/*[in]*/ UINT indexFunc;
		/*[in]*/ UINT indexParam;
		/*[in]*/ REFGUID guid;
		/*[out]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(GetParamCustData)(
		/*[in]*/ UINT indexFunc,
		/*[in]*/ UINT indexParam,
		/*[in]*/ REFGUID guid,
		/*[out]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetParamCustData)

		VSL_CHECK_VALIDVALUE(indexFunc);

		VSL_CHECK_VALIDVALUE(indexParam);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_VARIANT(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVarCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ REFGUID guid;
		/*[out]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(GetVarCustData)(
		/*[in]*/ UINT index,
		/*[in]*/ REFGUID guid,
		/*[out]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetVarCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_VARIANT(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImplTypeCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[in]*/ REFGUID guid;
		/*[out]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(GetImplTypeCustData)(
		/*[in]*/ UINT index,
		/*[in]*/ REFGUID guid,
		/*[out]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetImplTypeCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_VARIANT(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentation2ValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ LCID lcid;
		/*[out]*/ BSTR* pbstrHelpString;
		/*[out]*/ DWORD* pdwHelpStringContext;
		/*[out]*/ BSTR* pbstrHelpStringDll;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentation2)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ LCID lcid,
		/*[out]*/ BSTR* pbstrHelpString,
		/*[out]*/ DWORD* pdwHelpStringContext,
		/*[out]*/ BSTR* pbstrHelpStringDll)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentation2)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpString);

		VSL_SET_VALIDVALUE(pdwHelpStringContext);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpStringDll);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllCustDataValidValues
	{
		/*[out]*/ CUSTDATA* pCustData;
		HRESULT retValue;
	};

	STDMETHOD(GetAllCustData)(
		/*[out]*/ CUSTDATA* pCustData)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllCustData)

		VSL_SET_VALIDVALUE(pCustData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllFuncCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ CUSTDATA* pCustData;
		HRESULT retValue;
	};

	STDMETHOD(GetAllFuncCustData)(
		/*[in]*/ UINT index,
		/*[out]*/ CUSTDATA* pCustData)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllFuncCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pCustData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllParamCustDataValidValues
	{
		/*[in]*/ UINT indexFunc;
		/*[in]*/ UINT indexParam;
		/*[out]*/ CUSTDATA* pCustData;
		HRESULT retValue;
	};

	STDMETHOD(GetAllParamCustData)(
		/*[in]*/ UINT indexFunc,
		/*[in]*/ UINT indexParam,
		/*[out]*/ CUSTDATA* pCustData)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllParamCustData)

		VSL_CHECK_VALIDVALUE(indexFunc);

		VSL_CHECK_VALIDVALUE(indexParam);

		VSL_SET_VALIDVALUE(pCustData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllVarCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ CUSTDATA* pCustData;
		HRESULT retValue;
	};

	STDMETHOD(GetAllVarCustData)(
		/*[in]*/ UINT index,
		/*[out]*/ CUSTDATA* pCustData)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllVarCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pCustData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllImplTypeCustDataValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ CUSTDATA* pCustData;
		HRESULT retValue;
	};

	STDMETHOD(GetAllImplTypeCustData)(
		/*[in]*/ UINT index,
		/*[out]*/ CUSTDATA* pCustData)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllImplTypeCustData)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pCustData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeAttrValidValues
	{
		/*[out]*/ TYPEATTR** ppTypeAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeAttr)(
		/*[out]*/ TYPEATTR** ppTypeAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeAttr)

		VSL_SET_VALIDVALUE(ppTypeAttr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeCompValidValues
	{
		/*[out]*/ ITypeComp** ppTComp;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** ppTComp)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeComp)

		VSL_SET_VALIDVALUE_INTERFACE(ppTComp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFuncDescValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ FUNCDESC** ppFuncDesc;
		HRESULT retValue;
	};

	STDMETHOD(GetFuncDesc)(
		/*[in]*/ UINT index,
		/*[out]*/ FUNCDESC** ppFuncDesc)
	{
		VSL_DEFINE_MOCK_METHOD(GetFuncDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(ppFuncDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVarDescValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ VARDESC** ppVarDesc;
		HRESULT retValue;
	};

	STDMETHOD(GetVarDesc)(
		/*[in]*/ UINT index,
		/*[out]*/ VARDESC** ppVarDesc)
	{
		VSL_DEFINE_MOCK_METHOD(GetVarDesc)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(ppVarDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNamesValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out,size_is(cMaxNames),length_is(*pcNames)]*/ BSTR* rgBstrNames;
		/*[in]*/ UINT cMaxNames;
		/*[out]*/ UINT* pcNames;
		HRESULT retValue;
	};

	STDMETHOD(GetNames)(
		/*[in]*/ MEMBERID memid,
		/*[out,size_is(cMaxNames),length_is(*pcNames)]*/ BSTR* rgBstrNames,
		/*[in]*/ UINT cMaxNames,
		/*[out]*/ UINT* pcNames)
	{
		VSL_DEFINE_MOCK_METHOD(GetNames)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE_MEMCPY(rgBstrNames, cMaxNames*sizeof(rgBstrNames[0]), *(validValues.pcNames)*sizeof(validValues.rgBstrNames[0]));

		VSL_CHECK_VALIDVALUE(cMaxNames);

		VSL_SET_VALIDVALUE(pcNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRefTypeOfImplTypeValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ HREFTYPE* pRefType;
		HRESULT retValue;
	};

	STDMETHOD(GetRefTypeOfImplType)(
		/*[in]*/ UINT index,
		/*[out]*/ HREFTYPE* pRefType)
	{
		VSL_DEFINE_MOCK_METHOD(GetRefTypeOfImplType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImplTypeFlagsValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ INT* pImplTypeFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetImplTypeFlags)(
		/*[in]*/ UINT index,
		/*[out]*/ INT* pImplTypeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetImplTypeFlags)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pImplTypeFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[out,size_is(cNames)]*/ MEMBERID* pMemId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[out,size_is(cNames)]*/ MEMBERID* pMemId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_SET_VALIDVALUE_MEMCPY(pMemId, cNames*sizeof(pMemId[0]), validValues.cNames*sizeof(validValues.pMemId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ PVOID pvInstance;
		/*[in]*/ MEMBERID memid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
		size_t pvInstance_size_in_bytes;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ PVOID pvInstance,
		/*[in]*/ MEMBERID memid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE_PVOID(pvInstance);

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentationValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out]*/ BSTR* pBstrName;
		/*[out]*/ BSTR* pBstrDocString;
		/*[out]*/ DWORD* pdwHelpContext;
		/*[out]*/ BSTR* pBstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentation)(
		/*[in]*/ MEMBERID memid,
		/*[out]*/ BSTR* pBstrName,
		/*[out]*/ BSTR* pBstrDocString,
		/*[out]*/ DWORD* pdwHelpContext,
		/*[out]*/ BSTR* pBstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentation)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE_BSTR(pBstrName);

		VSL_SET_VALIDVALUE_BSTR(pBstrDocString);

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_SET_VALIDVALUE_BSTR(pBstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDllEntryValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ INVOKEKIND invKind;
		/*[out]*/ BSTR* pBstrDllName;
		/*[out]*/ BSTR* pBstrName;
		/*[out]*/ WORD* pwOrdinal;
		HRESULT retValue;
	};

	STDMETHOD(GetDllEntry)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ INVOKEKIND invKind,
		/*[out]*/ BSTR* pBstrDllName,
		/*[out]*/ BSTR* pBstrName,
		/*[out]*/ WORD* pwOrdinal)
	{
		VSL_DEFINE_MOCK_METHOD(GetDllEntry)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(invKind);

		VSL_SET_VALIDVALUE_BSTR(pBstrDllName);

		VSL_SET_VALIDVALUE_BSTR(pBstrName);

		VSL_SET_VALIDVALUE(pwOrdinal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRefTypeInfoValidValues
	{
		/*[in]*/ HREFTYPE hRefType;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetRefTypeInfo)(
		/*[in]*/ HREFTYPE hRefType,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetRefTypeInfo)

		VSL_CHECK_VALIDVALUE(hRefType);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddressOfMemberValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[in]*/ INVOKEKIND invKind;
		/*[out]*/ PVOID* ppv;
		HRESULT retValue;
	};

	STDMETHOD(AddressOfMember)(
		/*[in]*/ MEMBERID memid,
		/*[in]*/ INVOKEKIND invKind,
		/*[out]*/ PVOID* ppv)
	{
		VSL_DEFINE_MOCK_METHOD(AddressOfMember)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_CHECK_VALIDVALUE(invKind);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateInstanceValidValues
	{
		/*[in]*/ IUnknown* pUnkOuter;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ PVOID* ppvObj;
		HRESULT retValue;
	};

	STDMETHOD(CreateInstance)(
		/*[in]*/ IUnknown* pUnkOuter,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ PVOID* ppvObj)
	{
		VSL_DEFINE_MOCK_METHOD(CreateInstance)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkOuter);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppvObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMopsValidValues
	{
		/*[in]*/ MEMBERID memid;
		/*[out]*/ BSTR* pBstrMops;
		HRESULT retValue;
	};

	STDMETHOD(GetMops)(
		/*[in]*/ MEMBERID memid,
		/*[out]*/ BSTR* pBstrMops)
	{
		VSL_DEFINE_MOCK_METHOD(GetMops)

		VSL_CHECK_VALIDVALUE(memid);

		VSL_SET_VALIDVALUE_BSTR(pBstrMops);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContainingTypeLibValidValues
	{
		/*[out]*/ ITypeLib** ppTLib;
		/*[out]*/ UINT* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetContainingTypeLib)(
		/*[out]*/ ITypeLib** ppTLib,
		/*[out]*/ UINT* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetContainingTypeLib)

		VSL_SET_VALIDVALUE_INTERFACE(ppTLib);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseTypeAttrValidValues
	{
		/*[in]*/ TYPEATTR* pTypeAttr;
	};

	virtual void _stdcall ReleaseTypeAttr(
		/*[in]*/ TYPEATTR* pTypeAttr)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseTypeAttr)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeAttr);

	}
	struct ReleaseFuncDescValidValues
	{
		/*[in]*/ FUNCDESC* pFuncDesc;
	};

	virtual void _stdcall ReleaseFuncDesc(
		/*[in]*/ FUNCDESC* pFuncDesc)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseFuncDesc)

		VSL_CHECK_VALIDVALUE_POINTER(pFuncDesc);

	}
	struct ReleaseVarDescValidValues
	{
		/*[in]*/ VARDESC* pVarDesc;
	};

	virtual void _stdcall ReleaseVarDesc(
		/*[in]*/ VARDESC* pVarDesc)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseVarDesc)

		VSL_CHECK_VALIDVALUE_POINTER(pVarDesc);

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPEINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeMarshal.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPEMARSHAL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPEMARSHAL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeMarshalNotImpl :
	public ITypeMarshal
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeMarshalNotImpl)

public:

	typedef ITypeMarshal Interface;

	STDMETHOD(Size)(
		/*[in]*/ PVOID /*pvType*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in]*/ PVOID /*pvDestContext*/,
		/*[out]*/ ULONG* /*pSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Marshal)(
		/*[in]*/ PVOID /*pvType*/,
		/*[in]*/ DWORD /*dwDestContext*/,
		/*[in]*/ PVOID /*pvDestContext*/,
		/*[in]*/ ULONG /*cbBufferLength*/,
		/*[out]*/ BYTE* /*pBuffer*/,
		/*[out]*/ ULONG* /*pcbWritten*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unmarshal)(
		/*[out]*/ PVOID /*pvType*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ ULONG /*cbBufferLength*/,
		/*[in]*/ BYTE* /*pBuffer*/,
		/*[out]*/ ULONG* /*pcbRead*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Free)(
		/*[in]*/ PVOID /*pvType*/)VSL_STDMETHOD_NOTIMPL
};

class ITypeMarshalMockImpl :
	public ITypeMarshal,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeMarshalMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeMarshalMockImpl)

	typedef ITypeMarshal Interface;
	struct SizeValidValues
	{
		/*[in]*/ PVOID pvType;
		/*[in]*/ DWORD dwDestContext;
		/*[in]*/ PVOID pvDestContext;
		/*[out]*/ ULONG* pSize;
		HRESULT retValue;
		size_t pvType_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(Size)(
		/*[in]*/ PVOID pvType,
		/*[in]*/ DWORD dwDestContext,
		/*[in]*/ PVOID pvDestContext,
		/*[out]*/ ULONG* pSize)
	{
		VSL_DEFINE_MOCK_METHOD(Size)

		VSL_CHECK_VALIDVALUE_PVOID(pvType);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_SET_VALIDVALUE(pSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct MarshalValidValues
	{
		/*[in]*/ PVOID pvType;
		/*[in]*/ DWORD dwDestContext;
		/*[in]*/ PVOID pvDestContext;
		/*[in]*/ ULONG cbBufferLength;
		/*[out]*/ BYTE* pBuffer;
		/*[out]*/ ULONG* pcbWritten;
		HRESULT retValue;
		size_t pvType_size_in_bytes;
		size_t pvDestContext_size_in_bytes;
	};

	STDMETHOD(Marshal)(
		/*[in]*/ PVOID pvType,
		/*[in]*/ DWORD dwDestContext,
		/*[in]*/ PVOID pvDestContext,
		/*[in]*/ ULONG cbBufferLength,
		/*[out]*/ BYTE* pBuffer,
		/*[out]*/ ULONG* pcbWritten)
	{
		VSL_DEFINE_MOCK_METHOD(Marshal)

		VSL_CHECK_VALIDVALUE_PVOID(pvType);

		VSL_CHECK_VALIDVALUE(dwDestContext);

		VSL_CHECK_VALIDVALUE_PVOID(pvDestContext);

		VSL_CHECK_VALIDVALUE(cbBufferLength);

		VSL_SET_VALIDVALUE(pBuffer);

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnmarshalValidValues
	{
		/*[out]*/ PVOID pvType;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ ULONG cbBufferLength;
		/*[in]*/ BYTE* pBuffer;
		/*[out]*/ ULONG* pcbRead;
		HRESULT retValue;
		size_t pvType_size_in_bytes;
	};

	STDMETHOD(Unmarshal)(
		/*[out]*/ PVOID pvType,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ ULONG cbBufferLength,
		/*[in]*/ BYTE* pBuffer,
		/*[out]*/ ULONG* pcbRead)
	{
		VSL_DEFINE_MOCK_METHOD(Unmarshal)

		VSL_SET_VALIDVALUE_PVOID(pvType);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(cbBufferLength);

		VSL_CHECK_VALIDVALUE_POINTER(pBuffer);

		VSL_SET_VALIDVALUE(pcbRead);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeValidValues
	{
		/*[in]*/ PVOID pvType;
		HRESULT retValue;
		size_t pvType_size_in_bytes;
	};

	STDMETHOD(Free)(
		/*[in]*/ PVOID pvType)
	{
		VSL_DEFINE_MOCK_METHOD(Free)

		VSL_CHECK_VALIDVALUE_PVOID(pvType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPEMARSHAL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeLib.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeLibNotImpl :
	public ITypeLib
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeLibNotImpl)

public:

	typedef ITypeLib Interface;

	virtual UINT STDMETHODCALLTYPE GetTypeInfoCount(){ return UINT(); }

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoType)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ TYPEKIND* /*pTKind*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoOfGuid)(
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ ITypeInfo** /*ppTinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibAttr)(
		/*[out]*/ TLIBATTR** /*ppTLibAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** /*ppTComp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentation)(
		/*[in]*/ INT /*index*/,
		/*[out]*/ BSTR* /*pBstrName*/,
		/*[out]*/ BSTR* /*pBstrDocString*/,
		/*[out]*/ DWORD* /*pdwHelpContext*/,
		/*[out]*/ BSTR* /*pBstrHelpFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsName)(
		/*[in,out]*/ LPOLESTR /*szNameBuf*/,
		/*[in]*/ ULONG /*lHashVal*/,
		/*[out]*/ BOOL* /*pfName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindName)(
		/*[in,out]*/ LPOLESTR /*szNameBuf*/,
		/*[in]*/ ULONG /*lHashVal*/,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ ITypeInfo** /*ppTInfo*/,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ MEMBERID* /*rgMemId*/,
		/*[in,out]*/ USHORT* /*pcFound*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE ReleaseTLibAttr(
		/*[in]*/ TLIBATTR* /*pTLibAttr*/){ return ; }
};

class ITypeLibMockImpl :
	public ITypeLib,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeLibMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeLibMockImpl)

	typedef ITypeLib Interface;
	struct GetTypeInfoCountValidValues
	{
		UINT retValue;
	};

	virtual UINT _stdcall GetTypeInfoCount()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetTypeInfoCount)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT index,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoTypeValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ TYPEKIND* pTKind;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoType)(
		/*[in]*/ UINT index,
		/*[out]*/ TYPEKIND* pTKind)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pTKind);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoOfGuidValidValues
	{
		/*[in]*/ REFGUID guid;
		/*[out]*/ ITypeInfo** ppTinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoOfGuid)(
		/*[in]*/ REFGUID guid,
		/*[out]*/ ITypeInfo** ppTinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoOfGuid)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibAttrValidValues
	{
		/*[out]*/ TLIBATTR** ppTLibAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetLibAttr)(
		/*[out]*/ TLIBATTR** ppTLibAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibAttr)

		VSL_SET_VALIDVALUE(ppTLibAttr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeCompValidValues
	{
		/*[out]*/ ITypeComp** ppTComp;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** ppTComp)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeComp)

		VSL_SET_VALIDVALUE_INTERFACE(ppTComp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentationValidValues
	{
		/*[in]*/ INT index;
		/*[out]*/ BSTR* pBstrName;
		/*[out]*/ BSTR* pBstrDocString;
		/*[out]*/ DWORD* pdwHelpContext;
		/*[out]*/ BSTR* pBstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentation)(
		/*[in]*/ INT index,
		/*[out]*/ BSTR* pBstrName,
		/*[out]*/ BSTR* pBstrDocString,
		/*[out]*/ DWORD* pdwHelpContext,
		/*[out]*/ BSTR* pBstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentation)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_BSTR(pBstrName);

		VSL_SET_VALIDVALUE_BSTR(pBstrDocString);

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_SET_VALIDVALUE_BSTR(pBstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsNameValidValues
	{
		/*[in,out]*/ LPOLESTR szNameBuf;
		/*[in]*/ ULONG lHashVal;
		/*[out]*/ BOOL* pfName;
		HRESULT retValue;
	};

	STDMETHOD(IsName)(
		/*[in,out]*/ LPOLESTR szNameBuf,
		/*[in]*/ ULONG lHashVal,
		/*[out]*/ BOOL* pfName)
	{
		VSL_DEFINE_MOCK_METHOD(IsName)

		VSL_SET_VALIDVALUE_STRINGW(szNameBuf, VSL_VALIDVALUD_STRINGW_LENGTH(szNameBuf));

		VSL_CHECK_VALIDVALUE(lHashVal);

		VSL_SET_VALIDVALUE(pfName);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindNameValidValues
	{
		/*[in,out]*/ LPOLESTR szNameBuf;
		/*[in]*/ ULONG lHashVal;
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ ITypeInfo** ppTInfo;
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ MEMBERID* rgMemId;
		/*[in,out]*/ USHORT* pcFound;
		HRESULT retValue;
	};

	STDMETHOD(FindName)(
		/*[in,out]*/ LPOLESTR szNameBuf,
		/*[in]*/ ULONG lHashVal,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ ITypeInfo** ppTInfo,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ MEMBERID* rgMemId,
		/*[in,out]*/ USHORT* pcFound)
	{
		VSL_DEFINE_MOCK_METHOD(FindName)

		VSL_SET_VALIDVALUE_STRINGW(szNameBuf, VSL_VALIDVALUD_STRINGW_LENGTH(szNameBuf));

		VSL_CHECK_VALIDVALUE(lHashVal);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(ppTInfo, *pcFound, *(validValues.pcFound));

		VSL_SET_VALIDVALUE_MEMCPY(rgMemId, *pcFound*sizeof(rgMemId[0]), *(validValues.pcFound)*sizeof(validValues.rgMemId[0]));

		VSL_SET_VALIDVALUE(pcFound);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseTLibAttrValidValues
	{
		/*[in]*/ TLIBATTR* pTLibAttr;
	};

	virtual void _stdcall ReleaseTLibAttr(
		/*[in]*/ TLIBATTR* pTLibAttr)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseTLibAttr)

		VSL_CHECK_VALIDVALUE_POINTER(pTLibAttr);

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPELIB_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockITypeLib2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ITYPELIB2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ITYPELIB2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "OAIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ITypeLib2NotImpl :
	public ITypeLib2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeLib2NotImpl)

public:

	typedef ITypeLib2 Interface;

	STDMETHOD(GetCustData)(
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ VARIANT* /*pVarVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibStatistics)(
		/*[out]*/ ULONG* /*pcUniqueNames*/,
		/*[out]*/ ULONG* /*pcchUniqueNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentation2)(
		/*[in]*/ INT /*index*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ BSTR* /*pbstrHelpString*/,
		/*[out]*/ DWORD* /*pdwHelpStringContext*/,
		/*[out]*/ BSTR* /*pbstrHelpStringDll*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAllCustData)(
		/*[out]*/ CUSTDATA* /*pCustData*/)VSL_STDMETHOD_NOTIMPL

	virtual UINT STDMETHODCALLTYPE GetTypeInfoCount(){ return UINT(); }

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoType)(
		/*[in]*/ UINT /*index*/,
		/*[out]*/ TYPEKIND* /*pTKind*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoOfGuid)(
		/*[in]*/ REFGUID /*guid*/,
		/*[out]*/ ITypeInfo** /*ppTinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibAttr)(
		/*[out]*/ TLIBATTR** /*ppTLibAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** /*ppTComp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentation)(
		/*[in]*/ INT /*index*/,
		/*[out]*/ BSTR* /*pBstrName*/,
		/*[out]*/ BSTR* /*pBstrDocString*/,
		/*[out]*/ DWORD* /*pdwHelpContext*/,
		/*[out]*/ BSTR* /*pBstrHelpFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsName)(
		/*[in,out]*/ LPOLESTR /*szNameBuf*/,
		/*[in]*/ ULONG /*lHashVal*/,
		/*[out]*/ BOOL* /*pfName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindName)(
		/*[in,out]*/ LPOLESTR /*szNameBuf*/,
		/*[in]*/ ULONG /*lHashVal*/,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ ITypeInfo** /*ppTInfo*/,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ MEMBERID* /*rgMemId*/,
		/*[in,out]*/ USHORT* /*pcFound*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE ReleaseTLibAttr(
		/*[in]*/ TLIBATTR* /*pTLibAttr*/){ return ; }
};

class ITypeLib2MockImpl :
	public ITypeLib2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ITypeLib2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ITypeLib2MockImpl)

	typedef ITypeLib2 Interface;
	struct GetCustDataValidValues
	{
		/*[in]*/ REFGUID guid;
		/*[out]*/ VARIANT* pVarVal;
		HRESULT retValue;
	};

	STDMETHOD(GetCustData)(
		/*[in]*/ REFGUID guid,
		/*[out]*/ VARIANT* pVarVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustData)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_VARIANT(pVarVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibStatisticsValidValues
	{
		/*[out]*/ ULONG* pcUniqueNames;
		/*[out]*/ ULONG* pcchUniqueNames;
		HRESULT retValue;
	};

	STDMETHOD(GetLibStatistics)(
		/*[out]*/ ULONG* pcUniqueNames,
		/*[out]*/ ULONG* pcchUniqueNames)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibStatistics)

		VSL_SET_VALIDVALUE(pcUniqueNames);

		VSL_SET_VALIDVALUE(pcchUniqueNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentation2ValidValues
	{
		/*[in]*/ INT index;
		/*[in]*/ LCID lcid;
		/*[out]*/ BSTR* pbstrHelpString;
		/*[out]*/ DWORD* pdwHelpStringContext;
		/*[out]*/ BSTR* pbstrHelpStringDll;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentation2)(
		/*[in]*/ INT index,
		/*[in]*/ LCID lcid,
		/*[out]*/ BSTR* pbstrHelpString,
		/*[out]*/ DWORD* pdwHelpStringContext,
		/*[out]*/ BSTR* pbstrHelpStringDll)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentation2)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpString);

		VSL_SET_VALIDVALUE(pdwHelpStringContext);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpStringDll);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAllCustDataValidValues
	{
		/*[out]*/ CUSTDATA* pCustData;
		HRESULT retValue;
	};

	STDMETHOD(GetAllCustData)(
		/*[out]*/ CUSTDATA* pCustData)
	{
		VSL_DEFINE_MOCK_METHOD(GetAllCustData)

		VSL_SET_VALIDVALUE(pCustData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		UINT retValue;
	};

	virtual UINT _stdcall GetTypeInfoCount()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetTypeInfoCount)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT index,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoTypeValidValues
	{
		/*[in]*/ UINT index;
		/*[out]*/ TYPEKIND* pTKind;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoType)(
		/*[in]*/ UINT index,
		/*[out]*/ TYPEKIND* pTKind)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoType)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pTKind);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoOfGuidValidValues
	{
		/*[in]*/ REFGUID guid;
		/*[out]*/ ITypeInfo** ppTinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoOfGuid)(
		/*[in]*/ REFGUID guid,
		/*[out]*/ ITypeInfo** ppTinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoOfGuid)

		VSL_CHECK_VALIDVALUE(guid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibAttrValidValues
	{
		/*[out]*/ TLIBATTR** ppTLibAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetLibAttr)(
		/*[out]*/ TLIBATTR** ppTLibAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibAttr)

		VSL_SET_VALIDVALUE(ppTLibAttr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeCompValidValues
	{
		/*[out]*/ ITypeComp** ppTComp;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeComp)(
		/*[out]*/ ITypeComp** ppTComp)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeComp)

		VSL_SET_VALIDVALUE_INTERFACE(ppTComp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentationValidValues
	{
		/*[in]*/ INT index;
		/*[out]*/ BSTR* pBstrName;
		/*[out]*/ BSTR* pBstrDocString;
		/*[out]*/ DWORD* pdwHelpContext;
		/*[out]*/ BSTR* pBstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentation)(
		/*[in]*/ INT index,
		/*[out]*/ BSTR* pBstrName,
		/*[out]*/ BSTR* pBstrDocString,
		/*[out]*/ DWORD* pdwHelpContext,
		/*[out]*/ BSTR* pBstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentation)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_BSTR(pBstrName);

		VSL_SET_VALIDVALUE_BSTR(pBstrDocString);

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_SET_VALIDVALUE_BSTR(pBstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsNameValidValues
	{
		/*[in,out]*/ LPOLESTR szNameBuf;
		/*[in]*/ ULONG lHashVal;
		/*[out]*/ BOOL* pfName;
		HRESULT retValue;
	};

	STDMETHOD(IsName)(
		/*[in,out]*/ LPOLESTR szNameBuf,
		/*[in]*/ ULONG lHashVal,
		/*[out]*/ BOOL* pfName)
	{
		VSL_DEFINE_MOCK_METHOD(IsName)

		VSL_SET_VALIDVALUE_STRINGW(szNameBuf, VSL_VALIDVALUD_STRINGW_LENGTH(szNameBuf));

		VSL_CHECK_VALIDVALUE(lHashVal);

		VSL_SET_VALIDVALUE(pfName);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindNameValidValues
	{
		/*[in,out]*/ LPOLESTR szNameBuf;
		/*[in]*/ ULONG lHashVal;
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ ITypeInfo** ppTInfo;
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ MEMBERID* rgMemId;
		/*[in,out]*/ USHORT* pcFound;
		HRESULT retValue;
	};

	STDMETHOD(FindName)(
		/*[in,out]*/ LPOLESTR szNameBuf,
		/*[in]*/ ULONG lHashVal,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ ITypeInfo** ppTInfo,
		/*[out,size_is(*pcFound),length_is(*pcFound)]*/ MEMBERID* rgMemId,
		/*[in,out]*/ USHORT* pcFound)
	{
		VSL_DEFINE_MOCK_METHOD(FindName)

		VSL_SET_VALIDVALUE_STRINGW(szNameBuf, VSL_VALIDVALUD_STRINGW_LENGTH(szNameBuf));

		VSL_CHECK_VALIDVALUE(lHashVal);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(ppTInfo, *pcFound, *(validValues.pcFound));

		VSL_SET_VALIDVALUE_MEMCPY(rgMemId, *pcFound*sizeof(rgMemId[0]), *(validValues.pcFound)*sizeof(validValues.rgMemId[0]));

		VSL_SET_VALIDVALUE(pcFound);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseTLibAttrValidValues
	{
		/*[in]*/ TLIBATTR* pTLibAttr;
	};

	virtual void _stdcall ReleaseTLibAttr(
		/*[in]*/ TLIBATTR* pTLibAttr)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseTLibAttr)

		VSL_CHECK_VALIDVALUE_POINTER(pTLibAttr);

	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ITYPELIB2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIUIHostLocale.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IUIHOSTLOCALE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IUIHOSTLOCALE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "uilocale.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IUIHostLocaleNotImpl :
	public IUIHostLocale
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUIHostLocaleNotImpl)

public:

	typedef IUIHostLocale Interface;

	STDMETHOD(GetUILocale)(
		/*[out,retval]*/ LCID* /*plcid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDialogFont)(
		/*[out]*/ UIDLGLOGFONT* /*plogfont*/)VSL_STDMETHOD_NOTIMPL
};

class IUIHostLocaleMockImpl :
	public IUIHostLocale,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUIHostLocaleMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IUIHostLocaleMockImpl)

	typedef IUIHostLocale Interface;
	struct GetUILocaleValidValues
	{
		/*[out,retval]*/ LCID* plcid;
		HRESULT retValue;
	};

	STDMETHOD(GetUILocale)(
		/*[out,retval]*/ LCID* plcid)
	{
		VSL_DEFINE_MOCK_METHOD(GetUILocale)

		VSL_SET_VALIDVALUE(plcid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDialogFontValidValues
	{
		/*[out]*/ UIDLGLOGFONT* plogfont;
		HRESULT retValue;
	};

	STDMETHOD(GetDialogFont)(
		/*[out]*/ UIDLGLOGFONT* plogfont)
	{
		VSL_DEFINE_MOCK_METHOD(GetDialogFont)

		VSL_SET_VALIDVALUE(plogfont);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IUIHOSTLOCALE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIUIElement.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IUIELEMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IUIELEMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "objext.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IUIElementNotImpl :
	public IUIElement
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUIElementNotImpl)

public:

	typedef IUIElement Interface;

	STDMETHOD(Show)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hide)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsVisible)()VSL_STDMETHOD_NOTIMPL
};

class IUIElementMockImpl :
	public IUIElement,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUIElementMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IUIElementMockImpl)

	typedef IUIElement Interface;
	struct ShowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Show)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Show)

		VSL_RETURN_VALIDVALUES();
	}
	struct HideValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Hide)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Hide)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsVisibleValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsVisible)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsVisible)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IUIELEMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIUIHostLocale2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IUIHOSTLOCALE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IUIHOSTLOCALE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "uilocale.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IUIHostLocale2NotImpl :
	public IUIHostLocale2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUIHostLocale2NotImpl)

public:

	typedef IUIHostLocale2 Interface;

	STDMETHOD(LoadUILibrary)(
		/*[in]*/ LPCOLESTR /*lpstrPath*/,
		/*[in]*/ LPCOLESTR /*lpstrDllName*/,
		/*[in]*/ DWORD /*dwExFlags*/,
		/*[out,retval]*/ DWORD_PTR* /*phinstOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MungeDialogFont)(
		/*[in]*/ DWORD /*dwSize*/,
		/*[in,size_is(dwSize)]*/ const BYTE* /*pDlgTemplate*/,
		/*[out]*/ BYTE** /*ppDlgTemplateOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadDialog)(
		/*[in]*/ DWORD_PTR /*hMod*/,
		/*[in]*/ DWORD /*dwDlgResId*/,
		/*[out]*/ BYTE** /*ppDlgTemplate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUILibraryFileName)(
		/*[in]*/ LPCOLESTR /*lpstrPath*/,
		/*[in]*/ LPCOLESTR /*lpstrDllName*/,
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUILocale)(
		/*[out,retval]*/ LCID* /*plcid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDialogFont)(
		/*[out]*/ UIDLGLOGFONT* /*plogfont*/)VSL_STDMETHOD_NOTIMPL
};

class IUIHostLocale2MockImpl :
	public IUIHostLocale2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUIHostLocale2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IUIHostLocale2MockImpl)

	typedef IUIHostLocale2 Interface;
	struct LoadUILibraryValidValues
	{
		/*[in]*/ LPCOLESTR lpstrPath;
		/*[in]*/ LPCOLESTR lpstrDllName;
		/*[in]*/ DWORD dwExFlags;
		/*[out,retval]*/ DWORD_PTR* phinstOut;
		HRESULT retValue;
	};

	STDMETHOD(LoadUILibrary)(
		/*[in]*/ LPCOLESTR lpstrPath,
		/*[in]*/ LPCOLESTR lpstrDllName,
		/*[in]*/ DWORD dwExFlags,
		/*[out,retval]*/ DWORD_PTR* phinstOut)
	{
		VSL_DEFINE_MOCK_METHOD(LoadUILibrary)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrDllName);

		VSL_CHECK_VALIDVALUE(dwExFlags);

		VSL_SET_VALIDVALUE(phinstOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct MungeDialogFontValidValues
	{
		/*[in]*/ DWORD dwSize;
		/*[in,size_is(dwSize)]*/ BYTE* pDlgTemplate;
		/*[out]*/ BYTE** ppDlgTemplateOut;
		HRESULT retValue;
	};

	STDMETHOD(MungeDialogFont)(
		/*[in]*/ DWORD dwSize,
		/*[in,size_is(dwSize)]*/ const BYTE* pDlgTemplate,
		/*[out]*/ BYTE** ppDlgTemplateOut)
	{
		VSL_DEFINE_MOCK_METHOD(MungeDialogFont)

		VSL_CHECK_VALIDVALUE(dwSize);

		VSL_CHECK_VALIDVALUE_MEMCMP(pDlgTemplate, dwSize*sizeof(pDlgTemplate[0]), validValues.dwSize*sizeof(validValues.pDlgTemplate[0]));

		VSL_SET_VALIDVALUE(ppDlgTemplateOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadDialogValidValues
	{
		/*[in]*/ DWORD_PTR hMod;
		/*[in]*/ DWORD dwDlgResId;
		/*[out]*/ BYTE** ppDlgTemplate;
		HRESULT retValue;
	};

	STDMETHOD(LoadDialog)(
		/*[in]*/ DWORD_PTR hMod,
		/*[in]*/ DWORD dwDlgResId,
		/*[out]*/ BYTE** ppDlgTemplate)
	{
		VSL_DEFINE_MOCK_METHOD(LoadDialog)

		VSL_CHECK_VALIDVALUE(hMod);

		VSL_CHECK_VALIDVALUE(dwDlgResId);

		VSL_SET_VALIDVALUE(ppDlgTemplate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUILibraryFileNameValidValues
	{
		/*[in]*/ LPCOLESTR lpstrPath;
		/*[in]*/ LPCOLESTR lpstrDllName;
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(GetUILibraryFileName)(
		/*[in]*/ LPCOLESTR lpstrPath,
		/*[in]*/ LPCOLESTR lpstrDllName,
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetUILibraryFileName)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrDllName);

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUILocaleValidValues
	{
		/*[out,retval]*/ LCID* plcid;
		HRESULT retValue;
	};

	STDMETHOD(GetUILocale)(
		/*[out,retval]*/ LCID* plcid)
	{
		VSL_DEFINE_MOCK_METHOD(GetUILocale)

		VSL_SET_VALIDVALUE(plcid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDialogFontValidValues
	{
		/*[out]*/ UIDLGLOGFONT* plogfont;
		HRESULT retValue;
	};

	STDMETHOD(GetDialogFont)(
		/*[out]*/ UIDLGLOGFONT* plogfont)
	{
		VSL_DEFINE_MOCK_METHOD(GetDialogFont)

		VSL_SET_VALIDVALUE(plogfont);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IUIHOSTLOCALE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsActionNotImpl :
	public IVsAction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsActionNotImpl)

public:

	typedef IVsAction Interface;

	STDMETHOD(CanMerge)(
		/*[in]*/ IVsAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Merge)(
		/*[in]*/ IVsAction* /*pAction*/)VSL_STDMETHOD_NOTIMPL
};

class IVsActionMockImpl :
	public IVsAction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsActionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsActionMockImpl)

	typedef IVsAction Interface;
	struct CanMergeValidValues
	{
		/*[in]*/ IVsAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(CanMerge)(
		/*[in]*/ IVsAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(CanMerge)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct MergeValidValues
	{
		/*[in]*/ IVsAction* pAction;
		HRESULT retValue;
	};

	STDMETHOD(Merge)(
		/*[in]*/ IVsAction* pAction)
	{
		VSL_DEFINE_MOCK_METHOD(Merge)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIUrlMon.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IURLMON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IURLMON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IUrlMonNotImpl :
	public IUrlMon
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUrlMonNotImpl)

public:

	typedef IUrlMon Interface;

	STDMETHOD(AsyncGetClassBits)(
		/*[in]*/ REFCLSID /*rclsid*/,
		/*[in,unique]*/ LPCWSTR /*pszTYPE*/,
		/*[in,unique]*/ LPCWSTR /*pszExt*/,
		/*[in]*/ DWORD /*dwFileVersionMS*/,
		/*[in]*/ DWORD /*dwFileVersionLS*/,
		/*[in,unique]*/ LPCWSTR /*pszCodeBase*/,
		/*[in]*/ IBindCtx* /*pbc*/,
		/*[in]*/ DWORD /*dwClassContext*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ DWORD /*flags*/)VSL_STDMETHOD_NOTIMPL
};

class IUrlMonMockImpl :
	public IUrlMon,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUrlMonMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IUrlMonMockImpl)

	typedef IUrlMon Interface;
	struct AsyncGetClassBitsValidValues
	{
		/*[in]*/ REFCLSID rclsid;
		/*[in,unique]*/ LPCWSTR pszTYPE;
		/*[in,unique]*/ LPCWSTR pszExt;
		/*[in]*/ DWORD dwFileVersionMS;
		/*[in]*/ DWORD dwFileVersionLS;
		/*[in,unique]*/ LPCWSTR pszCodeBase;
		/*[in]*/ IBindCtx* pbc;
		/*[in]*/ DWORD dwClassContext;
		/*[in]*/ REFIID riid;
		/*[in]*/ DWORD flags;
		HRESULT retValue;
	};

	STDMETHOD(AsyncGetClassBits)(
		/*[in]*/ REFCLSID rclsid,
		/*[in,unique]*/ LPCWSTR pszTYPE,
		/*[in,unique]*/ LPCWSTR pszExt,
		/*[in]*/ DWORD dwFileVersionMS,
		/*[in]*/ DWORD dwFileVersionLS,
		/*[in,unique]*/ LPCWSTR pszCodeBase,
		/*[in]*/ IBindCtx* pbc,
		/*[in]*/ DWORD dwClassContext,
		/*[in]*/ REFIID riid,
		/*[in]*/ DWORD flags)
	{
		VSL_DEFINE_MOCK_METHOD(AsyncGetClassBits)

		VSL_CHECK_VALIDVALUE(rclsid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTYPE);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExt);

		VSL_CHECK_VALIDVALUE(dwFileVersionMS);

		VSL_CHECK_VALIDVALUE(dwFileVersionLS);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCodeBase);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pbc);

		VSL_CHECK_VALIDVALUE(dwClassContext);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IURLMON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsActivityLog.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSACTIVITYLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSACTIVITYLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsActivityLogNotImpl :
	public IVsActivityLog
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsActivityLogNotImpl)

public:

	typedef IVsActivityLog Interface;

	STDMETHOD(LogEntry)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryGuid)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ GUID /*guid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryHr)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ HRESULT /*hr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryGuidHr)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ GUID /*guid*/,
		/*[in]*/ HRESULT /*hr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ LPCOLESTR /*pszPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryGuidPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ GUID /*guid*/,
		/*[in]*/ LPCOLESTR /*pszPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryHrPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ HRESULT /*hr*/,
		/*[in]*/ LPCOLESTR /*pszPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogEntryGuidHrPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE /*actType*/,
		/*[in]*/ LPCOLESTR /*pszSource*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ GUID /*guid*/,
		/*[in]*/ HRESULT /*hr*/,
		/*[in]*/ LPCOLESTR /*pszPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsActivityLogMockImpl :
	public IVsActivityLog,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsActivityLogMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsActivityLogMockImpl)

	typedef IVsActivityLog Interface;
	struct LogEntryValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		HRESULT retValue;
	};

	STDMETHOD(LogEntry)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntry)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryGuidValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ GUID guid;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryGuid)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ GUID guid)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryGuid)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryHrValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ HRESULT hr;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryHr)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ HRESULT hr)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryHr)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(hr);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryGuidHrValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ GUID guid;
		/*[in]*/ HRESULT hr;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryGuidHr)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ GUID guid,
		/*[in]*/ HRESULT hr)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryGuidHr)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE(hr);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryPathValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ LPCOLESTR pszPath;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ LPCOLESTR pszPath)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryPath)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryGuidPathValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ GUID guid;
		/*[in]*/ LPCOLESTR pszPath;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryGuidPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ GUID guid,
		/*[in]*/ LPCOLESTR pszPath)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryGuidPath)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryHrPathValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ HRESULT hr;
		/*[in]*/ LPCOLESTR pszPath;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryHrPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ HRESULT hr,
		/*[in]*/ LPCOLESTR pszPath)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryHrPath)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(hr);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogEntryGuidHrPathValidValues
	{
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType;
		/*[in]*/ LPCOLESTR pszSource;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ GUID guid;
		/*[in]*/ HRESULT hr;
		/*[in]*/ LPCOLESTR pszPath;
		HRESULT retValue;
	};

	STDMETHOD(LogEntryGuidHrPath)(
		/*[in]*/ ACTIVITYLOG_ENTRYTYPE actType,
		/*[in]*/ LPCOLESTR pszSource,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ GUID guid,
		/*[in]*/ HRESULT hr,
		/*[in]*/ LPCOLESTR pszPath)
	{
		VSL_DEFINE_MOCK_METHOD(LogEntryGuidHrPath)

		VSL_CHECK_VALIDVALUE(actType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(guid);

		VSL_CHECK_VALIDVALUE(hr);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSACTIVITYLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAddProjectItemDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSADDPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSADDPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAddProjectItemDlgNotImpl :
	public IVsAddProjectItemDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddProjectItemDlgNotImpl)

public:

	typedef IVsAddProjectItemDlg Interface;

	STDMETHOD(AddProjectItemDlg)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSADDITEMFLAGS /*grfAddFlags*/,
		/*[in]*/ LPCOLESTR /*lpszExpand*/,
		/*[in]*/ LPCOLESTR /*lpszSelect*/,
		/*[in,out]*/ BSTR* /*pbstrLocation*/,
		/*[in,out]*/ BSTR* /*pbstrFilter*/,
		/*[out]*/ BOOL* /*pfDontShowAgain*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAddProjectItemDlgMockImpl :
	public IVsAddProjectItemDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddProjectItemDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAddProjectItemDlgMockImpl)

	typedef IVsAddProjectItemDlg Interface;
	struct AddProjectItemDlgValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSADDITEMFLAGS grfAddFlags;
		/*[in]*/ LPCOLESTR lpszExpand;
		/*[in]*/ LPCOLESTR lpszSelect;
		/*[in,out]*/ BSTR* pbstrLocation;
		/*[in,out]*/ BSTR* pbstrFilter;
		/*[out]*/ BOOL* pfDontShowAgain;
		HRESULT retValue;
	};

	STDMETHOD(AddProjectItemDlg)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSADDITEMFLAGS grfAddFlags,
		/*[in]*/ LPCOLESTR lpszExpand,
		/*[in]*/ LPCOLESTR lpszSelect,
		/*[in,out]*/ BSTR* pbstrLocation,
		/*[in,out]*/ BSTR* pbstrFilter,
		/*[out]*/ BOOL* pfDontShowAgain)
	{
		VSL_DEFINE_MOCK_METHOD(AddProjectItemDlg)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(grfAddFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszSelect);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilter);

		VSL_SET_VALIDVALUE(pfDontShowAgain);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSADDPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAddNewWebProjectItemDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSADDNEWWEBPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSADDNEWWEBPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAddNewWebProjectItemDlgNotImpl :
	public IVsAddNewWebProjectItemDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddNewWebProjectItemDlgNotImpl)

public:

	typedef IVsAddNewWebProjectItemDlg Interface;

	STDMETHOD(AddNewWebProjectItemDlg)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*lpszHelpTopic*/,
		/*[in]*/ LPCOLESTR /*lpszLanguage*/,
		/*[in]*/ LPCOLESTR /*lpszSelect*/,
		/*[in]*/ VSADDNEWWEBITEMOPTIONS /*options*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAddNewWebProjectItemDlgMockImpl :
	public IVsAddNewWebProjectItemDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddNewWebProjectItemDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAddNewWebProjectItemDlgMockImpl)

	typedef IVsAddNewWebProjectItemDlg Interface;
	struct AddNewWebProjectItemDlgValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszDlgTitle;
		/*[in]*/ LPCOLESTR lpszHelpTopic;
		/*[in]*/ LPCOLESTR lpszLanguage;
		/*[in]*/ LPCOLESTR lpszSelect;
		/*[in]*/ VSADDNEWWEBITEMOPTIONS options;
		HRESULT retValue;
	};

	STDMETHOD(AddNewWebProjectItemDlg)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszDlgTitle,
		/*[in]*/ LPCOLESTR lpszHelpTopic,
		/*[in]*/ LPCOLESTR lpszLanguage,
		/*[in]*/ LPCOLESTR lpszSelect,
		/*[in]*/ VSADDNEWWEBITEMOPTIONS options)
	{
		VSL_DEFINE_MOCK_METHOD(AddNewWebProjectItemDlg)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszHelpTopic);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszLanguage);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszSelect);

		VSL_CHECK_VALIDVALUE(options);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSADDNEWWEBPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAggregatableProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSAGGREGATABLEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSAGGREGATABLEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAggregatableProjectNotImpl :
	public IVsAggregatableProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAggregatableProjectNotImpl)

public:

	typedef IVsAggregatableProject Interface;

	STDMETHOD(SetInnerProject)(
		/*[in]*/ IUnknown* /*punkInner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeForOuter)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppvProject*/,
		/*[out]*/ BOOL* /*pfCanceled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAggregationComplete)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAggregateProjectTypeGuids)(
		/*[out]*/ BSTR* /*pbstrProjTypeGuids*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetAggregateProjectTypeGuids)(
		/*[in]*/ LPCOLESTR /*lpstrProjTypeGuids*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAggregatableProjectMockImpl :
	public IVsAggregatableProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAggregatableProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAggregatableProjectMockImpl)

	typedef IVsAggregatableProject Interface;
	struct SetInnerProjectValidValues
	{
		/*[in]*/ IUnknown* punkInner;
		HRESULT retValue;
	};

	STDMETHOD(SetInnerProject)(
		/*[in]*/ IUnknown* punkInner)
	{
		VSL_DEFINE_MOCK_METHOD(SetInnerProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkInner);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeForOuterValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFIID iidProject;
		/*[out,iid_is(iidProject)]*/ void** ppvProject;
		/*[out]*/ BOOL* pfCanceled;
		HRESULT retValue;
	};

	STDMETHOD(InitializeForOuter)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFIID iidProject,
		/*[out,iid_is(iidProject)]*/ void** ppvProject,
		/*[out]*/ BOOL* pfCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeForOuter)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_SET_VALIDVALUE(ppvProject);

		VSL_SET_VALIDVALUE(pfCanceled);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAggregationCompleteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnAggregationComplete)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnAggregationComplete)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAggregateProjectTypeGuidsValidValues
	{
		/*[out]*/ BSTR* pbstrProjTypeGuids;
		HRESULT retValue;
	};

	STDMETHOD(GetAggregateProjectTypeGuids)(
		/*[out]*/ BSTR* pbstrProjTypeGuids)
	{
		VSL_DEFINE_MOCK_METHOD(GetAggregateProjectTypeGuids)

		VSL_SET_VALIDVALUE_BSTR(pbstrProjTypeGuids);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetAggregateProjectTypeGuidsValidValues
	{
		/*[in]*/ LPCOLESTR lpstrProjTypeGuids;
		HRESULT retValue;
	};

	STDMETHOD(SetAggregateProjectTypeGuids)(
		/*[in]*/ LPCOLESTR lpstrProjTypeGuids)
	{
		VSL_DEFINE_MOCK_METHOD(SetAggregateProjectTypeGuids)

		VSL_CHECK_VALIDVALUE_STRINGW(lpstrProjTypeGuids);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSAGGREGATABLEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAddWebReferenceDlg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSADDWEBREFERENCEDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSADDWEBREFERENCEDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAddWebReferenceDlg2NotImpl :
	public IVsAddWebReferenceDlg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddWebReferenceDlg2NotImpl)

public:

	typedef IVsAddWebReferenceDlg2 Interface;

	STDMETHOD(AddWebReferenceDlg)(
		/*[in]*/ IDiscoverySession* /*pDiscoverySession*/,
		/*[out]*/ BSTR* /*pbstrWebReferenceUrl*/,
		/*[out]*/ BSTR* /*pbstrWebReferenceName*/,
		/*[out]*/ IDiscoveryResult** /*ppIDiscoveryResult*/,
		/*[out]*/ BOOL* /*pfCancelled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAddWebReferenceDlg2MockImpl :
	public IVsAddWebReferenceDlg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddWebReferenceDlg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAddWebReferenceDlg2MockImpl)

	typedef IVsAddWebReferenceDlg2 Interface;
	struct AddWebReferenceDlgValidValues
	{
		/*[in]*/ IDiscoverySession* pDiscoverySession;
		/*[out]*/ BSTR* pbstrWebReferenceUrl;
		/*[out]*/ BSTR* pbstrWebReferenceName;
		/*[out]*/ IDiscoveryResult** ppIDiscoveryResult;
		/*[out]*/ BOOL* pfCancelled;
		HRESULT retValue;
	};

	STDMETHOD(AddWebReferenceDlg)(
		/*[in]*/ IDiscoverySession* pDiscoverySession,
		/*[out]*/ BSTR* pbstrWebReferenceUrl,
		/*[out]*/ BSTR* pbstrWebReferenceName,
		/*[out]*/ IDiscoveryResult** ppIDiscoveryResult,
		/*[out]*/ BOOL* pfCancelled)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebReferenceDlg)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDiscoverySession);

		VSL_SET_VALIDVALUE_BSTR(pbstrWebReferenceUrl);

		VSL_SET_VALIDVALUE_BSTR(pbstrWebReferenceName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIDiscoveryResult);

		VSL_SET_VALIDVALUE(pfCancelled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSADDWEBREFERENCEDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAddProjectItemDlg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSADDPROJECTITEMDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSADDPROJECTITEMDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAddProjectItemDlg2NotImpl :
	public IVsAddProjectItemDlg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddProjectItemDlg2NotImpl)

public:

	typedef IVsAddProjectItemDlg2 Interface;

	STDMETHOD(AddProjectItemDlgTitled)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSADDITEMFLAGS /*grfAddFlags*/,
		/*[in]*/ LPCOLESTR /*lpszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*lpszExpand*/,
		/*[in]*/ LPCOLESTR /*lpszSelect*/,
		/*[in,out]*/ BSTR* /*pbstrLocation*/,
		/*[in,out]*/ BSTR* /*pbstrFilter*/,
		/*[out]*/ BOOL* /*pfDontShowAgain*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddNewProjectItem)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSSPECIFICEDITORFLAGS /*grfEditorFlags*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[in,out]*/ BSTR* /*pbstrFileToAdd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddExistingProjectItems)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSSPECIFICEDITORFLAGS /*grfEditorFlags*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ ULONG /*cFilesToAdd*/,
		/*[in,size_is(cFilesToAdd)]*/ LPCOLESTR[] /*rgpszFilesToAdd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddProjectItemDlgTitledEx)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSADDITEMFLAGS /*grfAddFlags*/,
		/*[in]*/ LPCOLESTR /*lpszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*lpszTreeViewTitle*/,
		/*[in]*/ LPCOLESTR /*lpszHelpTopic*/,
		/*[in]*/ LPCOLESTR /*lpszExpand*/,
		/*[in]*/ LPCOLESTR /*lpszSelect*/,
		/*[in,out]*/ BSTR* /*pbstrLocation*/,
		/*[in,out]*/ BSTR* /*pbstrFilter*/,
		/*[out]*/ BOOL* /*pfDontShowAgain*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddProjectItemDlg)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProject*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSADDITEMFLAGS /*grfAddFlags*/,
		/*[in]*/ LPCOLESTR /*lpszExpand*/,
		/*[in]*/ LPCOLESTR /*lpszSelect*/,
		/*[in,out]*/ BSTR* /*pbstrLocation*/,
		/*[in,out]*/ BSTR* /*pbstrFilter*/,
		/*[out]*/ BOOL* /*pfDontShowAgain*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAddProjectItemDlg2MockImpl :
	public IVsAddProjectItemDlg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddProjectItemDlg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAddProjectItemDlg2MockImpl)

	typedef IVsAddProjectItemDlg2 Interface;
	struct AddProjectItemDlgTitledValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSADDITEMFLAGS grfAddFlags;
		/*[in]*/ LPCOLESTR lpszDlgTitle;
		/*[in]*/ LPCOLESTR lpszExpand;
		/*[in]*/ LPCOLESTR lpszSelect;
		/*[in,out]*/ BSTR* pbstrLocation;
		/*[in,out]*/ BSTR* pbstrFilter;
		/*[out]*/ BOOL* pfDontShowAgain;
		HRESULT retValue;
	};

	STDMETHOD(AddProjectItemDlgTitled)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSADDITEMFLAGS grfAddFlags,
		/*[in]*/ LPCOLESTR lpszDlgTitle,
		/*[in]*/ LPCOLESTR lpszExpand,
		/*[in]*/ LPCOLESTR lpszSelect,
		/*[in,out]*/ BSTR* pbstrLocation,
		/*[in,out]*/ BSTR* pbstrFilter,
		/*[out]*/ BOOL* pfDontShowAgain)
	{
		VSL_DEFINE_MOCK_METHOD(AddProjectItemDlgTitled)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(grfAddFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszSelect);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilter);

		VSL_SET_VALIDVALUE(pfDontShowAgain);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddNewProjectItemValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ LPCOLESTR pszItemName;
		/*[in,out]*/ BSTR* pbstrFileToAdd;
		HRESULT retValue;
	};

	STDMETHOD(AddNewProjectItem)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ LPCOLESTR pszItemName,
		/*[in,out]*/ BSTR* pbstrFileToAdd)
	{
		VSL_DEFINE_MOCK_METHOD(AddNewProjectItem)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(grfEditorFlags);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileToAdd);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddExistingProjectItemsValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ ULONG cFilesToAdd;
		/*[in,size_is(cFilesToAdd)]*/ LPCOLESTR* rgpszFilesToAdd;
		HRESULT retValue;
	};

	STDMETHOD(AddExistingProjectItems)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ ULONG cFilesToAdd,
		/*[in,size_is(cFilesToAdd)]*/ LPCOLESTR rgpszFilesToAdd[])
	{
		VSL_DEFINE_MOCK_METHOD(AddExistingProjectItems)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(grfEditorFlags);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE(cFilesToAdd);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFilesToAdd, cFilesToAdd*sizeof(rgpszFilesToAdd[0]), validValues.cFilesToAdd*sizeof(validValues.rgpszFilesToAdd[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct AddProjectItemDlgTitledExValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSADDITEMFLAGS grfAddFlags;
		/*[in]*/ LPCOLESTR lpszDlgTitle;
		/*[in]*/ LPCOLESTR lpszTreeViewTitle;
		/*[in]*/ LPCOLESTR lpszHelpTopic;
		/*[in]*/ LPCOLESTR lpszExpand;
		/*[in]*/ LPCOLESTR lpszSelect;
		/*[in,out]*/ BSTR* pbstrLocation;
		/*[in,out]*/ BSTR* pbstrFilter;
		/*[out]*/ BOOL* pfDontShowAgain;
		HRESULT retValue;
	};

	STDMETHOD(AddProjectItemDlgTitledEx)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSADDITEMFLAGS grfAddFlags,
		/*[in]*/ LPCOLESTR lpszDlgTitle,
		/*[in]*/ LPCOLESTR lpszTreeViewTitle,
		/*[in]*/ LPCOLESTR lpszHelpTopic,
		/*[in]*/ LPCOLESTR lpszExpand,
		/*[in]*/ LPCOLESTR lpszSelect,
		/*[in,out]*/ BSTR* pbstrLocation,
		/*[in,out]*/ BSTR* pbstrFilter,
		/*[out]*/ BOOL* pfDontShowAgain)
	{
		VSL_DEFINE_MOCK_METHOD(AddProjectItemDlgTitledEx)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(grfAddFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTreeViewTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszHelpTopic);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszSelect);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilter);

		VSL_SET_VALIDVALUE(pfDontShowAgain);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddProjectItemDlgValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProject;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSADDITEMFLAGS grfAddFlags;
		/*[in]*/ LPCOLESTR lpszExpand;
		/*[in]*/ LPCOLESTR lpszSelect;
		/*[in,out]*/ BSTR* pbstrLocation;
		/*[in,out]*/ BSTR* pbstrFilter;
		/*[out]*/ BOOL* pfDontShowAgain;
		HRESULT retValue;
	};

	STDMETHOD(AddProjectItemDlg)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProject,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSADDITEMFLAGS grfAddFlags,
		/*[in]*/ LPCOLESTR lpszExpand,
		/*[in]*/ LPCOLESTR lpszSelect,
		/*[in,out]*/ BSTR* pbstrLocation,
		/*[in,out]*/ BSTR* pbstrFilter,
		/*[out]*/ BOOL* pfDontShowAgain)
	{
		VSL_DEFINE_MOCK_METHOD(AddProjectItemDlg)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(grfAddFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszSelect);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilter);

		VSL_SET_VALIDVALUE(pfDontShowAgain);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSADDPROJECTITEMDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAddWebReferenceDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSADDWEBREFERENCEDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSADDWEBREFERENCEDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAddWebReferenceDlgNotImpl :
	public IVsAddWebReferenceDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddWebReferenceDlgNotImpl)

public:

	typedef IVsAddWebReferenceDlg Interface;

	STDMETHOD(AddWebReferenceDlg)(
		/*[out]*/ BSTR* /*pbstrWebReferenceUrl*/,
		/*[out]*/ BOOL* /*pfCancelled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAddWebReferenceDlgMockImpl :
	public IVsAddWebReferenceDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAddWebReferenceDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAddWebReferenceDlgMockImpl)

	typedef IVsAddWebReferenceDlg Interface;
	struct AddWebReferenceDlgValidValues
	{
		/*[out]*/ BSTR* pbstrWebReferenceUrl;
		/*[out]*/ BOOL* pfCancelled;
		HRESULT retValue;
	};

	STDMETHOD(AddWebReferenceDlg)(
		/*[out]*/ BSTR* pbstrWebReferenceUrl,
		/*[out]*/ BOOL* pfCancelled)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebReferenceDlg)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebReferenceUrl);

		VSL_SET_VALIDVALUE(pfCancelled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSADDWEBREFERENCEDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAppCommandLine.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSAPPCOMMANDLINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSAPPCOMMANDLINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAppCommandLineNotImpl :
	public IVsAppCommandLine
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAppCommandLineNotImpl)

public:

	typedef IVsAppCommandLine Interface;

	STDMETHOD(GetOption)(
		/*[in]*/ LPCOLESTR /*pszOptionName*/,
		/*[out]*/ BOOL* /*pfPresent*/,
		/*[out,retval]*/ BSTR* /*pbstrOptionValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAppCommandLineMockImpl :
	public IVsAppCommandLine,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAppCommandLineMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAppCommandLineMockImpl)

	typedef IVsAppCommandLine Interface;
	struct GetOptionValidValues
	{
		/*[in]*/ LPCOLESTR pszOptionName;
		/*[out]*/ BOOL* pfPresent;
		/*[out,retval]*/ BSTR* pbstrOptionValue;
		HRESULT retValue;
	};

	STDMETHOD(GetOption)(
		/*[in]*/ LPCOLESTR pszOptionName,
		/*[out]*/ BOOL* pfPresent,
		/*[out,retval]*/ BSTR* pbstrOptionValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetOption)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOptionName);

		VSL_SET_VALIDVALUE(pfPresent);

		VSL_SET_VALIDVALUE_BSTR(pbstrOptionValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSAPPCOMMANDLINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsApplicationSettings.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSAPPLICATIONSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSAPPLICATIONSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsApplicationSettingsNotImpl :
	public IVsApplicationSettings
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsApplicationSettingsNotImpl)

public:

	typedef IVsApplicationSettings Interface;

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ LPCWSTR /*pszWebServiceName*/,
		/*[out]*/ BSTR* /*pbstrAppSettingsObjectName*/,
		/*[out]*/ BSTR* /*pbstrPropertyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAppSettingsPropertyExpression)(
		/*[in]*/ LPCWSTR /*pszAppSettingsObjectName*/,
		/*[in]*/ LPCWSTR /*pszPropertyName*/,
		/*[out,retval]*/ IUnknown** /*ppUnkExpression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureWebServiceUrlPropertyExpression)(
		/*[in]*/ LPCWSTR /*pszAppSettingsObjectName*/,
		/*[in]*/ LPCWSTR /*pszPropertyName*/,
		/*[in]*/ VARIANT /*varPropertyValue*/,
		/*[out,retval]*/ IUnknown** /*ppUnkExpression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPropertyInfo)(
		/*[in]*/ LPCWSTR /*pszAppSettingsObjectName*/,
		/*[in]*/ LPCWSTR /*pszPropertyName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsApplicationSettingsMockImpl :
	public IVsApplicationSettings,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsApplicationSettingsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsApplicationSettingsMockImpl)

	typedef IVsApplicationSettings Interface;
	struct GetPropertyInfoValidValues
	{
		/*[in]*/ LPCWSTR pszWebServiceName;
		/*[out]*/ BSTR* pbstrAppSettingsObjectName;
		/*[out]*/ BSTR* pbstrPropertyName;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyInfo)(
		/*[in]*/ LPCWSTR pszWebServiceName,
		/*[out]*/ BSTR* pbstrAppSettingsObjectName,
		/*[out]*/ BSTR* pbstrPropertyName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(pszWebServiceName);

		VSL_SET_VALIDVALUE_BSTR(pbstrAppSettingsObjectName);

		VSL_SET_VALIDVALUE_BSTR(pbstrPropertyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAppSettingsPropertyExpressionValidValues
	{
		/*[in]*/ LPCWSTR pszAppSettingsObjectName;
		/*[in]*/ LPCWSTR pszPropertyName;
		/*[out,retval]*/ IUnknown** ppUnkExpression;
		HRESULT retValue;
	};

	STDMETHOD(GetAppSettingsPropertyExpression)(
		/*[in]*/ LPCWSTR pszAppSettingsObjectName,
		/*[in]*/ LPCWSTR pszPropertyName,
		/*[out,retval]*/ IUnknown** ppUnkExpression)
	{
		VSL_DEFINE_MOCK_METHOD(GetAppSettingsPropertyExpression)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAppSettingsObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropertyName);

		VSL_SET_VALIDVALUE_INTERFACE(ppUnkExpression);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureWebServiceUrlPropertyExpressionValidValues
	{
		/*[in]*/ LPCWSTR pszAppSettingsObjectName;
		/*[in]*/ LPCWSTR pszPropertyName;
		/*[in]*/ VARIANT varPropertyValue;
		/*[out,retval]*/ IUnknown** ppUnkExpression;
		HRESULT retValue;
	};

	STDMETHOD(EnsureWebServiceUrlPropertyExpression)(
		/*[in]*/ LPCWSTR pszAppSettingsObjectName,
		/*[in]*/ LPCWSTR pszPropertyName,
		/*[in]*/ VARIANT varPropertyValue,
		/*[out,retval]*/ IUnknown** ppUnkExpression)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureWebServiceUrlPropertyExpression)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAppSettingsObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropertyName);

		VSL_CHECK_VALIDVALUE(varPropertyValue);

		VSL_SET_VALIDVALUE_INTERFACE(ppUnkExpression);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyInfoValidValues
	{
		/*[in]*/ LPCWSTR pszAppSettingsObjectName;
		/*[in]*/ LPCWSTR pszPropertyName;
		HRESULT retValue;
	};

	STDMETHOD(SetPropertyInfo)(
		/*[in]*/ LPCWSTR pszAppSettingsObjectName,
		/*[in]*/ LPCWSTR pszPropertyName)
	{
		VSL_DEFINE_MOCK_METHOD(SetPropertyInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAppSettingsObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropertyName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSAPPLICATIONSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAggregatableProjectFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSAGGREGATABLEPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSAGGREGATABLEPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAggregatableProjectFactoryNotImpl :
	public IVsAggregatableProjectFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAggregatableProjectFactoryNotImpl)

public:

	typedef IVsAggregatableProjectFactory Interface;

	STDMETHOD(GetAggregateProjectType)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[out]*/ BSTR* /*pbstrProjTypeGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PreCreateForOuter)(
		/*[in]*/ IUnknown* /*punkOuter*/,
		/*[out]*/ IUnknown** /*ppunkProject*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAggregatableProjectFactoryMockImpl :
	public IVsAggregatableProjectFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAggregatableProjectFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAggregatableProjectFactoryMockImpl)

	typedef IVsAggregatableProjectFactory Interface;
	struct GetAggregateProjectTypeValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[out]*/ BSTR* pbstrProjTypeGuid;
		HRESULT retValue;
	};

	STDMETHOD(GetAggregateProjectType)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[out]*/ BSTR* pbstrProjTypeGuid)
	{
		VSL_DEFINE_MOCK_METHOD(GetAggregateProjectType)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjTypeGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct PreCreateForOuterValidValues
	{
		/*[in]*/ IUnknown* punkOuter;
		/*[out]*/ IUnknown** ppunkProject;
		HRESULT retValue;
	};

	STDMETHOD(PreCreateForOuter)(
		/*[in]*/ IUnknown* punkOuter,
		/*[out]*/ IUnknown** ppunkProject)
	{
		VSL_DEFINE_MOCK_METHOD(PreCreateForOuter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkOuter);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkProject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSAGGREGATABLEPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAssemblyNameUnification.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSASSEMBLYNAMEUNIFICATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSASSEMBLYNAMEUNIFICATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAssemblyNameUnificationNotImpl :
	public IVsAssemblyNameUnification
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAssemblyNameUnificationNotImpl)

public:

	typedef IVsAssemblyNameUnification Interface;

	STDMETHOD(GetUnifiedAssemblyName)(
		/*[in]*/ LPCOLESTR /*wszFrameworkDirectory*/,
		/*[in]*/ LPCOLESTR /*wszSimpleAssemblyName*/,
		/*[in]*/ LPCOLESTR /*wszFullAssemblyName*/,
		/*[out]*/ BSTR* /*pbstrUnifiedAssemblyName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAssemblyNameUnificationMockImpl :
	public IVsAssemblyNameUnification,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAssemblyNameUnificationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAssemblyNameUnificationMockImpl)

	typedef IVsAssemblyNameUnification Interface;
	struct GetUnifiedAssemblyNameValidValues
	{
		/*[in]*/ LPCOLESTR wszFrameworkDirectory;
		/*[in]*/ LPCOLESTR wszSimpleAssemblyName;
		/*[in]*/ LPCOLESTR wszFullAssemblyName;
		/*[out]*/ BSTR* pbstrUnifiedAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(GetUnifiedAssemblyName)(
		/*[in]*/ LPCOLESTR wszFrameworkDirectory,
		/*[in]*/ LPCOLESTR wszSimpleAssemblyName,
		/*[in]*/ LPCOLESTR wszFullAssemblyName,
		/*[out]*/ BSTR* pbstrUnifiedAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUnifiedAssemblyName)

		VSL_CHECK_VALIDVALUE_STRINGW(wszFrameworkDirectory);

		VSL_CHECK_VALIDVALUE_STRINGW(wszSimpleAssemblyName);

		VSL_CHECK_VALIDVALUE_STRINGW(wszFullAssemblyName);

		VSL_SET_VALIDVALUE_BSTR(pbstrUnifiedAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSASSEMBLYNAMEUNIFICATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAsyncEnum.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSASYNCENUM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSASYNCENUM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAsyncEnumNotImpl :
	public IVsAsyncEnum
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsyncEnumNotImpl)

public:

	typedef IVsAsyncEnum Interface;

	STDMETHOD(AdviseAsyncEnumCallback)(
		/*[in]*/ IVsAsyncEnumCallback* /*pIVsAsyncEnumCallback*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseAsyncEnumCallback)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Stop)(
		/*[in]*/ BOOL /*fSync*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAsyncEnumMockImpl :
	public IVsAsyncEnum,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsyncEnumMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAsyncEnumMockImpl)

	typedef IVsAsyncEnum Interface;
	struct AdviseAsyncEnumCallbackValidValues
	{
		/*[in]*/ IVsAsyncEnumCallback* pIVsAsyncEnumCallback;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseAsyncEnumCallback)(
		/*[in]*/ IVsAsyncEnumCallback* pIVsAsyncEnumCallback,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseAsyncEnumCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsAsyncEnumCallback);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseAsyncEnumCallbackValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseAsyncEnumCallback)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseAsyncEnumCallback)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopValidValues
	{
		/*[in]*/ BOOL fSync;
		HRESULT retValue;
	};

	STDMETHOD(Stop)(
		/*[in]*/ BOOL fSync)
	{
		VSL_DEFINE_MOCK_METHOD(Stop)

		VSL_CHECK_VALIDVALUE(fSync);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSASYNCENUM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAsyncEnumCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSASYNCENUMCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSASYNCENUMCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAsyncEnumCallbackNotImpl :
	public IVsAsyncEnumCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsyncEnumCallbackNotImpl)

public:

	typedef IVsAsyncEnumCallback Interface;

	STDMETHOD(OnDataAvailable)(
		/*[in]*/ ULONG /*cElementsAvailable*/,
		/*[in]*/ BOOL /*fIsComplete*/,
		/*[in]*/ ULONG /*ulProgressCurrent*/,
		/*[in]*/ ULONG /*ulProgressMax*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAsyncEnumCallbackMockImpl :
	public IVsAsyncEnumCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsyncEnumCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAsyncEnumCallbackMockImpl)

	typedef IVsAsyncEnumCallback Interface;
	struct OnDataAvailableValidValues
	{
		/*[in]*/ ULONG cElementsAvailable;
		/*[in]*/ BOOL fIsComplete;
		/*[in]*/ ULONG ulProgressCurrent;
		/*[in]*/ ULONG ulProgressMax;
		HRESULT retValue;
	};

	STDMETHOD(OnDataAvailable)(
		/*[in]*/ ULONG cElementsAvailable,
		/*[in]*/ BOOL fIsComplete,
		/*[in]*/ ULONG ulProgressCurrent,
		/*[in]*/ ULONG ulProgressMax)
	{
		VSL_DEFINE_MOCK_METHOD(OnDataAvailable)

		VSL_CHECK_VALIDVALUE(cElementsAvailable);

		VSL_CHECK_VALIDVALUE(fIsComplete);

		VSL_CHECK_VALIDVALUE(ulProgressCurrent);

		VSL_CHECK_VALIDVALUE(ulProgressMax);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSASYNCENUMCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAsynchOpenFromSccProjectEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSASYNCHOPENFROMSCCPROJECTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSASYNCHOPENFROMSCCPROJECTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAsynchOpenFromSccProjectEventsNotImpl :
	public IVsAsynchOpenFromSccProjectEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsynchOpenFromSccProjectEventsNotImpl)

public:

	typedef IVsAsynchOpenFromSccProjectEvents Interface;

	STDMETHOD(OnFilesDownloaded)(
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszFullPaths*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnLoadComplete)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnLoadFailed)()VSL_STDMETHOD_NOTIMPL
};

class IVsAsynchOpenFromSccProjectEventsMockImpl :
	public IVsAsynchOpenFromSccProjectEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsynchOpenFromSccProjectEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAsynchOpenFromSccProjectEventsMockImpl)

	typedef IVsAsynchOpenFromSccProjectEvents Interface;
	struct OnFilesDownloadedValidValues
	{
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszFullPaths;
		HRESULT retValue;
	};

	STDMETHOD(OnFilesDownloaded)(
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszFullPaths[])
	{
		VSL_DEFINE_MOCK_METHOD(OnFilesDownloaded)

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFullPaths, cFiles*sizeof(rgpszFullPaths[0]), validValues.cFiles*sizeof(validValues.rgpszFullPaths[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnLoadCompleteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnLoadComplete)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnLoadComplete)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnLoadFailedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnLoadFailed)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnLoadFailed)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSASYNCHOPENFROMSCCPROJECTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAsynchOpenFromScc.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSASYNCHOPENFROMSCC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSASYNCHOPENFROMSCC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAsynchOpenFromSccNotImpl :
	public IVsAsynchOpenFromScc
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsynchOpenFromSccNotImpl)

public:

	typedef IVsAsynchOpenFromScc Interface;

	STDMETHOD(LoadProjectAsynchronously)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[out]*/ BOOL* /*pReturnValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadProject)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsLoadingContent)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ BOOL* /*pfIsLoading*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAsynchOpenFromSccMockImpl :
	public IVsAsynchOpenFromScc,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAsynchOpenFromSccMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAsynchOpenFromSccMockImpl)

	typedef IVsAsynchOpenFromScc Interface;
	struct LoadProjectAsynchronouslyValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[out]*/ BOOL* pReturnValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadProjectAsynchronously)(
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[out]*/ BOOL* pReturnValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadProjectAsynchronously)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_SET_VALIDVALUE(pReturnValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadProjectValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		HRESULT retValue;
	};

	STDMETHOD(LoadProject)(
		/*[in]*/ LPCOLESTR lpszProjectPath)
	{
		VSL_DEFINE_MOCK_METHOD(LoadProject)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsLoadingContentValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ BOOL* pfIsLoading;
		HRESULT retValue;
	};

	STDMETHOD(IsLoadingContent)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ BOOL* pfIsLoading)
	{
		VSL_DEFINE_MOCK_METHOD(IsLoadingContent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE(pfIsLoading);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSASYNCHOPENFROMSCC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBroadcastMessageEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBROADCASTMESSAGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBROADCASTMESSAGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBroadcastMessageEventsNotImpl :
	public IVsBroadcastMessageEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBroadcastMessageEventsNotImpl)

public:

	typedef IVsBroadcastMessageEvents Interface;

	STDMETHOD(OnBroadcastMessage)(
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBroadcastMessageEventsMockImpl :
	public IVsBroadcastMessageEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBroadcastMessageEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBroadcastMessageEventsMockImpl)

	typedef IVsBroadcastMessageEvents Interface;
	struct OnBroadcastMessageValidValues
	{
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		HRESULT retValue;
	};

	STDMETHOD(OnBroadcastMessage)(
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(OnBroadcastMessage)

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBROADCASTMESSAGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAtomicTextProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSATOMICTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSATOMICTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAtomicTextProviderNotImpl :
	public IVsAtomicTextProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAtomicTextProviderNotImpl)

public:

	typedef IVsAtomicTextProvider Interface;

	STDMETHOD(GetAtomFlags)(
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAtomAttributes)(
		/*[in]*/ DWORD /*dwLength*/,
		/*[out,size_is(dwLength)]*/ ULONG* /*pColorAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAtomGlyphWidth)(
		/*[in]*/ long /*iPixSpaceWidth*/,
		/*[out]*/ long* /*pGlyphPix*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawAtomGlyph)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAtomicTextProviderMockImpl :
	public IVsAtomicTextProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAtomicTextProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAtomicTextProviderMockImpl)

	typedef IVsAtomicTextProvider Interface;
	struct GetAtomFlagsValidValues
	{
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetAtomFlags)(
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetAtomFlags)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAtomAttributesValidValues
	{
		/*[in]*/ DWORD dwLength;
		/*[out,size_is(dwLength)]*/ ULONG* pColorAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetAtomAttributes)(
		/*[in]*/ DWORD dwLength,
		/*[out,size_is(dwLength)]*/ ULONG* pColorAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetAtomAttributes)

		VSL_CHECK_VALIDVALUE(dwLength);

		VSL_SET_VALIDVALUE_MEMCPY(pColorAttr, dwLength*sizeof(pColorAttr[0]), validValues.dwLength*sizeof(validValues.pColorAttr[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAtomGlyphWidthValidValues
	{
		/*[in]*/ long iPixSpaceWidth;
		/*[out]*/ long* pGlyphPix;
		HRESULT retValue;
	};

	STDMETHOD(GetAtomGlyphWidth)(
		/*[in]*/ long iPixSpaceWidth,
		/*[out]*/ long* pGlyphPix)
	{
		VSL_DEFINE_MOCK_METHOD(GetAtomGlyphWidth)

		VSL_CHECK_VALIDVALUE(iPixSpaceWidth);

		VSL_SET_VALIDVALUE(pGlyphPix);

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawAtomGlyphValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawAtomGlyph)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawAtomGlyph)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSATOMICTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBackForwardNavigation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBACKFORWARDNAVIGATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBACKFORWARDNAVIGATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBackForwardNavigationNotImpl :
	public IVsBackForwardNavigation
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBackForwardNavigationNotImpl)

public:

	typedef IVsBackForwardNavigation Interface;

	STDMETHOD(NavigateTo)(
		/*[in]*/ IVsWindowFrame* /*pFrame*/,
		/*[in]*/ BSTR /*bstrData*/,
		/*[in]*/ IUnknown* /*punk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEqual)(
		/*[in]*/ IVsWindowFrame* /*pFrame*/,
		/*[in]*/ BSTR /*bstrData*/,
		/*[in]*/ IUnknown* /*punk*/,
		/*[out,retval]*/ BOOL* /*fReplaceSelf*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBackForwardNavigationMockImpl :
	public IVsBackForwardNavigation,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBackForwardNavigationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBackForwardNavigationMockImpl)

	typedef IVsBackForwardNavigation Interface;
	struct NavigateToValidValues
	{
		/*[in]*/ IVsWindowFrame* pFrame;
		/*[in]*/ BSTR bstrData;
		/*[in]*/ IUnknown* punk;
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo)(
		/*[in]*/ IVsWindowFrame* pFrame,
		/*[in]*/ BSTR bstrData,
		/*[in]*/ IUnknown* punk)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateTo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_CHECK_VALIDVALUE_BSTR(bstrData);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEqualValidValues
	{
		/*[in]*/ IVsWindowFrame* pFrame;
		/*[in]*/ BSTR bstrData;
		/*[in]*/ IUnknown* punk;
		/*[out,retval]*/ BOOL* fReplaceSelf;
		HRESULT retValue;
	};

	STDMETHOD(IsEqual)(
		/*[in]*/ IVsWindowFrame* pFrame,
		/*[in]*/ BSTR bstrData,
		/*[in]*/ IUnknown* punk,
		/*[out,retval]*/ BOOL* fReplaceSelf)
	{
		VSL_DEFINE_MOCK_METHOD(IsEqual)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_CHECK_VALIDVALUE_BSTR(bstrData);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_SET_VALIDVALUE(fReplaceSelf);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBACKFORWARDNAVIGATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsAutoOutliningClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSAUTOOUTLININGCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSAUTOOUTLININGCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsAutoOutliningClientNotImpl :
	public IVsAutoOutliningClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAutoOutliningClientNotImpl)

public:

	typedef IVsAutoOutliningClient Interface;

	STDMETHOD(QueryWaitForAutoOutliningCallback)(
		/*[out]*/ BOOL* /*fWait*/)VSL_STDMETHOD_NOTIMPL
};

class IVsAutoOutliningClientMockImpl :
	public IVsAutoOutliningClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsAutoOutliningClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsAutoOutliningClientMockImpl)

	typedef IVsAutoOutliningClient Interface;
	struct QueryWaitForAutoOutliningCallbackValidValues
	{
		/*[out]*/ BOOL* fWait;
		HRESULT retValue;
	};

	STDMETHOD(QueryWaitForAutoOutliningCallback)(
		/*[out]*/ BOOL* fWait)
	{
		VSL_DEFINE_MOCK_METHOD(QueryWaitForAutoOutliningCallback)

		VSL_SET_VALIDVALUE(fWait);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSAUTOOUTLININGCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBatchUpdate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBATCHUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBATCHUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBatchUpdateNotImpl :
	public IVsBatchUpdate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBatchUpdateNotImpl)

public:

	typedef IVsBatchUpdate Interface;

	STDMETHOD(FlushPendingUpdates)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBatchUpdateMockImpl :
	public IVsBatchUpdate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBatchUpdateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBatchUpdateMockImpl)

	typedef IVsBatchUpdate Interface;
	struct FlushPendingUpdatesValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(FlushPendingUpdates)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(FlushPendingUpdates)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBATCHUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBrowseComponentSet.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBrowseComponentSetNotImpl :
	public IVsBrowseComponentSet
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseComponentSetNotImpl)

public:

	typedef IVsBrowseComponentSet Interface;

	STDMETHOD(put_ComponentsListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ComponentsListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* /*pdwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ChildListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ChildListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* /*pdwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[in]*/ IVsObjectList2* /*pExtraListToCombineWith*/,
		/*[out,retval]*/ IVsObjectList2** /*ppIVsObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pgrfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNavInfo)(
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/,
		/*[out,retval]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBrowseComponentSetMockImpl :
	public IVsBrowseComponentSet,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseComponentSetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBrowseComponentSetMockImpl)

	typedef IVsBrowseComponentSet Interface;
	struct put_ComponentsListOptionsValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(put_ComponentsListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ComponentsListOptions)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ComponentsListOptionsValidValues
	{
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions;
		HRESULT retValue;
	};

	STDMETHOD(get_ComponentsListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ComponentsListOptions)

		VSL_SET_VALIDVALUE(pdwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ChildListOptionsValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(put_ChildListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ChildListOptions)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ChildListOptionsValidValues
	{
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions;
		HRESULT retValue;
	};

	STDMETHOD(get_ChildListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ChildListOptions)

		VSL_SET_VALIDVALUE(pdwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[in]*/ IVsObjectList2* pExtraListToCombineWith;
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[in]*/ IVsObjectList2* pExtraListToCombineWith,
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExtraListToCombineWith);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSupportedCategoryFields2ValidValues
	{
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pgrfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pgrfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedCategoryFields2)

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pgrfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNavInfoValidValues
	{
		/*[in]*/ REFGUID guidLib;
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		/*[out,retval]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateNavInfo)(
		/*[in]*/ REFGUID guidLib,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes,
		/*[out,retval]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNavInfo)

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBrowseObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBROWSEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBROWSEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBrowseObjectNotImpl :
	public IVsBrowseObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseObjectNotImpl)

public:

	typedef IVsBrowseObject Interface;

	STDMETHOD(GetProjectItem)(
		/*[out]*/ IVsHierarchy** /*pHier*/,
		/*[out]*/ VSITEMID* /*pItemid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBrowseObjectMockImpl :
	public IVsBrowseObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBrowseObjectMockImpl)

	typedef IVsBrowseObject Interface;
	struct GetProjectItemValidValues
	{
		/*[out]*/ IVsHierarchy** pHier;
		/*[out]*/ VSITEMID* pItemid;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectItem)(
		/*[out]*/ IVsHierarchy** pHier,
		/*[out]*/ VSITEMID* pItemid)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectItem)

		VSL_SET_VALIDVALUE_INTERFACE(pHier);

		VSL_SET_VALIDVALUE(pItemid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBROWSEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBrowseContainersList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBROWSECONTAINERSLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBROWSECONTAINERSLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBrowseContainersListNotImpl :
	public IVsBrowseContainersList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseContainersListNotImpl)

public:

	typedef IVsBrowseContainersList Interface;

	STDMETHOD(GetContainerData)(
		/*[in]*/ ULONG /*ulIndex*/,
		/*[out]*/ VSCOMPONENTSELECTORDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindContainer)(
		/*[in]*/ VSCOMPONENTSELECTORDATA* /*pData*/,
		/*[out]*/ ULONG* /*pulIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBrowseContainersListMockImpl :
	public IVsBrowseContainersList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseContainersListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBrowseContainersListMockImpl)

	typedef IVsBrowseContainersList Interface;
	struct GetContainerDataValidValues
	{
		/*[in]*/ ULONG ulIndex;
		/*[out]*/ VSCOMPONENTSELECTORDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetContainerData)(
		/*[in]*/ ULONG ulIndex,
		/*[out]*/ VSCOMPONENTSELECTORDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetContainerData)

		VSL_CHECK_VALIDVALUE(ulIndex);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindContainerValidValues
	{
		/*[in]*/ VSCOMPONENTSELECTORDATA* pData;
		/*[out]*/ ULONG* pulIndex;
		HRESULT retValue;
	};

	STDMETHOD(FindContainer)(
		/*[in]*/ VSCOMPONENTSELECTORDATA* pData,
		/*[out]*/ ULONG* pulIndex)
	{
		VSL_DEFINE_MOCK_METHOD(FindContainer)

		VSL_CHECK_VALIDVALUE_POINTER(pData);

		VSL_SET_VALIDVALUE(pulIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBROWSECONTAINERSLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBuildMacroInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUILDMACROINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUILDMACROINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBuildMacroInfoNotImpl :
	public IVsBuildMacroInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildMacroInfoNotImpl)

public:

	typedef IVsBuildMacroInfo Interface;

	STDMETHOD(GetBuildMacroValue)(
		/*[in]*/ BSTR /*bstrBuildMacroName*/,
		/*[out]*/ BSTR* /*pbstrBuildMacroValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBuildMacroInfoMockImpl :
	public IVsBuildMacroInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildMacroInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBuildMacroInfoMockImpl)

	typedef IVsBuildMacroInfo Interface;
	struct GetBuildMacroValueValidValues
	{
		/*[in]*/ BSTR bstrBuildMacroName;
		/*[out]*/ BSTR* pbstrBuildMacroValue;
		HRESULT retValue;
	};

	STDMETHOD(GetBuildMacroValue)(
		/*[in]*/ BSTR bstrBuildMacroName,
		/*[out]*/ BSTR* pbstrBuildMacroValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuildMacroValue)

		VSL_CHECK_VALIDVALUE_BSTR(bstrBuildMacroName);

		VSL_SET_VALIDVALUE_BSTR(pbstrBuildMacroValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUILDMACROINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBuildableProjectCfg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUILDABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUILDABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBuildableProjectCfg2NotImpl :
	public IVsBuildableProjectCfg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildableProjectCfg2NotImpl)

public:

	typedef IVsBuildableProjectCfg2 Interface;

	STDMETHOD(GetBuildCfgProperty)(
		/*[in]*/ VSBLDCFGPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartBuildEx)(
		/*[in]*/ DWORD /*dwBuildId*/,
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBuildableProjectCfg2MockImpl :
	public IVsBuildableProjectCfg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildableProjectCfg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBuildableProjectCfg2MockImpl)

	typedef IVsBuildableProjectCfg2 Interface;
	struct GetBuildCfgPropertyValidValues
	{
		/*[in]*/ VSBLDCFGPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetBuildCfgProperty)(
		/*[in]*/ VSBLDCFGPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuildCfgProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartBuildExValidValues
	{
		/*[in]*/ DWORD dwBuildId;
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartBuildEx)(
		/*[in]*/ DWORD dwBuildId,
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartBuildEx)

		VSL_CHECK_VALIDVALUE(dwBuildId);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUILDABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBuildDependency.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUILDDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUILDDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBuildDependencyNotImpl :
	public IVsBuildDependency
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildDependencyNotImpl)

public:

	typedef IVsBuildDependency Interface;

	STDMETHOD(get_MustUpdateBefore)(
		/*[out]*/ BOOL* /*pfMustUpdateBefore*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReferredProject)(
		/*[out]*/ IUnknown** /*ppIUnknownProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* /*pguidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HelpContext)(
		/*[out]*/ DWORD* /*pdwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HelpFile)(
		/*[out]*/ BSTR* /*pbstrHelpFile*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBuildDependencyMockImpl :
	public IVsBuildDependency,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildDependencyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBuildDependencyMockImpl)

	typedef IVsBuildDependency Interface;
	struct get_MustUpdateBeforeValidValues
	{
		/*[out]*/ BOOL* pfMustUpdateBefore;
		HRESULT retValue;
	};

	STDMETHOD(get_MustUpdateBefore)(
		/*[out]*/ BOOL* pfMustUpdateBefore)
	{
		VSL_DEFINE_MOCK_METHOD(get_MustUpdateBefore)

		VSL_SET_VALIDVALUE(pfMustUpdateBefore);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReferredProjectValidValues
	{
		/*[out]*/ IUnknown** ppIUnknownProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ReferredProject)(
		/*[out]*/ IUnknown** ppIUnknownProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReferredProject)

		VSL_SET_VALIDVALUE_INTERFACE(ppIUnknownProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out]*/ GUID* pguidType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* pguidType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pguidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpContextValidValues
	{
		/*[out]*/ DWORD* pdwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(get_HelpContext)(
		/*[out]*/ DWORD* pdwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(get_HelpContext)

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpFileValidValues
	{
		/*[out]*/ BSTR* pbstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(get_HelpFile)(
		/*[out]*/ BSTR* pbstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_HelpFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUILDDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBuildPropertyStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUILDPROPERTYSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUILDPROPERTYSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBuildPropertyStorageNotImpl :
	public IVsBuildPropertyStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildPropertyStorageNotImpl)

public:

	typedef IVsBuildPropertyStorage Interface;

	STDMETHOD(GetPropertyValue)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[in]*/ LPCOLESTR /*pszConfigName*/,
		/*[in]*/ PersistStorageType /*storage*/,
		/*[out,retval]*/ BSTR* /*pbstrPropValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPropertyValue)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[in]*/ LPCOLESTR /*pszConfigName*/,
		/*[in]*/ PersistStorageType /*storage*/,
		/*[in]*/ LPCOLESTR /*pszPropValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveProperty)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[in]*/ LPCOLESTR /*pszConfigName*/,
		/*[in]*/ PersistStorageType /*storage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemAttribute)(
		/*[in]*/ VSITEMID /*item*/,
		/*[in]*/ LPCOLESTR /*pszAttributeName*/,
		/*[out]*/ BSTR* /*pbstrAttributeValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetItemAttribute)(
		/*[in]*/ VSITEMID /*item*/,
		/*[in]*/ LPCOLESTR /*pszAttributeName*/,
		/*[in]*/ LPCOLESTR /*pszAttributeValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBuildPropertyStorageMockImpl :
	public IVsBuildPropertyStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildPropertyStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBuildPropertyStorageMockImpl)

	typedef IVsBuildPropertyStorage Interface;
	struct GetPropertyValueValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[in]*/ LPCOLESTR pszConfigName;
		/*[in]*/ PersistStorageType storage;
		/*[out,retval]*/ BSTR* pbstrPropValue;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyValue)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[in]*/ LPCOLESTR pszConfigName,
		/*[in]*/ PersistStorageType storage,
		/*[out,retval]*/ BSTR* pbstrPropValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyValue)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszConfigName);

		VSL_CHECK_VALIDVALUE(storage);

		VSL_SET_VALIDVALUE_BSTR(pbstrPropValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValueValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[in]*/ LPCOLESTR pszConfigName;
		/*[in]*/ PersistStorageType storage;
		/*[in]*/ LPCOLESTR pszPropValue;
		HRESULT retValue;
	};

	STDMETHOD(SetPropertyValue)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[in]*/ LPCOLESTR pszConfigName,
		/*[in]*/ PersistStorageType storage,
		/*[in]*/ LPCOLESTR pszPropValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetPropertyValue)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszConfigName);

		VSL_CHECK_VALIDVALUE(storage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePropertyValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[in]*/ LPCOLESTR pszConfigName;
		/*[in]*/ PersistStorageType storage;
		HRESULT retValue;
	};

	STDMETHOD(RemoveProperty)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[in]*/ LPCOLESTR pszConfigName,
		/*[in]*/ PersistStorageType storage)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveProperty)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszConfigName);

		VSL_CHECK_VALIDVALUE(storage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemAttributeValidValues
	{
		/*[in]*/ VSITEMID item;
		/*[in]*/ LPCOLESTR pszAttributeName;
		/*[out]*/ BSTR* pbstrAttributeValue;
		HRESULT retValue;
	};

	STDMETHOD(GetItemAttribute)(
		/*[in]*/ VSITEMID item,
		/*[in]*/ LPCOLESTR pszAttributeName,
		/*[out]*/ BSTR* pbstrAttributeValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemAttribute)

		VSL_CHECK_VALIDVALUE(item);

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttributeName);

		VSL_SET_VALIDVALUE_BSTR(pbstrAttributeValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetItemAttributeValidValues
	{
		/*[in]*/ VSITEMID item;
		/*[in]*/ LPCOLESTR pszAttributeName;
		/*[in]*/ LPCOLESTR pszAttributeValue;
		HRESULT retValue;
	};

	STDMETHOD(SetItemAttribute)(
		/*[in]*/ VSITEMID item,
		/*[in]*/ LPCOLESTR pszAttributeName,
		/*[in]*/ LPCOLESTR pszAttributeValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetItemAttribute)

		VSL_CHECK_VALIDVALUE(item);

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttributeName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttributeValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUILDPROPERTYSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBufferExtraFiles.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUFFEREXTRAFILES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUFFEREXTRAFILES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBufferExtraFilesNotImpl :
	public IVsBufferExtraFiles
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBufferExtraFilesNotImpl)

public:

	typedef IVsBufferExtraFiles Interface;

	STDMETHOD(GetQueryEditFilesDocuments)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[out]*/ BSTR* /*bstrMkDocuments*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBufferExtraFilesMockImpl :
	public IVsBufferExtraFiles,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBufferExtraFilesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBufferExtraFilesMockImpl)

	typedef IVsBufferExtraFiles Interface;
	struct GetQueryEditFilesDocumentsValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[out]*/ BSTR* bstrMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(GetQueryEditFilesDocuments)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[out]*/ BSTR* bstrMkDocuments)
	{
		VSL_DEFINE_MOCK_METHOD(GetQueryEditFilesDocuments)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE_BSTR(bstrMkDocuments);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUFFEREXTRAFILES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBrowseProjectLocation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBROWSEPROJECTLOCATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBROWSEPROJECTLOCATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBrowseProjectLocationNotImpl :
	public IVsBrowseProjectLocation
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseProjectLocationNotImpl)

public:

	typedef IVsBrowseProjectLocation Interface;

	STDMETHOD(BrowseProjectLocation)(
		/*[in]*/ LPCOLESTR /*pszStartDirectory*/,
		/*[out]*/ BSTR* /*pbstrProjectLocation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBrowseProjectLocationMockImpl :
	public IVsBrowseProjectLocation,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBrowseProjectLocationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBrowseProjectLocationMockImpl)

	typedef IVsBrowseProjectLocation Interface;
	struct BrowseProjectLocationValidValues
	{
		/*[in]*/ LPCOLESTR pszStartDirectory;
		/*[out]*/ BSTR* pbstrProjectLocation;
		HRESULT retValue;
	};

	STDMETHOD(BrowseProjectLocation)(
		/*[in]*/ LPCOLESTR pszStartDirectory,
		/*[out]*/ BSTR* pbstrProjectLocation)
	{
		VSL_DEFINE_MOCK_METHOD(BrowseProjectLocation)

		VSL_CHECK_VALIDVALUE_STRINGW(pszStartDirectory);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectLocation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBROWSEPROJECTLOCATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBuildableProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUILDABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUILDABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBuildableProjectCfgNotImpl :
	public IVsBuildableProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildableProjectCfgNotImpl)

public:

	typedef IVsBuildableProjectCfg Interface;

	STDMETHOD(get_ProjectCfg)(
		/*[out]*/ IVsProjectCfg** /*ppIVsProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseBuildStatusCallback)(
		/*[in]*/ IVsBuildStatusCallback* /*pIVsBuildStatusCallback*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseBuildStatusCallback)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartBuild)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartClean)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartUpToDateCheck)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatus)(
		/*[out]*/ BOOL* /*pfBuildDone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Stop)(
		/*[in]*/ BOOL /*fSync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Wait)(
		/*[in]*/ DWORD /*dwMilliseconds*/,
		/*[in]*/ BOOL /*fTickWhenMessageQNotEmpty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStartBuild)(
		/*[in]*/ DWORD /*dwOptions*/,
		/*[out,optional]*/ BOOL* /*pfSupported*/,
		/*[out,optional]*/ BOOL* /*pfReady*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStartClean)(
		/*[in]*/ DWORD /*dwOptions*/,
		/*[out,optional]*/ BOOL* /*pfSupported*/,
		/*[out,optional]*/ BOOL* /*pfReady*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStartUpToDateCheck)(
		/*[in]*/ DWORD /*dwOptions*/,
		/*[out,optional]*/ BOOL* /*pfSupported*/,
		/*[out,optional]*/ BOOL* /*pfReady*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBuildableProjectCfgMockImpl :
	public IVsBuildableProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildableProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBuildableProjectCfgMockImpl)

	typedef IVsBuildableProjectCfg Interface;
	struct get_ProjectCfgValidValues
	{
		/*[out]*/ IVsProjectCfg** ppIVsProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfg)(
		/*[out]*/ IVsProjectCfg** ppIVsProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseBuildStatusCallbackValidValues
	{
		/*[in]*/ IVsBuildStatusCallback* pIVsBuildStatusCallback;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseBuildStatusCallback)(
		/*[in]*/ IVsBuildStatusCallback* pIVsBuildStatusCallback,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseBuildStatusCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsBuildStatusCallback);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseBuildStatusCallbackValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseBuildStatusCallback)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseBuildStatusCallback)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartBuildValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartBuild)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartBuild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartCleanValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartClean)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartClean)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartUpToDateCheckValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartUpToDateCheck)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartUpToDateCheck)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusValidValues
	{
		/*[out]*/ BOOL* pfBuildDone;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatus)(
		/*[out]*/ BOOL* pfBuildDone)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatus)

		VSL_SET_VALIDVALUE(pfBuildDone);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopValidValues
	{
		/*[in]*/ BOOL fSync;
		HRESULT retValue;
	};

	STDMETHOD(Stop)(
		/*[in]*/ BOOL fSync)
	{
		VSL_DEFINE_MOCK_METHOD(Stop)

		VSL_CHECK_VALIDVALUE(fSync);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitValidValues
	{
		/*[in]*/ DWORD dwMilliseconds;
		/*[in]*/ BOOL fTickWhenMessageQNotEmpty;
		HRESULT retValue;
	};

	STDMETHOD(Wait)(
		/*[in]*/ DWORD dwMilliseconds,
		/*[in]*/ BOOL fTickWhenMessageQNotEmpty)
	{
		VSL_DEFINE_MOCK_METHOD(Wait)

		VSL_CHECK_VALIDVALUE(dwMilliseconds);

		VSL_CHECK_VALIDVALUE(fTickWhenMessageQNotEmpty);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStartBuildValidValues
	{
		/*[in]*/ DWORD dwOptions;
		/*[out,optional]*/ BOOL* pfSupported;
		/*[out,optional]*/ BOOL* pfReady;
		HRESULT retValue;
	};

	STDMETHOD(QueryStartBuild)(
		/*[in]*/ DWORD dwOptions,
		/*[out,optional]*/ BOOL* pfSupported,
		/*[out,optional]*/ BOOL* pfReady)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStartBuild)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_SET_VALIDVALUE(pfSupported);

		VSL_SET_VALIDVALUE(pfReady);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStartCleanValidValues
	{
		/*[in]*/ DWORD dwOptions;
		/*[out,optional]*/ BOOL* pfSupported;
		/*[out,optional]*/ BOOL* pfReady;
		HRESULT retValue;
	};

	STDMETHOD(QueryStartClean)(
		/*[in]*/ DWORD dwOptions,
		/*[out,optional]*/ BOOL* pfSupported,
		/*[out,optional]*/ BOOL* pfReady)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStartClean)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_SET_VALIDVALUE(pfSupported);

		VSL_SET_VALIDVALUE(pfReady);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStartUpToDateCheckValidValues
	{
		/*[in]*/ DWORD dwOptions;
		/*[out,optional]*/ BOOL* pfSupported;
		/*[out,optional]*/ BOOL* pfReady;
		HRESULT retValue;
	};

	STDMETHOD(QueryStartUpToDateCheck)(
		/*[in]*/ DWORD dwOptions,
		/*[out,optional]*/ BOOL* pfSupported,
		/*[out,optional]*/ BOOL* pfReady)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStartUpToDateCheck)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_SET_VALIDVALUE(pfSupported);

		VSL_SET_VALIDVALUE(pfReady);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUILDABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsBuildStatusCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUILDSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUILDSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsBuildStatusCallbackNotImpl :
	public IVsBuildStatusCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildStatusCallbackNotImpl)

public:

	typedef IVsBuildStatusCallback Interface;

	STDMETHOD(BuildBegin)(
		/*[in,out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BuildEnd)(
		/*[in]*/ BOOL /*fSuccess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Tick)(
		/*[in,out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsBuildStatusCallbackMockImpl :
	public IVsBuildStatusCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsBuildStatusCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsBuildStatusCallbackMockImpl)

	typedef IVsBuildStatusCallback Interface;
	struct BuildBeginValidValues
	{
		/*[in,out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(BuildBegin)(
		/*[in,out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(BuildBegin)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct BuildEndValidValues
	{
		/*[in]*/ BOOL fSuccess;
		HRESULT retValue;
	};

	STDMETHOD(BuildEnd)(
		/*[in]*/ BOOL fSuccess)
	{
		VSL_DEFINE_MOCK_METHOD(BuildEnd)

		VSL_CHECK_VALIDVALUE(fSuccess);

		VSL_RETURN_VALIDVALUES();
	}
	struct TickValidValues
	{
		/*[in,out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(Tick)(
		/*[in,out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(Tick)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUILDSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCanCoordinatorClipTextSpan.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCANCOORDINATORCLIPTEXTSPAN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCANCOORDINATORCLIPTEXTSPAN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCanCoordinatorClipTextSpanNotImpl :
	public IVsCanCoordinatorClipTextSpan
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCanCoordinatorClipTextSpanNotImpl)

public:

	typedef IVsCanCoordinatorClipTextSpan Interface;

	STDMETHOD(ShouldClipSpanToValidSpanInSecondaryBuffer)(
		/*[in]*/ const IVsTextLines* /*pPrimaryBuffer*/,
		/*[in]*/ const IVsTextLines* /*pSecondaryBuffer*/,
		/*[in]*/ const TextSpan* /*ptsTextSpanInPrimaryBuffer*/,
		/*[out]*/ BOOL* /*pfShouldClipTextSpan*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCanCoordinatorClipTextSpanMockImpl :
	public IVsCanCoordinatorClipTextSpan,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCanCoordinatorClipTextSpanMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCanCoordinatorClipTextSpanMockImpl)

	typedef IVsCanCoordinatorClipTextSpan Interface;
	struct ShouldClipSpanToValidSpanInSecondaryBufferValidValues
	{
		/*[in]*/ IVsTextLines* pPrimaryBuffer;
		/*[in]*/ IVsTextLines* pSecondaryBuffer;
		/*[in]*/ TextSpan* ptsTextSpanInPrimaryBuffer;
		/*[out]*/ BOOL* pfShouldClipTextSpan;
		HRESULT retValue;
	};

	STDMETHOD(ShouldClipSpanToValidSpanInSecondaryBuffer)(
		/*[in]*/ const IVsTextLines* pPrimaryBuffer,
		/*[in]*/ const IVsTextLines* pSecondaryBuffer,
		/*[in]*/ const TextSpan* ptsTextSpanInPrimaryBuffer,
		/*[out]*/ BOOL* pfShouldClipTextSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ShouldClipSpanToValidSpanInSecondaryBuffer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPrimaryBuffer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSecondaryBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsTextSpanInPrimaryBuffer);

		VSL_SET_VALIDVALUE(pfShouldClipTextSpan);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCANCOORDINATORCLIPTEXTSPAN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsButtonBarManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUTTONBARMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUTTONBARMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsButtonBarManagerNotImpl :
	public IVsButtonBarManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsButtonBarManagerNotImpl)

public:

	typedef IVsButtonBarManager Interface;

	STDMETHOD(AddButtonBar)(
		/*[in]*/ long /*cButtons*/,
		/*[in]*/ HANDLE /*hImageList*/,
		/*[in]*/ IVsButtonBarClient* /*pClient*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetButtonBar)(
		/*[out]*/ IVsButtonBar** /*ppButtonBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveButtonBar)()VSL_STDMETHOD_NOTIMPL
};

class IVsButtonBarManagerMockImpl :
	public IVsButtonBarManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsButtonBarManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsButtonBarManagerMockImpl)

	typedef IVsButtonBarManager Interface;
	struct AddButtonBarValidValues
	{
		/*[in]*/ long cButtons;
		/*[in]*/ HANDLE hImageList;
		/*[in]*/ IVsButtonBarClient* pClient;
		HRESULT retValue;
	};

	STDMETHOD(AddButtonBar)(
		/*[in]*/ long cButtons,
		/*[in]*/ HANDLE hImageList,
		/*[in]*/ IVsButtonBarClient* pClient)
	{
		VSL_DEFINE_MOCK_METHOD(AddButtonBar)

		VSL_CHECK_VALIDVALUE(cButtons);

		VSL_CHECK_VALIDVALUE(hImageList);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetButtonBarValidValues
	{
		/*[out]*/ IVsButtonBar** ppButtonBar;
		HRESULT retValue;
	};

	STDMETHOD(GetButtonBar)(
		/*[out]*/ IVsButtonBar** ppButtonBar)
	{
		VSL_DEFINE_MOCK_METHOD(GetButtonBar)

		VSL_SET_VALIDVALUE_INTERFACE(ppButtonBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveButtonBarValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveButtonBar)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveButtonBar)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUTTONBARMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCfgProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCfgProviderNotImpl :
	public IVsCfgProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProviderNotImpl)

public:

	typedef IVsCfgProvider Interface;

	STDMETHOD(GetCfgs)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsCfg*[] /*rgpcfg*/,
		/*[out,optional]*/ ULONG* /*pcActual*/,
		/*[out,optional]*/ VSCFGFLAGS* /*prgfFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCfgProviderMockImpl :
	public IVsCfgProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCfgProviderMockImpl)

	typedef IVsCfgProvider Interface;
	struct GetCfgsValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsCfg** rgpcfg;
		/*[out,optional]*/ ULONG* pcActual;
		/*[out,optional]*/ VSCFGFLAGS* prgfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgs)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsCfg* rgpcfg[],
		/*[out,optional]*/ ULONG* pcActual,
		/*[out,optional]*/ VSCFGFLAGS* prgfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgs)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpcfg, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_SET_VALIDVALUE(prgfFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsButtonBarClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSBUTTONBARCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSBUTTONBARCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsButtonBarClientNotImpl :
	public IVsButtonBarClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsButtonBarClientNotImpl)

public:

	typedef IVsButtonBarClient Interface;

	STDMETHOD(SetButtonBar)(
		/*[in]*/ IVsButtonBar* /*pButtonBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetButtonTipText)(
		/*[in]*/ long /*iButton*/,
		/*[out]*/ BSTR* /*pbstrTip*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnButtonPressed)(
		/*[in]*/ long /*iButton*/)VSL_STDMETHOD_NOTIMPL
};

class IVsButtonBarClientMockImpl :
	public IVsButtonBarClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsButtonBarClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsButtonBarClientMockImpl)

	typedef IVsButtonBarClient Interface;
	struct SetButtonBarValidValues
	{
		/*[in]*/ IVsButtonBar* pButtonBar;
		HRESULT retValue;
	};

	STDMETHOD(SetButtonBar)(
		/*[in]*/ IVsButtonBar* pButtonBar)
	{
		VSL_DEFINE_MOCK_METHOD(SetButtonBar)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pButtonBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetButtonTipTextValidValues
	{
		/*[in]*/ long iButton;
		/*[out]*/ BSTR* pbstrTip;
		HRESULT retValue;
	};

	STDMETHOD(GetButtonTipText)(
		/*[in]*/ long iButton,
		/*[out]*/ BSTR* pbstrTip)
	{
		VSL_DEFINE_MOCK_METHOD(GetButtonTipText)

		VSL_CHECK_VALIDVALUE(iButton);

		VSL_SET_VALIDVALUE_BSTR(pbstrTip);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnButtonPressedValidValues
	{
		/*[in]*/ long iButton;
		HRESULT retValue;
	};

	STDMETHOD(OnButtonPressed)(
		/*[in]*/ long iButton)
	{
		VSL_DEFINE_MOCK_METHOD(OnButtonPressed)

		VSL_CHECK_VALIDVALUE(iButton);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSBUTTONBARCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCfgBrowseObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCFGBROWSEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCFGBROWSEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCfgBrowseObjectNotImpl :
	public IVsCfgBrowseObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgBrowseObjectNotImpl)

public:

	typedef IVsCfgBrowseObject Interface;

	STDMETHOD(GetCfg)(
		/*[out]*/ IVsCfg** /*ppCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectItem)(
		/*[out]*/ IVsHierarchy** /*pHier*/,
		/*[out]*/ VSITEMID* /*pItemid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCfgBrowseObjectMockImpl :
	public IVsCfgBrowseObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgBrowseObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCfgBrowseObjectMockImpl)

	typedef IVsCfgBrowseObject Interface;
	struct GetCfgValidValues
	{
		/*[out]*/ IVsCfg** ppCfg;
		HRESULT retValue;
	};

	STDMETHOD(GetCfg)(
		/*[out]*/ IVsCfg** ppCfg)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectItemValidValues
	{
		/*[out]*/ IVsHierarchy** pHier;
		/*[out]*/ VSITEMID* pItemid;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectItem)(
		/*[out]*/ IVsHierarchy** pHier,
		/*[out]*/ VSITEMID* pItemid)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectItem)

		VSL_SET_VALIDVALUE_INTERFACE(pHier);

		VSL_SET_VALIDVALUE(pItemid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCFGBROWSEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCfgNotImpl :
	public IVsCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgNotImpl)

public:

	typedef IVsCfg Interface;

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* /*pfIsDebugOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* /*pfIsReleaseOnly*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCfgMockImpl :
	public IVsCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCfgMockImpl)

	typedef IVsCfg Interface;
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsDebugOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* pfIsDebugOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebugOnly)

		VSL_SET_VALIDVALUE(pfIsDebugOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReleaseOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsReleaseOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* pfIsReleaseOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReleaseOnly)

		VSL_SET_VALIDVALUE(pfIsReleaseOnly);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCallBrowser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCALLBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCALLBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCallBrowserNotImpl :
	public IVsCallBrowser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCallBrowserNotImpl)

public:

	typedef IVsCallBrowser Interface;

	STDMETHOD(SetRootAtSymbol)(
		/*[in]*/ CALLBROWSERMODE /*cbMode*/,
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRootAtNavInfo)(
		/*[in]*/ CALLBROWSERMODE /*cbMode*/,
		/*[in]*/ IVsNavInfo* /*pNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanCreateNewInstance)(
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCallBrowserMockImpl :
	public IVsCallBrowser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCallBrowserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCallBrowserMockImpl)

	typedef IVsCallBrowser Interface;
	struct SetRootAtSymbolValidValues
	{
		/*[in]*/ CALLBROWSERMODE cbMode;
		/*[in]*/ REFGUID guidLib;
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		HRESULT retValue;
	};

	STDMETHOD(SetRootAtSymbol)(
		/*[in]*/ CALLBROWSERMODE cbMode,
		/*[in]*/ REFGUID guidLib,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes)
	{
		VSL_DEFINE_MOCK_METHOD(SetRootAtSymbol)

		VSL_CHECK_VALIDVALUE(cbMode);

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRootAtNavInfoValidValues
	{
		/*[in]*/ CALLBROWSERMODE cbMode;
		/*[in]*/ IVsNavInfo* pNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(SetRootAtNavInfo)(
		/*[in]*/ CALLBROWSERMODE cbMode,
		/*[in]*/ IVsNavInfo* pNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(SetRootAtNavInfo)

		VSL_CHECK_VALIDVALUE(cbMode);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanCreateNewInstanceValidValues
	{
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanCreateNewInstance)(
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanCreateNewInstance)

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCALLBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCfgProvider2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCFGPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCFGPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCfgProvider2NotImpl :
	public IVsCfgProvider2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProvider2NotImpl)

public:

	typedef IVsCfgProvider2 Interface;

	STDMETHOD(GetCfgNames)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ BSTR[] /*rgbstr*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPlatformNames)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ BSTR[] /*rgbstr*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCfgOfName)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/,
		/*[in]*/ LPCOLESTR /*pszPlatformName*/,
		/*[out]*/ IVsCfg** /*ppCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddCfgsOfCfgName)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/,
		/*[in]*/ LPCOLESTR /*pszCloneCfgName*/,
		/*[in]*/ BOOL /*fPrivate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteCfgsOfCfgName)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameCfgsOfCfgName)(
		/*[in]*/ LPCOLESTR /*pszOldName*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddCfgsOfPlatformName)(
		/*[in]*/ LPCOLESTR /*pszPlatformName*/,
		/*[in]*/ LPCOLESTR /*pszClonePlatformName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteCfgsOfPlatformName)(
		/*[in]*/ LPCOLESTR /*pszPlatformName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSupportedPlatformNames)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ BSTR[] /*rgbstr*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCfgProviderProperty)(
		/*[in]*/ VSCFGPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseCfgProviderEvents)(
		/*[in]*/ IVsCfgProviderEvents* /*pCPE*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseCfgProviderEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCfgs)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsCfg*[] /*rgpcfg*/,
		/*[out,optional]*/ ULONG* /*pcActual*/,
		/*[out,optional]*/ VSCFGFLAGS* /*prgfFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCfgProvider2MockImpl :
	public IVsCfgProvider2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProvider2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCfgProvider2MockImpl)

	typedef IVsCfgProvider2 Interface;
	struct GetCfgNamesValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ BSTR* rgbstr;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgNames)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ BSTR rgbstr[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgNames)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstr, celt*sizeof(rgbstr[0]), validValues.celt*sizeof(validValues.rgbstr[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPlatformNamesValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ BSTR* rgbstr;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetPlatformNames)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ BSTR rgbstr[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetPlatformNames)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstr, celt*sizeof(rgbstr[0]), validValues.celt*sizeof(validValues.rgbstr[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCfgOfNameValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		/*[in]*/ LPCOLESTR pszPlatformName;
		/*[out]*/ IVsCfg** ppCfg;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgOfName)(
		/*[in]*/ LPCOLESTR pszCfgName,
		/*[in]*/ LPCOLESTR pszPlatformName,
		/*[out]*/ IVsCfg** ppCfg)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgOfName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_SET_VALIDVALUE_INTERFACE(ppCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddCfgsOfCfgNameValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		/*[in]*/ LPCOLESTR pszCloneCfgName;
		/*[in]*/ BOOL fPrivate;
		HRESULT retValue;
	};

	STDMETHOD(AddCfgsOfCfgName)(
		/*[in]*/ LPCOLESTR pszCfgName,
		/*[in]*/ LPCOLESTR pszCloneCfgName,
		/*[in]*/ BOOL fPrivate)
	{
		VSL_DEFINE_MOCK_METHOD(AddCfgsOfCfgName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCloneCfgName);

		VSL_CHECK_VALIDVALUE(fPrivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteCfgsOfCfgNameValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		HRESULT retValue;
	};

	STDMETHOD(DeleteCfgsOfCfgName)(
		/*[in]*/ LPCOLESTR pszCfgName)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteCfgsOfCfgName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameCfgsOfCfgNameValidValues
	{
		/*[in]*/ LPCOLESTR pszOldName;
		/*[in]*/ LPCOLESTR pszNewName;
		HRESULT retValue;
	};

	STDMETHOD(RenameCfgsOfCfgName)(
		/*[in]*/ LPCOLESTR pszOldName,
		/*[in]*/ LPCOLESTR pszNewName)
	{
		VSL_DEFINE_MOCK_METHOD(RenameCfgsOfCfgName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddCfgsOfPlatformNameValidValues
	{
		/*[in]*/ LPCOLESTR pszPlatformName;
		/*[in]*/ LPCOLESTR pszClonePlatformName;
		HRESULT retValue;
	};

	STDMETHOD(AddCfgsOfPlatformName)(
		/*[in]*/ LPCOLESTR pszPlatformName,
		/*[in]*/ LPCOLESTR pszClonePlatformName)
	{
		VSL_DEFINE_MOCK_METHOD(AddCfgsOfPlatformName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszClonePlatformName);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteCfgsOfPlatformNameValidValues
	{
		/*[in]*/ LPCOLESTR pszPlatformName;
		HRESULT retValue;
	};

	STDMETHOD(DeleteCfgsOfPlatformName)(
		/*[in]*/ LPCOLESTR pszPlatformName)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteCfgsOfPlatformName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSupportedPlatformNamesValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ BSTR* rgbstr;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedPlatformNames)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ BSTR rgbstr[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedPlatformNames)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstr, celt*sizeof(rgbstr[0]), validValues.celt*sizeof(validValues.rgbstr[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCfgProviderPropertyValidValues
	{
		/*[in]*/ VSCFGPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgProviderProperty)(
		/*[in]*/ VSCFGPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgProviderProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseCfgProviderEventsValidValues
	{
		/*[in]*/ IVsCfgProviderEvents* pCPE;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseCfgProviderEvents)(
		/*[in]*/ IVsCfgProviderEvents* pCPE,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseCfgProviderEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCPE);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseCfgProviderEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseCfgProviderEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseCfgProviderEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCfgsValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsCfg** rgpcfg;
		/*[out,optional]*/ ULONG* pcActual;
		/*[out,optional]*/ VSCFGFLAGS* prgfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgs)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsCfg* rgpcfg[],
		/*[out,optional]*/ ULONG* pcActual,
		/*[out,optional]*/ VSCFGFLAGS* prgfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgs)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpcfg, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_SET_VALIDVALUE(prgfFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCFGPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeDefViewContext.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEDEFVIEWCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEDEFVIEWCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeDefViewContextNotImpl :
	public IVsCodeDefViewContext
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeDefViewContextNotImpl)

public:

	typedef IVsCodeDefViewContext Interface;

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSymbolName)(
		/*[in]*/ ULONG /*iItem*/,
		/*[out]*/ BSTR* /*pbstrSymbolName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFileName)(
		/*[in]*/ ULONG /*iItem*/,
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLine)(
		/*[in]*/ ULONG /*iItem*/,
		/*[out]*/ ULONG* /*piLine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCol)(
		/*[in]*/ ULONG /*iItem*/,
		/*[out]*/ ULONG* /*piCol*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodeDefViewContextMockImpl :
	public IVsCodeDefViewContext,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeDefViewContextMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeDefViewContextMockImpl)

	typedef IVsCodeDefViewContext Interface;
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcItems;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcItems)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSymbolNameValidValues
	{
		/*[in]*/ ULONG iItem;
		/*[out]*/ BSTR* pbstrSymbolName;
		HRESULT retValue;
	};

	STDMETHOD(GetSymbolName)(
		/*[in]*/ ULONG iItem,
		/*[out]*/ BSTR* pbstrSymbolName)
	{
		VSL_DEFINE_MOCK_METHOD(GetSymbolName)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE_BSTR(pbstrSymbolName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFileNameValidValues
	{
		/*[in]*/ ULONG iItem;
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetFileName)(
		/*[in]*/ ULONG iItem,
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetFileName)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineValidValues
	{
		/*[in]*/ ULONG iItem;
		/*[out]*/ ULONG* piLine;
		HRESULT retValue;
	};

	STDMETHOD(GetLine)(
		/*[in]*/ ULONG iItem,
		/*[out]*/ ULONG* piLine)
	{
		VSL_DEFINE_MOCK_METHOD(GetLine)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE(piLine);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColValidValues
	{
		/*[in]*/ ULONG iItem;
		/*[out]*/ ULONG* piCol;
		HRESULT retValue;
	};

	STDMETHOD(GetCol)(
		/*[in]*/ ULONG iItem,
		/*[out]*/ ULONG* piCol)
	{
		VSL_DEFINE_MOCK_METHOD(GetCol)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE(piCol);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEDEFVIEWCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCfgProviderEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCFGPROVIDEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCFGPROVIDEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCfgProviderEventsNotImpl :
	public IVsCfgProviderEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProviderEventsNotImpl)

public:

	typedef IVsCfgProviderEvents Interface;

	STDMETHOD(OnCfgNameAdded)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCfgNameDeleted)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCfgNameRenamed)(
		/*[in]*/ LPCOLESTR /*pszOldName*/,
		/*[in]*/ LPCOLESTR /*lszNewName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPlatformNameAdded)(
		/*[in]*/ LPCOLESTR /*pszPlatformName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPlatformNameDeleted)(
		/*[in]*/ LPCOLESTR /*pszPlatformName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCfgProviderEventsMockImpl :
	public IVsCfgProviderEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProviderEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCfgProviderEventsMockImpl)

	typedef IVsCfgProviderEvents Interface;
	struct OnCfgNameAddedValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		HRESULT retValue;
	};

	STDMETHOD(OnCfgNameAdded)(
		/*[in]*/ LPCOLESTR pszCfgName)
	{
		VSL_DEFINE_MOCK_METHOD(OnCfgNameAdded)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCfgNameDeletedValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		HRESULT retValue;
	};

	STDMETHOD(OnCfgNameDeleted)(
		/*[in]*/ LPCOLESTR pszCfgName)
	{
		VSL_DEFINE_MOCK_METHOD(OnCfgNameDeleted)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCfgNameRenamedValidValues
	{
		/*[in]*/ LPCOLESTR pszOldName;
		/*[in]*/ LPCOLESTR lszNewName;
		HRESULT retValue;
	};

	STDMETHOD(OnCfgNameRenamed)(
		/*[in]*/ LPCOLESTR pszOldName,
		/*[in]*/ LPCOLESTR lszNewName)
	{
		VSL_DEFINE_MOCK_METHOD(OnCfgNameRenamed)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(lszNewName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPlatformNameAddedValidValues
	{
		/*[in]*/ LPCOLESTR pszPlatformName;
		HRESULT retValue;
	};

	STDMETHOD(OnPlatformNameAdded)(
		/*[in]*/ LPCOLESTR pszPlatformName)
	{
		VSL_DEFINE_MOCK_METHOD(OnPlatformNameAdded)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPlatformNameDeletedValidValues
	{
		/*[in]*/ LPCOLESTR pszPlatformName;
		HRESULT retValue;
	};

	STDMETHOD(OnPlatformNameDeleted)(
		/*[in]*/ LPCOLESTR pszPlatformName)
	{
		VSL_DEFINE_MOCK_METHOD(OnPlatformNameDeleted)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCFGPROVIDEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsChangeTrackingUndoManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCHANGETRACKINGUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCHANGETRACKINGUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsChangeTrackingUndoManagerNotImpl :
	public IVsChangeTrackingUndoManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsChangeTrackingUndoManagerNotImpl)

public:

	typedef IVsChangeTrackingUndoManager Interface;

	STDMETHOD(MarkCleanState)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryCleanState)(
		/*[out]*/ BOOL* /*pfClean*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseTrackingClient)(
		/*[in]*/ IVsUndoTrackingEvents* /*pUndoTrackingEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseTrackingClient)()VSL_STDMETHOD_NOTIMPL
};

class IVsChangeTrackingUndoManagerMockImpl :
	public IVsChangeTrackingUndoManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsChangeTrackingUndoManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsChangeTrackingUndoManagerMockImpl)

	typedef IVsChangeTrackingUndoManager Interface;
	struct MarkCleanStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(MarkCleanState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(MarkCleanState)

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCleanStateValidValues
	{
		/*[out]*/ BOOL* pfClean;
		HRESULT retValue;
	};

	STDMETHOD(QueryCleanState)(
		/*[out]*/ BOOL* pfClean)
	{
		VSL_DEFINE_MOCK_METHOD(QueryCleanState)

		VSL_SET_VALIDVALUE(pfClean);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseTrackingClientValidValues
	{
		/*[in]*/ IVsUndoTrackingEvents* pUndoTrackingEvents;
		HRESULT retValue;
	};

	STDMETHOD(AdviseTrackingClient)(
		/*[in]*/ IVsUndoTrackingEvents* pUndoTrackingEvents)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseTrackingClient)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUndoTrackingEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseTrackingClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseTrackingClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseTrackingClient)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCHANGETRACKINGUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCmdNameMapping.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCMDNAMEMAPPING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCMDNAMEMAPPING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCmdNameMappingNotImpl :
	public IVsCmdNameMapping
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCmdNameMappingNotImpl)

public:

	typedef IVsCmdNameMapping Interface;

	STDMETHOD(MapGUIDIDToName)(
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*dwCmdID*/,
		/*[in]*/ VSCMDNAMEOPTS /*grfOptions*/,
		/*[out]*/ BSTR* /*pbstrCmdName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapNameToGUIDID)(
		/*[in]*/ const LPCOLESTR /*pszCmdName*/,
		/*[out]*/ GUID* /*pguidCmdGroup*/,
		/*[out]*/ DWORD* /*pdwCmdID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumNames)(
		/*[in]*/ VSCMDNAMEOPTS /*grfOptions*/,
		/*[out,retval]*/ IEnumString** /*ppEnumString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastUpdated)(
		/*[out,retval]*/ DWORD* /*pdwTickCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumMacroNames)(
		/*[in]*/ VSCMDNAMEOPTS /*grfOptions*/,
		/*[out,retval]*/ IEnumString** /*ppEnumString*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCmdNameMappingMockImpl :
	public IVsCmdNameMapping,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCmdNameMappingMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCmdNameMappingMockImpl)

	typedef IVsCmdNameMapping Interface;
	struct MapGUIDIDToNameValidValues
	{
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD dwCmdID;
		/*[in]*/ VSCMDNAMEOPTS grfOptions;
		/*[out]*/ BSTR* pbstrCmdName;
		HRESULT retValue;
	};

	STDMETHOD(MapGUIDIDToName)(
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD dwCmdID,
		/*[in]*/ VSCMDNAMEOPTS grfOptions,
		/*[out]*/ BSTR* pbstrCmdName)
	{
		VSL_DEFINE_MOCK_METHOD(MapGUIDIDToName)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(dwCmdID);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_SET_VALIDVALUE_BSTR(pbstrCmdName);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapNameToGUIDIDValidValues
	{
		/*[in]*/ LPCOLESTR pszCmdName;
		/*[out]*/ GUID* pguidCmdGroup;
		/*[out]*/ DWORD* pdwCmdID;
		HRESULT retValue;
	};

	STDMETHOD(MapNameToGUIDID)(
		/*[in]*/ const LPCOLESTR pszCmdName,
		/*[out]*/ GUID* pguidCmdGroup,
		/*[out]*/ DWORD* pdwCmdID)
	{
		VSL_DEFINE_MOCK_METHOD(MapNameToGUIDID)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdName);

		VSL_SET_VALIDVALUE(pguidCmdGroup);

		VSL_SET_VALIDVALUE(pdwCmdID);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumNamesValidValues
	{
		/*[in]*/ VSCMDNAMEOPTS grfOptions;
		/*[out,retval]*/ IEnumString** ppEnumString;
		HRESULT retValue;
	};

	STDMETHOD(EnumNames)(
		/*[in]*/ VSCMDNAMEOPTS grfOptions,
		/*[out,retval]*/ IEnumString** ppEnumString)
	{
		VSL_DEFINE_MOCK_METHOD(EnumNames)

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumString);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastUpdatedValidValues
	{
		/*[out,retval]*/ DWORD* pdwTickCount;
		HRESULT retValue;
	};

	STDMETHOD(GetLastUpdated)(
		/*[out,retval]*/ DWORD* pdwTickCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastUpdated)

		VSL_SET_VALIDVALUE(pdwTickCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumMacroNamesValidValues
	{
		/*[in]*/ VSCMDNAMEOPTS grfOptions;
		/*[out,retval]*/ IEnumString** ppEnumString;
		HRESULT retValue;
	};

	STDMETHOD(EnumMacroNames)(
		/*[in]*/ VSCMDNAMEOPTS grfOptions,
		/*[out,retval]*/ IEnumString** ppEnumString)
	{
		VSL_DEFINE_MOCK_METHOD(EnumMacroNames)

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumString);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCMDNAMEMAPPING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodePageSelection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEPAGESELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEPAGESELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodePageSelectionNotImpl :
	public IVsCodePageSelection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodePageSelectionNotImpl)

public:

	typedef IVsCodePageSelection Interface;

	STDMETHOD(ShowEncodingDialog)(
		/*[in]*/ LPCOLESTR /*pszFileName*/,
		/*[in]*/ IVsUserData* /*pUserData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodePageSelectionMockImpl :
	public IVsCodePageSelection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodePageSelectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodePageSelectionMockImpl)

	typedef IVsCodePageSelection Interface;
	struct ShowEncodingDialogValidValues
	{
		/*[in]*/ LPCOLESTR pszFileName;
		/*[in]*/ IVsUserData* pUserData;
		HRESULT retValue;
	};

	STDMETHOD(ShowEncodingDialog)(
		/*[in]*/ LPCOLESTR pszFileName,
		/*[in]*/ IVsUserData* pUserData)
	{
		VSL_DEFINE_MOCK_METHOD(ShowEncodingDialog)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUserData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEPAGESELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCfgProviderEventsHelper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCFGPROVIDEREVENTSHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCFGPROVIDEREVENTSHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCfgProviderEventsHelperNotImpl :
	public IVsCfgProviderEventsHelper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProviderEventsHelperNotImpl)

public:

	typedef IVsCfgProviderEventsHelper Interface;

	STDMETHOD(AdviseCfgProviderEvents)(
		/*[in]*/ IVsCfgProviderEvents* /*pCPE*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseCfgProviderEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnCfgNameAdded)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnCfgNameDeleted)(
		/*[in]*/ LPCOLESTR /*pszCfgName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnCfgNameRenamed)(
		/*[in]*/ LPCOLESTR /*pszOldName*/,
		/*[in]*/ LPCOLESTR /*lszNewName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnPlatformNameAdded)(
		/*[in]*/ LPCOLESTR /*pszPlatformName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnPlatformNameDeleted)(
		/*[in]*/ LPCOLESTR /*pszPlatformName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCfgProviderEventsHelperMockImpl :
	public IVsCfgProviderEventsHelper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCfgProviderEventsHelperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCfgProviderEventsHelperMockImpl)

	typedef IVsCfgProviderEventsHelper Interface;
	struct AdviseCfgProviderEventsValidValues
	{
		/*[in]*/ IVsCfgProviderEvents* pCPE;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseCfgProviderEvents)(
		/*[in]*/ IVsCfgProviderEvents* pCPE,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseCfgProviderEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCPE);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseCfgProviderEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseCfgProviderEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseCfgProviderEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnCfgNameAddedValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnCfgNameAdded)(
		/*[in]*/ LPCOLESTR pszCfgName)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnCfgNameAdded)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnCfgNameDeletedValidValues
	{
		/*[in]*/ LPCOLESTR pszCfgName;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnCfgNameDeleted)(
		/*[in]*/ LPCOLESTR pszCfgName)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnCfgNameDeleted)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCfgName);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnCfgNameRenamedValidValues
	{
		/*[in]*/ LPCOLESTR pszOldName;
		/*[in]*/ LPCOLESTR lszNewName;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnCfgNameRenamed)(
		/*[in]*/ LPCOLESTR pszOldName,
		/*[in]*/ LPCOLESTR lszNewName)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnCfgNameRenamed)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(lszNewName);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnPlatformNameAddedValidValues
	{
		/*[in]*/ LPCOLESTR pszPlatformName;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnPlatformNameAdded)(
		/*[in]*/ LPCOLESTR pszPlatformName)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnPlatformNameAdded)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnPlatformNameDeletedValidValues
	{
		/*[in]*/ LPCOLESTR pszPlatformName;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnPlatformNameDeleted)(
		/*[in]*/ LPCOLESTR pszPlatformName)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnPlatformNameDeleted)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPlatformName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCFGPROVIDEREVENTSHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeDefView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEDEFVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEDEFVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeDefViewNotImpl :
	public IVsCodeDefView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeDefViewNotImpl)

public:

	typedef IVsCodeDefView Interface;

	STDMETHOD(ShowWindow)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HideWindow)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsVisible)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContext)(
		/*[in]*/ IVsCodeDefViewContext* /*pIVsCodeDefViewContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRefreshDelay)(
		/*[out]*/ ULONG* /*pcMilliseconds*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ForceIdleProcessing)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCodeDefView)(
		/*[in]*/ IVsTextView* /*pIVsTextView*/,
		/*[out]*/ BOOL* /*pfIsCodeDefView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodeDefViewMockImpl :
	public IVsCodeDefView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeDefViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeDefViewMockImpl)

	typedef IVsCodeDefView Interface;
	struct ShowWindowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowWindow)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowWindow)

		VSL_RETURN_VALIDVALUES();
	}
	struct HideWindowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HideWindow)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HideWindow)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsVisibleValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsVisible)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsVisible)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContextValidValues
	{
		/*[in]*/ IVsCodeDefViewContext* pIVsCodeDefViewContext;
		HRESULT retValue;
	};

	STDMETHOD(SetContext)(
		/*[in]*/ IVsCodeDefViewContext* pIVsCodeDefViewContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetContext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsCodeDefViewContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRefreshDelayValidValues
	{
		/*[out]*/ ULONG* pcMilliseconds;
		HRESULT retValue;
	};

	STDMETHOD(GetRefreshDelay)(
		/*[out]*/ ULONG* pcMilliseconds)
	{
		VSL_DEFINE_MOCK_METHOD(GetRefreshDelay)

		VSL_SET_VALIDVALUE(pcMilliseconds);

		VSL_RETURN_VALIDVALUES();
	}
	struct ForceIdleProcessingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ForceIdleProcessing)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ForceIdleProcessing)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCodeDefViewValidValues
	{
		/*[in]*/ IVsTextView* pIVsTextView;
		/*[out]*/ BOOL* pfIsCodeDefView;
		HRESULT retValue;
	};

	STDMETHOD(IsCodeDefView)(
		/*[in]*/ IVsTextView* pIVsTextView,
		/*[out]*/ BOOL* pfIsCodeDefView)
	{
		VSL_DEFINE_MOCK_METHOD(IsCodeDefView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsTextView);

		VSL_SET_VALIDVALUE(pfIsCodeDefView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEDEFVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsClassView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCLASSVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCLASSVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsClassViewNotImpl :
	public IVsClassView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsClassViewNotImpl)

public:

	typedef IVsClassView Interface;

	STDMETHOD(NavigateTo)(
		/*[in]*/ const VSOBJECTINFO* /*pObjInfo*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsClassViewMockImpl :
	public IVsClassView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsClassViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsClassViewMockImpl)

	typedef IVsClassView Interface;
	struct NavigateToValidValues
	{
		/*[in]*/ VSOBJECTINFO* pObjInfo;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo)(
		/*[in]*/ const VSOBJECTINFO* pObjInfo,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateTo)

		VSL_CHECK_VALIDVALUE_POINTER(pObjInfo);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCLASSVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsColorableItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOLORABLEITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOLORABLEITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsColorableItemNotImpl :
	public IVsColorableItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsColorableItemNotImpl)

public:

	typedef IVsColorableItem Interface;

	STDMETHOD(GetDefaultColors)(
		/*[out]*/ COLORINDEX* /*piForeground*/,
		/*[out]*/ COLORINDEX* /*piBackground*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultFontFlags)(
		/*[out]*/ DWORD* /*pdwFontFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsColorableItemMockImpl :
	public IVsColorableItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsColorableItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsColorableItemMockImpl)

	typedef IVsColorableItem Interface;
	struct GetDefaultColorsValidValues
	{
		/*[out]*/ COLORINDEX* piForeground;
		/*[out]*/ COLORINDEX* piBackground;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultColors)(
		/*[out]*/ COLORINDEX* piForeground,
		/*[out]*/ COLORINDEX* piBackground)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultColors)

		VSL_SET_VALIDVALUE(piForeground);

		VSL_SET_VALIDVALUE(piBackground);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultFontFlagsValidValues
	{
		/*[out]*/ DWORD* pdwFontFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultFontFlags)(
		/*[out]*/ DWORD* pdwFontFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultFontFlags)

		VSL_SET_VALIDVALUE(pdwFontFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOLORABLEITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsColorizer2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOLORIZER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOLORIZER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsColorizer2NotImpl :
	public IVsColorizer2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsColorizer2NotImpl)

public:

	typedef IVsColorizer2 Interface;

	STDMETHOD(BeginColorization)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndColorization)()VSL_STDMETHOD_NOTIMPL
};

class IVsColorizer2MockImpl :
	public IVsColorizer2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsColorizer2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsColorizer2MockImpl)

	typedef IVsColorizer2 Interface;
	struct BeginColorizationValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginColorization)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginColorization)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndColorizationValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndColorization)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndColorization)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOLORIZER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeShareHandler.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODESHAREHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODESHAREHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeShareHandlerNotImpl :
	public IVsCodeShareHandler
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeShareHandlerNotImpl)

public:

	typedef IVsCodeShareHandler Interface;

	STDMETHOD(DlgInit)(
		/*[in]*/ HWND /*hwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VBDialogBoxParam)(
		/*[in]*/ HINSTANCE /*hinst*/,
		/*[in]*/ DWORD /*dwId*/,
		/*[in]*/ DWORD* /*pFARPROC*/,
		/*[in]*/ LPARAM /*lp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VBDialogCover)(
		/*[in]*/ DWORD* /*pFARPROC*/,
		/*[in]*/ DWORD* /*lpvoid*/,
		/*[out]*/ HWND* /*lphwndParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VsGetOpenFileName)(
		/*[in]*/ DWORD* /*pOPENFILENAMEA*/,
		/*[in]*/ LONG /*dwHelpTopic*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStdHelp)(
		/*[in]*/ UINT /*wCmd*/,
		/*[in]*/ LONG /*lContext*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodeShareHandlerMockImpl :
	public IVsCodeShareHandler,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeShareHandlerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeShareHandlerMockImpl)

	typedef IVsCodeShareHandler Interface;
	struct DlgInitValidValues
	{
		/*[in]*/ HWND hwnd;
		HRESULT retValue;
	};

	STDMETHOD(DlgInit)(
		/*[in]*/ HWND hwnd)
	{
		VSL_DEFINE_MOCK_METHOD(DlgInit)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct VBDialogBoxParamValidValues
	{
		/*[in]*/ HINSTANCE hinst;
		/*[in]*/ DWORD dwId;
		/*[in]*/ DWORD* pFARPROC;
		/*[in]*/ LPARAM lp;
		HRESULT retValue;
	};

	STDMETHOD(VBDialogBoxParam)(
		/*[in]*/ HINSTANCE hinst,
		/*[in]*/ DWORD dwId,
		/*[in]*/ DWORD* pFARPROC,
		/*[in]*/ LPARAM lp)
	{
		VSL_DEFINE_MOCK_METHOD(VBDialogBoxParam)

		VSL_CHECK_VALIDVALUE(hinst);

		VSL_CHECK_VALIDVALUE(dwId);

		VSL_CHECK_VALIDVALUE_POINTER(pFARPROC);

		VSL_CHECK_VALIDVALUE(lp);

		VSL_RETURN_VALIDVALUES();
	}
	struct VBDialogCoverValidValues
	{
		/*[in]*/ DWORD* pFARPROC;
		/*[in]*/ DWORD* lpvoid;
		/*[out]*/ HWND* lphwndParent;
		HRESULT retValue;
	};

	STDMETHOD(VBDialogCover)(
		/*[in]*/ DWORD* pFARPROC,
		/*[in]*/ DWORD* lpvoid,
		/*[out]*/ HWND* lphwndParent)
	{
		VSL_DEFINE_MOCK_METHOD(VBDialogCover)

		VSL_CHECK_VALIDVALUE_POINTER(pFARPROC);

		VSL_CHECK_VALIDVALUE_POINTER(lpvoid);

		VSL_SET_VALIDVALUE(lphwndParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct VsGetOpenFileNameValidValues
	{
		/*[in]*/ DWORD* pOPENFILENAMEA;
		/*[in]*/ LONG dwHelpTopic;
		HRESULT retValue;
	};

	STDMETHOD(VsGetOpenFileName)(
		/*[in]*/ DWORD* pOPENFILENAMEA,
		/*[in]*/ LONG dwHelpTopic)
	{
		VSL_DEFINE_MOCK_METHOD(VsGetOpenFileName)

		VSL_CHECK_VALIDVALUE_POINTER(pOPENFILENAMEA);

		VSL_CHECK_VALIDVALUE(dwHelpTopic);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStdHelpValidValues
	{
		/*[in]*/ UINT wCmd;
		/*[in]*/ LONG lContext;
		HRESULT retValue;
	};

	STDMETHOD(GetStdHelp)(
		/*[in]*/ UINT wCmd,
		/*[in]*/ LONG lContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetStdHelp)

		VSL_CHECK_VALIDVALUE(wCmd);

		VSL_CHECK_VALIDVALUE(lContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODESHAREHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeWindowEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEWINDOWEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEWINDOWEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeWindowEventsNotImpl :
	public IVsCodeWindowEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowEventsNotImpl)

public:

	typedef IVsCodeWindowEvents Interface;

	STDMETHOD(OnNewView)(
		/*[in]*/ IVsTextView* /*pView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCloseView)(
		/*[in]*/ IVsTextView* /*pView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodeWindowEventsMockImpl :
	public IVsCodeWindowEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeWindowEventsMockImpl)

	typedef IVsCodeWindowEvents Interface;
	struct OnNewViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		HRESULT retValue;
	};

	STDMETHOD(OnNewView)(
		/*[in]*/ IVsTextView* pView)
	{
		VSL_DEFINE_MOCK_METHOD(OnNewView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		HRESULT retValue;
	};

	STDMETHOD(OnCloseView)(
		/*[in]*/ IVsTextView* pView)
	{
		VSL_DEFINE_MOCK_METHOD(OnCloseView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEWINDOWEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeWindowEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEWINDOWEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEWINDOWEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeWindowExNotImpl :
	public IVsCodeWindowEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowExNotImpl)

public:

	typedef IVsCodeWindowEx Interface;

	STDMETHOD(Initialize)(
		/*[in]*/ CODEWINDOWBEHAVIORFLAGS /*grfCodeWindowBehaviorFlags*/,
		/*[in]*/ VSUSERCONTEXTATTRIBUTEUSAGE /*usageAuxUserContext*/,
		/*[in]*/ LPCOLESTR /*szNameAuxUserContext*/,
		/*[in]*/ LPCOLESTR /*szValueAuxUserContext*/,
		/*[in]*/ DWORD /*InitViewFlags*/,
		/*[in]*/ const INITVIEW* /*pInitView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsReadOnly)()VSL_STDMETHOD_NOTIMPL
};

class IVsCodeWindowExMockImpl :
	public IVsCodeWindowEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeWindowExMockImpl)

	typedef IVsCodeWindowEx Interface;
	struct InitializeValidValues
	{
		/*[in]*/ CODEWINDOWBEHAVIORFLAGS grfCodeWindowBehaviorFlags;
		/*[in]*/ VSUSERCONTEXTATTRIBUTEUSAGE usageAuxUserContext;
		/*[in]*/ LPCOLESTR szNameAuxUserContext;
		/*[in]*/ LPCOLESTR szValueAuxUserContext;
		/*[in]*/ DWORD InitViewFlags;
		/*[in]*/ INITVIEW* pInitView;
		HRESULT retValue;
	};

	STDMETHOD(Initialize)(
		/*[in]*/ CODEWINDOWBEHAVIORFLAGS grfCodeWindowBehaviorFlags,
		/*[in]*/ VSUSERCONTEXTATTRIBUTEUSAGE usageAuxUserContext,
		/*[in]*/ LPCOLESTR szNameAuxUserContext,
		/*[in]*/ LPCOLESTR szValueAuxUserContext,
		/*[in]*/ DWORD InitViewFlags,
		/*[in]*/ const INITVIEW* pInitView)
	{
		VSL_DEFINE_MOCK_METHOD(Initialize)

		VSL_CHECK_VALIDVALUE(grfCodeWindowBehaviorFlags);

		VSL_CHECK_VALIDVALUE(usageAuxUserContext);

		VSL_CHECK_VALIDVALUE_STRINGW(szNameAuxUserContext);

		VSL_CHECK_VALIDVALUE_STRINGW(szValueAuxUserContext);

		VSL_CHECK_VALIDVALUE(InitViewFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pInitView);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsReadOnlyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsReadOnly)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsReadOnly)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEWINDOWEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeWindowNotImpl :
	public IVsCodeWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowNotImpl)

public:

	typedef IVsCodeWindow Interface;

	STDMETHOD(SetBuffer)(
		/*[in]*/ IVsTextLines* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuffer)(
		/*[out]*/ IVsTextLines** /*ppBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPrimaryView)(
		/*[out]*/ IVsTextView** /*ppView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSecondaryView)(
		/*[out]*/ IVsTextView** /*ppView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetViewClassID)(
		/*[in]*/ REFCLSID /*clsidView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetViewClassID)(
		/*[out]*/ CLSID* /*pclsidView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBaseEditorCaption)(
		/*[in]*/ LPCOLESTR* /*pszBaseEditorCaption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEditorCaption)(
		/*[in]*/ READONLYSTATUS /*dwReadOnly*/,
		/*[out]*/ BSTR* /*pbstrEditorCaption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastActiveView)(
		/*[out]*/ IVsTextView** /*ppView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodeWindowMockImpl :
	public IVsCodeWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeWindowMockImpl)

	typedef IVsCodeWindow Interface;
	struct SetBufferValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(SetBuffer)(
		/*[in]*/ IVsTextLines* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(SetBuffer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetBuffer)(
		/*[out]*/ IVsTextLines** ppBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPrimaryViewValidValues
	{
		/*[out]*/ IVsTextView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(GetPrimaryView)(
		/*[out]*/ IVsTextView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(GetPrimaryView)

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSecondaryViewValidValues
	{
		/*[out]*/ IVsTextView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(GetSecondaryView)(
		/*[out]*/ IVsTextView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(GetSecondaryView)

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetViewClassIDValidValues
	{
		/*[in]*/ REFCLSID clsidView;
		HRESULT retValue;
	};

	STDMETHOD(SetViewClassID)(
		/*[in]*/ REFCLSID clsidView)
	{
		VSL_DEFINE_MOCK_METHOD(SetViewClassID)

		VSL_CHECK_VALIDVALUE(clsidView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetViewClassIDValidValues
	{
		/*[out]*/ CLSID* pclsidView;
		HRESULT retValue;
	};

	STDMETHOD(GetViewClassID)(
		/*[out]*/ CLSID* pclsidView)
	{
		VSL_DEFINE_MOCK_METHOD(GetViewClassID)

		VSL_SET_VALIDVALUE(pclsidView);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBaseEditorCaptionValidValues
	{
		/*[in]*/ LPCOLESTR* pszBaseEditorCaption;
		HRESULT retValue;
	};

	STDMETHOD(SetBaseEditorCaption)(
		/*[in]*/ LPCOLESTR* pszBaseEditorCaption)
	{
		VSL_DEFINE_MOCK_METHOD(SetBaseEditorCaption)

		VSL_CHECK_VALIDVALUE_POINTER(pszBaseEditorCaption);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEditorCaptionValidValues
	{
		/*[in]*/ READONLYSTATUS dwReadOnly;
		/*[out]*/ BSTR* pbstrEditorCaption;
		HRESULT retValue;
	};

	STDMETHOD(GetEditorCaption)(
		/*[in]*/ READONLYSTATUS dwReadOnly,
		/*[out]*/ BSTR* pbstrEditorCaption)
	{
		VSL_DEFINE_MOCK_METHOD(GetEditorCaption)

		VSL_CHECK_VALIDVALUE(dwReadOnly);

		VSL_SET_VALIDVALUE_BSTR(pbstrEditorCaption);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastActiveViewValidValues
	{
		/*[out]*/ IVsTextView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(GetLastActiveView)(
		/*[out]*/ IVsTextView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastActiveView)

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCodeWindowManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCODEWINDOWMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCODEWINDOWMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCodeWindowManagerNotImpl :
	public IVsCodeWindowManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowManagerNotImpl)

public:

	typedef IVsCodeWindowManager Interface;

	STDMETHOD(AddAdornments)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAdornments)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnNewView)(
		/*[in]*/ IVsTextView* /*pView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCodeWindowManagerMockImpl :
	public IVsCodeWindowManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCodeWindowManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCodeWindowManagerMockImpl)

	typedef IVsCodeWindowManager Interface;
	struct AddAdornmentsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AddAdornments)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AddAdornments)

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAdornmentsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveAdornments)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveAdornments)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnNewViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		HRESULT retValue;
	};

	STDMETHOD(OnNewView)(
		/*[in]*/ IVsTextView* pView)
	{
		VSL_