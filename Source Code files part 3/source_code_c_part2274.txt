RUCT_PACKING=$(IA64_STRUCT_PACKING)
!elseif !defined(MSC_STRUCT_PACKING)
MSC_STRUCT_PACKING=/Zp8
!endif

# Due to different compilers in the nt tree (older VC++ as well intel compiler)
# interpreting the /Zc:wchar_t- switch as /Zc /Z: /Zw /Zc /Zh /Za ...
# creating a variable to disable /Zc:wchar_t- for the problematic directory
!ifndef NO_WCHAR_T
COMPILER_WCHAR_T=/Zc:wchar_t-
!else
COMPILER_WCHAR_T=
!endif

# Another wchar_t fix, don't want to use any wchar_t flags
# if it's managed and version 1.1 code.
!if "$(URT_VER)" == "1.1" && defined(MANAGED_CXX)
COMPILER_WCHAR_T=
!endif

STDFLAGS= /c $(COMPILER_WCHAR_T) /Zl $(MSC_STRUCT_PACKING) /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) \
          $(ERATTA_FLAGS) $(EH_FLAGS) $(RTTI_FLAGS) $(STRING_POOLING) \
          $(BO_FLAGS)

!IF $(FREEBUILD)
ASM_DBG_DEFINES=/DDBG=0
!ELSE
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) /d debug
!ENDIF

# This is only needed on x86
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) /DFPO=0

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
# @@END_DDKSPLIT
DBGFLAGS=$(DBGFLAGS) /Zi
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) /d debug
LINKER_FLAGS=$(LINKER_FLAGS) /debug /debugtype:cv,fixup
# @@BEGIN_DDKSPLIT
!ENDIF
# @@END_DDKSPLIT

!IFDEF SECTION_ALIGNMENT
SECTION_ALIGNMENT=/align:$(SECTION_ALIGNMENT)
!ENDIF

KERNEL_ALIGNMENT=0x80
HAL_ALIGNMENT=0x80

LINKER_FLAGS = $(LINKER_FLAGS) $(SECTION_ALIGNMENT) /debugtype:pdata

!if !defined(USE_PDB_TO_COMPILE) || "$(USE_PDB_TO_COMPILE)" == "0"
DBGFLAGS=$(DBGFLAGS:/Zi=/Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=/Z7)
!else
USER_C_FLAGS=$(USER_C_FLAGS:/Z7=/Zi)
USER_C_FLAGS=$(USER_C_FLAGS:-Z7=/Zi)
! if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
! else
DBGFLAGS=$(DBGFLAGS) /Fd$(OBJ_PATH)\$(_OBJ_DIR)\ia64^\
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(OBJ_PATH)\$(_OBJ_DIR)\ia64^\
! endif
!endif

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=/D$(HALTYPE)=1
!ENDIF


#
#
#
!ifdef GENIA64
STD_DEFINES= /D_WIN64 /D_IA64_=1 /DIA64=1 /DNO_HW_DETECT /D_MSC_EXTENSIONS /D_GENIA64_ $(HALDEF) $(STD_DEFINES) /D_CROSS_PLATFORM_=1
!else
STD_DEFINES= /D_WIN64 /D_IA64_=1 /DIA64=1 /DNO_HW_DETECT /D_MSC_EXTENSIONS $(PTR_SIZE) $(HALDEF) $(STD_DEFINES) /D_MERCED_A0_=1
!endif

!ifdef PC98CHANGE
STD_DEFINES=$(STD_DEFINES) /D_PC98_
!endif

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
ASM_DEFINES=$(ASM_DEFINES) /D__assembler=1
CFLAGS=$(IA64_FLAGS) $(NTIA64FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
IA64_ASMFLAGS=$(IA64_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

IA64_CDEFINES=$(CDEFINES)
IA64_CFLAGS=$(CFLAGS)

!ifndef CC_NAME
! if defined(SUBSTITUTE_IA64_CC_MANAGED) && defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_IA64_CC_MANAGED) 
! elseif defined(SUBSTITUTE_IA64_CC) && !defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_IA64_CC) 
! elseif !defined(CC_NAME)
!  ifdef RAZZLETOOLPATH
!   if "$(PROCESSOR_ARCHITECTURE)" == "IA64"  
CC_NAME = $(RAZZLETOOLPATH)\ia64\ia64\cl.exe 
!   else
CC_NAME = cl.exe 
!   endif
!  else
CC_NAME=cl.exe 
!  endif
! endif
!endif



C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef IA64_ASSEMBLER_NAME
IA64_ASSEMBLER_NAME  = ias.exe
!endif

# CRT workaround for:  cl : warning D9025 : overriding '/D_MT' with '/U_MT'
!if defined(CRTLIBTYPE) && "$(MTOPTION)" != ""
CRT_BUILD_FLAGS = $(CRT_BUILD_FLAGS:/U_MT=)
!endif
GLOBAL_C_FLAGS = /Iia64 /I. $(INCPATH1) $(CRT_BUILD_FLAGS) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

CXX_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(MANAGED_CXX_FLAGS)
C_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS)
C_COMPILER_FLAGS = $(C_COMPILER_FLAGS_NOPCH) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(CXX_COMPILER_FLAGS_NOPCH) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) /EP /Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS:/EP=/E)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

IA64_ASSEMBLER=$(IA64_ASSEMBLER_NAME) $(_IA64_HAZARD_DETECTION) $(_IA64_MERCED_MSR) /N so /I ia64 /I . $(INCPATH1:/I=/I ) $(IA64_ADBGFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
	       
ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.s:
    $(C_COMPILER_NAME) @<< /Fa $<
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\ia64}.s{}.lst:
    $(IA64_ASSEMBLER) /o $@.obj $<

{ia64}.s{}.lst:
    $(IA64_ASSEMBLER) /o $@.obj $<

{..\ia64}.s{$(_OBJ_DIR)\ia64}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $< >$@.i
    $(IA64_ASSEMBLER) /o $@ $@.i
    @-erase $@.i >nul 2>&1

{$(_OBJ_DIR)\ia64}.s{$(_OBJ_DIR)\ia64}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $< >$@.i
    $(IA64_ASSEMBLER) /o $@ $@.i
    @-erase $@.i >nul 2>&1

{ia64}.s{$(_OBJ_DIR)\ia64}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $< >$@.i
    $(IA64_ASSEMBLER) /o $@ $@.i
    @-erase $@.i >nul 2>&1

{..\ia64}.s{$(OBJ_PATH)\$(_OBJ_DIR)\ia64}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $< >$@.i
    $(IA64_ASSEMBLER) /o $@ $@.i
    @-erase $@.i >nul 2>&1

{$(OBJ_PATH)\$(_OBJ_DIR)\ia64}.s{$(OBJ_PATH)\$(_OBJ_DIR)\ia64}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $< >$@.i
    $(IA64_ASSEMBLER) /o $@ $@.i
    @-erase $@.i >nul 2>&1

{ia64}.s{$(OBJ_PATH)\$(_OBJ_DIR)\ia64}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $< >$@.i
    $(IA64_ASSEMBLER) /o $@ $@.i
    @-erase $@.i >nul 2>&1

NTKERNEL_LINK_OPTIONS=/section:ivt,,align=0x8000 /fixed:no /base:0xE000000084000000 /entry:KiSystemBegin

# SEH support for libs built with an older compiler
# @@BEGIN_DDKSPLIT
!if 0
# @@END_DDKSPLIT
!ifdef _NT_TARGET_VERSION
!    if $(_NT_TARGET_VERSION) < 0x600 && $(_NT_TOOLS_VERSION) >= 0x700
TARGETLIBS=$(TARGETLIBS) $(DDK_LIB_PATH)\sehupd.lib
!    endif
!endif
# @@BEGIN_DDKSPLIT
!endif
# @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\i386mk.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    i386mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

#
# x86 option control
#
UMBASE=$(UMBASE:*=i386)
UMLIBS=$(UMLIBS:*=i386)
NTRES=$(NTRES:*=i386)
UMRES=$(UMRES:*=i386)
UMOBJS=$(UMOBJS:*=i386)
CRTLIBS=$(CRTLIBS:*=i386)
LINKLIBS=$(LINKLIBS:*=i386)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=i386)
DLLBASE=$(DLLBASE:*=i386)
DLLDEF=$(DLLDEF:*=i386)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=i386)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=i386)
DYNLINK_LIB=$(DYNLINK_LIB:*=i386)
TARGETEXEFILES=$(TARGETEXEFILES:*=i386)
TARGETLIBFILES=$(TARGETLIBFILES:*=i386)
TARGETOBJFILES=$(TARGETOBJFILES:*=i386)
UMOBJFILES=$(UMOBJFILES:*=i386)
UMEXEFILES=$(UMEXEFILES:*=i386)
HEADERFILE=$(HEADERFILE:*=i386)
HEADEROBJNAME=$(HEADEROBJNAME:*=i386)
HEADEROBJ=$(HEADEROBJ:*=i386)
PRECOMPILED=$(PRECOMPILED:*=i386)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=i386)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=i386)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=i386)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=i386)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=i386)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=i386)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=i386)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=i386)
ORDER=$(ORDER:*=i386)
OBJLIBFILES=$(OBJLIBFILES:*=i386)
MISCFILES=$(MISCFILES) $(I386_MISCFILES)
!if defined(I386_DRIVER_INFS)
DRIVER_INFS=$(DRIVER_INFS) $(I386_DRIVER_INFS)
!endif
!if defined(I386_PRINTER_INFS)
PRINTER_INFS=$(PRINTER_INFS) $(I386_PRINTER_INFS)
!endif
!if defined(I386_NON_PNP_INFS)
NON_PNP_INFS=$(NON_PNP_INFS) $(I386_NON_PNP_INFS)
!endif
!if defined(I386_NON_PNP_SIGN_INFS)
NON_PNP_SIGN_INFS=$(NON_PNP_SIGN_INFS) $(I386_NON_PNP_SIGN_INFS)
!endif
!if defined(I386_LOC_DRIVER_INFS)
LOC_DRIVER_INFS=$(LOC_DRIVER_INFS) $(I386_LOC_DRIVER_INFS)
!endif
!if defined(I386_LOC_PRINTER_INFS)
LOC_PRINTER_INFS=$(LOC_PRINTER_INFS) $(I386_LOC_PRINTER_INFS)
!endif
!if defined(I386_LOC_NON_PNP_INFS)
LOC_NON_PNP_INFS=$(LOC_NON_PNP_INFS) $(I386_LOC_NON_PNP_INFS)
!endif
!if defined(I386_LOC_NON_PNP_SIGN_INFS)
LOC_NON_PNP_SIGN_INFS=$(LOC_NON_PNP_SIGN_INFS) $(I386_LOC_NON_PNP_SIGN_INFS)
!endif
SOURCES=$(SOURCES) $(I386_SOURCES)


!IF "$(TARGETTYPE)"=="GDI_DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"
#
#Drivers don't link with link libs.
#
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ELSE
!IF !defined(CE_TARGET) && (defined(USE_NTDLL) || defined (USE_NOLIBS))
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ENDIF
!ENDIF

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=i386)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=i386)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=i386)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=i386)
!endif

!IFNDEF CE_TARGET
!IF "$(DLLENTRY)" != "/noentry" && "$(DLLENTRY)" != "-noentry"
!   IF "$(DLLENTRY:@12=)" == "$(DLLENTRY)"
DLLENTRY=$(DLLENTRY)@12
!   ENDIF
!ENDIF
!ENDIF

!IFDEF STD_CALL_ENTRY
UMENTRY=$(UMENTRY)@4
!ENDIF

ENTRY_SUFFIX=@8
GDI_ENTRY_SUFFIX=@12

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x2000

!IFDEF 386_WARNING_LEVEL
MSC_WARNING_LEVEL=$(386_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) $(COMPILER_WX_SWITCH)

!ifdef 386_PERFFLAGS
PERFFLAGS = $(386_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!ifdef 386_OPTIMIZATION
MSC_OPTIMIZATION=$(386_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

LINK_TIME_CODE_GENERATION_MSC_FLAG=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_FLAG=/GL
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_FLAG)

!IFDEF 386_CPPFLAGS
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
! if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=/EHa
! else
!  if "$(USE_NATIVE_EH)" == "CTHROW"
EH_FLAGS=/EHsc-
!  else
EH_FLAGS=/EHsc
!  endif
! endif
!else
EH_FLAGS=/EHs-c-
!endif

!if defined(USE_RTTI) || (defined(MANAGED_CXX) && "$(URT_VER)" != "1.1")
RTTI_FLAGS=/GR
!else
RTTI_FLAGS=/GR-
!endif

# On by default
!if "$(BUFFER_OVERFLOW_CHECKS)" == ""
BUFFER_OVERFLOW_CHECKS=1
!endif

# Turn off for the select few
!if ("$(DRIVERTYPE)" == "VXD") || \
    (("$(TARGETTYPE)" == "MINIPORT") && ($(_NT_TARGET_VERSION) < 0x502)) || \
    (("$(TARGETTYPE)" == "DYNLINK") && defined(RESOURCE_ONLY_DLL)) || \
    "$(BUFFER_OVERFLOW_CHECKS)" == "0"
!undef BUFFER_OVERFLOW_CHECKS
!endif

!if defined(BUFFER_OVERFLOW_CHECKS)
# verify it's one of the chosen few - 1, NTDLL or compile only - all others are wrong.
! if "$(BUFFER_OVERFLOW_CHECKS)" != "1" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "NTDLL" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "COMPILE_ONLY" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "LINK_ONLY"
!message BUILDMSG: Error: INVALID BUFFER_OVERFLOW_CHECKS value "$(BUFFER_OVERFLOW_CHECKS)" in $(MAKEDIR)
! endif
! if "$(BUFFER_OVERFLOW_CHECKS)" == "LINK_ONLY"
BO_FLAGS=/GS-
BUFFER_OVERFLOW_CHECKS=1
! else
BO_FLAGS=/GS
! endif
! if "$(BUFFER_OVERFLOW_CHECKS)" == "1"
!  if "$(TARGETTYPE)" == "DRIVER" || \
      "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
      "$(TARGETTYPE)" == "DRIVER_LIBRARY" || \
      "$(TARGETTYPE)" == "MINIPORT" 
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib
DRIVER_ENTRY=GsDriverEntry
!  elseif "$(TARGETTYPE)" == "GDI_DRIVER"
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
GDI_DRIVER_ENTRY=GsDrvEnableDriver
!  elseif "$(TARGETTYPE)" == "DYNLINK"
!   if !(("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss"))
!    if ("$(DLLENTRY)" == "/noentry" || "$(DLLENTRY)" == "-noentry")
!     if defined(USE_MSVCRT) || defined(USE_LIBCMT)
DLLENTRY=-entry:_DllMainCRTStartup@12
!     else
DLLENTRY=-entry:_DllMainCRTStartupForGS@12
!     endif
!    endif
!    if !defined(USE_MSVCRT) && !defined(USE_LIBCMT)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!    endif
!   endif
!  else	# TARGETTYPE == PROGRAM/LIBRARY/NOTARGET with special build rules
!   if ("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss")
!    if defined(NTKERNEL)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib
!    else
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!    endif
!   else
!    if !defined(USE_MSVCRT) && !defined(USE_LIBCMT)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!    endif
!   endif
!  endif
! elseif "$(BUFFER_OVERFLOW_CHECKS)" == "NTDLL"
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!  if ("$(TARGETTYPE)" == "DYNLINK") && \
      ("$(DLLENTRY)" == "/noentry" || "$(DLLENTRY)" == "-noentry") && \
      ("$(TARGETNAME)" != "ntdll")
DLLENTRY=-entry:_DllMainCRTStartupForGS@12
!  endif
! endif
!endif  # Overflow checks

!ifndef X86_CPU_OPTIMIZATION
X86_CPU_OPTIMIZATION=/G6
!endif

# Undocumented switch definitions
ERATTA_FLAGS=

# Hotpatch support
ERATTA_FLAGS=$(ERATTA_FLAGS) /hotpatch
LINKER_FLAGS=$(LINKER_FLAGS) /functionpadmin:5
!ifndef NO_SAFESEH
LINKER_FLAGS=$(LINKER_FLAGS) /safeseh
!endif

!if defined(386_STRUCT_PACKING)
MSC_STRUCT_PACKING=$(386_STRUCT_PACKING)
!elseif !defined(MSC_STRUCT_PACKING)
MSC_STRUCT_PACKING=/Zp8
!endif

# Due to different compilers in the nt tree (older VC++ as well intel compiler)
# interpreting the /Zc:wchar_t- switch as /Zc /Z: /Zw /Zc /Zh /Za ...
# creating a variable to disable /Zc:wchar_t- for the problematic directory
!ifndef NO_WCHAR_T
COMPILER_WCHAR_T=/Zc:wchar_t-
!else
COMPILER_WCHAR_T=
!endif

# Another wchar_t fix, don't want to use any wchar_t flags
# if it's managed and version 1.1 code.
!if "$(URT_VER)" == "1.1" && defined(MANAGED_CXX)
COMPILER_WCHAR_T=
!endif

STDFLAGS= /c $(COMPILER_WCHAR_T) /Zl $(MSC_STRUCT_PACKING) /Gy /Gm- $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING) $(BO_FLAGS)

!IF "$(MCPP_TYPE)" == "pure" || "$(MCPP_TYPE)" == "safe"
MSC_CALL_TYPE=
MSC_CALL_DEFINE=
!ELSE
!IF "$(386_STDCALL)" == "0"
MSC_CALL_TYPE=/Gd
MSC_CALL_DEFINE=
!ELSE
!   IF "$(386_STDCALL)" == "2"
MSC_CALL_TYPE=/Gr
MSC_CALL_DEFINE=
!   ELSE
MSC_CALL_TYPE=/Gz
MSC_CALL_DEFINE=/DSTD_CALL
!   ENDIF
!ENDIF
!ENDIF

!IF $(FREEBUILD)
ASM_DBG_DEFINES=/DDBG=0
!ENDIF

TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) /DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
# @@END_DDKSPLIT
DBGFLAGS=$(DBGFLAGS) /Zi
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) /debug /debugtype:cv,fixup
# @@BEGIN_DDKSPLIT
!ENDIF
# @@END_DDKSPLIT

!if !defined(USE_PDB_TO_COMPILE) || "$(USE_PDB_TO_COMPILE)" == "0"
DBGFLAGS=$(DBGFLAGS:/Zi=/Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=/Z7)
!else
USER_C_FLAGS=$(USER_C_FLAGS:/Z7=/Zi)
USER_C_FLAGS=$(USER_C_FLAGS:-Z7=/Zi)
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(OBJ_PATH)\$O^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(OBJ_PATH)\$O\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(OBJ_PATH)\$O^\
! endif
!endif

#
# 386 option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=/D$(HALTYPE)=1
!ENDIF

STD_DEFINES= /D_X86_=1 /Di386=1 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)

386_ASMFLAGS=$(386_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

386_CDEFINES=$(CDEFINES)
386_CFLAGS=$(CFLAGS)

!if defined(SUBSTITUTE_386_CC_MANAGED) && defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_386_CC_MANAGED) 
!elseif defined(SUBSTITUTE_386_CC) && !defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_386_CC) 
!elseif !defined(CC_NAME)
CC_NAME=cl.exe /nologo
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)

!ifndef 386_ASSEMBLER_NAME
386_ASSEMBLER_NAME  = ml.exe /safeseh
!endif

GLOBAL_C_FLAGS = /Ii386 /I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

GLOBAL_C_FLAGS=$(CRT_BUILD_FLAGS) $(GLOBAL_C_FLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

CXX_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(MANAGED_CXX_FLAGS)
C_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS)
C_COMPILER_FLAGS = $(C_COMPILER_FLAGS_NOPCH) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(CXX_COMPILER_FLAGS_NOPCH) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) /EP /Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

!ifdef NOMASMCOMPATIBILITY
386_ASSEMBLER=$(386_ASSEMBLER_NAME) /c /coff /Cx /nologo /Ii386\ /I. $(INCPATH1) $(386_ASMFLAGS)
!else
386_ASSEMBLER=$(386_ASSEMBLER_NAME) /c /coff /Cx /nologo /Ii386\ /I. $(INCPATH1) /Zm $(386_ASMFLAGS)
!endif

_ECHO_386_ASSEMBLER_OBJ=$(386_ASSEMBLER) /Fo$@ $<
_ECHO_386_ASSEMBLER_OBJ=$(_ECHO_386_ASSEMBLER_OBJ:   = )
_ECHO_386_ASSEMBLER_OBJ=$(_ECHO_386_ASSEMBLER_OBJ:  = )

_ECHO_386_ASSEMBLER_LIST=$(386_ASSEMBLER) /Fl$@ /Fo$@.obj $<
_ECHO_386_ASSEMBLER_LIST=$(_ECHO_386_ASSEMBLER_LIST:   = )
_ECHO_386_ASSEMBLER_LIST=$(_ECHO_386_ASSEMBLER_LIST:  = )
_ECHO_386_ASSEMBLER_LIST=$(_ECHO_386_ASSEMBLER_LIST: =^
)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
	
ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $<
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\i386}.asm{}.lst:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_LIST)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fl$@ /Fo$@.obj $<

{i386}.asm{}.lst:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_LIST)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fl$@ /Fo$@.obj $<

{..\i386}.asm{$O}.obj:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_OBJ)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fo$@ $<

{$O}.asm{$O}.obj:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_OBJ)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fo$@ $<

{i386}.asm{$O}.obj:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_OBJ)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fo$@ $<

{..\i386}.asm{$(OBJ_PATH)\$O}.obj:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_OBJ)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fo$@ $<

{$(OBJ_PATH)\$O}.asm{$(OBJ_PATH)\$O}.obj:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_OBJ)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fo$@ $<

{i386}.asm{$(OBJ_PATH)\$O}.obj:
    @type <<$(ECHO_RSP)
$(_ECHO_386_ASSEMBLER_OBJ)
<<$(BUILD_NOKEEP)
    @$(386_ASSEMBLER) /Fo$@ $<

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTKERNEL_LINK_OPTIONS=/entry:KiSystemStartup@4
!ELSE
NTKERNEL_LINK_OPTIONS=/base:0x80100000 /entry:KiSystemStartup@4
!ENDIF

# NXCOMPAT support for binaries built with an older compiler (is on by default as of VS10)
!if "$(TARGETTYPE)" != "DRIVER"         && \
    "$(TARGETTYPE)" != "DRIVER_LIBRARY" && \
    "$(TARGETTYPE)" != "EXPORT_DRIVER"  && \
    "$(TARGETTYPE)" != "HAL"            && \
    "$(TARGETTYPE)" != "GDI_DRIVER"     && \
    "$(TARGETTYPE)" != "MINIPORT"

# TODO (kjordan): Should we change the following to check _NT_TOOLS_VERSION instead,
# and add logic to CoreXT to set _NT_TOOLS_VERSION based on COMPILER_VERSION?
! if ! ("$(COMPILER_VERSION)" >= "VS9")     
!  if defined(LINKER_WIN98OPT) || defined (CHICAGO_PRODUCT)
LINKER_FLAGS=$(LINKER_FLAGS) /opt:win98
!  else
!   ifndef CE_TARGET
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!   endif
!  endif
! endif

! if $(_NT_TOOLS_VERSION) >= 0x800 && \
     (!defined(NTKERNEL)) && \
     ("$(UMTYPE)" != "posix")
!  ifdef NO_NXCOMPAT
LINKER_FLAGS=$(LINKER_FLAGS) /nxcompat:no
!  else
LINKER_FLAGS=$(LINKER_FLAGS) /nxcompat
!  endif
! endif
!endif

# SEH support for libs built with an older compiler
# @@BEGIN_DDKSPLIT
!if 0
# @@END_DDKSPLIT
!ifdef _NT_TARGET_VERSION
!    if $(_NT_TARGET_VERSION) < 0x600 && $(_NT_TOOLS_VERSION) >= 0x700
TARGETLIBS=$(TARGETLIBS) $(DDK_LIB_PATH)\sehupd.lib
!    endif
!endif
# @@BEGIN_DDKSPLIT
!endif
# @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\mppcmk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    mppcmk.inc

Abstract:

	This module contains the MPPC specific build controls.  It is included
	by makefile.def.

Revision History:

!ENDIF

# add the powermac stuff to the path
PATH=$(IMPORT)\msdev\bin\mppc;$(PATH)

#
# MPPC option control
#

!undef USE_MAPSYM

UMBASE=$(UMBASE:*=mppc)
UMLIBS=$(UMLIBS:*=mppc)
NTRES=$(NTRES:*=mppc)
UMRES=$(UMRES:*=mppc)
UMOBJS=$(UMOBJS:*=mppc)
LINKLIBS=$(LINKLIBS:*=mppc)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=mppc)
DLLBASE=$(DLLBASE:*=mppc)
DLLDEF=$(DLLDEF:*=mppc)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=mppc)
TARGET=$(TARGET:*=mppc)
DYNLINK_LIB=$(DYNLINK_LIB:*=mppc)
TARGETEXEFILES=$(TARGETEXEFILES:*=mppc)
TARGETLIBFILES=$(TARGETLIBFILES:*=mppc)
TARGETOBJFILES=$(TARGETOBJFILES:*=mppc)
UMOBJFILES=$(UMOBJFILES:*=mppc)
UMEXEFILES=$(UMEXEFILES:*=mppc)
HEADERFILE=$(HEADERFILE:*=mppc)
HEADEROBJNAME=$(HEADEROBJNAME:*=mppc)
HEADEROBJ=$(HEADEROBJ:*=mppc)
PRECOMPILED=$(PRECOMPILED:*=mppc)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=mppc)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=mppc)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=mppc)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=mppc)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=mppc)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=mppc)
ORDER=$(ORDER:*=mppc)
MISCFILES=$(MISCFILES) $(MPPC_MISCFILES)
SOURCES=$(SOURCES) $(MPPC_SOURCES)

#
# Include 64-bit helper library
#
!if "$(TARGETTYPE)" == "DRIVER"     || \
    "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
    "$(TARGETTYPE)" == "HAL" || \
    "$(TARGETTYPE)" == "GDI_DRIVER" || \
    "$(TARGETTYPE)" == "MINIPORT"
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!elseif defined(USE_NTDLL) || \
     defined(USE_SYSDLL) || \
     defined (USE_NOLIBS)
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
! if "$(UMTYPE)" == "nt" || \
     "$(UMTYPE)" == "ntss"
# Do this to avoid multiple library warnings (and allow building csr/server)
UMLIBS=$(SDK_LIB_PATH)\int64.lib $(UMLIBS)
! endif
!elseif "$(UMTYPE)" == "nt" || \
        "$(UMTYPE)" == "ntss"
UMLIBS=$(SDK_LIB_PATH)\int64.lib $(UMLIBS)
!endif

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=mppc)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=mppc)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=mppc)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=mppc)
!endif

!IF "$(GPSIZE)" != "0"
#
# GPSIZE is irrelevant on PowerPC
#
LINKGPSIZE=
!ENDIF

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=


!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
! else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\mppc^\
! endif
!endif

!ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\mppc^\
!endif

!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Z7
LINKER_FLAGS=$(LINKER_FLAGS) -debug -debugtype:cv,fixup
!ENDIF

!IFDEF MPPC_WARNING_LEVEL
MSC_WARNING_LEVEL=$(MPPC_WARNING_LEVEL)
!ENDIF

!ifdef MPPC_PERFFLAGS
PERFFLAGS = $(MPPC_PERFFLAGS)
!endif

# DEFAULT_MSC_OPT = $(DEFAULT_MSC_OPT:/Oxs=/Ox)

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(MPPC_OPTIMIZATION)
MSC_OPTIMIZATION=$(MPPC_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

!IFDEF MPPC_CPPFLAGS
MSC_CPPFLAGS=$(MPPC_CPPFLAGS)
!ENDIF

!ifdef NO_READONLY_STRINGS
STRING_POOLING =
!else
STRING_POOLING = /GF
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX /GR
!else
EH_FLAGS=/GX- /GR-
!endif

MPPC_AS=pas
MPPC_DIS=pdis
MPPC_AS_WARNINGS=

MPPC_START_FILE=start.obj

ENV_DEFINES=$(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(PM_DEFINES)
STD_DEFINES=-DMPPC=1 -D_MPPC_=1 -DNO_EXT_KEYS $(STD_DEFINES) -D_MAC

STDFLAGS=-c -Zel -Zp2 -Gy $(STRING_POOLING) $(EH_FLAGS)

MPPC_C_COMPILER_NAME = cl -nologo
# MPPC_C_COMPILER_NAME = cl
MPPC_CC = $(MPPC_C_COMPILER_NAME)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) $(ENV_DEFINES) $(MFC_DEFINES)
CFLAGS=$(MPPC_FLAGS) $(NTMPPCFLAGS) $(STDFLAGS) $(DBGFLAGS) $(USER_C_FLAGS) $(PERFFLAGS)

MPPC_CDEFINES= $(CDEFINES)
MPPC_CFLAGS  = $(CFLAGS)  $(MSC_WARNING_LEVEL) # -DALLOC_TEXT

!IFNDEF MPPC_OPTIONS
MPPC_OPTIONS=
!ENDIF

C_COMPILER_NAME      = $(MPPC_C_COMPILER_NAME)
C_PREPROCESSOR_NAME  = $(MPPC_C_COMPILER_NAME)
CXX_COMPILER_NAME    = $(MPPC_C_COMPILER_NAME)

GLOBAL_C_FLAGS       = -nologo -Imppc\ -I. $(INCPATH0) $(CDEFINES) $(MPPC_OPTIONS) \
                        $(MPPC_CFLAGS) -D__stdcall= -D__cdecl= -DFPO=1 -DLANGUAGE_C

# Disable -WX for now, unless explicitly allowed

!ifndef ALLOW_WX
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS:-WX=)
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS:/WX=)
!endif

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) $(PRECOMPILED) -EP -Tc

C_PREPROCESSOR       = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER           = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
CXX_COMPILER         = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

MPPC_ASSEMBLER        = $(MPPC_AS) $(MPPC_AS_WARNINGS)

ECHO_MSG             = ClPpc $< " $(C_COMPILER) "
ECHO_CXX_MSG         = ClPpc $< " $(CXX_COMPILER) "

ECHO_PRECOMPILED_MSG1=CpPpc $(PRECOMPILED_INCLUDE) \
                     "$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
		      $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)"

ECHO_PRECOMPILED_MSG2=CpPpc $(PRECOMPILED_INCLUDE) \
                     "$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
		      $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)"

{.\}.cxx{}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{.\}.cxx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{}.cxx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{..\mppc\}.s{$(_OBJ_DIR)\mppc\}.obj:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\..\mppc\$(<F) > $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i && $(MPPC_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i >nul 2>&1

{..\mppc\}.s.pp:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\..\mppc\$(<F) > $(MAKEDIR)\$(<B).pp

{mppc\}.s{$(_OBJ_DIR)\mppc\}.obj:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\mppc\$(<F) > $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i && $(MPPC_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i >nul 2>&1

{mppc\}.s.pp:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\mppc\$(<F) > $(MAKEDIR)\$(<B).pp

.SUFFIXES: .il

{}.il{}.cod:
    @-erase $@ >nul 2>&1
    @echo cl $<" $(C_COMPILER) "
    @$(C_COMPILER) -FAac -Fa$(<B).cod -B1..\bootbin\null.exe -Bk$(<B). -Fo$(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).o $(MAKEDIR)\$(<B).c
    @del $(_OBJ_DIR)\mppc\$(<B).o

!IFDEF CAIRO_PRODUCT
!IFDEF _CAIROMPPCTREE
_NTTREE=$(_CAIROMPPCTREE)
_NTTREE_NO_SPLIT=$(_CAIROMPPCTREE_NS)
!ENDIF
!ELSE
!IFDEF _NTMPPCTREE
_NTTREE=$(_NTMPPCTREE)
_NTTREE_NO_SPLIT=$(_NTMPPCTREE_NS)
!ENDIF
!ENDIF

!IFDEF _NTMPPCLIBS
_NTLIBS=$(_NTMPPCLIBS)
!ENDIF

COPYDST=$(MPPCCOPYDST)

LIB_COPY=ntmppccp.cmd

NTTEST_LINK_OPTIONS= -base:0x80010000 -entry:KiSystemStartup
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\projects.inc ===
BASE_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Base\inc
BASE_REF_PATH=$(PUBLIC_INTERNAL_PATH)\Base\ref
BASE_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Base\lib
BASE_LIB_PATH=$(BASE_LIB_DEST)\$(TARGET_DIRECTORY)

SDKTOOLS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\SdkTools\inc
SDKTOOLS_REF_PATH=$(PUBLIC_INTERNAL_PATH)\SdkTools\ref
SDKTOOLS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\SdkTools\lib
SDKTOOLS_LIB_PATH=$(SDKTOOLS_LIB_DEST)\$(TARGET_DIRECTORY)

SDKTOOLS_TST_INC_PATH=$(PUBLIC_INTERNAL_PATH)\SdkToolsTest\inc
SDKTOOLS_TST_REF_PATH=$(PUBLIC_INTERNAL_PATH)\SdkToolsTest\ref
SDKTOOLS_TST_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\SdkToolsTest\lib
SDKTOOLS_TST_LIB_PATH=$(SDKTOOLS_TST_LIB_DEST)\$(TARGET_DIRECTORY)



#CLR_REF_PATH=$(URTTARGET)

#!if "$(URT_VER)" == "2.0"
#CLR_REF_PATH=$(SDK_REF_PATH)\CLR20
#!else
#CLR_REF_PATH=$(SDK_REF_PATH)\CLR11
#!endif

CLR3_REF_PATH=$(SDK_ROOT)\CLR\clr30

CLR35_REF_PATH=$(SDK_ROOT)\CLR\clr35

!if exist($(INETROOT)\build\projects.inc)
!include $(INETROOT)\build\projects.inc
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\sxsversionsmk.inc ===
# sxsversionsmk.inc

#
# This file is not used yet.
# I hope Jon uses it when he addresses 
#  586269 Need to rev versions of assemblies for .NET Server
#
# and system_defaultmk.inc should be deleted.
#
# need msvcrt versions
#
# need to be sure to policy files say like
# old = 6.0.0.0 - CURRENT_VIA_PREPROCESSING, new = CURRENT_VIA_PREPROCESSING
#
# stop using preprocessing for the names of dependent assemblies (as system_defaultmk.inc does)
# the names are frozen
#

GDIPLUS_ASSEMBLY_VERSION=1.0
GDIPLUS_ASSEMBLY_VERSION_PART_3=3000
GDIPLUS_ASSEMBLY_VERSION_PART_4=0
GDIPLUS_ASSEMBLY_FULL_VERSION=$(GDIPLUS_ASSEMBLY_VERSION).$(GDIPLUS_ASSEMBLY_VERSION_PART_3).$(GDIPLUS_ASSEMBLY_VERSION_PART_4)

# This does not need to match the nt subsystem version.
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=5.2
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=0
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=0
SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION=$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4)

COMMON_CONTROLS_ASSEMBLY_VERSION=6.0
# This changes to 100?
COMMON_CONTROLS_ASSEMBLY_VERSION_PART_3=1
COMMON_CONTROLS_ASSEMBLY_VERSION_PART_4=0
COMMON_CONTROLS_ASSEMBLY_FULL_VERSION=$(COMMON_CONTROLS_ASSEMBLY_VERSION).$(COMMON_CONTROLS_ASSEMBLY_VERSION_PART_3).$(COMMON_CONTROLS_ASSEMBLY_VERSION_PART_4)

SXS_MANIFEST_DEFINES= \
 $(SXS_MANIFEST_DEFINES) \
 -DGDIPLUS_ASSEMBLY_FULL_VERSION_STRING_A="\"$(GDIPLUS_ASSEMBLY_FULL_VERSION)\"" \
 -DSYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_A="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION)\"" \
 -DCOMMON_CONTROLS_ASSEMBLY_FULL_VERSION_STRING_A="\"$(COMMON_CONTROLS_ASSEMBLY_FULL_VERSION)\"" \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\system_defaultmk.inc ===
# system_defaultmk.inc

# This is for Fusion stuff only. It does not need to match the nt subsystem version.
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=6.0
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=$(VER_PRODUCTBUILD)
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=$(VER_PRODUCTBUILD_QFE)

SYSTEM_COMPATIBLE_ASSEMBLY_NAME=Microsoft.Windows.SystemCompatible
DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME=\
    -DSYSTEM_COMPATIBLE_ASSEMBLY_NAME="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\"" \
    -DLSYSTEM_COMPATIBLE_ASSEMBLY_NAME=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\""

SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION=$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4)

SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)$(SXS_ASSEMBLY_VERSION_PART_3)$(SXS_ASSEMBLY_VERSION_PART_4)

SXS_MANIFEST_DEFINES= \
 $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
 $(SXS_MANIFEST_DEFINES) \
 -DSYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_A="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION)\"" \

C_DEFINES=\
  $(C_DEFINES) \
  $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
  -DSYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_W=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION)\"" \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\wcpcompiler.inc ===
#
#   use the new Microsoft.*.targets from URT directory.
#

# When one of below macros is set from Sources, it doesn't want to go through the fullbuild
# It just wants to do CodeGeneration at Pass1.
#
#   MSBUILD_XAMLFILES:      .xaml files will be compiled to .baml and .g.cs
#   MSBUILD_APPDEFFILE:     Application Definition xaml file. 
#   MSBUILD_RESOURCE :      Resource files used by .xaml files, and will be
#                           embedded to the generated .g.resources.
#

#  MSBUILD_FULLBUILD true  : means a msbuild project file is ready, 
#                            msbuild controls the complete build procedure.
#  MSBUILD_FULLBUILD false : No msbuild project file avaible, just compile .xaml files
#                            to .cs and .baml, generate the correct managed resources.
#                            Windows build engine will control how to compile the final
#                            assembly and embed the managed resources.
# 

!if defined(MSBUILD_XAMLFILES) || defined(MSBUILD_APPDEFFILE) || defined(MSBUILD_RESOURCE)
MSBUILD_FULLBUILD=False  
!else
MSBUILD_FULLBUILD=True
!endif

MSBUILD_INTERMEDIATE_PATH=$(OBJ_PATH)\$(O)

XAML_COMPILER_PATH=$(COREXT_URT_ROOT)\$(COMPLUS_VERSION)\wcpcompiler
!if [set URTDIR=$(COREXT_URT_ROOT)\$(COMPLUS_VERSION)]
!endif

MSBUILD_TEMP_SOURCE_INC=$(MSBUILD_INTERMEDIATE_PATH)\xamlsource.inc

MSBUILD_COMPILER_NAME=urtrun 2.0 $(COREXT_URT_ROOT)\$(COMPLUS_VERSION)\msbuild.exe

!if "$(GENERATE_TEMP_TARGET_FOR_LOCAL_TYPE_REF)"  != "true"

!if "$(MSBUILD_FULLBUILD)" == "True"
!  ifndef MSBUILD_TARGETTYPE
      ERROR MSBUILD_TARGETTYPE must be defined in your sources file
!  endif
MSBUILD_PROJ_FILE=$(SOURCES: =)
!else
# For non-full msbuild compilation, it can convert TARGETTYPE to MSBUILD_TARGETTYPE here.
#
!  ifndef MSBUILD_TARGETTYPE
!    if "$(MANAGED_TARGET_TYPE)" != ""
MSBUILD_TARGETTYPE=$(MANAGED_TARGET_TYPE)
!    elseif "$(TARGETTYPE)" != ""
!      if "$(TARGETTYPE)" == "DYNLINK"
MSBUILD_TARGETTYPE=Library
!          elseif "$(TARGETTYPE)" == "PROGRAM"
MSBUILD_TARGETTYPE=winexe
!      elseif "$(TARGETTYPE)" == "CONTAINER"
MSBUILD_TARGETTYPE=Container
!      elseif "$(MSBUILD_APPDEFFILE)" != ""
MSBUILD_TARGETTYPE=winexe
!      else
MSBUILD_TARGETTYPE=Library
!      endif
!      if "$(TARGETTYPE)" == "PROGRAM" && "$(UMTYPE)" == "console"
MSBUILD_TARGETTYPE=exe
!      endif
!    endif
!  endif
!endif

!if "$(MSBUILD_TARGETTYPE)" =="winexe" || "$(MSBUILD_TARGETTYPE)" =="exe"
LINK_TARGETEXT=exe
!elseif "$(MSBUILD_TARGETTYPE)" =="Library"
MAKEDLL=1
LINK_TARGETEXT=dll
!elseif "$(MSBUILD_TARGETTYPE)" =="module"
LINK_TARGETEXT=netmodule
!endif

!if $(FREEBUILD)
MSBUILD_CONFIG=Release
!else
MSBUILD_CONFIG=Debug
!endif

!if ("$(MSBUILD_TARGETTYPE)" == "Container" || "$(MSBUILD_TARGETTYPE)" == "DocumentContainer")
MSBUILD_FLAGS=$(MSBUILD_FLAGS) /p:HostInBrowser=True
!else
!    ifdef MSBUILD_HOST
!      if $(MSBUILD_HOST)
MSBUILD_FLAGS=$(MSBUILD_FLAGS) /p:HostInBrowser=True
!      else
MSBUILD_FLAGS=$(MSBUILD_FLAGS) /p:HostInBrowser=False
!      endif
!   endif
!endif

!ifndef MSBUILD_TARGET
MSBUILD_TARGET=build
!endif

!if "$(MSBUILD_CHECKUID)" == "true"
MSBUILD_TARGET=RazzleCheckUid;$(MSBUILD_TARGET)
!endif 
#
# The valid value for MSBUILD_VERBOSITY is
#
#   quiet,     short form: q 
#   minimal,      m
#   normal,       n
#   detailed,     d 
#   diagnostic,   diag
#
#
!if "$(MSBUILD_VERBOSITY)" == ""
MSBUILD_VERBOSITY=normal
!endif

# Move some common property settings to Razzle.Before.Microsoft.Common.targets.
MSBUILD_COMMON_PROPERTY=/p:COREXT_REF_PATH=$(COREXT_REF_PATH) /p:COREXT_INC_PATH=$(COREXT_INC_PATH)

MSBUILD_COMMON_PROPERTY=$(MSBUILD_COMMON_PROPERTY) /p:OBJ_PATH=$(OBJ_PATH)

MSBUILD_FLAGS=$(MSBUILD_FLAGS) $(MSBUILD_COMMON_PROPERTY) /v:$(MSBUILD_VERBOSITY) 

!ifdef NO_BINPLACE
MSBUILD_BINPLACE_CMD=
!else

!ifndef MSBUILD_BINPLACE_DIRECTORY
MSBUILD_BINPLACE_DIRECTORY=$(TARGETPATH)\$(TARGET_DIRECTORY)
!endif

! if "$(MSBUILD_TARGETTYPE)" == "module"
MSBUILD_BINPLACE_CMD=
!   else
MSBUILD_BINPLACE_CMD=\
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(LINK_TARGETEXT)

!      ifdef MSBUILD_BINPLACE_SYMBOL_TOGETHER
MSBUILD_SYMBOL_TOGETHER_CMD=\
            $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!endif

!   endif
!endif

!ifdef USE_ASMMETA
ASMMETA_INPUT=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(LINK_TARGETEXT)
O_BINARY_METADATA=$O\$(TARGETNAME).metadata_$(LINK_TARGETEXT)
!endif

# Sanity checks
!if "$(MSBUILD_FULLBUILD)" == "True"
!    if "$(MSBUILD_TARGETTYPE)" != "Library" && "$(MSBUILD_TARGETTYPE)" != "winexe" && "$(MSBUILD_TARGETTYPE)" != "exe" && "$(MSBUILD_TARGETTYPE)" != "module"
!        ERROR Invalid MSBUILD_TARGETTYPE: $(MSBUILD_TARGETTYPE)
!    endif
!endif


!if "$(MSBUILD_FULLBUILD)" == "False"

MSBUILD_SOURCES=$(MSBUILD_XAMLFILES) \
                $(MSBUILD_APPDEFFILE)  \
                $(MSBUILD_RESOURCE) 


#
# If below files are changed since last build, the .g.resources is required to re-generate 
# even if there is no xaml file and reference assembly change.
#
MSBUILD_SOMEDEPENDENTFILES=$(COREXT_URT_ROOT)\$(COMPLUS_VERSION)\wcpcompiler\presentationbuildtasks.dll \
                           $(COREXT_URT_ROOT)\$(COMPLUS_VERSION)\Microsoft.WinFX.targets \
                           $(COREXT_URT_ROOT)\$(COMPLUS_VERSION)\Razzle.Before.Microsoft.Common.targets \
                           $(NTMAKEENV)\xaml2code.pl   \
                           $(NTMAKEENV)\wcpcompiler.inc \
                           Sources
                           
MSBUILD_ALL_XAML=$(MSBUILD_XAMLFILES) \
                 $(MSBUILD_APPDEFFILE)

!if "$(BUILD_PASS)" == "PASS1"

MSBUILD_REFERENCE=$(REFERENCES:;= )

!  if defined(MSBUILD_TARGET_SELFREF) || defined(MSBUILD_ASMMETA_REFERENCE)

MSBUILD_REFERENCE=$(MSBUILD_REFERENCE) \
                $(TARGETNAME).asmmeta

!  endif

!endif   


!if "$(BUILD_PASS)" == "PASS1" && ("$(MSBUILD_XAMLFILES)" != ""  || "$(MSBUILD_APPDEFFILE)" != "")

#
# For every xaml file setting to MSBUILD_XAMLFILES, it will generate a .g.cs 
# under $(MSBUILD_INTERMEDIATE_PATH) tree with same subdirectory structure.
# such as for file .\SubDir1\SubDir2\Foo.xaml, it will generate file 
# $(MSBUILD_INTERMEDIATE_PATH)\SubDir1\SubDir2\Foo.g.cs
#

XAML_GEN_CS_CMD=cscript.exe /E:jscript /nologo $(XAML_COMPILER_PATH)\GenCodeFilesList.js   \
                          /xaml:"$(MSBUILD_ALL_XAML)" \
                          /geninc:"$(MSBUILD_TEMP_SOURCE_INC)" \
                          /curdir:"$(MAKEDIR)"      \
                          /objdir:"$(MSBUILD_INTERMEDIATE_PATH)" \
                          /codefiles:"$(SOURCES)"
                           
!if [$(XAML_GEN_CS_CMD) ]
!endif


!    if EXIST($(MSBUILD_TEMP_SOURCE_INC))

!include  $(MSBUILD_TEMP_SOURCE_INC)

SOURCES=$(SOURCES) \
        $(MSBUILD_GENERATED_SOURCES)
        
ADD_GENERATED_CODE_FILES=true
        
!    endif


XAMLCOMPILER_DEPENDENTS=$(MSBUILD_SOURCES)  \
                        $(MSBUILD_REFERENCE) \
                        $(MSBUILD_ORG_SOURCES) \
                        $(MSBUILD_SOMEDEPENDENTFILES) 

!if !exist($(MSBUILD_INTERMEDIATE_PATH)\$(TARGETNAME)_MarkupCompiler.cache)
!    if exist ($(MSBUILD_GENERATED_RESOURCE_FILE))
!        message deleting $(MSBUILD_GENERATED_RESOURCE_FILE)
!        if [del $(MSBUILD_GENERATED_RESOURCE_FILE)]
!        endif
!    endif
!endif                                                
                        
!endif  

!endif  # "$(MSBUILD_FULLBUILD)" == "False"   

#
# Temporarily remove CustomBeforeMicrosoftCommonTargets, since it has been set in urtrun.cmd.
#
#  /p:CustomBeforeMicrosoftCommonTargets=$(COREXT_URT_ROOT)\$(COMPLUS_VERSION)\Razzle.Before.Microsoft.Common.targets
#
#
MSBUILD_FLAGS=$(MSBUILD_FLAGS) /consoleloggerparameters:NoSummary


#
# currently we support xaml compilation only for below cases:
#
#   if a project file is available, compile it at Pass2.
#   if a project file is not available, compile xaml files at Pass1
#

!if "$(MSBUILD_FULLBUILD)" == "True"
build_xaml:
!if "$(BUILD_PASS)" == "PASS2"
    set BUILDMSG3=making $(@)

    $(MSBUILD_COMPILER_NAME) \
    $(MSBUILD_PROJ_FILE) \
    /p:MAKEDIR=$(MAKEDIR)                  \
    /p:Do_MSBUILD_FromWinBuild=true        \
    /p:MainOutputType=$(MSBUILD_TARGETTYPE) \
    /p:MainStagingPath=$(MSBUILD_INTERMEDIATE_PATH)\ \
    /p:DependStagingPath=$(MSBUILD_INTERMEDIATE_PATH)\Dependent  \
    /p:Configuration=$(MSBUILD_CONFIG) \
    /p:OutputPath=$(TARGETPATH)\$(TARGET_DIRECTORY) \
    /p:IntermediateOutputPath=$(O)\ \
    /p:BaseIntermediateOutputPath=$(O)\ \
! ifdef MSBUILD_BINPLACE_DIRECTORY
    /p:BINPLACE_DIRECTORY=$(MSBUILD_BINPLACE_DIRECTORY)  \
! endif
    $(MSBUILD_FLAGS) \
    /t:$(MSBUILD_TARGET)
! ifdef MSBUILD_BINPLACE_DIRECTORY
    $(MSBUILD_BINPLACE_CMD)
    $(MSBUILD_SYMBOL_TOGETHER_CMD)
! endif
!endif
!endif


!if "$(MSBUILD_FULLBUILD)" == "False"
build_xaml: $(MSBUILD_GENERATED_RESOURCE_FILE) 
!if "$(BUILD_PASS)" == "PASS1"
    @echo CODE_GENERATION_FROM_XAMLFILE handling is done.
!endif

#
# Since there is no nmake macro that can tell whether this is for clean build or regular build.
#
# For Xaml file compilation without project, we check the existence of the target assembly in $(O) directory
# to determine if this is a clean build or regular build.
#

MSBUILD_BCZMARKER=$(TARGET)

$(MSBUILD_GENERATED_RESOURCE_FILE) :  $(XAMLCOMPILER_DEPENDENTS) 
!if "$(BUILD_PASS)" == "PASS1" && "$(MSBUILD_FULLBUILD)" == "False" 
    set BUILDMSG3=making $(@) and compile Markup files

    perl.exe $(RAZZLETOOLPATH)\Xaml2Code.pl -xaml    "$(MSBUILD_XAMLFILES)"   \
                              -codefiles "$(MSBUILD_ORG_SOURCES)"        \
                              -msbuild "$(MSBUILD_COMPILER_NAME)"        \
                              -ref     "$(REFERENCES)"                   \
                              -res     "$(MSBUILD_RESOURCE)"     	 \
                              -tref    "$(MSBUILD_TARGET_SELFREF)"       \
                              -asmref  "$(MSBUILD_ASMMETA_REFERENCE)"    \
                              -type    "$(MSBUILD_TARGETTYPE)"           \
                              -outdir  $(MSBUILD_INTERMEDIATE_PATH)\   \
                              -appdef  "$(MSBUILD_APPDEFFILE)"           \
                              -tname   "$(TARGETNAME)"                   \
                              -config  "$(MSBUILD_CONFIG)"               \
                              -clrns   "$(MSBUILD_DEFNAMESPACE)"         \
                              -pubkey "$(MSBUILD_ASM_PUBLIC_KEY_TOKEN)"  \
                              -version "$(MSBUILD_ASM_VERSION)" \
                              -bczMarker "$(MSBUILD_BCZMARKER)" \
                              -locdirectives "$(MSBUILD_LOCDIRECTIVES_TO_LOCFILE)" \
                              -checkuid "$(MSBUILD_CHECKUID)" \
                              -options "$(MSBUILD_FLAGS)"


    cscript.exe /E:jscript /nologo $(XAML_COMPILER_PATH)\GenCodeFilesList.js   \
                          /checkCodeFiles:"true"  \
                          /incFileName:"$(MSBUILD_TEMP_SOURCE_INC)" 
                          


!endif

!endif

#
# End of handling for regular xaml file compilation.
#
!else

#
#  Handling for $(GENERATE_TEMP_TARGET_FOR_LOCAL_TYPE_REF)  equal true, 
#  This is for local-type-reference.
#

# Ignore the managed resources
_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS=
_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS=

# Shoudl not binplace the temporary target assembly
NO_BINPLACE=1
BINPLACE_CMD=@echo Skip Binplace:
BINPLACE_TOOL=$(BINPLACE_CMD)
BINPLACE_FLAGS=

!if "$(BUILD_PASS)" == "PASS1" && ("$(MSBUILD_XAMLFILES)" != ""  || "$(MSBUILD_APPDEFFILE)" != "")

#
# Add the generated .g.cs files to the SOURCES macro for the temporary assembly generation.
#


!    if EXIST($(MSBUILD_TEMP_SOURCE_INC))

!include  $(MSBUILD_TEMP_SOURCE_INC)

CHeck_CODEFILES_CMD=cscript.exe /E:jscript /nologo $(XAML_COMPILER_PATH)\GenCodeFilesList.js   \
                      /checkCodeFiles:"true"  \
                      /incFileName:"$(MSBUILD_TEMP_SOURCE_INC)"  
                      

!if [$(CHeck_CODEFILES_CMD)]
!endif


SOURCES=$(SOURCES) \
        $(MSBUILD_GENERATED_SOURCES)
!    endif

!endif

#
# Don't run command for build_xaml target.
#
XAML_COMPILATION=0

!if "$(MANAGED_COFFBASE)" == ""
MANAGED_COFFBASE=0x400000
!endif

GenTempTarget : $(TARGET)
   @echo generating the temporary target assembly.
   @echo TARGET is $(TARGET)


#
# End of Temporary target assemly generation.
#
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\Themes\PlaceHold3.c ===
*********************************************
DO NOT CLOSE THIS WINDOW
*********************************************

This window serves as a point of reference for
this dock.  If you close it, other windows may
not know where to position themselves.

If you want to tab another window against this
dock, it is recommended that you first bring 
this placeholder to the front of the dock.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\Themes\PlaceHold4.c ===
*********************************************
DO NOT CLOSE THIS WINDOW
*********************************************

This window serves as a point of reference for
this dock.  If you close it, other windows may
not know where to position themselves.

If you want to tab another window against this
dock, it is recommended that you first bring 
this placeholder to the front of the dock.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\Themes\PlaceHold5.c ===
*********************************************
DO NOT CLOSE THIS WINDOW
*********************************************

This window serves as a point of reference for
this dock.  If you close it, other windows may
not know where to position themselves.

If you want to tab another window against this
dock, it is recommended that you first bring 
this placeholder to the front of the dock.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\Themes\PlaceHold2.c ===
*********************************************
DO NOT CLOSE THIS WINDOW
*********************************************

This window serves as a point of reference for
this dock.  If you close it, other windows may
not know where to position themselves.

If you want to tab another window against this
dock, it is recommended that you first bring 
this placeholder to the front of the dock.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\Themes\PlaceHold1.c ===
*********************************************
DO NOT CLOSE THIS WINDOW
*********************************************

This window serves as a point of reference for
this dock.  If you close it, other windows may
not know where to position themselves.

If you want to tab another window against this
dock, it is recommended that you first bring 
this placeholder to the front of the dock.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\clipboard.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                              Clipboard Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

value UINT ClipboardFormats
{
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13
#define CF_ENHMETAFILE      14
#define CF_HDROP            15
#define CF_LOCALE           16
#define CF_MAX              17
};

value INT ClipboardStatus
{
#define ClipboardEmpty                  0
#define ClipboardContainsUnknownFormat  -1
};

category Clipboard:

BOOL ChangeClipboardChain(
                          HWND hWndRemove,
                          HWND hWndNewNext);

FailOnFalse [gle] CloseClipboard();

LongFailIfZero [gle] CountClipboardFormats();

FailOnFalse [gle] EmptyClipboard();

LongFailIfZero [gle] EnumClipboardFormats(ClipboardFormats format);

HANDLE [gle] GetClipboardData(ClipboardFormats uFormat);

LongFailIfZero [gle] GetClipboardFormatNameA(UINT        format,
                                             [out] LPSTR lpszFormatName,
                                             int         cchMaxCount);

LongFailIfZero [gle] GetClipboardFormatNameW(UINT         format,
                                             [out] LPWSTR lpszFormatName,
                                             int          cchMaxCount);

DwordFailIfZero [gle] GetClipboardOwner();

DWORD GetClipboardSequenceNumber();

DwordFailIfZero [gle] GetClipboardViewer();

DwordFailIfZero [gle] GetOpenClipboardWindow();

ClipboardStatus [gle] GetPriorityClipboardFormat(ClipboardFormats* paFormatPriorityList,
                                                 int               cFormats);

BOOL [gle] IsClipboardFormatAvailable(ClipboardFormats format);

FailOnFalse [gle] OpenClipboard(HWND hWndNewOwner);

LongFailIfZero [gle] RegisterClipboardFormatA(LPCSTR lpszFormat);

LongFailIfZero [gle] RegisterClipboardFormatW(LPCWSTR lpszFormat);

HANDLE [gle] SetClipboardData(ClipboardFormats uFormat,
                              HANDLE           hMem);

HWND [gle] SetClipboardViewer(HWND hWndNewViewer);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\avifile.h ===
category AVIFileExports:

typedef struct _AVIFILEINFOA {
    DWORD       dwMaxBytesPerSec;   // max. transfer rate
    DWORD       dwFlags;        // the ever-present flags
    DWORD       dwCaps;
    DWORD       dwStreams;
    DWORD       dwSuggestedBufferSize;

    DWORD       dwWidth;
    DWORD       dwHeight;

    DWORD       dwScale;    
    DWORD       dwRate; /* dwRate / dwScale == samples/second */
    DWORD       dwLength;

    DWORD       dwEditCount;

    char        szFileType[64];     // descriptive string for file type?
} AVIFILEINFOA;
typedef AVIFILEINFOA  * LPAVIFILEINFOA;

typedef struct _AVIFILEINFOW {
    DWORD       dwMaxBytesPerSec;   // max. transfer rate
    DWORD       dwFlags;        // the ever-present flags
    DWORD       dwCaps;
    DWORD       dwStreams;
    DWORD       dwSuggestedBufferSize;

    DWORD       dwWidth;
    DWORD       dwHeight;

    DWORD       dwScale;    
    DWORD       dwRate; /* dwRate / dwScale == samples/second */
    DWORD       dwLength;

    DWORD       dwEditCount;

    WCHAR       szFileType[64];     // descriptive string for file type?
} AVIFILEINFOW;
typedef AVIFILEINFOW  * LPAVIFILEINFOW;

typedef DWORD AVIFILE;
typedef DWORD* PAVIFILE;

VOID AVIFileInit();
VOID AVIFileExit();

ULONG AVIFileAddRef(PAVIFILE pfile);
ULONG AVIFileRelease(PAVIFILE pfile);

STDAPI AVIFileOpenA(PAVIFILE* ppfile,  LPCSTR szFile, UINT mode, CLSID pclsidHandler);
STDAPI AVIFileOpenW(PAVIFILE* ppfile,  LPCWSTR szFile, UINT mode, CLSID pclsidHandler);

STDAPI AVIFileInfoA(PAVIFILE pfile, LPAVIFILEINFOA pfi, LONG lSize);
STDAPI AVIFileInfoW(PAVIFILE pfile, LPAVIFILEINFOW pfi, LONG lSize);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\d3d8.h ===
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
//                              D3D8 API Set
//
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

module D3D8.DLL:
category Direct3D:

#include "d3d8types.h"
#include "d3d8caps.h"

//
// GUIDs
//

struct __declspec(uuid("1dd9e8da-1c77-4d40-b0cf-98fefdff9512")) IDirect3D8;
struct __declspec(uuid("7385e5df-8fe8-41d5-86b6-d7b48547b6cf")) IDirect3DDevice8;
struct __declspec(uuid("1b36bb7b-09b7-410a-b445-7d1430d7b33f")) IDirect3DResource8;
struct __declspec(uuid("b4211cfa-51b9-4a9f-ab78-db99b2bb678e")) IDirect3DBaseTexture8;
struct __declspec(uuid("e4cdd575-2866-4f01-b12e-7eece1ec9358")) IDirect3DTexture8;
struct __declspec(uuid("3ee5b968-2aca-4c34-8bb5-7e0c3d19b750")) IDirect3DCubeTexture8;
struct __declspec(uuid("4b8aaafa-140f-42ba-9131-597eafaa2ead")) IDirect3DVolumeTexture8;
struct __declspec(uuid("8aeeeac7-05f9-44d4-b591-000b0df1cb95")) IDirect3DVertexBuffer8;
struct __declspec(uuid("0e689c9a-053d-44a0-9d92-db0e3d750f86")) IDirect3DIndexBuffer8;
struct __declspec(uuid("b96eebca-b326-4ea5-882f-2ff5bae021dd")) IDirect3DSurface8;
struct __declspec(uuid("bd7349f5-14f1-42e4-9c79-972380db40c0")) IDirect3DVolume8;
struct __declspec(uuid("928c088b-76b9-4c6b-a536-a590853876cd")) IDirect3DSwapChain8;


//
// Typedefs
//

typedef IDirect3D8                *LPDIRECT3D8;
typedef IDirect3DDevice8          *LPDIRECT3DDEVICE8;
typedef IDirect3DResource8        *LPDIRECT3DRESOURCE8;
typedef IDirect3DBaseTexture8     *LPDIRECT3DBASETEXTURE8;
typedef IDirect3DTexture8         *LPDIRECT3DTEXTURE8;
typedef IDirect3DVolumeTexture8   *LPDIRECT3DVOLUMETEXTURE8;
typedef IDirect3DCubeTexture8     *LPDIRECT3DCUBETEXTURE8;
typedef IDirect3DVertexBuffer8    *LPDIRECT3DVERTEXBUFFER8;
typedef IDirect3DIndexBuffer8     *LPDIRECT3DINDEXBUFFER8;
typedef IDirect3DSurface8         *LPDIRECT3DSURFACE8;
typedef IDirect3DVolume8          *LPDIRECT3DVOLUME8;
typedef IDirect3DSwapChain8       *LPDIRECT3DSWAPCHAIN8;

typedef IDirect3D8                **LPLPDIRECT3D8;
typedef IDirect3DDevice8          **LPLPDIRECT3DDEVICE8;
typedef IDirect3DResource8        **LPLPDIRECT3DRESOURCE8;
typedef IDirect3DBaseTexture8     **LPLPDIRECT3DBASETEXTURE8;
typedef IDirect3DTexture8         **LPLPDIRECT3DTEXTURE8;
typedef IDirect3DVolumeTexture8   **LPLPDIRECT3DVOLUMETEXTURE8;
typedef IDirect3DCubeTexture8     **LPLPDIRECT3DCUBETEXTURE8;
typedef IDirect3DVertexBuffer8    **LPLPDIRECT3DVERTEXBUFFER8;
typedef IDirect3DIndexBuffer8     **LPLPDIRECT3DINDEXBUFFER8;
typedef IDirect3DSurface8         **LPLPDIRECT3DSURFACE8;
typedef IDirect3DVolume8          **LPLPDIRECT3DVOLUME8;
typedef IDirect3DSwapChain8       **LPLPDIRECT3DSWAPCHAIN8;

alias LPDIRECT3D8;
alias LPDIRECT3DDEVICE8;
alias LPDIRECT3DRESOURCE8;
alias LPDIRECT3DBASETEXTURE8;
alias LPDIRECT3DTEXTURE8;
alias LPDIRECT3DVOLUMETEXTURE8;
alias LPDIRECT3DCUBETEXTURE8;
alias LPDIRECT3DVERTEXBUFFER8;
alias LPDIRECT3DINDEXBUFFER8;
alias LPDIRECT3DSURFACE8;
alias LPDIRECT3DVOLUME8;
alias LPDIRECT3DSWAPCHAIN8;
alias LPLPDIRECT3D8;
alias LPLPDIRECT3DDEVICE8;
alias LPLPDIRECT3DRESOURCE8;
alias LPLPDIRECT3DBASETEXTURE8;
alias LPLPDIRECT3DTEXTURE8;
alias LPLPDIRECT3DVOLUMETEXTURE8;
alias LPLPDIRECT3DCUBETEXTURE8;
alias LPLPDIRECT3DVERTEXBUFFER8;
alias LPLPDIRECT3DINDEXBUFFER8;
alias LPLPDIRECT3DSURFACE8;
alias LPLPDIRECT3DVOLUME8;
alias LPLPDIRECT3DSWAPCHAIN8;

//
// Masks
//

mask DWORD d3dAdaperIdentifierFlags8
{
#define D3DENUM_NO_WHQL_LEVEL                   0x00000002
};

mask DWORD d3dSetPrivateDataFlags8
{
#define D3DSPD_IUNKNOWN                         0x00000001
};

mask DWORD d3dSetCursorPositionFlags8
{
#define D3DCURSOR_IMMEDIATE_UPDATE              0x00000001
};

//
// Values
//

value LONG d3dCreateVersion8
{
#define DX_VERSION_80                           120
#define DX_VERSION_81                           220
};

value UINT d3dMode8
{
#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFF
};

value DWORD d3dSetGammaRamp8
{
#define D3DSGR_NO_CALIBRATION                  0x00000000
#define D3DSGR_CALIBRATE                       0x00000001
};

value DWORD D3DRESULT8
{
#define D3D_OK                                  0
#define D3DERR_WRONGTEXTUREFORMAT               0x88760818 [fail]
#define D3DERR_UNSUPPORTEDCOLOROPERATION        0x88760819 [fail]
#define D3DERR_UNSUPPORTEDCOLORARG              0x8876081a [fail]
#define D3DERR_UNSUPPORTEDALPHAOPERATION        0x8876081b [fail]
#define D3DERR_UNSUPPORTEDALPHAARG              0x8876081c [fail]
#define D3DERR_TOOMANYOPERATIONS                0x8876081d [fail]
#define D3DERR_CONFLICTINGTEXTUREFILTER         0x8876081e [fail]
#define D3DERR_UNSUPPORTEDFACTORVALUE           0x8876081f [fail]
#define D3DERR_CONFLICTINGRENDERSTATE           0x88760821 [fail]
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         0x88760822 [fail]
#define D3DERR_CONFLICTINGTEXTUREPALETTE        0x88760826 [fail]
#define D3DERR_DRIVERINTERNALERROR              0x88760827 [fail]
#define D3DERR_NOTFOUND                         0x88760866 [fail]
#define D3DERR_MOREDATA                         0x88760867 [fail]
#define D3DERR_DEVICELOST                       0x88760868 [fail]
#define D3DERR_DEVICENOTRESET                   0x88760869 [fail]
#define D3DERR_NOTAVAILABLE                     0x8876086a [fail]
#define D3DERR_OUTOFVIDEOMEMORY                 0x8876017c [fail]
#define D3DERR_INVALIDDEVICE                    0x8876086b [fail]
#define D3DERR_INVALIDCALL                      0x8876086c [fail]
#define D3DERR_DRIVERINVALIDCALL                0x8876086d [fail]
};

//
// Functions
//

LPDIRECT3D8 Direct3DCreate8(d3dCreateVersion8 SDKVersion);


//
// Interfaces
//

interface IDirect3D8 : IUnknown
{
    D3DRESULT8 RegisterSoftwareDevice(LPVOID pInitializeFunction);
    UINT       GetAdapterCount();
    D3DRESULT8 GetAdapterIdentifier(d3dAdapterID8 Adapter, d3dAdaperIdentifierFlags8 Flags,[out] LPD3DADAPTER_IDENTIFIER8 pIdentifier);
    UINT       GetAdapterModeCount(d3dAdapterID8 Adapter);
    D3DRESULT8 EnumAdapterModes(d3dAdapterID8 Adapter, d3dMode8 Mode,[out] LPD3DDISPLAYMODE pMode);
    D3DRESULT8 GetAdapterDisplayMode(d3dAdapterID8 Adapter,[out] LPD3DDISPLAYMODE pMode);
    D3DRESULT8 CheckDeviceType(d3dAdapterID8 Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    D3DRESULT8 CheckDeviceFormat(d3dAdapterID8 Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, d3dUsage8 Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
    D3DRESULT8 CheckDeviceMultiSampleType(d3dAdapterID8 Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
    D3DRESULT8 CheckDepthStencilMatch(d3dAdapterID8 Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
    D3DRESULT8 GetDeviceCaps(d3dAdapterID8 Adapter, D3DDEVTYPE DeviceType,[out] LPD3DCAPS8 pCaps);
    HMONITOR   GetAdapterMonitor(d3dAdapterID8 Adapter);
    D3DRESULT8 CreateDevice(d3dAdapterID8 Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, d3dBehaviorFlags8 BehaviorFlags, [out] LPD3DPRESENT_PARAMETERS pPresentationParameters, [out] LPLPDIRECT3DDEVICE8 ppReturnedDeviceInterface);
};

interface IDirect3DDevice8 : IUnknown
{
    D3DRESULT8 TestCooperativeLevel();
    UINT       GetAvailableTextureMem();
    D3DRESULT8 ResourceManagerDiscardBytes(DWORD Bytes);
    D3DRESULT8 GetDirect3D([out] LPLPDIRECT3D8 ppD3D8);
    D3DRESULT8 GetDeviceCaps([out] LPD3DCAPS8 pCaps);
    D3DRESULT8 GetDisplayMode([out] LPD3DDISPLAYMODE pMode);
    D3DRESULT8 GetCreationParameters([out] LPD3DDEVICE_CREATION_PARAMETERS pParameters);
    D3DRESULT8 SetCursorProperties(UINT XHotSpot, UINT YHotSpot, LPDIRECT3DSURFACE8 pCursorBitmap);
    void       SetCursorPosition(UINT XScreenSpace, UINT YScreenSpace, d3dSetCursorPositionFlags8 Flags);
    BOOL       ShowCursor(BOOL bShow);
    D3DRESULT8 CreateAdditionalSwapChain([out] LPD3DPRESENT_PARAMETERS pPresentationParameters,[out] LPLPDIRECT3DSWAPCHAIN8 ppSwapChain);
    D3DRESULT8 Reset([out] LPD3DPRESENT_PARAMETERS pPresentationParameters);
    D3DRESULT8 Present(RECT* pSourceRect, RECT* pDestRect, HWND hDestWindowOverride, RGNDATA* pDirtyRegion);
    D3DRESULT8 GetBackBuffer(UINT BackBuffer, D3DBACKBUFFER_TYPE Type, [out] LPLPDIRECT3DSURFACE8 ppBackBuffer);
    D3DRESULT8 GetRasterStatus(LPD3DRASTER_STATUS pRasterStatus);
    void       SetGammaRamp(d3dSetGammaRamp8 Flags, LPD3DGAMMARAMP pRamp);
    void       GetGammaRamp([out] LPD3DGAMMARAMP pRamp);
    D3DRESULT8 CreateTexture(UINT Width, UINT Height, UINT Levels, d3dUsage8 Usage, D3DFORMAT Format, D3DPOOL Pool, [out] LPLPDIRECT3DTEXTURE8 ppTexture);
    D3DRESULT8 CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, d3dUsage8 Usage, D3DFORMAT Format, D3DPOOL Pool, [out] LPLPDIRECT3DVOLUMETEXTURE8 ppVolumeTexture);
    D3DRESULT8 CreateCubeTexture(UINT EdgeLength, UINT Levels, d3dUsage8 Usage, D3DFORMAT Format, D3DPOOL Pool, [out] LPLPDIRECT3DCUBETEXTURE8 ppCubeTexture);
    D3DRESULT8 CreateVertexBuffer(UINT Length, d3dUsage8 Usage, d3dFVF8 FVF, D3DPOOL Pool, [out] LPLPDIRECT3DVERTEXBUFFER8 ppVertexBuffer);
    D3DRESULT8 CreateIndexBuffer(UINT Length, d3dUsage8 Usage, D3DFORMAT Format, D3DPOOL Pool, [out] LPLPDIRECT3DINDEXBUFFER8 ppIndexBuffer);
    D3DRESULT8 CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, [out] LPLPDIRECT3DSURFACE8 ppSurface);
    D3DRESULT8 CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, [out] LPLPDIRECT3DSURFACE8 ppSurface);
    D3DRESULT8 CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, [out] LPLPDIRECT3DSURFACE8 ppSurface);
    D3DRESULT8 CopyRects(LPDIRECT3DSURFACE8 pSourceSurface, RECT* pSourceRectsArray, UINT cRects, LPDIRECT3DSURFACE8 pDestinationSurface, POINT* pDestPointsArray);
    D3DRESULT8 UpdateTexture(LPDIRECT3DBASETEXTURE8 pSourceTexture, LPDIRECT3DBASETEXTURE8 pDestinationTexture);
    D3DRESULT8 GetFrontBuffer(LPDIRECT3DSURFACE8 pDestSurface);
    D3DRESULT8 SetRenderTarget(LPDIRECT3DSURFACE8 pRenderTarget, LPDIRECT3DSURFACE8 pNewZStencil);
    D3DRESULT8 GetRenderTarget([out] LPLPDIRECT3DSURFACE8 ppRenderTarget);
    D3DRESULT8 GetDepthStencilSurface([out] LPLPDIRECT3DSURFACE8 ppZStencilSurface);
    D3DRESULT8 BeginScene();
    D3DRESULT8 EndScene();
    D3DRESULT8 Clear(UINT Count, LPD3DRECT pRects, d3dClearFlags8 Flags, D3DCOLOR Color, float Z, DWORD Stencil);
    D3DRESULT8 SetTransform(D3DTRANSFORMSTATETYPE8 State, LPD3DMATRIX8 pMatrix);
    D3DRESULT8 GetTransform(D3DTRANSFORMSTATETYPE8 State, [out] LPD3DMATRIX8 pMatrix);
    D3DRESULT8 MultiplyTransform(D3DTRANSFORMSTATETYPE8 State, LPD3DMATRIX8 pMatrix);
    D3DRESULT8 SetViewport(LPD3DVIEWPORT8 pViewport);
    D3DRESULT8 GetViewport([out] LPD3DVIEWPORT8 pViewport);
    D3DRESULT8 SetMaterial(LPD3DMATERIAL8 pMaterial);
    D3DRESULT8 GetMaterial([out] LPD3DMATERIAL8 pMaterial);
    D3DRESULT8 SetLight(DWORD Index, LPD3DLIGHT8 pLight);
    D3DRESULT8 GetLight(DWORD Index, [out] LPD3DLIGHT8 pLight);
    D3DRESULT8 LightEnable(DWORD Index, BOOL Enable);
    D3DRESULT8 GetLightEnable(DWORD Index, [out] BOOL* pEnable);
    D3DRESULT8 SetClipPlane(DWORD Index, float* pPlane);
    D3DRESULT8 GetClipPlane(DWORD Index, [out] float* pPlane);
    D3DRESULT8 SetRenderState(D3DRENDERSTATETYPE8 State, DWORD Value);
    D3DRESULT8 GetRenderState(D3DRENDERSTATETYPE8 State, [out] LPDWORD pValue);
    D3DRESULT8 BeginStateBlock();
    D3DRESULT8 EndStateBlock([out] LPDWORD pToken);
    D3DRESULT8 ApplyStateBlock(DWORD Token);
    D3DRESULT8 CaptureStateBlock(DWORD Token);
    D3DRESULT8 DeleteStateBlock(DWORD Token);
    D3DRESULT8 CreateStateBlock(D3DSTATEBLOCKTYPE8 Type, [out] LPDWORD pToken);
    D3DRESULT8 SetClipStatus(LPD3DCLIPSTATUS8 pClipStatus);
    D3DRESULT8 GetClipStatus([out] LPD3DCLIPSTATUS8 pClipStatus);
    D3DRESULT8 GetTexture(DWORD Stage, [out] LPLPDIRECT3DBASETEXTURE8 ppTexture);
    D3DRESULT8 SetTexture(DWORD Stage, LPDIRECT3DBASETEXTURE8 pTexture);
    D3DRESULT8 GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE8 Type, [out] LPDWORD pValue);
    D3DRESULT8 SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE8 Type, DWORD Value);
    D3DRESULT8 ValidateDevice([out] LPDWORD pNumPasses);
    D3DRESULT8 GetInfo(DWORD DevInfoID, [out] LPVOID pDevInfoStruct, DWORD DevInfoStructSize);
    D3DRESULT8 SetPaletteEntries(UINT PaletteNumber, PALETTEENTRY* pEntries);
    D3DRESULT8 GetPaletteEntries(UINT PaletteNumber, [out] PALETTEENTRY* pEntries);
    D3DRESULT8 SetCurrentTexturePalette(UINT PaletteNumber);
    D3DRESULT8 GetCurrentTexturePalette([out] UINT *PaletteNumber);
    D3DRESULT8 DrawPrimitive(D3DPRIMITIVETYPE8 PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
    D3DRESULT8 DrawIndexedPrimitive(D3DPRIMITIVETYPE8 PrimitiveType, UINT minIndex, UINT NumVertices, UINT startIndex, UINT primCount);
    D3DRESULT8 DrawPrimitiveUP(D3DPRIMITIVETYPE8 PrimitiveType, UINT PrimitiveCount, LPVOID pVertexStreamZeroData, UINT VertexStreamZeroStride);
    D3DRESULT8 DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE8 PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, LPVOID pIndexData, D3DFORMAT IndexDataFormat, LPVOID pVertexStreamZeroData, UINT VertexStreamZeroStride);
    D3DRESULT8 ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, LPDIRECT3DVERTEXBUFFER8 pDestBuffer, d3dProcessVerticesFlags Flags);
    D3DRESULT8 CreateVertexShader(LPDWORD pDeclaration, LPDWORD pFunction, [out] LPDWORD pHandle, d3dUsage8 Usage);
    D3DRESULT8 SetVertexShader(DWORD Handle);                 // let's not use fvf here - VB fvf can be seen in CreateVB
    D3DRESULT8 GetVertexShader([out] LPDWORD pHandle);
    D3DRESULT8 DeleteVertexShader(DWORD Handle);
    D3DRESULT8 SetVertexShaderConstant(DWORD Register, LPVOID pConstantData, DWORD ConstantCount);
    D3DRESULT8 GetVertexShaderConstant(DWORD Register, [out] LPVOID pConstantData, DWORD ConstantCount);
    D3DRESULT8 GetVertexShaderDeclaration(DWORD Handle, [out] LPVOID pData, [out] LPDWORD pSizeOfData);
    D3DRESULT8 GetVertexShaderFunction(DWORD Handle, [out] LPVOID pData, [out] LPDWORD pSizeOfData);
    D3DRESULT8 SetStreamSource(UINT StreamNumber, LPDIRECT3DVERTEXBUFFER8 pStreamData, UINT Stride);
    D3DRESULT8 GetStreamSource(UINT StreamNumber, [out] LPLPDIRECT3DVERTEXBUFFER8 ppStreamData, [out] UINT* pStride);
    D3DRESULT8 SetIndices(LPDIRECT3DINDEXBUFFER8 pIndexData, UINT BaseVertexIndex);
    D3DRESULT8 GetIndices([out] LPLPDIRECT3DINDEXBUFFER8 ppIndexData, [out] UINT* pBaseVertexIndex);
    D3DRESULT8 CreatePixelShader(LPDWORD pFunction, [out] LPDWORD pHandle);
    D3DRESULT8 SetPixelShader(DWORD Handle);
    D3DRESULT8 GetPixelShader([out] LPDWORD pHandle);
    D3DRESULT8 DeletePixelShader(DWORD Handle);
    D3DRESULT8 SetPixelShaderConstant(DWORD Register, LPVOID pConstantData, DWORD ConstantCount);
    D3DRESULT8 GetPixelShaderConstant(DWORD Register, [out] LPVOID pConstantData, DWORD ConstantCount);
    D3DRESULT8 GetPixelShaderFunction(DWORD Handle, [out] LPVOID pData, [out] LPDWORD pSizeOfData);
    D3DRESULT8 DrawRectPatch(UINT Handle, float* pNumSegs, LPD3DRECTPATCH_INFO pRectPatchInfo);
    D3DRESULT8 DrawTriPatch(UINT Handle, float* pNumSegs, LPD3DTRIPATCH_INFO pTriPatchInfo);
    D3DRESULT8 DeletePatch(UINT Handle);
};


interface IDirect3DResource8 : IUnknown
{
    D3DRESULT8 GetDevice([out] LPLPDIRECT3DDEVICE8 ppDevice);
    D3DRESULT8 SetPrivateData(REFGUID refguid, LPVOID pData, DWORD SizeOfData, d3dSetPrivateDataFlags8 Flags);
    D3DRESULT8 GetPrivateData(REFGUID refguid, LPVOID pData,[out] LPDWORD pSizeOfData);
    D3DRESULT8 FreePrivateData(REFGUID refguid);
    DWORD      SetPriority(DWORD PriorityNew);
    DWORD      GetPriority();
    void       PreLoad();
    D3DRESOURCETYPE GetType();
};

interface IDirect3DBaseTexture8 : IDirect3DResource8
{
    DWORD      SetLOD(DWORD LODNew);
    DWORD      GetLOD();
    DWORD      GetLevelCount();
};

interface IDirect3DTexture8 : IDirect3DBaseTexture8
{
    D3DRESULT8 GetLevelDesc(UINT Level, [out] LPD3DSURFACE_DESC pDesc);
    D3DRESULT8 GetSurfaceLevel(UINT Level, [out] LPLPDIRECT3DSURFACE8 ppSurfaceLevel);
    D3DRESULT8 LockRect(UINT Level, [out] LPD3DLOCKED_RECT pLockedRect, RECT* pRect, d3dLockFlags8 Flags);
    D3DRESULT8 UnlockRect(UINT Level);
    D3DRESULT8 AddDirtyRect(RECT* pDirtyRect);
};

interface IDirect3DVolumeTexture8 : IDirect3DBaseTexture8
{
    D3DRESULT8 GetLevelDesc(UINT Level, [out] LPD3DVOLUME_DESC pDesc);
    D3DRESULT8 GetVolumeLevel(UINT Level, [out] LPLPDIRECT3DVOLUME8 ppVolumeLevel);
    D3DRESULT8 LockBox(UINT Level, [out] LPD3DLOCKED_BOX pLockedVolume, LPD3DBOX pBox, d3dLockFlags8 Flags);
    D3DRESULT8 UnlockBox(UINT Level);
    D3DRESULT8 AddDirtyBox(LPD3DBOX pDirtyBox);
};

interface IDirect3DCubeTexture8 : IDirect3DBaseTexture8
{
    D3DRESULT8 GetLevelDesc(UINT Level, [out] LPD3DSURFACE_DESC pDesc);
    D3DRESULT8 GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, [out] LPLPDIRECT3DSURFACE8 ppCubeMapSurface);
    D3DRESULT8 LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, [out] LPD3DLOCKED_RECT pLockedRect, RECT* pRect, d3dLockFlags8 Flags);
    D3DRESULT8 UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level);
    D3DRESULT8 AddDirtyRect(D3DCUBEMAP_FACES FaceType, RECT* pDirtyRect);
};

interface IDirect3DVertexBuffer8 : IDirect3DResource8
{
    D3DRESULT8 Lock(UINT OffsetToLock, UINT SizeToLock, [out] BYTE** ppbData, d3dLockFlags8 Flags);
    D3DRESULT8 Unlock();
    D3DRESULT8 GetDesc([out] LPD3DVERTEXBUFFER_DESC pDesc);
};

interface IDirect3DIndexBuffer8 : IDirect3DResource8
{
    D3DRESULT8 Lock(UINT OffsetToLock, UINT SizeToLock, [out] BYTE** ppbData, d3dLockFlags8 Flags);
    D3DRESULT8 Unlock();
    D3DRESULT8 GetDesc([out] LPD3DINDEXBUFFER_DESC pDesc);
};

interface IDirect3DSurface8 : IUnknown
{
    D3DRESULT8 GetDevice([out] LPLPDIRECT3DDEVICE8 ppDevice);
    D3DRESULT8 SetPrivateData(REFGUID refguid, LPVOID pData, DWORD SizeOfData, d3dSetPrivateDataFlags8 Flags);
    D3DRESULT8 GetPrivateData(REFGUID refguid, LPVOID pData, [out] LPDWORD pSizeOfData);
    D3DRESULT8 FreePrivateData(REFGUID refguid);
    D3DRESULT8 GetContainer(REFIID riid, [out] LPVOID* ppContainer);
    D3DRESULT8 GetDesc([out] LPD3DSURFACE_DESC pDesc);
    D3DRESULT8 LockRect([out] LPD3DLOCKED_RECT pLockedRect, RECT* pRect, d3dLockFlags8 Flags);
    D3DRESULT8 UnlockRect();
};

interface IDirect3DVolume8 : IUnknown
{
    D3DRESULT8 GetDevice([out] LPLPDIRECT3DDEVICE8 ppDevice);
    D3DRESULT8 SetPrivateData(REFGUID refguid, LPVOID pData, DWORD SizeOfData, d3dSetPrivateDataFlags8 Flags);
    D3DRESULT8 GetPrivateData(REFGUID refguid, LPVOID pData, [out] LPDWORD pSizeOfData);
    D3DRESULT8 FreePrivateData(REFGUID refguid);
    D3DRESULT8 GetContainer(REFIID riid, [out] LPVOID* ppContainer);
    D3DRESULT8 GetDesc([out] LPD3DVOLUME_DESC pDesc);
    D3DRESULT8 LockBox([out] LPD3DLOCKED_BOX pLockedVolume, LPD3DBOX pBox, d3dLockFlags8 Flags);
    D3DRESULT8 UnlockBox();
};

interface IDirect3DSwapChain8 : IUnknown
{
    D3DRESULT8 Present(RECT* pSourceRect, RECT* pDestRect, HWND hDestWindowOverride, RGNDATA* pDirtyRegion);
    D3DRESULT8 GetBackBuffer(UINT BackBuffer, D3DBACKBUFFER_TYPE Type, [out] LPLPDIRECT3DSURFACE8 ppBackBuffer);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\advapi32.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                              AdvApi32 Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category AdvApi32:


module ADVAPI32.DLL:

typedef PVOID PSID;

typedef ULONG SECURITY_INFORMATION;
typedef SECURITY_INFORMATION *PSECURITY_INFORMATION;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef PVOID PGENERIC_MAPPING;
typedef PVOID PPRIVILEGE_SET;

value int SidNameUse
{
#define SidTypeUser                     1
#define SidTypeGroup                    2
#define SidTypeDomain                   3
#define SidTypeAlias                    4
#define SidTypeWellKnownGroup           5
#define SidTypeDeletedAccount           6
#define SidTypeInvalid                  7
#define SidTypeUnknown                  8
#define SidTypeComputer                 9
};

typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;

FailOnFalse [gle] AccessCheck([in] PSECURITY_DESCRIPTOR pSecurityDescriptor,
                              [in] HANDLE ClientToken,
                              [in] DWORD DesiredAccess,
                              [in] PGENERIC_MAPPING GenericMapping,
                              [out] PPRIVILEGE_SET PrivilegeSet,
                              [out] LPDWORD PrivilegeSetLength,
                              [out] LPDWORD GrantedAccess,
                              [out] LPBOOL AccessStatus);

FailOnFalse [gle] AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
                                           BYTE nSubAuthorityCount,
                                           DWORD nSubAuthority0,
                                           DWORD nSubAuthority1,
                                           DWORD nSubAuthority2,
                                           DWORD nSubAuthority3,
                                           DWORD nSubAuthority4,
                                           DWORD nSubAuthority5,
                                           DWORD nSubAuthority6,
                                           DWORD nSubAuthority7,
                                           [out] PSID* pSid);

FailOnFalse [gle] EqualSid(PSID pSid1,
                           PSID pSid2);

FailOnFalse [gle] GetFileSecurityA(LPCSTR lpFileName,
                                   SECURITY_INFORMATION RequestedInformation,
                                   [out] PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                   DWORD nLength,
                                   [out] LPDWORD lpnLengthNeeded);

FailOnFalse [gle] GetFileSecurityW(LPCWSTR lpFileName,
                                   SECURITY_INFORMATION RequestedInformation,
                                   [out] PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                   DWORD nLength,
                                   [out] LPDWORD lpnLengthNeeded);

FailOnFalse [gle] GetKernelObjectSecurity(HANDLE Handle,
                                          SECURITY_INFORMATION RequestedInformation,
                                          [out] PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                          DWORD nLength,
                                          [out] LPDWORD lpnLengthNeeded);

DWORD GetLengthSid(PSID pSid);

FailOnFalse [gle] GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                             [out] PSID *pGroup,
                                             [out] LPBOOL lpbGroupDefaulted);

FailOnFalse [gle] GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                             [out] PSID *pOwner,
                                             [out] LPBOOL lpbOwnerDefaulted);

PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid);

PDWORD GetSidSubAuthority(PSID pSid,
                          DWORD nSubAuthority);

PBYTE GetSidSubAuthorityCount(PSID pSid);

FailOnFalse IsValidSid(PSID pSid);

FailOnFalse [gle] LookupAccountNameA(LPCSTR lpSystemName,
                                     LPCSTR lpAccountName,
                                     [out] PSID Sid,
                                     [out] LPDWORD cbSid,
                                     [out] LPSTR ReferencedDomainName,
                                     [out] LPDWORD cbReferencedDomainName,
                                     [out] SidNameUse* peUse);

FailOnFalse [gle] LookupAccountNameW(LPCWSTR lpSystemName,
                                     LPCWSTR lpAccountName,
                                     [out] PSID Sid,
                                     [out] LPDWORD cbSid,
                                     [out] LPWSTR ReferencedDomainName,
                                     [out] LPDWORD cbReferencedDomainName,
                                     [out] SidNameUse* peUse);

FailOnFalse [gle] LookupAccountSidA(LPCSTR lpSystemName,
                                    PSID Sid,
                                    [out] LPSTR Name,
                                    [out] LPDWORD cbName,
                                    [out] LPSTR ReferencedDomainName,
                                    [out] LPDWORD cbReferencedDomainName,
                                    [out] SidNameUse* peUse);

FailOnFalse [gle] LookupAccountSidW(LPCWSTR lpSystemName,
                                    PSID Sid,
                                    [out] LPWSTR Name,
                                    [out] LPDWORD cbName,
                                    [out] LPWSTR ReferencedDomainName,
                                    [out] LPDWORD cbReferencedDomainName,
                                    [out] SidNameUse* peUse);

// ------------------------------------------------------------
//
//                       Services functions
//
// ------------------------------------------------------------

//
// Value to indicate no change to an optional parameter
//


//
// Service Types (Bit Mask)
//
mask DWORD ServiceType
{
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

};


//
// Start Type
//

value DWORD ServiceStartType
{
#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004
};

//
// Error control type
//
value DWORD ServiceErrorControlType
{
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003
};

//
// Service State -- for Enum Requests (Bit Mask)
//

value DWORD ServiceState
{
#define SERVICE_ACTIVE                 0x00000001
#define SERVICE_INACTIVE               0x00000002
#define SERVICE_STATE_ALL              0x00000003
#define SERVICE_NO_CHANGE              0xffffffff
};

//
// Controls
//
value DWORD ServiceControl
{
#define SERVICE_CONTROL_STOP                   0x00000001
#define SERVICE_CONTROL_PAUSE                  0x00000002
#define SERVICE_CONTROL_CONTINUE               0x00000003
#define SERVICE_CONTROL_INTERROGATE            0x00000004
#define SERVICE_CONTROL_SHUTDOWN               0x00000005
#define SERVICE_CONTROL_PARAMCHANGE            0x00000006
#define SERVICE_CONTROL_NETBINDADD             0x00000007
#define SERVICE_CONTROL_NETBINDREMOVE          0x00000008
#define SERVICE_CONTROL_NETBINDENABLE          0x00000009
#define SERVICE_CONTROL_NETBINDDISABLE         0x0000000A
#define SERVICE_CONTROL_DEVICEEVENT            0x0000000B
#define SERVICE_CONTROL_HARDWAREPROFILECHANGE  0x0000000C
#define SERVICE_CONTROL_POWEREVENT             0x0000000D
#define SERVICE_CONTROL_SESSIONCHANGE          0x0000000E
};

//
// Service State -- for CurrentState
//
value DWORD ServiceCurrentState
{
#define SERVICE_STOPPED                        0x00000001
#define SERVICE_START_PENDING                  0x00000002
#define SERVICE_STOP_PENDING                   0x00000003
#define SERVICE_RUNNING                        0x00000004
#define SERVICE_CONTINUE_PENDING               0x00000005
#define SERVICE_PAUSE_PENDING                  0x00000006
#define SERVICE_PAUSED                         0x00000007
};

//
// Controls Accepted  (Bit Mask)
//
mask DWORD ServiceControlsAccepted
{
#define SERVICE_ACCEPT_STOP                    0x00000001
#define SERVICE_ACCEPT_PAUSE_CONTINUE          0x00000002
#define SERVICE_ACCEPT_SHUTDOWN                0x00000004
#define SERVICE_ACCEPT_PARAMCHANGE             0x00000008
#define SERVICE_ACCEPT_NETBINDCHANGE           0x00000010
#define SERVICE_ACCEPT_HARDWAREPROFILECHANGE   0x00000020
#define SERVICE_ACCEPT_POWEREVENT              0x00000040
#define SERVICE_ACCEPT_SESSIONCHANGE           0x00000080
};

//
// Service Control Manager object specific access types
//
mask DWORD SCManagerAccess
{
#define SC_MANAGER_CONNECT             0x0001
#define SC_MANAGER_CREATE_SERVICE      0x0002
#define SC_MANAGER_ENUMERATE_SERVICE   0x0004
#define SC_MANAGER_LOCK                0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS   0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG  0x0020
};

//
// Service object specific access type
//
mask DWORD ServiceObjectAccess
{
#define SERVICE_QUERY_CONFIG           0x0001
#define SERVICE_CHANGE_CONFIG          0x0002
#define SERVICE_QUERY_STATUS           0x0004
#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
#define SERVICE_START                  0x0010
#define SERVICE_STOP                   0x0020
#define SERVICE_PAUSE_CONTINUE         0x0040
#define SERVICE_INTERROGATE            0x0080
#define SERVICE_USER_DEFINED_CONTROL   0x0100
};

//
// Service flags for QueryServiceStatusEx
//
mask DWORD QueryServiceStatusExFlags
{
#define SERVICE_RUNS_IN_SYSTEM_PROCESS  0x00000001
};

//
// Info levels for ChangeServiceConfig2 and QueryServiceConfig2
//
value LONG ServiceConfig2Values
{
#define SERVICE_CONFIG_DESCRIPTION     1
#define SERVICE_CONFIG_FAILURE_ACTIONS 2
};

//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR       lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;

//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR      lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;

//
// Actions to take on service failure
//
value LONG SC_ACTION_TYPE
{
#define SC_ACTION_NONE          0
#define SC_ACTION_RESTART       1
#define SC_ACTION_REBOOT        2
#define SC_ACTION_RUN_COMMAND   3
};

typedef struct _SC_ACTION {
    SC_ACTION_TYPE  Type;
    DWORD           Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD       dwResetPeriod;
    LPSTR       lpRebootMsg;
    LPSTR       lpCommand;
    DWORD       cActions;
    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;

typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD       dwResetPeriod;
    LPWSTR      lpRebootMsg;
    LPWSTR      lpCommand;
    DWORD       cActions;
    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;

typedef    HANDLE SC_HANDLE;
typedef    SC_HANDLE *LPSC_HANDLE ;
typedef  HANDLE SERVICE_STATUS_HANDLE;

//
// Info levels for QueryServiceStatusEx
//

value LONG SC_STATUS_TYPE
{
#define SC_STATUS_PROCESS_INFO      0
};

//
// Info levels for EnumServicesStatusEx
//
value LONG SC_ENUM_TYPE
{
#define SC_ENUM_PROCESS_INFO      0
};

//
// Service Status Structures
//

typedef struct _SERVICE_STATUS {
    ServiceType   dwServiceType;
    ServiceCurrentState   dwCurrentState;
    ServiceControlsAccepted   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    ServiceType   dwServiceType;
    ServiceCurrentState   dwCurrentState;
    ServiceControlsAccepted   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
    DWORD   dwProcessId;
    DWORD   dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;

//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR             lpServiceName;
    LPSTR             lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR            lpServiceName;
    LPWSTR            lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;

typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR                     lpServiceName;
    LPSTR                     lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR                    lpServiceName;
    LPWSTR                    lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;

//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;

//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    ServiceType   dwServiceType;
    ServiceStartType   dwStartType;
    ServiceErrorControlType   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    ServiceType   dwServiceType;
    ServiceStartType   dwStartType;
    ServiceErrorControlType   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;

//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPVOID    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPVOID    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;


BOOL

ChangeServiceConfigA(
    SC_HANDLE    hService,
    ServiceType        dwServiceType,
    ServiceStartType        dwStartType,
    ServiceErrorControlType        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    [out] LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword,
    LPCSTR     lpDisplayName
    );

BOOL

ChangeServiceConfigW(
    SC_HANDLE    hService,
    ServiceType        dwServiceType,
    ServiceStartType        dwStartType,
    ServiceErrorControlType        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    [out] LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword,
    LPCWSTR     lpDisplayName
    );


BOOL

ChangeServiceConfig2A(
    SC_HANDLE    hService,
    ServiceConfig2Values        dwInfoLevel,
    LPVOID       lpInfo
    );

BOOL

ChangeServiceConfig2W(
    SC_HANDLE    hService,
    ServiceConfig2Values        dwInfoLevel,
    LPVOID       lpInfo
    );


BOOL

CloseServiceHandle(
    SC_HANDLE   hSCObject
    );


BOOL

ControlService(
    SC_HANDLE           hService,
    ServiceControl               dwControl,
    LPSERVICE_STATUS    lpServiceStatus
    );


SC_HANDLE

CreateServiceA(
    SC_HANDLE    hSCManager,
    LPCSTR     lpServiceName,
    LPCSTR     lpDisplayName,
    AccessMode        dwDesiredAccess,
    ServiceType        dwServiceType,
    ServiceStartType        dwStartType,
    ServiceErrorControlType        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    [out] LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword
    );

SC_HANDLE

CreateServiceW(
    SC_HANDLE    hSCManager,
    LPCWSTR     lpServiceName,
    LPCWSTR     lpDisplayName,
    AccessMode        dwDesiredAccess,
    ServiceType        dwServiceType,
    ServiceStartType        dwStartType,
    ServiceErrorControlType        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    [out] LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword
    );


BOOL

DeleteService(
    SC_HANDLE   hService
    );


BOOL

EnumDependentServicesA(
    SC_HANDLE               hService,
    ServiceState            dwServiceState,
    [out] LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    [out] LPDWORD                 pcbBytesNeeded,
    [out] LPDWORD                 lpServicesReturned
    );

BOOL

EnumDependentServicesW(
    SC_HANDLE               hService,
    ServiceState                   dwServiceState,
    [out] LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    [out] LPDWORD                 pcbBytesNeeded,
    [out] LPDWORD                 lpServicesReturned
    );


BOOL

EnumServicesStatusA(
    SC_HANDLE               hSCManager,
    ServiceType                   dwServiceType,
    ServiceState                   dwServiceState,
    [out] LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    [out] LPDWORD                 pcbBytesNeeded,
    [out] LPDWORD                 lpServicesReturned,
    [out] LPDWORD                 lpResumeHandle
    );

BOOL

EnumServicesStatusW(
    SC_HANDLE               hSCManager,
    ServiceType                   dwServiceType,
    ServiceState                   dwServiceState,
    [out] LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    [out] LPDWORD                 pcbBytesNeeded,
    [out] LPDWORD                 lpServicesReturned,
    [out] LPDWORD                 lpResumeHandle
    );


BOOL

EnumServicesStatusExA(
    SC_HANDLE                  hSCManager,
    SC_ENUM_TYPE               InfoLevel,
    ServiceType                      dwServiceType,
    ServiceState                      dwServiceState,
    LPBYTE                     lpServices,
    DWORD                      cbBufSize,
    [out] LPDWORD                    pcbBytesNeeded,
    [out] LPDWORD                    lpServicesReturned,
    [out] LPDWORD                    lpResumeHandle,
    LPCSTR                   pszGroupName
    );

BOOL

EnumServicesStatusExW(
    SC_HANDLE                  hSCManager,
    SC_ENUM_TYPE               InfoLevel,
    ServiceType                      dwServiceType,
    ServiceState                      dwServiceState,
    LPBYTE                     lpServices,
    DWORD                      cbBufSize,
    [out] LPDWORD                    pcbBytesNeeded,
    [out] LPDWORD                    lpServicesReturned,
    [out] LPDWORD                    lpResumeHandle,
    LPCWSTR                   pszGroupName
    );


BOOL

GetServiceKeyNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpDisplayName,
    [out] LPSTR                 lpServiceName,
    [out] LPDWORD                 lpcchBuffer
    );

BOOL

GetServiceKeyNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpDisplayName,
    [out] LPWSTR                 lpServiceName,
    [out] LPDWORD                 lpcchBuffer
    );


BOOL

GetServiceDisplayNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpServiceName,
    [out] LPSTR                 lpDisplayName,
    [out] LPDWORD                 lpcchBuffer
    );

BOOL

GetServiceDisplayNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpServiceName,
    [out] LPWSTR                 lpDisplayName,
    [out] LPDWORD                 lpcchBuffer
    );


SC_LOCK

LockServiceDatabase(
    SC_HANDLE   hSCManager
    );


BOOL

NotifyBootConfigStatus(
    BOOL     BootAcceptable
    );


SC_HANDLE

OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    AccessMode   dwDesiredAccess
    );

SC_HANDLE

OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    AccessMode   dwDesiredAccess
    );


SC_HANDLE

OpenServiceA(
    SC_HANDLE   hSCManager,
    LPCSTR    lpServiceName,
    AccessMode       dwDesiredAccess
    );

SC_HANDLE

OpenServiceW(
    SC_HANDLE   hSCManager,
    LPCWSTR    lpServiceName,
    AccessMode       dwDesiredAccess
    );


BOOL

QueryServiceConfigA(
    SC_HANDLE               hService,
    [out] LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD                   cbBufSize,
    [out] LPDWORD                 pcbBytesNeeded
    );

BOOL

QueryServiceConfigW(
    SC_HANDLE               hService,
    [out] LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD                   cbBufSize,
    [out] LPDWORD                 pcbBytesNeeded
    );


BOOL

QueryServiceConfig2A(
    SC_HANDLE   hService,
    ServiceConfig2Values       dwInfoLevel,
    LPBYTE      lpBuffer,
    DWORD       cbBufSize,
    [out] LPDWORD     pcbBytesNeeded
    );

BOOL

QueryServiceConfig2W(
    SC_HANDLE   hService,
    ServiceConfig2Values       dwInfoLevel,
    LPBYTE      lpBuffer,
    DWORD       cbBufSize,
    LPDWORD     pcbBytesNeeded
    );


BOOL

QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    [OUT] LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    [OUT] LPDWORD                         pcbBytesNeeded
    );

BOOL

QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    [OUT] LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    [OUT] LPDWORD                         pcbBytesNeeded
    );


BOOL

QueryServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    [OUT] PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
    DWORD                   cbBufSize,
    [OUT] LPDWORD                 pcbBytesNeeded
    );


BOOL

QueryServiceStatus(
    SC_HANDLE           hService,
    [OUT] LPSERVICE_STATUS    lpServiceStatus
    );


BOOL

QueryServiceStatusEx(
    SC_HANDLE           hService,
    SC_STATUS_TYPE      InfoLevel,
    LPBYTE              lpBuffer,
    DWORD               cbBufSize,
    [OUT] LPDWORD             pcbBytesNeeded
    );


SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerA(
    LPCSTR             lpServiceName,
    LPVOID   lpHandlerProc
    );

SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerW(
    LPCWSTR             lpServiceName,
    LPVOID   lpHandlerProc
    );


SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerExA(
    LPCSTR                lpServiceName,
    LPVOID   lpHandlerProc,
    LPVOID                  lpContext
    );

SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerExW(
    LPCWSTR                lpServiceName,
    LPVOID   lpHandlerProc,
    LPVOID                  lpContext
    );


BOOL

SetServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    [OUT] PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );


BOOL

SetServiceStatus(
    SERVICE_STATUS_HANDLE   hServiceStatus,
    LPSERVICE_STATUS        lpServiceStatus
    );


BOOL

StartServiceCtrlDispatcherA(
    SERVICE_TABLE_ENTRYA *lpServiceStartTable
    );

BOOL

StartServiceCtrlDispatcherW(
    SERVICE_TABLE_ENTRYW *lpServiceStartTable
    );



BOOL

StartServiceA(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCSTR             *lpServiceArgVectors
    );

BOOL

StartServiceW(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCWSTR             *lpServiceArgVectors
    );

BOOL
UnlockServiceDatabase(
    SC_LOCK     ScLock
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\com.h ===
category ComponentObjectModel:

interface IUnknown
{
    HRESULT QueryInterface(
        [IID] REFIID iid,
        [out] COM_INTERFACE_PTR* ppvObject );
    
    ULONG AddRef(); 
    ULONG Release();
};

typedef IUnknown* LPUNKNOWN;

interface IClassFactory : IUnknown
{
    HRESULT CreateInstance(
        IUnknown * pUnkOuter,
        [IID] REFIID riid,
        [out] COM_INTERFACE_PTR* ppvObject );
    
    HRESULT LockServer( BOOL fLock );
};

interface IDispatch : IUnknown
{
    HRESULT GetTypeInfoCount( UINT pctinfo  );
    
    HRESULT GetTypeInfo(
        UINT iTInfo,
        LCID lcid,
        LPVOID ppTInfo );
    
    HRESULT GetIDsOfNames(
        REFIID riid,
        LPOLECHAR* rgszNames,
        UINT cNames,
        LCID lcid,
        [out] DISPID* rgDispId );
    
    HRESULT Invoke( 
        DISPID  dispIdMember,      
        REFIID  riid,              
        LCID  lcid,                
        WORD  wFlags,              
        DISPPARAMS*  pDispParams,  
        VARIANT*  pVarResult,  
        EXCEPINFO*  pExcepInfo,  
        UINT*  puArgErr );
};


interface IPersist : IUnknown
{
    HRESULT GetClassID(
        [out] CLSID *pClassID  //Pointer to CLSID of object
    );
};

interface IPersistFile : IPersist
{
    HRESULT IsDirty();

    HRESULT Load(
      LPCOLESTR pszFileName, 
                    //Pointer to absolute path of the file to open
      DWORD dwMode  //Specifies the access mode from the STGM enumeration
    );

    HRESULT Save(
      LPCOLESTR pszFileName,   //Pointer to absolute path of the file 
                               //where the object is saved
      BOOL fRemember           //Specifies whether the file is to be the 
                               //current working file or not
    );

    HRESULT SaveCompleted(
      LPCOLESTR pszFileName  //Pointer to absolute path of the file 
                             //where the object was saved
    );

    HRESULT GetCurFile(
      LPOLESTR *ppszFileName  //Pointer to the path for the current file 
                              //or the default save prompt
    );
};
 
 
// We can't log IMalloc because it is a global object.
// It causes recursion problems in LogProcessHook because
// StringFromCLSID uses the global interface.
/*
interface IMalloc : IUnknown
{
    PVOID   Alloc( SIZE_T cb );
    
    PVOID   Realloc( 
        PVOID pv,
        SIZE_T cb );
    
    VOID    Free( PVOID pv);
    
    SIZE_T  GetSize( PVOID pv );
    
    int     DidAlloc( PVOID pv );
    
    VOID    HeapMinimize();
    
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\d3d.h ===
module D3D.DLL:
category Direct3D:

#include "d3dtypes.h"
#include "d3dcaps.h"

//
// GUIDs
//

struct __declspec(uuid("64108800-957D-11D0-89AB-00A0C9054129")) IDirect3DDevice;
struct __declspec(uuid("2CDCD9E0-25A0-11CF-A31A-00AA00B93356")) IDirect3DTexture;
struct __declspec(uuid("93281500-8CF8-11D0-89AB-00A0C9054129")) IDirect3DViewport2;
struct __declspec(uuid("6AAE1EC1-662A-11D0-889D-00AA00BBB76A")) IDirect3D2;
struct __declspec(uuid("B0AB3B61-33D7-11D1-A981-00C04FD7B174")) IDirect3DViewport3;
struct __declspec(uuid("F5049E78-4861-11D2-A407-00A0C90629A8")) IDirect3DTnLHalDevice;
struct __declspec(uuid("BB223240-E72B-11D0-A9B4-00AA00C0993E")) IDirect3D3;
struct __declspec(uuid("F5049E77-4861-11D2-A407-00A0C90629A8")) IDirect3D7;
struct __declspec(uuid("7A503555-4A83-11D1-A5DB-00A0C90367F8")) IDirect3DVertexBuffer;
struct __declspec(uuid("4417C142-33AD-11CF-816F-0000C020156E")) IDirect3DLight;
struct __declspec(uuid("4417C146-33AD-11CF-816F-0000C020156E")) IDirect3DViewport;
struct __declspec(uuid("3BBA0080-2421-11CF-A31A-00AA00B93356")) IDirect3D;
struct __declspec(uuid("F2086B20-259F-11CF-A31A-00AA00B93356")) IDirect3DRampDevice;
struct __declspec(uuid("93281503-8CF8-11D0-89AB-00A0C9054129")) IDirect3DMaterial2;
struct __declspec(uuid("CA9C46F4-D3C5-11D1-B75A-00600852B312")) IDirect3DMaterial3;
struct __declspec(uuid("881949A1-D6F3-11D0-89AB-00A0C9054129")) IDirect3DMMXDevice;
struct __declspec(uuid("93281501-8CF8-11D0-89AB-00A0C9054129")) IDirect3DDevice2;
struct __declspec(uuid("B0AB3B60-33D7-11D1-A981-00C04FD7B174")) IDirect3DDevice3;
struct __declspec(uuid("93281502-8CF8-11D0-89AB-00A0C9054129")) IDirect3DTexture2;
struct __declspec(uuid("84E63DE0-46AA-11CF-816F-0000C020156E")) IDirect3DHALDevice;
struct __declspec(uuid("F5049E79-4861-11D2-A407-00A0C90629A8")) IDirect3DDevice7;
struct __declspec(uuid("8767DF22-BACC-11D1-8969-00A0C90629A8")) IDirect3DNullDevice;
struct __declspec(uuid("A4665C60-2673-11CF-A31A-00AA00B93356")) IDirect3DRGBDevice;
struct __declspec(uuid("4417C145-33AD-11CF-816F-0000C020156E")) IDirect3DExecuteBuffer;
struct __declspec(uuid("50936643-13E9-11D1-89AA-00A0C9054129")) IDirect3DRefDevice;
struct __declspec(uuid("F5049E7D-4861-11D2-A407-00A0C90629A8")) IDirect3DVertexBuffer7;
struct __declspec(uuid("4417C144-33AD-11CF-816F-0000C020156E")) IDirect3DMaterial;


//
// Typedefs
//

typedef IDirect3D            *LPDIRECT3D;
typedef IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef IDirect3DLight       *LPDIRECT3DLIGHT;
typedef IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef IDirect3DViewport    *LPDIRECT3DVIEWPORT;
typedef IDirect3D2           *LPDIRECT3D2;
typedef IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
typedef IDirect3D3            *LPDIRECT3D3;
typedef IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
typedef IDirect3D7             *LPDIRECT3D7;
typedef IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
typedef IDirect3D IDIRECT3D;
typedef IDirect3D * LPIDIRECT3D;
typedef IDirect3D ** LPLPIDIRECT3D;
typedef IDirect3D2 IDIRECT3D2;
typedef IDirect3D2 * LPIDIRECT3D2;
typedef IDirect3D2 ** LPLPIDIRECT3D2;
typedef IDirect3D3 IDIRECT3D3;
typedef IDirect3D3 * LPIDIRECT3D3;
typedef IDirect3D3 ** LPLPIDIRECT3D3;
typedef IDirect3D7 IDIRECT3D7;
typedef IDirect3D7 * LPIDIRECT3D7;
typedef IDirect3D7 ** LPLPIDIRECT3D7;
typedef IDirect3DDevice IDIRECT3DDEVICE;
typedef IDirect3DDevice * LPIDIRECT3DDEVICE;
typedef IDirect3DDevice ** LPLPIDIRECT3DDEVICE;
typedef IDirect3DDevice2 IDIRECT3DDEVICE2;
typedef IDirect3DDevice2 * LPIDIRECT3DDEVICE2;
typedef IDirect3DDevice2 ** LPLPIDIRECT3DDEVICE2;
typedef IDirect3DDevice3 IDIRECT3DDEVICE3;
typedef IDirect3DDevice3 * LPIDIRECT3DDEVICE3;
typedef IDirect3DDevice3 ** LPLPIDIRECT3DDEVICE3;
typedef IDirect3DDevice7 IDIRECT3DDEVICE7;
typedef IDirect3DDevice7 * LPIDIRECT3DDEVICE7;
typedef IDirect3DDevice7 ** LPLPIDIRECT3DDEVICE7;
typedef IDirect3DExecuteBuffer IDIRECT3DEXECUTEBUFFER;
typedef IDirect3DExecuteBuffer * LPIDIRECT3DEXECUTEBUFFER;
typedef IDirect3DExecuteBuffer ** LPLPIDIRECT3DEXECUTEBUFFER;
typedef IDirect3DLight IDIRECT3DLIGHT;
typedef IDirect3DLight * LPIDIRECT3DLIGHT;
typedef IDirect3DLight ** LPLPIDIRECT3DLIGHT;
typedef IDirect3DMaterial IDIRECT3DMATERIAL;
typedef IDirect3DMaterial * LPIDIRECT3DMATERIAL;
typedef IDirect3DMaterial ** LPLPIDIRECT3DMATERIAL;
typedef IDirect3DMaterial2 IDIRECT3DMATERIAL2;
typedef IDirect3DMaterial2 * LPIDIRECT3DMATERIAL2;
typedef IDirect3DMaterial2 ** LPLPIDIRECT3DMATERIAL2;
typedef IDirect3DMaterial3 IDIRECT3DMATERIAL3;
typedef IDirect3DMaterial3 * LPIDIRECT3DMATERIAL3;
typedef IDirect3DMaterial3 ** LPLPIDIRECT3DMATERIAL3;
typedef IDirect3DTexture IDIRECT3DTEXTURE;
typedef IDirect3DTexture * LPIDIRECT3DTEXTURE;
typedef IDirect3DTexture ** LPLPIDIRECT3DTEXTURE;
typedef IDirect3DTexture2 IDIRECT3DTEXTURE2;
typedef IDirect3DTexture2 * LPIDIRECT3DTEXTURE2;
typedef IDirect3DTexture2 ** LPLPIDIRECT3DTEXTURE2;
typedef IDirect3DViewport IDIRECT3DVIEWPORT;
typedef IDirect3DViewport * LPIDIRECT3DVIEWPORT;
typedef IDirect3DViewport ** LPLPIDIRECT3DVIEWPORT;
typedef IDirect3DViewport2 IDIRECT3DVIEWPORT2;
typedef IDirect3DViewport2 * LPIDIRECT3DVIEWPORT2;
typedef IDirect3DViewport2 ** LPLPIDIRECT3DVIEWPORT2;
typedef IDirect3DViewport3 IDIRECT3DVIEWPORT3;
typedef IDirect3DViewport3 * LPIDIRECT3DVIEWPORT3;
typedef IDirect3DViewport3 ** LPLPIDIRECT3DVIEWPORT3;
typedef IDirect3DVertexBuffer IDIRECT3DVERTEXBUFFER;
typedef IDirect3DVertexBuffer * LPIDIRECT3DVERTEXBUFFER;
typedef IDirect3DVertexBuffer ** LPLPIDIRECT3DVERTEXBUFFER;
typedef IDirect3DVertexBuffer7 IDIRECT3DVERTEXBUFFER7;
typedef IDirect3DVertexBuffer7 * LPIDIRECT3DVERTEXBUFFER7;
typedef IDirect3DVertexBuffer7 ** LPLPIDIRECT3DVERTEXBUFFER7;


//
// Masks
//

mask DWORD d3dnextFlags
{
	#define D3DNEXT_NEXT                             0x00000001l
	#define D3DNEXT_HEAD                             0x00000002l
	#define D3DNEXT_TAIL                             0x00000004l
};

mask DWORD direct3dFlags
{
	#define DIRECT3D_VERSION                         0x0700
};

mask DWORD D3D7RESULT 
{
	#define D3D_OK                                   0 
	#define D3DERR_BADMAJORVERSION                   0x887602BCL
	#define D3DERR_BADMINORVERSION                   0x887602BDL
	#define D3DERR_INVALID_DEVICE                    0x887602C1L
	#define D3DERR_INITFAILED                        0x887602C2L
	#define D3DERR_DEVICEAGGREGATED                  0x887602C3L
	#define D3DERR_EXECUTE_CREATE_FAILED             0x887602C6L
	#define D3DERR_EXECUTE_DESTROY_FAILED            0x887602C7L
	#define D3DERR_EXECUTE_LOCK_FAILED               0x887602C8L
	#define D3DERR_EXECUTE_UNLOCK_FAILED             0x887602C9L
	#define D3DERR_EXECUTE_LOCKED                    0x887602CAL
	#define D3DERR_EXECUTE_NOT_LOCKED                0x887602CBL
	#define D3DERR_EXECUTE_FAILED                    0x887602CCL
	#define D3DERR_EXECUTE_CLIPPED_FAILED            0x887602CDL
	#define D3DERR_TEXTURE_NO_SUPPORT                0x887602D0L
	#define D3DERR_TEXTURE_CREATE_FAILED             0x887602D1L
	#define D3DERR_TEXTURE_DESTROY_FAILED            0x887602D2L
	#define D3DERR_TEXTURE_LOCK_FAILED               0x887602D3L
	#define D3DERR_TEXTURE_UNLOCK_FAILED             0x887602D4L
	#define D3DERR_TEXTURE_LOAD_FAILED               0x887602D5L
	#define D3DERR_TEXTURE_SWAP_FAILED               0x887602D6L
	#define D3DERR_TEXTURE_LOCKED                    0x887602D7L
	#define D3DERR_TEXTURE_NOT_LOCKED                0x887602D8L
	#define D3DERR_TEXTURE_GETSURF_FAILED            0x887602D9L
	#define D3DERR_MATRIX_CREATE_FAILED              0x887602DAL
	#define D3DERR_MATRIX_DESTROY_FAILED             0x887602DBL
	#define D3DERR_MATRIX_SETDATA_FAILED             0x887602DCL
	#define D3DERR_MATRIX_GETDATA_FAILED             0x887602DDL
	#define D3DERR_SETVIEWPORTDATA_FAILED            0x887602DEL
	#define D3DERR_INVALIDCURRENTVIEWPORT            0x887602DFL
	#define D3DERR_INVALIDPRIMITIVETYPE              0x887602E0L
	#define D3DERR_INVALIDVERTEXTYPE                 0x887602E1L
	#define D3DERR_TEXTURE_BADSIZE                   0x887602E2L
	#define D3DERR_INVALIDRAMPTEXTURE                0x887602E3L
	#define D3DERR_MATERIAL_CREATE_FAILED            0x887602E4L
	#define D3DERR_MATERIAL_DESTROY_FAILED           0x887602E5L
	#define D3DERR_MATERIAL_SETDATA_FAILED           0x887602E6L
	#define D3DERR_MATERIAL_GETDATA_FAILED           0x887602E7L
	#define D3DERR_INVALIDPALETTE                    0x887602E8L
	#define D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY          0x887602E9L
	#define D3DERR_ZBUFF_NEEDS_VIDEOMEMORY           0x887602EAL
	#define D3DERR_SURFACENOTINVIDMEM                0x887602EBL
	#define D3DERR_LIGHT_SET_FAILED                  0x887602EEL
	#define D3DERR_LIGHTHASVIEWPORT                  0x887602EFL
	#define D3DERR_LIGHTNOTINTHISVIEWPORT            0x887602F0L
	#define D3DERR_SCENE_IN_SCENE                    0x887602F8L
	#define D3DERR_SCENE_NOT_IN_SCENE                0x887602F9L
	#define D3DERR_SCENE_BEGIN_FAILED                0x887602FAL
	#define D3DERR_SCENE_END_FAILED                  0x887602FBL
	#define D3DERR_INBEGIN                           0x88760302L
	#define D3DERR_NOTINBEGIN                        0x88760303L
	#define D3DERR_NOVIEWPORTS                       0x88760304L
	#define D3DERR_VIEWPORTDATANOTSET                0x88760305L
	#define D3DERR_VIEWPORTHASNODEVICE               0x88760306L
	#define D3DERR_NOCURRENTVIEWPORT                 0x88760307L
	#define D3DERR_INVALIDVERTEXFORMAT               0x88760800L
	#define D3DERR_COLORKEYATTACHED                  0x88760802L
	#define D3DERR_VERTEXBUFFEROPTIMIZED             0x8876080CL
	#define D3DERR_VBUF_CREATE_FAILED                0x8876080DL
	#define D3DERR_VERTEXBUFFERLOCKED                0x8876080EL
	#define D3DERR_VERTEXBUFFERUNLOCKFAILED          0x8876080FL
	#define D3DERR_ZBUFFER_NOTPRESENT                0x88760816L
	#define D3DERR_STENCILBUFFER_NOTPRESENT          0x88760817L
	#define D3DERR_WRONGTEXTUREFORMAT                0x88760818L
	#define D3DERR_UNSUPPORTEDCOLOROPERATION         0x88760819L
	#define D3DERR_UNSUPPORTEDCOLORARG               0x8876081AL
	#define D3DERR_UNSUPPORTEDALPHAOPERATION         0x8876081BL
	#define D3DERR_UNSUPPORTEDALPHAARG               0x8876081CL
	#define D3DERR_TOOMANYOPERATIONS                 0x8876081DL
	#define D3DERR_CONFLICTINGTEXTUREFILTER          0x8876081EL
	#define D3DERR_UNSUPPORTEDFACTORVALUE            0x8876081FL
	#define D3DERR_CONFLICTINGRENDERSTATE            0x88760821L
	#define D3DERR_UNSUPPORTEDTEXTUREFILTER          0x88760822L
	#define D3DERR_TOOMANYPRIMITIVES                 0x88760823L
	#define D3DERR_INVALIDMATRIX                     0x88760824L
	#define D3DERR_TOOMANYVERTICES                   0x88760825L
	#define D3DERR_CONFLICTINGTEXTUREPALETTE         0x88760826L
	#define D3DERR_INVALIDSTATEBLOCK                 0x88760834L
	#define D3DERR_INBEGINSTATEBLOCK                 0x88760835L
	#define D3DERR_NOTINBEGINSTATEBLOCK              0x88760836L
};

mask DWORD d3ddpFlags
{
	#define D3DDP_WAIT                               0x00000001l
	#define D3DDP_OUTOFORDER                         0x00000002l
	#define D3DDP_DONOTCLIP                          0x00000004l
	#define D3DDP_DONOTUPDATEEXTENTS                 0x00000008l
	#define D3DDP_DONOTLIGHT                         0x00000010l
};



//
// Values
//



//
// Structs
//



//
// Interfaces
//

interface IDirect3DDevice7 : IUnknown
{
	D3D7RESULT GetCaps([out] LPD3DDEVICEDESC7 arg0);
	D3D7RESULT EnumTextureFormats(LPD3DENUMPIXELFORMATSCALLBACK arg0, LPVOID arg1);
	D3D7RESULT BeginScene();
	D3D7RESULT EndScene();
	D3D7RESULT GetDirect3D([out] LPDIRECT3D7* arg0);
	D3D7RESULT SetRenderTarget(LPDIRECTDRAWSURFACE7 arg0, DWORD arg1);
	D3D7RESULT GetRenderTarget([out] LPDIRECTDRAWSURFACE7 * arg0);
	D3D7RESULT Clear(DWORD arg0, LPD3DRECT arg1, DWORD arg2, D3DCOLOR arg3, D3DVALUE arg4, DWORD arg5);
	D3D7RESULT SetTransform(D3DTRANSFORMSTATETYPE arg0, LPD3DMATRIX arg1);
	D3D7RESULT GetTransform(D3DTRANSFORMSTATETYPE arg0, [out] LPD3DMATRIX arg1);
	D3D7RESULT SetViewport(LPD3DVIEWPORT7 arg0);
	D3D7RESULT MultiplyTransform(D3DTRANSFORMSTATETYPE arg0, LPD3DMATRIX arg1);
	D3D7RESULT GetViewport([out] LPD3DVIEWPORT7 arg0);
	D3D7RESULT SetMaterial(LPD3DMATERIAL7 arg0);
	D3D7RESULT GetMaterial([out] LPD3DMATERIAL7 arg0);
	D3D7RESULT SetLight(DWORD arg0, LPD3DLIGHT7 arg1);
	D3D7RESULT GetLight(DWORD arg0, LPD3DLIGHT7 arg1);
	D3D7RESULT SetRenderState(D3DRENDERSTATETYPE arg0, DWORD arg1);
	D3D7RESULT GetRenderState(D3DRENDERSTATETYPE arg0, [out] LPDWORD arg1);
	D3D7RESULT BeginStateBlock();
	D3D7RESULT EndStateBlock([out] LPDWORD arg0);
	D3D7RESULT PreLoad(LPDIRECTDRAWSURFACE7 arg0);
	D3D7RESULT DrawPrimitive(D3DPRIMITIVETYPE arg0, DWORD arg1, LPVOID arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitive(D3DPRIMITIVETYPE arg0, DWORD arg1, LPVOID arg2, DWORD arg3, LPWORD arg4, DWORD arg5, DWORD arg6);
	D3D7RESULT SetClipStatus(LPD3DCLIPSTATUS arg0);
	D3D7RESULT GetClipStatus([out] LPD3DCLIPSTATUS arg0);
	D3D7RESULT DrawPrimitiveStrided(D3DPRIMITIVETYPE arg0, DWORD arg1, LPD3DDRAWPRIMITIVESTRIDEDDATA arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitiveStrided(D3DPRIMITIVETYPE arg0, DWORD arg1, LPD3DDRAWPRIMITIVESTRIDEDDATA arg2, DWORD arg3, LPWORD arg4, DWORD arg5, DWORD arg6);
	D3D7RESULT DrawPrimitiveVB(D3DPRIMITIVETYPE arg0, LPDIRECT3DVERTEXBUFFER7 arg1, DWORD arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE arg0, LPDIRECT3DVERTEXBUFFER7 arg1, DWORD arg2, DWORD arg3, LPWORD arg4, DWORD arg5, DWORD arg6);
	D3D7RESULT ComputeSphereVisibility(LPD3DVECTOR arg0, LPD3DVALUE arg1, DWORD arg2, DWORD arg3, LPDWORD arg4);
	D3D7RESULT GetTexture(DWORD arg0, [out] LPDIRECTDRAWSURFACE7 * arg1);
	D3D7RESULT SetTexture(DWORD arg0, LPDIRECTDRAWSURFACE7 arg1);
	D3D7RESULT GetTextureStageState(DWORD arg0, D3DTEXTURESTAGESTATETYPE arg1, [out] LPDWORD arg2);
	D3D7RESULT SetTextureStageState(DWORD arg0, D3DTEXTURESTAGESTATETYPE arg1, DWORD arg2);
	D3D7RESULT ValidateDevice([out] LPDWORD arg0);
	D3D7RESULT ApplyStateBlock(DWORD arg0);
	D3D7RESULT CaptureStateBlock(DWORD arg0);
	D3D7RESULT DeleteStateBlock(DWORD arg0);
	D3D7RESULT CreateStateBlock(D3DSTATEBLOCKTYPE arg0, [out] LPDWORD arg1);
	D3D7RESULT Load(LPDIRECTDRAWSURFACE7 arg0, LPPOINT arg1, LPDIRECTDRAWSURFACE7 arg2, LPRECT arg3, DWORD arg4);
	D3D7RESULT LightEnable(DWORD arg0, BOOL arg1);
	D3D7RESULT GetLightEnable(DWORD arg0, [out] BOOL* arg1);
	D3D7RESULT SetClipPlane(DWORD arg0, D3DVALUE* arg1);
	D3D7RESULT GetClipPlane(DWORD arg0, [out] D3DVALUE* arg1);
	D3D7RESULT GetInfo(DWORD arg0, [out] LPVOID arg1, DWORD arg2);
};

interface IDirect3D7 : IUnknown
{
	D3D7RESULT EnumDevices(LPD3DENUMDEVICESCALLBACK7 arg0, LPVOID arg1);
	D3D7RESULT CreateDevice(REFCLSID arg0, LPDIRECTDRAWSURFACE7 arg1, [out] LPDIRECT3DDEVICE7* arg2);
	D3D7RESULT CreateVertexBuffer(LPD3DVERTEXBUFFERDESC arg0, [out] LPDIRECT3DVERTEXBUFFER7* arg1, DWORD arg2);
	D3D7RESULT EnumZBufferFormats(REFCLSID arg0, LPD3DENUMPIXELFORMATSCALLBACK arg1, LPVOID arg2);
	D3D7RESULT EvictManagedTextures();
};

interface IDirect3DVertexBuffer : IUnknown
{
	D3D7RESULT Lock(DWORD arg0, LPVOID* arg1, LPDWORD arg2);
	D3D7RESULT Unlock();
	D3D7RESULT ProcessVertices(DWORD arg0, DWORD arg1, DWORD arg2, LPDIRECT3DVERTEXBUFFER arg3, DWORD arg4, LPDIRECT3DDEVICE3 arg5, DWORD arg6);
	D3D7RESULT GetVertexBufferDesc([out] LPD3DVERTEXBUFFERDESC arg0);
	D3D7RESULT Optimize(LPDIRECT3DDEVICE3 arg0, DWORD arg1);
};

interface IDirect3DLight : IUnknown
{
	D3D7RESULT Initialize(LPDIRECT3D arg0);
	D3D7RESULT SetLight(LPD3DLIGHT arg0);
	D3D7RESULT GetLight([out] LPD3DLIGHT arg0);
};

interface IDirect3DExecuteBuffer : IUnknown
{
	D3D7RESULT Initialize(LPDIRECT3DDEVICE arg0, LPD3DEXECUTEBUFFERDESC arg1);
	D3D7RESULT Lock(LPD3DEXECUTEBUFFERDESC arg0);
	D3D7RESULT Unlock();
	D3D7RESULT SetExecuteData(LPD3DEXECUTEDATA arg0);
	D3D7RESULT GetExecuteData([out] LPD3DEXECUTEDATA arg0);
	D3D7RESULT Validate(LPDWORD arg0, LPD3DVALIDATECALLBACK arg1, LPVOID arg2, DWORD arg3);
	D3D7RESULT Optimize(DWORD arg0);
};

interface IDirect3DVertexBuffer7 : IUnknown
{
	D3D7RESULT Lock(DWORD arg0, LPVOID* arg1, LPDWORD arg2);
	D3D7RESULT Unlock();
	D3D7RESULT ProcessVertices(DWORD arg0, DWORD arg1, DWORD arg2, LPDIRECT3DVERTEXBUFFER7 arg3, DWORD arg4, LPDIRECT3DDEVICE7 arg5, DWORD arg6);
	D3D7RESULT GetVertexBufferDesc([out] LPD3DVERTEXBUFFERDESC arg0);
	D3D7RESULT Optimize(LPDIRECT3DDEVICE7 arg0, DWORD arg1);
	D3D7RESULT ProcessVerticesStrided(DWORD arg0, DWORD arg1, DWORD arg2, LPD3DDRAWPRIMITIVESTRIDEDDATA arg3, DWORD arg4, LPDIRECT3DDEVICE7 arg5, DWORD arg6);
};

interface IDirect3DMaterial : IUnknown
{
	D3D7RESULT Initialize(LPDIRECT3D arg0);
	D3D7RESULT SetMaterial(LPD3DMATERIAL arg0);
	D3D7RESULT GetMaterial([out] LPD3DMATERIAL arg0);
	D3D7RESULT GetHandle(LPDIRECT3DDEVICE arg0, [out] LPD3DMATERIALHANDLE arg1);
	D3D7RESULT Reserve();
	D3D7RESULT Unreserve();
};

interface IDirect3DViewport : IUnknown
{
	D3D7RESULT Initialize(LPDIRECT3D arg0);
	D3D7RESULT GetViewport([out] LPD3DVIEWPORT arg0);
	D3D7RESULT SetViewport(LPD3DVIEWPORT arg0);
	D3D7RESULT TransformVertices(DWORD arg0, LPD3DTRANSFORMDATA arg1, DWORD arg2, LPDWORD arg3);
	D3D7RESULT LightElements(DWORD arg0, LPD3DLIGHTDATA arg1);
	D3D7RESULT SetBackground(D3DMATERIALHANDLE arg0);
	D3D7RESULT GetBackground([out] LPD3DMATERIALHANDLE arg0, [out] LPBOOL arg1);
	D3D7RESULT SetBackgroundDepth(LPDIRECTDRAWSURFACE arg0);
	D3D7RESULT GetBackgroundDepth([out] LPDIRECTDRAWSURFACE* arg0, [out] LPBOOL arg1);
	D3D7RESULT Clear(DWORD arg0, LPD3DRECT arg1, DWORD arg2);
	D3D7RESULT AddLight(LPDIRECT3DLIGHT arg0);
	D3D7RESULT DeleteLight(LPDIRECT3DLIGHT arg0);
	D3D7RESULT NextLight(LPDIRECT3DLIGHT arg0, [out] LPDIRECT3DLIGHT* arg1, DWORD arg2);
};

interface IDirect3D : IUnknown
{
	D3D7RESULT Initialize(REFCLSID arg0);
	D3D7RESULT EnumDevices(LPD3DENUMDEVICESCALLBACK arg0, LPVOID arg1);
	D3D7RESULT CreateLight([out] LPDIRECT3DLIGHT* arg0, IUnknown* arg1);
	D3D7RESULT CreateMaterial([out] LPDIRECT3DMATERIAL* arg0, IUnknown* arg1);
	D3D7RESULT CreateViewport([out] LPDIRECT3DVIEWPORT* arg0, IUnknown* arg1);
	D3D7RESULT FindDevice(LPD3DFINDDEVICESEARCH arg0, LPD3DFINDDEVICERESULT arg1);
};

interface IDirect3DDevice : IUnknown
{
	D3D7RESULT Initialize(LPDIRECT3D arg0, LPGUID arg1, LPD3DDEVICEDESC arg2);
	D3D7RESULT GetCaps([out] LPD3DDEVICEDESC arg0, [out] LPD3DDEVICEDESC arg1);
	D3D7RESULT SwapTextureHandles(LPDIRECT3DTEXTURE arg0, LPDIRECT3DTEXTURE arg1);
	D3D7RESULT CreateExecuteBuffer(LPD3DEXECUTEBUFFERDESC arg0, [out] LPDIRECT3DEXECUTEBUFFER* arg1, IUnknown* arg2);
	D3D7RESULT GetStats(LPD3DSTATS arg0);
	D3D7RESULT Execute(LPDIRECT3DEXECUTEBUFFER arg0, LPDIRECT3DVIEWPORT arg1, DWORD arg2);
	D3D7RESULT AddViewport(LPDIRECT3DVIEWPORT arg0);
	D3D7RESULT DeleteViewport(LPDIRECT3DVIEWPORT arg0);
	D3D7RESULT NextViewport(LPDIRECT3DVIEWPORT arg0, [out] LPDIRECT3DVIEWPORT* arg1, DWORD arg2);
	D3D7RESULT Pick(LPDIRECT3DEXECUTEBUFFER arg0, LPDIRECT3DVIEWPORT arg1, DWORD arg2, LPD3DRECT arg3);
	D3D7RESULT GetPickRecords(LPDWORD arg0, LPD3DPICKRECORD arg1);
	D3D7RESULT EnumTextureFormats(LPD3DENUMTEXTUREFORMATSCALLBACK arg0, LPVOID arg1);
	D3D7RESULT CreateMatrix([out] LPD3DMATRIXHANDLE arg0);
	D3D7RESULT SetMatrix(D3DMATRIXHANDLE arg0, LPD3DMATRIX arg1);
	D3D7RESULT GetMatrix(D3DMATRIXHANDLE arg0, [out] LPD3DMATRIX arg1);
	D3D7RESULT DeleteMatrix(D3DMATRIXHANDLE arg0);
	D3D7RESULT BeginScene();
	D3D7RESULT EndScene();
	D3D7RESULT GetDirect3D([out] LPDIRECT3D* arg0);
};

interface IDirect3DTexture : IUnknown
{
	D3D7RESULT Initialize(LPDIRECT3DDEVICE arg0, LPDIRECTDRAWSURFACE arg1);
	D3D7RESULT GetHandle(LPDIRECT3DDEVICE arg0, LPD3DTEXTUREHANDLE arg1);
	D3D7RESULT PaletteChanged(DWORD arg0, DWORD arg1);
	D3D7RESULT Load(LPDIRECT3DTEXTURE arg0);
	D3D7RESULT Unload();
};

interface IDirect3DMaterial2 : IUnknown
{
	D3D7RESULT SetMaterial(LPD3DMATERIAL arg0);
	D3D7RESULT GetMaterial([out] LPD3DMATERIAL arg0);
	D3D7RESULT GetHandle(LPDIRECT3DDEVICE2 arg0, [out] LPD3DMATERIALHANDLE arg1);
};

interface IDirect3DViewport2 : IDirect3DViewport
{
	D3D7RESULT GetViewport2([out] LPD3DVIEWPORT2 arg0);
	D3D7RESULT SetViewport2(LPD3DVIEWPORT2 arg0);
};

interface IDirect3DMaterial3 : IUnknown
{
	D3D7RESULT SetMaterial(LPD3DMATERIAL arg0);
	D3D7RESULT GetMaterial([out] LPD3DMATERIAL arg0);
	D3D7RESULT GetHandle(LPDIRECT3DDEVICE3 arg0, [out] LPD3DMATERIALHANDLE arg1);
};

interface IDirect3D2 : IUnknown
{
	D3D7RESULT EnumDevices(LPD3DENUMDEVICESCALLBACK arg0, LPVOID arg1);
	D3D7RESULT CreateLight([out] LPDIRECT3DLIGHT* arg0, IUnknown* arg1);
	D3D7RESULT CreateMaterial([out] LPDIRECT3DMATERIAL2* arg0, IUnknown* arg1);
	D3D7RESULT CreateViewport([out] LPDIRECT3DVIEWPORT2* arg0, IUnknown* arg1);
	D3D7RESULT FindDevice(LPD3DFINDDEVICESEARCH arg0, LPD3DFINDDEVICERESULT arg1);
	D3D7RESULT CreateDevice(REFCLSID arg0, LPDIRECTDRAWSURFACE arg1, [out] LPDIRECT3DDEVICE2* arg2);
};

interface IDirect3DDevice2 : IUnknown
{
	D3D7RESULT GetCaps([out] LPD3DDEVICEDESC arg0, [out] LPD3DDEVICEDESC arg1);
	D3D7RESULT SwapTextureHandles(LPDIRECT3DTEXTURE2 arg0, LPDIRECT3DTEXTURE2 arg1);
	D3D7RESULT GetStats([out] LPD3DSTATS arg0);
	D3D7RESULT AddViewport(LPDIRECT3DVIEWPORT2 arg0);
	D3D7RESULT DeleteViewport(LPDIRECT3DVIEWPORT2 arg0);
	D3D7RESULT NextViewport(LPDIRECT3DVIEWPORT2 arg0, [out] LPDIRECT3DVIEWPORT2* arg1, DWORD arg2);
	D3D7RESULT EnumTextureFormats(LPD3DENUMTEXTUREFORMATSCALLBACK arg0, LPVOID arg1);
	D3D7RESULT BeginScene();
	D3D7RESULT EndScene();
	D3D7RESULT GetDirect3D([out] LPDIRECT3D2* arg0);
	D3D7RESULT SetCurrentViewport(LPDIRECT3DVIEWPORT2 arg0);
	D3D7RESULT GetCurrentViewport(LPDIRECT3DVIEWPORT2 * arg0);
	D3D7RESULT SetRenderTarget(LPDIRECTDRAWSURFACE arg0, DWORD arg1);
	D3D7RESULT GetRenderTarget([out] LPDIRECTDRAWSURFACE * arg0);
	D3D7RESULT Begin(D3DPRIMITIVETYPE arg0, D3DVERTEXTYPE arg1, DWORD arg2);
	D3D7RESULT BeginIndexed(D3DPRIMITIVETYPE arg0, D3DVERTEXTYPE arg1, LPVOID arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT Vertex(LPVOID arg0);
	D3D7RESULT Index(WORD arg0);
	D3D7RESULT End(DWORD arg0);
	D3D7RESULT GetRenderState(D3DRENDERSTATETYPE arg0, [out] LPDWORD arg1);
	D3D7RESULT SetRenderState(D3DRENDERSTATETYPE arg0, DWORD arg1);
	D3D7RESULT GetLightState(D3DLIGHTSTATETYPE arg0, [out] LPDWORD arg1);
	D3D7RESULT SetLightState(D3DLIGHTSTATETYPE arg0, DWORD arg1);
	D3D7RESULT SetTransform(D3DTRANSFORMSTATETYPE arg0, LPD3DMATRIX arg1);
	D3D7RESULT GetTransform(D3DTRANSFORMSTATETYPE arg0, [out] LPD3DMATRIX arg1);
	D3D7RESULT MultiplyTransform(D3DTRANSFORMSTATETYPE arg0, [out] LPD3DMATRIX arg1);
	D3D7RESULT DrawPrimitive(D3DPRIMITIVETYPE arg0, D3DVERTEXTYPE arg1, LPVOID arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitive(D3DPRIMITIVETYPE arg0, D3DVERTEXTYPE arg1, LPVOID arg2, DWORD arg3, LPWORD arg4, DWORD arg5, DWORD arg6);
	D3D7RESULT SetClipStatus(LPD3DCLIPSTATUS arg0);
	D3D7RESULT GetClipStatus(LPD3DCLIPSTATUS arg0);
};

interface IDirect3DViewport3 : IDirect3DViewport2
{
	D3D7RESULT SetBackgroundDepth2(LPDIRECTDRAWSURFACE4 arg0);
	D3D7RESULT GetBackgroundDepth2([out] LPDIRECTDRAWSURFACE4* arg0, LPBOOL arg1);
	D3D7RESULT Clear2(DWORD arg0, LPD3DRECT arg1, DWORD arg2, D3DCOLOR arg3, D3DVALUE arg4, DWORD arg5);
};

interface IDirect3DTexture2 : IUnknown
{
	D3D7RESULT GetHandle(LPDIRECT3DDEVICE2 arg0, LPD3DTEXTUREHANDLE arg1);
	D3D7RESULT PaletteChanged(DWORD arg0, DWORD arg1);
	D3D7RESULT Load(LPDIRECT3DTEXTURE2 arg0);
};

interface IDirect3D3 : IUnknown
{
	D3D7RESULT EnumDevices(LPD3DENUMDEVICESCALLBACK arg0, LPVOID arg1);
	D3D7RESULT CreateLight([out] LPDIRECT3DLIGHT* arg0, LPUNKNOWN arg1);
	D3D7RESULT CreateMaterial([out] LPDIRECT3DMATERIAL3* arg0, LPUNKNOWN arg1);
	D3D7RESULT CreateViewport([out] LPDIRECT3DVIEWPORT3* arg0, LPUNKNOWN arg1);
	D3D7RESULT FindDevice(LPD3DFINDDEVICESEARCH arg0, [out] LPD3DFINDDEVICERESULT arg1);
	D3D7RESULT CreateDevice(REFCLSID arg0, LPDIRECTDRAWSURFACE4 arg1, [out] LPDIRECT3DDEVICE3* arg2, LPUNKNOWN arg3);
	D3D7RESULT CreateVertexBuffer(LPD3DVERTEXBUFFERDESC arg0, [out] LPDIRECT3DVERTEXBUFFER* arg1, DWORD arg2, LPUNKNOWN arg3);
	D3D7RESULT EnumZBufferFormats(REFCLSID arg0, LPD3DENUMPIXELFORMATSCALLBACK arg1, LPVOID arg2);
	D3D7RESULT EvictManagedTextures();
};

interface IDirect3DDevice3 : IUnknown
{
	D3D7RESULT GetCaps([out] LPD3DDEVICEDESC arg0, [out] LPD3DDEVICEDESC arg1);
	D3D7RESULT GetStats([out] LPD3DSTATS arg0);
	D3D7RESULT AddViewport(LPDIRECT3DVIEWPORT3 arg0);
	D3D7RESULT DeleteViewport(LPDIRECT3DVIEWPORT3 arg0);
	D3D7RESULT NextViewport(LPDIRECT3DVIEWPORT3 arg0, [out] LPDIRECT3DVIEWPORT3* arg1, DWORD arg2);
	D3D7RESULT EnumTextureFormats(LPD3DENUMPIXELFORMATSCALLBACK arg0, LPVOID arg1);
	D3D7RESULT BeginScene();
	D3D7RESULT EndScene();
	D3D7RESULT GetDirect3D([out] LPDIRECT3D3* arg0);
	D3D7RESULT SetCurrentViewport(LPDIRECT3DVIEWPORT3 arg0);
	D3D7RESULT GetCurrentViewport([out] LPDIRECT3DVIEWPORT3 * arg0);
	D3D7RESULT SetRenderTarget(LPDIRECTDRAWSURFACE4 arg0, DWORD arg1);
	D3D7RESULT GetRenderTarget([out] LPDIRECTDRAWSURFACE4 * arg0);
	D3D7RESULT Begin(D3DPRIMITIVETYPE arg0, DWORD arg1, DWORD arg2);
	D3D7RESULT BeginIndexed(D3DPRIMITIVETYPE arg0, DWORD arg1, LPVOID arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT Vertex(LPVOID arg0);
	D3D7RESULT Index(WORD arg0);
	D3D7RESULT End(DWORD arg0);
	D3D7RESULT GetRenderState(D3DRENDERSTATETYPE arg0, [out] LPDWORD arg1);
	D3D7RESULT SetRenderState(D3DRENDERSTATETYPE arg0, DWORD arg1);
	D3D7RESULT GetLightState(D3DLIGHTSTATETYPE arg0, [out] LPDWORD arg1);
	D3D7RESULT SetLightState(D3DLIGHTSTATETYPE arg0, DWORD arg1);
	D3D7RESULT SetTransform(D3DTRANSFORMSTATETYPE arg0, LPD3DMATRIX arg1);
	D3D7RESULT GetTransform(D3DTRANSFORMSTATETYPE arg0, [out] LPD3DMATRIX arg1);
	D3D7RESULT MultiplyTransform(D3DTRANSFORMSTATETYPE arg0, [out] LPD3DMATRIX arg1);
	D3D7RESULT DrawPrimitive(D3DPRIMITIVETYPE arg0, DWORD arg1, LPVOID arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitive(D3DPRIMITIVETYPE arg0, DWORD arg1, LPVOID arg2, DWORD arg3, LPWORD arg4, DWORD arg5, DWORD arg6);
	D3D7RESULT SetClipStatus(LPD3DCLIPSTATUS arg0);
	D3D7RESULT GetClipStatus([out] LPD3DCLIPSTATUS arg0);
	D3D7RESULT DrawPrimitiveStrided(D3DPRIMITIVETYPE arg0, DWORD arg1, LPD3DDRAWPRIMITIVESTRIDEDDATA arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitiveStrided(D3DPRIMITIVETYPE arg0, DWORD arg1, LPD3DDRAWPRIMITIVESTRIDEDDATA arg2, DWORD arg3, LPWORD arg4, DWORD arg5, DWORD arg6);
	D3D7RESULT DrawPrimitiveVB(D3DPRIMITIVETYPE arg0, LPDIRECT3DVERTEXBUFFER arg1, DWORD arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE arg0, LPDIRECT3DVERTEXBUFFER arg1, LPWORD arg2, DWORD arg3, DWORD arg4);
	D3D7RESULT ComputeSphereVisibility(LPD3DVECTOR arg0, LPD3DVALUE arg1, DWORD arg2, DWORD arg3, LPDWORD arg4);
	D3D7RESULT GetTexture(DWORD arg0, [out] LPDIRECT3DTEXTURE2 * arg1);
	D3D7RESULT SetTexture(DWORD arg0, LPDIRECT3DTEXTURE2 arg1);
	D3D7RESULT GetTextureStageState(DWORD arg0, D3DTEXTURESTAGESTATETYPE arg1, [out] LPDWORD arg2);
	D3D7RESULT SetTextureStageState(DWORD arg0, D3DTEXTURESTAGESTATETYPE arg1, DWORD arg2);
	D3D7RESULT ValidateDevice(LPDWORD arg0);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\ddraw.h ===
module DDRAW.DLL:
category DirectDraw:

 class __declspec(uuid("D7B70EE0-4340-11CF-B063-0020AFC2CD35")) DirectDraw;
 class __declspec(uuid("3c305196-50db-11d3-9cfe-00c04fd930c5")) DirectDraw7;
 class __declspec(uuid("593817A0-7DB3-11CF-A2DE-00AA00b93356")) DirectDrawClipper;
struct __declspec(uuid("6C14DB80-A733-11CE-A521-0020AF0BE560")) IDirectDraw            ;
struct __declspec(uuid("B3A6F3E0-2B43-11CF-A2DE-00AA00B93356")) IDirectDraw2           ;
struct __declspec(uuid("9c59509a-39bd-11d1-8c4a-00c04fd930c5")) IDirectDraw4           ;
struct __declspec(uuid("15e65ec0-3b9c-11d2-b92f-00609797ea5b")) IDirectDraw7           ;
struct __declspec(uuid("6c0f8a6c-2f3a-11d3-8f01-0000f8757fbc")) IDirectDrawRM          ;
struct __declspec(uuid("6C14DB81-A733-11CE-A521-0020AF0BE560")) IDirectDrawSurface     ;
struct __declspec(uuid("57805885-6eec-11cf-9441-a82303c10e27")) IDirectDrawSurface2    ;
struct __declspec(uuid("DA044E00-69B2-11D0-A1D5-00AA00B8DFBB")) IDirectDrawSurface3    ;
struct __declspec(uuid("0B2B8630-AD35-11D0-8EA6-00609797EA5B")) IDirectDrawSurface4    ;
struct __declspec(uuid("06675a80-3b9b-11d2-b92f-00609797ea5b")) IDirectDrawSurface7    ;
struct __declspec(uuid("6C14DB84-A733-11CE-A521-0020AF0BE560")) IDirectDrawPalette     ;
struct __declspec(uuid("6C14DB85-A733-11CE-A521-0020AF0BE560")) IDirectDrawClipper     ;
struct __declspec(uuid("4B9F0EE0-0D7E-11D0-9B06-00A0C903A3B8")) IDirectDrawColorControl;
struct __declspec(uuid("69C11C3E-B46B-11D1-AD7A-00C04FC29B4E")) IDirectDrawGammaControl;

typedef IDirectDraw              *LPDIRECTDRAW;
typedef IDirectDraw2             *LPDIRECTDRAW2;
typedef IDirectDraw4             *LPDIRECTDRAW4;
typedef IDirectDraw7             *LPDIRECTDRAW7;
typedef IDirectDrawSurface       *LPDIRECTDRAWSURFACE;
typedef IDirectDrawSurface2      *LPDIRECTDRAWSURFACE2;
typedef IDirectDrawSurface3      *LPDIRECTDRAWSURFACE3;
typedef IDirectDrawSurface4      *LPDIRECTDRAWSURFACE4;
typedef IDirectDrawSurface7      *LPDIRECTDRAWSURFACE7;
typedef IDirectDrawPalette       *LPDIRECTDRAWPALETTE;
typedef IDirectDrawClipper       *LPDIRECTDRAWCLIPPER;
typedef IDirectDrawColorControl  *LPDIRECTDRAWCOLORCONTROL;
typedef IDirectDrawGammaControl  *LPDIRECTDRAWGAMMACONTROL;

typedef DDSURFACEDESC            *LPDDSURFACEDESC;
typedef DDSURFACEDESC2           *LPDDSURFACEDESC2;
typedef DDCOLORCONTROL           *LPDDCOLORCONTROL;

typedef LPVOID                   LPDDENUMCALLBACKW;
typedef LPVOID                   LPDDENUMCALLBACKA;
typedef LPVOID                   LPDDENUMCALLBACKEXW;
typedef LPVOID                   LPDDENUMCALLBACKEXA;

typedef LPVOID                   LPDDENUMMODESCALLBACK;
typedef LPVOID                   LPDDENUMMODESCALLBACK2;

typedef LPVOID                   LPDDENUMSURFACESCALLBACK;
typedef LPVOID                   LPDDENUMSURFACESCALLBACK2;
typedef LPVOID                   LPDDENUMSURFACESCALLBACK7;

mask DWORD DirectDrawOptSurfaceDescFlags
{
/*
 * guid field is valid.
 */
#define DDOSD_GUID                  0x00000001l

/*
 * dwCompressionRatio field is valid.
 */
#define DDOSD_COMPRESSION_RATIO     0x00000002l

/*
 * ddSCaps field is valid.
 */
#define DDOSD_SCAPS                 0x00000004l

/*
 * ddOSCaps field is valid.
 */
#define DDOSD_OSCAPS                0x00000008l

/*
 * All input fields are valid.
 */
#define DDOSD_ALL                   0x0000000fl
};

mask DWORD DirectDrawOptSurfaceDescCapsFlags
{
/*
 * The surface's optimized pixelformat is compressed
 */
#define DDOSDCAPS_OPTCOMPRESSED                 0x00000001l

/*
 * The surface's optimized pixelformat is reordered
 */
#define DDOSDCAPS_OPTREORDERED                  0x00000002l

/*
 * The opt surface is a monolithic mipmap
 */
#define DDOSDCAPS_MONOLITHICMIPMAP              0x00000004l
};

mask DWORD DirectDrawGetDeviceIdentifierFlags
{
/*
 * This flag causes GetDeviceIdentifier to return information about the host (typically 2D) adapter in a system equipped
 * with a stacked secondary 3D adapter. Such an adapter appears to the application as if it were part of the
 * host adapter, but is typically physcially located on a separate card. The stacked secondary's information is
 * returned when GetDeviceIdentifier's dwFlags field is zero, since this most accurately reflects the qualities
 * of the DirectDraw object involved.
 */
#define DDGDI_GETHOSTIDENTIFIER         0x00000001L
};



mask DWORD DirectDrawSurfaceDescFlags
{
/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS               0x00000001l     // default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT             0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH              0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH              0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT    0x00000020l

/*
 * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
 */
#define DDSD_ZBUFFERBITDEPTH    0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH      0x00000080l


/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE          0x00000800l

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT        0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY      0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT          0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY       0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT           0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE        0x00040000l

/*
 * dwLinearSize is valid
 */
#define DDSD_LINEARSIZE         0x00080000l

/*
 * dwTextureStage is valid
 */
#define DDSD_TEXTURESTAGE       0x00100000l
/*
 * dwFVF is valid
 */
#define DDSD_FVF                0x00200000l
/*
 * dwSrcVBHandle is valid
 */
#define DDSD_SRCVBHANDLE        0x00400000l
/*
 * All input fields are valid.
 */
#define DDSD_ALL                0x007ff9eel
};

mask DWORD DirectDrawEnumerateExFlags
{
/*
 * Flags for DirectDrawEnumerateEx
 * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
 * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
 * By default, only the primary display device is enumerated.
 * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L

/*
 * This flag causes enumeration of non-display devices
 */
#define DDENUM_NONDISPLAYDEVICES            0x00000004L
};

value DWORD DirectDrawCreateFlags
{
#define DDCREATE_HARDWAREONLY           0x00000001L
#define DDCREATE_EMULATIONONLY          0x00000002L
};

mask DWORD DirectDrawColorControlFlags
{
/*
 * lBrightness field is valid.
 */
#define DDCOLOR_BRIGHTNESS              0x00000001l

/*
 * lContrast field is valid.
 */
#define DDCOLOR_CONTRAST                0x00000002l

/*
 * lHue field is valid.
 */
#define DDCOLOR_HUE                     0x00000004l

/*
 * lSaturation field is valid.
 */
#define DDCOLOR_SATURATION              0x00000008l

/*
 * lSharpness field is valid.
 */
#define DDCOLOR_SHARPNESS               0x00000010l

/*
 * lGamma field is valid.
 */
#define DDCOLOR_GAMMA                   0x00000020l

/*
 * lColorEnable field is valid.
 */
#define DDCOLOR_COLORENABLE             0x00000040l
};

mask DWORD DirectDrawCapsFlags
{
/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED1                       0x00000001l

/*
 * Indicates that this surface contains alpha-only information.
 * (To determine if a surface is RGBA/YUVA, the pixel format must be
 * interrogated.)
 */
#define DDSCAPS_ALPHA                           0x00000002l

/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER                      0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX                         0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP                            0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER                     0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN                  0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
 * overlayed at the moment.
 */
#define DDSCAPS_OVERLAY                         0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE                         0x00000100l

/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE                  0x00000200l


/*
 * This flag used to be DDSCAPS_PRIMARYSURFACELEFT, which is now
 * obsolete.
 */
#define DDSCAPS_RESERVED3               0x00000400l

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY                    0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE                         0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY                     0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE                         0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses
 * from the surface may or may not generate a protection fault, but the
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */
#define DDSCAPS_WRITEONLY                       0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured.
 */
#define DDSCAPS_ZBUFFER                         0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC                           0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO                       0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC                         0x00100000l

/*
 * Surface is a ModeX surface.
 *
 */
#define DDSCAPS_MODEX                           0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED2                       0x00800000l


/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l

/*
 * Indicates that the surface will recieve data from a video port.
 */
#define DDSCAPS_VIDEOPORT                       0x08000000l

/*
 * Indicates that a video memory surface is resident in true, local video
 * memory rather than non-local video memory. If this flag is specified then
 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_NONLOCALVIDMEM.
 */
#define DDSCAPS_LOCALVIDMEM                     0x10000000l

/*
 * Indicates that a video memory surface is resident in non-local video
 * memory rather than true, local video memory. If this flag is specified
 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_LOCALVIDMEM.
 */
#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l

/*
 * Indicates that this surface is a standard VGA mode surface, and not a
 * ModeX surface. (This flag will never be set in combination with the
 * DDSCAPS_MODEX flag).
 */
#define DDSCAPS_STANDARDVGAMODE                 0x40000000l

/*
 * Indicates that this surface will be an optimized surface. This flag is
 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
 * will be created without any underlying video memory until loaded.
 */
#define DDSCAPS_OPTIMIZED                       0x80000000l
};



mask DWORD DirectDrawCapabilityFlags2
{
/*
 * Indicates that this surface will receive data from a video port using
 * the de-interlacing hardware.  This allows the driver to allocate memory
 * for any extra buffers that may be required.  The DDSCAPS_VIDEOPORT and
 * DDSCAPS_OVERLAY flags must also be set.
 */
#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000002L

/*
 * Indicates to the driver that this surface will be locked very frequently
 * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
 * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTDYNAMIC                    0x00000004L

/*
 * Indicates to the driver that this surface can be re-ordered/retiled on
 * load. This operation will not change the size of the texture. It is
 * relatively fast and symmetrical, since the application may lock these
 * bits (although it will take a performance hit when doing so). Surfaces
 * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
 * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTSTATIC                     0x00000008L

/*
 * Indicates that the client would like this texture surface to be managed by the
 * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
 * DDSCAPS_TEXTURE set.
 */
#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L

/*
 * These bits are reserved for internal use */
#define DDSCAPS2_RESERVED1                      0x00000020L
#define DDSCAPS2_RESERVED2                      0x00000040L

/*
 * Indicates to the driver that this surface will never be locked again.
 * The driver is free to optimize this surface via retiling and actual compression.
 * All calls to Lock() or Blts from this surface will fail. Surfaces with this
 * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
 */
#define DDSCAPS2_OPAQUE                         0x00000080L

/*
 * Applications should set this bit at CreateSurface time to indicate that they
 * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
 */
#define DDSCAPS2_HINTANTIALIASING               0x00000100L


/*
 * This flag is used at CreateSurface time to indicate that this set of
 * surfaces is a cubic environment map
 */
#define DDSCAPS2_CUBEMAP                        0x00000200L

/*
 * These flags preform two functions:
 * - At CreateSurface time, they define which of the six cube faces are
 *   required by the application.
 * - After creation, each face in the cubemap will have exactly one of these
 *   bits set.
 */
#define DDSCAPS2_CUBEMAP_POSITIVEX              0x00000400L
#define DDSCAPS2_CUBEMAP_NEGATIVEX              0x00000800L
#define DDSCAPS2_CUBEMAP_POSITIVEY              0x00001000L
#define DDSCAPS2_CUBEMAP_NEGATIVEY              0x00002000L
#define DDSCAPS2_CUBEMAP_POSITIVEZ              0x00004000L
#define DDSCAPS2_CUBEMAP_NEGATIVEZ              0x00008000L

/*
 * This flag is an additional flag which is present on mipmap sublevels from DX7 onwards
 * It enables easier use of GetAttachedSurface rather than EnumAttachedSurfaces for surface
 * constructs such as Cube Maps, wherein there are more than one mipmap surface attached
 * to the root surface.
 * This caps bit is ignored by CreateSurface
 */
#define DDSCAPS2_MIPMAPSUBLEVEL                 0x00010000L

/* This flag indicates that the texture should be managed by D3D only */
#define DDSCAPS2_D3DTEXTUREMANAGE               0x00020000L

/* This flag indicates that the managed surface can be safely lost */
#define DDSCAPS2_DONOTPERSIST                   0x00040000L

/* indicates that this surface is part of a stereo flipping chain */
#define DDSCAPS2_STEREOSURFACELEFT              0x00080000L
};

mask DWORD DirectDrawDriverCapsFlags
{
 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D                       0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST        0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST            0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC         0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC             0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE              0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT                      0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE                 0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC                0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH               0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI                      0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY                  0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP          0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC            0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH           0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE                  0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC             0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE             0x00020000l


/*
 * This flag used to bo DDCAPS_STEREOVIEW, which is now obsolete
 */
#define DDCAPS_RESERVED1                0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI                      0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS                    0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS                0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY                 0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA                    0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST         0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE               0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL             0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED             0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL             0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP                  0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED         0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM             0x80000000l
};


mask DWORD DirectDrawDriverCapsFlags2
{
 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED              0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/*
 * Display hardware contains a video port
 */
#define DDCAPS2_VIDEOPORT               0x00000004l

/*
 * The overlay can be automatically flipped according to the video port
 * VSYNCs, providing automatic doubled buffered display of video port
 * data using an overlay
 */
#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l

/*
 * Overlay can display each field of interlaced data individually while
 * it is interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l

/*
 * Overlay can display each field of interlaced data individually while
 * it is not interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l

/*
 * The overlay surface contains color controls (brightness, sharpness, etc.)
 */
#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l

/*
 * The primary surface contains color controls (gamma, etc.)
 */
#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l

/*
 * RGBZ -> RGB supported for 16:16 RGB:Z
 */
#define DDCAPS2_CANDROPZ16BIT           0x00000100l

/*
 * Driver supports non-local video memory.
 */
#define DDCAPS2_NONLOCALVIDMEM          0x00000200l

/*
 * Dirver supports non-local video memory but has different capabilities for
 * non-local video memory surfaces. If this bit is set then so must
 * DDCAPS2_NONLOCALVIDMEM.
 */
#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l

/*
 * Driver neither requires nor prefers surfaces to be pagelocked when performing
 * blts involving system memory surfaces
 */
#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l

/*
 * Driver can create surfaces which are wider than the primary surface
 */
#define DDCAPS2_WIDESURFACES            0x00001000l

/*
 * Driver supports bob without using a video port by handling the
 * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
 */
#define DDCAPS2_CANFLIPODDEVEN          0x00002000l

/*
 * Driver supports bob using hardware
 */
#define DDCAPS2_CANBOBHARDWARE          0x00004000l

/*
 * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
 */
#define DDCAPS2_COPYFOURCC              0x00008000l


/*
 * Driver supports loadable gamma ramps for the primary surface
 */
#define DDCAPS2_PRIMARYGAMMA            0x00020000l

/*
 * Driver can render in windowed mode.
 */
#define DDCAPS2_CANRENDERWINDOWED       0x00080000l

/*
 * A calibrator is available to adjust the gamma ramp according to the
 * physical display properties so that the result will be identical on
 * all calibrated systems.
 */
#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l

/*
 * Indicates that the driver will respond to DDFLIP_INTERVALn flags
 */
#define DDCAPS2_FLIPINTERVAL            0x00200000l

/*
 * Indicates that the driver will respond to DDFLIP_NOVSYNC
 */
#define DDCAPS2_FLIPNOVSYNC             0x00400000l

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the texture if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the texture if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGETEXTURE        0x00800000l

/*
 * The Direct3D texture manager uses this cap to decide whether to put managed
 * surfaces in non-local video memory. If the cap is set, the texture manager will
 * put managed surfaces in non-local vidmem. Drivers that cannot texture from
 * local vidmem SHOULD NOT set this cap.
 */
#define DDCAPS2_TEXMANINNONLOCALVIDMEM  0x01000000l

/*
 * Indicates that the driver supports DX7 type of stereo in at least one mode (which may
 * not necessarily be the current mode). Applications should use IDirectDraw7 (or higher)
 * ::EnumDisplayModes and check the DDSURFACEDESC.ddsCaps.dwCaps2 field for the presence of
 * DDSCAPS2_STEREOSURFACELEFT to check if a particular mode supports stereo. The application
 * can also use IDirectDraw7(or higher)::GetDisplayMode to check the current mode.
 */
#define DDCAPS2_STEREO                  0x02000000L

/*
 * This caps bit is intended for internal DirectDraw use. 
 * -It is only valid if DDCAPS2_NONLOCALVIDMEMCAPS is set.
 * -If this bit is set, then DDCAPS_CANBLTSYSMEM MUST be set by the driver (and
 *  all the assoicated system memory blt caps must be correct).
 * -It implies that the system->video blt caps in DDCAPS also apply to system to 
 *  nonlocal blts. I.e. the dwSVBCaps, dwSVBCKeyCaps, dwSVBFXCaps and dwSVBRops
 *  members of DDCAPS (DDCORECAPS) are filled in correctly.
 * -Any blt from system to nonlocal memory that matches these caps bits will
 *  be passed to the driver.
 *
 * NOTE: This is intended to enable the driver itself to do efficient reordering
 * of textures. This is NOT meant to imply that hardware can write into AGP memory.
 * This operation is not currently supported.
 */
#define DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL   0x04000000L
};


mask DWORD DirectDrawFxAlphaCapsFlags
{
/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND         0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS            0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG         0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES          0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG       0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND     0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS        0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG     0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES      0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG   0x00000200l
};

mask DWORD DirectDrawFxCapsFlags
{
/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY       0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN      0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT     0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN        0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION            0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90          0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX             0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN            0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKY             0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKYN            0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX            0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN           0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHY            0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHYN           0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY   0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN  0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX         0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN        0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKY         0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKYN        0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX        0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN       0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHY        0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHYN       0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT 0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN    0x10000000l

/*
 * Driver can do alpha blending for blits.
 */
#define DDFXCAPS_BLTALPHA               0x00000001l


/*
 * Driver can do alpha blending for overlays.
 */
#define DDFXCAPS_OVERLAYALPHA           0x00000004l

};

mask DWORD DirectDrawStereoViewCapsFlags
{
/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * This flag used to be DDSVCAPS_ENIGMA, which is now obsolete
 */

#define DDSVCAPS_RESERVED1              0x00000001l

/*
 * This flag used to be DDSVCAPS_FLICKER, which is now obsolete
 */
#define DDSVCAPS_RESERVED2              0x00000002l

/*
 * This flag used to be DDSVCAPS_REDBLUE, which is now obsolete
 */
#define DDSVCAPS_RESERVED3              0x00000004l

/*
 * This flag used to be DDSVCAPS_SPLIT, which is now obsolete
 */
#define DDSVCAPS_RESERVED4              0x00000008l

/*
 * The stereo view is accomplished with switching technology
 */

#define DDSVCAPS_STEREOSEQUENTIAL       0x00000010L

};


mask DWORD DirectDrawPaletteCapsFlags
{
/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT                    0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES             0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT                    0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 * This flag is obsolete. DirectDraw always initializes the color array from
 * the lpDDColorArray parameter. The definition remains for source-level
 * compatibility.
 */
#define DDPCAPS_INITIALIZE              0x00000000l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE          0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT      0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256                0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC                   0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT                    0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT                    0x00000200l

/*
 * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
 */
#define DDPCAPS_ALPHA                   0x00000400l
};

/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
 *
 ****************************************************************************/

value DWORD DirectDrawSurfaceSetPrivateDataConstants
{
/*
 * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
 * pointer and Release when the private data is destroyed. This includes when
 * the surface or palette is destroyed before such priovate data is destroyed.
 */
#define DDSPD_IUNKNOWNPOINTER           0x00000001L

/*
 * Private data is only valid for the current state of the object,
 * as determined by the uniqueness value.
 */
#define DDSPD_VOLATILE                  0x00000002L
};


value DWORD DirectDrawSurfaceSetPaletteConstants
{
/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1                  0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2                  0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4                  0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8                  0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16                 0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24                 0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32                 0x00000100l
};

mask DWORD DirectDrawSurfaceSetGetColorKeyFlags
{
/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE       0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT          0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY      0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT           0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY       0x00000010l
};

mask DWORD DirectDrawColorKeyCapsFlags
{
/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT                      0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE              0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV           0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV                   0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY                  0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE          0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV       0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE         0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV               0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT                       0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE               0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV            0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV                    0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY                   0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE           0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV        0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE          0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV                0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY                0x00040000l
};

mask DWORD DirectDrawPixelFormatFlags
{
/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS                        0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA                              0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4                    0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8                  0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8                    0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB                                0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED                         0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set.
 */
#define DDPF_RGBTOYUV                           0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV                                0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER                            0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1                    0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2                    0x00001000l

/*
 * The surface contains Z information in the pixels
 */
#define DDPF_ZPIXELS                            0x00002000l

/*
 * The surface contains stencil information along with Z
 */
#define DDPF_STENCILBUFFER                      0x00004000l

/*
 * Premultiplied alpha format -- the color components have been
 * premultiplied by the alpha component.
 */
#define DDPF_ALPHAPREMULT                       0x00008000l


/*
 * Luminance data in the pixel format is valid.
 * Use this flag for luminance-only or luminance+alpha surfaces,
 * the bit depth is then ddpf.dwLuminanceBitCount.
 */
#define DDPF_LUMINANCE                          0x00020000l

/*
 * Luminance data in the pixel format is valid.
 * Use this flag when hanging luminance off bumpmap surfaces,
 * the bit mask for the luminance portion of the pixel is then
 * ddpf.dwBumpLuminanceBitMask
 */
#define DDPF_BUMPLUMINANCE                      0x00040000l

/*
 * Bump map dUdV data in the pixel format is valid.
 */
#define DDPF_BUMPDUDV                           0x00080000l
};

/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

mask DWORD DirectDrawEnumSurfacesFlags
{
/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL                      0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH                    0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH                  0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED             0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST                0x00000010l
};

mask DWORD DirectDrawSetDisplayModeFlags
{
/****************************************************************************
 *
 * DIRECTDRAW SETDISPLAYMODE FLAGS
 *
 ****************************************************************************/

/*
 * The desired mode is a standard VGA mode
 */
#define DDSDM_STANDARDVGAMODE                   0x00000001l
};

mask DWORD DirectDrawEnumDisplayModesFlags
{
/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES                      0x00000001l

/*
 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
 * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
 * enumerated if the application has previously called SetCooperativeLevel with the
 * DDSCL_ALLOWMODEX flag set).
 */
#define DDEDM_STANDARDVGAMODES                  0x00000002L

};

mask DWORD DirectDrawSetCooperativeLevelFlags
{

/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN                        0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
 */
#define DDSCL_ALLOWREBOOT                       0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES                   0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL                            0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l


/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

/*
 * this window will receive the focus messages
 */
#define DDSCL_SETFOCUSWINDOW                    0x00000080l

/*
 * this window is associated with the DDRAW object and will
 * cover the screen in fullscreen mode
 */
#define DDSCL_SETDEVICEWINDOW                   0x00000100l

/*
 * app wants DDRAW to create a window to be associated with the
 * DDRAW object
 */
#define DDSCL_CREATEDEVICEWINDOW                0x00000200l

/*
 * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
 * take the global crtisec more frequently.
 */
#define DDSCL_MULTITHREADED                     0x00000400l

/*
 * App specifies that it would like to keep the FPU set up for optimal Direct3D
 * performance (single precision and exceptions disabled) so Direct3D
 * does not need to explicitly set the FPU each time. This is assumed by
 * default in DirectX 7. See also DDSCL_FPUPRESERVE
 */
#define DDSCL_FPUSETUP                          0x00000800l

/*
 * App specifies that it needs either double precision FPU or FPU exceptions
 * enabled. This makes Direct3D explicitly set the FPU state eah time it is
 * called. Setting the flag will reduce Direct3D performance. The flag is
 * assumed by default in DirectX 6 and earlier. See also DDSCL_FPUSETUP
 */
#define DDSCL_FPUPRESERVE                          0x00001000l
};

mask DWORD DirectDrawBltFlags
{
/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST                         0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE            0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG                      0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE          0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND                    0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC                          0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE             0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG                       0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE           0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC                             0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL                         0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX                              0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS                            0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST                           0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE                   0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC                            0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE                    0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP                               0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE                     0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER                           0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE          0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE               0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE           0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL                         0x02000000l


/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_DONOTWAIT                         0x08000000l
};


mask DWORD DirectDrawBltFastFlags
{
/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010
#define DDBLTFAST_DONOTWAIT                     0x00000020
};

mask DWORD DirectDrawFlipFlags
{
/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001L

/*
 * Indicates that the target surface contains the even field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_EVEN                          0x00000002L

/*
 * Indicates that the target surface contains the odd field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_ODD                           0x00000004L

/*
 * Causes DirectDraw to perform the physical flip immediately and return
 * to the application. Typically, what was the front buffer but is now the back
 * buffer will still be visible (depending on timing) until the next vertical
 * retrace. Subsequent operations involving the two flipped surfaces will
 * not check to see if the physical flip has finished (i.e. will not return
 * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
 * This allows an application to perform Flips at a higher frequency than the
 * monitor refresh rate, but may introduce visible artifacts.
 * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set,
 * DDFLIP_NOVSYNC has no effect.
 */
#define DDFLIP_NOVSYNC                       0x00000008L


/*
 * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
 * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
 * surface involved in the flip until the specified number of vertical retraces has
 * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set,
 * DDFLIP_INTERVALn has no effect.
 */

/*
 * DirectDraw will flip on every other vertical sync
 */
#define DDFLIP_INTERVAL2                     0x02000000L


/*
 * DirectDraw will flip on every third vertical sync
 */
#define DDFLIP_INTERVAL3                     0x03000000L


/*
 * DirectDraw will flip on every fourth vertical sync
 */
#define DDFLIP_INTERVAL4                     0x04000000L

/*
 * DirectDraw will flip and display a main stereo surface
 */
#define DDFLIP_STEREO                        0x00000010L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDFLIP_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDFLIP_DONOTWAIT.
 */
#define DDFLIP_DONOTWAIT                     0x00000020L

};

mask DWORD DirectDrawSurfaceOverlayFlags
{
/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases.
 */
#define DDOVER_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE                             0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST                          0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE                  0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC                           0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE                   0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW                             0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS                0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l


/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                             0x00080000l

/*
 * Autoflip the overlay when ever the video port autoflips
 */
#define DDOVER_AUTOFLIP                         0x00100000l

/*
 * Display each field of video port data individually without
 * causing any jittery artifacts
 */
#define DDOVER_BOB                              0x00200000l

/*
 * Indicates that bob/weave decisions should not be overridden by other
 * interfaces.
 */
#define DDOVER_OVERRIDEBOBWEAVE                 0x00400000l

/*
 * Indicates that the surface memory is composed of interleaved fields.
 */
#define DDOVER_INTERLEAVED                      0x00800000l

/*
 * Indicates that bob will be performed using hardware rather than
 * software or emulated.
 */
#define DDOVER_BOBHARDWARE                      0x01000000l

/*
 * Indicates that overlay FX structure contains valid ARGB scaling factors.
 */
#define DDOVER_ARGBSCALEFACTORS                 0x02000000l

/*
 * Indicates that ARGB scaling factors can be degraded to fit driver capabilities.
 */
#define DDOVER_DEGRADEARGBSCALING               0x04000000l
};


mask DWORD DirectDrawSurfaceLockFlags
{
/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR                 0x00000000L     // default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT                             0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT                            0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY                         0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY                        0x00000020L


/*
 * Indicates that a system wide lock should not be taken when this surface
 * is locked. This has several advantages (cursor responsiveness, ability
 * to call more Windows functions, easier debugging) when locking video
 * memory surfaces. However, an application specifying this flag must
 * comply with a number of conditions documented in the help file.
 * Furthermore, this flag cannot be specified when locking the primary.
 */
#define DDLOCK_NOSYSLOCK                        0x00000800L

/*
 * Used only with Direct3D Vertex Buffer Locks. Indicates that no vertices
 * that were referred to in Draw*PrimtiveVB calls since the start of the
 * frame (or the last lock without this flag) will be modified during the
 * lock. This can be useful when one is only appending data to the vertex
 * buffer
 */
#define DDLOCK_NOOVERWRITE                      0x00001000L

/*
 * Indicates that no assumptions will be made about the contents of the 
 * surface or vertex buffer during this lock.
 * This enables two things:
 * -    Direct3D or the driver may provide an alternative memory
 *      area as the vertex buffer. This is useful when one plans to clear the
 *      contents of the vertex buffer and fill in new data.
 * -    Drivers sometimes store surface data in a re-ordered format.
 *      When the application locks the surface, the driver is forced to un-re-order
 *      the surface data before allowing the application to see the surface contents.
 *      This flag is a hint to the driver that it can skip the un-re-ordering process
 *      since the application plans to overwrite every single pixel in the surface
 *      or locked rectangle (and so erase any un-re-ordered pixels anyway).
 *      Applications should always set this flag when they intend to overwrite the entire
 *      surface or locked rectangle.
 */
#define DDLOCK_DISCARDCONTENTS                  0x00002000L
 /*
  * DDLOCK_OKTOSWAP is an older, less informative name for DDLOCK_DISCARDCONTENTS
  */
#define DDLOCK_OKTOSWAP                         0x00002000L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDLOCK_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDLOCK_DONOTWAIT.
 */
#define DDLOCK_DONOTWAIT                        0x00004000L

};

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

mask DWORD DirectDrawSurfaceBltFxFlags
{
/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY                   0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT                 0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN                    0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING                       0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180                       0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270                       0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90                        0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE                    0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST                 0x00000100l
};

mask DWORD DirectDrawOverlayFxFlags
{
/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY                  0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN                   0x00000004l

};

mask DWORD DirectDrawWaitForVerticalBlankFlags
{

/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN                     0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT                0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND                       0x00000004l

 };
 
mask DWORD DirectDrawGetFlipStatusFlags
{
 /****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP                   0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE                0x00000002l
};

mask DWORD DirectDrawGetBltStatusFlags
{
/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT                    0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE                 0x00000002l

};

mask DWORD DirectDrawEnumOverlayZOrderFlags
{

/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT      0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK      0x00000001l

};

mask DWORD DirectDrawUpdateOverlayZOrderFlags
{
/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT             0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK              0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD             0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD            0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF         0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF          0x00000005l
};

mask DWORD DirectDrawSetGammaRampFlags
{
/****************************************************************************
 *
 * DIRECTDRAW SETGAMMARAMP FLAGS
 *
 ****************************************************************************/

/*
 * Request calibrator to adjust the gamma ramp according to the physical
 * properties of the display so that the result should appear identical
 * on all systems.
 */
#define DDSGR_CALIBRATE                        0x00000001L

};

mask DWORD DirectDrawStartModeTestFlags
{

/****************************************************************************
 *
 * DIRECTDRAW STARTMODETEST FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDSMT_ISTESTREQUIRED                   0x00000001L

};

mask DWORD DirectDrawEvaluateModeFlags
{

/****************************************************************************
 *
 * DIRECTDRAW EVALUATEMODE FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDEM_MODEPASSED                        0x00000001L

/*
 * Indicates that the mode being tested has failed
 */
#define DDEM_MODEFAILED                        0x00000002L

};

value DWORD DDRESULT
{
/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
#define DD_OK                                   0
#define DD_FALSE                                1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED                0x88760005     [fail]

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE               0x8876000A     [fail]

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE               0x88760014     [fail]

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL                 0x88760028     [fail]

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION                         0x88760037     [fail]

/*
 * Generic failure.
 */
#define DDERR_GENERIC                           0x80004005L     [fail]

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN                       0x8876005A     [fail]

/*
 * Unable to match primary surface creation request with existing
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY               0x8876005F     [fail]

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS                       0x88760064     [fail]

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST                   0x8876006E     [fail]

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE                       0x88760078     [fail]

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT                     0x88760082     [fail]

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS                     0x80070057L     [fail]

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT                0x88760091     [fail]

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT                       0x88760096     [fail]

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES                    0x887600A0     [fail]

/*
 * There is no 3D present.
 */
#define DDERR_NO3D                              0x887600AA     [fail]

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW                         0x887600B4     [fail]

/*
 * Operation could not be carried out because there is no stereo
 * hardware present or available.
 */
#define DDERR_NOSTEREOHARDWARE          0x887600B5     [fail]

/*
 * Operation could not be carried out because there is no hardware
 * present which supports stereo surfaces
 */
#define DDERR_NOSURFACELEFT                             0x887600B6     [fail]



/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST                        0x887600CD     [fail]

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW                     0x887600D2     [fail]

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET             0x887600D4     [fail]

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY                        0x887600D7     [fail]

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW                      0x887600DC     [fail]

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT               0x887600DE     [fail]

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE                   0x887600E1     [fail]

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW                          0x887600E6     [fail]

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI                             0x887600F0     [fail]

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW                        0x887600FA     [fail]

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND                          0x887600FF     [fail]

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW                       0x88760104     [fail]

/*
 * Operation could not be carried out because the source and destination
 * rectangles are on the same surface and overlap each other.
 */
#define DDERR_OVERLAPPINGRECTS                  0x8876010E     [fail]

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW                      0x88760118     [fail]

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW                      0x88760122     [fail]

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW                       0x88760136     [fail]

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR                      0x8876013C     [fail]

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX                 0x8876013D     [fail]

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR                      0x88760140     [fail]

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW                       0x8876014A     [fail]

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW                         0x8876014F     [fail]

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW                       0x88760154     [fail]

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW                      0x8876015E     [fail]

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS                         0x88760168     [fail]

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY                       0x8007000EL     [fail]

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY                  0x8876017C     [fail]

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP                   0x8876017E     [fail]

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE      0x88760180     [fail]

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY                       0x88760183     [fail]

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET                    0x88760190     [fail]

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED            0x8876019A     [fail]

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT           0x887601A4     [fail]

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY                       0x887601AE     [fail]

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 * Will also happen on attempts to lock an optimized surface.
 */
#define DDERR_CANTLOCKSURFACE                   0x887601B3     [fail]

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED                 0x887601B8     [fail]

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should
 * have Restore called on it.
 */
#define DDERR_SURFACELOST                       0x887601C2     [fail]

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED                0x887601CC     [fail]

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT                      0x887601D6     [fail]

/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE                        0x887601E0     [fail]

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH                       0x887601EA     [fail]

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED                       0x80004001L     [fail]

/*
 * Pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT                 0x887601FE     [fail]

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK                   0x88760208     [fail]

/*
 * The specified stream contains invalid data
 */
#define DDERR_INVALIDSTREAM                     0x88760209     [fail]

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS           0x88760219     [fail]

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING                   0x8876021C     [fail]


/*
 * The specified surface type requires specification of the COMPLEX flag
 */
#define DDERR_DDSCAPSCOMPLEXREQUIRED            0x8876021E     [fail]


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN                            0x88760230     [fail]

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID             0x88760231     [fail]

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED          0x88760232     [fail]

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW                    0x88760233     [fail]

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS       0x88760234     [fail]

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION                       0x88760235     [fail]

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL                    0x88760236     [fail]

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND                0x88760237     [fail]

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED                 0x88760238     [fail]

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND                            0x88760239     [fail]

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED                    0x8876023A     [fail]

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET                    0x8876023B     [fail]

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED                 0x8876023C     [fail]

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW                       0x8876023D     [fail]

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP                   0x8876023E     [fail]

/*
 * No blter.
 */
#define DDERR_NOBLTHW                           0x8876023F     [fail]

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW                        0x88760240     [fail]

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE                 0x88760241     [fail]

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST                     0x88760242     [fail]

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION                   0x88760243     [fail]

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE                0x88760244     [fail]

/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET           0x88760245     [fail]

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE                      0x88760246     [fail]

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE                     0x88760247     [fail]

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED                         0x88760248     [fail]

/*
 * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
 * surface when the surface had no palette AND the display mode was not palette-indexed
 * (in this case DirectDraw cannot select a proper palette into the DC)
 */
#define DDERR_CANTCREATEDC                      0x88760249     [fail]

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC                              0x8876024A     [fail]

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE                         0x8876024B     [fail]

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED                 0x8876024C     [fail]

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED                     0x8876024D     [fail]


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE                   0x8876024E     [fail]

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW                        0x8876024F     [fail]

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                0x88760250     [fail]


/*
 * Device does not support optimized surfaces, therefore no video memory optimized surfaces
 */
#define DDERR_NOOPTIMIZEHW                      0x88760258     [fail]

/*
 * Surface is an optimized surface, but has not yet been allocated any memory
 */
#define DDERR_NOTLOADED                         0x88760259     [fail]

/*
 * Attempt was made to create or set a device window without first setting
 * the focus window
 */
#define DDERR_NOFOCUSWINDOW                     0x8876025A     [fail]

/*
 * Attempt was made to set a palette on a mipmap sublevel
 */
#define DDERR_NOTONMIPMAPSUBLEVEL               0x8876025B     [fail]

/*
 * A DC has already been returned for this surface. Only one DC can be
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED                  0x8876026C     [fail]

/*
 * An attempt was made to allocate non-local video memory from a device
 * that does not support non-local video memory.
 */
#define DDERR_NONONLOCALVIDMEM                  0x88760276     [fail]

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK                      0x88760280     [fail]


/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK                    0x88760294     [fail]

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED                     0x887602A8     [fail]

/*
 * There is more data available than the specified buffer size could hold
 */
#define DDERR_MOREDATA                          0x887602B2     [fail]

/*
 * The data has expired and is therefore no longer valid.
 */
#define DDERR_EXPIRED                           0x887602B3     [fail]

/*
 * The mode test has finished executing.
 */
#define DDERR_TESTFINISHED                      0x887602B4     [fail]

/*
 * The mode test has switched to a new mode.
 */
#define DDERR_NEWMODE                           0x887602B5     [fail]

/*
 * D3D has not yet been initialized.
 */
#define DDERR_D3DNOTINITIALIZED                 0x887602B6     [fail]

/*
 * The video port is not active
 */
#define DDERR_VIDEONOTACTIVE                    0x887602B7     [fail]

/*
 * The monitor does not have EDID data.
 */
#define DDERR_NOMONITORINFORMATION              0x887602B8     [fail]

/*
 * The driver does not enumerate display mode refresh rates.
 */
#define DDERR_NODRIVERSUPPORT                   0x887602B9     [fail]

/*
 * Surfaces created by one direct draw device cannot be used directly by
 * another direct draw device.
 */
#define DDERR_DEVICEDOESNTOWNSURFACE            0x887602BB     [fail]



/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    0x800401F0L     [fail]

};

typedef struct _DDARGB
{
    BYTE blue;
    BYTE green;
    BYTE red;
    BYTE alpha;
} DDARGB;

typedef DDARGB *LPDDARGB;

/*
 * This version of the structure remains for backwards source compatibility.
 * The DDARGB structure is the one that should be used for all DirectDraw APIs.
 */
typedef struct _DDRGBA
{
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE alpha;
} DDRGBA;

typedef DDRGBA *LPDDRGBA;


/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY * LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        DWORD   dwFillColorDepthPixel;                    // color in RGB or Palettized
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
} DDBLTFX;

typedef DDBLTFX * LPDDBLTFX;

typedef LPVOID LPDDCAPS;

/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS * LPDDSCAPS;


/*
 * DDOSCAPS
 */
typedef struct _DDOSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDOSCAPS;

typedef DDOSCAPS * LPDDOSCAPS;

/*
 * This structure is used internally by DirectDraw.
 */
typedef struct _DDSCAPSEX
{
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    DWORD       dwCaps4;
} DDSCAPSEX, * LPDDSCAPSEX;

/*
 * DDSCAPS2
 */
typedef struct _DDSCAPS2
{
    DWORD       dwCaps;         // capabilities of surface wanted
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    DWORD       dwCaps4;
} DDSCAPS2;

typedef DDSCAPS2 * LPDDSCAPS2;

typedef struct _DDCAPS_DX1
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[8];              // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMinHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
} DDCAPS_DX1, *LPDDCAPS_DX1;

/*
 * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX3
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[8];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[8];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[8];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[8];// ROPS supported for System->System blts
    DWORD       dwReserved4;            // reserved
    DWORD       dwReserved5;            // reserved
    DWORD       dwReserved6;            // reserved
} DDCAPS_DX3, *LPDDCAPS_DX3;

/*
 * This structure is the DDCAPS structure as it was in version 5 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX5
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[8];   // ROPS supported
/* 84*/ DDSCAPS ddsCaps;                // DDSCAPS structure has all the general capabilities
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[8];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[8];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[8];// ROPS supported for System->System blts
// Members added for DX5:
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[8]; // ROPS supported for non-local->local blts
} DDCAPS_DX5, *LPDDCAPS_DX5;

typedef struct _DDCAPS_DX6
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha caps
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[8];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[8];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[8];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[8];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[8]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX6, * LPDDCAPS_DX6;

typedef struct _DDCAPS_DX7
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[8];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[8];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[8];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[8];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[8]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX7, * LPDDCAPS_DX7;

/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
        DWORD   dwRGBBitCountOrDepth;          // how many bits per pixel
        DWORD   dwRBitMask;             // mask for red bit
        DWORD   dwGBitMask;             // mask for green bits
        DWORD   dwBBitMask;             // mask for blue bits
        DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
} DDPIXELFORMAT;

typedef DDPIXELFORMAT * LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD       dwFlags;                        // flags
} DDOVERLAYFX;

typedef DDOVERLAYFX *LPDDOVERLAYFX;


/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH * LPDDBLTBATCH;


/*
 * DDGAMMARAMP
 */
typedef struct _DDGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} DDGAMMARAMP;
typedef DDGAMMARAMP * LPDDGAMMARAMP;

/*
 *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
 */

typedef struct tagDDDEVICEIDENTIFIER
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[512];
    char    szDescription[512];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;
} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;

typedef struct tagDDDEVICEIDENTIFIER2
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[512];
    char    szDescription[512];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;

    /*
     * This element is used to determine the Windows Hardware Quality Lab (WHQL)
     * certification level for this driver/device pair.
     */
    DWORD   dwWHQLLevel;

} DDDEVICEIDENTIFIER2, * LPDDDEVICEIDENTIFIER2;

/*
 * Flags for the IDirectDraw4::GetDeviceIdentifier method
 */

/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
        LONG            lPitch;                 // distance to start of next line (return value only)
    DWORD               dwBackBufferCount;      // number of back buffers requested
        DWORD           dwMipMapCount;          // number of mip-map levels requested
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

/*
 * DDSURFACEDESC2
 */
typedef struct _DDSURFACEDESC2
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
        LONG            lPitch;                 // distance to start of next line (return value only)
    DWORD               dwBackBufferCount;      // number of back buffers requested
        DWORD           dwMipMapCount;          // number of mip-map levels requestde
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
        DDCOLORKEY      ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
        DDPIXELFORMAT   ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS2            ddsCaps;                // direct draw surface capabilities
    DWORD               dwTextureStage;         // stage in multitexture cascade
} DDSURFACEDESC2;


/*
 * DDOPTSURFACEDESC
 */
typedef struct _DDOPTSURFACEDESC
{
    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
    DirectDrawOptSurfaceDescFlags       dwFlags;            // determines what fields are valid
    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
    GUID        guid;               // Compression technique GUID
    DWORD       dwCompressionRatio; // Compression ratio
} DDOPTSURFACEDESC;

/*
 * DDCOLORCONTROL
 */
typedef struct _DDCOLORCONTROL
{
    DWORD               dwSize;
    DirectDrawColorControlFlags               dwFlags;
    LONG                lBrightness;
    LONG                lContrast;
    LONG                lHue;
    LONG                lSaturation;
    LONG                lSharpness;
    LONG                lGamma;
    LONG                lColorEnable;
    DWORD               dwReserved1;
} DDCOLORCONTROL;

/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 */

/*
 * IDirectDraw
 */
interface IDirectDraw : IUnknown
{
    /*** IDirectDraw methods ***/
    DDRESULT Compact();
    DDRESULT CreateClipper( DWORD dwFlags, [out] LPDIRECTDRAWCLIPPER * lplpDDClipper, IUnknown * pUnkOuter );
    DDRESULT CreatePalette( DirectDrawPaletteCapsFlags dwFlags, LPPALETTEENTRY lpDDColorArray, [out] LPDIRECTDRAWPALETTE * lplpDDPalette, IUnknown * pUnkOuter);
    DDRESULT CreateSurface(  LPDDSURFACEDESC lpDDSurfaceDesc, [out] LPDIRECTDRAWSURFACE * lplpDDSurface, IUnknown * pUnkOuter);
    DDRESULT DuplicateSurface( LPDIRECTDRAWSURFACE lpDDSurface, [out] LPDIRECTDRAWSURFACE * lplpDupDDSurface );
    DDRESULT EnumDisplayModes( DirectDrawEnumDisplayModesFlags dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK lpEnumModesCallback );
    DDRESULT EnumSurfaces( DirectDrawEnumSurfacesFlags dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback  );
    DDRESULT FlipToGDISurface();
    DDRESULT GetCaps( [out] LPDDCAPS lpDDDriverCaps, [out] LPDDCAPS lpDDHELCaps);
    DDRESULT GetDisplayMode( [out] LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT GetFourCCCodes(  [out] LPDWORD lpNumCodes, LPDWORD lpCodes );
    DDRESULT GetGDISurface( [out] LPDIRECTDRAWSURFACE * lplpGDIDDSSurface );
    DDRESULT GetMonitorFrequency( [out] LPDWORD lpdwFrequency );
    DDRESULT GetScanLine( [out] LPDWORD lpdwScanLine );
    DDRESULT GetVerticalBlankStatus( [out] LPBOOL lpbIsInVB );
    DDRESULT Initialize( GUID * lpGUID );
    DDRESULT RestoreDisplayMode();
    DDRESULT SetCooperativeLevel( HWND hWnd, DirectDrawSetCooperativeLevelFlags dwFlags  );
    DDRESULT SetDisplayMode( DWORD dwWidth, DWORD dwHeight, DWORD dwBPP );
    DDRESULT WaitForVerticalBlank( DirectDrawWaitForVerticalBlankFlags dwFlags, HANDLE hEvent );
};

interface IDirectDraw2 : IUnknown
{
    /*** IDirectDraw methods ***/
    DDRESULT Compact();
    DDRESULT CreateClipper( DWORD dwFlags, [out] LPDIRECTDRAWCLIPPER * lplpDDClipper, IUnknown * pUnkOuter );
    DDRESULT CreatePalette( DirectDrawPaletteCapsFlags dwFlags, LPPALETTEENTRY lpDDColorArray, [out] LPDIRECTDRAWPALETTE * lplpDDPalette, IUnknown * pUnkOuter);
    DDRESULT CreateSurface(  LPDDSURFACEDESC lpDDSurfaceDesc, [out] LPDIRECTDRAWSURFACE * lplpDDSurface, IUnknown * pUnkOuter);
    DDRESULT DuplicateSurface( LPDIRECTDRAWSURFACE lpDDSurface, [out] LPDIRECTDRAWSURFACE * lplpDupDDSurface );
    DDRESULT EnumDisplayModes( DirectDrawEnumDisplayModesFlags dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK lpEnumModesCallback );
    DDRESULT EnumSurfaces( DirectDrawEnumSurfacesFlags dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback  );
    DDRESULT FlipToGDISurface();
    DDRESULT GetCaps( [out] LPDDCAPS lpDDDriverCaps, [out] LPDDCAPS lpDDHELCaps);
    DDRESULT GetDisplayMode( [out] LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT GetFourCCCodes(  [out] LPDWORD lpNumCodes, LPDWORD lpCodes );
    DDRESULT GetGDISurface( [out] LPDIRECTDRAWSURFACE * lplpGDIDDSSurface );
    DDRESULT GetMonitorFrequency( [out] LPDWORD lpdwFrequency );
    DDRESULT GetScanLine( [out] LPDWORD lpdwScanLine );
    DDRESULT GetVerticalBlankStatus( [out] LPBOOL lpbIsInVB );
    DDRESULT Initialize( GUID * lpGUID );
    DDRESULT RestoreDisplayMode();
    DDRESULT SetCooperativeLevel( HWND hWnd, DirectDrawSetCooperativeLevelFlags dwFlags  );
    DDRESULT SetDisplayMode( DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DirectDrawSetDisplayModeFlags dwFlags );
    DDRESULT WaitForVerticalBlank( DirectDrawWaitForVerticalBlankFlags dwFlags, HANDLE hEvent );
    /*** Added in the v2 interface ***/
    DDRESULT GetAvailableVidMem( LPDDSCAPS lpDDSCaps, [out] LPDWORD lpdwTotal, [out] LPDWORD lpdwFree );
};

interface IDirectDraw4 : IUnknown
{
    /*** IDirectDraw methods ***/
    DDRESULT Compact();
    DDRESULT CreateClipper( DWORD dwFlags, [out] LPDIRECTDRAWCLIPPER * lplpDDClipper, IUnknown * pUnkOuter );
    DDRESULT CreatePalette( DirectDrawPaletteCapsFlags dwFlags, LPPALETTEENTRY lpDDColorArray, [out] LPDIRECTDRAWPALETTE * lplpDDPalette, IUnknown * pUnkOuter);
    DDRESULT CreateSurface(  LPDDSURFACEDESC2 lpDDSurfaceDesc, [out] LPDIRECTDRAWSURFACE4 * lplpDDSurface, IUnknown * pUnkOuter);
    DDRESULT DuplicateSurface( LPDIRECTDRAWSURFACE4 lpDDSurface, [out] LPDIRECTDRAWSURFACE4 * lplpDupDDSurface );
    DDRESULT EnumDisplayModes( DirectDrawEnumDisplayModesFlags dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
    DDRESULT EnumSurfaces( DirectDrawEnumSurfacesFlags dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumSurfacesCallback  );
    DDRESULT FlipToGDISurface();
    DDRESULT GetCaps( [out] LPDDCAPS lpDDDriverCaps, [out] LPDDCAPS lpDDHELCaps);
    DDRESULT GetDisplayMode( [out] LPDDSURFACEDESC2 lpDDSurfaceDesc );
    DDRESULT GetFourCCCodes(  [out] LPDWORD lpNumCodes, LPDWORD lpCodes );
    DDRESULT GetGDISurface( [out] LPDIRECTDRAWSURFACE4 * lplpGDIDDSSurface );
    DDRESULT GetMonitorFrequency( [out] LPDWORD lpdwFrequency );
    DDRESULT GetScanLine( [out] LPDWORD lpdwScanLine );
    DDRESULT GetVerticalBlankStatus( [out] LPBOOL lpbIsInVB );
    DDRESULT Initialize( GUID * lpGUID );
    DDRESULT RestoreDisplayMode();
    DDRESULT SetCooperativeLevel( HWND hWnd, DirectDrawSetCooperativeLevelFlags dwFlags  );
    DDRESULT SetDisplayMode( DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DirectDrawSetDisplayModeFlags dwFlags );
    DDRESULT WaitForVerticalBlank( DirectDrawWaitForVerticalBlankFlags dwFlags, HANDLE hEvent );
    /*** Added in the v2 interface ***/
    DDRESULT GetAvailableVidMem( LPDDSCAPS2 lpDDSCaps, [out] LPDWORD lpdwTotal, [out] LPDWORD lpdwFree );
    /*** Added in the V4 Interface ***/
    DDRESULT GetSurfaceFromDC( HDC hdc, [out] LPDIRECTDRAWSURFACE4 * lpDDSurface );
    DDRESULT RestoreAllSurfaces();
    DDRESULT TestCooperativeLevel();
    DDRESULT GetDeviceIdentifier( LPDDDEVICEIDENTIFIER lpDDDI, DirectDrawGetDeviceIdentifierFlags dwFlags );
};

interface IDirectDraw7 : IUnknown
{
    /*** IDirectDraw methods ***/
    DDRESULT Compact();
    DDRESULT CreateClipper( DWORD dwFlags, [out] LPDIRECTDRAWCLIPPER * lplpDDClipper, IUnknown * pUnkOuter );
    DDRESULT CreatePalette( DirectDrawPaletteCapsFlags dwFlags, LPPALETTEENTRY lpDDColorArray, [out] LPDIRECTDRAWPALETTE * lplpDDPalette, IUnknown * pUnkOuter);
    DDRESULT CreateSurface(  LPDDSURFACEDESC2 lpDDSurfaceDesc, [out] LPDIRECTDRAWSURFACE7 * lplpDDSurface, IUnknown * pUnkOuter);
    DDRESULT DuplicateSurface( LPDIRECTDRAWSURFACE4 lpDDSurface, [out] LPDIRECTDRAWSURFACE7 * lplpDupDDSurface );
    DDRESULT EnumDisplayModes( DirectDrawEnumDisplayModesFlags dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
    DDRESULT EnumSurfaces( DirectDrawEnumSurfacesFlags dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumSurfacesCallback  );
    DDRESULT FlipToGDISurface();
    DDRESULT GetCaps( [out] LPDDCAPS lpDDDriverCaps, [out] LPDDCAPS lpDDHELCaps);
    DDRESULT GetDisplayMode( [out] LPDDSURFACEDESC2 lpDDSurfaceDesc );
    DDRESULT GetFourCCCodes(  [out] LPDWORD lpNumCodes, LPDWORD lpCodes );
    DDRESULT GetGDISurface( [out] LPDIRECTDRAWSURFACE7 * lplpGDIDDSSurface );
    DDRESULT GetMonitorFrequency( [out] LPDWORD lpdwFrequency );
    DDRESULT GetScanLine( [out] LPDWORD lpdwScanLine );
    DDRESULT GetVerticalBlankStatus( [out] LPBOOL lpbIsInVB );
    DDRESULT Initialize( GUID * lpGUID );
    DDRESULT RestoreDisplayMode();
    DDRESULT SetCooperativeLevel( HWND hWnd, DirectDrawSetCooperativeLevelFlags dwFlags  );
    DDRESULT SetDisplayMode( DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DirectDrawSetDisplayModeFlags dwFlags );
    DDRESULT WaitForVerticalBlank( DirectDrawWaitForVerticalBlankFlags dwFlags, HANDLE hEvent );
    /*** Added in the v2 interface ***/
    DDRESULT GetAvailableVidMem( LPDDSCAPS2 lpDDSCaps, [out] LPDWORD lpdwTotal, [out] LPDWORD lpdwFree );
    /*** Added in the V4 Interface ***/
    DDRESULT GetSurfaceFromDC( HDC hdc, [out] LPDIRECTDRAWSURFACE7 * lpDDSurface );
    DDRESULT RestoreAllSurfaces();
    DDRESULT TestCooperativeLevel();
    DDRESULT GetDeviceIdentifier( LPDDDEVICEIDENTIFIER2 lpDDDI, DirectDrawGetDeviceIdentifierFlags dwFlags );
    /*** Added in the V7 Interface ***/
    DDRESULT StartModeTest( LPSIZE lpModesToTest, DWORD dwNumEntries, DirectDrawStartModeTestFlags dwFlags);
    DDRESULT EvaluateMode( DirectDrawEvaluateModeFlags dwFlags, [out] DWORD * pSecondsUntilTimeout );
};

interface IDirectDrawPalette : IUnknown
{
    /*** IDirectDrawPalette methods ***/
    DDRESULT GetCaps( [out] DirectDrawPaletteCapsFlags* lpdwCaps);
    DDRESULT GetEntries( DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
    DDRESULT Initialize( LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable );
    DDRESULT SetEntries( DWORD dwFlags, DWORD dwStartingEntry, DWORD dwCount, LPPALETTEENTRY lpEntries );
};

/*
 * IDirectDrawClipper
 */
interface IDirectDrawClipper : IUnknown
{
    /*** IDirectDrawClipper methods ***/
    DDRESULT GetClipList( LPRECT lpRect, LPRGNDATA lpClipList, [out] LPDWORD lpdwSize );
    DDRESULT GetHWnd( [out] HWND * hWnd);
    DDRESULT Initialize( LPDIRECTDRAW lpDD, DWORD dwFlags );
    DDRESULT IsClipListChanged( [out] BOOL * lpbChanged );
    DDRESULT SetClipList( LPRGNDATA lpClipList, DWORD dwFlags );
    DDRESULT SetHWnd( DWORD dwFlags, HWND hWnd );
};

/*
 * IDirectDrawSurface and related interfaces
 */
interface IDirectDrawSurface : IUnknown
{
    /*** IDirectDrawSurface methods ***/
    DDRESULT AddAttachedSurface( LPDIRECTDRAWSURFACE lpDDSAttachedSurface );
    DDRESULT AddOverlayDirtyRect( LPRECT lpRect );
    DDRESULT Blt( LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DirectDrawBltFlags dwFlags, LPDDBLTFX lpDDBltFx );
    DDRESULT BltBatch( LPDDBLTBATCH lpDDBltBatch, DWORD dwCount, DWORD dwFlags );
    DDRESULT BltFast( DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
    DDRESULT DeleteAttachedSurface( DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDSurface );
    DDRESULT EnumAttachedSurfaces( LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback );
    DDRESULT EnumOverlayZOrders( DirectDrawEnumOverlayZOrderFlags dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfnCallback );
    DDRESULT Flip( LPDIRECTDRAWSURFACE lpDDSurfaceTargetOverride, DirectDrawFlipFlags dwFlags );
    DDRESULT GetAttachedSurface( LPDDSCAPS lpDDSCaps, [out] LPDIRECTDRAWSURFACE * lplpDDAttachedSurface);
    DDRESULT GetBltStatus( DirectDrawGetBltStatusFlags dwFlags );
    DDRESULT GetCaps( [out] LPDDSCAPS lpDDSCaps );
    DDRESULT GetClipper( [out] LPDIRECTDRAWCLIPPER * lplpDDClipper );
    DDRESULT GetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT GetDC( [out] HDC * phDC );
    DDRESULT GetFlipStatus( DWORD dwFlags );
    DDRESULT GetOverlayPosition( [out] LPLONG lplX, [out] LPLONG lplY );
    DDRESULT GetPalette( [out] LPDIRECTDRAWPALETTE * lplpDDPalette );
    DDRESULT GetPixelFormat( [out] LPDDPIXELFORMAT lpDDPixelFormat );
    DDRESULT GetSurfaceDesc( [out] LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT Initialize( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT IsLost();
    DDRESULT Lock( LPRECT lpDestRect,LPDDSURFACEDESC lpDDSurfaceDesc, DirectDrawSurfaceLockFlags dwFlags, HANDLE hEvent );
    DDRESULT ReleaseDC( HDC hDC );
    DDRESULT Restore();
    DDRESULT SetClipper( LPDIRECTDRAWCLIPPER lpDDClipper );
    DDRESULT SetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT SetOverlayPosition( LONG lX, LONG lY );
    DDRESULT SetPalette( LPDIRECTDRAWPALETTE lpDDPalette );
    DDRESULT Unlock( LPVOID lp );                                                                    
    DDRESULT UpdateOverlay( LPRECT lpSrcRect, LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, DirectDrawSurfaceOverlayFlags dwFlags, LPDDOVERLAYFX lpDDOverlayFx );
    DDRESULT UpdateOverlayDisplay( DWORD dwFlags );
    DDRESULT UpdateOverlayZOrder( DirectDrawUpdateOverlayZOrderFlags dwFlags, LPDIRECTDRAWSURFACE lpDDSReference );
};

/*
 * IDirectDrawSurface2 and related interfaces
 */
interface IDirectDrawSurface2 : IUnknown
{
    /*** IDirectDrawSurface methods ***/
    DDRESULT AddAttachedSurface( LPDIRECTDRAWSURFACE2 lpDDSAttachedSurface );
    DDRESULT AddOverlayDirtyRect( LPRECT lpRect );
    DDRESULT Blt( LPRECT lpDestRect, LPDIRECTDRAWSURFACE2 lpDDSrcSurface, LPRECT lpSrcRect, DirectDrawBltFlags dwFlags, LPDDBLTFX lpDDBltFx );
    DDRESULT BltBatch( LPDDBLTBATCH lpDDBltBatch, DWORD dwCount, DWORD dwFlags );
    DDRESULT BltFast( DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE2 lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
    DDRESULT DeleteAttachedSurface( DWORD dwFlags, LPDIRECTDRAWSURFACE2 lpDDSurface );
    DDRESULT EnumAttachedSurfaces( LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback );
    DDRESULT EnumOverlayZOrders( DirectDrawEnumOverlayZOrderFlags dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfnCallback );
    DDRESULT Flip( LPDIRECTDRAWSURFACE2 lpDDSurfaceTargetOverride, DirectDrawFlipFlags dwFlags );
    DDRESULT GetAttachedSurface( LPDDSCAPS lpDDSCaps, [out] LPDIRECTDRAWSURFACE2 * lplpDDAttachedSurface);
    DDRESULT GetBltStatus( DirectDrawGetBltStatusFlags dwFlags );
    DDRESULT GetCaps( [out] LPDDSCAPS lpDDSCaps );
    DDRESULT GetClipper( [out] LPDIRECTDRAWCLIPPER * lplpDDClipper );
    DDRESULT GetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT GetDC( [out] HDC * phDC );
    DDRESULT GetFlipStatus( DWORD dwFlags );
    DDRESULT GetOverlayPosition( [out] LPLONG lplX, [out] LPLONG lplY );
    DDRESULT GetPalette( [out] LPDIRECTDRAWPALETTE * lplpDDPalette );
    DDRESULT GetPixelFormat( [out] LPDDPIXELFORMAT lpDDPixelFormat );
    DDRESULT GetSurfaceDesc( [out] LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT Initialize( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT IsLost();
    DDRESULT Lock( LPRECT lpDestRect,LPDDSURFACEDESC lpDDSurfaceDesc, DirectDrawSurfaceLockFlags dwFlags, HANDLE hEvent );
    DDRESULT ReleaseDC( HDC hDC );
    DDRESULT Restore();
    DDRESULT SetClipper( LPDIRECTDRAWCLIPPER lpDDClipper );
    DDRESULT SetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT SetOverlayPosition( LONG lX, LONG lY );
    DDRESULT SetPalette( LPDIRECTDRAWPALETTE lpDDPalette );
    DDRESULT Unlock( LPVOID lp );                                                                    
    DDRESULT UpdateOverlay( LPRECT lpSrcRect, LPDIRECTDRAWSURFACE2 lpDDDestSurface, LPRECT lpDestRect, DirectDrawSurfaceOverlayFlags dwFlags, LPDDOVERLAYFX lpDDOverlayFx );
    DDRESULT UpdateOverlayDisplay( DWORD dwFlags );
    DDRESULT UpdateOverlayZOrder( DirectDrawUpdateOverlayZOrderFlags dwFlags, LPDIRECTDRAWSURFACE2 lpDDSReference );
    /*** Added in the v2 interface ***/
    DDRESULT GetDDInterface( [out] IUnknown* lplpDD );
    DDRESULT PageLock( DWORD dwFlags );
    DDRESULT PageUnlock( DWORD dwFlags );
};

/*
 * IDirectDrawSurface3 and related interfaces
 */
interface IDirectDrawSurface3 : IUnknown
{
    /*** IDirectDrawSurface methods ***/
    DDRESULT AddAttachedSurface( LPDIRECTDRAWSURFACE3 lpDDSAttachedSurface );
    DDRESULT AddOverlayDirtyRect( LPRECT lpRect );
    DDRESULT Blt( LPRECT lpDestRect, LPDIRECTDRAWSURFACE3 lpDDSrcSurface, LPRECT lpSrcRect, DirectDrawBltFlags dwFlags, LPDDBLTFX lpDDBltFx );
    DDRESULT BltBatch( LPDDBLTBATCH lpDDBltBatch, DWORD dwCount, DWORD dwFlags );
    DDRESULT BltFast( DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE3 lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
    DDRESULT DeleteAttachedSurface( DWORD dwFlags, LPDIRECTDRAWSURFACE3 lpDDSurface );
    DDRESULT EnumAttachedSurfaces( LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback );
    DDRESULT EnumOverlayZOrders( DirectDrawEnumOverlayZOrderFlags dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfnCallback );
    DDRESULT Flip( LPDIRECTDRAWSURFACE3 lpDDSurfaceTargetOverride, DirectDrawFlipFlags dwFlags );
    DDRESULT GetAttachedSurface( LPDDSCAPS lpDDSCaps, [out] LPDIRECTDRAWSURFACE3 * lplpDDAttachedSurface);
    DDRESULT GetBltStatus( DirectDrawGetBltStatusFlags dwFlags );
    DDRESULT GetCaps( [out] LPDDSCAPS lpDDSCaps );
    DDRESULT GetClipper( [out] LPDIRECTDRAWCLIPPER * lplpDDClipper );
    DDRESULT GetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT GetDC( [out] HDC * phDC );
    DDRESULT GetFlipStatus( DWORD dwFlags );
    DDRESULT GetOverlayPosition( [out] LPLONG lplX, [out] LPLONG lplY );
    DDRESULT GetPalette( [out] LPDIRECTDRAWPALETTE * lplpDDPalette );
    DDRESULT GetPixelFormat( [out] LPDDPIXELFORMAT lpDDPixelFormat );
    DDRESULT GetSurfaceDesc( [out] LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT Initialize( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc );
    DDRESULT IsLost();
    DDRESULT Lock( LPRECT lpDestRect,LPDDSURFACEDESC lpDDSurfaceDesc, DirectDrawSurfaceLockFlags dwFlags, HANDLE hEvent );
    DDRESULT ReleaseDC( HDC hDC );
    DDRESULT Restore();
    DDRESULT SetClipper( LPDIRECTDRAWCLIPPER lpDDClipper );
    DDRESULT SetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT SetOverlayPosition( LONG lX, LONG lY );
    DDRESULT SetPalette( LPDIRECTDRAWPALETTE lpDDPalette );
    DDRESULT Unlock( LPVOID lp );                                                                    
    DDRESULT UpdateOverlay( LPRECT lpSrcRect, LPDIRECTDRAWSURFACE3 lpDDDestSurface, LPRECT lpDestRect, DirectDrawSurfaceOverlayFlags dwFlags, LPDDOVERLAYFX lpDDOverlayFx );
    DDRESULT UpdateOverlayDisplay( DWORD dwFlags );
    DDRESULT UpdateOverlayZOrder( DirectDrawUpdateOverlayZOrderFlags dwFlags, LPDIRECTDRAWSURFACE3 lpDDSReference );
    /*** Added in the v2 interface ***/
    DDRESULT GetDDInterface( [out] IUnknown* lplpDD );
    DDRESULT PageLock( DWORD dwFlags );
    DDRESULT PageUnlock( DWORD dwFlags );
    /*** Added in the V3 interface ***/
    DDRESULT SetSurfaceDesc( LPDDSURFACEDESC lpDDSD, DWORD dwFlags );
};


/*
 * IDirectDrawSurface4 and related interfaces
 */
interface IDirectDrawSurface4 : IUnknown
{
    /*** IDirectDrawSurface methods ***/
    DDRESULT AddAttachedSurface( LPDIRECTDRAWSURFACE4 lpDDSAttachedSurface );
    DDRESULT AddOverlayDirtyRect( LPRECT lpRect );
    DDRESULT Blt( LPRECT lpDestRect, LPDIRECTDRAWSURFACE4 lpDDSrcSurface, LPRECT lpSrcRect, DirectDrawBltFlags dwFlags, LPDDBLTFX lpDDBltFx );
    DDRESULT BltBatch( LPDDBLTBATCH lpDDBltBatch, DWORD dwCount, DWORD dwFlags );
    DDRESULT BltFast( DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE4 lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
    DDRESULT DeleteAttachedSurface( DWORD dwFlags, LPDIRECTDRAWSURFACE4 lpDDSurface );
    DDRESULT EnumAttachedSurfaces( LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumSurfacesCallback );
    DDRESULT EnumOverlayZOrders( DirectDrawEnumOverlayZOrderFlags dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpfnCallback );
    DDRESULT Flip( LPDIRECTDRAWSURFACE4 lpDDSurfaceTargetOverride, DirectDrawFlipFlags dwFlags );
    DDRESULT GetAttachedSurface( LPDDSCAPS lpDDSCaps, [out] LPDIRECTDRAWSURFACE4 * lplpDDAttachedSurface);
    DDRESULT GetBltStatus( DirectDrawGetBltStatusFlags dwFlags );
    DDRESULT GetCaps( [out] LPDDSCAPS lpDDSCaps );
    DDRESULT GetClipper( [out] LPDIRECTDRAWCLIPPER * lplpDDClipper );
    DDRESULT GetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT GetDC( [out] HDC * phDC );
    DDRESULT GetFlipStatus( DWORD dwFlags );
    DDRESULT GetOverlayPosition( [out] LPLONG lplX, [out] LPLONG lplY );
    DDRESULT GetPalette( [out] LPDIRECTDRAWPALETTE * lplpDDPalette );
    DDRESULT GetPixelFormat( [out] LPDDPIXELFORMAT lpDDPixelFormat );
    DDRESULT GetSurfaceDesc( [out] LPDDSURFACEDESC2 lpDDSurfaceDesc );
    DDRESULT Initialize( LPDIRECTDRAW lpDD, LPDDSURFACEDESC2 lpDDSurfaceDesc );
    DDRESULT IsLost();
    DDRESULT Lock( LPRECT lpDestRect,LPDDSURFACEDESC2 lpDDSurfaceDesc, DirectDrawSurfaceLockFlags dwFlags, HANDLE hEvent );
    DDRESULT ReleaseDC( HDC hDC );
    DDRESULT Restore();
    DDRESULT SetClipper( LPDIRECTDRAWCLIPPER lpDDClipper );
    DDRESULT SetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT SetOverlayPosition( LONG lX, LONG lY );
    DDRESULT SetPalette( LPDIRECTDRAWPALETTE lpDDPalette );
    DDRESULT Unlock( LPVOID lp );                                                                    
    DDRESULT UpdateOverlay( LPRECT lpSrcRect, LPDIRECTDRAWSURFACE4 lpDDDestSurface, LPRECT lpDestRect, DirectDrawSurfaceOverlayFlags dwFlags, LPDDOVERLAYFX lpDDOverlayFx );
    DDRESULT UpdateOverlayDisplay( DWORD dwFlags );
    DDRESULT UpdateOverlayZOrder( DirectDrawUpdateOverlayZOrderFlags dwFlags, LPDIRECTDRAWSURFACE4 lpDDSReference );
    /*** Added in the v2 interface ***/
    DDRESULT GetDDInterface( [out] IUnknown* lplpDD );
    DDRESULT PageLock( DWORD dwFlags );
    DDRESULT PageUnlock( DWORD dwFlags );
    /*** Added in the V3 interface ***/
    DDRESULT SetSurfaceDesc( LPDDSURFACEDESC2 lpDDSD, DWORD dwFlags );
    /*** Added in the v4 interface ***/
    DDRESULT SetPrivateData( REFGUID guidTag, LPVOID lpData, DWORD cbSize, DWORD dwFlags );
    DDRESULT GetPrivateData( REFGUID guidTag, LPVOID lpData, [out] LPDWORD lpcbBufferSize );
    DDRESULT FreePrivateData( REFGUID guidTag );
    DDRESULT GetUniquenessValue( [out] LPDWORD lpValue );
    DDRESULT ChangeUniquenessValue();
};

/*
 * IDirectDrawSurface7 and related interfaces
 */
interface IDirectDrawSurface7 : IUnknown
{
    /*** IDirectDrawSurface methods ***/
    DDRESULT AddAttachedSurface( LPDIRECTDRAWSURFACE7 lpDDSAttachedSurface );
    DDRESULT AddOverlayDirtyRect( LPRECT lpRect );
    DDRESULT Blt( LPRECT lpDestRect, LPDIRECTDRAWSURFACE7 lpDDSrcSurface, LPRECT lpSrcRect, DirectDrawBltFlags dwFlags, LPDDBLTFX lpDDBltFx );
    DDRESULT BltBatch( LPDDBLTBATCH lpDDBltBatch, DWORD dwCount, DWORD dwFlags );
    DDRESULT BltFast( DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE7 lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
    DDRESULT DeleteAttachedSurface( DWORD dwFlags, LPDIRECTDRAWSURFACE7 lpDDSurface );
    DDRESULT EnumAttachedSurfaces( LPVOID lpContext, LPDDENUMSURFACESCALLBACK7 lpEnumSurfacesCallback );
    DDRESULT EnumOverlayZOrders( DirectDrawEnumOverlayZOrderFlags dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK7 lpfnCallback );
    DDRESULT Flip( LPDIRECTDRAWSURFACE7 lpDDSurfaceTargetOverride, DirectDrawFlipFlags dwFlags );
    DDRESULT GetAttachedSurface( LPDDSCAPS2 lpDDSCaps, [out] LPDIRECTDRAWSURFACE7 * lplpDDAttachedSurface);
    DDRESULT GetBltStatus( DirectDrawGetBltStatusFlags dwFlags );
    DDRESULT GetCaps( [out] LPDDSCAPS2 lpDDSCaps );
    DDRESULT GetClipper( [out] LPDIRECTDRAWCLIPPER * lplpDDClipper );
    DDRESULT GetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT GetDC( [out] HDC * phDC );
    DDRESULT GetFlipStatus( DWORD dwFlags );
    DDRESULT GetOverlayPosition( [out] LPLONG lplX, [out] LPLONG lplY );
    DDRESULT GetPalette( [out] LPDIRECTDRAWPALETTE * lplpDDPalette );
    DDRESULT GetPixelFormat( [out] LPDDPIXELFORMAT lpDDPixelFormat );
    DDRESULT GetSurfaceDesc( [out] LPDDSURFACEDESC2 lpDDSurfaceDesc );
    DDRESULT Initialize( LPDIRECTDRAW lpDD, LPDDSURFACEDESC2 lpDDSurfaceDesc );
    DDRESULT IsLost();
    DDRESULT Lock( LPRECT lpDestRect,LPDDSURFACEDESC2 lpDDSurfaceDesc, DirectDrawSurfaceLockFlags dwFlags, HANDLE hEvent );
    DDRESULT ReleaseDC( HDC hDC );
    DDRESULT Restore();
    DDRESULT SetClipper( LPDIRECTDRAWCLIPPER lpDDClipper );
    DDRESULT SetColorKey( DirectDrawSurfaceSetGetColorKeyFlags dwFlags, [out] LPDDCOLORKEY lpDDColorKey );
    DDRESULT SetOverlayPosition( LONG lX, LONG lY );
    DDRESULT SetPalette( LPDIRECTDRAWPALETTE lpDDPalette );
    DDRESULT Unlock( LPVOID lp );                                                                    
    DDRESULT UpdateOverlay( LPRECT lpSrcRect, LPDIRECTDRAWSURFACE7 lpDDDestSurface, LPRECT lpDestRect, DirectDrawSurfaceOverlayFlags dwFlags, LPDDOVERLAYFX lpDDOverlayFx );
    DDRESULT UpdateOverlayDisplay( DWORD dwFlags );
    DDRESULT UpdateOverlayZOrder( DirectDrawUpdateOverlayZOrderFlags dwFlags, LPDIRECTDRAWSURFACE7 lpDDSReference );
    /*** Added in the v2 interface ***/
    DDRESULT GetDDInterface( [out] IUnknown* lplpDD );
    DDRESULT PageLock( DWORD dwFlags );
    DDRESULT PageUnlock( DWORD dwFlags );
    /*** Added in the V3 interface ***/
    DDRESULT SetSurfaceDesc( LPDDSURFACEDESC2 lpDDSD, DWORD dwFlags );
    /*** Added in the v4 interface ***/
    DDRESULT SetPrivateData( REFGUID guidTag, LPVOID lpData, DWORD cbSize, DWORD dwFlags );
    DDRESULT GetPrivateData( REFGUID guidTag, LPVOID lpData, [out] LPDWORD lpcbBufferSize );
    DDRESULT FreePrivateData( REFGUID guidTag );
    DDRESULT GetUniquenessValue( [out] LPDWORD lpValue );
    DDRESULT ChangeUniquenessValue();
    /*** Moved Texture7 methods here ***/
    DDRESULT SetPriority( DWORD dwPriority );
    DDRESULT GetPriority( [out] LPDWORD lpdwPriority );
    DDRESULT SetLOD( DWORD dwMaxLOD );
    DDRESULT GetLOD( [out] LPDWORD lpdwMaxLOD );
};

/*
 * IDirectDrawColorControl
 */
interface IDirectDrawColorControl : IUnknown
{
    /*** IDirectDrawColorControl methods ***/
    DDRESULT GetColorControls( LPDDCOLORCONTROL lpColorControl );
    DDRESULT SetColorControls( LPDDCOLORCONTROL lpColorControl );
};

/*
 * IDirectDrawGammaControl
 */
interface IDirectDrawGammaControl : IUnknown
{
    /*** IDirectDrawGammaControl methods ***/
    DDRESULT GetGammaRamp( DWORD dwFlags, LPDDGAMMARAMP lpRampData );
    DDRESULT SetGammaRamp( DirectDrawSetGammaRampFlags dwFlags, LPDDGAMMARAMP lpRampData );
};

DDRESULT DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
DDRESULT DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
DDRESULT DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DirectDrawEnumerateExFlags dwFlags);
DDRESULT DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DirectDrawEnumerateExFlags dwFlags);

DDRESULT DirectDrawCreate( DirectDrawCreateFlags lpGUID, [out] LPDIRECTDRAW *lplpDD, IUnknown *pUnkOuter );
DDRESULT DirectDrawCreateEx( DirectDrawCreateFlags lpGuid, [out] COM_INTERFACE_PTR *lplpDD, [iid] REFIID  iid, IUnknown *pUnkOuter );
DDRESULT DirectDrawCreateClipper( DWORD dwFlags, [out] LPDIRECTDRAWCLIPPER *lplpDDClipper, IUnknown *pUnkOuter );

HRESULT DllGetClassObject(
  REFCLSID rclsid,  //CLSID for the class object
  [iid] REFIID riid,      //Reference to the identifier of the interface 
                    // that communicates with the class object
  [out] COM_INTERFACE_PTR * ppv      //Address of output variable that receives the 
                    // interface pointer requested in riid
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\d3d8caps.h ===
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
//                              D3D8 Caps
//
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

//
// Masks
//

//
// Caps
//
mask DWORD d3dCaps8
{
#define D3DCAPS_READ_SCANLINE           0x00020000L
};

//
// Caps2
//
mask DWORD d3dCaps28
{
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L
};

//
// Caps3
//
mask DWORD d3dCaps38
{
#define D3DCAPS3_RESERVED               0x8000001fL
};

//
// CursorCaps
//
mask DWORD d3dCursorCaps8
{
#define D3DCURSORCAPS_COLOR             0x00000001L
#define D3DCURSORCAPS_LOWRES            0x00000002L
};

//
// DevCaps
//
mask DWORD d3dDevCaps8
{
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L
#define D3DDEVCAPS_PUREDEVICE           0x00100000L
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L
#define D3DDEVCAPS_RTPATCHES            0x00400000L
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L
#define D3DDEVCAPS_NPATCHES             0x01000000L
};

//
// PrimitiveMiscCaps
//
mask DWORD d3dPrimitiveMiscCaps8
{
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L
#define D3DPMISCCAPS_BLENDOP            0x00000800L
};

//
// LineCaps
//
mask DWORD d3dLineCaps8
{
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L
};

//
// RasterCaps
//
mask DWORD d3dRasterCaps8
{
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L
};

//
// ZCmpCaps, AlphaCmpCaps
//
mask DWORD d3dCmpCaps8
{
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L
};

//
// SourceBlendCaps, DestBlendCaps
//
mask DWORD d3dBlendCaps8
{
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L
};

//
// ShadeCaps
//
mask DWORD d3dShadeCaps8
{
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L
};

//
// TextureCaps
//
mask DWORD d3dTextureCaps8
{
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L
#define D3DPTEXTURECAPS_POW2                0x00000002L
#define D3DPTEXTURECAPS_ALPHA               0x00000004L
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L
};

//
// TextureFilterCaps
//
mask DWORD d3dTextureFilterCaps8
{
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L
};

//
// TextureAddressCaps
//
mask DWORD d3dTextureAddressCaps8
{
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L
};

//
// StencilCaps
//
mask DWORD d3dStencilCaps8
{
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L
};

//
// TextureOpCaps
//
mask DWORD d3dTextureOpCaps8
{
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L
};

//
// FVFCaps
//
mask DWORD d3dFVFCaps8
{
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L
#define D3DFVFCAPS_PSIZE                0x00100000L
};

//
// VertexProcessingCaps
//
mask DWORD d3dVertexProcessingCaps8
{
#define D3DVTXPCAPS_TEXGEN              0x00000001L
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L
#define D3DVTXPCAPS_TWEENING            0x00000040L
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L
};


//
// Structs
//

typedef struct _D3DCAPS8
{
    D3DDEVTYPE                DeviceType;
    d3dAdapterID8             AdapterOrdinal;
    d3dCaps8                  Caps;
    d3dCaps28                 Caps2;
    d3dCaps38                 Caps3;
    d3dPresentationIntervals8 PresentationIntervals;
    d3dCursorCaps8            CursorCaps;
    d3dDevCaps8               DevCaps;
    d3dPrimitiveMiscCaps8     PrimitiveMiscCaps;
    d3dRasterCaps8            RasterCaps;
    d3dCmpCaps8               ZCmpCaps;
    d3dBlendCaps8             SrcBlendCaps;
    d3dBlendCaps8             DestBlendCaps;
    d3dCmpCaps8               AlphaCmpCaps;
    d3dShadeCaps8             ShadeCaps;
    d3dTextureCaps8           TextureCaps;
    d3dTextureFilterCaps8     TextureFilterCaps;
    d3dTextureFilterCaps8     CubeTextureFilterCaps;
    d3dTextureFilterCaps8     VolumeTextureFilterCaps;
    d3dTextureAddressCaps8    TextureAddressCaps;
    d3dTextureAddressCaps8    VolumeTextureAddressCaps;
    d3dLineCaps8              LineCaps;
    DWORD                     MaxTextureWidth;
	DWORD                     MaxTextureHeight;
    DWORD                     MaxVolumeExtent;
    DWORD                     MaxTextureRepeat;
    DWORD                     MaxTextureAspectRatio;
    DWORD                     MaxAnisotropy;
    float                     MaxVertexW;
    float                     GuardBandLeft;
    float                     GuardBandTop;
    float                     GuardBandRight;
    float                     GuardBandBottom;
    float                     ExtentsAdjust;
    d3dStencilCaps8           StencilCaps;
    d3dFVFCaps8               FVFCaps;
    d3dTextureOpCaps8         TextureOpCaps;
    DWORD                     MaxTextureBlendStages;
    DWORD                     MaxSimultaneousTextures;
    d3dVertexProcessingCaps8  VertexProcessingCaps;
    DWORD                     MaxActiveLights;
    DWORD                     MaxUserClipPlanes;
    DWORD                     MaxVertexBlendMatrices;
    DWORD                     MaxVertexBlendMatrixIndex;
    float                     MaxPointSize;
    DWORD                     MaxPrimitiveCount;
    DWORD                     MaxVertexIndex;
    DWORD                     MaxStreams;
    DWORD                     MaxStreamStride;
    DWORD                     VertexShaderVersion;
    DWORD                     MaxVertexShaderConst;
    DWORD                     PixelShaderVersion;
    float                     MaxPixelShaderValue;
} D3DCAPS8, *LPD3DCAPS8;

alias LPD3DCAPS8;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\d3d8types.h ===
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
//                              D3D8 Types
//
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

//
// Typedefs
//


//
// Masks
//

mask DWORD d3dUsage8
{
#define D3DUSAGE_RENDERTARGET          0x00000001
#define D3DUSAGE_DEPTHSTENCIL          0x00000002
#define D3DUSAGE_WRITEONLY             0x00000008
#define D3DUSAGE_SOFTWAREPROCESSING    0x00000010
#define D3DUSAGE_DONOTCLIP             0x00000020
#define D3DUSAGE_POINTS                0x00000040
#define D3DUSAGE_RTPATCHES             0x00000080
#define D3DUSAGE_NPATCHES              0x00000100
#define D3DUSAGE_DYNAMIC               0x00000200
};

mask DWORD d3dPresentParamsFlags8
{
#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER  0x00000001
};

mask DWORD d3dPresentationIntervals8
{
#define D3DPRESENT_INTERVAL_ONE        0x00000001
#define D3DPRESENT_INTERVAL_TWO        0x00000002
#define D3DPRESENT_INTERVAL_THREE      0x00000004
#define D3DPRESENT_INTERVAL_FOUR       0x00000008
#define D3DPRESENT_INTERVAL_IMMEDIATE  0x80000000
};

mask DWORD d3dLockFlags8
{
#define D3DLOCK_READONLY               0x00000010
#define D3DLOCK_DISCARD                0x00002000
#define D3DLOCK_NOOVERWRITE            0x00001000
#define D3DLOCK_NOSYSLOCK              0x00000800
#define D3DLOCK_NO_DIRTY_UPDATE        0x00008000
};

mask DWORD d3dFVF8
{
#define D3DFVF_RESERVED0               0x001
#define D3DFVF_XYZ                     0x002
#define D3DFVF_XYZRHW                  0x004
#define D3DFVF_XYZB2                   0x008
#define D3DFVF_NORMAL                  0x010
#define D3DFVF_PSIZE                   0x020
#define D3DFVF_DIFFUSE                 0x040
#define D3DFVF_SPECULAR                0x080
#define D3DFVF_TEX1                    0x100
#define D3DFVF_TEX2                    0x200
#define D3DFVF_TEX4                    0x400
#define D3DFVF_TEX8                    0x800
#define D3DFVF_LASTBETA_UBYTE4         0x1000
#define D3DFVF_RESERVED                0xFFFFE000
};

mask DWORD d3dBehaviorFlags8
{
#define D3DCREATE_FPU_PRESERVE              0x00000002
#define D3DCREATE_MULTITHREADED             0x00000004
#define D3DCREATE_PUREDEVICE                0x00000010
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING 0x00000020
#define D3DCREATE_HARDWARE_VERTEXPROCESSING 0x00000040
#define D3DCREATE_MIXED_VERTEXPROCESSING    0x00000080
};

mask DWORD d3dClearFlags8
{
#define D3DCLEAR_TARGET                 0x00000001
#define D3DCLEAR_ZBUFFER                0x00000002
#define D3DCLEAR_STENCIL                0x00000004
};

mask DWORD d3dClipStatus8
{
#define D3DCS_LEFT                      0x00000001L
#define D3DCS_RIGHT                     0x00000002L
#define D3DCS_TOP                       0x00000004L
#define D3DCS_BOTTOM                    0x00000008L
#define D3DCS_FRONT                     0x00000010L
#define D3DCS_BACK                      0x00000020L
#define D3DCS_PLANE0                    0x00000040L
#define D3DCS_PLANE1                    0x00000080L
#define D3DCS_PLANE2                    0x00000100L
#define D3DCS_PLANE3                    0x00000200L
#define D3DCS_PLANE4                    0x00000400L
#define D3DCS_PLANE5                    0x00000800L
};

mask DWORD d3dProcessVerticesFlags
{
#define D3DPV_DONOTCOPYDATA             1
};

//
// Values
//


value UINT d3dAdapterID8
{
#define D3DADAPTER_DEFAULT              0
};

value DWORD D3DDEVTYPE
{
#define D3DDEVTYPE_HAL                  1
#define D3DDEVTYPE_REF                  2
#define D3DDEVTYPE_SW                   3
};

value DWORD D3DMULTISAMPLE_TYPE
{
#define D3DMULTISAMPLE_NONE             0
#define D3DMULTISAMPLE_2_SAMPLES        2
#define D3DMULTISAMPLE_3_SAMPLES        3
#define D3DMULTISAMPLE_4_SAMPLES        4
#define D3DMULTISAMPLE_5_SAMPLES        5
#define D3DMULTISAMPLE_6_SAMPLES        6
#define D3DMULTISAMPLE_7_SAMPLES        7
#define D3DMULTISAMPLE_8_SAMPLES        8
#define D3DMULTISAMPLE_9_SAMPLES        9
#define D3DMULTISAMPLE_10_SAMPLES      10
#define D3DMULTISAMPLE_11_SAMPLES      11
#define D3DMULTISAMPLE_12_SAMPLES      12
#define D3DMULTISAMPLE_13_SAMPLES      13
#define D3DMULTISAMPLE_14_SAMPLES      14
#define D3DMULTISAMPLE_15_SAMPLES      15
#define D3DMULTISAMPLE_16_SAMPLES      16
};

value DWORD D3DRESOURCETYPE
{
#define D3DRTYPE_SURFACE                1
#define D3DRTYPE_VOLUME                 2
#define D3DRTYPE_TEXTURE                3
#define D3DRTYPE_VOLUMETEXTURE          4
#define D3DRTYPE_CUBETEXTURE            5
#define D3DRTYPE_VERTEXBUFFER           6
#define D3DRTYPE_INDEXBUFFER            7
};

value DWORD D3DSWAPEFFECT
{
#define D3DSWAPEFFECT_DEFAULT           0
#define D3DSWAPEFFECT_DISCARD           1
#define D3DSWAPEFFECT_FLIP              2
#define D3DSWAPEFFECT_COPY              3
#define D3DSWAPEFFECT_COPY_VSYNC        4
};

value UINT d3dRefreshRate8
{
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x7fffffff
};

value DWORD D3DPOOL
{
#define D3DPOOL_DEFAULT                 0
#define D3DPOOL_MANAGED                 1
#define D3DPOOL_SYSTEMMEM               2
};

value DWORD D3DCUBEMAP_FACES
{
#define D3DCUBEMAP_FACE_POSITIVE_X      0
#define D3DCUBEMAP_FACE_NEGATIVE_X      1
#define D3DCUBEMAP_FACE_POSITIVE_Y      2
#define D3DCUBEMAP_FACE_NEGATIVE_Y      3
#define D3DCUBEMAP_FACE_POSITIVE_Z      4
#define D3DCUBEMAP_FACE_NEGATIVE_Z      5
};

value DWORD D3DBACKBUFFER_TYPE
{
#define D3DBACKBUFFER_TYPE_MONO         0
#define D3DBACKBUFFER_TYPE_LEFT         1
#define D3DBACKBUFFER_TYPE_RIGHT        2
};

value DWORD D3DTRANSFORMSTATETYPE8
{
#define D3DTS_VIEW                      2
#define D3DTS_PROJECTION                3
#define D3DTS_TEXTURE0                 16
#define D3DTS_TEXTURE1                 17
#define D3DTS_TEXTURE2                 18
#define D3DTS_TEXTURE3                 19
#define D3DTS_TEXTURE4                 20
#define D3DTS_TEXTURE5                 21
#define D3DTS_TEXTURE6                 22
#define D3DTS_TEXTURE7                 23
#define D3DTS_WORLD                   256
#define D3DTS_WORLD1                  257
#define D3DTS_WORLD2                  258
#define D3DTS_WORLD3                  259
};

value DWORD D3DLIGHTTYPE8
{
#define D3DLIGHT_POINT                  1
#define D3DLIGHT_SPOT                   2
#define D3DLIGHT_DIRECTIONAL            3
};

value DWORD D3DRENDERSTATETYPE8
{
#define D3DRS_ZENABLE                    7  
#define D3DRS_FILLMODE                   8  
#define D3DRS_SHADEMODE                  9  
#define D3DRS_LINEPATTERN               10 
#define D3DRS_ZWRITEENABLE              14 
#define D3DRS_ALPHATESTENABLE           15 
#define D3DRS_LASTPIXEL                 16 
#define D3DRS_SRCBLEND                  19 
#define D3DRS_DESTBLEND                 20 
#define D3DRS_CULLMODE                  22 
#define D3DRS_ZFUNC                     23 
#define D3DRS_ALPHAREF                  24 
#define D3DRS_ALPHAFUNC                 25 
#define D3DRS_DITHERENABLE              26 
#define D3DRS_ALPHABLENDENABLE          27 
#define D3DRS_FOGENABLE                 28 
#define D3DRS_SPECULARENABLE            29 
#define D3DRS_ZVISIBLE                  30 
#define D3DRS_FOGCOLOR                  34 
#define D3DRS_FOGTABLEMODE              35 
#define D3DRS_FOGSTART                  36 
#define D3DRS_FOGEND                    37 
#define D3DRS_FOGDENSITY                38 
#define D3DRS_EDGEANTIALIAS             40 
#define D3DRS_ZBIAS                     47 
#define D3DRS_RANGEFOGENABLE            48 
#define D3DRS_STENCILENABLE             52 
#define D3DRS_STENCILFAIL               53 
#define D3DRS_STENCILZFAIL              54 
#define D3DRS_STENCILPASS               55 
#define D3DRS_STENCILFUNC               56 
#define D3DRS_STENCILREF                57 
#define D3DRS_STENCILMASK               58 
#define D3DRS_STENCILWRITEMASK          59 
#define D3DRS_TEXTUREFACTOR             60 
#define D3DRS_WRAP0                    128
#define D3DRS_WRAP1                    129
#define D3DRS_WRAP2                    130
#define D3DRS_WRAP3                    131
#define D3DRS_WRAP4                    132
#define D3DRS_WRAP5                    133
#define D3DRS_WRAP6                    134
#define D3DRS_WRAP7                    135
#define D3DRS_CLIPPING                 136
#define D3DRS_LIGHTING                 137
#define D3DRS_AMBIENT                  139
#define D3DRS_FOGVERTEXMODE            140
#define D3DRS_COLORVERTEX              141
#define D3DRS_LOCALVIEWER              142
#define D3DRS_NORMALIZENORMALS         143
#define D3DRS_DIFFUSEMATERIALSOURCE    145
#define D3DRS_SPECULARMATERIALSOURCE   146
#define D3DRS_AMBIENTMATERIALSOURCE    147
#define D3DRS_EMISSIVEMATERIALSOURCE   148
#define D3DRS_VERTEXBLEND              151
#define D3DRS_CLIPPLANEENABLE          152
#define D3DRS_SOFTWAREVERTEXPROCESSING 153
#define D3DRS_POINTSIZE                154
#define D3DRS_POINTSIZE_MIN            155
#define D3DRS_POINTSPRITEENABLE        156
#define D3DRS_POINTSCALEENABLE         157
#define D3DRS_POINTSCALE_A             158
#define D3DRS_POINTSCALE_B             159
#define D3DRS_POINTSCALE_C             160
#define D3DRS_MULTISAMPLEANTIALIAS     161
#define D3DRS_MULTISAMPLEMASK          162
#define D3DRS_PATCHEDGESTYLE           163
#define D3DRS_PATCHSEGMENTS            164
#define D3DRS_DEBUGMONITORTOKEN        165
#define D3DRS_POINTSIZE_MAX            166
#define D3DRS_INDEXEDVERTEXBLENDENABLE 167
#define D3DRS_COLORWRITEENABLE         168
#define D3DRS_TWEENFACTOR              170
#define D3DRS_BLENDOP                  171
};

value DWORD D3DTEXTURESTAGESTATETYPE8
{
#define D3DTSS_COLOROP                  1
#define D3DTSS_COLORARG1                2
#define D3DTSS_COLORARG2                3
#define D3DTSS_ALPHAOP                  4
#define D3DTSS_ALPHAARG1                5
#define D3DTSS_ALPHAARG2                6
#define D3DTSS_BUMPENVMAT00             7
#define D3DTSS_BUMPENVMAT01             8
#define D3DTSS_BUMPENVMAT10             9
#define D3DTSS_BUMPENVMAT11            10
#define D3DTSS_TEXCOORDINDEX           11
#define D3DTSS_ADDRESSU                13
#define D3DTSS_ADDRESSV                14
#define D3DTSS_BORDERCOLOR             15
#define D3DTSS_MAGFILTER               16
#define D3DTSS_MINFILTER               17
#define D3DTSS_MIPFILTER               18
#define D3DTSS_MIPMAPLODBIAS           19
#define D3DTSS_MAXMIPLEVEL             20
#define D3DTSS_MAXANISOTROPY           21
#define D3DTSS_BUMPENVLSCALE           22
#define D3DTSS_BUMPENVLOFFSET          23
#define D3DTSS_TEXTURETRANSFORMFLAGS   24
#define D3DTSS_ADDRESSW                25
#define D3DTSS_COLORARG0               26
#define D3DTSS_ALPHAARG0               27
#define D3DTSS_RESULTARG               28
};

value DWORD D3DSTATEBLOCKTYPE8
{
#define D3DSBT_ALL                      1
#define D3DSBT_PIXELSTATE               2
#define D3DSBT_VERTEXSTATE              3
};

value DWORD D3DPRIMITIVETYPE8
{
#define D3DPT_POINTLIST                 1
#define D3DPT_LINELIST                  2
#define D3DPT_LINESTRIP                 3
#define D3DPT_TRIANGLELIST              4
#define D3DPT_TRIANGLESTRIP             5
#define D3DPT_TRIANGLEFAN               6
};

value DWORD D3DBASISTYPE
{
#define D3DBASIS_BEZIER                 0
#define D3DBASIS_BSPLINE                1
#define D3DBASIS_INTERPOLATE            2
};

value DWORD D3DORDERTYPE
{
#define D3DORDER_LINEAR                 1
#define D3DORDER_CUBIC                  3
#define D3DORDER_QUINTIC                5
};

value DWORD D3DFORMAT
{
#define D3DFMT_UNKNOWN                  0
#define D3DFMT_R8G8B8                  20
#define D3DFMT_A8R8G8B8                21
#define D3DFMT_X8R8G8B8                22
#define D3DFMT_R5G6B5                  23
#define D3DFMT_X1R5G5B5                24
#define D3DFMT_A1R5G5B5                25
#define D3DFMT_A4R4G4B4                26
#define D3DFMT_R3G3B2                  27
#define D3DFMT_A8                      28
#define D3DFMT_A8R3G3B2                29
#define D3DFMT_X4R4G4B4                30
#define D3DFMT_A8P8                    40
#define D3DFMT_P8                      41
#define D3DFMT_L8                      50
#define D3DFMT_A8L8                    51
#define D3DFMT_A4L4                    52
#define D3DFMT_V8U8                    60
#define D3DFMT_L6V5U5                  61
#define D3DFMT_X8L8V8U8                62
#define D3DFMT_Q8W8V8U8                63
#define D3DFMT_V16U16                  64
#define D3DFMT_W11V11U10               65
#define D3DFMT_UYVY                    0x59565955
#define D3DFMT_YUY2                    0x32595559
#define D3DFMT_DXT1                    0x31545844 
#define D3DFMT_DXT2                    0x32545844 
#define D3DFMT_DXT3                    0x33545844 
#define D3DFMT_DXT4                    0x34545844 
#define D3DFMT_DXT5                    0x35545844 
#define D3DFMT_D16_LOCKABLE            70
#define D3DFMT_D32                     71
#define D3DFMT_D15S1                   73
#define D3DFMT_D24S8                   75
#define D3DFMT_D16                     80
#define D3DFMT_D24X8                   77
#define D3DFMT_D24X4S4                 79
#define D3DFMT_VERTEXDATA             100
#define D3DFMT_INDEX16                101
#define D3DFMT_INDEX32                102
};


//
// structs
//

typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    D3DFORMAT       Format;
} D3DDISPLAYMODE,*LPD3DDISPLAYMODE;

typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[512];
    char            Description[512];
    DWORD           DriverVersionLowPart;
    DWORD           DriverVersionHighPart;
    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;
    GUID            DeviceIdentifier;
    DWORD           WHQLLevel;
} D3DADAPTER_IDENTIFIER8,*LPD3DADAPTER_IDENTIFIER8;

typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                      BackBufferWidth;
    UINT                      BackBufferHeight;
    D3DFORMAT                 BackBufferFormat;
    UINT                      BackBufferCount;
    D3DMULTISAMPLE_TYPE       MultiSampleType;
    D3DSWAPEFFECT             SwapEffect;
    HWND                      hDeviceWindow;
    BOOL                      Windowed;
    BOOL                      EnableAutoDepthStencil;
    D3DFORMAT                 AutoDepthStencilFormat;
    d3dPresentParamsFlags8    Flags;
    d3dRefreshRate8           FullScreen_RefreshRateInHz;
    d3dPresentationIntervals8 FullScreen_PresentationInterval;
} D3DPRESENT_PARAMETERS,*LPD3DPRESENT_PARAMETERS;

typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    d3dUsage8           Usage;
    D3DPOOL             Pool;
    UINT                Size;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC,*LPD3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    d3dUsage8           Usage;
    D3DPOOL             Pool;
    UINT                Size;
    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC,*LPD3DVOLUME_DESC;

typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    LPVOID              pBits;
} D3DLOCKED_RECT,*LPD3DLOCKED_RECT;

typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX,*LPD3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    LPVOID              pBits;
} D3DLOCKED_BOX,*LPD3DLOCKED_BOX;

typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    d3dUsage8           Usage;
    D3DPOOL             Pool;
    UINT                Size;
    d3dFVF8             FVF;

} D3DVERTEXBUFFER_DESC,*LPD3DVERTEXBUFFER_DESC;

typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    d3dUsage8           Usage;
    D3DPOOL             Pool;
    UINT                Size;
} D3DINDEXBUFFER_DESC,*LPD3DINDEXBUFFER_DESC;

typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    d3dAdapterID8       AdapterOrdinal;
    D3DDEVTYPE          DeviceType;
    HWND                hFocusWindow;
    d3dBehaviorFlags8   BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS,*LPD3DDEVICE_CREATION_PARAMETERS;

typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS,*LPD3DRASTER_STATUS;

typedef struct _D3DMATRIX8
{
    float        _11;
    float        _12;
    float        _13;
    float        _14;
    float        _21;
    float        _22;
    float        _23;
    float        _24;
    float        _31;
    float        _32;
    float        _33;
    float        _34;
    float        _41;
    float        _42;
    float        _43;
    float        _44;
} D3DMATRIX8,*LPD3DMATRIX8;

typedef struct _D3DVIEWPORT8
{
    UINT        X;
    UINT        Y;
    UINT        Width;
    UINT        Height;
    float       MinZ;
    float       MaxZ;
} D3DVIEWPORT8,*LPD3DVIEWPORT8;

typedef struct _D3DMATERIAL8
{
    D3DCOLORVALUE   Diffuse;
    D3DCOLORVALUE   Ambient;
    D3DCOLORVALUE   Specular;
    D3DCOLORVALUE   Emissive;
    float           Power;
} D3DMATERIAL8,*LPD3DMATERIAL8;

typedef struct _D3DCLIPSTATUS8 {
    d3dClipStatus8  ClipUnion;
    d3dClipStatus8  ClipIntersection;
} D3DCLIPSTATUS8,*LPD3DCLIPSTATUS8;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE8   Type;
    D3DCOLORVALUE   Diffuse;
    D3DCOLORVALUE   Specular;
    D3DCOLORVALUE   Ambient;
    D3DVECTOR       Position;
    D3DVECTOR       Direction;
    float           Range;
    float           Falloff;
    float           Attenuation0;
    float           Attenuation1;
    float           Attenuation2;
    float           Theta;
    float           Phi;
} D3DLIGHT8,*LPD3DLIGHT8;

typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO,*LPD3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO,*LPD3DTRIPATCH_INFO;

typedef struct _D3DGAMMARAMP
{
    WORD                red  [256];
    WORD                green[256];
    WORD                blue [256];
} D3DGAMMARAMP,*LPD3DGAMMARAMP;

alias LPD3DDISPLAYMODE;
alias LPD3DADAPTER_IDENTIFIER8;
alias LPD3DPRESENT_PARAMETERS;
alias LPD3DSURFACE_DESC;
alias LPD3DVOLUME_DESC;
alias LPD3DLOCKED_RECT;
alias LPD3DBOX;
alias LPD3DLOCKED_BOX;
alias LPD3DVERTEXBUFFER_DESC;
alias LPD3DINDEXBUFFER_DESC;
alias LPD3DDEVICE_CREATION_PARAMETERS;
alias LPD3DRASTER_STATUS;	
alias LPD3DMATRIX8;
alias LPD3DVIEWPORT8;
alias LPD3DVECTOR;
alias LPD3DCOLORVALUE;
alias LPD3DRECT;
alias LPD3DMATERIAL8;
alias LPD3DCLIPSTATUS8;
alias LPD3DLIGHT8;
alias LPD3DRECTPATCH_INFO;
alias LPD3DTRIPATCH_INFO;
alias LPD3DGAMMARAMP;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\dsound.h ===
module DSOUND.DLL:
category DirectSound:

 class __declspec(uuid("47d4d946-62e8-11cf-93bc-444553540000"))        DirectSound;
 class __declspec(uuid("3901cc3f-84b5-4fa4-ba35-aa8172b8a09b"))        DirectSound8;
 class __declspec(uuid("b0210780-89cd-11d0-af08-00a0c925cd16"))        DirectSoundCapture;
 class __declspec(uuid("e4bcac13-7f99-4908-9a8e-74e3bf24b6e1"))        DirectSoundCapture8;
 class __declspec(uuid("fea4300c-7959-4147-b26a-2377b9e7a91d"))        DirectSoundFullDuplex;
 class __declspec(uuid("b2f586d4-5558-49d1-a07b-3249dbbb33c2"))        DirectSoundBufferConfig;

struct __declspec(uuid("279AFA83-4981-11CE-A521-0020AF0BE560")) IDirectSound;
struct __declspec(uuid("279AFA85-4981-11CE-A521-0020AF0BE560")) IDirectSoundBuffer;
struct __declspec(uuid("279AFA84-4981-11CE-A521-0020AF0BE560")) IDirectSound3DListener;
struct __declspec(uuid("279AFA86-4981-11CE-A521-0020AF0BE560")) IDirectSound3DBuffer;
struct __declspec(uuid("b0210781-89cd-11d0-af08-00a0c925cd16")) IDirectSoundCapture;
struct __declspec(uuid("b0210782-89cd-11d0-af08-00a0c925cd16")) IDirectSoundCaptureBuffer;
struct __declspec(uuid("b30f3564-1698-45ba-9f75-fc3c6c3b2810")) IDirectSoundFXSend;
struct __declspec(uuid("C50A7E93-F395-4834-9EF6-7FA99DE50966")) IDirectSound8;
struct __declspec(uuid("6825a449-7524-4d82-920f-50e36ab3ab1e")) IDirectSoundBuffer8;
struct __declspec(uuid("00990df4-0dbb-4872-833e-6d303e80aeb6")) IDirectSoundCaptureBuffer8;

struct __declspec(uuid("b0210783-89cd-11d0-af08-00a0c925cd16")) IDirectSoundNotify;
struct __declspec(uuid("31efac30-515c-11d0-a9aa-00aa0061be93")) IKsPropertySet;

struct __declspec(uuid("def00000-9c6d-47ed-aaf1-4dda8f2b5c03"))        IDefaultPlayback;
struct __declspec(uuid("def00001-9c6d-47ed-aaf1-4dda8f2b5c03"))        IDefaultCapture;
struct __declspec(uuid("def00002-9c6d-47ed-aaf1-4dda8f2b5c03"))        IDefaultVoicePlayback;
struct __declspec(uuid("def00003-9c6d-47ed-aaf1-4dda8f2b5c03"))        IDefaultVoiceCapture;
struct __declspec(uuid("d616f352-d622-11ce-aac5-0020af0b99a3"))        IDirectSoundFXGargle;
struct __declspec(uuid("880842e3-145f-43e6-a934-a71806e50547"))  IDirectSoundFXChorus;
struct __declspec(uuid("903e9878-2c92-4072-9b2c-ea68f5396783"))  IDirectSoundFXFlanger;
struct __declspec(uuid("8bd28edf-50db-4e92-a2bd-445488d1ed42"))  IDirectSoundFXEcho;
struct __declspec(uuid("8ecf4326-455f-4d8b-bda9-8d5d3e9e3e0b"))  IDirectSoundFXDistortion;
struct __declspec(uuid("4bbd1154-62f6-4e2c-a15c-d3b6c417f7a0"))  IDirectSoundFXCompressor;
struct __declspec(uuid("c03ca9fe-fe90-4204-8078-82334cd177da"))  IDirectSoundFXParamEq;
struct __declspec(uuid("4b166a6a-0d66-43f3-80e3-ee6280dee1a4"))  IDirectSoundFXI3DL2Reverb;
struct __declspec(uuid("46858c3a-0dc6-45e3-b760-d4eef16cb325"))  IDirectSoundFXWavesReverb;
struct __declspec(uuid("174d3eb9-6696-4fac-a46c-a0ac7bc9e20f"))  IDirectSoundCaptureFXAec;
struct __declspec(uuid("ed311e41-fbae-4175-9625-cd0854f693ca"))  IDirectSoundCaptureFXNoiseSuppress;
struct __declspec(uuid("edcb4c7a-daab-4216-a42e-6c50596ddc1d"))  IDirectSoundFullDuplex;




typedef IDirectSound *LPDIRECTSOUND;
typedef IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;
typedef IDirectSound3DListener *LPDIRECTSOUND3DLISTENER;
typedef IDirectSound3DBuffer *LPDIRECTSOUND3DBUFFER;
typedef IDirectSoundCapture *LPDIRECTSOUNDCAPTURE;
typedef IDirectSoundCaptureBuffer *LPDIRECTSOUNDCAPTUREBUFFER;
typedef IDirectSoundNotify *LPDIRECTSOUNDNOTIFY;

typedef IDirectSoundFXSend           *LPDIRECTSOUNDFXSEND;
typedef IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
typedef IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
typedef IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef IDirectSound8                *LPDIRECTSOUND8;
typedef IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;

typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;

//
// Flags
//

mask DWORD DSCAPS_MASK
{
#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800
};

mask DWORD DSBPLAY_MASK
{
#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020
};

mask DWORD DSBSTATUS_MASK
{
#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020
};

value DWORD DSBLOCK_VALUE
{
#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002
};

value DWORD DSSCL_VALUE
{
#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
};

value DWORD DS3DMODE_VALUE
{
#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002
};

mask DWORD DSBCAPS_MASK
{
#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSCBCAPS_CTRLFX             0x00000200
//#define DSBCAPS_CTRLDEFAULT         0x000000E0
//#define DSBCAPS_CTRLALL             0x000001F0
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000 
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000

#define DSCBCAPS_WAVEMAPPED         0x80000000
};

value DWORD DSSPEAKER_VALUE
{
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

//#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
//#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
//#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
};

value DWORD DSBFREQUENCY_VALUE
{
#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0
};

value DWORD DSBPAN_VALUE
{
#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000
};

value DWORD DSBVOLUME_VALUE
{
#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0
};

value DWORD DSBSIZE_VALUE
{
#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
};

value DWORD DS3D_VALUE
{
#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001
};


//#define DSCCAPS_EMULDRIVER          0x00000020

mask DWORD DSCBLOCK_MASK
{
#define DSCBLOCK_ENTIREBUFFER       0x00000001
};

mask DWORD DSCBSTATUS_MASK
{
#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002
};
mask DWORD DSCBSTART_MASK
{
#define DSCBSTART_LOOPING           0x00000001
};
//
//#define DSBPN_OFFSETSTOP            0xFFFFFFFF
//
mask DWORD DSFX_MASK
{
    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002
};

mask DWORD DSFXR_MASK
{
    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100
};

typedef struct _DSEFFECTDESC
{
    DWORD               dwSize;
    DWORD               dwFlags;
    GUID                guidDSFXClass;
    LPDIRECTSOUNDBUFFER lpSendBuffer;
    DWORD               dwReserved;
} DSEFFECTDESC;
typedef DSEFFECTDESC *LPDSEFFECTDESC;
typedef DSEFFECTDESC *LPCDSEFFECTDESC;

value DWORD DSFXR_ENUM
{
#define  DSFXR_PRESENT           0
#define  DSFXR_LOCHARDWARE       1
#define  DSFXR_LOCSOFTWARE       2
#define  DSFXR_UNALLOCATED       3
#define  DSFXR_FAILED            4
#define  DSFXR_UNKNOWN           5
#define  DSFXR_SENDLOOP          6
};

typedef struct _DSCEFFECTDESC
{
    DWORD       dwSize;
    DWORD       dwFlags;
    GUID        guidDSCFXClass;
    GUID        guidDSCFXInstance;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
} DSCEFFECTDESC;
typedef  DSCEFFECTDESC *LPDSCEFFECTDESC;
typedef DSCEFFECTDESC *LPCDSCEFFECTDESC;

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DSCAPS_MASK     dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef DSBCAPS *LPCDSBCAPS;

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DSBCAPS_MASK    dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef DSBUFFERDESC *LPCDSBUFFERDESC;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS 
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// Compatibility typedefs
//

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;
typedef LPVOID *LPLPVOID;
//typedef WAVEFORMATEX *LPCWAVEFORMATEX;

value DWORD DSRESULT
{
//
// Return Codes
//

#define DS_OK                           0

// The call failed because resources (such as a priority level)
// were already being used by another caller.
#define DSERR_ALLOCATED                 0x8878000A  [fail]

// The control (vol,pan,etc.) requested by the caller is not available.
#define DSERR_CONTROLUNAVAIL            0x8878001E  [fail]

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              0x80070057  [fail]

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               0x88780032  [fail]

// An undetermined error occured inside the DirectSound subsystem
#define DSERR_GENERIC                   0x80004005  [fail]

// The caller does not have the priority level required for the function to
// succeed.
#define DSERR_PRIOLEVELNEEDED           0x88780046  [fail]

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               0x8007000E  [fail]

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 0x88780064  [fail]

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               0x80004001  [fail]

// No sound driver is available for use
#define DSERR_NODRIVER                  0x88780078  [fail]

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        0x88780082  [fail]

// This object does not support aggregation
#define DSERR_NOAGGREGATION             0x80040110  [fail]

// The buffer memory has been lost, and must be restored.
#define DSERR_BUFFERLOST                0x88780096  [fail]

// Another app has a higher priority level, preventing this call from
// succeeding.
#define DSERR_OTHERAPPHASPRIO           0x887800A0  [fail]

// This object has not been initialized
#define DSERR_UNINITIALIZED             0x887800AA  [fail]

// The requested COM interface is not available
#define DSERR_NOINTERFACE               0x80000004  [fail]

// Access is denied
#define DSERR_ACCESSDENIED              0x80070005  [fail]

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            0x887800B4  [fail]

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              0x887800BE  [fail]

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  0x887800C8  [fail]

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         0x887800D2  [fail]

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            0x88781193  [fail]

};


//
// IDirectSound
//


interface IDirectSound: IUnknown
{
    // IDirectSound methods
    DSRESULT  CreateSoundBuffer    ([in] LPCDSBUFFERDESC lpcDSBufferDesc, [out] LPLPDIRECTSOUNDBUFFER lplpDirectSoundBuffer, [in] IUnknown * pUnkOuter);
    DSRESULT  GetCaps              ([out] LPDSCAPS lpDSCaps) ;
    DSRESULT  DuplicateSoundBuffer ([in] LPDIRECTSOUNDBUFFER lpDsbOriginal, [out] LPLPDIRECTSOUNDBUFFER lplpDsbDuplicate) ;
    DSRESULT  SetCooperativeLevel  (HWND hwnd, DSSCL_VALUE dwLevel) ;
    DSRESULT  Compact              () ;
    DSRESULT  GetSpeakerConfig     ([out] DSSPEAKER_VALUE * lpdwSpeakerConfig) ;
    DSRESULT  SetSpeakerConfig     (DSSPEAKER_VALUE dwSpeakerConfig) ;
    DSRESULT  Initialize           ([in] LPCGUID lpcGuid) ;
};
interface IDirectSound8 : IDirectSound
{
    // IDirectSound8 methods
     DSRESULT VerifyCertification  (LPDWORD pdwCertified) ;
};

//
// IDirectSoundBuffer
//


interface IDirectSoundBuffer: IUnknown
{
    // IDirectSoundBuffer methods
    DSRESULT  GetCaps               ([out] LPDSCAPS lpDSCaps ) ;
    DSRESULT  GetCurrentPosition    ([out] LPDWORD lpdwCurrentPlayCursor, [out] LPDWORD lpdwCurrentWriteCursor );
    DSRESULT  GetFormat             ([out] LPWAVEFORMATEX lpwfxFormat, DWORD dwSizeAllocated,  [out] LPDWORD lpdwSizeWritten );
    DSRESULT  GetVolume             ([out] LPLONG lplVolume );
    DSRESULT  GetPan                ([out] LPLONG lplPan);
    DSRESULT  GetFrequency          ([out] LPDWORD lpdwFrequency );
    DSRESULT  GetStatus             ([out] LPDWORD lpdwStatus );
    DSRESULT  Initialize            ([in] LPDIRECTSOUND lpDirectSound, [in] LPCDSBUFFERDESC lpcDSBufferDesc );
    DSRESULT  Lock                  (DWORD dwWriteCursor,   DWORD dwWriteBytes,   [out]  LPVOID lplpvAudioPtr1, [out] LPDWORD lpdwAudioBytes1, [out] LPVOID lplpvAudioPtr2, [out] LPDWORD lpdwAudioBytes2, DSBLOCK_VALUE dwFlags);
    DSRESULT  Play                  (DWORD dwReserved1, DWORD dwPriority,  DSBPLAY_MASK dwFlags );
    DSRESULT  SetCurrentPosition    (DWORD dwNewPosition);
    DSRESULT  SetFormat             ([in] LPCWAVEFORMATEX lpcfxFormat );
    DSRESULT  SetVolume             (LONG lVolume );
    DSRESULT  SetPan                (LONG lPan );
    DSRESULT  SetFrequency          (DWORD dwFrequency );
    DSRESULT  Stop                  ( );
    DSRESULT  Unlock                ([in] LPVOID lpvAudioPtr1, DWORD dwAudioBytes1, [in] LPVOID lpvAudioPtr2, DWORD dwAudioBytes2 );
    DSRESULT  Restore               ( );
};

interface IDirectSoundBuffer8: IDirectSoundBuffer
{
    // IDirectSoundBuffer8 methods
    DSRESULT  SetFX                 (DWORD dwEffectsCount, [in] LPDSEFFECTDESC pDSFXDesc, [out] LPDWORD pdwResultCodes) ;
    DSRESULT  AcquireResources      (DWORD dwFlags, DWORD dwEffectsCount, [out] LPDWORD pdwResultCodes) ;
    DSRESULT  GetObjectInPath       (REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, [out] LPVOID *ppObject) ;
};


//
// IDirectSound3DListener
//


interface IDirectSound3DListener: IUnknown
{
    // IDirectSound3D methods
    DSRESULT  GetAllParameters          ([out] LPDS3DLISTENER lpListener );
    DSRESULT  GetDistanceFactor         ([out] LPD3DVALUE lpflDistanceFactor );
    DSRESULT  GetDopplerFactor          ([out] LPD3DVALUE lpflDopplerFactor );
    DSRESULT  GetOrientation            ([out] LPD3DVECTOR lpvOrientFront, [out] LPD3DVECTOR lpvOrientTop );
    DSRESULT  GetPosition               ([out] LPD3DVECTOR lpvPosition);
    DSRESULT  GetRolloffFactor          ([out] LPD3DVALUE lpflRolloffFactor );
    DSRESULT  GetVelocity               ([out] LPD3DVECTOR lpvVelocity);
    DSRESULT  SetAllParameters          ([in] LPCDS3DLISTENER lpcListener, DS3D_VALUE dwApply );
    DSRESULT  SetDistanceFactor         (D3DVALUE flDistanceFactor, DS3D_VALUE dwApply );
    DSRESULT  SetDopplerFactor          (D3DVALUE flDopplerFactor, DS3D_VALUE dwApply );
    DSRESULT  SetOrientation            (D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront, D3DVALUE xTop,   D3DVALUE yTop,   D3DVALUE zTop,   DS3D_VALUE dwApply);
    DSRESULT  SetPosition               (D3DVALUE x,   D3DVALUE y,   D3DVALUE z,   DS3D_VALUE dwApply );
    DSRESULT  SetRolloffFactor          (D3DVALUE flRolloffFactor, DS3D_VALUE dwApply);
    DSRESULT  SetVelocity               (D3DVALUE x,   D3DVALUE y,   D3DVALUE z,   DS3D_VALUE dwApply );
    DSRESULT  CommitDeferredSettings    ( );
};

//
// IDirectSound3DBuffer
//


interface IDirectSound3DBuffer: IUnknown
{
    // IDirectSoundBuffer3D methods
    DSRESULT  GetAllParameters      ([out] LPDS3DBUFFER lpDs3dBuffer );
    DSRESULT  GetConeAngles         ([out] LPDWORD lpdwInsideConeAngle, [out] LPDWORD lpdwOutsideConeAngle );
    DSRESULT  GetConeOrientation    ([out] LPD3DVECTOR lpvOrientation );
    DSRESULT  GetConeOutsideVolume  ([out] LPLONG lplConeOutsideVolume );
    DSRESULT  GetMaxDistance        ([out] LPD3DVALUE lpflMaxDistance );
    DSRESULT  GetMinDistance        ([out] LPD3DVALUE lpflMinDistance );
    DSRESULT  GetMode               ([out] LPDWORD lpdwMode );
    DSRESULT  GetPosition           ([out] LPD3DVECTOR lpvPosition );
    DSRESULT  GetVelocity           ([out] LPD3DVECTOR lpvVelocity );
    DSRESULT  SetAllParameters      ([in] LPCDS3DBUFFER lpcDs3dBuffer, DS3D_VALUE dwApply );
    DSRESULT  SetConeAngles         (DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DS3D_VALUE dwApply );
    DSRESULT  SetConeOrientation    (D3DVALUE x,   D3DVALUE y,   D3DVALUE z,   DS3D_VALUE dwApply );
    DSRESULT  SetConeOutsideVolume  (LONG lConeOutsideVolume, DS3D_VALUE dwApply );
    DSRESULT  SetMaxDistance        (D3DVALUE flMaxDistance, DS3D_VALUE dwApply );
    DSRESULT  SetMinDistance        (D3DVALUE flMinDistance, DS3D_VALUE dwApply );
    DSRESULT  SetMode               (DS3DMODE_VALUE dwMode, DS3D_VALUE dwApply );
    DSRESULT  SetPosition           (D3DVALUE x,   D3DVALUE y,   D3DVALUE z,   DS3D_VALUE dwApply );
    DSRESULT  SetVelocity           (D3DVALUE x,   D3DVALUE y,   D3DVALUE z,   DS3D_VALUE dwApply );
};


//
// IDirectSoundCapture
//


interface IDirectSoundCapture: IUnknown
{
    // IDirectSoundCapture methods
    DSRESULT  CreateCaptureBuffer   ([in] LPDSCBUFFERDESC lpDSCBufferDesc, [out] LPLPDIRECTSOUNDCAPTUREBUFFER lplpDirectSoundCaptureBuffer, [in] LPUNKNOWN pUnkOuter );
    DSRESULT  GetCaps               ([out] LPDSCAPS lpDSCaps ) ;
    DSRESULT  Initialize            ([in] LPCGUID lpcGuid );
};

interface IDirectSoundCaptureBuffer8 : IDirectSoundCapture
{
    // IDirectSoundCaptureBuffer8 methods
    DSRESULT GetObjectInPath       (REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, [out] LPVOID *ppObject) ;
    DSRESULT GetFXStatus           (DWORD dwFXCount, [out] LPDWORD pdwFXStatus) ;
};

//
// IDirectSoundCaptureBuffer
//


interface IDirectSoundCaptureBuffer: IUnknown
{
    // IDirectSoundCaptureBuffer methods
    DSRESULT  GetCaps               ([out] LPDSCAPS lpDSCaps ) ;
    DSRESULT  GetCurrentPosition    ([out] LPDWORD lpdwCapturePosition, [out] LPDWORD lpdwReadPosition );
    DSRESULT  GetFormat             ([out] LPWAVEFORMATEX lpwfxFormat, DWORD dwSizeAllocated,  [out] LPDWORD lpdwSizeWritten );
    DSRESULT  GetStatus             ([out] DWORD *lpdwStatus );
    DSRESULT  Initialize            (LPDIRECTSOUNDCAPTURE lpDirectSoundCapture, [in] LPCDSCBUFFERDESC lpcDSCBufferDesc );
    DSRESULT  Lock                  (DWORD dwReadCursor,     DWORD dwReadBytes,  [out] LPVOID *lplpvAudioPtr1, [out] LPDWORD lpdwAudioBytes1, [out] LPVOID *lplpvAudioPtr2, [out] LPDWORD lpdwAudioBytes2, DSCBLOCK_MASK dwFlags);
    DSRESULT  Start                 (DSCBSTART_MASK dwFlags );
    DSRESULT  Stop                  ( );
    DSRESULT  Unlock                ([in] LPVOID lpvAudioPtr1,DWORD dwAudioBytes1, [in] LPVOID lpvAudioPtr2,DWORD dwAudioBytes2 );
};


//
// IDirectSoundNotify
//


interface IDirectSoundNotify: IUnknown
{
    // IDirectSoundNotify methods
    DSRESULT  SetNotificationPositions  ( );
};

typedef struct _DSFXSend
{
    LONG lSendLevel;
} DSFXSend;
typedef DSFXSend *LPDSFXSend;
typedef DSFXSend *LPCDSFXSend;


interface IDirectSoundFXSend: IUnknown
{
    // IDirectSoundFXSend methods
    DSRESULT SetAllParameters      ([in] LPCDSFXSend pcDsFxSend) ;
    DSRESULT GetAllParameters      ([out] LPDSFXSend pDsFxSend) ;
};


typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle;
typedef DSFXGargle *LPDSFXGargle;
typedef DSFXGargle *LPCDSFXGargle;

value DWORD DSFXGARGLE_VALUE
{
#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1
};



interface IDirectSoundFXGargle: IUnknown
{
    // IDirectSoundFXGargle methods
    DSRESULT SetAllParameters      ([in] LPCDSFXGargle pcDsFxGargle) ;
    DSRESULT GetAllParameters      ([out] LPDSFXGargle pDsFxGargle) ;
};

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus;
typedef DSFXChorus *LPDSFXChorus;
typedef DSFXChorus *LPCDSFXChorus;

interface IDirectSoundFXChorus: IUnknown
{
    // IDirectSoundFXChorus methods
    DSRESULT SetAllParameters      ([in] LPCDSFXChorus pcDsFxChorus) ;
    DSRESULT GetAllParameters      ([out] LPDSFXChorus pDsFxChorus) ;
};


typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger;
typedef DSFXFlanger *LPDSFXFlanger;
typedef DSFXFlanger *LPCDSFXFlanger;

interface IDirectSoundFXFlanger: IUnknown
{
    // IDirectSoundFXFlanger methods
    DSRESULT  SetAllParameters      ([in] LPCDSFXFlanger pcDsFxFlanger) ;
    DSRESULT  GetAllParameters      ([out] LPDSFXFlanger pDsFxFlanger) ;
};

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho;
typedef DSFXEcho *LPDSFXEcho;
typedef DSFXEcho *LPCDSFXEcho;

interface IDirectSoundFXEcho: IUnknown
{
    // IDirectSoundFXEcho methods
    DSRESULT SetAllParameters      ([in] LPCDSFXEcho pcDsFxEcho) ;
    DSRESULT GetAllParameters      ([out] LPDSFXEcho pDsFxEcho) ;
};
typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion;
typedef DSFXDistortion *LPDSFXDistortion;
typedef DSFXDistortion *LPCDSFXDistortion;

interface IDirectSoundFXDistortion: IUnknown
{
    // IDirectSoundFXDistortion methods
    DSRESULT SetAllParameters      ([in] LPCDSFXDistortion pcDsFxDistortion) ;
    DSRESULT GetAllParameters      ([out] LPDSFXDistortion pDsFxDistortion) ;
};

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor;
typedef DSFXCompressor  *LPDSFXCompressor;
typedef DSFXCompressor *LPCDSFXCompressor;

interface IDirectSoundFXCompressor: IUnknown
{
    // IDirectSoundFXCompressor methods
    DSRESULT SetAllParameters      ([in] LPCDSFXCompressor pcDsFxCompressor) ;
    DSRESULT GetAllParameters      ([out] LPDSFXCompressor pDsFxCompressor) ;
};


typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq;
typedef DSFXParamEq *LPDSFXParamEq;
typedef DSFXParamEq *LPCDSFXParamEq;

interface IDirectSoundFXParamEq: IUnknown
{
    // IDirectSoundFXParamEq methods
    DSRESULT SetAllParameters      ([in] LPCDSFXParamEq pcDsFxParamEq) ;
    DSRESULT GetAllParameters      ([out] LPDSFXParamEq pDsFxParamEq) ;
};


typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb;
typedef DSFXI3DL2Reverb *LPDSFXI3DL2Reverb;
typedef DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;


interface IDirectSoundFXI3DL2Reverb: IUnknown
{
    // IDirectSoundFXI3DL2Reverb methods
    DSRESULT SetAllParameters      ([in] LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) ;
    DSRESULT GetAllParameters      ([out] LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) ;
    DSRESULT SetPreset             (DWORD dwPreset) ;
    DSRESULT GetPreset             ([out] LPDWORD pdwPreset) ;
    DSRESULT SetQuality            (LONG lQuality) ;
    DSRESULT GetQuality            ([out] LONG *plQuality) ;
};

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb;
typedef DSFXWavesReverb *LPDSFXWavesReverb;
typedef DSFXWavesReverb *LPCDSFXWavesReverb;

interface IDirectSoundFXWavesReverb: IUnknown
{
    // IDirectSoundFXWavesReverb methods
    DSRESULT SetAllParameters      ([in] LPCDSFXWavesReverb pcDsFxWavesReverb) ;
    DSRESULT GetAllParameters      ([out] LPDSFXWavesReverb pDsFxWavesReverb) ;
};

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAec;
typedef DSCFXAec *LPDSCFXAec;
typedef DSCFXAec *LPCDSCFXAec;

interface IDirectSoundCaptureFXAec: IUnknown
{
    // IDirectSoundCaptureFXAec methods
    DSRESULT SetAllParameters      ([in] LPCDSCFXAec pDscFxAec) ;
    DSRESULT GetAllParameters      ([out] LPDSCFXAec pDscFxAec) ;
};

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXNoiseSuppress;
typedef DSCFXNoiseSuppress *LPDSCFXNoiseSuppress;
typedef DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

interface IDirectSoundCaptureFXNoiseSuppress: IUnknown
{
    // IDirectSoundCaptureFXNoiseSuppress methods
    DSRESULT SetAllParameters      ([in] LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) ;
    DSRESULT GetAllParameters      ([out] LPDSCFXNoiseSuppress pDscFxNoiseSuppress) ;
};


interface IDirectSoundFullDuplex: IUnknown
{
    // IDirectSoundFullDuplex methods 
    DSRESULT Initialize      ([in] LPCGUID pCaptureGuid, [in] LPCGUID pRenderGuid, [in] LPCDSCBUFFERDESC lpDscBufferDesc, [in] LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, [out] LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, [out] LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) ;
};





//
// IKsPropertySet
//


mask DWORD KSPROPERTY_SUPPORT_MASK
{
#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002
};

interface IKsPropertySet: IUnknown
{
    // IKsPropertySet methods
    DSRESULT  Get               (REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength, [out] LPVOID pPropertyData, ULONG ulDataLength, [out] ULONG * pulBytesReturned );
    DSRESULT  Set               (REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength, LPVOID pPropertyData, ULONG ulDataLength );
    DSRESULT  QuerySupport      (REFGUID rguidPropSet, ULONG ulId, ULONG* pulTypeSupport );
};

typedef IKsPropertySet *LPKSPROPERTYSET;

//
// DirectSound API
//

typedef LPVOID LPDSENUMCALLBACKW;
typedef LPVOID LPDSENUMCALLBACKA;

DSRESULT DirectSoundCreate( [in] LPCGUID lpcGuid, [out] LPDIRECTSOUND * ppDS, [in] LPUNKNOWN pUnkOuter );
DSRESULT DirectSoundEnumerateA( LPDSENUMCALLBACKA lpDSEnumCallback, LPVOID lpContext );
DSRESULT DirectSoundEnumerateW( LPDSENUMCALLBACKW lpDSEnumCallback, LPVOID lpContext );
DSRESULT DirectSoundCaptureCreate( [in] LPCGUID lpcGUID, [out] LPDIRECTSOUNDCAPTURE *lplpDSC, [in] LPUNKNOWN pUnkOuter );
DSRESULT DirectSoundCaptureEnumerateA( [in] LPDSENUMCALLBACKA lpDSEnumCallback, [in] LPVOID lpContext );
DSRESULT DirectSoundCaptureEnumerateW( [in] LPDSENUMCALLBACKW lpDSEnumCallback, [in] LPVOID lpContext );

DSRESULT DirectSoundCreate8([in] LPCGUID pcGuidDevice, [out] LPDIRECTSOUND8 *ppDS8, [in] LPUNKNOWN pUnkOuter);
DSRESULT DirectSoundCaptureCreate8([in] LPCGUID pcGuidDevice, [out] LPDIRECTSOUNDCAPTURE *ppDSC8, [in] LPUNKNOWN pUnkOuter);
DSRESULT DirectSoundFullDuplexCreate([in] LPCGUID pcGuidCaptureDevice, [in] LPCGUID pcGuidRenderDevice, [in] LPCDSCBUFFERDESC pcDSCBufferDesc, [in] LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd, DWORD dwLevel, [out] LPDIRECTSOUNDFULLDUPLEX* ppDSFD, [out] LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8, [out] LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, [in] LPUNKNOWN pUnkOuter); 
DSRESULT GetDeviceID([in] LPCGUID pGuidSrc, [out] LPGUID pGuidDest);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\dplay.h ===
module DPLAYX.DLL:
category DirectPlay:

/*
 * GUIDS used by DirectPlay objects
 */
 class __declspec(uuid("D1EB6D20-8923-11d0-9D97-00A0C90A43CB"))  DirectPlay;
 class __declspec(uuid("2b74f7c0-9154-11cf-a9cd-00aa006886e3"))  IDirectPlay2;
 class __declspec(uuid("9d460580-a822-11cf-960c-0080c7534e82"))  IDirectPlay2A;
 class __declspec(uuid("133efe40-32dc-11d0-9cfb-00a0c90a43cb"))  IDirectPlay3;
 class __declspec(uuid("133efe41-32dc-11d0-9cfb-00a0c90a43cb"))  IDirectPlay3A;
 class __declspec(uuid("0ab1c530-4745-11d1-a7a1-0000f803abfc"))  IDirectPlay4;
 class __declspec(uuid("0ab1c531-4745-11d1-a7a1-0000f803abfc"))  IDirectPlay4A;

struct __declspec(uuid("685BC400-9D2C-11cf-A9CD-00AA006886E3")) DPSPGUID_IPX;
struct __declspec(uuid("36E95EE0-8577-11cf-960C-0080C7534E82")) DPSPGUID_TCPIP;
struct __declspec(uuid("0F1D6860-88D9-11cf-9C4E-00A0C905425E")) DPSPGUID_SERIAL;
struct __declspec(uuid("44EAA760-CB68-11cf-9C4E-00A0C905425E")) DPSPGUID_MODEM;

typedef IUnknown           *LPDIRECTPLAY;
typedef IDirectPlay2       *LPDIRECTPLAY2;
typedef IDirectPlay2       *LPDIRECTPLAY2A;
typedef IDirectPlay2       IDirectPlay2A;

typedef IDirectPlay3       *LPDIRECTPLAY3;
typedef IDirectPlay3       *LPDIRECTPLAY3A;
typedef IDirectPlay3       IDirectPlay3A;

typedef IDirectPlay4       *LPDIRECTPLAY4;
typedef IDirectPlay4       *LPDIRECTPLAY4A;
typedef IDirectPlay4       IDirectPlay4A;

/*
 * DPID
 * DirectPlay player and group ID
 */
typedef DWORD DPID;
typedef DWORD *LPDPID;

/*
#define DPID_SYSMSG         0
#define DPID_ALLPLAYERS     0
#define DPID_SERVERPLAYER	1
#define DPID_UNKNOWN		0xFFFFFFFF
*/

mask DWORD DPlayObjectFlags
{
/*
 * This DirectPlay object is the session host.  If the host exits the
 * session, another application will become the host and receive a
 * DPSYS_HOST system message.
 */
#define DPCAPS_ISHOST               0x00000002

/*
 * The service provider bound to this DirectPlay object can optimize
 * group messaging.
 */
#define DPCAPS_GROUPOPTIMIZED       0x00000008

/*
 * The service provider bound to this DirectPlay object can optimize
 * keep alives (see DPSESSION_KEEPALIVE)
 */
#define DPCAPS_KEEPALIVEOPTIMIZED   0x00000010

/*
 * The service provider bound to this DirectPlay object can optimize
 * guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDOPTIMIZED  0x00000020

/*
 * This DirectPlay object supports guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDSUPPORTED  0x00000040

/*
 * This DirectPlay object supports digital signing of messages.
 */
#define DPCAPS_SIGNINGSUPPORTED     0x00000080

/*
 * This DirectPlay object supports encryption of messages.
 */
#define DPCAPS_ENCRYPTIONSUPPORTED  0x00000100

};


/*
 * DPCAPS
 * Used to obtain the capabilities of a DirectPlay object
 */
typedef struct _DPCAPS
{
    DWORD dwSize;               // Size of structure, in bytes
    DPlayObjectFlags dwFlags;              // DPCAPS_xxx flags
    DWORD dwMaxBufferSize;      // Maximum message size, in bytes,  for this service provider
    DWORD dwMaxQueueSize;       // Obsolete. 
    DWORD dwMaxPlayers;         // Maximum players/groups (local + remote)
    DWORD dwHundredBaud;        // Bandwidth in 100 bits per second units; 
                                // i.e. 24 is 2400, 96 is 9600, etc.
    DWORD dwLatency;            // Estimated latency; 0 = unknown
    DWORD dwMaxLocalPlayers;    // Maximum # of locally created players allowed
    DWORD dwHeaderLength;       // Maximum header length, in bytes, on messages
                                // added by the service provider
    DWORD dwTimeout;            // Service provider's suggested timeout value
                                // This is how long DirectPlay will wait for 
                                // responses to system messages
} DPCAPS;
typedef DPCAPS *LPDPCAPS;

/*
 * LPCDPSESSIONDESC2
 * A constant pointer to DPSESSIONDESC2
 */
typedef DPSESSIONDESC2 *LPCDPSESSIONDESC2;
 
mask DWORD DPSESSION_Flags
{
/*
 * Applications cannot create new players in this session.
 */
#define DPSESSION_NEWPLAYERSDISABLED    0x00000001 

/*
 * If the DirectPlay object that created the session, the host,
 * quits, then the host will attempt to migrate to another
 * DirectPlay object so that new players can continue to be created
 * and new applications can join the session.
 */
#define DPSESSION_MIGRATEHOST           0x00000004

/*
 * This flag tells DirectPlay not to set the idPlayerTo and idPlayerFrom 
 * fields in player messages.  This cuts two DWORD's off the message 
 * overhead.
 */
#define DPSESSION_NOMESSAGEID           0x00000008


/*
 * This flag tells DirectPlay to not allow any new applications to
 * join the session.  Applications already in the session can still
 * create new players.
 */
#define DPSESSION_JOINDISABLED          0x00000020

/*
 * This flag tells DirectPlay to detect when remote players 
 * exit abnormally (e.g. their computer or modem gets unplugged)
 */
#define DPSESSION_KEEPALIVE             0x00000040

/*
 * This flag tells DirectPlay not to send a message to all players
 * when a players remote data changes
 */
#define DPSESSION_NODATAMESSAGES        0x00000080

/*
 * This flag indicates that the session belongs to a secure server
 * and needs user authentication
 */
#define DPSESSION_SECURESERVER          0x00000100

/*
 * This flag indicates that the session is private and requirs a password
 * for EnumSessions as well as Open.
 */
#define DPSESSION_PRIVATE               0x00000200

/*
 * This flag indicates that the session requires a password for joining.
 */
#define DPSESSION_PASSWORDREQUIRED      0x00000400

/*
 * This flag tells DirectPlay to route all messages through the server
 */
#define DPSESSION_MULTICASTSERVER		0x00000800

/*
 * This flag tells DirectPlay to only download information about the
 * DPPLAYER_SERVERPLAYER.  
 */
#define DPSESSION_CLIENTSERVER			0x00001000

/*
 * This flag tells DirectPlay to use the protocol built into dplay
 * for reliability and statistics all the time.  When this bit is
 * set, only other sessions with this bit set can join or be joined.
 */
#define DPSESSION_DIRECTPLAYPROTOCOL	0x00002000

/*
 * This flag tells DirectPlay that preserving order of received
 * packets is not important, when using reliable delivery.  This
 * will allow messages to be indicated out of order if preceding
 * messages have not yet arrived.  Otherwise DPLAY will wait for
 * earlier messages before delivering later reliable messages.
 */
#define DPSESSION_NOPRESERVEORDER		0x00004000

};


/*
 * DPSESSIONDESC2
 * Used to describe the properties of a DirectPlay
 * session instance
 */
typedef struct _DPSESSIONDESC2
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // DPSESSION_xxx flags
    GUID    guidInstance;       // ID for the session instance
    GUID    guidApplication;    // GUID of the DirectPlay application.
                                // GUID_NULL for all applications.
    DWORD   dwMaxPlayers;       // Maximum # players allowed in session
    DWORD   dwCurrentPlayers;   // Current # players in session (read only)
//    union
//    {                           // Name of the session
//        LPWSTR  lpszSessionName;    // Unicode
        LPSTR   lpszSessionNameA;   // ANSI
//    };
//    union
//    {                           // Password of the session (optional)
//        LPWSTR  lpszPassword;       // Unicode
        LPSTR   lpszPasswordA;      // ANSI
//    };
    DWORD   dwReserved1;        // Reserved for future MS use.
    DWORD   dwReserved2;
    DWORD   dwUser1;            // For use by the application
    DWORD   dwUser2;
    DWORD   dwUser3;
    DWORD   dwUser4;
} DPSESSIONDESC2;
typedef DPSESSIONDESC2 *LPDPSESSIONDESC2;

/*
 * DPNAME
 * Used to hold the name of a DirectPlay entity
 * like a player or a group
 */
typedef struct _DPNAME
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // Not used. Must be zero.
//    union
//    {                           // The short or friendly name
//        LPWSTR  lpszShortName;  // Unicode
        LPSTR   lpszShortNameA; // ANSI
//    };
//    union
//    {                           // The long or formal name
//        LPWSTR  lpszLongName;   // Unicode
        LPSTR   lpszLongNameA;  // ANSI
//    };

} DPNAME;
typedef DPNAME *LPDPNAME;

/*
 * LPCDPNAME
 * A constant pointer to DPNAME
 */
typedef DPNAME *LPCDPNAME;

/*
 * DPCREDENTIALS
 * Used to hold the user name and password of a DirectPlay user
 */
typedef struct _DPCREDENTIALS
{
    DWORD dwSize;               // Size of structure
    DWORD dwFlags;              // Not used. Must be zero.
//    union
//    {                           // User name of the account
//        LPWSTR  lpszUsername;   // Unicode
        LPSTR   lpszUsernameA;  // ANSI
//    };    
//    union
//    {                           // Password of the account
//        LPWSTR  lpszPassword;   // Unicode
        LPSTR   lpszPasswordA;  // ANSI
//    };    
//    union
//    {                           // Domain name of the account
//        LPWSTR  lpszDomain;     // Unicode
        LPSTR   lpszDomainA;    // ANSI
//    };    
} DPCREDENTIALS;
typedef DPCREDENTIALS *LPDPCREDENTIALS;

typedef DPCREDENTIALS *LPCDPCREDENTIALS;

/*
 * DPSECURITYDESC
 * Used to describe the security properties of a DirectPlay
 * session instance
 */
typedef struct _DPSECURITYDESC
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
//    union
//    {                               // SSPI provider name
//        LPWSTR  lpszSSPIProvider;   // Unicode
        LPSTR   lpszSSPIProviderA;  // ANSI
//    };
//    union
//    {                               // CAPI provider name
//        LPWSTR lpszCAPIProvider;    // Unicode
        LPSTR  lpszCAPIProviderA;   // ANSI
//    };
    DWORD dwCAPIProviderType;       // Crypto Service Provider type
    DWORD dwEncryptionAlgorithm;    // Encryption Algorithm type
} DPSECURITYDESC;
typedef DPSECURITYDESC *LPDPSECURITYDESC;

typedef DPSECURITYDESC *LPCDPSECURITYDESC;

/*
 * DPACCOUNTDESC
 * Used to describe a user membership account
 */
typedef struct _DPACCOUNTDESC
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
//    union
//    {                               // Account identifier
//        LPWSTR  lpszAccountID;      // Unicode
        LPSTR   lpszAccountIDA;     // ANSI
//    };
} DPACCOUNTDESC;
typedef DPACCOUNTDESC *LPDPACCOUNTDESC;

typedef DPACCOUNTDESC *LPCDPACCOUNTDESC;

/*
 * LPCGUID
 * A constant pointer to a guid
 */
typedef GUID *LPCGUID;

/****************************************************************************
 *
 * DPLCONNECTION flags
 *
 ****************************************************************************/
mask DWORD DPLCONNECTIONFlags
{

/*
 * This application should create a new session as
 * described by the DPSESIONDESC structure
 */
#define DPLCONNECTION_CREATESESSION				 0x00000002

/*
 * This application should join the session described by 
 * the DPSESIONDESC structure with the lpAddress data
 */
#define DPLCONNECTION_JOINSESSION				0x00000001

};

/*
 * DPLCONNECTION
 * Used to hold all in the informaion needed to connect
 * an application to a session or create a session
 */
typedef struct _DPLCONNECTION
{
    DWORD               dwSize;             // Size of this structure
    DPLCONNECTIONFlags  dwFlags;            // Flags specific to this structure
    LPDPSESSIONDESC2    lpSessionDesc;      // Pointer to session desc to use on connect
    LPDPNAME            lpPlayerName;       // Pointer to Player name structure
    GUID                guidSP;             // GUID of the DPlay SP to use
    LPVOID              lpAddress;          // Address for service provider
    DWORD               dwAddressSize;      // Size of address data
} DPLCONNECTION;
typedef DPLCONNECTION *LPDPLCONNECTION;

/*
 * LPCDPLCONNECTION
 * A constant pointer to DPLCONNECTION
 */
typedef DPLCONNECTION *LPCDPLCONNECTION;

/*
 * DPCHAT
 * Used to hold the a DirectPlay chat message
 */
typedef struct _DPCHAT
{
    DWORD               dwSize;
    DWORD               dwFlags;
//    union
//    {                          // Message string
//        LPWSTR  lpszMessage;   // Unicode
        LPSTR   lpszMessageA;  // ANSI
//    };    
} DPCHAT;
typedef DPCHAT * LPDPCHAT;

/*
 * SGBUFFER
 * Scatter Gather Buffer used for SendEx
 */
typedef struct _SGBUFFER
{
	UINT         len;       // length of buffer data
	//PUCHAR	     pData;		// pointer to buffer data
	CHAR *	     pData;		// pointer to buffer data
} SGBUFFER;
typedef SGBUFFER *PSGBUFFER;
typedef SGBUFFER *LPSGBUFFER;


value DWORD DPRESULT
{

/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           0
#define DPERR_ALREADYINITIALIZED        0x88770005L		[fail]
#define DPERR_ACCESSDENIED              0x8877000AL		[fail]
#define DPERR_ACTIVEPLAYERS             0x88770014L		[fail]
#define DPERR_BUFFERTOOSMALL            0x8877001EL		[fail]
#define DPERR_CANTADDPLAYER             0x88770028L		[fail]
#define DPERR_CANTCREATEGROUP           0x88770032L		[fail]
#define DPERR_CANTCREATEPLAYER          0x8877003CL		[fail]
#define DPERR_CANTCREATESESSION         0x88770046L		[fail]
#define DPERR_CAPSNOTAVAILABLEYET       0x88770050L		[fail]
#define DPERR_EXCEPTION                 0x8877005AL		[fail]
#define DPERR_GENERIC                   0x80004005L		[fail]
#define DPERR_INVALIDFLAGS              0x88770078L		[fail]
#define DPERR_INVALIDOBJECT             0x88770082L		[fail]
#define DPERR_INVALIDPARAM              0x80070057L		[fail]
#define DPERR_INVALIDPARAMS             0x80070057L		[fail]
#define DPERR_INVALIDPLAYER             0x88770096L		[fail]
#define DPERR_INVALIDGROUP             	0x8877009BL		[fail]
#define DPERR_NOCAPS                    0x887700A0L		[fail]
#define DPERR_NOCONNECTION              0x887700AAL		[fail]
#define DPERR_NOMEMORY                  0x8007000EL		[fail]
#define DPERR_OUTOFMEMORY               0x8007000EL		[fail]
#define DPERR_NOMESSAGES                0x887700BEL		[fail]
#define DPERR_NONAMESERVERFOUND         0x887700C8L		[fail]
#define DPERR_NOPLAYERS                 0x887700D2L		[fail]
#define DPERR_NOSESSIONS                0x887700DCL		[fail]
#define DPERR_PENDING			0x8000000AL		[fail]
#define DPERR_SENDTOOBIG		0x887700E6L		[fail]
#define DPERR_TIMEOUT                   0x887700F0L		[fail]
#define DPERR_UNAVAILABLE               0x887700FAL		[fail]
#define DPERR_UNSUPPORTED               0x80004001L		[fail]
#define DPERR_BUSY                      0x8877010EL		[fail]
#define DPERR_USERCANCEL                0x88770118L		[fail]
#define DPERR_NOINTERFACE               0x80004002L		[fail]
#define DPERR_CANNOTCREATESERVER        0x88770122L		[fail]
#define DPERR_PLAYERLOST                0x8877012CL		[fail]
#define DPERR_SESSIONLOST               0x88770136L		[fail]
#define DPERR_UNINITIALIZED             0x88770140L		[fail]
#define DPERR_NONEWPLAYERS              0x8877013AL		[fail]
#define DPERR_INVALIDPASSWORD           0x88770154L		[fail]
#define DPERR_CONNECTING                0x8877015EL		[fail]
#define DPERR_CONNECTIONLOST            0x88770168L		[fail]
#define DPERR_UNKNOWNMESSAGE            0x88770172L		[fail]
#define DPERR_CANCELFAILED              0x8877017CL		[fail]
#define DPERR_INVALIDPRIORITY           0x88770186L		[fail]
#define DPERR_NOTHANDLED                0x88770190L		[fail]
#define DPERR_CANCELLED                 0x8877019AL		[fail]
#define DPERR_ABORTED                   0x887701A4L		[fail]


#define DPERR_BUFFERTOOLARGE            0x887703E8L		[fail]
#define DPERR_CANTCREATEPROCESS         0x887703F2L		[fail]
#define DPERR_APPNOTSTARTED             0x887703FCL		[fail]
#define DPERR_INVALIDINTERFACE          0x88770406L		[fail]
#define DPERR_NOSERVICEPROVIDER         0x88770410L		[fail]
#define DPERR_UNKNOWNAPPLICATION        0x8877041AL		[fail]
#define DPERR_NOTLOBBIED                0x8877042EL		[fail]
#define DPERR_SERVICEPROVIDERLOADED	0x88770438L		[fail]
#define DPERR_ALREADYREGISTERED		0x88770442L		[fail]
#define DPERR_NOTREGISTERED		0x8877044CL		[fail]

//
// Security related errors
//
#define DPERR_AUTHENTICATIONFAILED      0x887707D0L		[fail]
#define DPERR_CANTLOADSSPI              0x887707DAL		[fail]
#define DPERR_ENCRYPTIONFAILED          0x887707E4L		[fail]
#define DPERR_SIGNFAILED                0x887707EEL		[fail]
#define DPERR_CANTLOADSECURITYPACKAGE   0x887707F8L		[fail]
#define DPERR_ENCRYPTIONNOTSUPPORTED    0x88770802L		[fail]
#define DPERR_CANTLOADCAPI              0x8877080CL		[fail]
#define DPERR_NOTLOGGEDIN               0x88770816L		[fail]
#define DPERR_LOGONDENIED               0x88770820L		[fail]

};

/****************************************************************************
 *
 * Prototypes for DirectPlay callback functions
 *
 ****************************************************************************/

typedef LPVOID LPDPENUMSESSIONSCALLBACK2;
typedef LPVOID LPDPENUMPLAYERSCALLBACK2;
typedef LPVOID LPDPENUMDPCALLBACK;
typedef LPVOID LPDPENUMDPCALLBACKA;
typedef LPVOID LPDPENUMCONNECTIONSCALLBACK;


/****************************************************************************
 *
 * EnumConnections API flags
 *
 ****************************************************************************/
mask DWORD EnumConnectionsFlags
{
/*
 * Enumerate Service Providers
 */
#define DPCONNECTION_DIRECTPLAY      0x00000001

/*
 * Enumerate Lobby Providers
 */
#define DPCONNECTION_DIRECTPLAYLOBBY 0x00000002

};

/****************************************************************************
 *
 * EnumPlayers API flags
 *
 ****************************************************************************/
mask DWORD EnumPlayersMask
{
/*
 * Enumerate all players in the current session
 */
#define DPENUMPLAYERS_ALL           0x00000000
//#define DPENUMGROUPS_ALL            DPENUMPLAYERS_ALL


/*
 * Enumerate only local (created by this application) players
 * or groups
 */
#define DPENUMPLAYERS_LOCAL         0x00000008
//#define DPENUMGROUPS_LOCAL			DPENUMPLAYERS_LOCAL

/*
 * Enumerate only remote (non-local) players
 * or groups
 */
#define DPENUMPLAYERS_REMOTE        0x00000010
//#define DPENUMGROUPS_REMOTE			DPENUMPLAYERS_REMOTE

/*
 * Enumerate groups along with the players
 */
#define DPENUMPLAYERS_GROUP         0x00000020

/*
 * Enumerate players or groups in another session 
 * (must supply lpguidInstance)
 */
#define DPENUMPLAYERS_SESSION       0x00000080
//#define DPENUMGROUPS_SESSION		DPENUMPLAYERS_SESSION

/*
 * Enumerate server players
 */
#define DPENUMPLAYERS_SERVERPLAYER  0x00000100

/*
 * Enumerate spectator players
 */
#define DPENUMPLAYERS_SPECTATOR     0x00000200

/*
 * Enumerate shortcut groups
 */
#define DPENUMGROUPS_SHORTCUT       0x00000400

/*
 * Enumerate staging area groups
 */
#define DPENUMGROUPS_STAGINGAREA    0x00000800
/*
 * Enumerate hidden groups
 */
#define DPENUMGROUPS_HIDDEN         0x00001000

/*
 * Enumerate the group's owner
 */
#define DPENUMPLAYERS_OWNER			0x00002000

};

/****************************************************************************
 *
 * CreatePlayer API flags
 *
 ****************************************************************************/

mask DWORD CreatePlayerFlags
{
/*
 * This flag indicates that this player should be designated
 * the server player. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SERVERPLAYER           0x00000100

/*
 * This flag indicates that this player should be designated
 * a spectator. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SPECTATOR              0x00000200

/*
 * This flag indicates that this player was created locally.
 * (returned from GetPlayerFlags)
 */
#define DPPLAYER_LOCAL                  0x00000008

/*
 * This flag indicates that this player is the group's owner
 * (Only returned in EnumGroupPlayers)
 */
#define DPPLAYER_OWNER                   0x00002000

};

/****************************************************************************
 *
 * CreateGroup API flags
 *
 ****************************************************************************/


mask DWORD CreateGroupFlags
{
/*
 * This flag indicates that the StartSession can be called on the group.
 * The app should specify this at CreateGroup, or CreateGroupInGroup.
 */
#define DPGROUP_STAGINGAREA             0x00000800

/*
 * This flag indicates that this group was created locally.
 * (returned from GetGroupFlags)
 */
#define DPGROUP_LOCAL                   0x00000008

/*
 * This flag indicates that this group was created hidden.
 */
#define DPGROUP_HIDDEN                   0x00001000
};

/****************************************************************************
 *
 * EnumSessions API flags
 *
 ****************************************************************************/

mask DWORD EnumSessionsFlags
{
/*
 * Enumerate sessions which can be joined
 */
#define DPENUMSESSIONS_AVAILABLE    0x00000001 

/*
 * Enumerate all sessions even if they can't be joined.
 */
#define DPENUMSESSIONS_ALL          0x00000002


/*
 * Start an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_ASYNC		0x00000010

/*
 * Stop an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_STOPASYNC	0x00000020
 
/*
 * Enumerate sessions even if they require a password
 */
 #define DPENUMSESSIONS_PASSWORDREQUIRED	0x00000040

/*
 * Return status about progress of enumeration instead of
 * showing any status dialogs.
 */
 #define DPENUMSESSIONS_RETURNSTATUS 0x00000080
};

/****************************************************************************
 *
 * GetCaps and GetPlayerCaps API flags
 *
 ****************************************************************************/
mask DWORD GetCapsFlags
{
/*
 * The latency returned should be for guaranteed message sending.
 * Default is non-guaranteed messaging.
 */
#define DPGETCAPS_GUARANTEED        0x00000001 

};
 
/****************************************************************************
 *
 * GetGroupData, GetPlayerData API flags
 * Remote and local Group/Player data is maintained separately. 
 * Default is DPGET_REMOTE.
 *
 ****************************************************************************/

mask DWORD GetDataFlags
{
/*
 * Get the remote data (set by any DirectPlay object in
 * the session using DPSET_REMOTE)
 */
#define DPGET_REMOTE                0x00000000
	
/*
 * Get the local data (set by this DirectPlay object 
 * using DPSET_LOCAL)
 */
#define DPGET_LOCAL                 0x00000001

};

/****************************************************************************
 *
 * Open API flags
 *
 ****************************************************************************/

mask DWORD OpenFlags
{
/*
 * Join the session that is described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_JOIN                 0x00000001

/*
 * Create a new session as described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_CREATE               0x00000002

/*
 * Return status about progress of open instead of showing
 * any status dialogs.
 */
#define DPOPEN_RETURNSTATUS		0x00000080L

};

/****************************************************************************
 *
 * Receive API flags
 * Default is DPRECEIVE_ALL
 *
 ****************************************************************************/
mask DWORD ReceiveFlags
{
/*
 * Get the first message in the queue
 */
#define DPRECEIVE_ALL               0x00000001

/*
 * Get the first message in the queue directed to a specific player 
 */
#define DPRECEIVE_TOPLAYER          0x00000002

/*
 * Get the first message in the queue from a specific player
 */
#define DPRECEIVE_FROMPLAYER        0x00000004

/*
 * Get the message but don't remove it from the queue
 */
#define DPRECEIVE_PEEK              0x00000008

};

/****************************************************************************
 *
 * Send API flags
 *
 ****************************************************************************/
mask DWORD SendFlags
{

/*
 * Send the message using a guaranteed send method.
 * Default is non-guaranteed.
 */
#define DPSEND_GUARANTEED           0x00000001


/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_HIGHPRIORITY         0x00000002

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_OPENSTREAM           0x00000008

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_CLOSESTREAM          0x00000010

/*
 * Send the message digitally signed to ensure authenticity.
 */
#define DPSEND_SIGNED               0x00000020

/*
 * Send the message with encryption to ensure privacy.
 */
#define DPSEND_ENCRYPTED            0x00000040

/*
 * The message is a lobby system message
 */
#define DPSEND_LOBBYSYSTEMMESSAGE	0x00000080


/*
 * Send message asynchronously, must check caps
 * before using this flag.  It is always provided
 * if the protocol flag is set.
 */
#define DPSEND_ASYNC				0x00000200

/*
 * When an message is completed, don't tell me. 
 * by default the application is notified with a system message.
 */
#define DPSEND_NOSENDCOMPLETEMSG    0x00000400


/*
 * Maximum priority for sends available to applications
 */
#define DPSEND_MAX_PRIORITY         0x0000FFFF

};

/****************************************************************************
 *
 * SetGroupData, SetGroupName, SetPlayerData, SetPlayerName,
 * SetSessionDesc API flags.
 * Default is DPSET_REMOTE.
 *
 ****************************************************************************/

mask DWORD SetDataFlags
{
/* 
 * Propagate the data to all players in the session
 */
#define DPSET_REMOTE                0x00000000

/*
 * Do not propagate the data to other players
 */
#define DPSET_LOCAL                 0x00000001

/*
 * Used with DPSET_REMOTE, use guaranteed message send to
 * propagate the data
 */
#define DPSET_GUARANTEED            0x00000002

};

/****************************************************************************
 *
 * GetMessageQueue API flags.
 * Default is DPMESSAGEQUEUE_SEND
 *
 ****************************************************************************/
mask DWORD GetMessageQueueFlags
{
/* 
 * Get Send Queue - requires Service Provider Support
 */
#define DPMESSAGEQUEUE_SEND        	0x00000001

/*
 * Get Receive Queue
 */
#define DPMESSAGEQUEUE_RECEIVE      0x00000002

};

/****************************************************************************
 *
 * Connect API flags
 *
 ****************************************************************************/

 
/*
 * Start an asynchronous connect which returns status codes
 */
//#define DPCONNECT_RETURNSTATUS      0x00000080


/****************************************************************************
 *
 * DirectPlay system messages and message data structures
 *
 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
 * the dwType member against one of the following DPSYS_xxx constants. Once
 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
 * structures to access the data of the message.
 *
 ****************************************************************************/

value DWORD DirectPlayMessages
{
/*
 * A new player or group has been created in the session
 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
 * is a player or a group.
 */
#define DPSYS_CREATEPLAYERORGROUP   0x0003  

/*
 * A player has been deleted from the session
 * Use DPMSG_DESTROYPLAYERORGROUP
 */
#define DPSYS_DESTROYPLAYERORGROUP  0x0005  

/*
 * A player has been added to a group
 * Use DPMSG_ADDPLAYERTOGROUP
 */
#define DPSYS_ADDPLAYERTOGROUP      0x0007  

/*
 * A player has been removed from a group
 * Use DPMSG_DELETEPLAYERFROMGROUP
 */
#define DPSYS_DELETEPLAYERFROMGROUP 0x0021  

/*
 * This DirectPlay object lost its connection with all the
 * other players in the session.
 * Use DPMSG_SESSIONLOST.
 */
#define DPSYS_SESSIONLOST           0x0031

/*
 * The current host has left the session.
 * This DirectPlay object is now the host.
 * Use DPMSG_HOST.
 */
#define DPSYS_HOST                  0x0101

/*
 * The remote data associated with a player or
 * group has changed. Check dwPlayerType to see
 * if it is a player or a group
 * Use DPMSG_SETPLAYERORGROUPDATA
 */
#define DPSYS_SETPLAYERORGROUPDATA  0x0102

/*
 * The name of a player or group has changed.
 * Check dwPlayerType to see if it is a player
 * or a group.
 * Use DPMSG_SETPLAYERORGROUPNAME
 */
#define DPSYS_SETPLAYERORGROUPNAME  0x0103

/*
 * The session description has changed.
 * Use DPMSG_SETSESSIONDESC
 */
#define DPSYS_SETSESSIONDESC        0x0104

/*
 * A group has been added to a group
 * Use DPMSG_ADDGROUPTOGROUP
 */
#define DPSYS_ADDGROUPTOGROUP      	0x0105  

/*
 * A group has been removed from a group
 * Use DPMSG_DELETEGROUPFROMGROUP
 */
#define DPSYS_DELETEGROUPFROMGROUP 	0x0106

/*
 * A secure player-player message has arrived.
 * Use DPMSG_SECUREMESSAGE
 */
#define DPSYS_SECUREMESSAGE         0x0107

/*
 * Start a new session.
 * Use DPMSG_STARTSESSION
 */
#define DPSYS_STARTSESSION          0x0108

/*
 * A chat message has arrived
 * Use DPMSG_CHAT
 */
#define DPSYS_CHAT                  0x0109

/*
 * The owner of a group has changed
 * Use DPMSG_SETGROUPOWNER
 */
#define DPSYS_SETGROUPOWNER         0x010A

/*
 * An async send has finished, failed or been cancelled
 * Use DPMSG_SENDCOMPLETE
 */
#define DPSYS_SENDCOMPLETE          0x010d

};


value DWORD PlayerTypeValue
{
/*
 * Used in the dwPlayerType field to indicate if it applies to a group
 * or a player
 */
#define DPPLAYERTYPE_GROUP          0x00000000
#define DPPLAYERTYPE_PLAYER         0x00000001

};


/*
 * DPMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct _DPMSG_GENERIC
{
    DirectPlayMessages       dwType;         // Message type
} DPMSG_GENERIC;
typedef DPMSG_GENERIC *LPDPMSG_GENERIC;

/*
 * DPMSG_CREATEPLAYERORGROUP
 * System message generated when a new player or group
 * created in the session with information about it.
 */
typedef struct _DPMSG_CREATEPLAYERORGROUP
{
    DWORD       dwType;         // Message type
    PlayerTypeValue    dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of the player or group
    DWORD       dwCurrentPlayers;   // current # players & groups in session
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
    DPNAME      dpnName;        // structure with name info
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPID	    dpIdParent;     // id of parent group
	DWORD		dwFlags;		// player or group flags
} DPMSG_CREATEPLAYERORGROUP;
typedef DPMSG_CREATEPLAYERORGROUP *LPDPMSG_CREATEPLAYERORGROUP;

/*
 * DPMSG_DESTROYPLAYERORGROUP
 * System message generated when a player or group is being
 * destroyed in the session with information about it.
 */
typedef struct _DPMSG_DESTROYPLAYERORGROUP
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // player ID being deleted
    LPVOID      lpLocalData;    // copy of players local data
    DWORD       dwLocalDataSize; // sizeof local data
    LPVOID      lpRemoteData;   // copy of players remote data
    DWORD       dwRemoteDataSize; // sizeof remote data
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPNAME      dpnName;        // structure with name info
    DPID	    dpIdParent;     // id of parent group	
	DWORD		dwFlags;		// player or group flags
} DPMSG_DESTROYPLAYERORGROUP;
typedef DPMSG_DESTROYPLAYERORGROUP *LPDPMSG_DESTROYPLAYERORGROUP;

/*
 * DPMSG_ADDPLAYERTOGROUP
 * System message generated when a player is being added
 * to a group.
 */
typedef struct _DPMSG_ADDPLAYERTOGROUP
{
    DWORD       dwType;         // Message type
    DPID        dpIdGroup;      // group ID being added to
    DPID        dpIdPlayer;     // player ID being added
} DPMSG_ADDPLAYERTOGROUP;
typedef DPMSG_ADDPLAYERTOGROUP *LPDPMSG_ADDPLAYERTOGROUP;

/*
 * DPMSG_DELETEPLAYERFROMGROUP
 * System message generated when a player is being
 * removed from a group
 */
typedef DPMSG_ADDPLAYERTOGROUP          DPMSG_DELETEPLAYERFROMGROUP;
typedef DPMSG_DELETEPLAYERFROMGROUP     *LPDPMSG_DELETEPLAYERFROMGROUP;

/*
 * DPMSG_ADDGROUPTOGROUP
 * System message generated when a group is being added
 * to a group.
 */
typedef struct _DPMSG_ADDGROUPTOGROUP
{
    DWORD       dwType;         // Message type
    DPID        dpIdParentGroup; // group ID being added to
    DPID        dpIdGroup;     // group ID being added
} DPMSG_ADDGROUPTOGROUP;
typedef  DPMSG_ADDGROUPTOGROUP *LPDPMSG_ADDGROUPTOGROUP;

/*
 * DPMSG_DELETEGROUPFROMGROUP
 * System message generated when a GROUP is being
 * removed from a group
 */
typedef DPMSG_ADDGROUPTOGROUP          DPMSG_DELETEGROUPFROMGROUP;
typedef DPMSG_DELETEGROUPFROMGROUP     *LPDPMSG_DELETEGROUPFROMGROUP;

/*
 * DPMSG_SETPLAYERORGROUPDATA
 * System message generated when remote data for a player or
 * group has changed.
 */
typedef struct _DPMSG_SETPLAYERORGROUPDATA
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
} DPMSG_SETPLAYERORGROUPDATA;
typedef DPMSG_SETPLAYERORGROUPDATA *LPDPMSG_SETPLAYERORGROUPDATA;

/*
 * DPMSG_SETPLAYERORGROUPNAME
 * System message generated when the name of a player or
 * group has changed.
 */
typedef struct _DPMSG_SETPLAYERORGROUPNAME
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    DPNAME      dpnName;        // structure with new name info
} DPMSG_SETPLAYERORGROUPNAME;
typedef DPMSG_SETPLAYERORGROUPNAME *LPDPMSG_SETPLAYERORGROUPNAME;

/*
 * DPMSG_SETSESSIONDESC
 * System message generated when session desc has changed
 */
typedef struct _DPMSG_SETSESSIONDESC
{
    DWORD           dwType;     // Message type
    DPSESSIONDESC2  dpDesc;     // Session desc
} DPMSG_SETSESSIONDESC;
typedef DPMSG_SETSESSIONDESC *LPDPMSG_SETSESSIONDESC;

/*
 * DPMSG_HOST
 * System message generated when the host has migrated to this
 * DirectPlay object.
 *
 */
typedef DPMSG_GENERIC       DPMSG_HOST;
typedef DPMSG_HOST          *LPDPMSG_HOST;

/*
 * DPMSG_SESSIONLOST
 * System message generated when the connection to the session is lost.
 *
 */
typedef DPMSG_GENERIC       DPMSG_SESSIONLOST;
typedef DPMSG_SESSIONLOST   *LPDPMSG_SESSIONLOST;

/*
 * DPMSG_SECUREMESSAGE
 * System message generated when a player requests a secure send
 */
typedef struct _DPMSG_SECUREMESSAGE
{
    DWORD		dwType;         // Message Type
    DWORD		dwFlags;        // Signed/Encrypted
    DPID        dpIdFrom;       // ID of Sending Player
    LPVOID		lpData;         // Player message
    DWORD		dwDataSize;     // Size of player message
} DPMSG_SECUREMESSAGE;
typedef  DPMSG_SECUREMESSAGE *LPDPMSG_SECUREMESSAGE;

/*
 * DPMSG_STARTSESSION
 * System message containing all information required to 
 * start a new session
 */
typedef struct _DPMSG_STARTSESSION
{
    DWORD              dwType;     // Message type
    LPDPLCONNECTION    lpConn;     // DPLCONNECTION structure
} DPMSG_STARTSESSION;
typedef DPMSG_STARTSESSION *LPDPMSG_STARTSESSION;

/*
 * DPMSG_CHAT
 * System message containing a chat message
 */
typedef struct _DPMSG_CHAT
{
    DWORD              	dwType;       	// Message type
    DWORD              	dwFlags;      	// Message flags
    DPID               	idFromPlayer; 	// ID of the Sending Player
    DPID               	idToPlayer;   	// ID of the To Player
    DPID               	idToGroup;    	// ID of the To Group
	LPDPCHAT 			lpChat;			// Pointer to a structure containing the chat message
} DPMSG_CHAT;
typedef DPMSG_CHAT *LPDPMSG_CHAT;

/*
 * DPMSG_SETGROUPOWNER
 * System message generated when the owner of a group has changed
 */
typedef struct _DPMSG_SETGROUPOWNER
{
    DWORD       dwType;         // Message type
    DPID        idGroup;        // ID of the group
    DPID        idNewOwner;     // ID of the player that is the new owner
    DPID        idOldOwner;     // ID of the player that used to be the owner
} DPMSG_SETGROUPOWNER;
typedef DPMSG_SETGROUPOWNER *LPDPMSG_SETGROUPOWNER;

/*
 * DPMSG_SENDCOMPLETE
 * System message generated when finished with an Async Send message
 *
 * NOTE SENDPARMS has an overlay for DPMSG_SENDCOMPLETE, don't
 *                change this message w/o changing SENDPARMS.
 */
typedef struct _DPMSG_SENDCOMPLETE
{
	DWORD 		dwType;
	DPID		idFrom;
	DPID		idTo;
	DWORD		dwFlags;
	DWORD		dwPriority;
	DWORD		dwTimeout;
	LPVOID		lpvContext;
	DWORD		dwMsgID;
	DPRESULT     hr;
	DWORD       dwSendTime;
} DPMSG_SENDCOMPLETE;
typedef DPMSG_SENDCOMPLETE *LPDPMSG_SENDCOMPLETE;



/****************************************************************************
 *
 * IDirectPlay2 (and IDirectPlay2A) Interface
 *
 ****************************************************************************/


interface IDirectPlay2 : IUnknown
{
    /*** IDirectPlay2 methods ***/
    DPRESULT AddPlayerToGroup(DPID idGroup, DPID idPlayer );
    DPRESULT Close();
    DPRESULT CreateGroup( LPDPID lpidGroup, LPDPNAME lpGroupName, LPVOID lpData, DWORD dwDataSize, CreateGroupFlags dwFlags);
    DPRESULT CreatePlayer( LPDPID lpidPlayer, LPDPNAME lpPlayerName, HANDLE hEvent, LPVOID lpData, DWORD dwDataSize, CreatePlayerFlags dwFlags);
    DPRESULT DeletePlayerFromGroup(DPID idGroup, DPID idPlayer );
    DPRESULT DestroyGroup( DPID idGroup);
    DPRESULT DestroyPlayer( DPID idPlayer);
    DPRESULT EnumGroupPlayers( DPID idGroup, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, DWORD dwFlags);
    DPRESULT EnumGroups( LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, DWORD dwFlags );
    DPRESULT EnumPlayers(LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, EnumPlayersMask dwFlags);
    DPRESULT EnumSessions(LPDPSESSIONDESC2 lpsd, DWORD dwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumSessionsCallback2, LPVOID lpContext, EnumSessionsFlags dwFlags );
    DPRESULT GetCaps( [out] LPDPCAPS lpDPCaps, GetCapsFlags dwFlags);
    DPRESULT GetGroupData( DPID idGroup, [out] LPVOID lpData, [out] LPDWORD lpdwDataSize, GetDataFlags dwFlags);
    DPRESULT GetGroupName( DPID idGroup, [out] LPVOID lpData, [out] LPDWORD lpdwDataSize);
    DPRESULT GetMessageCount( DPID idPlayer, [out] LPDWORD lpdwCount );
    DPRESULT GetPlayerAddress( DPID idPlayer, [out] LPVOID lpData, [out] LPDWORD lpdwDataSize );
    DPRESULT GetPlayerCaps( DPID idPlayer, [out] LPDPCAPS lpPlayerCaps , GetCapsFlags dwFlags);
    DPRESULT GetPlayerData( DPID idPlayerD, [out] LPVOID lpData, [out] LPDWORD lpdwDataSize, GetDataFlags dwFlags);
    DPRESULT GetPlayerName( DPID idPlayerD, [out] LPVOID lpData, [out] LPDWORD lpdwDataSize );
    DPRESULT GetSessionDesc( [out] LPVOID lpData, [out] LPDWORD lpdwDataSize );
    DPRESULT Initialize( LPGUID lpGUID );
    DPRESULT Open( LPDPSESSIONDESC2 lpsd , OpenFlags dwFlags);
    DPRESULT Receive( LPDPID lpidFrom, LPDPID lpidTo, ReceiveFlags dwFlags, [out] LPVOID lpData, [out] LPDWORD lpdwDataSize );
    DPRESULT Send( DPID idFrom, DPID idTo, SendFlags dwFlags, LPVOID lpData, DWORD dwDataSize);
    DPRESULT SetGroupData( DPID idGroup, LPVOID lpData, DWORD dwDataSize, SetDataFlags dwFlags);
    DPRESULT SetGroupName( DPID idGroup, LPDPNAME lpGroupName, SetDataFlags dwFlags);
    DPRESULT SetPlayerData( DPID idPlayer, LPVOID lpData, DWORD dwDataSize, SetDataFlags dwFlags);
    DPRESULT SetPlayerName( DPID idPlayer, LPDPNAME lpPlayerName, SetDataFlags dwFlags);
    DPRESULT SetSessionDesc( LPDPSESSIONDESC2 lpSessDesc , SetDataFlags dwFlags);
};

/****************************************************************************
 *
 * IDirectPlay3 (and IDirectPlay3A) Interface
 *
 ****************************************************************************/

interface IDirectPlay3 : IDirectPlay2
{
     /*** IDirectPlay3 methods ***/
    DPRESULT AddGroupToGroup(DPID idParentGroup, DPID idGroup);
    DPRESULT CreateGroupInGroup(DPID idParentGroup , LPDPID lpidGroup , LPDPNAME lpGroupName , LPVOID lpData, DWORD dwDataSize, CreateGroupFlags dwFlags);
    DPRESULT DeleteGroupFromGroup(DPID idParentGroup, DPID idGroup);	
    DPRESULT EnumConnections( LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, EnumConnectionsFlags dwFlags);
    DPRESULT EnumGroupsInGroup( DPID idGroup, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, EnumPlayersMask dwFlags);
	DPRESULT GetGroupConnectionSettings(DWORD dwFlags, DPID idGroup, [out] LPVOID lpData, [out] LPDWORD dwDataSize);
	DPRESULT InitializeConnection(LPVOID lpData, DWORD dwDataSize);
    DPRESULT SecureOpen(LPCDPSESSIONDESC2 lpsd, DWORD dwFlags, LPCDPSECURITYDESC lpSecurity, LPCDPCREDENTIALS lpCredentials);
    DPRESULT SendChatMessage(DPID idFrom, DPID idTo, SendFlags dwFlags, LPDPCHAT lpChatMessage );
    DPRESULT SetGroupConnectionSettings(DWORD dwFlags, DPID idGroup, LPDPLCONNECTION lpConnection );
    DPRESULT StartSession(DWORD dwFlags, DPID idGroup );
    DPRESULT GetGroupFlags(DPID idGroup, [out] CreateGroupFlags * lpdwFlags );
    DPRESULT GetGroupParent(DPID idGroup, [out] LPDPID lpidParentGroup);
    DPRESULT GetPlayerAccount(DPID idPlayer, DWORD dwFlags, [out] LPVOID lpData , [out] LPDWORD lpdwDataSize );
    DPRESULT GetPlayerFlags(DPID idPlayer,  [out] LPDWORD lpdwDataSize );
};


interface IDirectPlay4 : IDirectPlay3
{
    /*** IDirectPlay4 methods ***/
    DPRESULT GetGroupOwner( DPID idGroup, [out]  LPDPID lpidOwner );
    DPRESULT SetGroupOwner(DPID idGroup, DPID idOwner);
    DPRESULT SendEx( DPID idFrom, DPID idTo, SendFlags dwFlags, LPVOID lpData, DWORD dwDataSize, DWORD dwPriority, DWORD dwTimeout, LPVOID lpContext, LPDWORD lpdwMsgID );
    DPRESULT GetMessageQueue(DPID idFrom, DPID idTo, GetMessageQueueFlags dwFlags, [out] LPDWORD lpdwNumMsgs, [out] LPDWORD lpdwNumBytes );
    DPRESULT CancelMessage( DWORD dwMsgID, DWORD dwFlags );
    DPRESULT CancelPriority( DWORD dwMinPriority, DWORD dwMaxPriority, DWORD dwFlags );
};



/*
 * API's
 */
 
DPRESULT DirectPlayEnumerateA( LPDPENUMDPCALLBACKA lpCallback, LPVOID lpContext );
DPRESULT DirectPlayEnumerateW( LPDPENUMDPCALLBACK lpCallback, LPVOID  lpContext);
DPRESULT DirectPlayCreate( LPGUID lpGUID, [out] LPDIRECTPLAY *lplpDP, IUnknown *pUnk);

HRESULT DllGetClassObject(
  REFCLSID rclsid,  //CLSID for the class object
  [iid] REFIID riid,      //Reference to the identifier of the interface 
                    // that communicates with the class object
  [out] COM_INTERFACE_PTR * ppv      //Address of output variable that receives the 
                    // interface pointer requested in riid
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\d3dcaps.h ===
//
// GUIDs
//



//
// Typedefs
//

typedef VOID * LPD3DENUMDEVICESCALLBACK;
typedef VOID * LPD3DENUMDEVICESCALLBACK7;


//
// Masks
//

mask DWORD d3ddevcapsFlags
{
	#define D3DDEVCAPS_FLOATTLVERTEX                 0x00000001L
	#define D3DDEVCAPS_SORTINCREASINGZ               0x00000002L
	#define D3DDEVCAPS_SORTDECREASINGZ               0X00000004L
	#define D3DDEVCAPS_SORTEXACT                     0x00000008L
	#define D3DDEVCAPS_EXECUTESYSTEMMEMORY           0x00000010L
	#define D3DDEVCAPS_EXECUTEVIDEOMEMORY            0x00000020L
	#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY          0x00000040L
	#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY           0x00000080L
	#define D3DDEVCAPS_TEXTURESYSTEMMEMORY           0x00000100L
	#define D3DDEVCAPS_TEXTUREVIDEOMEMORY            0x00000200L
	#define D3DDEVCAPS_DRAWPRIMTLVERTEX              0x00000400L
	#define D3DDEVCAPS_CANRENDERAFTERFLIP            0x00000800L
	#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM         0x00001000L
	#define D3DDEVCAPS_DRAWPRIMITIVES2               0x00002000L
	#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES       0x00004000L
	#define D3DDEVCAPS_DRAWPRIMITIVES2EX             0x00008000L
	#define D3DDEVCAPS_HWTRANSFORMANDLIGHT           0x00010000L
	#define D3DDEVCAPS_CANBLTSYSTONONLOCAL           0x00020000L
	#define D3DDEVCAPS_HWRASTERIZATION               0x00080000L
};

mask DWORD d3dlightingmodelFlags
{
	#define D3DLIGHTINGMODEL_RGB                     0x00000001L
	#define D3DLIGHTINGMODEL_MONO                    0x00000002L
};

mask DWORD d3dddFlags
{
	#define D3DDD_COLORMODEL                         0x00000001L
	#define D3DDD_DEVCAPS                            0x00000002L
	#define D3DDD_TRANSFORMCAPS                      0x00000004L
	#define D3DDD_LIGHTINGCAPS                       0x00000008L
	#define D3DDD_BCLIPPING                          0x00000010L
	#define D3DDD_LINECAPS                           0x00000020L
	#define D3DDD_TRICAPS                            0x00000040L
	#define D3DDD_DEVICERENDERBITDEPTH               0x00000080L
	#define D3DDD_DEVICEZBUFFERBITDEPTH              0x00000100L
	#define D3DDD_MAXBUFFERSIZE                      0x00000200L
	#define D3DDD_MAXVERTEXCOUNT                     0x00000400L
};

mask DWORD d3dptexturecapsFlags
{
	#define D3DPTEXTURECAPS_PERSPECTIVE              0x00000001L
	#define D3DPTEXTURECAPS_POW2                     0x00000002L
	#define D3DPTEXTURECAPS_ALPHA                    0x00000004L
	#define D3DPTEXTURECAPS_TRANSPARENCY             0x00000008L
	#define D3DPTEXTURECAPS_BORDER                   0x00000010L
	#define D3DPTEXTURECAPS_SQUAREONLY               0x00000020L
	#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L
	#define D3DPTEXTURECAPS_ALPHAPALETTE             0x00000080L
	#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL       0x00000100L
	#define D3DPTEXTURECAPS_PROJECTED                0x00000400L
	#define D3DPTEXTURECAPS_CUBEMAP                  0x00000800L
	#define D3DPTEXTURECAPS_COLORKEYBLEND            0x00001000L
};

mask DWORD d3dprastercapsFlags
{
	#define D3DPRASTERCAPS_DITHER                    0x00000001L
	#define D3DPRASTERCAPS_ROP2                      0x00000002L
	#define D3DPRASTERCAPS_XOR                       0x00000004L
	#define D3DPRASTERCAPS_PAT                       0x00000008L
	#define D3DPRASTERCAPS_ZTEST                     0x00000010L
	#define D3DPRASTERCAPS_SUBPIXEL                  0x00000020L
	#define D3DPRASTERCAPS_SUBPIXELX                 0x00000040L
	#define D3DPRASTERCAPS_FOGVERTEX                 0x00000080L
	#define D3DPRASTERCAPS_FOGTABLE                  0x00000100L
	#define D3DPRASTERCAPS_STIPPLE                   0x00000200L
	#define D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT    0x00000400L
	#define D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT  0x00000800L
	#define D3DPRASTERCAPS_ANTIALIASEDGES            0x00001000L
	#define D3DPRASTERCAPS_MIPMAPLODBIAS             0x00002000L
	#define D3DPRASTERCAPS_ZBIAS                     0x00004000L
	#define D3DPRASTERCAPS_ZBUFFERLESSHSR            0x00008000L
	#define D3DPRASTERCAPS_FOGRANGE                  0x00010000L
	#define D3DPRASTERCAPS_ANISOTROPY                0x00020000L
	#define D3DPRASTERCAPS_WBUFFER                   0x00040000L
	#define D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT 0x00080000L
	#define D3DPRASTERCAPS_WFOG                      0x00100000L
	#define D3DPRASTERCAPS_ZFOG                      0x00200000L
};

mask DWORD d3dfvfcapsFlags
{
	#define D3DFVFCAPS_TEXCOORDCOUNTMASK             0x0000ffffL
	#define D3DFVFCAPS_DONOTSTRIPELEMENTS            0x00080000L
};

mask DWORD d3ddebFlags
{
	#define D3DDEB_BUFSIZE                           0x00000001l
	#define D3DDEB_CAPS                              0x00000002l
	#define D3DDEB_LPDATA                            0x00000004l
};

mask DWORD d3dptblendcapsFlags
{
	#define D3DPTBLENDCAPS_DECAL                     0x00000001L
	#define D3DPTBLENDCAPS_MODULATE                  0x00000002L
	#define D3DPTBLENDCAPS_DECALALPHA                0x00000004L
	#define D3DPTBLENDCAPS_MODULATEALPHA             0x00000008L
	#define D3DPTBLENDCAPS_DECALMASK                 0x00000010L
	#define D3DPTBLENDCAPS_MODULATEMASK              0x00000020L
	#define D3DPTBLENDCAPS_COPY                      0x00000040L
	#define D3DPTBLENDCAPS_ADD                       0x00000080L
};

mask DWORD d3dptaddresscapsFlags
{
	#define D3DPTADDRESSCAPS_WRAP                    0x00000001L
	#define D3DPTADDRESSCAPS_MIRROR                  0x00000002L
	#define D3DPTADDRESSCAPS_CLAMP                   0x00000004L
	#define D3DPTADDRESSCAPS_BORDER                  0x00000008L
	#define D3DPTADDRESSCAPS_INDEPENDENTUV           0x00000010L
};

mask DWORD d3dptfiltercapsFlags
{
	#define D3DPTFILTERCAPS_NEAREST                  0x00000001L
	#define D3DPTFILTERCAPS_LINEAR                   0x00000002L
	#define D3DPTFILTERCAPS_MIPNEAREST               0x00000004L
	#define D3DPTFILTERCAPS_MIPLINEAR                0x00000008L
	#define D3DPTFILTERCAPS_LINEARMIPNEAREST         0x00000010L
	#define D3DPTFILTERCAPS_LINEARMIPLINEAR          0x00000020L
	#define D3DPTFILTERCAPS_MINFPOINT                0x00000100L
	#define D3DPTFILTERCAPS_MINFLINEAR               0x00000200L
	#define D3DPTFILTERCAPS_MINFANISOTROPIC          0x00000400L
	#define D3DPTFILTERCAPS_MIPFPOINT                0x00010000L
	#define D3DPTFILTERCAPS_MIPFLINEAR               0x00020000L
	#define D3DPTFILTERCAPS_MAGFPOINT                0x01000000L
	#define D3DPTFILTERCAPS_MAGFLINEAR               0x02000000L
	#define D3DPTFILTERCAPS_MAGFANISOTROPIC          0x04000000L
	#define D3DPTFILTERCAPS_MAGFAFLATCUBIC           0x08000000L
	#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC        0x10000000L
};

mask DWORD d3ddebcapsFlags
{
	#define D3DDEBCAPS_SYSTEMMEMORY                  0x00000001l
	#define D3DDEBCAPS_VIDEOMEMORY                   0x00000002l
	#define D3DDEBCAPS_MEM                           3 
};

mask DWORD d3dpcmpcapsFlags
{
	#define D3DPCMPCAPS_NEVER                        0x00000001L
	#define D3DPCMPCAPS_LESS                         0x00000002L
	#define D3DPCMPCAPS_EQUAL                        0x00000004L
	#define D3DPCMPCAPS_LESSEQUAL                    0x00000008L
	#define D3DPCMPCAPS_GREATER                      0x00000010L
	#define D3DPCMPCAPS_NOTEQUAL                     0x00000020L
	#define D3DPCMPCAPS_GREATEREQUAL                 0x00000040L
	#define D3DPCMPCAPS_ALWAYS                       0x00000080L
};

mask DWORD d3dtexopcapsFlags
{
	#define D3DTEXOPCAPS_DISABLE                     0x00000001L
	#define D3DTEXOPCAPS_SELECTARG1                  0x00000002L
	#define D3DTEXOPCAPS_SELECTARG2                  0x00000004L
	#define D3DTEXOPCAPS_MODULATE                    0x00000008L
	#define D3DTEXOPCAPS_MODULATE2X                  0x00000010L
	#define D3DTEXOPCAPS_MODULATE4X                  0x00000020L
	#define D3DTEXOPCAPS_ADD                         0x00000040L
	#define D3DTEXOPCAPS_ADDSIGNED                   0x00000080L
	#define D3DTEXOPCAPS_ADDSIGNED2X                 0x00000100L
	#define D3DTEXOPCAPS_SUBTRACT                    0x00000200L
	#define D3DTEXOPCAPS_ADDSMOOTH                   0x00000400L
	#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA           0x00000800L
	#define D3DTEXOPCAPS_BLENDTEXTUREALPHA           0x00001000L
	#define D3DTEXOPCAPS_BLENDFACTORALPHA            0x00002000L
	#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM         0x00004000L
	#define D3DTEXOPCAPS_BLENDCURRENTALPHA           0x00008000L
	#define D3DTEXOPCAPS_PREMODULATE                 0x00010000L
	#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR      0x00020000L
	#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA      0x00040000L
	#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR   0x00080000L
	#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA   0x00100000L
	#define D3DTEXOPCAPS_BUMPENVMAP                  0x00200000L
	#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE         0x00400000L
	#define D3DTEXOPCAPS_DOTPRODUCT3                 0x00800000L
};

mask DWORD d3dvtxpcapsFlags
{
	#define D3DVTXPCAPS_TEXGEN                       0x00000001L
	#define D3DVTXPCAPS_MATERIALSOURCE7              0x00000002L
	#define D3DVTXPCAPS_VERTEXFOG                    0x00000004L
	#define D3DVTXPCAPS_DIRECTIONALLIGHTS            0x00000008L
	#define D3DVTXPCAPS_POSITIONALLIGHTS             0x00000010L
	#define D3DVTXPCAPS_LOCALVIEWER                  0x00000020L
};

mask DWORD d3dstencilcapsFlags
{
	#define D3DSTENCILCAPS_KEEP                      0x00000001L
	#define D3DSTENCILCAPS_ZERO                      0x00000002L
	#define D3DSTENCILCAPS_REPLACE                   0x00000004L
	#define D3DSTENCILCAPS_INCRSAT                   0x00000008L
	#define D3DSTENCILCAPS_DECRSAT                   0x00000010L
	#define D3DSTENCILCAPS_INVERT                    0x00000020L
	#define D3DSTENCILCAPS_INCR                      0x00000040L
	#define D3DSTENCILCAPS_DECR                      0x00000080L
};

mask DWORD d3dpblendcapsFlags
{
	#define D3DPBLENDCAPS_ZERO                       0x00000001L
	#define D3DPBLENDCAPS_ONE                        0x00000002L
	#define D3DPBLENDCAPS_SRCCOLOR                   0x00000004L
	#define D3DPBLENDCAPS_INVSRCCOLOR                0x00000008L
	#define D3DPBLENDCAPS_SRCALPHA                   0x00000010L
	#define D3DPBLENDCAPS_INVSRCALPHA                0x00000020L
	#define D3DPBLENDCAPS_DESTALPHA                  0x00000040L
	#define D3DPBLENDCAPS_INVDESTALPHA               0x00000080L
	#define D3DPBLENDCAPS_DESTCOLOR                  0x00000100L
	#define D3DPBLENDCAPS_INVDESTCOLOR               0x00000200L
	#define D3DPBLENDCAPS_SRCALPHASAT                0x00000400L
	#define D3DPBLENDCAPS_BOTHSRCALPHA               0x00000800L
	#define D3DPBLENDCAPS_BOTHINVSRCALPHA            0x00001000L
};

mask DWORD d3dpshadecapsFlags
{
	#define D3DPSHADECAPS_COLORFLATMONO              0x00000001L
	#define D3DPSHADECAPS_COLORFLATRGB               0x00000002L
	#define D3DPSHADECAPS_COLORGOURAUDMONO           0x00000004L
	#define D3DPSHADECAPS_COLORGOURAUDRGB            0x00000008L
	#define D3DPSHADECAPS_COLORPHONGMONO             0x00000010L
	#define D3DPSHADECAPS_COLORPHONGRGB              0x00000020L
	#define D3DPSHADECAPS_SPECULARFLATMONO           0x00000040L
	#define D3DPSHADECAPS_SPECULARFLATRGB            0x00000080L
	#define D3DPSHADECAPS_SPECULARGOURAUDMONO        0x00000100L
	#define D3DPSHADECAPS_SPECULARGOURAUDRGB         0x00000200L
	#define D3DPSHADECAPS_SPECULARPHONGMONO          0x00000400L
	#define D3DPSHADECAPS_SPECULARPHONGRGB           0x00000800L
	#define D3DPSHADECAPS_ALPHAFLATBLEND             0x00001000L
	#define D3DPSHADECAPS_ALPHAFLATSTIPPLED          0x00002000L
	#define D3DPSHADECAPS_ALPHAGOURAUDBLEND          0x00004000L
	#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED       0x00008000L
	#define D3DPSHADECAPS_ALPHAPHONGBLEND            0x00010000L
	#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED         0x00020000L
	#define D3DPSHADECAPS_FOGFLAT                    0x00040000L
	#define D3DPSHADECAPS_FOGGOURAUD                 0x00080000L
	#define D3DPSHADECAPS_FOGPHONG                   0x00100000L
};

mask DWORD d3dfdsFlags
{
	#define D3DFDS_COLORMODEL                        0x00000001L
	#define D3DFDS_GUID                              0x00000002L
	#define D3DFDS_HARDWARE                          0x00000004L
	#define D3DFDS_TRIANGLES                         0x00000008L
	#define D3DFDS_LINES                             0x00000010L
	#define D3DFDS_MISCCAPS                          0x00000020L
	#define D3DFDS_RASTERCAPS                        0x00000040L
	#define D3DFDS_ZCMPCAPS                          0x00000080L
	#define D3DFDS_ALPHACMPCAPS                      0x00000100L
	#define D3DFDS_SRCBLENDCAPS                      0x00000200L
	#define D3DFDS_DSTBLENDCAPS                      0x00000400L
	#define D3DFDS_SHADECAPS                         0x00000800L
	#define D3DFDS_TEXTURECAPS                       0x00001000L
	#define D3DFDS_TEXTUREFILTERCAPS                 0x00002000L
	#define D3DFDS_TEXTUREBLENDCAPS                  0x00004000L
	#define D3DFDS_TEXTUREADDRESSCAPS                0x00008000L
};

mask DWORD d3dlightcapsFlags
{
	#define D3DLIGHTCAPS_POINT                       0x00000001L
	#define D3DLIGHTCAPS_SPOT                        0x00000002L
	#define D3DLIGHTCAPS_DIRECTIONAL                 0x00000004L
	#define D3DLIGHTCAPS_PARALLELPOINT               0x00000008L
	#define D3DLIGHTCAPS_GLSPOT                      0x00000010L
};

mask DWORD d3dpmisccapsFlags
{
	#define D3DPMISCCAPS_MASKPLANES                  0x00000001L
	#define D3DPMISCCAPS_MASKZ                       0x00000002L
	#define D3DPMISCCAPS_LINEPATTERNREP              0x00000004L
	#define D3DPMISCCAPS_CONFORMANT                  0x00000008L
	#define D3DPMISCCAPS_CULLNONE                    0x00000010L
	#define D3DPMISCCAPS_CULLCW                      0x00000020L
	#define D3DPMISCCAPS_CULLCCW                     0x00000040L
};

mask DWORD d3dtransformcapsFlags
{
	#define D3DTRANSFORMCAPS_CLIP                    0x00000001L
};



//
// Values
//



//
// Structs
//

typedef struct _D3DDEVINFO_TEXTUREMANAGER
{
    BOOL    bThrashing;                 /* indicates if thrashing */
    DWORD   dwApproxBytesDownloaded;    /* Approximate number of bytes downloaded by texture manager */
    DWORD   dwNumEvicts;                /* number of textures evicted */
    DWORD   dwNumVidCreates;            /* number of textures created in video memory */
    DWORD   dwNumTexturesUsed;          /* number of textures used */
    DWORD   dwNumUsedTexInVid;          /* number of used textures present in video memory */
    DWORD   dwWorkingSet;               /* number of textures in video memory */
    DWORD   dwWorkingSetBytes;          /* number of bytes in video memory */
    DWORD   dwTotalManaged;             /* total number of managed textures */
    DWORD   dwTotalBytes;               /* total number of bytes of managed textures */
    DWORD   dwLastPri;                  /* priority of last texture evicted */
} D3DDEVINFO_TEXTUREMANAGER, *LPD3DDEVINFO_TEXTUREMANAGER;

typedef struct _D3DExecuteBufferDesc
{
    DWORD               dwSize;         /* size of this structure */
    DWORD               dwFlags;        /* flags indicating which fields are valid */
    DWORD               dwCaps;         /* capabilities of execute buffer */
    DWORD               dwBufferSize;   /* size of execute buffer data */
    LPVOID              lpData;         /* pointer to actual data */
} D3DEXECUTEBUFFERDESC, *LPD3DEXECUTEBUFFERDESC;

typedef struct _D3DLIGHTINGCAPS
{
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

typedef struct _D3DPrimCaps
{
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

typedef struct _D3DFINDDEVICESEARCH
{
    DWORD               dwSize;
    DWORD               dwFlags;
    BOOL                bHardware;
    D3DCOLORMODEL       dcmColorModel;
    GUID                guid;
    DWORD               dwCaps;
    D3DPRIMCAPS         dpcPrimCaps;
} D3DFINDDEVICESEARCH, *LPD3DFINDDEVICESEARCH;

typedef struct _D3DTRANSFORMCAPS
{
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

typedef struct _D3DDEVINFO_TEXTURING
{
    DWORD   dwNumLoads;                 /* counts Load() API calls */
    DWORD   dwApproxBytesLoaded;        /* Approximate number bytes loaded via Load() */
    DWORD   dwNumPreLoads;              /* counts PreLoad() API calls */
    DWORD   dwNumSet;                   /* counts SetTexture() API calls */
    DWORD   dwNumCreates;               /* counts texture creates */
    DWORD   dwNumDestroys;              /* counts texture destroys */
    DWORD   dwNumSetPriorities;         /* counts SetPriority() API calls */
    DWORD   dwNumSetLODs;               /* counts SetLOD() API calls */
    DWORD   dwNumLocks;                 /* counts number of texture locks */
    DWORD   dwNumGetDCs;                /* counts number of GetDCs to textures */
} D3DDEVINFO_TEXTURING, *LPD3DDEVINFO_TEXTURING;

typedef struct _D3DDeviceDesc
{
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
    DWORD        dwMinTextureWidth;
    DWORD        dwMinTextureHeight;
    DWORD        dwMaxTextureWidth;
    DWORD        dwMaxTextureHeight;
    DWORD        dwMinStippleWidth;
    DWORD        dwMaxStippleWidth;
    DWORD        dwMinStippleHeight;
    DWORD        dwMaxStippleHeight;
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    // Guard band that the rasterizer can accommodate
    // Screen-space vertices inside this space but outside the viewport
    // will get clipped properly.
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
} D3DDEVICEDESC, *LPD3DDEVICEDESC;
typedef struct _D3DDeviceDesc7
{
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */

    DWORD       dwMinTextureWidth;
    DWORD       dwMinTextureHeight;
    DWORD       dwMaxTextureWidth;
    DWORD       dwMaxTextureHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;
    GUID        deviceGUID;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
} D3DDEVICEDESC7, *LPD3DDEVICEDESC7;

typedef struct _D3DFINDDEVICERESULT
{
    DWORD               dwSize;
    GUID                guid;           /* guid which matched */
    D3DDEVICEDESC       ddHwDesc;       /* hardware D3DDEVICEDESC */
    D3DDEVICEDESC       ddSwDesc;       /* software D3DDEVICEDESC */
} D3DFINDDEVICERESULT, *LPD3DFINDDEVICERESULT;


//
// Interfaces
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\debugging.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                Debugging Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
module KERNEL32.DLL:
category DebuggingAndErrorHandling:

typedef LPVOID LPDEBUG_EVENT;

FailOnFalse [gle] ContinueDebugEvent(
                                     DWORD dwProcessId,       
                                     DWORD dwThreadId,        
                                     DWORD dwContinueStatus   
                                     );

FailOnFalse [gle] DebugActiveProcess(
                                     DWORD dwProcessId   
                                     );

VOID DebugBreak();

VOID FatalExit(
               INT ExitCode   
               );

FailOnFalse [gle] FlushInstructionCache(
                                        HANDLE hProcess,        
                                        LPCVOID lpBaseAddress,  
                                        DWORD dwSize            
                                        );

FailOnFalse [gle] GetThreadContext(
                                   HANDLE hThread,       
                                   LPCONTEXT lpContext   
                                   );

FailOnFalse [gle] GetThreadSelectorEntry(
                                         HANDLE hThread,              
                                         DWORD dwSelector,            
                                         [out] LPVOID lpSelectorEntry  
                                         );

BOOL IsDebuggerPresent();

VOID OutputDebugStringA(
                       LPCSTR lpOutputString   
                       );

VOID OutputDebugStringW(
                       LPCWSTR lpOutputString   
                       );

FailOnFalse [gle] SetThreadContext(
                                   HANDLE hThread,            
                                   LPCONTEXT lpContext   
                                   );

FailOnFalse [gle] WaitForDebugEvent(
                                    LPDEBUG_EVENT lpDebugEvent,  
                                    DWORD dwMilliseconds         
                                    );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                          Error Handling Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FailOnFalse [gle] Beep(
                       DWORD dwFreq,      
                       DWORD dwDuration   
                       );

VOID FatalAppExitA(
                  UINT uAction,          
                  LPCSTR lpMessageText  
                  );

VOID FatalAppExitW(
                  UINT uAction,          
                  LPCWSTR lpMessageText  
                  );

module KERNEL32.DLL:

mask DWORD FormatMessageFlags
{
#define FORMAT_MESSAGE_ALLOCATE_BUFFER 0x00000100
#define FORMAT_MESSAGE_IGNORE_INSERTS  0x00000200
#define FORMAT_MESSAGE_FROM_STRING     0x00000400
#define FORMAT_MESSAGE_FROM_HMODULE    0x00000800
#define FORMAT_MESSAGE_FROM_SYSTEM     0x00001000
#define FORMAT_MESSAGE_ARGUMENT_ARRAY  0x00002000
#define FORMAT_MESSAGE_MAX_WIDTH_MASK  0x000000FF
};

DwordFailIfZero [gle] FormatMessageA(
                                    FormatMessageFlags dwFlags,      
                                    LPCVOID lpSource,   
                                    DWORD dwMessageId,  
                                    DWORD dwLanguageId, 
                                    [out] LPSTR lpBuffer,    
                                    DWORD nSize,        
                                    PVOID Arguments  
                                    );

DwordFailIfZero [gle] FormatMessageW(
                                    FormatMessageFlags dwFlags,      
                                    LPCVOID lpSource,   
                                    DWORD dwMessageId,  
                                    DWORD dwLanguageId, 
                                    [out] LPWSTR lpBuffer,    
                                    DWORD nSize,        
                                    PVOID Arguments  
                                    );


DWORD GetLastError();


value UINT MessageBeepType
{
#define MB_OK                       0x00000000L
#define MB_ICONHAND                 0x00000010L
#define MB_ICONQUESTION             0x00000020L
#define MB_ICONEXCLAMATION          0x00000030L
#define MB_ICONASTERISK             0x00000040L
};

module USER32.DLL:
FailOnFalse [gle] MessageBeep(
                              MessageBeepType uType   
                              );

value UINT SetErrorModeType
{
#define SEM_FAILCRITICALERRORS      0x0001
#define SEM_NOGPFAULTERRORBOX       0x0002
#define SEM_NOALIGNMENTFAULTEXCEPT  0x0004
#define SEM_NOOPENFILEERRORBOX      0x8000
};

module KERNEL32.DLL:
UINT SetErrorMode(
                  SetErrorModeType uMode   
                  );

VOID SetLastError(
                  DWORD dwErrCode   
                  );

module USER32.DLL:
VOID SetLastErrorEx(
                    DWORD dwErrCode,  
                    DWORD dwType      
                    );



// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                              Toolhelp32 Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


module KERNEL32.DLL:
mask DWORD CreateToolhelp32SnapshotFlags
{
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_INHERIT      0x80000000
};

value DWORD HeapList32Type
{
#define HF32_DEFAULT      1  // process's default heap
#define HF32_SHARED       2  // is shared heap
};

typedef struct tagHEAPLIST32
{
    SIZE_T dwSize;
    DWORD  th32ProcessID;   // owning process
    ULONG_PTR  th32HeapID;      // heap (in owning process's context!)
    HeapList32Type  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;

mask DWORD HeapEntry32Flags
{
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004
};

typedef struct tagHEAPENTRY32
{
    SIZE_T dwSize;
    HANDLE hHandle;     // Handle of this heap block
    ULONG_PTR dwAddress;   // Linear address of start of block
    SIZE_T dwBlockSize; // Size of block in bytes
    HeapEntry32Flags  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    ULONG_PTR  th32HeapID;      // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;

HANDLE [gle]
CreateToolhelp32Snapshot(
    CreateToolhelp32SnapshotFlags dwFlags,
    DWORD th32ProcessID
    );


FailOnFalse [gle]
Heap32ListFirst(
    HANDLE hSnapshot,
    [out] LPHEAPLIST32 lphl
    );

FailOnFalse [gle]
Heap32ListNext(
    HANDLE hSnapshot,
    [out] LPHEAPLIST32 lphl
    );

FailOnFalse [gle]
Heap32First(
    [out] LPHEAPENTRY32 lphe,
    DWORD th32ProcessID,
    ULONG_PTR th32HeapID
    );

FailOnFalse [gle]
Heap32Next(
    [out] LPHEAPENTRY32 lphe
    );

FailOnFalse [gle]
Toolhelp32ReadProcessMemory(
    DWORD   th32ProcessID,
    LPCVOID lpBaseAddress,
    LPVOID  lpBuffer,
    SIZE_T  cbRead,
    [out] SIZE_T *lpNumberOfBytesRead
    );

typedef struct tagPROCESSENTRY32W
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;          // this process
    ULONG_PTR th32DefaultHeapID;
    DWORD   th32ModuleID;           // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;         // Base priority of process's threads
    DWORD   dwFlags;
    WCHAR   szExeFile[260];    // Path
} PROCESSENTRY32W;
typedef PROCESSENTRY32W *  PPROCESSENTRY32W;
typedef PROCESSENTRY32W *  LPPROCESSENTRY32W;

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;          // this process
    ULONG_PTR th32DefaultHeapID;
    DWORD   th32ModuleID;           // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;         // Base priority of process's threads
    DWORD   dwFlags;
    CHAR    szExeFile[260];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

FailOnFalse [gle]
Process32FirstW(
    HANDLE hSnapshot,
    [out] LPPROCESSENTRY32W lppe
    );

FailOnFalse [gle]
Process32NextW(
    HANDLE hSnapshot,
    [out] LPPROCESSENTRY32W lppe
    );

FailOnFalse [gle]
Process32First(
    HANDLE hSnapshot,
    [out] LPPROCESSENTRY32 lppe
    );

FailOnFalse [gle]
Process32Next(
    HANDLE hSnapshot,
    [out] LPPROCESSENTRY32 lppe
    );

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;       // this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

FailOnFalse [gle]
Thread32First(
    HANDLE hSnapshot,
    [out] LPTHREADENTRY32 lpte
    );

FailOnFalse [gle]
Thread32Next(
    HANDLE hSnapshot,
    [out] LPTHREADENTRY32 lpte
    );

typedef struct tagMODULEENTRY32W
{
    DWORD   dwSize;
    DWORD   th32ModuleID;       // This module
    DWORD   th32ProcessID;      // owning process
    DWORD   GlblcntUsage;       // Global usage count on the module
    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
    WCHAR   szModule[256];
    WCHAR   szExePath[260];
} MODULEENTRY32W;
typedef MODULEENTRY32W *  PMODULEENTRY32W;
typedef MODULEENTRY32W *  LPMODULEENTRY32W;

FailOnFalse [gle]
Module32FirstW(
    HANDLE hSnapshot,
    [out] LPMODULEENTRY32W lpme
    );

FailOnFalse [gle]
Module32NextW(
    HANDLE hSnapshot,
    [out] LPMODULEENTRY32W lpme
    );


typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;       // This module
    DWORD   th32ProcessID;      // owning process
    DWORD   GlblcntUsage;       // Global usage count on the module
    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
    char    szModule[256];
    char    szExePath[260];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

FailOnFalse [gle]
Module32First(
    HANDLE hSnapshot,
    [out] LPMODULEENTRY32 lpme
    );

FailOnFalse [gle]
Module32Next(
    HANDLE hSnapshot,
    [out] LPMODULEENTRY32 lpme
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\d3dtypes.h ===
//
// GUIDs
//



//
// Typedefs
//

typedef float D3DVALUE;
typedef float *LPD3DVALUE;
typedef LONG D3DFIXED;
typedef VOID *LPD3DVALIDATECALLBACK;
typedef VOID *LPD3DENUMTEXTUREFORMATSCALLBACK;
typedef VOID *LPD3DENUMPIXELFORMATSCALLBACK;
typedef DWORD D3DMATERIALHANDLE;
typedef DWORD *LPD3DMATERIALHANDLE;
typedef DWORD D3DTEXTUREHANDLE;
typedef DWORD *LPD3DTEXTUREHANDLE;
typedef DWORD D3DMATRIXHANDLE;
typedef DWORD *LPD3DMATRIXHANDLE;
typedef DWORD D3DCOLORMODEL;
typedef DWORD D3DCOLOR;

typedef struct _D3DCOLORVALUE
{
    D3DVALUE dvR;
    D3DVALUE dvG;
    D3DVALUE dvB;
    D3DVALUE dvA;
} D3DCOLORVALUE, *LPD3DCOLORVALUE;

typedef struct _D3DVECTOR
{
    D3DVALUE dvX;
    D3DVALUE dvY;
    D3DVALUE dvZ;
} D3DVECTOR, *LPD3DVECTOR;

typedef struct _D3DRECT
{
    LONG lX1;
    LONG lY1;
    LONG lX2;
    LONG lY2;
} D3DRECT, *LPD3DRECT;


//
// Masks
//

mask DWORD d3dpvFlags
{
    #define D3DPV_DONOTCOPYDATA                      1
};

mask DWORD d3dclearFlags
{
    #define D3DCLEAR_TARGET                          0x00000001l
    #define D3DCLEAR_ZBUFFER                         0x00000002l
    #define D3DCLEAR_STENCIL                         0x00000004l
};

mask DWORD d3dclipFlags
{
    #define D3DCLIP_LEFT                             0x00000001L
    #define D3DCLIP_RIGHT                            0x00000002L
    #define D3DCLIP_TOP                              0x00000004L
    #define D3DCLIP_BOTTOM                           0x00000008L
    #define D3DCLIP_FRONT                            0x00000010L
    #define D3DCLIP_BACK                             0x00000020L
    #define D3DCLIP_GEN0                             0x00000040L
    #define D3DCLIP_GEN1                             0x00000080L
    #define D3DCLIP_GEN2                             0x00000100L
    #define D3DCLIP_GEN3                             0x00000200L
    #define D3DCLIP_GEN4                             0x00000400L
    #define D3DCLIP_GEN5                             0x00000800L
};

mask DWORD d3dtriflagFlags
{
    #define D3DTRIFLAG_START                         0x00000000L
    #define D3DTRIFLAG_ODD                           0x0000001eL
    #define D3DTRIFLAG_EVEN                          0x0000001fL
    #define D3DTRIFLAG_EDGEENABLE1                   0x00000100L
    #define D3DTRIFLAG_EDGEENABLE2                   0x00000200L
    #define D3DTRIFLAG_EDGEENABLE3                   0x00000400L
};

mask DWORD d3dclipstatusFlags
{
    #define D3DCLIPSTATUS_STATUS                     0x00000001L
    #define D3DCLIPSTATUS_EXTENTS2                   0x00000002L
    #define D3DCLIPSTATUS_EXTENTS3                   0x00000004L
};

mask DWORD d3dsetstatusFlags
{
    #define D3DSETSTATUS_STATUS                      0x00000001L
    #define D3DSETSTATUS_EXTENTS                     0x00000002L
};

mask DWORD d3dwrapcoordFlags
{
    #define D3DWRAPCOORD_0                           0x00000001L
    #define D3DWRAPCOORD_1                           0x00000002L
    #define D3DWRAPCOORD_2                           0x00000004L
    #define D3DWRAPCOORD_3                           0x00000008L
};

mask DWORD d3dvisFlags
{
    #define D3DVIS_INSIDE_FRUSTUM                    0
    #define D3DVIS_INTERSECT_FRUSTUM                 1
    #define D3DVIS_OUTSIDE_FRUSTUM                   2
    #define D3DVIS_INSIDE_LEFT                       0
    #define D3DVIS_INTERSECT_LEFT                    4 
    #define D3DVIS_OUTSIDE_LEFT                      8 
    #define D3DVIS_INSIDE_RIGHT                      0
    #define D3DVIS_INTERSECT_RIGHT                   16 
    #define D3DVIS_OUTSIDE_RIGHT                     32 
    #define D3DVIS_INSIDE_TOP                        0
    #define D3DVIS_INTERSECT_TOP                     64 
    #define D3DVIS_OUTSIDE_TOP                       128 
    #define D3DVIS_INSIDE_BOTTOM                     0
    #define D3DVIS_INTERSECT_BOTTOM                  256 
    #define D3DVIS_OUTSIDE_BOTTOM                    512 
    #define D3DVIS_INSIDE_NEAR                       0
    #define D3DVIS_INTERSECT_NEAR                    1024 
    #define D3DVIS_OUTSIDE_NEAR                      2048 
    #define D3DVIS_INSIDE_FAR                        0
    #define D3DVIS_INTERSECT_FAR                     4096 
    #define D3DVIS_OUTSIDE_FAR                       8192 
};

mask DWORD d3dexecuteFlags
{
    #define D3DEXECUTE_CLIPPED                       0x00000001l
    #define D3DEXECUTE_UNCLIPPED                     0x00000002l
};

mask DWORD d3dvopFlags
{
    #define D3DVOP_LIGHT                             1024 
    #define D3DVOP_TRANSFORM                         1
    #define D3DVOP_CLIP                              4 
    #define D3DVOP_EXTENTS                           8 
};

mask DWORD d3dtaFlags
{
    #define D3DTA_SELECTMASK                         0x0000000f
    #define D3DTA_DIFFUSE                            0x00000000
    #define D3DTA_CURRENT                            0x00000001
    #define D3DTA_TEXTURE                            0x00000002
    #define D3DTA_TFACTOR                            0x00000003
    #define D3DTA_SPECULAR                           0x00000004
    #define D3DTA_COMPLEMENT                         0x00000010
    #define D3DTA_ALPHAREPLICATE                     0x00000020
};

mask DWORD d3ddevinfoidFlags
{
    #define D3DDEVINFOID_TEXTUREMANAGER              1
    #define D3DDEVINFOID_D3DTEXTUREMANAGER           2
    #define D3DDEVINFOID_TEXTURING                   3
};

mask DWORD d3dlightFlags
{
    #define D3DLIGHT_ACTIVE                          0x00000001
    #define D3DLIGHT_NO_SPECULAR                     0x00000002
    #define D3DLIGHT_ALL                             3 
};

mask DWORD d3dwrapFlags
{
    #define D3DWRAP_U                                0x00000001L
    #define D3DWRAP_V                                0x00000002L
};

mask DWORD d3dtssFlags
{
    #define D3DTSS_TCI_PASSTHRU                      0x00000000
    #define D3DTSS_TCI_CAMERASPACENORMAL             0x00010000
    #define D3DTSS_TCI_CAMERASPACEPOSITION           0x00020000
    #define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR   0x00030000
};

mask DWORD d3dtransformFlags
{
    #define D3DTRANSFORM_CLIPPED                     0x00000001l
    #define D3DTRANSFORM_UNCLIPPED                   0x00000002l
};

mask DWORD d3dpalFlags
{
    #define D3DPAL_FREE                              0x00
    #define D3DPAL_READONLY                          0x40
    #define D3DPAL_RESERVED                          0x80
};

mask DWORD d3dvbcapsFlags
{
    #define D3DVBCAPS_SYSTEMMEMORY                   0x00000800l
    #define D3DVBCAPS_WRITEONLY                      0x00010000l
    #define D3DVBCAPS_OPTIMIZED                      0x80000000l
    #define D3DVBCAPS_DONOTCLIP                      0x00000001l
};

mask DWORD d3dcolorFlags
{
    #define D3DCOLOR_MONO                            1
    #define D3DCOLOR_RGB                             2
};

mask DWORD d3denumretFlags
{
    #define D3DENUMRET_CANCEL                        1 
    #define D3DENUMRET_OK                            0 
};

mask DWORD d3dstateFlags
{
    #define D3DSTATE_OVERRIDE_BIAS                   256
};

mask DWORD d3drenderstateFlags
{
    #define D3DRENDERSTATE_BLENDENABLE               27 
    #define D3DRENDERSTATE_WRAPBIAS                  128UL
};

mask DWORD d3dfvfFlags
{
    #define D3DFVF_RESERVED0                         0x001
    #define D3DFVF_POSITION_MASK                     0x00E
    #define D3DFVF_XYZ                               0x002
    #define D3DFVF_XYZRHW                            0x004
    #define D3DFVF_XYZB1                             0x006
    #define D3DFVF_XYZB2                             0x008
    #define D3DFVF_XYZB3                             0x00a
    #define D3DFVF_XYZB4                             0x00c
    #define D3DFVF_XYZB5                             0x00e
    #define D3DFVF_NORMAL                            0x010
    #define D3DFVF_RESERVED1                         0x020
    #define D3DFVF_DIFFUSE                           0x040
    #define D3DFVF_SPECULAR                          0x080
    #define D3DFVF_TEXCOUNT_MASK                     0xf00
    #define D3DFVF_TEXCOUNT_SHIFT                    8
    #define D3DFVF_TEX0                              0x000
    #define D3DFVF_TEX1                              0x100
    #define D3DFVF_TEX2                              0x200
    #define D3DFVF_TEX3                              0x300
    #define D3DFVF_TEX4                              0x400
    #define D3DFVF_TEX5                              0x500
    #define D3DFVF_TEX6                              0x600
    #define D3DFVF_TEX7                              0x700
    #define D3DFVF_TEX8                              0x800
    #define D3DFVF_RESERVED2                         0xf000
    #define D3DFVF_VERTEX                            0x00000112 
    #define D3DFVF_LVERTEX                           0x000001E2 
    #define D3DFVF_TLVERTEX                          0x000001C4 
    #define D3DFVF_TEXTUREFORMAT2                    0
    #define D3DFVF_TEXTUREFORMAT1                    3
    #define D3DFVF_TEXTUREFORMAT3                    1
    #define D3DFVF_TEXTUREFORMAT4                    2
};

mask DWORD d3dstatusFlags
{
    #define D3DSTATUS_CLIPUNIONLEFT                  1 
    #define D3DSTATUS_CLIPUNIONRIGHT                 2 
    #define D3DSTATUS_CLIPUNIONTOP                   4 
    #define D3DSTATUS_CLIPUNIONBOTTOM                8 
    #define D3DSTATUS_CLIPUNIONFRONT                 16 
    #define D3DSTATUS_CLIPUNIONBACK                  32 
    #define D3DSTATUS_CLIPUNIONGEN0                  64 
    #define D3DSTATUS_CLIPUNIONGEN1                  128 
    #define D3DSTATUS_CLIPUNIONGEN2                  256 
    #define D3DSTATUS_CLIPUNIONGEN3                  512 
    #define D3DSTATUS_CLIPUNIONGEN4                  1024 
    #define D3DSTATUS_CLIPUNIONGEN5                  2048 
    #define D3DSTATUS_CLIPINTERSECTIONLEFT           0x00001000L
    #define D3DSTATUS_CLIPINTERSECTIONRIGHT          0x00002000L
    #define D3DSTATUS_CLIPINTERSECTIONTOP            0x00004000L
    #define D3DSTATUS_CLIPINTERSECTIONBOTTOM         0x00008000L
    #define D3DSTATUS_CLIPINTERSECTIONFRONT          0x00010000L
    #define D3DSTATUS_CLIPINTERSECTIONBACK           0x00020000L
    #define D3DSTATUS_CLIPINTERSECTIONGEN0           0x00040000L
    #define D3DSTATUS_CLIPINTERSECTIONGEN1           0x00080000L
    #define D3DSTATUS_CLIPINTERSECTIONGEN2           0x00100000L
    #define D3DSTATUS_CLIPINTERSECTIONGEN3           0x00200000L
    #define D3DSTATUS_CLIPINTERSECTIONGEN4           0x00400000L
    #define D3DSTATUS_CLIPINTERSECTIONGEN5           0x00800000L
    #define D3DSTATUS_ZNOTVISIBLE                    0x01000000L
    #define D3DSTATUS_CLIPUNIONALL                   0x00000FFFL 
    #define D3DSTATUS_CLIPINTERSECTIONALL            0x00FFF000L 
    #define D3DSTATUS_DEFAULT                        0x01FFF000L 
};

mask DWORD d3dprocessverticesFlags
{
    #define D3DPROCESSVERTICES_TRANSFORMLIGHT        0x00000000L
    #define D3DPROCESSVERTICES_TRANSFORM             0x00000001L
    #define D3DPROCESSVERTICES_COPY                  0x00000002L
    #define D3DPROCESSVERTICES_OPMASK                0x00000007L
    #define D3DPROCESSVERTICES_UPDATEEXTENTS         0x00000008L
    #define D3DPROCESSVERTICES_NOCOLOR               0x00000010L
};



//
// Values
//

value DWORD D3DBLEND
{
    #define D3DBLEND_ZERO                            1
    #define D3DBLEND_ONE                             2
    #define D3DBLEND_SRCCOLOR                        3
    #define D3DBLEND_INVSRCCOLOR                     4
    #define D3DBLEND_SRCALPHA                        5
    #define D3DBLEND_INVSRCALPHA                     6
    #define D3DBLEND_DESTALPHA                       7
    #define D3DBLEND_INVDESTALPHA                    8
    #define D3DBLEND_DESTCOLOR                       9
    #define D3DBLEND_INVDESTCOLOR                    10
    #define D3DBLEND_SRCALPHASAT                     11
    #define D3DBLEND_BOTHSRCALPHA                    12
    #define D3DBLEND_BOTHINVSRCALPHA                 13
    #define D3DBLEND_FORCE_DWORD                     0x7fffffff
};

value DWORD D3DTEXTURESTAGESTATETYPE
{
    #define D3DTSS_COLOROP                           1
    #define D3DTSS_COLORARG1                         2
    #define D3DTSS_COLORARG2                         3
    #define D3DTSS_ALPHAOP                           4
    #define D3DTSS_ALPHAARG1                         5
    #define D3DTSS_ALPHAARG2                         6
    #define D3DTSS_BUMPENVMAT00                      7
    #define D3DTSS_BUMPENVMAT01                      8
    #define D3DTSS_BUMPENVMAT10                      9
    #define D3DTSS_BUMPENVMAT11                      10
    #define D3DTSS_TEXCOORDINDEX                     11
    #define D3DTSS_ADDRESS                           12
    #define D3DTSS_ADDRESSU                          13
    #define D3DTSS_ADDRESSV                          14
    #define D3DTSS_BORDERCOLOR                       15
    #define D3DTSS_MAGFILTER                         16
    #define D3DTSS_MINFILTER                         17
    #define D3DTSS_MIPFILTER                         18
    #define D3DTSS_MIPMAPLODBIAS                     19
    #define D3DTSS_MAXMIPLEVEL                       20
    #define D3DTSS_MAXANISOTROPY                     21
    #define D3DTSS_BUMPENVLSCALE                     22
    #define D3DTSS_BUMPENVLOFFSET                    23
    #define D3DTSS_TEXTURETRANSFORMFLAGS             24
    #define D3DTSS_ADDRESSW                          25
    #define D3DTSS_COLORARG0                         26
    #define D3DTSS_ALPHAARG0                         27
    #define D3DTSS_RESULTARG                         28
    #define D3DTSS_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DSHADEMODE
{
    #define D3DSHADE_FLAT                            1
    #define D3DSHADE_GOURAUD                         2
    #define D3DSHADE_PHONG                           3
    #define D3DSHADE_FORCE_DWORD                     0x7fffffff
};

value DWORD D3DTEXTUREMAGFILTER
{
    #define D3DTFG_POINT                             1
    #define D3DTFG_LINEAR                            2
    #define D3DTFG_FLATCUBIC                         3
    #define D3DTFG_GAUSSIANCUBIC                     4
    #define D3DTFG_ANISOTROPIC                       5
    #define D3DTFG_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DCMPFUNC
{
    #define D3DCMP_NEVER                             1
    #define D3DCMP_LESS                              2
    #define D3DCMP_EQUAL                             3
    #define D3DCMP_LESSEQUAL                         4
    #define D3DCMP_GREATER                           5
    #define D3DCMP_NOTEQUAL                          6
    #define D3DCMP_GREATEREQUAL                      7
    #define D3DCMP_ALWAYS                            8
    #define D3DCMP_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DFILLMODE
{
    #define D3DFILL_POINT                            1
    #define D3DFILL_WIREFRAME                        2
    #define D3DFILL_SOLID                            3
    #define D3DFILL_FORCE_DWORD                      0x7fffffff
};

value DWORD D3DSTATEBLOCKTYPE
{
    #define D3DSBT_ALL                               1
    #define D3DSBT_PIXELSTATE                        2
    #define D3DSBT_VERTEXSTATE                       3
    #define D3DSBT_FORCE_DWORD                       0xffffffff
};

value DWORD D3DVERTEXBLENDFLAGS
{
    #define D3DVBLEND_DISABLE                        0
    #define D3DVBLEND_1WEIGHT                        1
    #define D3DVBLEND_2WEIGHTS                       2
    #define D3DVBLEND_3WEIGHTS                       3
};

value DWORD D3DTEXTUREOP
{
    #define D3DTOP_DISABLE                           1
    #define D3DTOP_SELECTARG1                        2
    #define D3DTOP_SELECTARG2                        3
    #define D3DTOP_MODULATE                          4
    #define D3DTOP_MODULATE2X                        5
    #define D3DTOP_MODULATE4X                        6
    #define D3DTOP_ADD                               7
    #define D3DTOP_ADDSIGNED                         8
    #define D3DTOP_ADDSIGNED2X                       9
    #define D3DTOP_SUBTRACT                          10
    #define D3DTOP_ADDSMOOTH                         11
    #define D3DTOP_BLENDDIFFUSEALPHA                 12
    #define D3DTOP_BLENDTEXTUREALPHA                 13
    #define D3DTOP_BLENDFACTORALPHA                  14
    #define D3DTOP_BLENDTEXTUREALPHAPM               15
    #define D3DTOP_BLENDCURRENTALPHA                 16
    #define D3DTOP_PREMODULATE                       17
    #define D3DTOP_MODULATEALPHA_ADDCOLOR            18
    #define D3DTOP_MODULATECOLOR_ADDALPHA            19
    #define D3DTOP_MODULATEINVALPHA_ADDCOLOR         20
    #define D3DTOP_MODULATEINVCOLOR_ADDALPHA         21
    #define D3DTOP_BUMPENVMAP                        22
    #define D3DTOP_BUMPENVMAPLUMINANCE               23
    #define D3DTOP_DOTPRODUCT3                       24
    #define D3DTOP_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DCULL
{
    #define D3DCULL_NONE                             1
    #define D3DCULL_CW                               2
    #define D3DCULL_CCW                              3
    #define D3DCULL_FORCE_DWORD                      0x7fffffff
};

value DWORD D3DSTENCILOP
{
    #define D3DSTENCILOP_KEEP                        1
    #define D3DSTENCILOP_ZERO                        2
    #define D3DSTENCILOP_REPLACE                     3
    #define D3DSTENCILOP_INCRSAT                     4
    #define D3DSTENCILOP_DECRSAT                     5
    #define D3DSTENCILOP_INVERT                      6
    #define D3DSTENCILOP_INCR                        7
    #define D3DSTENCILOP_DECR                        8
    #define D3DSTENCILOP_FORCE_DWORD                 0x7fffffff
};

value DWORD D3DTEXTUREBLEND
{
    #define D3DTBLEND_DECAL                          1
    #define D3DTBLEND_MODULATE                       2
    #define D3DTBLEND_DECALALPHA                     3
    #define D3DTBLEND_MODULATEALPHA                  4
    #define D3DTBLEND_DECALMASK                      5
    #define D3DTBLEND_MODULATEMASK                   6
    #define D3DTBLEND_COPY                           7
    #define D3DTBLEND_ADD                            8
    #define D3DTBLEND_FORCE_DWORD                    0x7fffffff
};

value DWORD D3DZBUFFERTYPE
{
    #define D3DZB_FALSE                              0
    #define D3DZB_TRUE                               1
    #define D3DZB_USEW                               2
    #define D3DZB_FORCE_DWORD                        0x7fffffff
};

value DWORD D3DTEXTUREFILTER
{
    #define D3DFILTER_NEAREST                        1
    #define D3DFILTER_LINEAR                         2
    #define D3DFILTER_MIPNEAREST                     3
    #define D3DFILTER_MIPLINEAR                      4
    #define D3DFILTER_LINEARMIPNEAREST               5
    #define D3DFILTER_LINEARMIPLINEAR                6
    #define D3DFILTER_FORCE_DWORD                    0x7fffffff
};

value DWORD D3DTEXTUREADDRESS
{
    #define D3DTADDRESS_WRAP                         1
    #define D3DTADDRESS_MIRROR                       2
    #define D3DTADDRESS_CLAMP                        3
    #define D3DTADDRESS_BORDER                       4
    #define D3DTADDRESS_FORCE_DWORD                  0x7fffffff
};

value DWORD D3DTEXTURETRANSFORMFLAGS
{
    #define D3DTTFF_DISABLE                          0
    #define D3DTTFF_COUNT1                           1
    #define D3DTTFF_COUNT2                           2
    #define D3DTTFF_COUNT3                           3
    #define D3DTTFF_COUNT4                           4
    #define D3DTTFF_PROJECTED                        256
    #define D3DTTFF_FORCE_DWORD                      0x7fffffff
};

value DWORD D3DLIGHTTYPE
{
    #define D3DLIGHT_POINT                           1
    #define D3DLIGHT_SPOT                            2
    #define D3DLIGHT_DIRECTIONAL                     3
    #define D3DLIGHT_PARALLELPOINT                   4
    #define D3DLIGHT_GLSPOT                          5
    #define D3DLIGHT_FORCE_DWORD                     0x7fffffff
};

value DWORD D3DOPCODE
{
    #define D3DOP_POINT                              1
    #define D3DOP_LINE                               2
    #define D3DOP_TRIANGLE                           3
    #define D3DOP_MATRIXLOAD                         4
    #define D3DOP_MATRIXMULTIPLY                     5
    #define D3DOP_STATETRANSFORM                     6
    #define D3DOP_STATELIGHT                         7
    #define D3DOP_STATERENDER                        8
    #define D3DOP_PROCESSVERTICES                    9
    #define D3DOP_TEXTURELOAD                        10
    #define D3DOP_EXIT                               11
    #define D3DOP_BRANCHFORWARD                      12
    #define D3DOP_SPAN                               13
    #define D3DOP_SETSTATUS                          14
    #define D3DOP_FORCE_DWORD                        0x7fffffff
};

value DWORD D3DTEXTUREMINFILTER
{
    #define D3DTFN_POINT                             1
    #define D3DTFN_LINEAR                            2
    #define D3DTFN_ANISOTROPIC                       3
    #define D3DTFN_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DLIGHTSTATETYPE
{
    #define D3DLIGHTSTATE_MATERIAL                   1
    #define D3DLIGHTSTATE_AMBIENT                    2
    #define D3DLIGHTSTATE_COLORMODEL                 3
    #define D3DLIGHTSTATE_FOGMODE                    4
    #define D3DLIGHTSTATE_FOGSTART                   5
    #define D3DLIGHTSTATE_FOGEND                     6
    #define D3DLIGHTSTATE_FOGDENSITY                 7
    #define D3DLIGHTSTATE_COLORVERTEX                8
    #define D3DLIGHTSTATE_FORCE_DWORD                0x7fffffff
};

value DWORD D3DANTIALIASMODE
{
    #define D3DANTIALIAS_NONE                        0
    #define D3DANTIALIAS_SORTDEPENDENT               1
    #define D3DANTIALIAS_SORTINDEPENDENT             2
    #define D3DANTIALIAS_FORCE_DWORD                 0x7fffffff
};

value DWORD D3DPRIMITIVETYPE
{
    #define D3DPT_POINTLIST                          1
    #define D3DPT_LINELIST                           2
    #define D3DPT_LINESTRIP                          3
    #define D3DPT_TRIANGLELIST                       4
    #define D3DPT_TRIANGLESTRIP                      5
    #define D3DPT_TRIANGLEFAN                        6
    #define D3DPT_FORCE_DWORD                        0x7fffffff
};

value DWORD D3DTEXTUREMIPFILTER
{
    #define D3DTFP_NONE                              1
    #define D3DTFP_POINT                             2
    #define D3DTFP_LINEAR                            3
    #define D3DTFP_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DMATERIALCOLORSOURCE
{
    #define D3DMCS_MATERIAL                          0
    #define D3DMCS_COLOR1                            1
    #define D3DMCS_COLOR2                            2
    #define D3DMCS_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DTRANSFORMSTATETYPE
{
    #define D3DTRANSFORMSTATE_WORLD                  1
    #define D3DTRANSFORMSTATE_VIEW                   2
    #define D3DTRANSFORMSTATE_PROJECTION             3
    #define D3DTRANSFORMSTATE_WORLD1                 4
    #define D3DTRANSFORMSTATE_WORLD2                 5
    #define D3DTRANSFORMSTATE_WORLD3                 6
    #define D3DTRANSFORMSTATE_TEXTURE0               16
    #define D3DTRANSFORMSTATE_TEXTURE1               17
    #define D3DTRANSFORMSTATE_TEXTURE2               18
    #define D3DTRANSFORMSTATE_TEXTURE3               19
    #define D3DTRANSFORMSTATE_TEXTURE4               20
    #define D3DTRANSFORMSTATE_TEXTURE5               21
    #define D3DTRANSFORMSTATE_TEXTURE6               22
    #define D3DTRANSFORMSTATE_TEXTURE7               23
    #define D3DTRANSFORMSTATE_FORCE_DWORD            0x7fffffff
};

value DWORD D3DVERTEXTYPE
{
    #define D3DVT_VERTEX                             1
    #define D3DVT_LVERTEX                            2
    #define D3DVT_TLVERTEX                           3
    #define D3DVT_FORCE_DWORD                        0x7fffffff
};

value DWORD D3DFOGMODE
{
    #define D3DFOG_NONE                              0
    #define D3DFOG_EXP                               1
    #define D3DFOG_EXP2                              2
    #define D3DFOG_LINEAR                            3
    #define D3DFOG_FORCE_DWORD                       0x7fffffff
};

value DWORD D3DRENDERSTATETYPE
{
    #define D3DRENDERSTATE_ANTIALIAS                 2
    #define D3DRENDERSTATE_TEXTUREPERSPECTIVE        4
    #define D3DRENDERSTATE_ZENABLE                   7
    #define D3DRENDERSTATE_FILLMODE                  8
    #define D3DRENDERSTATE_SHADEMODE                 9
    #define D3DRENDERSTATE_LINEPATTERN               10
    #define D3DRENDERSTATE_ZWRITEENABLE              14
    #define D3DRENDERSTATE_ALPHATESTENABLE           15
    #define D3DRENDERSTATE_LASTPIXEL                 16
    #define D3DRENDERSTATE_SRCBLEND                  19
    #define D3DRENDERSTATE_DESTBLEND                 20
    #define D3DRENDERSTATE_CULLMODE                  22
    #define D3DRENDERSTATE_ZFUNC                     23
    #define D3DRENDERSTATE_ALPHAREF                  24
    #define D3DRENDERSTATE_ALPHAFUNC                 25
    #define D3DRENDERSTATE_DITHERENABLE              26
    #define D3DRENDERSTATE_ALPHABLENDENABLE          27
    #define D3DRENDERSTATE_FOGENABLE                 28
    #define D3DRENDERSTATE_SPECULARENABLE            29
    #define D3DRENDERSTATE_ZVISIBLE                  30
    #define D3DRENDERSTATE_STIPPLEDALPHA             33
    #define D3DRENDERSTATE_FOGCOLOR                  34
    #define D3DRENDERSTATE_FOGTABLEMODE              35
    #define D3DRENDERSTATE_FOGSTART                  36
    #define D3DRENDERSTATE_FOGEND                    37
    #define D3DRENDERSTATE_FOGDENSITY                38
    #define D3DRENDERSTATE_EDGEANTIALIAS             40
    #define D3DRENDERSTATE_COLORKEYENABLE            41
    #define D3DRENDERSTATE_ZBIAS                     47
    #define D3DRENDERSTATE_RANGEFOGENABLE            48
    #define D3DRENDERSTATE_STENCILENABLE             52
    #define D3DRENDERSTATE_STENCILFAIL               53
    #define D3DRENDERSTATE_STENCILZFAIL              54
    #define D3DRENDERSTATE_STENCILPASS               55
    #define D3DRENDERSTATE_STENCILFUNC               56
    #define D3DRENDERSTATE_STENCILREF                57
    #define D3DRENDERSTATE_STENCILMASK               58
    #define D3DRENDERSTATE_STENCILWRITEMASK          59
    #define D3DRENDERSTATE_TEXTUREFACTOR             60
    #define D3DRENDERSTATE_WRAP0                     128
    #define D3DRENDERSTATE_WRAP1                     129
    #define D3DRENDERSTATE_WRAP2                     130
    #define D3DRENDERSTATE_WRAP3                     131
    #define D3DRENDERSTATE_WRAP4                     132
    #define D3DRENDERSTATE_WRAP5                     133
    #define D3DRENDERSTATE_WRAP6                     134
    #define D3DRENDERSTATE_WRAP7                     135
    #define D3DRENDERSTATE_CLIPPING                  136
    #define D3DRENDERSTATE_LIGHTING                  137
    #define D3DRENDERSTATE_EXTENTS                   138
    #define D3DRENDERSTATE_AMBIENT                   139
    #define D3DRENDERSTATE_FOGVERTEXMODE             140
    #define D3DRENDERSTATE_COLORVERTEX               141
    #define D3DRENDERSTATE_LOCALVIEWER               142
    #define D3DRENDERSTATE_NORMALIZENORMALS          143
    #define D3DRENDERSTATE_COLORKEYBLENDENABLE       144
    #define D3DRENDERSTATE_DIFFUSEMATERIALSOURCE     145
    #define D3DRENDERSTATE_SPECULARMATERIALSOURCE    146
    #define D3DRENDERSTATE_AMBIENTMATERIALSOURCE     147
    #define D3DRENDERSTATE_EMISSIVEMATERIALSOURCE    148
    #define D3DRENDERSTATE_VERTEXBLEND               151
    #define D3DRENDERSTATE_CLIPPLANEENABLE           152
    #define D3DRENDERSTATE_TEXTUREHANDLE             1
    #define D3DRENDERSTATE_TEXTUREADDRESS            3
    #define D3DRENDERSTATE_WRAPU                     5
    #define D3DRENDERSTATE_WRAPV                     6
    #define D3DRENDERSTATE_MONOENABLE                11
    #define D3DRENDERSTATE_ROP2                      12
    #define D3DRENDERSTATE_PLANEMASK                 13
    #define D3DRENDERSTATE_TEXTUREMAG                17
    #define D3DRENDERSTATE_TEXTUREMIN                18
    #define D3DRENDERSTATE_TEXTUREMAPBLEND           21
    #define D3DRENDERSTATE_SUBPIXEL                  31
    #define D3DRENDERSTATE_SUBPIXELX                 32
    #define D3DRENDERSTATE_STIPPLEENABLE             39
    #define D3DRENDERSTATE_BORDERCOLOR               43
    #define D3DRENDERSTATE_TEXTUREADDRESSU           44
    #define D3DRENDERSTATE_TEXTUREADDRESSV           45
    #define D3DRENDERSTATE_MIPMAPLODBIAS             46
    #define D3DRENDERSTATE_ANISOTROPY                49
    #define D3DRENDERSTATE_FLUSHBATCH                50
    #define D3DRENDERSTATE_STIPPLEPATTERN00          64
    #define D3DRENDERSTATE_STIPPLEPATTERN01          65
    #define D3DRENDERSTATE_STIPPLEPATTERN02          66
    #define D3DRENDERSTATE_STIPPLEPATTERN03          67
    #define D3DRENDERSTATE_STIPPLEPATTERN04          68
    #define D3DRENDERSTATE_STIPPLEPATTERN05          69
    #define D3DRENDERSTATE_STIPPLEPATTERN06          70
    #define D3DRENDERSTATE_STIPPLEPATTERN07          71
    #define D3DRENDERSTATE_STIPPLEPATTERN08          72
    #define D3DRENDERSTATE_STIPPLEPATTERN09          73
    #define D3DRENDERSTATE_STIPPLEPATTERN10          74
    #define D3DRENDERSTATE_STIPPLEPATTERN11          75
    #define D3DRENDERSTATE_STIPPLEPATTERN12          76
    #define D3DRENDERSTATE_STIPPLEPATTERN13          77
    #define D3DRENDERSTATE_STIPPLEPATTERN14          78
    #define D3DRENDERSTATE_STIPPLEPATTERN15          79
    #define D3DRENDERSTATE_STIPPLEPATTERN16          80
    #define D3DRENDERSTATE_STIPPLEPATTERN17          81
    #define D3DRENDERSTATE_STIPPLEPATTERN18          82
    #define D3DRENDERSTATE_STIPPLEPATTERN19          83
    #define D3DRENDERSTATE_STIPPLEPATTERN20          84
    #define D3DRENDERSTATE_STIPPLEPATTERN21          85
    #define D3DRENDERSTATE_STIPPLEPATTERN22          86
    #define D3DRENDERSTATE_STIPPLEPATTERN23          87
    #define D3DRENDERSTATE_STIPPLEPATTERN24          88
    #define D3DRENDERSTATE_STIPPLEPATTERN25          89
    #define D3DRENDERSTATE_STIPPLEPATTERN26          90
    #define D3DRENDERSTATE_STIPPLEPATTERN27          91
    #define D3DRENDERSTATE_STIPPLEPATTERN28          92
    #define D3DRENDERSTATE_STIPPLEPATTERN29          93
    #define D3DRENDERSTATE_STIPPLEPATTERN30          94
    #define D3DRENDERSTATE_STIPPLEPATTERN31          95
    #define D3DRENDERSTATE_FOGTABLESTART             36
    #define D3DRENDERSTATE_FOGTABLEEND               37
    #define D3DRENDERSTATE_FOGTABLEDENSITY           38
    #define D3DRENDERSTATE_FORCE_DWORD               0x7fffffff
};



//
// Structs
//

typedef struct _D3DLINEPATTERN
{
    WORD    wRepeatFactor;
    WORD    wLinePattern;
} D3DLINEPATTERN;

typedef struct _D3DPICKRECORD
{
    BYTE     bOpcode;
    BYTE     bPad;
    DWORD    dwOffset;
    D3DVALUE dvZ;
} D3DPICKRECORD, *LPD3DPICKRECORD;

typedef struct _D3DMATERIAL7
{
    D3DCOLORVALUE   dcvDiffuse;
    D3DCOLORVALUE   dcvAmbient;
    D3DCOLORVALUE   dcvSpecular;
    D3DCOLORVALUE   dcvEmissive;
    D3DVALUE        dvPower;
} D3DMATERIAL7, *LPD3DMATERIAL7;

typedef struct _D3DLINE
{
    WORD    wV1;
    WORD    wV2;
} D3DLINE, *LPD3DLINE;

typedef struct _D3DPOINT
{
    WORD    wCount;     /* number of points     */
    WORD    wFirst;     /* index to first vertex    */
} D3DPOINT, *LPD3DPOINT;

typedef struct _D3DCLIPSTATUS
{
    DWORD dwFlags; /* Do we set 2d extents, 3D extents or status */
    DWORD dwStatus; /* Clip status */
    float minx;
    float maxx; /* X extents */
    float miny;
    float maxy; /* Y extents */
    float minz;
    float maxz; /* Z extents */
} D3DCLIPSTATUS, *LPD3DCLIPSTATUS;

typedef struct _D3DBRANCH
{
    DWORD   dwMask;     /* Bitmask against D3D status */
    DWORD   dwValue;
    BOOL    bNegate;        /* TRUE to negate comparison */
    DWORD   dwOffset;   /* How far to branch forward (0 for exit)*/
} D3DBRANCH, *LPD3DBRANCH;

typedef struct _D3DDP_PTRSTRIDE
{
    LPVOID lpvData;
    DWORD  dwStride;
} D3DDP_PTRSTRIDE;

typedef struct _D3DDRAWPRIMITIVESTRIDEDDATA
{
    D3DDP_PTRSTRIDE position;
    D3DDP_PTRSTRIDE normal;
    D3DDP_PTRSTRIDE diffuse;
    D3DDP_PTRSTRIDE specular;
    D3DDP_PTRSTRIDE textureCoords[8];
} D3DDRAWPRIMITIVESTRIDEDDATA, *LPD3DDRAWPRIMITIVESTRIDEDDATA;

typedef struct _D3DSPAN
{
    WORD    wCount; /* Number of spans */
    WORD    wFirst; /* Index to first vertex */
} D3DSPAN, *LPD3DSPAN;

typedef struct _D3DLIGHTINGELEMENT
{
    D3DVECTOR dvPosition;           /* Lightable point in model space */
    D3DVECTOR dvNormal;             /* Normalised unit vector */
} D3DLIGHTINGELEMENT, *LPD3DLIGHTINGELEMENT;

typedef struct _D3DTRIANGLE
{
    WORD    wV1;
    WORD    wV2;
    WORD    wV3;
    WORD        wFlags;       /* Edge (and other) flags */
} D3DTRIANGLE, *LPD3DTRIANGLE;

typedef struct _D3DVERTEX
{
    D3DVALUE     dvX;
    D3DVALUE     dvY;
    D3DVALUE     dvZ;
    D3DVALUE     dvNX;
    D3DVALUE     dvNY;
    D3DVALUE     dvNZ;
    D3DVALUE     dvTU;
    D3DVALUE     dvTV;
} D3DVERTEX, *LPD3DVERTEX;

typedef struct _D3DSTATE
{
    DWORD   dwStateType;
    D3DVALUE        dvArg[1];
} D3DSTATE, *LPD3DSTATE;

typedef struct _D3DSTATUS
{
    DWORD       dwFlags;    /* Do we set extents or status */
    DWORD   dwStatus;   /* D3D status */
    D3DRECT drExtent;
} D3DSTATUS, *LPD3DSTATUS;

typedef struct _D3DPROCESSVERTICES
{
    DWORD        dwFlags;    /* Do we transform or light or just copy? */
    WORD         wStart;     /* Index to first vertex in source */
    WORD         wDest;      /* Index to first vertex in local buffer */
    DWORD        dwCount;    /* Number of vertices to be processed */
    DWORD    dwReserved; /* Must be zero */
} D3DPROCESSVERTICES, *LPD3DPROCESSVERTICES;

typedef struct _D3DHVERTEX
{
    DWORD           dwFlags;        /* Homogeneous clipping flags */
    D3DVALUE    dvHX;
    D3DVALUE    dvHY;
    D3DVALUE    dvHZ;
} D3DHVERTEX, *LPD3DHVERTEX;

typedef struct _D3DLVERTEX
{
    D3DVALUE     dvX;
    D3DVALUE     dvY;
    D3DVALUE     dvZ;
    DWORD        dwReserved;
    D3DCOLOR     dcColor;
    D3DCOLOR     dcSpecular;
    D3DVALUE     dvTU;
    D3DVALUE     dvTV;
} D3DLVERTEX, *LPD3DLVERTEX;

typedef struct _D3DLIGHT2
{
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;        /* Type of light source */
    D3DCOLORVALUE   dcvColor;       /* Color of light */
    D3DVECTOR       dvPosition;     /* Position in world space */
    D3DVECTOR       dvDirection;    /* Direction in world space */
    D3DVALUE        dvRange;        /* Cutoff range */
    D3DVALUE        dvFalloff;      /* Falloff */
    D3DVALUE        dvAttenuation0; /* Constant attenuation */
    D3DVALUE        dvAttenuation1; /* Linear attenuation */
    D3DVALUE        dvAttenuation2; /* Quadratic attenuation */
    D3DVALUE        dvTheta;        /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;          /* Outer angle of spotlight cone */
    DWORD           dwFlags;
} D3DLIGHT2, *LPD3DLIGHT2;

typedef struct _D3DEXECUTEDATA
{
    DWORD       dwSize;
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;   /* Status after execute */
} D3DEXECUTEDATA, *LPD3DEXECUTEDATA;

typedef struct _D3DSTATS
{
    DWORD        dwSize;
    DWORD        dwTrianglesDrawn;
    DWORD        dwLinesDrawn;
    DWORD        dwPointsDrawn;
    DWORD        dwSpansDrawn;
    DWORD        dwVerticesProcessed;
} D3DSTATS, *LPD3DSTATS;

typedef struct _D3DMATERIAL
{
    DWORD           dwSize;
    D3DCOLORVALUE   dcvDiffuse;
    D3DCOLORVALUE   dcvAmbient;
    D3DCOLORVALUE   dcvSpecular;
    D3DCOLORVALUE   dcvEmissive;
    D3DVALUE        dvPower;
    D3DTEXTUREHANDLE    hTexture;       /* Handle to texture map */
    DWORD           dwRampSize;
} D3DMATERIAL, *LPD3DMATERIAL;

typedef struct _D3DLIGHT7
{
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvDiffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   dcvSpecular;        /* Specular color of light */
    D3DCOLORVALUE   dcvAmbient;         /* Ambient color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT7, *LPD3DLIGHT7;

typedef struct _D3DTEXTURELOAD
{
    D3DTEXTUREHANDLE hDestTexture;
    D3DTEXTUREHANDLE hSrcTexture;
} D3DTEXTURELOAD, *LPD3DTEXTURELOAD;

typedef struct _D3DVIEWPORT2
{
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Viewport Dimensions */
    D3DVALUE    dvClipX;        /* Top left of clip volume */
    D3DVALUE    dvClipY;
    D3DVALUE    dvClipWidth;    /* Clip Volume Dimensions */
    D3DVALUE    dvClipHeight;
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT2, *LPD3DVIEWPORT2;

typedef struct _D3DMATRIX
{
    D3DVALUE        _11;
    D3DVALUE        _12;
    D3DVALUE        _13;
    D3DVALUE        _14;
    D3DVALUE        _21;
    D3DVALUE        _22;
    D3DVALUE        _23;
    D3DVALUE        _24;
    D3DVALUE        _31;
    D3DVALUE        _32;
    D3DVALUE        _33;
    D3DVALUE        _34;
    D3DVALUE        _41;
    D3DVALUE        _42;
    D3DVALUE        _43;
    D3DVALUE        _44;
} D3DMATRIX, *LPD3DMATRIX;

typedef struct _D3DMATRIXLOAD
{
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix;   /* Source matrix */
} D3DMATRIXLOAD, *LPD3DMATRIXLOAD;

typedef struct _D3DMATRIXMULTIPLY
{
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix1;  /* First source matrix */
    D3DMATRIXHANDLE hSrcMatrix2;  /* Second source matrix */
} D3DMATRIXMULTIPLY, *LPD3DMATRIXMULTIPLY;

typedef struct _D3DTRANSFORMDATA
{
    DWORD           dwSize;
    LPVOID      lpIn;           /* Input vertices */
    DWORD           dwInSize;       /* Stride of input vertices */
    LPVOID      lpOut;          /* Output vertices */
    DWORD           dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX    lpHOut;         /* Output homogeneous vertices */
    DWORD           dwClip;         /* Clipping hint */
    DWORD           dwClipIntersection;
    DWORD           dwClipUnion;    /* Union of all clip flags */
    D3DRECT         drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATA, *LPD3DTRANSFORMDATA;

typedef struct _D3DVERTEXBUFFERDESC
{
    DWORD dwSize;
    DWORD dwCaps;
    DWORD dwFVF;
    DWORD dwNumVertices;
} D3DVERTEXBUFFERDESC, *LPD3DVERTEXBUFFERDESC;

typedef struct _D3DVIEWPORT7
{
    DWORD       dwX;
    DWORD       dwY;            /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;       /* Viewport Dimensions */
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT7, *LPD3DVIEWPORT7;

typedef struct _D3DLIGHT
{
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvColor;           /* Color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT, *LPD3DLIGHT;

typedef struct _D3DTLVERTEX
{
    D3DVALUE    dvSX;
    D3DVALUE    dvSY;
    D3DVALUE    dvSZ;
    D3DVALUE    dvRHW;
    D3DCOLOR    dcColor;
    D3DCOLOR    dcSpecular;
    D3DVALUE    dvTU;
    D3DVALUE    dvTV;
} D3DTLVERTEX, *LPD3DTLVERTEX;

typedef struct _D3DVIEWPORT
{
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Dimensions */
    D3DVALUE    dvScaleX;   /* Scale homogeneous to screen */
    D3DVALUE    dvScaleY;   /* Scale homogeneous to screen */
    D3DVALUE    dvMaxX;     /* Min/max homogeneous x coord */
    D3DVALUE    dvMaxY;     /* Min/max homogeneous y coord */
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;     /* Min/max homogeneous z coord */
} D3DVIEWPORT, *LPD3DVIEWPORT;

typedef struct _D3DINSTRUCTION
{
    BYTE bOpcode;   /* Instruction opcode */
    BYTE bSize;     /* Size of each instruction data unit */
    WORD wCount;    /* Count of instruction data units to follow */
} D3DINSTRUCTION, *LPD3DINSTRUCTION;

typedef struct _D3DLIGHTDATA
{
    DWORD                dwSize;
    LPD3DLIGHTINGELEMENT lpIn;      /* Input positions and normals */
    DWORD                dwInSize;  /* Stride of input elements */
    LPD3DTLVERTEX        lpOut;     /* Output colors */
    DWORD                dwOutSize; /* Stride of output colors */
} D3DLIGHTDATA, *LPD3DLIGHTDATA;



//
// Interfaces
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\kernel32.h ===
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
//                              KERNEL32 API Set
//
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
typedef LPVOID LPCONTEXT; 

mask DWORD DesiredSecurityAccess
{
#define KEY_QUERY_VALUE         0x0001
#define KEY_SET_VALUE           0x0002
#define KEY_CREATE_SUB_KEY      0x0004
#define KEY_ENUMERATE_SUB_KEYS  0x0008
#define KEY_NOTIFY              0x0010
#define KEY_CREATE_LINK         0x0020
};

mask DWORD ServiceTypes
{
#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_INTERACTIVE_PROCESS    0x00000100
};

value DWORD StartTypes
{
#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004
};

value DWORD ErrorControls
{
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003
};

value DWORD ControlCodes
{
#define SERVICE_CONTROL_STOP           0x00000001
#define SERVICE_CONTROL_PAUSE          0x00000002
#define SERVICE_CONTROL_CONTINUE       0x00000003
#define SERVICE_CONTROL_INTERROGATE    0x00000004
#define SERVICE_CONTROL_SHUTDOWN       0x00000005
#define SERVICE_CONTROL_PARAMCHANGE    0x00000006
#define SERVICE_CONTROL_NETBINDADD     0x00000007
#define SERVICE_CONTROL_NETBINDREMOVE  0x00000008
#define SERVICE_CONTROL_NETBINDENABLE  0x00000009
#define SERVICE_CONTROL_NETBINDDISABLE 0x0000000A
};

mask DWORD DesiredAccessTypes
{
#define SC_MANAGER_CONNECT             0x0001
#define SC_MANAGER_CREATE_SERVICE      0x0002
#define SC_MANAGER_ENUMERATE_SERVICE   0x0004
#define SC_MANAGER_LOCK                0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS   0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG  0x0020
};

value DWORD InfoLevels 
{
#define SERVICE_CONFIG_DESCRIPTION     1
#define SERVICE_CONFIG_FAILURE_ACTIONS 2
};

value DWORD Status
{
#define STATUS_WAIT_0                    0x00000000L    
#define STATUS_ABANDONED_WAIT_0          0x00000080L    
#define STATUS_USER_APC                  0x000000C0L    
#define STATUS_TIMEOUT                   0x00000102L    
#define STATUS_PENDING                   0x00000103L    
#define STATUS_SEGMENT_NOTIFICATION      0x40000005L    
#define STATUS_GUARD_PAGE_VIOLATION      0x80000001L    
#define STATUS_DATATYPE_MISALIGNMENT     0x80000002L    
#define STATUS_BREAKPOINT                0x80000003L    
#define STATUS_SINGLE_STEP               0x80000004L    
#define STATUS_ACCESS_VIOLATION          0xC0000005L    
#define STATUS_IN_PAGE_ERROR             0xC0000006L    
#define STATUS_INVALID_HANDLE            0xC0000008L    
#define STATUS_NO_MEMORY                 0xC0000017L    
#define STATUS_ILLEGAL_INSTRUCTION       0xC000001DL    
#define STATUS_NONCONTINUABLE_EXCEPTION  0xC0000025L    
#define STATUS_INVALID_DISPOSITION       0xC0000026L    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     0xC000008CL    
#define STATUS_FLOAT_DENORMAL_OPERAND    0xC000008DL    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      0xC000008EL    
#define STATUS_FLOAT_INEXACT_RESULT      0xC000008FL    
#define STATUS_FLOAT_INVALID_OPERATION   0xC0000090L    
#define STATUS_FLOAT_OVERFLOW            0xC0000091L    
#define STATUS_FLOAT_STACK_CHECK         0xC0000092L    
#define STATUS_FLOAT_UNDERFLOW           0xC0000093L    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    0xC0000094L    
#define STATUS_INTEGER_OVERFLOW          0xC0000095L    
#define STATUS_PRIVILEGED_INSTRUCTION    0xC0000096L    
#define STATUS_STACK_OVERFLOW            0xC00000FDL    
#define STATUS_CONTROL_C_EXIT            0xC000013AL    
#define STATUS_FLOAT_MULTIPLE_FAULTS     0xC00002B4L    
#define STATUS_FLOAT_MULTIPLE_TRAPS      0xC00002B5L    
#define STATUS_ILLEGAL_VLM_REFERENCE     0xC00002C0L     
};

mask DWORD ControlEvents
{
#define CTRL_C_EVENT        0
#define CTRL_BREAK_EVENT    1
#define CTRL_CLOSE_EVENT    2
#define CTRL_LOGOFF_EVENT   5
#define CTRL_SHUTDOWN_EVENT 6
};

mask DWORD GenericAccessRights
{
#define GENERIC_READ                    0x80000000L
#define GENERIC_WRITE                   0x40000000L
#define GENERIC_EXECUTE                 0x20000000L
#define GENERIC_ALL                     0x10000000L
};

mask DWORD ShareRights
{
#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_SHARE_DELETE               0x00000004  
};

value DWORD CreationActions
{
#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5
};

typedef struct _OVERLAPPED { 
    DWORD  Internal; 
    DWORD  InternalHigh; 
    DWORD  Offset; 
    DWORD  OffsetHigh; 
    HANDLE hEvent; 
} OVERLAPPED; 

value INT FilePointerStartingPosition
{
#define FILE_BEGIN           0
#define FILE_CURRENT         1
#define FILE_END             2
};

value LONG ThreadBasePriority
{
#define THREAD_BASE_PRIORITY_LOWRT  15  // value that gets a thread to LowRealtime-1
#define THREAD_BASE_PRIORITY_MAX    2   // maximum thread base priority boost
#define THREAD_BASE_PRIORITY_MIN    -2  // minimum thread base priority boost
#define THREAD_BASE_PRIORITY_IDLE   -15 // value that gets a thread to idle
};

value LONG ThreadPriority
{
#define THREAD_PRIORITY_LOWEST          -2
#define THREAD_PRIORITY_BELOW_NORMAL    -1
#define THREAD_PRIORITY_NORMAL          0
#define THREAD_PRIORITY_HIGHEST         2
#define THREAD_PRIORITY_ABOVE_NORMAL    1
#define THREAD_PRIORITY_ERROR_RETURN    0x7FFFFFFF
#define THREAD_PRIORITY_TIME_CRITICAL   15
#define THREAD_PRIORITY_IDLE            -15
};

#include "debugging.h"
#include "processes.h"
#include "memory.h"
#include "registry.h"
#include "fileio.h"
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\gdi32.h ===
module GDI32.DLL:
category GDI:


typedef HANDLE HGDIOBJ;
typedef HANDLE HFONT;
typedef HANDLE HPALETTE;
typedef HANDLE HBITMAP;
typedef HANDLE HBRUSH;
typedef HANDLE HPEN;
typedef HANDLE HENHMETAFILE;
typedef HANDLE HCOLORSPACE;
typedef HANDLE HGLRC;

typedef DWORD COLORREF;
typedef DWORD *LPCOLORREF;

value int _ODD_FAILURE
{
#define ODD_FAILURE 0x80000000 [fail]
};

/* Binary raster ops */
value DWORD _BinaryDrawMode
{
#define R2_BLACK            1   /*  0       */
#define R2_NOTMERGEPEN      2   /* DPon     */
#define R2_MASKNOTPEN       3   /* DPna     */
#define R2_NOTCOPYPEN       4   /* PN       */
#define R2_MASKPENNOT       5   /* PDna     */
#define R2_NOT              6   /* Dn       */
#define R2_XORPEN           7   /* DPx      */
#define R2_NOTMASKPEN       8   /* DPan     */
#define R2_MASKPEN          9   /* DPa      */
#define R2_NOTXORPEN        10  /* DPxn     */
#define R2_NOP              11  /* D        */
#define R2_MERGENOTPEN      12  /* DPno     */
#define R2_COPYPEN          13  /* P        */
#define R2_MERGEPENNOT      14  /* PDno     */
#define R2_MERGEPEN         15  /* DPo      */
#define R2_WHITE            16  /*  1       */
#define R2_LAST             16
};

value DWORD _TernaryDrawMode
{
/* Ternary raster operations */
#define SRCCOPY             0x00CC0020 /* dest = source                   */
#define SRCPAINT            0x00EE0086 /* dest = source OR dest           */
#define SRCAND              0x008800C6 /* dest = source AND dest          */
#define SRCINVERT           0x00660046 /* dest = source XOR dest          */
#define SRCERASE            0x00440328 /* dest = source AND (NOT dest )   */
#define NOTSRCCOPY          0x00330008 /* dest = (NOT source)             */
#define NOTSRCERASE         0x001100A6 /* dest = (NOT src) AND (NOT dest) */
#define MERGECOPY           0x00C000CA /* dest = (source AND pattern)     */
#define MERGEPAINT          0x00BB0226 /* dest = (NOT source) OR dest     */
#define PATCOPY             0x00F00021 /* dest = pattern                  */
#define PATPAINT            0x00FB0A09 /* dest = DPSnoo                   */
#define PATINVERT           0x005A0049 /* dest = pattern XOR dest         */
#define DSTINVERT           0x00550009 /* dest = (NOT dest)               */
#define BLACKNESS           0x00000042 /* dest = BLACK                    */
#define WHITENESS           0x00FF0062 /* dest = WHITE                    */
#define NOMIRRORBITMAP      0x80000000 /* Do not Mirror the bitmap in this call */
#define CAPTUREBLT          0x40000000 /* Include layered windows */
};



value DWORD _GDI_ERROR
{
#define GDI_ERROR 0xFFFFFFFFL [fail]
};
value DWORD _HGDI_ERROR
{
#define HGDI_ERROR 0xFFFFFFFFL [fail]
};

value DWORD _RegionFlags
{
/* Region Flags */
#define ERROR               0 [fail]
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3
};

value int _CombineRgn
{
/* CombineRgn() Styles */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5
};

value DWORD _COMBINRGN_STYLE
{
/* CombineRgn() Styles */
/* StretchBlt() Modes */
#define BLACKONWHITE                 1
#define WHITEONBLACK                 2
#define COLORONCOLOR                 3
#define HALFTONE                     4
};

value DWORD _PolyFill
{
/* PolyFill() Modes */
#define ALTERNATE                    1
#define WINDING                      2
#define POLYFILL_LAST                2
};

mask DWORD _LAYOUT
{
#define LAYOUT_RTL                         0x00000001 // Right to left
#define LAYOUT_BTT                         0x00000002 // Bottom to top
#define LAYOUT_VBH                         0x00000004 // Vertical before horizontal
//#define LAYOUT_ORIENTATIONMASK             (LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH)
#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008
};

mask DWORD _TextAlignmentOptions
{
/* Text Alignment Options */
//#define TA_NOUPDATECP                0
//#define TA_UPDATECP                  1
#define TA_LEFT                      0
#define TA_RIGHT                     2
#define TA_CENTER                    6
#define TA_TOP                       0
#define TA_BOTTOM                    8
#define TA_BASELINE                  24
#define TA_RTLREADING                256
};

mask DWORD _ETO
{
#define ETO_OPAQUE                   0x0002
#define ETO_CLIPPED                  0x0004
#define ETO_GLYPH_INDEX              0x0010
#define ETO_RTLREADING               0x0080
#define ETO_NUMERICSLOCAL            0x0400
#define ETO_NUMERICSLATIN            0x0800
#define ETO_IGNORELANGUAGE           0x1000
#define ETO_PDY                      0x2000
};

mask DWORD _AspectFiltering
{
#define ASPECT_FILTERING             0x0001
};


mask DWORD _DCB
{
/* Bounds Accumulation APIs */
#define DCB_ERROR       0           //[fail]
#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
};

value DWORD _Meta
{
/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0410
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139
#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43
#define META_EXTFLOODFILL            0x0548
#define META_SETLAYOUT               0x0149
#define META_DELETEOBJECT            0x01f0
#define META_CREATEPALETTE           0x00f7
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEREGION            0x06FF
};

//#define ELF_VERSION         0
//#define ELF_CULTURE_LATIN   0

mask DWORD _EnumFontsMask
{
/* EnumFonts Masks */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0x002
#define TRUETYPE_FONTTYPE   0x004
};


/* palette entry flags */
mask BYTE _PaletteEntryFlag
{
#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */
};

value DWORD _BK_Mode
{
/* Background Modes */
#define TRANSPARENT         1
#define OPAQUE              2
};

value DWORD _GM
{
/* Graphics Modes */
#define GM_COMPATIBLE       1
#define GM_ADVANCED         2
};

mask DWORD _PT
{
/* PolyDraw and GetPath point types */
#define PT_CLOSEFIGURE      0x01
#define PT_LINETO           0x02
#define PT_BEZIERTO         0x04
#define PT_MOVETO           0x06
};

value DWORD _MM
{
/* Mapping Modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

};

value DWORD _Coordinate_Mode
{
/* Coordinate Modes */
#define ABSOLUTE            1
#define RELATIVE            2
};

value DWORD _StockObject
{

/* Stock Logical Objects */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
//#define HOLLOW_BRUSH        NULL_BRUSH
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16

#define DEFAULT_GUI_FONT    17

#define DC_BRUSH            18
#define DC_PEN              19

};

value DWORD COLORREF_RETURN
{
#define CLR_INVALID     0xFFFFFFFF [fail]
};

value DWORD _BrushStyles
{
/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5
#define BS_DIBPATTERNPT     6
#define BS_PATTERN8X8       7
#define BS_DIBPATTERN8X8    8
#define BS_MONOPATTERN      9
};

value ULONG_PTR _HatchStyle
{
/* Hatch Styles */
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */
};

mask int _PS
{
/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
//#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
//#define PS_NULL             5
//#define PS_INSIDEFRAME      6
//#define PS_USERSTYLE        7
#define PS_ALTERNATE        8

#define PS_ENDCAP_ROUND     0x00000000
#define PS_ENDCAP_SQUARE    0x00000100
#define PS_ENDCAP_FLAT      0x00000200
#define PS_ENDCAP_MASK      0x00000F00

#define PS_JOIN_ROUND       0x00000000
#define PS_JOIN_BEVEL       0x00001000
#define PS_JOIN_MITER       0x00002000
#define PS_JOIN_MASK        0x0000F000

#define PS_COSMETIC         0x00000000
#define PS_GEOMETRIC        0x00010000
#define PS_TYPE_MASK        0x000F0000
};

value DWORD _AD
{
#define AD_COUNTERCLOCKWISE 1
#define AD_CLOCKWISE        2
};

value DWORD _DeviceParameters
{
/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0     /* Device driver version                    */
#define TECHNOLOGY    2     /* Device classification                    */
#define HORZSIZE      4     /* Horizontal size in millimeters           */
#define VERTSIZE      6     /* Vertical size in millimeters             */
#define HORZRES       8     /* Horizontal width in pixels               */
#define VERTRES       10    /* Vertical height in pixels                */
#define BITSPIXEL     12    /* Number of bits per pixel                 */
#define PLANES        14    /* Number of planes                         */
#define NUMBRUSHES    16    /* Number of brushes the device has         */
#define NUMPENS       18    /* Number of pens the device has            */
#define NUMMARKERS    20    /* Number of markers the device has         */
#define NUMFONTS      22    /* Number of fonts the device has           */
#define NUMCOLORS     24    /* Number of colors the device supports     */
#define PDEVICESIZE   26    /* Size required for device descriptor      */
#define CURVECAPS     28    /* Curve capabilities                       */
#define LINECAPS      30    /* Line capabilities                        */
#define POLYGONALCAPS 32    /* Polygonal capabilities                   */
#define TEXTCAPS      34    /* Text capabilities                        */
#define CLIPCAPS      36    /* Clipping capabilities                    */
#define RASTERCAPS    38    /* Bitblt capabilities                      */
#define ASPECTX       40    /* Length of the X leg                      */
#define ASPECTY       42    /* Length of the Y leg                      */
#define ASPECTXY      44    /* Length of the hypotenuse                 */


#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */

#define SIZEPALETTE  104    /* Number of entries in physical palette    */
#define NUMRESERVED  106    /* Number of reserved entries in palette    */
#define COLORRES     108    /* Actual color resolution                  */


// Printing related DeviceCaps. These replace the appropriate Escapes

#define PHYSICALWIDTH   110 /* Physical Width in device units           */
#define PHYSICALHEIGHT  111 /* Physical Height in device units          */
#define PHYSICALOFFSETX 112 /* Physical Printable Area x margin         */
#define PHYSICALOFFSETY 113 /* Physical Printable Area y margin         */
#define SCALINGFACTORX  114 /* Scaling factor x                         */
#define SCALINGFACTORY  115 /* Scaling factor y                         */

// Display driver specific

#define VREFRESH        116  /* Current vertical refresh rate of the    */
                             /* display device (for displays only) in Hz*/
#define DESKTOPVERTRES  117  /* Horizontal width of entire desktop in   */
                             /* pixels                                  */
#define DESKTOPHORZRES  118  /* Vertical height of entire desktop in    */
                             /* pixels                                  */
#define BLTALIGNMENT    119  /* Preferred blt alignment                 */
#define SHADEBLENDCAPS  120  /* Shading and blending caps               */
#define COLORMGMTCAPS   121  /* Color Management caps                   */
};

mask DWORD _DeviceCapabilityDT
{

/* Device Capability Masks: */

/* Device Technologies */
#define DT_PLOTTER          0   /* Vector plotter                   */
#define DT_RASDISPLAY       1   /* Raster display                   */
#define DT_RASPRINTER       2   /* Raster printer                   */
#define DT_RASCAMERA        3   /* Raster camera                    */
#define DT_CHARSTREAM       4   /* Character-stream, PLP            */
#define DT_METAFILE         5   /* Metafile, VDM                    */
#define DT_DISPFILE         6   /* Display-file                     */
};

mask DWORD _DeviceCapabilityCC
{
/* Curve Capabilities */
#define CC_NONE             0   /* Curves not supported             */
#define CC_CIRCLES          1   /* Can do circles                   */
#define CC_PIE              2   /* Can do pie wedges                */
#define CC_CHORD            4   /* Can do chord arcs                */
#define CC_ELLIPSES         8   /* Can do ellipese                  */
#define CC_WIDE             16  /* Can do wide lines                */
#define CC_STYLED           32  /* Can do styled lines              */
#define CC_WIDESTYLED       64  /* Can do wide styled lines         */
#define CC_INTERIORS        128 /* Can do interiors                 */
#define CC_ROUNDRECT        256 /*                                  */
};

mask DWORD _DeviceCapabilityLC
{
/* Line Capabilities */
#define LC_NONE             0   /* Lines not supported              */
#define LC_POLYLINE         2   /* Can do polylines                 */
#define LC_MARKER           4   /* Can do markers                   */
#define LC_POLYMARKER       8   /* Can do polymarkers               */
#define LC_WIDE             16  /* Can do wide lines                */
#define LC_STYLED           32  /* Can do styled lines              */
#define LC_WIDESTYLED       64  /* Can do wide styled lines         */
#define LC_INTERIORS        128 /* Can do interiors                 */
};

mask DWORD _DeviceCapabilityPC
{
/* Polygonal Capabilities */
#define PC_NONE             0   /* Polygonals not supported         */
#define PC_POLYGON          1   /* Can do polygons                  */
#define PC_RECTANGLE        2   /* Can do rectangles                */
#define PC_WINDPOLYGON      4   /* Can do winding polygons          */
#define PC_TRAPEZOID        4   /* Can do trapezoids                */
#define PC_SCANLINE         8   /* Can do scanlines                 */
#define PC_WIDE             16  /* Can do wide borders              */
#define PC_STYLED           32  /* Can do styled borders            */
#define PC_WIDESTYLED       64  /* Can do wide styled borders       */
#define PC_INTERIORS        128 /* Can do interiors                 */
#define PC_POLYPOLYGON      256 /* Can do polypolygons              */
#define PC_PATHS            512 /* Can do paths                     */
};

mask DWORD _DeviceCapabilityCP
{
/* Clipping Capabilities */
#define CP_NONE             0   /* No clipping of output            */
#define CP_RECTANGLE        1   /* Output clipped to rects          */
#define CP_REGION           2   /* obsolete                         */
};

mask DWORD _DeviceCapabilityTC
{
/* Text Capabilities */
#define TC_OP_CHARACTER     0x00000001  /* Can do OutputPrecision   CHARACTER      */
#define TC_OP_STROKE        0x00000002  /* Can do OutputPrecision   STROKE         */
#define TC_CP_STROKE        0x00000004  /* Can do ClipPrecision     STROKE         */
#define TC_CR_90            0x00000008  /* Can do CharRotAbility    90             */
#define TC_CR_ANY           0x00000010  /* Can do CharRotAbility    ANY            */
#define TC_SF_X_YINDEP      0x00000020  /* Can do ScaleFreedom      X_YINDEPENDENT */
#define TC_SA_DOUBLE        0x00000040  /* Can do ScaleAbility      DOUBLE         */
#define TC_SA_INTEGER       0x00000080  /* Can do ScaleAbility      INTEGER        */
#define TC_SA_CONTIN        0x00000100  /* Can do ScaleAbility      CONTINUOUS     */
#define TC_EA_DOUBLE        0x00000200  /* Can do EmboldenAbility   DOUBLE         */
#define TC_IA_ABLE          0x00000400  /* Can do ItalisizeAbility  ABLE           */
#define TC_UA_ABLE          0x00000800  /* Can do UnderlineAbility  ABLE           */
#define TC_SO_ABLE          0x00001000  /* Can do StrikeOutAbility  ABLE           */
#define TC_RA_ABLE          0x00002000  /* Can do RasterFontAble    ABLE           */
#define TC_VA_ABLE          0x00004000  /* Can do VectorFontAble    ABLE           */
#define TC_RESERVED         0x00008000
#define TC_SCROLLBLT        0x00010000  /* Don't do text scroll with blt           */

};

mask DWORD _DeviceCapabilityRC
{
/* Raster Capabilities */
#define RC_NONE             0
#define RC_BITBLT           1       /* Can do standard BLT.             */
#define RC_BANDING          2       /* Device requires banding support  */
#define RC_SCALING          4       /* Device requires scaling support  */
#define RC_BITMAP64         8       /* Device can support >64K bitmap   */
#define RC_GDI20_OUTPUT     0x0010      /* has 2.0 output calls         */
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080      /* supports DIB to memory       */
#define RC_PALETTE          0x0100      /* supports a palette           */
#define RC_DIBTODEV         0x0200      /* supports DIBitsToDevice      */
#define RC_BIGFONT          0x0400      /* supports >64K fonts          */
#define RC_STRETCHBLT       0x0800      /* supports StretchBlt          */
#define RC_FLOODFILL        0x1000      /* supports FloodFill           */
#define RC_STRETCHDIB       0x2000      /* supports StretchDIBits       */
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

};

mask DWORD _DeviceCapabilitySB
{
/* Shading and blending caps                */
#define SB_NONE             0x00000000
#define SB_CONST_ALPHA      0x00000001
#define SB_PIXEL_ALPHA      0x00000002
#define SB_PREMULT_ALPHA    0x00000004

#define SB_GRAD_RECT        0x00000010
#define SB_GRAD_TRI         0x00000020
};

mask DWORD _ColorManagementCaps
{
/* Color Management caps */
#define CM_NONE             0x00000000
#define CM_DEVICE_ICM       0x00000001
#define CM_GAMMA_RAMP       0x00000002
#define CM_CMYK_COLOR       0x00000004
};


/* DIB color table identifiers */
value DWORD _DIB_Color
{
#define DIB_RGB_COLORS      0 /* color table in RGBs */
#define DIB_PAL_COLORS      1 /* color table in palette indices */
};

value DWORD _SYSPAL
{
/* constants for Get/SetSystemPaletteUse() */
#define SYSPAL_ERROR        0 [fail]
#define SYSPAL_STATIC       1
#define SYSPAL_NOSTATIC     2
#define SYSPAL_NOSTATIC256  3
};

value DWORD _CreateDIBitmap
{
/* constants for CreateDIBitmap */
#define CBM_INIT        0x04L   /* initialize bitmap */
};

value DWORD _FLOODFILL
{
/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1
};
/* current version of specification */
//#define DM_SPECVERSION 0x0401



value DWORD _PSIDENT
{
/*
 * Parameters for POSTSCRIPT_IDENTIFY escape
 */

#define PSIDENT_GDICENTRIC    0
#define PSIDENT_PSCENTRIC     1
};
value DWORD _PSINJECTMode
{

/*
 * Constants for PSINJECTDATA.Flags field
 */

#define   PSINJECT_APPEND       0
#define   PSINJECT_REPLACE      1
};

/*
 * Constants for PSINJECTDATA.InjectionPoint field
 */

/*
 * The data injected at these points coexist with the output emitted
 * by the driver for the same points.
 */

value WORD _PSINJECT
{
#define PSINJECT_BEGINSTREAM                1
#define PSINJECT_PSADOBE                    2
#define PSINJECT_PAGESATEND                 3
#define PSINJECT_PAGES                      4

#define PSINJECT_DOCNEEDEDRES               5
#define PSINJECT_DOCSUPPLIEDRES             6
#define PSINJECT_PAGEORDER                  7
#define PSINJECT_ORIENTATION                8
#define PSINJECT_BOUNDINGBOX                9
#define PSINJECT_DOCUMENTPROCESSCOLORS      10

#define PSINJECT_COMMENTS                   11
#define PSINJECT_BEGINDEFAULTS              12
#define PSINJECT_ENDDEFAULTS                13
#define PSINJECT_BEGINPROLOG                14
#define PSINJECT_ENDPROLOG                  15
#define PSINJECT_BEGINSETUP                 16
#define PSINJECT_ENDSETUP                   17
#define PSINJECT_TRAILER                    18
#define PSINJECT_EOF                        19
#define PSINJECT_ENDSTREAM                  20
#define PSINJECT_DOCUMENTPROCESSCOLORSATEND 21

#define PSINJECT_PAGENUMBER                 100
#define PSINJECT_BEGINPAGESETUP             101
#define PSINJECT_ENDPAGESETUP               102
#define PSINJECT_PAGETRAILER                103
#define PSINJECT_PLATECOLOR                 104

#define PSINJECT_SHOWPAGE                   105
#define PSINJECT_PAGEBBOX                   106
#define PSINJECT_ENDPAGECOMMENTS            107

#define PSINJECT_VMSAVE                     200
#define PSINJECT_VMRESTORE                  201

};

value DWORD _PSPROTOCOL
{
/* Value returned for FEATURESETTING_PROTOCOL */
#define PSPROTOCOL_ASCII             0
#define PSPROTOCOL_BCP               1
#define PSPROTOCOL_TBCP              2
#define PSPROTOCOL_BINARY            3
};

mask DWORD _QDI
{
/* Flag returned from QUERYDIBSUPPORT */
#define QDI_SETDIBITS                1
#define QDI_GETDIBITS                2
#define QDI_DIBTOSCREEN              4
#define QDI_STRETCHDIB               8
};

value DWORD _FEATURESETTING
{
/*
 * Parameter for GET_PS_FEATURESETTING escape
 */

#define FEATURESETTING_NUP         0
#define FEATURESETTING_OUTPUT      1
#define FEATURESETTING_PSLEVEL     2
#define FEATURESETTING_CUSTPAPER   3
#define FEATURESETTING_MIRROR      4
#define FEATURESETTING_NEGATIVE    5
#define FEATURESETTING_PROTOCOL    6
};

value DWORD _PR_JOBSTATUS
{
#define PR_JOBSTATUS                 0x0000
};

value DWORD _OBJ
{
#define OBJ_ERROR           0   [fail]
/* Object Definitions for EnumObjects() */
#define OBJ_PEN             1
#define OBJ_BRUSH           2
#define OBJ_DC              3
#define OBJ_METADC          4
#define OBJ_PAL             5
#define OBJ_FONT            6
#define OBJ_BITMAP          7
#define OBJ_REGION          8
#define OBJ_METAFILE        9
#define OBJ_MEMDC           10
#define OBJ_EXTPEN          11
#define OBJ_ENHMETADC       12
#define OBJ_ENHMETAFILE     13
#define OBJ_COLORSPACE      14
};

value DWORD _MWT
{
/* xform stuff */
#define MWT_IDENTITY        1
#define MWT_LEFTMULTIPLY    2
#define MWT_RIGHTMULTIPLY   3
};


/* Image Color Matching color definitions */

value DWORD _CS
{
#define CS_ENABLE                       0x00000001L
#define CS_DISABLE                      0x00000002L
#define CS_DELETE_TRANSFORM             0x00000003L
};


value DWORD _OUT
{
#define OUT_DEFAULT_PRECIS          0
#define OUT_STRING_PRECIS           1
#define OUT_CHARACTER_PRECIS        2
#define OUT_STROKE_PRECIS           3
#define OUT_TT_PRECIS               4
#define OUT_DEVICE_PRECIS           5
#define OUT_RASTER_PRECIS           6
#define OUT_TT_ONLY_PRECIS          7
#define OUT_OUTLINE_PRECIS          8
#define OUT_SCREEN_OUTLINE_PRECIS   9
#define OUT_PS_ONLY_PRECIS          10
};

value BYTE _OUTBYTE
{
#define OUT_DEFAULT_PRECIS          0
#define OUT_STRING_PRECIS           1
#define OUT_CHARACTER_PRECIS        2
#define OUT_STROKE_PRECIS           3
#define OUT_TT_PRECIS               4
#define OUT_DEVICE_PRECIS           5
#define OUT_RASTER_PRECIS           6
#define OUT_TT_ONLY_PRECIS          7
#define OUT_OUTLINE_PRECIS          8
#define OUT_SCREEN_OUTLINE_PRECIS   9
#define OUT_PS_ONLY_PRECIS          10
};

mask DWORD _CLIP
{
#define CLIP_DEFAULT_PRECIS     0
#define CLIP_CHARACTER_PRECIS   1
#define CLIP_STROKE_PRECIS      2
#define CLIP_MASK               0xf
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
};

mask BYTE _CLIPBYTE
{
#define CLIP_DEFAULT_PRECIS     0
#define CLIP_CHARACTER_PRECIS   1
#define CLIP_STROKE_PRECIS      2
#define CLIP_MASK               0xf
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
};

value DWORD _QUALITY
{
#define DEFAULT_QUALITY         0
#define DRAFT_QUALITY           1
#define PROOF_QUALITY           2
#define NONANTIALIASED_QUALITY  3
#define ANTIALIASED_QUALITY     4
#define CLEARTYPE_QUALITY       5
};

value BYTE _QUALITYBYTE
{
#define DEFAULT_QUALITY         0
#define DRAFT_QUALITY           1
#define PROOF_QUALITY           2
#define NONANTIALIASED_QUALITY  3
#define ANTIALIASED_QUALITY     4
};

value DWORD _PITCH
{
#define DEFAULT_PITCH           0
#define FIXED_PITCH             1
#define VARIABLE_PITCH          2
#define MONO_FONT               8
};

value DWORD _CHARSET
{
#define ANSI_CHARSET            0
#define DEFAULT_CHARSET         1 [fail]
#define SYMBOL_CHARSET          2
#define SHIFTJIS_CHARSET        128
#define HANGEUL_CHARSET         129
#define HANGUL_CHARSET          129
#define GB2312_CHARSET          134
#define CHINESEBIG5_CHARSET     136
#define OEM_CHARSET             255
#define JOHAB_CHARSET           130
#define HEBREW_CHARSET          177
#define ARABIC_CHARSET          178
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define VIETNAMESE_CHARSET      163
#define THAI_CHARSET            222
#define EASTEUROPE_CHARSET      238
#define RUSSIAN_CHARSET         204

#define MAC_CHARSET             77
#define BALTIC_CHARSET          186
};

value BYTE _CHARSETBYTE
{
#define ANSI_CHARSET            0
#define DEFAULT_CHARSET         1
#define SYMBOL_CHARSET          2
#define SHIFTJIS_CHARSET        128
#define HANGEUL_CHARSET         129
#define HANGUL_CHARSET          129
#define GB2312_CHARSET          134
#define CHINESEBIG5_CHARSET     136
#define OEM_CHARSET             255
#define JOHAB_CHARSET           130
#define HEBREW_CHARSET          177
#define ARABIC_CHARSET          178
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define VIETNAMESE_CHARSET      163
#define THAI_CHARSET            222
#define EASTEUROPE_CHARSET      238
#define RUSSIAN_CHARSET         204

#define MAC_CHARSET             77
#define BALTIC_CHARSET          186
};

mask DWORD _FS
{

#define FS_LATIN1               0x00000001L
#define FS_LATIN2               0x00000002L
#define FS_CYRILLIC             0x00000004L
#define FS_GREEK                0x00000008L
#define FS_TURKISH              0x00000010L
#define FS_HEBREW               0x00000020L
#define FS_ARABIC               0x00000040L
#define FS_BALTIC               0x00000080L
#define FS_VIETNAMESE           0x00000100L
#define FS_THAI                 0x00010000L
#define FS_JISJAPAN             0x00020000L
#define FS_CHINESESIMP          0x00040000L
#define FS_WANSUNG              0x00080000L
#define FS_CHINESETRAD          0x00100000L
#define FS_JOHAB                0x00200000L
#define FS_SYMBOL               0x80000000L
};

mask DWORD _FF
{

/* Font Families */
#define FF_DONTCARE         0x00  /* Don't care or don't know. */
#define FF_ROMAN            0x10  /* Variable stroke width, serifed.Times Roman, Century Schoolbook, etc. */
#define FF_SWISS            0x20  /* Variable stroke width, sans-serifed.Helvetica, Swiss, etc. */
#define FF_MODERN           0x30  /* Constant stroke width, serifed or sans-serifed. Pica, Elite, Courier, etc. */
#define FF_SCRIPT           0x40  /* Cursive, etc. */
#define FF_DECORATIVE       0x50  /* Old English, etc. */

};

mask BYTE _FFBYTE
{

/* Font Families */
#define FF_DONTCARE         0x00  /* Don't care or don't know. */
#define FF_ROMAN            0x10  /* Variable stroke width, serifed.Times Roman, Century Schoolbook, etc. */
#define FF_SWISS            0x20  /* Variable stroke width, sans-serifed.Helvetica, Swiss, etc. */
#define FF_MODERN           0x30  /* Constant stroke width, serifed or sans-serifed. Pica, Elite, Courier, etc. */
#define FF_SCRIPT           0x40  /* Cursive, etc. */
#define FF_DECORATIVE       0x50  /* Old English, etc. */

};

mask int _FW
{
/* Font Weights */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

};

value DWORD _PAN
{
#define PAN_FAMILYTYPE_INDEX        0
#define PAN_SERIFSTYLE_INDEX        1
#define PAN_WEIGHT_INDEX            2
#define PAN_PROPORTION_INDEX        3
#define PAN_CONTRAST_INDEX          4
#define PAN_STROKEVARIATION_INDEX   5
#define PAN_ARMSTYLE_INDEX          6
#define PAN_LETTERFORM_INDEX        7
#define PAN_MIDLINE_INDEX           8
#define PAN_XHEIGHT_INDEX           9
};

value DWORD _PAN_CULTURE
{
#define PAN_CULTURE_LATIN           0
};

value DWORD _PAN_FAMILY
{
#define PAN_FAMILY_ANY                         0 /* Any                            */
#define PAN_FAMILY_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */
};
value DWORD _PAN_SERIF
{
#define PAN_SERIF_ANY                         0 /* Any                            */
#define PAN_SERIF_NO_FIT                      1 /* No Fit                         */
#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */
};
value DWORD _PAN_WEIGHT_CULTURE
{
#define PAN_WEIGHT_ANY                         0 /* Any                            */
#define PAN_WEIGHT_NO_FIT                      1 /* No Fit                         */
#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */
};
value DWORD _PAN_PROP
{
#define PAN_PROP_ANY                         0 /* Any                            */
#define PAN_PROP_NO_FIT                      1 /* No Fit                         */
#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */
};
value DWORD _PAN_CONTRAST
{
#define PAN_CONTRAST_ANY                         0 /* Any                            */
#define PAN_CONTRAST_NO_FIT                      1 /* No Fit                         */
#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */
};
value DWORD _PAN_STROKE
{
#define PAN_STROKE_ANY                         0 /* Any                            */
#define PAN_STROKE_NO_FIT                      1 /* No Fit                         */
#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */
};
value DWORD _PAN_ARMS
{
#define PAN_ARMS_ANY                         0 /* Any                            */
#define PAN_ARMS_NO_FIT                      1 /* No Fit                         */
#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */
};
value DWORD _PAN_LETT
{
#define PAN_LETT_ANY                         0 /* Any                            */
#define PAN_LETT_NO_FIT                      1 /* No Fit                         */
#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */
};
value DWORD _PAN_MIDLINE
{
#define PAN_MIDLINE_ANY                         0 /* Any                            */
#define PAN_MIDLINE_NO_FIT                      1 /* No Fit                         */
#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */
};
value DWORD _PAN_XHEIGHT
{
#define PAN_XHEIGHT_ANY                         0 /* Any                            */
#define PAN_XHEIGHT_NO_FIT                      1 /* No Fit                         */
#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */
};

mask DWORD _DISPLAY_DEVICE
{
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA_COMPATIBLE      0x00000010
#define DISPLAY_DEVICE_REMOVABLE           0x00000020
#define DISPLAY_DEVICE_MODESPRUNED         0x08000000
#define DISPLAY_DEVICE_REMOTE              0x04000000
#define DISPLAY_DEVICE_DISCONNECT          0x02000000
};
mask DWORD _DISPLAY_DEVICE_STATE
{
/* Child device state */
#define DISPLAY_DEVICE_ACTIVE              0x00000001
#define DISPLAY_DEVICE_ATTACHED            0x00000002
};


value DWORD _RDH
{
#define RDH_RECTANGLES  1
};
//  GetGlyphOutline constants

value DWORD _GGO
{
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2
#define GGO_BEZIER         3
#define  GGO_GRAY2_BITMAP   4
#define  GGO_GRAY4_BITMAP   5
#define  GGO_GRAY8_BITMAP   6
#define  GGO_GLYPH_INDEX    0x0080
#define  GGO_UNHINTED       0x0100
};

value DWORD _TT_POLYGON
{
#define TT_POLYGON_TYPE   24
};

value WORD _TT_PRIM
{
#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2
#define TT_PRIM_CSPLINE    3
};

typedef struct tagMETAFILEPICT { 
    LONG      mm; 
    LONG      xExt; 
    LONG      yExt; 
    HMETAFILE hMF; 
} METAFILEPICT, *LPMETAFILEPICT; 


/* Logcolorspace signature */

// #define LCS_SIGNATURE           'PSOC'

/* Logcolorspace lcsType values */

// #define LCS_sRGB                'sRGB'
// #define LCS_WINDOWS_COLOR_SPACE 'Win '  // Windows default color space

typedef LONG   LCSCSTYPE;
value DWORD _LCSCSTYPE
{
#define LCS_CALIBRATED_RGB              0x00000000L
#define LCS_DEVICE_RGB                  0x00000001L
#define LCS_DEVICE_CMYK                 0x00000002L
};

mask DWORD _GCP
{
#define GCP_DBCS           0x0001
#define GCP_REORDER        0x0002
#define GCP_USEKERNING     0x0008
#define GCP_GLYPHSHAPE     0x0010
#define GCP_LIGATE         0x0020
////#define GCP_GLYPHINDEXING  0x0080
#define GCP_DIACRITIC      0x0100
#define GCP_KASHIDA        0x0400
#define GCP_ERROR          0x8000
//#define FLI_MASK           0x103B

#define GCP_JUSTIFY        0x00010000L
////#define GCP_NODIACRITICS   0x00020000L
#define FLI_GLYPHS         0x00040000L
#define GCP_CLASSIN        0x00080000L
#define GCP_MAXEXTENT      0x00100000L
#define GCP_JUSTIFYIN      0x00200000L
#define GCP_DISPLAYZWG      0x00400000L
#define GCP_SYMSWAPOFF      0x00800000L
#define GCP_NUMERICOVERRIDE 0x01000000L
#define GCP_NEUTRALOVERRIDE 0x02000000L
#define GCP_NUMERICSLATIN   0x04000000L
#define GCP_NUMERICSLOCAL   0x08000000L
};
mask DWORD _GCPCLASS
{
#define GCPCLASS_LATIN                  1
#define GCPCLASS_HEBREW                 2
//#define GCPCLASS_ARABIC                 2
#define GCPCLASS_NEUTRAL                3
#define GCPCLASS_LOCALNUMBER            4
#define GCPCLASS_LATINNUMBER            5
#define GCPCLASS_LATINNUMERICTERMINATOR 6
#define GCPCLASS_LATINNUMERICSEPARATOR  7
#define GCPCLASS_NUMERICSEPARATOR       8
#define GCPCLASS_PREBOUNDLTR         0x80
#define GCPCLASS_PREBOUNDRTL         0x40
#define GCPCLASS_POSTBOUNDLTR        0x20
#define GCPCLASS_POSTBOUNDRTL        0x10

#define GCPGLYPH_LINKBEFORE          0x8000
#define GCPGLYPH_LINKAFTER           0x4000
};

typedef LONG    LCSGAMUTMATCH;
value DWORD _LCSGAMUTMATCH
{
#define LCS_GM_BUSINESS                 0x00000001L
#define LCS_GM_GRAPHICS                 0x00000002L
#define LCS_GM_IMAGES                   0x00000004L
#define LCS_GM_ABS_COLORIMETRIC         0x00000008L
};


value UINT _UpdateICMRegKey
{
/* UpdateICMRegKey Constants               */
#define ICM_ADDPROFILE                  1
#define ICM_DELETEPROFILE               2
#define ICM_QUERYPROFILE                3
#define ICM_SETDEFAULTPROFILE           4
#define ICM_REGISTERICMATCHER           5
#define ICM_UNREGISTERICMATCHER         6
#define ICM_QUERYMATCH                  7
};


value DWORD _biCompression
{
/* constants for the biCompression field */
#define BI_RGB        0L
#define BI_RLE8       1L
#define BI_RLE4       2L
#define BI_BITFIELDS  3L
#define BI_JPEG       4L
#define BI_PNG        5L
};

value DWORD _TCI_SRC
{
#define TCI_SRCCHARSET  1
#define TCI_SRCCODEPAGE 2
#define TCI_SRCFONTSIG  3
};


mask WORD _RASTERIZER_STATUS_Flag
{
/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE    0x0001
#define TT_ENABLED      0x0002
};


mask BYTE _PFD
{
/* pixel types */
#define PFD_TYPE_RGBA        0
#define PFD_TYPE_COLORINDEX  1
};

mask BYTE _PFD_LAYER
{
/* layer types */
#define PFD_MAIN_PLANE       0
#define PFD_OVERLAY_PLANE    1
#define PFD_UNDERLAY_PLANE   -1
};
mask DWORD _PIXELFORMATDESCRIPTOR
{
/* PIXELFORMATDESCRIPTOR flags */
#define PFD_DOUBLEBUFFER            0x00000001
#define PFD_STEREO                  0x00000002
#define PFD_DRAW_TO_WINDOW          0x00000004
#define PFD_DRAW_TO_BITMAP          0x00000008
#define PFD_SUPPORT_GDI             0x00000010
#define PFD_SUPPORT_OPENGL          0x00000020
#define PFD_GENERIC_FORMAT          0x00000040
#define PFD_NEED_PALETTE            0x00000080
#define PFD_NEED_SYSTEM_PALETTE     0x00000100
#define PFD_SWAP_EXCHANGE           0x00000200
#define PFD_SWAP_COPY               0x00000400
#define PFD_SWAP_LAYER_BUFFERS      0x00000800
#define PFD_GENERIC_ACCELERATED     0x00001000
#define PFD_SUPPORT_DIRECTDRAW      0x00002000

/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */
#define PFD_DEPTH_DONTCARE          0x20000000
#define PFD_DOUBLEBUFFER_DONTCARE   0x40000000
#define PFD_STEREO_DONTCARE         0x80000000
};



mask DWORD _DeviceMode
{
/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8
};

value DWORD _DC_PRINTRATEUNIT
{
#define   PRINTRATEUNIT_PPM     1
#define   PRINTRATEUNIT_CPS     2
#define   PRINTRATEUNIT_LPM     3
#define   PRINTRATEUNIT_IPM     4
};
mask DWORD _DCTT
{
/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP             0x0000001L
#define DCTT_DOWNLOAD           0x0000002L
#define DCTT_SUBDEV             0x0000004L
#define DCTT_DOWNLOAD_OUTLINE   0x0000008L
};
value DWORD _DCBA
{
/* return values for DC_BINADJUST */
#define DCBA_FACEUPNONE       0x0000
#define DCBA_FACEUPCENTER     0x0001
#define DCBA_FACEUPLEFT       0x0002
#define DCBA_FACEUPRIGHT      0x0003
#define DCBA_FACEDOWNNONE     0x0100
#define DCBA_FACEDOWNCENTER   0x0101
#define DCBA_FACEDOWNLEFT     0x0102
#define DCBA_FACEDOWNRIGHT    0x0103
};

/* flAccel flags for the GLYPHSET structure above */
value DWORD _GS_8BIT_INDICES
{
#define GS_8BIT_INDICES     0x00000001
};

/* flags for GetGlyphIndices */
value DWORD _GGI_MARK_NONEXISTING_GLYPHS
{

#define GGI_MARK_NONEXISTING_GLYPHS  0X0001
};
value DWORD _FR
{

#define FR_PRIVATE     0x10
#define FR_NOT_ENUM    0x20
};
value BYTE _AC_SRC_OVER
{
//
// currentlly defined blend function
//
#define AC_SRC_OVER                 0x00
};
value BYTE _AC_SRC_ALPHA
{
//
// currentlly defined blend function
//
#define AC_SRC_ALPHA                 0x01
};
value ULONG _GRADIENT_FILL
{
//
// gradient drawing modes
//

#define GRADIENT_FILL_RECT_H    0x00000000
#define GRADIENT_FILL_RECT_V    0x00000001
#define GRADIENT_FILL_TRIANGLE  0x00000002
#define GRADIENT_FILL_OP_FLAG   0x000000ff
};
value WORD _COLORADJUSTMENTValue
{

/* Flags value for COLORADJUSTMENT */
#define CA_NEGATIVE                 0x0001
#define CA_LOG_FILTER               0x0002
};
value WORD _IlluminantIndexValue
{

/* IlluminantIndex values */
#define ILLUMINANT_DEVICE_DEFAULT   0
#define ILLUMINANT_A                1
#define ILLUMINANT_B                2
#define ILLUMINANT_C                3
#define ILLUMINANT_D50              4
#define ILLUMINANT_D55              5
#define ILLUMINANT_D65              6
#define ILLUMINANT_D75              7
#define ILLUMINANT_F2               8
};

value DWORD _ICM
{
#define ICM_OFF               1
#define ICM_ON                2
#define ICM_QUERY             3
#define ICM_DONE_OUTSIDEDC    4
};

value DWORD _EMR
{

// Enhanced metafile record types.

#define EMR_HEADER                      1
#define EMR_POLYBEZIER                  2
#define EMR_POLYGON                     3
#define EMR_POLYLINE                    4
#define EMR_POLYBEZIERTO                5
#define EMR_POLYLINETO                  6
#define EMR_POLYPOLYLINE                7
#define EMR_POLYPOLYGON                 8
#define EMR_SETWINDOWEXTEX              9
#define EMR_SETWINDOWORGEX              10
#define EMR_SETVIEWPORTEXTEX            11
#define EMR_SETVIEWPORTORGEX            12
#define EMR_SETBRUSHORGEX               13
#define EMR_EOF                         14
#define EMR_SETPIXELV                   15
#define EMR_SETMAPPERFLAGS              16
#define EMR_SETMAPMODE                  17
#define EMR_SETBKMODE                   18
#define EMR_SETPOLYFILLMODE             19
#define EMR_SETROP2                     20
#define EMR_SETSTRETCHBLTMODE           21
#define EMR_SETTEXTALIGN                22
#define EMR_SETCOLORADJUSTMENT          23
#define EMR_SETTEXTCOLOR                24
#define EMR_SETBKCOLOR                  25
#define EMR_OFFSETCLIPRGN               26
#define EMR_MOVETOEX                    27
#define EMR_SETMETARGN                  28
#define EMR_EXCLUDECLIPRECT             29
#define EMR_INTERSECTCLIPRECT           30
#define EMR_SCALEVIEWPORTEXTEX          31
#define EMR_SCALEWINDOWEXTEX            32
#define EMR_SAVEDC                      33
#define EMR_RESTOREDC                   34
#define EMR_SETWORLDTRANSFORM           35
#define EMR_MODIFYWORLDTRANSFORM        36
#define EMR_SELECTOBJECT                37
#define EMR_CREATEPEN                   38
#define EMR_CREATEBRUSHINDIRECT         39
#define EMR_DELETEOBJECT                40
#define EMR_ANGLEARC                    41
#define EMR_ELLIPSE                     42
#define EMR_RECTANGLE                   43
#define EMR_ROUNDRECT                   44
#define EMR_ARC                         45
#define EMR_CHORD                       46
#define EMR_PIE                         47
#define EMR_SELECTPALETTE               48
#define EMR_CREATEPALETTE               49
#define EMR_SETPALETTEENTRIES           50
#define EMR_RESIZEPALETTE               51
#define EMR_REALIZEPALETTE              52
#define EMR_EXTFLOODFILL                53
#define EMR_LINETO                      54
#define EMR_ARCTO                       55
#define EMR_POLYDRAW                    56
#define EMR_SETARCDIRECTION             57
#define EMR_SETMITERLIMIT               58
#define EMR_BEGINPATH                   59
#define EMR_ENDPATH                     60
#define EMR_CLOSEFIGURE                 61
#define EMR_FILLPATH                    62
#define EMR_STROKEANDFILLPATH           63
#define EMR_STROKEPATH                  64
#define EMR_FLATTENPATH                 65
#define EMR_WIDENPATH                   66
#define EMR_SELECTCLIPPATH              67
#define EMR_ABORTPATH                   68

#define EMR_GDICOMMENT                  70
#define EMR_FILLRGN                     71
#define EMR_FRAMERGN                    72
#define EMR_INVERTRGN                   73
#define EMR_PAINTRGN                    74
#define EMR_EXTSELECTCLIPRGN            75
#define EMR_BITBLT                      76
#define EMR_STRETCHBLT                  77
#define EMR_MASKBLT                     78
#define EMR_PLGBLT                      79
#define EMR_SETDIBITSTODEVICE           80
#define EMR_STRETCHDIBITS               81
#define EMR_EXTCREATEFONTINDIRECTW      82
#define EMR_EXTTEXTOUTA                 83
#define EMR_EXTTEXTOUTW                 84
#define EMR_POLYBEZIER16                85
#define EMR_POLYGON16                   86
#define EMR_POLYLINE16                  87
#define EMR_POLYBEZIERTO16              88
#define EMR_POLYLINETO16                89
#define EMR_POLYPOLYLINE16              90
#define EMR_POLYPOLYGON16               91
#define EMR_POLYDRAW16                  92
#define EMR_CREATEMONOBRUSH             93
#define EMR_CREATEDIBPATTERNBRUSHPT     94
#define EMR_EXTCREATEPEN                95
#define EMR_POLYTEXTOUTA                96
#define EMR_POLYTEXTOUTW                97

#define EMR_SETICMMODE                  98
#define EMR_CREATECOLORSPACE            99
#define EMR_SETCOLORSPACE              100
#define EMR_DELETECOLORSPACE           101
#define EMR_GLSRECORD                  102
#define EMR_GLSBOUNDEDRECORD           103
#define EMR_PIXELFORMAT                104

#define EMR_RESERVED_105               105
#define EMR_RESERVED_106               106
#define EMR_RESERVED_107               107
#define EMR_RESERVED_108               108
#define EMR_RESERVED_109               109
#define EMR_RESERVED_110               110
#define EMR_COLORCORRECTPALETTE        111
#define EMR_SETICMPROFILEA             112
#define EMR_SETICMPROFILEW             113
#define EMR_ALPHABLEND                 114
#define EMR_SETLAYOUT                  115
#define EMR_TRANSPARENTBLT             116
#define EMR_RESERVED_117               117
#define EMR_GRADIENTFILL               118
#define EMR_RESERVED_119               119
#define EMR_RESERVED_120               120
#define EMR_COLORMATCHTOTARGETW        121
#define EMR_CREATECOLORSPACEW          122
};
value DWORD _SETICMPROFILE_EMBEDED
{

#define SETICMPROFILE_EMBEDED           0x00000001
};
value DWORD _GDICOMMENT
{
#define GDICOMMENT_IDENTIFIER           0x43494447
#define GDICOMMENT_WINDOWS_METAFILE     0x80000001
#define GDICOMMENT_BEGINGROUP           0x00000002
#define GDICOMMENT_ENDGROUP             0x00000003
#define GDICOMMENT_MULTIFORMATS         0x40000004
#define GDICOMMENT_UNICODE_STRING       0x00000040
#define GDICOMMENT_UNICODE_END          0x00000080
};

value DWORD _WGL_FONT
{

#define WGL_FONT_LINES      0
#define WGL_FONT_POLYGONS   1
};
value DWORD _LAYERPLANEDESCRIPTOR
{

/* LAYERPLANEDESCRIPTOR flags */
#define LPD_DOUBLEBUFFER        0x00000001
#define LPD_STEREO              0x00000002
#define LPD_SUPPORT_GDI         0x00000010
#define LPD_SUPPORT_OPENGL      0x00000020
#define LPD_SHARE_DEPTH         0x00000040
#define LPD_SHARE_STENCIL       0x00000080
#define LPD_SHARE_ACCUM         0x00000100
#define LPD_SWAP_EXCHANGE       0x00000200
#define LPD_SWAP_COPY           0x00000400
#define LPD_TRANSPARENT         0x00001000
};
value BYTE _LPD_TYPE
{

#define LPD_TYPE_RGBA        0
#define LPD_TYPE_COLORINDEX  1
};
value DWORD _WGL_SWAP
{

/* wglSwapLayerBuffers flags */
#define WGL_SWAP_MAIN_PLANE     0x00000001
#define WGL_SWAP_OVERLAY1       0x00000002
#define WGL_SWAP_OVERLAY2       0x00000004
#define WGL_SWAP_OVERLAY3       0x00000008
#define WGL_SWAP_OVERLAY4       0x00000010
#define WGL_SWAP_OVERLAY5       0x00000020
#define WGL_SWAP_OVERLAY6       0x00000040
#define WGL_SWAP_OVERLAY7       0x00000080
#define WGL_SWAP_OVERLAY8       0x00000100
#define WGL_SWAP_OVERLAY9       0x00000200
#define WGL_SWAP_OVERLAY10      0x00000400
#define WGL_SWAP_OVERLAY11      0x00000800
#define WGL_SWAP_OVERLAY12      0x00001000
#define WGL_SWAP_OVERLAY13      0x00002000
#define WGL_SWAP_OVERLAY14      0x00004000
#define WGL_SWAP_OVERLAY15      0x00008000
#define WGL_SWAP_UNDERLAY1      0x00010000
#define WGL_SWAP_UNDERLAY2      0x00020000
#define WGL_SWAP_UNDERLAY3      0x00040000
#define WGL_SWAP_UNDERLAY4      0x00080000
#define WGL_SWAP_UNDERLAY5      0x00100000
#define WGL_SWAP_UNDERLAY6      0x00200000
#define WGL_SWAP_UNDERLAY7      0x00400000
#define WGL_SWAP_UNDERLAY8      0x00800000
#define WGL_SWAP_UNDERLAY9      0x01000000
#define WGL_SWAP_UNDERLAY10     0x02000000
#define WGL_SWAP_UNDERLAY11     0x04000000
#define WGL_SWAP_UNDERLAY12     0x08000000
#define WGL_SWAP_UNDERLAY13     0x10000000
#define WGL_SWAP_UNDERLAY14     0x20000000
#define WGL_SWAP_UNDERLAY15     0x40000000
};

mask DWORD _otmfsSelection
{
#define Italic          0x00
#define Underscore      0x01
#define Negative        0x02
#define Outline         0x04
#define Strikeout       0x08
#define Bold            0x10
};

value WORD RectangleStyleValue
{
#define BlackRectangle     0
#define WhiteRectangle     1 
#define GrayRectangle      2
};

mask BYTE _TMPF
{
/* tmPitchAndFamily flags */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08
#define TMPF_TRUETYPE       0x04
};

mask DWORD _NTMFlags
{
/* ntmFlags field flags */
#define NTM_REGULAR     0x00000040L
#define NTM_BOLD        0x00000020L
#define NTM_ITALIC      0x00000001L

#define NTM_NONNEGATIVE_AC  0x00010000
#define NTM_PS_OPENTYPE     0x00020000
#define NTM_TT_OPENTYPE     0x00040000
#define NTM_MULTIPLEMASTER  0x00080000
#define NTM_TYPE1           0x00100000
#define NTM_DSIG            0x00200000
};



value BYTE PanFamilyType
{
#define PAN_ANY                         0 /* Any                            */
#define PAN_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */
};
value BYTE PanSerifType
{
#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */
};
value BYTE PanWeightType
{
#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */
};
value BYTE PanPropType
{
#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */
};
value BYTE PanConstrastType
{
#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */
};
value BYTE PanStrokeType
{
#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */
};
value BYTE PanArmsType
{
#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */
};
value BYTE PanLettType
{
#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */
};
value BYTE PanMidlineType
{
#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */
};
value BYTE PanXHeightType
{
#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */
};

value DWORD EMRSignature
{
#define ENHMETA_SIGNATURE       0x464D4520
#define EPS_SIGNATURE                   0x46535045
};

value DWORD EMRColorSpaceFlagMask
{
#define CREATECOLORSPACE_EMBEDED        0x00000001
};

value DWORD EMRColorMatchFlagMask
{
#define COLORMATCHTOTARGET_EMBEDED      0x00000001
};



//==================================================================================
//==================================================================================
//==================================================================================
typedef struct  tagCOLORADJUSTMENT {
  WORD  caSize;
  _COLORADJUSTMENTValue  caFlags;
  _IlluminantIndexValue  caIlluminantIndex;
  WORD  caRedGamma;
  WORD  caGreenGamma;
  WORD  caBlueGamma;
  WORD  caReferenceBlack;
  WORD  caReferenceWhite;
  SHORT caContrast;
  SHORT caBrightness;
  SHORT caColorfulness;
  SHORT caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT,  *LPCOLORADJUSTMENT;

typedef struct _POINTL {
  LONG x;
  LONG y;
} POINTL, *PPOINTL;

typedef struct tagPOINTS {
  SHORT x;
  SHORT y;
} POINTS, *PPOINTS;

typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        RectangleStyleValue wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;

/*
 * Information about output options
 */

typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;

/*
 * Information about custom paper size
 */

typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

/*
 * Header structure for the input buffer to POSTSCRIPT_INJECTION escape
 */

typedef struct _PSINJECTDATA {

    DWORD   DataBytes;          /* number of raw data bytes */
    _PSINJECT   InjectionPoint;     /* injection point */
    WORD   Flags;              /* flags */

    /* Followed by raw data to be injected */

} PSINJECTDATA, *PPSINJECTDATA;


typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM,  *LPXFORM;

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP,  *NPBITMAP,  *LPBITMAP;

typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD * LPRGBQUAD;


typedef long            FXPT16DOT16;
typedef long            *LPFXPT16DOT16;

typedef long            FXPT2DOT30;
typedef long            *LPFXPT2DOT30;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of CIEXYZ.

typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ   *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE     *LPCIEXYZTRIPLE;

// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.


typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    _LCSCSTYPE lcsCSType;
    _LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    _LCSCSTYPE lcsCSType;
    _LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;



/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER,  *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        _biCompression      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER,  *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct tagBITMAPV4HEADER {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        _biCompression        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER,  *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

typedef struct tagBITMAPV5HEADER {
        DWORD        bV5Size;
        LONG         bV5Width;
        LONG         bV5Height;
        WORD         bV5Planes;
        WORD         bV5BitCount;
        _biCompression        bV5Compression;
        DWORD        bV5SizeImage;
        LONG         bV5XPelsPerMeter;
        LONG         bV5YPelsPerMeter;
        DWORD        bV5ClrUsed;
        DWORD        bV5ClrImportant;
        DWORD        bV5RedMask;
        DWORD        bV5GreenMask;
        DWORD        bV5BlueMask;
        DWORD        bV5AlphaMask;
        DWORD        bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD        bV5GammaRed;
        DWORD        bV5GammaGreen;
        DWORD        bV5GammaBlue;
        DWORD        bV5Intent;
        DWORD        bV5ProfileData;
        DWORD        bV5ProfileSize;
        DWORD        bV5Reserved;
} BITMAPV5HEADER,  *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

// Values for bV5CSType
// #define PROFILE_LINKED          'LINK'
// #define PROFILE_EMBEDDED        'MBED'

typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO,  *LPBITMAPINFO, *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO,  *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER,  *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;


typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO,  *NPCHARSETINFO,  *LPCHARSETINFO;

typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;




/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE,  *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD, *PMETARECORD,  *LPMETARECORD;

typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER, *PMETAHEADER,   *LPMETAHEADER;


/* Enhanced Metafile structures */
typedef struct tagENHMETARECORD
{
    DWORD   iType;              // Record type EMR_XXX
    DWORD   nSize;              // Record size in bytes
    DWORD   dParm[1];           // Parameters
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
    DWORD   cbPixelFormat;      // Size of PIXELFORMATDESCRIPTOR information
                                // This is 0 if no pixel format is set
    DWORD   offPixelFormat;     // Offset to PIXELFORMATDESCRIPTOR
                                // This is 0 if no pixel format is set
    DWORD   bOpenGL;            // TRUE if OpenGL commands are present in
                                // the metafile, otherwise FALSE
    SIZEL   szlMicrometers;     // Size of the reference device in micrometers

} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;


//
// BCHAR definition for APPs
//

typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    _TMPF        tmPitchAndFamily;
    _CHARSETBYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA,  *NPTEXTMETRICA,  *LPTEXTMETRICA;

typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    _TMPF        tmPitchAndFamily;
    _CHARSETBYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW,  *NPTEXTMETRICW,  *LPTEXTMETRICW;

typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    _TMPF        tmPitchAndFamily;
    _CHARSETBYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA,  *NPNEWTEXTMETRICA,  *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    _TMPF        tmPitchAndFamily;
    _CHARSETBYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW,  *NPNEWTEXTMETRICW,  *LPNEWTEXTMETRICW;

typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;

/* GDI Logical Objects: */

/* Pel Array */
typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY,  *NPPELARRAY,  *LPPELARRAY;

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    _BrushStyles        lbStyle;
    COLORREF    lbColor;
    _HatchStyle        lbHatch;
  } LOGBRUSH, *PLOGBRUSH,  *NPLOGBRUSH,  *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    _BrushStyles        lbStyle;
    COLORREF    lbColor;
    _HatchStyle       lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32,  *NPLOGBRUSH32,  *LPLOGBRUSH32;

typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN         *NPPATTERN;
typedef PATTERN          *LPPATTERN;

/* Logical Pen */
typedef struct tagLOGPEN
  {
    _PS        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN,  *NPLOGPEN,  *LPLOGPEN;

typedef struct tagEXTLOGPEN {
    _PS       elpPenStyle;
    DWORD       elpWidth;
    _BrushStyles        elpBrushStyle;
    COLORREF    elpColor;
    _HatchStyle        elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN,  *NPEXTLOGPEN,  *LPEXTLOGPEN;

/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE,  *NPLOGPALETTE,  *LPLOGPALETTE;


/* Logical Font */
//#define LF_FACESIZE         32

typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    _FW      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    _CHARSETBYTE      lfCharSet;
    _OUTBYTE      lfOutPrecision;
    _CLIPBYTE      lfClipPrecision;
    _QUALITYBYTE      lfQuality;
    _FFBYTE      lfPitchAndFamily;
    CHAR      lfFaceName[/*LF_FACESIZE*/  32];
} LOGFONTA, *PLOGFONTA,  *NPLOGFONTA,  *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    _FW      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    _CHARSETBYTE      lfCharSet;
    _OUTBYTE      lfOutPrecision;
    _CLIPBYTE      lfClipPrecision;
    _QUALITYBYTE      lfQuality;
    _FFBYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[/*LF_FACESIZE*/ 32];
} LOGFONTW, *PLOGFONTW,  *NPLOGFONTW,  *LPLOGFONTW;

//#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[/*LF_FULLFACESIZE*/ 64];
    BYTE     elfStyle[/*LF_FACESIZE*/ 32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[/*LF_FULLFACESIZE*/ 64];
    WCHAR    elfStyle[/*LF_FACESIZE*/ 32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;

typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[/*LF_FULLFACESIZE*/ 64];
    BYTE        elfStyle[/*LF_FACESIZE*/ 32];
    BYTE        elfScript[/*LF_FACESIZE*/ 32];
} ENUMLOGFONTEXA,  *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[/*LF_FULLFACESIZE*/ 64];
    WCHAR       elfStyle[/*LF_FACESIZE*/ 32];
    WCHAR       elfScript[/*LF_FACESIZE*/ 32];
} ENUMLOGFONTEXW,  *LPENUMLOGFONTEXW;

typedef struct tagPANOSE
{
    PanFamilyType    bFamilyType;
    PanSerifType    bSerifStyle;
    PanWeightType    bWeight;
    PanPropType    bProportion;
    PanConstrastType    bContrast;
    PanStrokeType    bStrokeVariation;
    PanArmsType    bArmStyle;
    PanLettType    bLetterform;
    PanMidlineType    bMidline;
    PanXHeightType    bXHeight;
} PANOSE, * LPPANOSE;

/* The extended logical font       */
/* An extension of the ENUMLOGFONT */

typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[/*LF_FULLFACESIZE*/ 64];
    BYTE        elfStyle[/*LF_FACESIZE*/ 32];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[/*ELF_VENDOR_SIZE*/ 4];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA,  *NPEXTLOGFONTA,  *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[/*LF_FULLFACESIZE*/ 64];
    WCHAR       elfStyle[/*LF_FACESIZE*/ 32];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[/*ELF_VENDOR_SIZE*/ 4];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW,  *NPEXTLOGFONTW,  *LPEXTLOGFONTW;

/* GetRegionData/ExtCreateRegion */

typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC,  *NPABC,  *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT,  *NPABCFLOAT,  *LPABCFLOAT;


typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    _otmfsSelection    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA,  *NPOUTLINETEXTMETRICA,  *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    _otmfsSelection    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW,  *NPOUTLINETEXTMETRICW,  *LPOUTLINETEXTMETRICW;



typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    _ETO      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA,  *NPPOLYTEXTA,  *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    _ETO      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW,  *NPPOLYTEXTW,  *LPPOLYTEXTW;

typedef struct _FIXED {
    WORD    fract;
    WORD   _value;
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2,  *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS,  *LPGLYPHMETRICS;

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    _TT_PRIM    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    _TT_POLYGON   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;


typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    _GCPCLASS *   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    _GCPCLASS *   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;

typedef struct _RASTERIZER_STATUS {
    short   nSize;
    _RASTERIZER_STATUS_Flag   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS,  *LPRASTERIZER_STATUS;

/* Pixel format descriptor */
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    _PIXELFORMATDESCRIPTOR dwFlags;
    _PFD  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    _PFD_LAYER  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR,  *LPPIXELFORMATDESCRIPTOR;

typedef OLDFONTENUMPROCA    FONTENUMPROCA;
typedef OLDFONTENUMPROCW    FONTENUMPROCW;


/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 */
typedef LPVOID OLDFONTENUMPROCA;
typedef LPVOID OLDFONTENUMPROCW;
typedef LPVOID GOBJENUMPROC;
typedef LPVOID LINEDDAPROC;

typedef LPVOID LPFNDEVMODEA;
typedef LPVOID LPFNDEVMODEW;

typedef LPVOID LPFNDEVCAPSA;
typedef LPVOID LPFNDEVCAPSW;

typedef struct tagWCRANGE
{
    WCHAR  wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD    cbThis;
    _GS_8BIT_INDICES    flAccel;
    DWORD    cGlyphsSupported;
    DWORD    cRanges;
    WCRANGE  ranges[1];
} GLYPHSET, *PGLYPHSET,  *LPGLYPHSET;

typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[/*MM_MAX_NUMAXES*/16];
} DESIGNVECTOR, *PDESIGNVECTOR,  *LPDESIGNVECTOR;
// The actual size of the DESIGNVECTOR and ENUMLOGFONTEXDV structures
// is determined by dvNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed

//#define MM_MAX_AXES_NAMELEN 16

typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[/*MM_MAX_NUMAXES*/ 16];
} AXISINFOA, *PAXISINFOA,  *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[/*MM_MAX_NUMAXES*/ 16];
} AXISINFOW, *PAXISINFOW,  *LPAXISINFOW;

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[/*MM_MAX_NUMAXES*/ 16];
} AXESLISTA, *PAXESLISTA,  *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[/*MM_MAX_NUMAXES*/ 16];
} AXESLISTW, *PAXESLISTW,  *LPAXESLISTW;

// The actual size of the AXESLIST and ENUMTEXTMETRIC structure is
// determined by axlNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed

typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA,  *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW,  *LPENUMLOGFONTEXDVW;


typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA,  *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW,  *LPENUMTEXTMETRICW;

//
// image blt
//

typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG    x;
    LONG    y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;

typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;

typedef struct _BLENDFUNCTION
{
    _AC_SRC_OVER   BlendOp;
    BYTE   BlendFlags;
    BYTE   SourceConstantAlpha;
    _AC_SRC_ALPHA   AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;

typedef LPVOID MFENUMPROC;
typedef LPVOID ENHMFENUMPROC;


/* new GDI */

typedef struct tagDIBSECTION {
    BITMAP              dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION,  *LPDIBSECTION, *PDIBSECTION;

typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

typedef LPVOID ICMENUMPROCA;
typedef LPVOID ICMENUMPROCW;

// Base record type for the enhanced metafile.

typedef struct tagEMR
{
    _EMR   iType;              // Enhanced metafile record type
    DWORD   nSize;              // Length of the record in bytes.
                                // This must be a multiple of 4.
} EMR, *PEMR;

// Base text record type for the enhanced metafile.

typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          // Offset to the string
    _ETO   fOptions;
    RECTL   rcl;
    DWORD   offDx;              // Offset to the inter-character spacing array.
                                // This is always given.
} EMRTEXT, *PEMRTEXT;

// Record structures for the enhanced metafile.

typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,
  EMRSETLAYOUT,         *PEMRSETLAYOUT,
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,        *PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          // Specifies a relative instance
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      // Specifies the arc direction in the
                                // advanced graphics mode.
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           // Object handle index
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index, background mode only
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        // Number of palette entries
    DWORD   offPalEntries;      // Offset to the palette entries
    DWORD   nSizeLast;          // Same as nSize and must be the last DWORD
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    _MWT   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    _FLOODFILL   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;

typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;               // Number of points
    POINTL  aptl[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;               // Number of points
    POINTS  apts[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cptl;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTL  aptl[1];            // Array of points
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cpts;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTS  apts[1];            // Array of points
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;


typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    _GM   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    EMRTEXT emrtext;            // This is followed by the string and spacing
                                // array
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    _GM   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    LONG    cStrings;
    EMRTEXT aemrtext[1];        // Array of EMRTEXT structures.  This is
                                // followed by the strings and spacing arrays.
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    _TernaryDrawMode   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    _TernaryDrawMode   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    _TernaryDrawMode   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
    _TernaryDrawMode   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             // Font handle index
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;


typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    LOGPALETTE lgpl;            // The peFlags fields in the palette entries
                                // do not contain any flags
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any
    DWORD   cbBits;             // Size of the brush bitmap bits if any
    EXTLOGPEN elp;              // The extended pen with the style array.
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    LOGBRUSH32 lb;                // The style must be BS_SOLID, BS_HOLLOW,
                                // BS_NULL or BS_HATCHED.
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    EMRSignature   dSignature;         // Format signature, e.g. ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Format version number.
    DWORD   cbData;             // Size of data in bytes.
    DWORD   offData;            // Offset to data from GDICOMMENT_IDENTIFIER.
                                // It must begin at a DWORD offset.
} EMRFORMAT, *PEMRFORMAT;

typedef struct tagEMRGLSRECORD
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;

typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR     emr;
    RECTL   rclBounds;          // Bounds in recording coordinates
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

typedef struct tagEMRPIXELFORMAT
{
    EMR     emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;


typedef struct tagEMRCREATECOLORSPACE
{
    EMR             emr;
    DWORD           ihCS;       // ColorSpace handle index
    LOGCOLORSPACEA  lcs;        // Ansi version of LOGCOLORSPACE
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

typedef struct tagEMRSETCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               // ColorSpace handle index
} EMRSETCOLORSPACE,    *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;


typedef struct tagEMREXTESCAPE
{
    EMR     emr;
    INT     iEscape;            // Escape code
    INT     cbEscData;          // Size of escape data
    BYTE    EscData[1];         // Escape data
} EMREXTESCAPE,  *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;

typedef struct tagEMRNAMEDESCAPE
{
    EMR     emr;
    INT     iEscape;            // Escape code
    INT     cbDriver;           // Size of driver name
    INT     cbEscData;          // Size of escape data
    BYTE    EscData[1];         // Driver name and Escape data
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;


typedef struct tagEMRCREATECOLORSPACEA
{
    EMR             emr;
    DWORD           ihCS;       // ColorSpace handle index
    LOGCOLORSPACEA  lcs;        // Unicode version of logical color space structure
    EMRColorSpaceFlagMask           dwFlags;    // flags
    DWORD           cbData;     // size of raw source profile data if attached
    BYTE            Data[1];    // Array size is cbData
} EMRCREATECOLORSPACEA, *PEMRCREATECOLORSPACEA;

typedef struct tagEMRCREATECOLORSPACEW
{
    EMR             emr;
    DWORD           ihCS;       // ColorSpace handle index
    LOGCOLORSPACEW  lcs;        // Unicode version of logical color space structure
    EMRColorSpaceFlagMask           dwFlags;    // flags
    DWORD           cbData;     // size of raw source profile data if attached
    BYTE            Data[1];    // Array size is cbData
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;

//#define COLORMATCHTOTARGET_EMBEDED      0x00000001

typedef struct tagCOLORMATCHTOTARGET
{
    EMR     emr;
    _CS   dwAction;           // CS_ENABLE, CS_DISABLE or CS_DELETE_TRANSFORM
    EMRColorMatchFlagMask   dwFlags;            // flags
    DWORD   cbName;             // Size of desired target profile name
    DWORD   cbData;             // Size of raw target profile data if attached
    BYTE    Data[1];            // Array size is cbName + cbData
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

typedef struct tagCOLORCORRECTPALETTE
{
    EMR     emr;
    DWORD   ihPalette;          // Palette handle index
    DWORD   nFirstEntry;        // Index of first entry to correct
    DWORD   nPalEntries;        // Number of palette entries to correct
    DWORD   nReserved;          // Reserved
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

typedef struct tagEMRALPHABLEND
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    _TernaryDrawMode   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;

typedef struct tagEMRGRADIENTFILL
{
    EMR       emr;
    RECTL     rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD     nVer;
    DWORD     nTri;
    _GRADIENT_FILL     ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;

typedef struct tagEMRTRANSPARENTBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    _TernaryDrawMode   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    _DIB_Color   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;

typedef struct tagEMRSETICMPROFILE
{
    EMR     emr;
    DWORD   dwFlags;            // flags
    DWORD   cbName;             // Size of desired profile name
    DWORD   cbData;             // Size of raw profile data if attached
    BYTE    Data[1];            // Array size is cbName and cbData
} EMRSETICMPROFILE, *PEMRSETICMPROFILE;

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT,  *LPGLYPHMETRICSFLOAT;

/* Layer plane descriptor */
typedef struct tagLAYERPLANEDESCRIPTOR { // lpd
    WORD  nSize;
    WORD  nVersion;
    _LAYERPLANEDESCRIPTOR dwFlags;
    _LPD_TYPE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    BYTE  bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR,  *LPLAYERPLANEDESCRIPTOR;

typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP,  *LPWGLSWAP;

//=========================================================================================================
//=========================================================================================================
//=========================================================================================================
//=========================================================================================================


IntFailIfZero AddFontResourceA(
    [in] LPCSTR lpszFilename
);
IntFailIfZero AddFontResourceW(
    [in] LPCWSTR lpszFilename
);

FailOnFalse [gle] AnimatePalette(
    [in] HPALETTE hpal,           // handle to logical palette
    [in] UINT iStartIndex,        // first entry in logical palette
    [in] UINT cEntries,           // number of entries
    [in] PALETTEENTRY *ppe  // first replacement
);
FailOnFalse [gle]  Arc(
    [in] HDC hdc,         // handle to device context
    [in] int nLeftRect,   // x-coord of rectangle's upper-left corner
    [in] int nTopRect,    // y-coord of rectangle's upper-left corner
    [in] int nRightRect,  // x-coord of rectangle's lower-right corner
    [in] int nBottomRect, // y-coord of rectangle's lower-right corner
    [in] int nXStartArc,  // x-coord of first radial ending poIN int
    [in] int nYStartArc,  // y-coord of first radial ending poIN int
    [in] int nXEndArc,    // x-coord of second radial ending poIN int
    [in] int nYEndArc     // y-coord of second radial ending poIN int
);
FailOnFalse  [gle] BitBlt(
    [in] HDC hdcDest, // handle to destination DC
    [in] int nXDest,  // x-coord of destination upper-left corner
    [in] int nYDest,  // y-coord of destination upper-left corner
    [in] int nWidth,  // width of destination rectangle
    [in] int nHeight, // height of destination rectangle
    [in] HDC hdcSrc,  // handle to source DC
    [in] int nXSrc,   // x-coordinate of source upper-left corner
    [in] int nYSrc,   // y-coordinate of source upper-left corner
    [in] _TernaryDrawMode dwRop  // raster operation code
);
FailOnFalse [gle]  CancelDC(
    [in] HDC hdc   // handle to DC
);
FailOnFalse  [gle] Chord(
    [in] HDC hdc,         // handle to DC
    [in] int nLeftRect,   // x-coord of upper-left corner of rectangle
    [in] int nTopRect,    // y-coord of upper-left corner of rectangle
    [in] int nRightRect,  // x-coord of lower-right corner of rectangle
    [in] int nBottomRect, // y-coord of lower-right corner of rectangle
    [in] int nXRadial1,   // x-coord of first radial's endpoIN int
    [in] int nYRadial1,   // y-coord of first radial's endpoIN int
    [in] int nXRadial2,   // x-coord of second radial's endpoIN int
    [in] int nYRadial2    // y-coord of second radial's endpoIN int
);
IntFailIfZero  [gle] ChoosePixelFormat(
    [in] HDC  hdc,  // device context to search for a best pixel format
               // match
    [in] PIXELFORMATDESCRIPTOR *  ppfd
               // pixel format for which a best match is sought
);

HMETAFILE  [gle] CloseMetaFile(
    [in] HDC hdc   // handle to Windows-metafile DC
);
_RegionFlags CombineRgn(
    [in] HRGN hrgnDest,      // handle to destination region
    [in] HRGN hrgnSrc1,      // handle to source region
    [in] HRGN hrgnSrc2,      // handle to source region
    [in] _CombineRgn fnCombineMode   // region combining mode
);
HMETAFILE  [gle] CopyMetaFileA(
    [in] HMETAFILE hmfSrc,  // handle to Windows-format metafile
    [in] LPCSTR lpszFile   // file name
);
HMETAFILE  [gle] CopyMetaFileW(
    [in] HMETAFILE hmfSrc,  // handle to Windows-format metafile
    [in] LPCWSTR lpszFile   // file name
);
HBITMAP  [gle] CreateBitmap(
    [in] int nWidth,         // bitmap width, in pixels
    [in] int nHeight,        // bitmap height, in pixels
    [in] UINT cPlanes,       // number of color planes
    [in] UINT cBitsPerPel,   // number of bits to identify color
    [in] VOID *lpvBits // color data array
);
HBITMAP  [gle] CreateBitmapIndirect(
     [in] BITMAP *lpbm    // bitmap data
);
HBRUSH  [gle] CreateBrushIndirect(
     [in] LOGBRUSH *lplb   // brush information
);
HBITMAP  [gle] CreateCompatibleBitmap(
    [in] HDC hdc,        // handle to DC
    [in] int nWidth,     // width of bitmap, in pixels
    [in] int nHeight     // height of bitmap, in pixels
);
HBITMAP  [gle] CreateDiscardableBitmap(
    [in] HDC hdc,     // handle to DC
    [in] int nWidth,  // bitmap width
    [in] int nHeight  // bitmap height
);
HDC  [gle] CreateCompatibleDC(
    [in] HDC hdc   // handle to DC
);
HDC  [gle] CreateDCA(
    [in] LPCSTR lpszDriver,        // driver name
    [in] LPCSTR lpszDevice,        // device name
    [in] LPCSTR lpszOutput,        // not used; should be NULL
    [in] DEVMODEA *lpInitData  // optional prIN inter data
);
HDC  [gle] CreateDCW(
    [in] LPCWSTR lpszDriver,        // driver name
    [in] LPCWSTR lpszDevice,        // device name
    [in] LPCWSTR lpszOutput,        // not used; should be NULL
    [in] DEVMODEW *lpInitData  // optional prIN inter data
);
HBITMAP  [gle] CreateDIBitmap(
    [in] HDC hdc,                        // handle to DC
    [in] BITMAPV5HEADER *lpbmih, // bitmap data
    [in] _CreateDIBitmap fdwInit,                  // initialization option
    [in] VOID *lpbInit,            // initialization data
    [in] BITMAPINFO *lpbmi,        // color-format data
    [in] _DIB_Color fuUsage                    // color-data usage
);

HBRUSH  [gle] CreateDIBPatternBrush(
    [in] HGLOBAL hglbDIBPacked,  // handle to DIB
    [in] _DIB_Color fuColorSpec        // color table data
);

HBRUSH  [gle] CreateDIBPatternBrushPt(
    [in] VOID *lpPackedDIB,  // bitmap bits
    [in] _DIB_Color iUsage               // usage
);
HRGN  [gle] CreateEllipticRgn(
    [in] int nLeftRect,   // x-coord of upper-left corner of rectangle
    [in] int nTopRect,    // y-coord of upper-left corner of rectangle
    [in] int nRightRect,  // x-coord of lower-right corner of rectangle
    [in] int nBottomRect  // y-coord of lower-right corner of rectangle
);
HRGN  [gle] CreateEllipticRgnIndirect(
     [in] RECT *lprc   // bounding rectangle
);
HFONT    [gle]  CreateFontIndirectA(
    [in]  LOGFONTA *lplf
);
HFONT  [gle]   CreateFontIndirectW(
    [in]  LOGFONTW *lplf
);

HFONT  [gle] CreateFontA(
    [in] int nHeight,               // height of font
    [in] int nWidth,                // average character width
    [in] int nEscapement,           // angle of escapement
    [in] int nOrientation,          // base-line orientation angle
    [in] _FW fnWeight,              // font weight
    [in] DWORD fdwItalic,           // italic attribute option
    [in] DWORD fdwUnderline,        // underline attribute option
    [in] DWORD fdwStrikeOut,        // strikeout attribute option
    [in] _CHARSET fdwCharSet,          // character set identifier
    [in] _OUT fdwOutputPrecision,  // output precision
    [in] _CLIP fdwClipPrecision,    // clipping precision
    [in] _OUT fdwQuality,          // output quality
    [in] _FF fdwPitchAndFamily,   // pitch and family
    [in] LPCSTR lpszFace           // typeface name
);

HFONT  [gle] CreateFontW(
    [in] int nHeight,               // height of font
    [in] int nWidth,                // average character width
    [in] int nEscapement,           // angle of escapement
    [in] int nOrientation,          // base-line orientation angle
    [in] _FW fnWeight,              // font weight
    [in] DWORD fdwItalic,           // italic attribute option
    [in] DWORD fdwUnderline,        // underline attribute option
    [in] DWORD fdwStrikeOut,        // strikeout attribute option
    [in] _CHARSET fdwCharSet,          // character set identifier
    [in] _OUT fdwOutputPrecision,  // output precision
    [in] _CLIP fdwClipPrecision,    // clipping precision
    [in] _OUT fdwQuality,          // output quality
    [in] _FF fdwPitchAndFamily,   // pitch and family
    [in] LPCWSTR lpszFace           // typeface name
);

HBRUSH  [gle] CreateHatchBrush(
    [in] int fnStyle,      // hatch style
    [in] COLORREF clrref   // foreground color
);
HDC  [gle] CreateICA(
    [in] LPCSTR lpszDriver,       // driver name
    [in] LPCSTR lpszDevice,       // device name
    [in] LPCSTR lpszOutput,       // port or file name
    [in] DEVMODEA *lpdvmInit  // optional initialization data
);
HDC  [gle] CreateICW(
    [in] LPCWSTR lpszDriver,       // driver name
    [in] LPCWSTR lpszDevice,       // device name
    [in] LPCWSTR lpszOutput,       // port or file name
    [in] DEVMODEW *lpdvmInit  // optional initialization data
);
HDC  [gle] CreateMetaFileA(
    [in] LPCSTR lpszFile
);
HDC  [gle] CreateMetaFileW(
    [in] LPCWSTR lpszFile
);

HPALETTE  [gle]  CreatePalette(
    [in]  LOGPALETTE * lplgpl
);
HPEN  [gle] CreatePen(
    [in] _PS fnPenStyle,    // pen style
    [in] int nWidth,        // pen width
    [in] COLORREF crColor   // pen color
);
HPEN    [gle]   CreatePenIndirect(
    [in]  LOGPEN *lplgpn
);
HRGN CreatePolyPolygonRgn(
    [in] POINT *lppt,        // poIN inter to array of poIN ints
    [in] INT *lpPolyCounts,  // poIN inter to count of vertices
    [in] int nCount,               // number of [in] integers in array
    [in] _PolyFill fnPolyFillMode        // polygon fill mode
);
HBRUSH  [gle] CreatePatternBrush(
    [in] HBITMAP hbmp   // handle to bitmap
);
HRGN CreateRectRgn(
    [in] int nLeftRect,   // x-coordinate of upper-left corner
    [in] int nTopRect,    // y-coordinate of upper-left corner
    [in] int nRightRect,  // x-coordinate of lower-right corner
    [in] int nBottomRect  // y-coordinate of lower-right corner
);
HRGN  [gle] CreateRectRgnIndirect(
    [in] RECT *lprc   // rectangle
);
HRGN  [gle] CreateRoundRectRgn(
    [in] int nLeftRect,      // x-coordinate of upper-left corner
    [in] int nTopRect,       // y-coordinate of upper-left corner
    [in] int nRightRect,     // x-coordinate of lower-right corner
    [in] int nBottomRect,    // y-coordinate of lower-right corner
    [in] int nWidthEllipse,  // height of ellipse
    [in] int nHeightEllipse  // width of ellipse
);
FailOnFalse  [gle] CreateScalableFontResourceA(
    DWORD fdwHidden,          // read-only option
    [in] LPCSTR lpszFontRes,      // font file name
    [in] LPCSTR lpszFontFile,     // scalable font file name
    [in] LPCSTR lpszCurrentPath   // scalable font file path
);
FailOnFalse  [gle] CreateScalableFontResourceW(
    DWORD fdwHidden,          // read-only option
    [in] LPCWSTR lpszFontRes,      // font file name
    [in] LPCWSTR lpszFontFile,     // scalable font file name
    [in] LPCWSTR lpszCurrentPath   // scalable font file path
);
HBRUSH  [gle] CreateSolidBrush(
    [in] COLORREF crColor   // brush color value
);

FailOnFalse  [gle]  DeleteDC(
    [in] HDC hdc
);
FailOnFalse  [gle]  DeleteMetaFile(
    [in] HMETAFILE hmf
);
FailOnFalse   [gle] DeleteObject(
    [in] HGDIOBJ hobj
);

IntFailIfZero  [gle] DescribePixelFormat(
    [in] HDC  hdc,           // device context of interest
    [in] int  iPixelFormat,  // pixel format selector
    [in] UINT  nBytes,       // size of buffer pointed to by ppfd
    [out] LPPIXELFORMATDESCRIPTOR  ppfd
                        // pointer to structure to receive pixel
                        // format data
);

SpoolerError [gle]  DrawEscape(
	[in] HDC hdc,            // handle to DC
	[in] int nEscape,        // escape function
	[in] int cbInput,        // size of structure for input
	[in] LPCSTR lpszInData   // structure for input
);
FailOnFalse  [gle] Ellipse(
	[in] HDC hdc,        // handle to DC
	[in] int nLeftRect,  // x-coord of upper-left corner of rectangle
	[in] int nTopRect,   // y-coord of upper-left corner of rectangle
	[in] int nRightRect, // x-coord of lower-right corner of rectangle
	[in] int nBottomRect // y-coord of lower-right corner of rectangle
);

int EnumFontFamiliesExA(
	[in] HDC hdc,                          // handle to DC
	[in] LPLOGFONTA lpLogfont,              // font information
	[in] FONTENUMPROCA lpEnumFontFamExProc, // callback function
	[in] LPARAM lParam,                    // additional data
	[in] DWORD dwFlags                     // not used; must be 0
);
int EnumFontFamiliesExW(
	[in] HDC hdc,                          // handle to DC
	[in] LPLOGFONTW lpLogfont,              // font information
	[in] FONTENUMPROCW lpEnumFontFamExProc, // callback function
	[in] LPARAM lParam,                    // additional data
	[in] DWORD dwFlags                     // not used; must be 0
);
int EnumFontFamiliesA(
	[in] HDC hdc,                        // handle to DC
	[in] LPCSTR lpszFamily,             // font family
	[in] FONTENUMPROCA lpEnumFontFamProc, // callback function
	[in] LPARAM lParam                   // additional data
);
int EnumFontFamiliesW(
	[in] HDC hdc,                        // handle to DC
	[in] LPCWSTR lpszFamily,             // font family
	[in] FONTENUMPROCW lpEnumFontFamProc, // callback function
	[in] LPARAM lParam                   // additional data
);

int EnumFontsA(
	[in] HDC hdc,                  // handle to DC
	[in] LPCSTR lpFaceName,       // font typeface name
	[in] FONTENUMPROCA lpFontFunc,  // callback function
	[in] LPARAM lParam             // application-supplied data
);
int EnumFontsW(
	[in] HDC hdc,                  // handle to DC
	[in] LPCWSTR lpFaceName,       // font typeface name
	[in] FONTENUMPROCW lpFontFunc,  // callback function
	[in] LPARAM lParam             // application-supplied data
);

int EnumObjects(
	[in] HDC hdc,                    // handle to DC
	[in] int nObjectType,            // object-type identifier
	[in] GOBJENUMPROC lpObjectFunc,  // callback function
	[in] LPARAM lParam               // application-supplied data
);


FailOnFalse EqualRgn(
	[in] HRGN hSrcRgn1,  // handle to first region
	[in] HRGN hSrcRgn2   // handle to second region
);
_RegionFlags ExcludeClipRect(
	[in] HDC hdc,         // handle to DC
	[in] int nLeftRect,   // x-coord of upper-left corner
	[in] int nTopRect,    // y-coord of upper-left corner
	[in] int nRightRect,  // x-coord of lower-right corner
	[in] int nBottomRect  // y-coord of lower-right corner
);
HRGN  [gle] ExtCreateRegion(
	[in] XFORM *lpXform,     // transformation data
	[in] DWORD nCount,             // size of region data
	[in] RGNDATA *lpRgnData  // region data buffer
);

FailOnFalse  [gle] ExtFloodFill(
	[in] HDC hdc,          // handle to DC
	[in] int nXStart,      // starting x-coordinate
	[in] int nYStart,      // starting y-coordinate
	[in] COLORREF crColor, // fill color
	[in] _FLOODFILL fuFillType   // fill type
);
FailOnFalse  [gle] FillRgn(
	[in] HDC hdc,    // handle to device context
	[in] HRGN hrgn,  // handle to region to be filled
	[in] HBRUSH hbr  // handle to brush used to fill the region
);

FailOnFalse  [gle] FloodFill(
	[in] HDC hdc,          // handle to DC
	[in] int nXStart,      // starting x-coordinate
	[in] int nYStart,      // starting y-coordinate
	[in] COLORREF crFill   // fill color
);
FailOnFalse  [gle] FrameRgn(
	[in] HDC hdc,     // handle to device context
	[in] HRGN hrgn,   // handle to region to be framed
	[in] HBRUSH hbr,  // handle to brush used to draw border
	[in] int nWidth,  // width of region frame
	[in] int nHeight  // height of region frame
);
_BinaryDrawMode [gle]  GetROP2(
	[in] HDC hdc   // handle to device context
);
FailOnFalse  [gle] GetAspectRatioFilterEx(
	[in] HDC hdc,               // handle to DC
	[out] LPSIZE lpAspectRatio   // aspect-ratio filter
);
COLORREF_RETURN GetBkColor(
    HDC hdc
);

COLORREF_RETURN GetDCBrushColor(
    HDC hdc
);
COLORREF_RETURN GetDCPenColor(
    HDC hdc
);

IntFailIfZero    GetBkMode(
	[in] HDC hdc
);
LONG [gle]  GetBitmapBits(
	[in] HBITMAP hbmp,      // handle to bitmap
	[in] LONG cbBuffer,     // number of bytes to copy
	[out] LPVOID lpvBits     // buffer to receive bits
);

FailOnFalse [gle]  GetBitmapDimensionEx(
	[in] HBITMAP hBitmap,     // handle to bitmap
	[out] LPSIZE lpDimension   // dimensions
);

_DCB GetBoundsRect(
	[in] HDC hdc,            // handle to device context
	[out] LPRECT lprcBounds,  // bounding rectangle
	[in] _DCB flags          // function options
);

FailOnFalse  [gle] GetBrushOrgEx(
	[in] HDC hdc,       // handle to DC
	[out] LPPOINT lppt   // coordinates of origin
);

FailOnFalse  [gle] GetCharWidthA(
	[in] HDC hdc,         // handle to DC
	[in] UINT iFirstChar, // first character in range
	[in] UINT iLastChar,  // last character in range
	[in] LPINT lpBuffer   // buffer for widths
);
FailOnFalse  [gle] GetCharWidthW(
	[in] HDC hdc,         // handle to DC
	[in] UINT iFirstChar, // first character in range
	[in] UINT iLastChar,  // last character in range
	[out] LPINT lpBuffer   // buffer for widths
);

FailOnFalse  [gle] GetCharWidth32A(
	[in] HDC hdc,          // handle to DC
	[in] UINT iFirstChar,  // first character in range
	[in] UINT iLastChar,   // last character in range
	[out] LPINT lpBuffer    // buffer for widths
);
FailOnFalse [gle]  GetCharWidth32W(
	[in] HDC hdc,          // handle to DC
	[in] UINT iFirstChar,  // first character in range
	[in] UINT iLastChar,   // last character in range
	[out] LPINT lpBuffer    // buffer for widths
);
FailOnFalse [gle]  GetCharWidthFloatA(
	[in] HDC hdc,          // handle to DC
	[in] UINT iFirstChar,  // first-character code point
	[in] UINT iLastChar,   // last-character code point
	[out] PFLOAT pxBuffer   // buffer for widths
);
FailOnFalse [gle]  GetCharWidthFloatW(
	[in] HDC hdc,          // handle to DC
	[in] UINT iFirstChar,  // first-character code point
	[in] UINT iLastChar,   // last-character code point
	[out] PFLOAT pxBuffer   // buffer for widths
);
FailOnFalse [gle]  GetCharABCWidthsA(
	[in] HDC hdc,         // handle to DC
	[in] UINT uFirstChar, // first character in range
	[in] UINT uLastChar,  // last character in range
	[out] LPABC lpabc      // array of character widths
);
FailOnFalse [gle]  GetCharABCWidthsW(
	[in] HDC hdc,         // handle to DC
	[in] UINT uFirstChar, // first character in range
	[in] UINT uLastChar,  // last character in range
	[out] LPABC lpabc      // array of character widths
);
FailOnFalse  [gle] GetCharABCWidthsFloatA(
	[in] HDC hdc,            // handle to DC
	[in] UINT iFirstChar,    // first character in range
	[in] UINT iLastChar,     // last character in range
	[out] LPABCFLOAT lpABCF   // array of character widths
);
FailOnFalse  [gle] GetCharABCWidthsFloatW(
	[in] HDC hdc,            // handle to DC
	[in] UINT iFirstChar,    // first character in range
	[in] UINT iLastChar,     // last character in range
	[out] LPABCFLOAT lpABCF   // array of character widths
);
_RegionFlags  [gle] GetClipBox(
	[in] HDC hdc,      // handle to DC
	[out] LPRECT lprc   // rectangle
);
IntFailIfNeg1  [gle] GetClipRgn(
	[in] HDC hdc,           // handle to DC
	[in] HRGN hrgn          // handle to region
);
IntFailIfZero  [gle] GetMetaRgn(
	[in] HDC hdc,    // handle to DC
	[in] HRGN hrgn   // handle to region
);
HGDIOBJ  [gle] GetCurrentObject(
	[in] HDC hdc,           // handle to DC
	[in] _OBJ uObjectType   // object type
);
FailOnFalse  [gle] GetCurrentPositionEx(
	[in] HDC hdc,        // handle to device context
	[out] LPPOINT lpPoint // current position
);
int GetDeviceCaps(
	[in] HDC hdc,     // handle to DC
	[in] _DeviceParameters nIndex   // index of capability
);

IntFailIfZero GetDIBits(
	[in] HDC hdc,           // handle to DC
	[in] HBITMAP hbmp,      // handle to bitmap
	[in] UINT uStartScan,   // first scan line to set
	[in] UINT cScanLines,   // number of scan lines to copy
	[out] LPVOID lpvBits,    // array for bitmap bits
	      LPBITMAPINFO lpbi, // bitmap data buffer
	[in] _DIB_Color uUsage        // RGB or palette index
);
_GDI_ERROR  [gle] GetFontData(
	[in] HDC hdc,           // handle to DC
	[in] DWORD dwTable,     // metric table name
	[in] DWORD dwOffset,    // offset into table
	[in] LPVOID lpvBuffer,  // buffer for returned data
	[in] DWORD cbData       // length of data
);

DWORD  [gle] GetGlyphOutlineA(
	[in] HDC hdc,             // handle to DC
	[in] UINT uChar,          // character to query
	[in] _GGO uFormat,        // data format
	[out] LPGLYPHMETRICS lpgm, // glyph metrics
	[in] DWORD cbBuffer,      // size of data buffer
	[out] LPVOID lpvBuffer,    // data buffer
	[in] MAT2 *lpmat2   // transformation matrix
);
DWORD  [gle] GetGlyphOutlineW(
	[in] HDC hdc,             // handle to DC
	[in] UINT uChar,          // character to query
	[in] _GGO uFormat,        // data format
	[out] LPGLYPHMETRICS lpgm, // glyph metrics
	[in] DWORD cbBuffer,      // size of data buffer
	[out] LPVOID lpvBuffer,    // data buffer
	[in] MAT2 *lpmat2   // transformation matrix
);

_GM    [gle]  GetGraphicsMode(
    [in] HDC hdc
);
_MM  [gle] GetMapMode(
	[in] HDC hdc   // handle to device context
);

UintFailIfZero  [gle] GetMetaFileBitsEx(
    [in] HMETAFILE hmf,
    [in] UINT nSize,
    [out] LPVOID lpvData
);

HMETAFILE    GetMetaFileA(
    [in] LPCSTR lpszMetaFile
);
HMETAFILE    GetMetaFileW(
    [in] LPCWSTR lpszMetaFile
);
COLORREF_RETURN  [gle] GetNearestColor(
	[in] HDC hdc,           // handle to DC
	[in] COLORREF crColor   // color to be matched
);

COLORREF_RETURN [gle] GetNearestPaletteIndex(
	[in] HPALETTE hpal,     // handle to logical palette
	[in] COLORREF crColor   // color to be matched
);

_OBJ  [gle] GetObjectType(
	[in] HGDIOBJ h   // handle to graphics object
);

UintFailIfZero [gle]  GetOutlineTextMetricsA(
	[in] HDC hdc,                    // handle to DC
	[in] UINT cbData,                // size of metric data array
	[out] LPOUTLINETEXTMETRICA lpOTM   // metric data array
);
UintFailIfZero [gle]  GetOutlineTextMetricsW(
	[in] HDC hdc,                    // handle to DC
	[in] UINT cbData,                // size of metric data array
	[out] LPOUTLINETEXTMETRICW lpOTM   // metric data array
);

UintFailIfZero [gle]  GetPaletteEntries(
	[in] HPALETTE hpal,        // handle to logical palette
	[in] UINT iStartIndex,     // first entry to retrieve
	[in] UINT nEntries,        // number of entries to retrieve
	[out] LPPALETTEENTRY lppe   // array that receives entries
);
COLORREF_RETURN GetPixel(
	[in] HDC hdc,    // handle to DC
	[in] int nXPos,  // x-coordinate of pixel
	[in] int nYPos   // y-coordinate of pixel
);

IntFailIfZero  [gle] GetPixelFormat(
    HDC hdc
);

_PolyFill  [gle] GetPolyFillMode(
	[in] HDC hdc   // handle to device context
);

FailOnFalse  [gle]  GetRasterizerCaps(
	[out] LPRASTERIZER_STATUS lprs ,
	[in]  UINT cb
);
IntFailIfNeg1   GetRandomRgn (
	[in]  HDC hdc ,
	[in] HRGN hrgn,
	[in]  INT iNum
);

IntFailIfZero GetRegionData(
	[in] HRGN hRgn,            // handle to region
	[in] DWORD dwCount,        // size of region data buffer
	[out] LPRGNDATA lpRgnData   // region data buffer
);
_RegionFlags GetRgnBox(
	[in] HRGN hrgn,   // handle to a region
	[out] LPRECT lprc  // bounding rectangle
);
HGDIOBJ  [gle] GetStockObject(
	[in] _StockObject fnObject   // stock object type
);
IntFailIfZero  [gle] GetStretchBltMode(
	[in] HDC hdc   // handle to DC
);

UINT  [gle] GetSystemPaletteEntries(
	[in] HDC hdc,              // handle to DC
	[in] UINT iStartIndex,     // first entry to be retrieved
	[in] UINT nEntries,        // number of entries to be retrieved
	[out] LPPALETTEENTRY lppe   // array that receives entries
);

_SYSPAL  [gle] GetSystemPaletteUse(
	[in] HDC hdc   // handle to DC
);

_ODD_FAILURE  [gle] GetTextCharacterExtra(
	[in] HDC hdc   // handle to DC
);
_TextAlignmentOptions  [gle] GetTextAlign(
	[in] HDC hdc   // handle to DC
);
COLORREF_RETURN GetTextColor(
    HDC hdc
);

FailOnFalse  [gle] GetTextExtentPointA(
	[in] HDC hdc,           // handle to DC
	[in] LPCSTR lpString,  // text string
	[in] int cbString,      // number of characters in string
	[out] LPSIZE lpSize      // string size
);
FailOnFalse  [gle] GetTextExtentPointW(
	[in] HDC hdc,           // handle to DC
	[in] LPCWSTR lpString,  // text string
	[in] int cbString,      // number of characters in string
	[out] LPSIZE lpSize      // string size
);

FailOnFalse  [gle] GetTextExtentPoint32A(
	[in] HDC hdc,           // handle to DC
	[in] LPCSTR lpString,  // text string
	[in] int cbString,      // characters in string
	[out] LPSIZE lpSize      // string size
);
FailOnFalse  [gle] GetTextExtentPoint32W(
	[in] HDC hdc,           // handle to DC
	[in] LPCWSTR lpString,  // text string
	[in] int cbString,      // characters in string
	[out] LPSIZE lpSize      // string size
);

FailOnFalse  [gle] GetTextExtentExPointA(
	[in] HDC hdc,         // handle to DC
	[in] LPCSTR lpszStr, // character string
	[in] int cchString,   // number of characters
	[in] int nMaxExtent,  // maximum width of formatted string
	[out] LPINT lpnFit,    // maximum number of characters
	[out] LPINT alpDx,     // array of partial string widths
	[out] LPSIZE lpSize    // string dimensions
);
FailOnFalse  [gle] GetTextExtentExPointW(
	[in] HDC hdc,         // handle to DC
	[in] LPCWSTR lpszStr, // character string
	[in] int cchString,   // number of characters
	[in] int nMaxExtent,  // maximum width of formatted string
	[out] LPINT lpnFit,    // maximum number of characters
	[out] LPINT alpDx,     // array of partial string widths
	[out] LPSIZE lpSize    // string dimensions
);
_CHARSET GetTextCharset(
	[in] HDC hdc  // handle to DC
);

_CHARSET GetTextCharsetInfo(
	[in] HDC hdc,                // handle to DC
	[out] LPFONTSIGNATURE lpSig,  // data buffer
	[in] DWORD dwFlags           // reserved; must be zero
);
FailOnFalse  [gle] TranslateCharsetInfo(
	[out] DWORD *lpSrc,        // information
	[out] LPCHARSETINFO lpCs,  // character set information
	[in] _TCI_SRC dwFlags        // translation option
);

_GCP  [gle] GetFontLanguageInfo(
	[in] HDC hdc  // handle to DC
);
IntFailIfZero  [gle] GetCharacterPlacementA(
	[in] HDC hdc,                  // handle to DC
	[in] LPCSTR lpString,         // character string
	[in] int nCount,               // number of characters
	[in] int nMaxExtent,           // maximum extent for string
	     LPGCP_RESULTSA lpResults,  // placement result
	[in] _GCP dwFlags             // placement options
);
IntFailIfZero  [gle] GetCharacterPlacementW(
	[in] HDC hdc,                  // handle to DC
	[in] LPCWSTR lpString,         // character string
	[in] int nCount,               // number of characters
	[in] int nMaxExtent,           // maximum extent for string
	     LPGCP_RESULTSW lpResults,  // placement result
	[in] _GCP dwFlags             // placement options
);


IntFailIfZero GetFontUnicodeRanges(
	[in] HDC hdc,         // handle to DC
	[out] LPGLYPHSET lpgs  // glyph set
);
DwordFailIfZero  [gle] GetGlyphIndicesA(
	[in] HDC hdc,       // handle to DC
	[in] LPCSTR lpstr, // string to convert
	[in] int c,         // number of characters in string
	[out] LPWORD pgi,    // array of glyph indices
	[in] _GGI_MARK_NONEXISTING_GLYPHS fl       // glyph options
);
DwordFailIfZero  [gle] GetGlyphIndicesW(
	[in] HDC hdc,       // handle to DC
	[in] LPCWSTR lpstr, // string to convert
	[in] int c,         // number of characters in string
	[out] LPWORD pgi,    // array of glyph indices
	[in] _GGI_MARK_NONEXISTING_GLYPHS fl       // glyph options
);
FailOnFalse  [gle] GetTextExtentPointI(
	[in] HDC hdc,           // handle to DC
	[in] LPWORD pgiIn,      // glyph indices
	[in] int cgi,           // number of indices in array
	[out] LPSIZE lpSize      // string size
);
FailOnFalse  [gle] GetTextExtentExPointI(
	[in] HDC hdc,         // handle to DC
	[in] LPWORD pgiIn,    // array of glyph indices
	[in] int cgi,         // number of glyphs in array
	[in] int nMaxExtent,  // maximum width of formatted string
	[out] LPINT lpnFit,    // maximum number of characters
	[out] LPINT alpDx,     // array of partial string widths
	[out] LPSIZE lpSize    // string dimensions
);
FailOnFalse  [gle] GetCharWidthI(
	[in] HDC hdc,         // handle to DC
	[in] UINT giFirst,    // first glyph index in range
	[in] UINT cgi,        // number of glyph indicies in range
	[in] LPWORD pgi,      // array of glyph indices
	[out] LPINT lpBuffer   // buffer for widths
);
FailOnFalse  [gle] GetCharABCWidthsI(
	[in] HDC hdc,         // handle to DC
	[in] UINT giFirst,    // first glyph index in range
	[in] UINT cgi,        // count of glyph indices in range
	[in] LPWORD pgi,      // array of glyph indices
	[out] LPABC lpabc      // array of character widths
);


IntFailIfZero AddFontResourceExA(
	[in] LPCSTR lpszFilename, // font file name
	[in] _FR fl,             // font characteristics
	[in] DESIGNVECTOR * pdv             // reserved
);

IntFailIfZero AddFontResourceExW(
	[in] LPCWSTR lpszFilename, // font file name
	[in] _FR fl,             // font characteristics
	[in] DESIGNVECTOR * pdv             // reserved
);

FailOnFalse RemoveFontResourceExA(
	[in] LPCSTR lpFileName,  // name of font file
	[in] _FR fl,            // font characteristics
	[in] DESIGNVECTOR * pdv             // reserved
);
FailOnFalse RemoveFontResourceExW(
	[in] LPCWSTR lpFileName,  // name of font file
	[in] _FR fl,            // font characteristics
	[in] DESIGNVECTOR * pdv             // reserved
);
HANDLE AddFontMemResourceEx(
	[in] PVOID pbFont,       // font resource
	[in] DWORD cbFont,       // number of bytes in font resource
	[in] PVOID pdv,          // Reserved. Must be 0.
	[in] DWORD *pcFonts      // number of fonts installed
);

FailOnFalse RemoveFontMemResourceEx(
	[in] HANDLE fh   // handle to the font resource
);


HFONT CreateFontIndirectExA(
	[in] ENUMLOGFONTEXDVA *penumlfex   // characteristiccs
);

HFONT CreateFontIndirectExW(
	[in] ENUMLOGFONTEXDVW *penumlfex   // characteristiccs
);


FailOnFalse  [gle] GetViewportExtEx(
	[in] HDC hdc,      // handle to device context
	[out] LPSIZE lpSize // viewport dimensions
);
FailOnFalse  [gle] GetViewportOrgEx(
	[in] HDC hdc,        // handle to device context
	[out] LPPOINT lpPoint // viewport origin
);
FailOnFalse  [gle] GetWindowExtEx(
	[in] HDC hdc,        // handle to device context
	[out] LPSIZE lpSize   // window extents
);
FailOnFalse  [gle] GetWindowOrgEx(
	[in] HDC hdc,         // handle to device context
	[out] LPPOINT lpPoint  // window origin
);
_RegionFlags IntersectClipRect(
	[in] HDC hdc,         // handle to DC
	[in] int nLeftRect,   // x-coord of upper-left corner
	[in] int nTopRect,    // y-coord of upper-left corner
	[in] int nRightRect,  // x-coord of lower-right corner
	[in] int nBottomRect  // y-coord of lower-right corner
);
FailOnFalse  [gle] InvertRgn(
	[in] HDC hdc,    // handle to device context
	[in] HRGN hrgn   // handle to region to be inverted
);

FailOnFalse  [gle] LineDDA(
	[in] int nXStart,             // x-coordinate of starting point
	[in] int nYStart,             // y-coordinate of starting point
	[in] int nXEnd,               // x-coordinate of ending point
	[in] int nYEnd,               // y-coordinate of ending point
	[in] LINEDDAPROC lpLineFunc,  // callback function
	[in] LPARAM lpData            // application-defined data
);
FailOnFalse  [gle] LineTo(
	[in] HDC hdc,    // device context handle
	[in] int nXEnd,  // x-coordinate of ending point
	[in] int nYEnd   // y-coordinate of ending point
);
FailOnFalse  [gle] MaskBlt(
	[in] HDC hdcDest,     // handle to destination DC
	[in] int nXDest,      // x-coord of destination upper-left corner
	[in] int nYDest,      // y-coord of destination upper-left corner
	[in] int nWidth,      // width of source and destination
	[in] int nHeight,     // height of source and destination
	[in] HDC hdcSrc,      // handle to source DC
	[in] int nXSrc,       // x-coord of upper-left corner of source
	[in] int nYSrc,       // y-coord of upper-left corner of source
	[in] HBITMAP hbmMask, // handle to monochrome bit mask
	[in] int xMask,       // horizontal offset into mask bitmap
	[in] int yMask,       // vertical offset into mask bitmap
	[in] _TernaryDrawMode dwRop      // raster operation code
);
FailOnFalse   [gle] PlgBlt(
	[in] HDC hdcDest,          // handle to destination DC
	[in] POINT *lpPoint, // destination vertices
	[in] HDC hdcSrc,           // handle to source DC
	[in] int nXSrc,            // x-coord of source upper-left corner
	[in] int nYSrc,            // y-coord of source upper-left corner
	[in] int nWidth,           // width of source rectangle
	[in] int nHeight,          // height of source rectangle
	[in] HBITMAP hbmMask,      // handle to bitmask
	[in] int xMask,            // x-coord of bitmask upper-left corner
	[in] int yMask             // y-coord of bitmask upper-left corner
);
_RegionFlags OffsetClipRgn(
	[in] HDC hdc,       // handle to DC
	[in] int nXOffset,  // offset along x-axis
	[in] int nYOffset   // offset along y-axis
);
_RegionFlags OffsetRgn(
	[in] HRGN hrgn,     // handle to region
	[in] int nXOffset,  // offset along x-axis
	[in] int nYOffset   // offset along y-axis
);
FailOnFalse   [gle] PatBlt(
	[in] HDC hdc,      // handle to DC
	[in] int nXLeft,   // x-coord of upper-left rectangle corner
	[in] int nYLeft,   // y-coord of upper-left rectangle corner
	[in] int nWidth,   // width of rectangle
	[in] int nHeight,  // height of rectangle
	[in] _TernaryDrawMode dwRop   // raster operation code
);
FailOnFalse   [gle] Pie(
	[in] HDC hdc,         // handle to DC
	[in] int nLeftRect,   // x-coord of upper-left corner of rectangle
	[in] int nTopRect,    // y-coord of upper-left corner of rectangle
	[in] int nRightRect,  // x-coord of lower-right corner of rectangle
	[in] int nBottomRect, // y-coord of lower-right corner of rectangle
	[in] int nXRadial1,   // x-coord of first radial's endpoint
	[in] int nYRadial1,   // y-coord of first radial's endpoint
	[in] int nXRadial2,   // x-coord of second radial's endpoint
	[in] int nYRadial2    // y-coord of second radial's endpoint
);
FailOnFalse   [gle] PlayMetaFile(
	[in] HDC hdc,        // handle to DC
	[in] HMETAFILE hmf   // handle to metafile
);
FailOnFalse  PaintRgn(
	[in] HDC hdc,    // handle to device context
	[in] HRGN hrgn   // handle to region to be painted
);


FailOnFalse   [gle] PolyPolygon(
	[in] HDC hdc,                  // handle to DC
	[in] POINT *lpPoints,    // array of vertices
	[in] INT *lpPolyCounts,  // array of count of vertices
	[in] int nCount                // count of polygons
);
BOOL  PtInRegion(
	[in] HRGN hrgn,  // handle to region
	[in] int X,      // x-coordinate of point
	[in] int Y       // y-coordinate of point
);
BOOL  PtVisible(
	[in] HDC hdc,  // handle to DC
	[in] int X,    // x-coordinate of point
	[in] int Y     // y-coordinate of point
);

BOOL  RectInRegion(
	[in] HRGN hrgn,         // handle to region
	[in] RECT *lprc   // pointer to rectangle
);
BOOL  RectVisible(
	[in] HDC hdc,           // handle to DC
	[in] RECT *lprc   // rectangle
);
FailOnFalse   [gle] Rectangle(
	[in] HDC hdc,         // handle to DC
	[in] int nLeftRect,   // x-coord of upper-left corner of rectangle
	[in] int nTopRect,    // y-coord of upper-left corner of rectangle
	[in] int nRightRect,  // x-coord of lower-right corner of rectangle
	[in] int nBottomRect  // y-coord of lower-right corner of rectangle
);

FailOnFalse   [gle] RestoreDC(
	[in] HDC hdc,       // handle to DC
	[in] int nSavedDC   // restore state
);
HDC  [gle]  ResetDCA(
	[in] HDC hdc,
	[in] DEVMODEA *lpInitData
);
HDC  [gle]  ResetDCW(
	[in] HDC hdc,
	[in] DEVMODEW *lpInitData
);

_GDI_ERROR [gle] RealizePalette(
	[in] HDC hdc   // handle to DC
);
FailOnFalse   [gle] RemoveFontResourceA(
	[in] LPCSTR lpFileName
);
FailOnFalse   [gle] RemoveFontResourceW(
	[in] LPCWSTR lpFileName
);
FailOnFalse   [gle] RoundRect(
	[in] HDC hdc,         // handle to DC
	[in] int nLeftRect,   // x-coord of upper-left corner of rectangle
	[in] int nTopRect,    // y-coord of upper-left corner of rectangle
	[in] int nRightRect,  // x-coord of lower-right corner of rectangle
	[in] int nBottomRect, // y-coord of lower-right corner of rectangle
	[in] int nWidth,      // width of ellipse
	[in] int nHeight      // height of ellipse
);

FailOnFalse   [gle] ResizePalette(
	[in] HPALETTE hpal, // handle to logical palette
	[in] UINT nEntries  // number of entries in logical palette
);

IntFailIfZero  [gle] SaveDC(
	[in] HDC hdc   // handle to DC
);
_RegionFlags  [gle] SelectClipRgn(
	[in] HDC hdc,    // handle to DC
	[in] HRGN hrgn   // handle to region
);
_RegionFlags  [gle] ExtSelectClipRgn(
	[in] HDC hdc,          // handle to DC
	[in] HRGN hrgn,        // handle to region
	[in] _CombineRgn fnMode        // region-selection mode
);
_RegionFlags   SetMetaRgn(
    HDC hdc
);

HGDIOBJ SelectObject(
	[in] HDC hdc,          // handle to DC
	[in] HGDIOBJ hgdiobj   // handle to object
);

HPALETTE  [gle] SelectPalette(
	[in] HDC hdc,                // handle to DC
	[in] HPALETTE hpal,          // handle to logical palette
	[in] BOOL bForceBackground   // foreground or background mode
);
COLORREF_RETURN   [gle] SetBkColor(
	[in] HDC hdc,           // handle to DC
	[in] COLORREF crColor   // background color value
);

COLORREF_RETURN  SetDCBrushColor(
	[in] HDC hdc,          // handle to DC
	[in] COLORREF crColor  // new brush color
);
COLORREF_RETURN  SetDCPenColor(
	[in] HDC hdc,          // handle to DC
	[in] COLORREF crColor  // new pen color
);

IntFailIfZero    [gle]  SetBkMode(
	[in] HDC hdc,      // handle to DC
	[in] int iBkMode   // background mode
);
LongFailIfZero  [gle] SetBitmapBits(
	[in] HBITMAP hbmp,        // handle to bitmap
	[in] DWORD cBytes,        // number of bytes in bitmap array
	[in] VOID *lpBits   // array with bitmap bits
);
_DCB  [gle] SetBoundsRect(
	[in] HDC hdc,                 // handle to DC
	[in] RECT *lprcBounds,  // bounding rectangle
	[in] _DCB flags               // rectangle combination option
);

IntFailIfZero  [gle] SetDIBits(
	[in] HDC hdc,                  // handle to DC
	[in] HBITMAP hbmp,             // handle to bitmap
	[in] UINT uStartScan,          // starting scan line
	[in] UINT cScanLines,          // number of scan lines
	[in] VOID *lpvBits,      // array of bitmap bits
	[in] BITMAPINFO *lpbmi,  // bitmap data
	[in] _DIB_Color fuColorUse           // type of color indexes to use
);

IntFailIfZero  [gle] SetDIBitsToDevice(
	[in] HDC hdc,                 // handle to DC
	[in] int XDest,               // x-coord of destination upper-left corner
	[in] int YDest,               // y-coord of destination upper-left corner
	[in] DWORD dwWidth,           // source rectangle width
	[in] DWORD dwHeight,          // source rectangle height
	[in] int XSrc,                // x-coord of source lower-left corner
	[in] int YSrc,                // y-coord of source lower-left corner
	[in] UINT uStartScan,         // first scan line in array
	[in] UINT cScanLines,         // number of scan lines
	[in] VOID *lpvBits,     // array of DIB bits
	[in] BITMAPINFO *lpbmi, // bitmap information
	[in] _DIB_Color fuColorUse          // RGB or palette indexes
);

_GDI_ERROR  [gle] SetMapperFlags(
	[in] HDC hdc,       // handle to DC
	[in] DWORD dwFlag   // font-mapper option
);
IntFailIfZero  [gle] SetGraphicsMode(
	[in] HDC hdc,    // handle to device context
	[in] _GM iMode   // graphics mode
);

IntFailIfZero  [gle] SetMapMode(
	[in] HDC hdc,        // handle to device context
	[in] _MM fnMapMode   // new mapping mode
);

_GDI_ERROR  [gle] SetLayout(
	[in] HDC hdc,
	[in] _LAYOUT dwLayout
);
_GDI_ERROR  [gle] GetLayout(
	[in] HDC hdc
);

HMETAFILE  [gle] SetMetaFileBitsEx(
	[in] UINT nSize,          // size of Windows-format metafile
	[in] BYTE *lpData   // metafile data
);

UintFailIfZero  [gle] SetPaletteEntries(
	[in] HPALETTE hpal,             // handle to logical palette
	[in] UINT iStart,               // index of first entry to set
	[in] UINT cEntries,             // number of entries to set
	[in] PALETTEENTRY *lppe   // array of palette entries
);

COLORREF_RETURN   [gle] SetPixel(
	[in] HDC hdc,           // handle to DC
	[in] int X,             // x-coordinate of pixel
	[in] int Y,             // y-coordinate of pixel
	[in] COLORREF crColor   // pixel color
);

FailOnFalse    [gle]  SetPixelV(
	[in] HDC hdc,           // handle to device context
	[in] int X,             // x-coordinate of pixel
	[in] int Y,             // y-coordinate of pixel
	[in] COLORREF crColor   // new pixel color
);

FailOnFalse  [gle]  SetPixelFormat(
	[in] HDC  hdc,  // device context whose pixel format the function
	                // attempts to set
	[in] int  iPixelFormat,
	                // pixel format index (one-based)
	[in] PIXELFORMATDESCRIPTOR *  ppfd
	              // pointer to logical pixel format specification
);

FailOnFalse  [gle] SetPolyFillMode(
	[in] HDC hdc,            // handle to device context
	[in] _PolyFill iPolyFillMode   // polygon fill mode
);
FailOnFalse  [gle] StretchBlt(
	[in] HDC hdcDest,      // handle to destination DC
	[in] int nXOriginDest, // x-coord of destination upper-left corner
	[in] int nYOriginDest, // y-coord of destination upper-left corner
	[in] int nWidthDest,   // width of destination rectangle
	[in] int nHeightDest,  // height of destination rectangle
	[in] HDC hdcSrc,       // handle to source DC
	[in] int nXOriginSrc,  // x-coord of source upper-left corner
	[in] int nYOriginSrc,  // y-coord of source upper-left corner
	[in] int nWidthSrc,    // width of source rectangle
	[in] int nHeightSrc,   // height of source rectangle
	[in] _TernaryDrawMode dwRop       // raster operation code
);


FailOnFalse   [gle]   SetRectRgn(
	[in] HRGN hrgn,       // handle to region
	[in] int nLeftRect,   // x-coordinate of upper-left corner of rectangle
	[in] int nTopRect,    // y-coordinate of upper-left corner of rectangle
	[in] int nRightRect,  // x-coordinate of lower-right corner of rectangle
	[in] int nBottomRect  // y-coordinate of lower-right corner of rectangle
);

_GDI_ERROR [gle]  StretchDIBits(
	[in] HDC hdc,                      // handle to DC
	[in] int XDest,                    // x-coord of destination upper-left corner
	[in] int YDest,                    // y-coord of destination upper-left corner
	[in] int nDestWidth,               // width of destination rectangle
	[in] int nDestHeight,              // height of destination rectangle
	[in] int XSrc,                     // x-coord of source upper-left corner
	[in] int YSrc,                     // y-coord of source upper-left corner
	[in] int nSrcWidth,                // width of source rectangle
	[in] int nSrcHeight,               // height of source rectangle
	[in] VOID *lpBits,           // bitmap bits
	[in] BITMAPINFO *lpBitsInfo, // bitmap data
	[in] _DIB_Color iUsage,                  // usage options
	[in] _TernaryDrawMode dwRop                   // raster operation code
);

IntFailIfZero  [gle] SetROP2(
	[in] HDC hdc,         // handle to DC
	[in] _BinaryDrawMode fnDrawMode   // drawing mode
);
IntFailIfZero  [gle] SetStretchBltMode(
	[in] HDC hdc,           // handle to DC
	[in] _COMBINRGN_STYLE iStretchMode   // bitmap stretching mode
);

_SYSPAL  [gle] SetSystemPaletteUse(
	[in] HDC hdc,      // handle to DC
	[in] _SYSPAL uUsage   // palette usage
);

_ODD_FAILURE  [gle] SetTextCharacterExtra(
	[in] HDC hdc,         // handle to DC
	[in] int nCharExtra   // extra-space value
);

COLORREF_RETURN  [gle]  SetTextColor(
	[in] HDC hdc,           // handle to DC
	[in] COLORREF crColor   // text color
);

UINT  [gle] SetTextAlign(
	[in] HDC hdc,     // handle to DC
	[in] _TextAlignmentOptions fMode   // text-alignment option
);

FailOnFalse  [gle]   SetTextJustification(
	[in] HDC hdc,          // handle to DC
	[in] int nBreakExtra,  // length of extra space
	[in] int nBreakCount   // count of space characters
);
FailOnFalse   [gle]  UpdateColors(
	[in] HDC hdc   // handle to DC
);

module MSIMG32.DLL:
FailOnFalse   [gle]  AlphaBlend(
	[in] HDC hdcDest,                 // handle to destination DC
	[in] int nXOriginDest,            // x-coord of upper-left corner
	[in] int nYOriginDest,            // y-coord of upper-left corner
	[in] int nWidthDest,              // destination width
	[in] int nHeightDest,             // destination height
	[in] HDC hdcSrc,                  // handle to source DC
	[in] int nXOriginSrc,             // x-coord of upper-left corner
	[in] int nYOriginSrc,             // y-coord of upper-left corner
	[in] int nWidthSrc,               // source width
	[in] int nHeightSrc,              // source height
	[in] BLENDFUNCTION blendFunction  // alpha-blending function
);

FailOnFalse   [gle]  TransparentBlt(
	[in] HDC hdcDest,        // handle to destination DC
	[in] int nXOriginDest,   // x-coord of destination upper-left corner
	[in] int nYOriginDest,   // y-coord of destination upper-left corner
	[in] int nWidthDest,     // width of destination rectangle
	[in] int hHeightDest,    // height of destination rectangle
	[in] HDC hdcSrc,         // handle to source DC
	[in] int nXOriginSrc,    // x-coord of source upper-left corner
	[in] int nYOriginSrc,    // y-coord of source upper-left corner
	[in] int nWidthSrc,      // width of source rectangle
	[in] int nHeightSrc,     // height of source rectangle
	[in] UINT crTransparent  // color to make transparent
);


FailOnFalse  [gle] GradientFill(
	[in] HDC hdc,                   // handle to DC
	[in] PTRIVERTEX pVertex,        // array of vertices
	[in] ULONG dwNumVertex,         // number of vertices
	[in] PVOID pMesh,               // array of gradients
	[in] ULONG dwNumMesh,           // size of gradient array
	[in] _GRADIENT_FILL dwMode               // gradient fill mode
);

module GDI32.DLL:
FailOnFalse   [gle]  PlayMetaFileRecord(
	[in] HDC hdc,                      // handle to DC
	[in] LPHANDLETABLE lpHandletable,  // metafile handle table
	[in] LPMETARECORD lpMetaRecord,    // metafile record
	[in] UINT nHandles                 // count of handles
);

FailOnFalse    [gle] EnumMetaFile(
	[in] HDC hdc,                // handle to DC
	[in] HMETAFILE hmf,          // handle to Windows-format metafile
	[in] MFENUMPROC lpMetaFunc,  // callback function
	[in] LPARAM lParam           // optional data
);

// Enhanced Metafile Function Declarations

HENHMETAFILE  [gle]  CloseEnhMetaFile(
	[in] HDC hdc   // handle to enhanced-metafile DC
);
HENHMETAFILE  [gle] CopyEnhMetaFileA(
	[in] HENHMETAFILE hemfSrc,  // handle to enhanced metafile
	[in] LPCSTR lpszFile       // file name
);
HENHMETAFILE  [gle] CopyEnhMetaFileW(
	[in] HENHMETAFILE hemfSrc,  // handle to enhanced metafile
	[in] LPCWSTR lpszFile       // file name
);

HDC  [gle] CreateEnhMetaFileA(
	[in] HDC hdcRef,            // handle to reference DC
	[in] LPCSTR lpFilename,    // file name
	[in] RECT *lpRect,    // bounding rectangle
	[in] LPCSTR lpDescription  // description string
);
HDC  [gle] CreateEnhMetaFileW(
	[in] HDC hdcRef,            // handle to reference DC
	[in] LPCWSTR lpFilename,    // file name
	[in] RECT *lpRect,    // bounding rectangle
	[in] LPCWSTR lpDescription  // description string
);

FailOnFalse   [gle] DeleteEnhMetaFile(
	[in] HENHMETAFILE hemf   // handle to an enhanced metafile
);
FailOnFalse    [gle] EnumEnhMetaFile(
	[in] HDC hdc,                     // handle to DC
	[in] HENHMETAFILE hemf,           // handle to enhanced metafile
	[in] ENHMFENUMPROC lpEnhMetaFunc, // callback function
	[in] LPVOID lpData,               // callback-function data
	[in] RECT *lpRect           // bounding rectangle
);
HENHMETAFILE  [gle] GetEnhMetaFileA(
	[in] LPCSTR lpszMetaFile   // file name
);
HENHMETAFILE  [gle] GetEnhMetaFileW(
	[in] LPCWSTR lpszMetaFile   // file name
);
UintFailIfZero   [gle]  GetEnhMetaFileBits(
	[in] HENHMETAFILE hemf, // handle to metafile
	[in] UINT cbBuffer,     // size of data buffer
	[out] LPBYTE lpbBuffer   // data buffer
);
UintFailIfZero  [gle]  GetEnhMetaFileDescriptionA(
	[in] HENHMETAFILE hemf,       // handle to enhanced metafile
	[in] UINT cchBuffer,          // size of text buffer
	[out] LPSTR lpszDescription   // text buffer
);
UintFailIfZero  [gle]  GetEnhMetaFileDescriptionW(
	[in] HENHMETAFILE hemf,       // handle to enhanced metafile
	[in] UINT cchBuffer,          // size of text buffer
	[out] LPWSTR lpszDescription   // text buffer
);
UintFailIfZero   [gle]  GetEnhMetaFileHeader(
	[in] HENHMETAFILE hemf,      // handle to enhanced metafile
	[in] UINT cbBuffer,          // size of buffer
	[out] LPENHMETAHEADER lpemh   // data buffer
);

UintFailIfZero  [gle]   GetEnhMetaFilePaletteEntries(
	[in] HENHMETAFILE hemf,    // handle to enhanced metafile
	[in] UINT cEntries,        // count of palette entries
	[out] LPPALETTEENTRY lppe   // array of palette entries
);

UintFailIfZero  [gle]   GetEnhMetaFilePixelFormat(
	[in] HENHMETAFILE  hemf, // handle to an enhanced metafile
	[in] DWORD cbBuffer,  // buffer size
	[out] PIXELFORMATDESCRIPTOR *  ppfd
	                    // pointer to logical pixel format specification
);

UintFailIfZero  [gle]   GetWinMetaFileBits(
	[in] HENHMETAFILE hemf, // handle to the enhanced metafile
	[in] UINT cbBuffer,     // buffer size
	[out] LPBYTE lpbBuffer,  // records buffer
	[in] INT fnMapMode,     // mapping mode
	[in] HDC hdcRef         // handle to reference DC
);
FailOnFalse   [gle]  PlayEnhMetaFile(
	[in] HDC hdc,            // handle to DC
	[in] HENHMETAFILE hemf,  // handle to an enhanced metafile
	[in] RECT *lpRect  // bounding rectangle
);

FailOnFalse  [gle]   PlayEnhMetaFileRecord(
	[in] HDC hdc,                              // handle to DC
	[in] LPHANDLETABLE lpHandletable,          // metafile handle table
	[in] ENHMETARECORD *lpEnhMetaRecord, // metafile record
	[in] UINT nHandles                         // count of handles
);

HENHMETAFILE  [gle]  SetEnhMetaFileBits(
	[in] UINT cbBuffer,      // buffer size
	[in] BYTE *lpData  // enhanced metafile data buffer
);


HENHMETAFILE  [gle] SetWinMetaFileBits(
	[in] UINT cbBuffer,              // size of buffer
	[in] BYTE *lpbBuffer,      // metafile data buffer
	[in] HDC hdcRef,                 // handle to reference DC
	[in] METAFILEPICT *lpmfp   // size of metafile picture
);
FailOnFalse   [gle]  GdiComment(
	[in] HDC hdc,             // handle to a device context
	[in] UINT cbSize,         // size of text buffer
	[in] BYTE *lpData   // text buffer
);

FailOnFalse  [gle]  GetTextMetricsA(
	[in] HDC hdc,            // handle to DC
	[out] LPTEXTMETRICA lptm   // text metrics
);
FailOnFalse  [gle]  GetTextMetricsW(
	[in] HDC hdc,            // handle to DC
	[out] LPTEXTMETRICW lptm   // text metrics
);

FailOnFalse  [gle]  AngleArc(
	[in] HDC hdc,            // handle to device context
	[in] int X,              // x-coordinate of circle's center
	[in] int Y,              // y-coordinate of circle's center
	[in] DWORD dwRadius,     // circle's radius
	[in] FLOAT eStartAngle,  // arc's start angle
	[in] FLOAT eSweepAngle   // arc's sweep angle
);
FailOnFalse  [gle]  PolyPolyline(
	[in] HDC hdc,                      // handle to device context
	[in] POINT *lppt,            // array of points
	[in] DWORD *lpdwPolyPoints,  // array of values
	[in] DWORD cCount                  // number of entries in values array
);
FailOnFalse  [gle]  GetWorldTransform(
	[in] HDC hdc,         // handle to device context
	[out] LPXFORM lpXform  // transformation
);
FailOnFalse  [gle]  SetWorldTransform(
	[in] HDC hdc,               // handle to device context
	[in] XFORM *lpXform   // transformation data
);
FailOnFalse  [gle]  ModifyWorldTransform(
	[in] HDC hdc,               // handle to device context
	[in] XFORM *lpXform,  // transformation data
	[in] DWORD iMode            // modification mode
);
FailOnFalse  [gle]  CombineTransform(
	[out] LPXFORM lpxformResult,  // combined transformation
	[in] XFORM *lpxform1,  // first transformation
	[in] XFORM *lpxform2   // second transformation
);
HBITMAP  [gle] CreateDIBSection(
	[in] HDC hdc,                 // handle to DC
	[in] BITMAPINFO *pbmi,  // bitmap data
	[in] UINT iUsage,             // data type indicator
	[out] VOID **ppvBits,          // bit values
	[in] HANDLE hSection,         // handle to file mapping object
	[in] DWORD dwOffset           // offset to bitmap bit values
);
UintFailIfZero  [gle] GetDIBColorTable(
	[in] HDC hdc,           // handle to DC
	[in] UINT uStartIndex,  // color table index of first entry
	[in] UINT cEntries,     // number of entries to retrieve
	[out] RGBQUAD *pColors   // array of color table entries
);
UintFailIfZero  [gle]  SetDIBColorTable(
	[in] HDC hdc,               // handle to DC
	[in] UINT uStartIndex,      // color table index of first entry
	[in] UINT cEntries,         // number of color table entries
	[in] RGBQUAD *pColors // array of color table entries
);

FailOnFalse  [gle]  SetColorAdjustment(
	[in] HDC hdc,                     // handle to DC
	[in] COLORADJUSTMENT *lpca  // color adjustment values
);
FailOnFalse  [gle]  GetColorAdjustment(
	[in] HDC hdc,                 // handle to DC
	[out] LPCOLORADJUSTMENT lpca   // color adjustment values
);

HPALETTE  [gle] CreateHalftonePalette(
	[in] HDC hdc   // handle to DC
);

FailOnFalse   [gle] AbortPath(
	[in] HDC hdc   // handle to DC
);
FailOnFalse   [gle] ArcTo(
	[in] HDC hdc,          // handle to device context
	[in] int nLeftRect,    // x-coord of rectangle's upper-left corner
	[in] int nTopRect,     // y-coord of rectangle's upper-left corner
	[in] int nRightRect,   // x-coord of rectangle's lower-right corner
	[in] int nBottomRect,  // y-coord of rectangle's lower-right corner
	[in] int nXRadial1,    // x-coord of first radial ending point
	[in] int nYRadial1,    // y-coord of first radial ending point
	[in] int nXRadial2,    // x-coord of second radial ending point
	[in] int nYRadial2     // y-coord of second radial ending point
);
FailOnFalse  [gle]  BeginPath(
	[in] HDC hdc   // handle to DC
);
FailOnFalse  [gle]  CloseFigure(
	[in] HDC hdc   // handle to DC
);
FailOnFalse   [gle] EndPath(
	[in] HDC hdc   // handle to DC
);
FailOnFalse  [gle]  FillPath(
	[in] HDC hdc   // handle to DC
);
FailOnFalse   [gle] FlattenPath(
	[in] HDC hdc   // handle to DC
);
IntFailIfNeg1   [gle]  GetPath(
	[in] HDC hdc,           // handle to DC
	[out] LPPOINT lpPoints,  // path vertices
	[out] _PT * lpTypes,    // array of path vertex types
	[in] int nSize          // count of points defining path
);
HRGN  [gle] PathToRegion(
	[in] HDC hdc   // handle to DC
);

FailOnFalse  [gle]  PolyDraw(
	[in] HDC hdc,               // handle to device context
	[in] POINT *lppt,     // array of points
	[in] _PT *lpbTypes,  // line and curve identifiers
	[in] int cCount             // count of points
);
FailOnFalse   [gle] SelectClipPath(
	[in] HDC hdc,    // handle to DC
	[in] _CombineRgn iMode   // clipping mode
);
IntFailIfZero  [gle] SetArcDirection(
	[in] HDC hdc,           // handle to device context
	[in] _AD ArcDirection   // new arc direction
);

FailOnFalse [gle] SetMiterLimit(
	[in] HDC hdc,            // handle to DC
	[in] FLOAT eNewLimit,    // new miter limit
	[out] PFLOAT peOldLimit   // previous miter limit
);
FailOnFalse [gle] StrokeAndFillPath(
	[in] HDC hdc   // handle to DC
);
FailOnFalse [gle] StrokePath(
	[in] HDC hdc   // handle to DC
);
FailOnFalse [gle] WidenPath(
	[in] HDC hdc   // handle to DC
);
HPEN  [gle] ExtCreatePen(
	[in] _PS dwPenStyle,      // pen style
	[in] DWORD dwWidth,         // pen width
	[in] LOGBRUSH *lplb,  // brush attributes
	[in] DWORD dwStyleCount,    // length of custom style array
	[in] DWORD *lpStyle   // custom style array
);

FailOnFalse  [gle]  GetMiterLimit(
	[in] HDC hdc,         // handle to DC
	[out] PFLOAT peLimit   // miter limit
);
_AD   GetArcDirection(
	[in] HDC hdc   // handle to device context
);

IntFailIfZero     [gle] GetObjectA(
	[in] HGDIOBJ hgdiobj,  // handle to graphics object
	[in] int cbBuffer,     // size of buffer for object information
	[out] LPVOID lpvObject  // buffer for object information
);
IntFailIfZero   [gle]  GetObjectW(
	[in] HGDIOBJ hgdiobj,  // handle to graphics object
	[in] int cbBuffer,     // size of buffer for object information
	[out] LPVOID lpvObject  // buffer for object information
);
FailOnFalse   [gle]  MoveToEx(
	[in] HDC hdc,          // handle to device context
	[in] int X,            // x-coordinate of new current position
	[in] int Y,            // y-coordinate of new current position
	[out] LPPOINT lpPoint   // old current position
);
FailOnFalse   [gle]  TextOutA(
	[in] HDC hdc,           // handle to DC
	[in] int nXStart,       // x-coordinate of starting position
	[in] int nYStart,       // y-coordinate of starting position
	[in] LPCSTR lpString,  // character string
	[in] int cbString       // number of characters
);
FailOnFalse   [gle]  TextOutW(
	[in] HDC hdc,           // handle to DC
	[in] int nXStart,       // x-coordinate of starting position
	[in] int nYStart,       // y-coordinate of starting position
	[in] LPCWSTR lpString,  // character string
	[in] int cbString       // number of characters
);
FailOnFalse   [gle]  ExtTextOutA(
	[in] HDC hdc,          // handle to DC
	[in] int X,            // x-coordinate of reference point
	[in] int Y,            // y-coordinate of reference point
	[in] _ETO fuOptions,   // text-output options
	[in] RECT *lprc, // optional dimensions
	[in] LPCSTR lpString, // string
	[in] UINT cbCount,     // number of characters in string
	[in] INT *lpDx   // array of spacing values
);

FailOnFalse   [gle]  ExtTextOutW(
	[in] HDC hdc,          // handle to DC
	[in] int X,            // x-coordinate of reference point
	[in] int Y,            // y-coordinate of reference point
	[in] _ETO fuOptions,   // text-output options
	[in] RECT *lprc, // optional dimensions
	[in] LPCWSTR lpString, // string
	[in] UINT cbCount,     // number of characters in string
	[in] INT *lpDx   // array of spacing values
);

FailOnFalse   [gle]  PolyTextOutA(
	[in] HDC hdc,                // handle to DC
	[in] POLYTEXTA *pptxt,  // array of strings
	[in] int cStrings            // number of strings in array
);
FailOnFalse   [gle]  PolyTextOutW(
	[in] HDC hdc,                // handle to DC
	[in] POLYTEXTW *pptxt,  // array of strings
	[in] int cStrings            // number of strings in array
);

HRGN  [gle] CreatePolygonRgn(
	[in] POINT *lppt,  // array of points
	[in] int cPoints,        // number of points in array
	[in] _PolyFill fnPolyFillMode  // polygon-filling mode
);
FailOnFalse   [gle]  DPtoLP(
	[in] HDC hdc,           // handle to device context
	     LPPOINT lpPoints,  // array of points
	[in] int nCount         // count of points in array
);
FailOnFalse   [gle]  LPtoDP(
	[in] HDC hdc,           // handle to device context
	     LPPOINT lpPoints,  // array of points
	[in] int nCount         // count of points in array
);
FailOnFalse   [gle]  Polygon(
	[in] HDC hdc,                // handle to DC
	[in] POINT *lpPoints,  // polygon vertices
	[in] int nCount              // count of polygon vertices
);
FailOnFalse   [gle]  Polyline(
	[in] HDC hdc,            // handle to device context
	[in] POINT *lppt,  // array of endpoints
	[in] int cPoints         // number of points in array
);

FailOnFalse   [gle]  PolyBezier(
	[in] HDC hdc,            // handle to device context
	[in] POINT *lppt,  // endpoints and control points
	[in] DWORD cPoints       // count of endpoints and control points
);
FailOnFalse  [gle]   PolyBezierTo(
	[in] HDC hdc,            // handle to device context
	[in] POINT *lppt,  // endpoints and control points
	[in] DWORD cCount        // count of endpoints and control points
);
FailOnFalse   PolylineTo(
	[in] HDC hdc,            // handle to device context
	[in] POINT *lppt,  // array of points
	[in] DWORD cCount        // number of points in array
);

FailOnFalse  [gle]   SetViewportExtEx(
	[in] HDC hdc,       // handle to device context
	[in] int nXExtent,  // new horizontal viewport extent
	[in] int nYExtent,  // new vertical viewport extent
	[out] LPSIZE lpSize  // original viewport extent
);
FailOnFalse  [gle]   SetViewportOrgEx(
	[in] HDC hdc,        // handle to device context
	[in] int X,          // new x-coordinate of viewport origin
	[in] int Y,          // new y-coordinate of viewport origin
	[out] LPPOINT lpPoint // original viewport origin
);
FailOnFalse  [gle]   SetWindowExtEx(
	[in] HDC hdc,       // handle to device context
	[in] int nXExtent,  // new horizontal window extent
	[in] int nYExtent,  // new vertical window extent
	[out] LPSIZE lpSize  // original window extent
);
FailOnFalse  [gle]   SetWindowOrgEx(
	[in] HDC hdc,        // handle to device context
	[in] int X,          // new x-coordinate of window origin
	[in] int Y,          // new y-coordinate of window origin
	[out] LPPOINT lpPoint // original window origin
);

FailOnFalse  [gle]   OffsetViewportOrgEx(
	[in] HDC hdc,         // handle to device context
	[in] int nXOffset,    // horizontal offset
	[in] int nYOffset,    // vertical offset
	[out] LPPOINT lpPoint  // original origin
);
FailOnFalse   [gle]  OffsetWindowOrgEx(
	[in] HDC hdc,          // handle to device context
	[in] int nXOffset,     // horizontal offset
	[in] int nYOffset,     // vertical offset
	[out] LPPOINT lpPoint   // original origin
);
FailOnFalse  [gle]   ScaleViewportExtEx(
	[in] HDC hdc,        // handle to device context
	[in] int Xnum,       // horizontal multiplicand
	[in] int Xdenom,     // horizontal divisor
	[in] int Ynum,       // vertical multiplicand
	[in] int Ydenom,     // vertical divisor
	[out] LPSIZE lpSize   // previous viewport extents
);
FailOnFalse  [gle]   ScaleWindowExtEx(
	[in] HDC hdc,        // handle to device context
	[in] int Xnum,       // horizontal multiplicand
	[in] int Xdenom,     // horizontal divisor
	[in] int Ynum,       // vertical multiplicand
	[in] int Ydenom,     // vertical divisor
	[out] LPSIZE lpSize   // previous window extents
);
FailOnFalse   [gle]  SetBitmapDimensionEx(
	[in] HBITMAP hBitmap,  // handle to bitmap
	[in] int nWidth,       // bitmap width in .01-mm units
	[in] int nHeight,      // bitmap height in .01-mm units
	[out] LPSIZE lpSize     // original dimensions
);
FailOnFalse   [gle]  SetBrushOrgEx(
	[in] HDC hdc,       // handle to device context
	[in] int nXOrg,     // x-coord of new origin
	[in] int nYOrg,     // y-coord of new origin
	[out] LPPOINT lppt   // points to previous brush origin
);

IntFailIfZero  [gle] GetTextFaceA(
	[in] HDC hdc,            // handle to DC
	[in] int nCount,         // length of typeface name buffer
	[out] LPSTR lpFaceName   // typeface name buffer
);
IntFailIfZero [gle]  GetTextFaceW(
	[in] HDC hdc,            // handle to DC
	[in] int nCount,         // length of typeface name buffer
	[out] LPWSTR lpFaceName   // typeface name buffer
);

DwordFailIfZero  [gle]  GetKerningPairsA(
	[in] HDC hdc,                 // handle to DC
	[in] DWORD nNumPairs,         // number of kerning pairs
	[out] LPKERNINGPAIR lpkrnpair  // array of kerning pairs
);
DwordFailIfZero  [gle]  GetKerningPairsW(
	[in] HDC hdc,                 // handle to DC
	[in] DWORD nNumPairs,         // number of kerning pairs
	[out] LPKERNINGPAIR lpkrnpair  // array of kerning pairs
);
FailOnFalse   [gle]  GetDCOrgEx(
	[in] HDC hdc,          // handle to a DC
	[out] LPPOINT lpPoint   // translation origin
);
FailOnFalse  [gle]   FixBrushOrgEx(
    HDC hdc,
    int arg1,
    int arg2,
    LPPOINT point
);
FailOnFalse   [gle]  UnrealizeObject(
	[in] HGDIOBJ hgdiobj   // handle to logical palette
);

FailOnFalse   GdiFlush();

DwordFailIfZero   [gle] GdiSetBatchLimit(
	[in] DWORD dwLimit   // batch limit
);

DwordFailIfZero [gle]  GdiGetBatchLimit();


IntFailIfZero SetICMMode(
	[in] HDC hDC,
	[in] _ICM iEnableICM
);

FailOnFalse  CheckColorsInGamut(
	[in] HDC hDC,              // device context handle
	[in] LPVOID lpRGBTriples,  // array of RGB triples
	[out] LPVOID lpBuffer,      // buffer for results
	[in] UINT nCount           // number of triples
);

HCOLORSPACE  GetColorSpace(
	[in] HDC hDC
);
FailOnFalse         GetLogColorSpaceA(
	[in] HCOLORSPACE hColorSpace,
	[out] LPLOGCOLORSPACEA lpBuffer,
	[in] DWORD nSize
);
FailOnFalse         GetLogColorSpaceW(
	[in] HCOLORSPACE hColorSpace,
	[out] LPLOGCOLORSPACEW lpBuffer,
	[in] DWORD nSize
);
HCOLORSPACE  CreateColorSpaceA(
	[in] LPLOGCOLORSPACEA lpLogColorSpace
);
HCOLORSPACE  CreateColorSpaceW(
	[in] LPLOGCOLORSPACEW lpLogColorSpace
);
HCOLORSPACE  SetColorSpace(
	[in] HDC hDC,
	[in] HCOLORSPACE hColorSpace
);

FailOnFalse         DeleteColorSpace(
	[in] HCOLORSPACE hColorSpace
);
FailOnFalse         GetICMProfileA(
	[in] HDC hDC,
	[out] LPDWORD lpcbName,
	[out] LPSTR lpszFilename
);
FailOnFalse         GetICMProfileW(
	[in] HDC hDC,
	[out] LPDWORD lpcbName,
	[out] LPWSTR lpszFilename
);
FailOnFalse         SetICMProfileA(
	[in] HDC hDC,
	[in] LPSTR lpFileName
);
FailOnFalse         SetICMProfileW(
	[in] HDC hDC,
	[in] LPWSTR lpFileName
);
FailOnFalse         GetDeviceGammaRamp(
	[in] HDC hDC,
	[out] LPVOID lpRamp
);
FailOnFalse         SetDeviceGammaRamp(
	[in] HDC hDC,
	[in] LPVOID lpRamp
);
FailOnFalse         ColorMatchToTarget(
	[in] HDC hDC,
	[in] HDC hdcTarget,
	[in] DWORD uiAction
);
int          EnumICMProfilesA(
	[in] HDC hDC,
	[in] ICMENUMPROCA lpEnumICMProfilesFunc,
	[in] LPARAM lParam
);
int          EnumICMProfilesW(
	[in] HDC hDC,
	[in] ICMENUMPROCW lpEnumICMProfilesFunc,
	[in] LPARAM lParam
);
FailOnFalse         UpdateICMRegKeyA(
	[in] DWORD dwReserved,
	[in] LPSTR lpszCMID,
	[in] LPSTR lpszFileName,
	[in] _UpdateICMRegKey nCommand
);
FailOnFalse         UpdateICMRegKeyW(
	[in] DWORD dwReserved,
	[in] LPWSTR lpszCMID,
	[in] LPWSTR lpszFileName,
	[in] _UpdateICMRegKey nCommand
);

FailOnFalse ColorCorrectPalette(
	[in] HDC hDC,
	[in] HPALETTE hPalette,
	[in] DWORD dwFirstEntry,
	[in] DWORD dwNumOfEntries
);


// OpenGL wgl prototypes
/*
FailOnFalse   wglCopyContext(HGLRC, HGLRC, UINT);
HGLRC  wglCreateContext(HDC);
HGLRC  wglCreateLayerContext(HDC, int);
FailOnFalse   wglDeleteContext(HGLRC);
HGLRC  wglGetCurrentContext();
HDC    wglGetCurrentDC();
PROC   wglGetProcAddress(LPCSTR);
FailOnFalse   wglMakeCurrent(HDC, HGLRC);
FailOnFalse   wglShareLists(HGLRC, HGLRC);
FailOnFalse   wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
FailOnFalse   wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
FailOnFalse   SwapBuffers(HDC);

FailOnFalse   wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                         FLOAT, int, LPGLYPHMETRICSFLOAT);
FailOnFalse   wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
FailOnFalse   wglDescribeLayerPlane(HDC, int, int, UINT,
                                           LPLAYERPLANEDESCRIPTOR);
IntFailIfZero    wglSetLayerPaletteEntries(HDC, int, int, int,
                                                COLORREF *);
IntFailIfZero    wglGetLayerPaletteEntries(HDC, int, int, int,
                                               COLORREF *);
FailOnFalse   wglRealizeLayerPalette(HDC, int, BOOL);
FailOnFalse   wglSwapLayerBuffers(HDC, UINT);


FailOnFalse  wglSwapMultipleBuffers(UINT,  WGLSWAP *);

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\hook.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                              Hook Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct tagCWPSTRUCT { 
    LPARAM  lParam; 
    WPARAM  wParam; 
    UINT    message; 
    HWND    hwnd; 
} CWPSTRUCT, *PCWPSTRUCT; 

typedef struct tagCWPRETSTRUCT { 
    LRESULT lResult; 
    LPARAM  lParam; 
    WPARAM  wParam; 
    UINT    message; 
    HWND    hwnd; 
} CWPRETSTRUCT, *PCWPRETSTRUCT; 

value INT CBTHookCodes 
{
#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9
};

value WPARAM HookProcType
{
#define WH_CALLWNDPROC      4
#define WH_CALLWNDPROCRET  12
#define WH_CBT              5
#define WH_DEBUG            9
#define WH_FOREGROUNDIDLE  11
#define WH_GETMESSAGE       3
#define WH_JOURNALPLAYBACK  1
#define WH_JOURNALRECORD    0
#define WH_KEYBOARD         2
#define WH_KEYBOARD_LL     13
#define WH_MOUSE            7
#define WH_MOUSE_LL        14
#define WH_MSGFILTER       -1
#define WH_SHELL           10
#define WH_SYSMSGFILTER     6
};

typedef struct tagDEBUGHOOKINFO { 
    DWORD  idThread; 
    DWORD  idThreadInstaller; 
    LPARAM lParam; 
    WPARAM wParam; 
    INT    code; 
} DEBUGHOOKINFO, *PDEBUGHOOKINFO; 

typedef struct tagEVENTMSG {
    UINT  message; 
    UINT  paramL; 
    UINT  paramH; 
    DWORD time; 
    HWND  hwnd; 
} EVENTMSG, *PEVENTMSG; 

value INT HookCode
{
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5
};

typedef struct tagKBDLLHOOKSTRUCT {
    DWORD     vkCode;
    DWORD     scanCode;
    DWORD     flags;
    DWORD     time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;

typedef struct tagMSLLHOOKSTRUCT {
    POINT     pt;
    DWORD     mouseData;
    DWORD     flags;
    DWORD     time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

value INT InputWhichGeneratedMessage
{
#define MSGF_DDEMGR                 0x8001
#define MSGF_DIALOGBOX              0
#define MSGF_MENU                   2
#define MSGF_SCROLLBAR              5
};

typedef struct tagMOUSEHOOKSTRUCT { 
    POINT     pt; 
    HWND      hwnd; 
    UINT      wHitTestCode; 
    ULONG_PTR dwExtraInfo; 
} MOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT; 

value INT ShellProcHookCode
{
#define HSHELL_ACCESSIBILITYSTATE   11
#define HSHELL_ACTIVATESHELLWINDOW  3
#define HSHELL_GETMINRECT           5
#define HSHELL_LANGUAGE             8
#define HSHELL_REDRAW               6
#define HSHELL_TASKMAN              7
#define HSHELL_WINDOWACTIVATED      4
#define HSHELL_WINDOWCREATED        1
#define HSHELL_WINDOWDESTROYED      2
};

category HookingFunctions:
module USER32.DLL:

BOOL CallMsgFilter(LPMSG lpMsg, int nCode);

LRESULT CallNextHookEx(HHOOK  hhk,
                       int    nCode,
                       WPARAM wParam,
                       LPARAM lParam);

HHOOK [gle] SetWindowsHookExA(HookProcType idHook,
                              HOOKPROC     lpfn,
                              HINSTANCE    hMod,
                              DWORD        dwThreadId);

HHOOK [gle] SetWindowsHookExW(HookProcType idHook,
                              HOOKPROC     lpfn,
                              HINSTANCE    hmod,
                              DWORD        dwThreadId);

FailOnFalse [gle] UnhookWindowsHookEx( [da] HHOOK hhk);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\FileIO.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         File I/O Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category IOFunctions:
module KERNEL32.DLL:

value long FileErrorReturnValue
{
#define HFILE_ERROR -1
};

value int _lcreatFileAttributes
{
#define Normal          0
#define Read_Only       1
#define Hidden          2
#define System          3
};

mask DWORD CopyFlags
{
#define COPY_FILE_FAIL_IF_EXISTS        0x00000001
#define COPY_FILE_RESTARTABLE           0x00000002
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE 0x00000004
};

value DWORD CallBackReasons
{
#define CALLBACK_CHUNK_FINISHED         0x00000000
#define CALLBACK_STREAM_SWITCH          0x00000001
};

value DWORD CopyRoutineReturns
{
#define PROGRESS_CONTINUE   0
#define PROGRESS_CANCEL     1
#define PROGRESS_STOP       2
#define PROGRESS_QUIET      3
};

mask DWORD DefineDosDeviceFlags
{
#define DDD_RAW_TARGET_PATH         0x00000001
#define DDD_REMOVE_DEFINITION       0x00000002
#define DDD_EXACT_MATCH_ON_REMOVE   0x00000004
#define DDD_NO_BROADCAST_SYSTEM     0x00000008
};

mask DWORD ChangeNotifications
{
#define FILE_NOTIFY_CHANGE_FILE_NAME    0x00000001   
#define FILE_NOTIFY_CHANGE_DIR_NAME     0x00000002   
#define FILE_NOTIFY_CHANGE_ATTRIBUTES   0x00000004   
#define FILE_NOTIFY_CHANGE_SIZE         0x00000008   
#define FILE_NOTIFY_CHANGE_LAST_WRITE   0x00000010   
#define FILE_NOTIFY_CHANGE_LAST_ACCESS  0x00000020   
#define FILE_NOTIFY_CHANGE_CREATION     0x00000040   
#define FILE_NOTIFY_CHANGE_SECURITY     0x00000100   
};

value LONG _FILEEX_INFO_LEVELS
{
#define FindExInfoStandard          0
#define FindExInfoMaxInfoLevel      1
};

value LONG OpenFileStyle
{
#define OF_READ         0   
#define OF_WRITE        1   
#define OF_READ_WRITE   2   
};


value LONG FINDEX_INFO_LEVELS 
{
#define   FindExSearchNameMatch             0
#define   FindExSearchLimitToDirectories   1 
#define   FindExSearchLimitToDevices       2
};

value LONG FINDEX_SEARCH_OPS 
{
#define FindExSearchNameMatch               0 
#define FindExSearchLimitToDirectories      1
#define FindExSearchLimitToDevices          2
};

value LPDWORD GetBinaryTypeValues
{
#define SCS_32BIT_BINARY    0
#define SCS_DOS_BINARY      1
#define SCS_WOW_BINARY      2
#define SCS_PIF_BINARY      3
#define SCS_POSIX_BINARY    4
#define SCS_OS216_BINARY    5
};

value UINT DriveTypes
{
#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6
};

value DWORD SPDataFlags
{
#define SPINT_ACTIVE  0x00000001
#define SPINT_DEFAULT 0x00000002
#define SPINT_REMOVED 0x00000004
};

typedef struct _SP_DEVICE_INTERFACE_DATA {
    DWORD cbSize;
    GUID  InterfaceClassGuid;
    SPDataFlags  Flags;
    ULONG_PTR Reserved;
} SP_DEVICE_INTERFACE_DATA, *PSP_DEVICE_INTERFACE_DATA;

typedef struct _SP_DEVINFO_LIST_DETAIL_DATA_A {
    DWORD  cbSize;
    GUID   ClassGuid;
    HANDLE RemoteMachineHandle;
    CHAR   RemoteMachineName[263];
} SP_DEVINFO_LIST_DETAIL_DATA_A, *PSP_DEVINFO_LIST_DETAIL_DATA_A;

typedef struct _SP_DEVINFO_LIST_DETAIL_DATA_W {
    DWORD  cbSize;
    GUID   ClassGuid;
    HANDLE RemoteMachineHandle;
    WCHAR  RemoteMachineName[263];
} SP_DEVINFO_LIST_DETAIL_DATA_W, *PSP_DEVINFO_LIST_DETAIL_DATA_W;

typedef struct _SP_DEVICE_INTERFACE_DETAIL_DATA_A {
    DWORD  cbSize;
    CHAR   DevicePath[1];
} SP_DEVICE_INTERFACE_DETAIL_DATA_A, *PSP_DEVICE_INTERFACE_DETAIL_DATA_A;

typedef struct _SP_DEVICE_INTERFACE_DETAIL_DATA_W {
    DWORD  cbSize;
    WCHAR  DevicePath[1];
} SP_DEVICE_INTERFACE_DETAIL_DATA_W, *PSP_DEVICE_INTERFACE_DETAIL_DATA_W;

value LONG GET_FILEEX_INFO_LEVELS
{
#define   GetFileExInfoStandard 0
};

typedef struct _BY_HANDLE_FILE_INFORMATION {
    FileFlagsAndAttributes    dwFileAttributes; 
    FILETIME ftCreationTime; 
    FILETIME ftLastAccessTime; 
    FILETIME ftLastWriteTime; 
    DWORD    dwVolumeSerialNumber; 
    DWORD    nFileSizeHigh; 
    DWORD    nFileSizeLow; 
    DWORD    nNumberOfLinks; 
    DWORD    nFileIndexHigh; 
    DWORD    nFileIndexLow; 
} BY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION; 


typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;

value DWORD GetFileTypeReturnValue
{
#define FILE_TYPE_UNKNOWN   0x0000
#define FILE_TYPE_DISK      0x0001
#define FILE_TYPE_CHAR      0x0002
#define FILE_TYPE_PIPE      0x0003
#define FILE_TYPE_REMOTE    0x8000
};

value DWORD LockOptions
{
#define LOCKFILE_FAIL_IMMEDIATELY   0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK     0x00000002
};

mask DWORD MoveFilePossibilities 
{
#define MOVEFILE_REPLACE_EXISTING       0x00000001
#define MOVEFILE_COPY_ALLOWED           0x00000002
#define MOVEFILE_DELAY_UNTIL_REBOOT     0x00000004
#define MOVEFILE_WRITE_THROUGH          0x00000008
#define MOVEFILE_CREATE_HARDLINK        0x00000010
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE  0x00000020
};

value UINT OpenFileActions
{
#define OF_READ             0x00000000
#define OF_WRITE            0x00000001
#define OF_READWRITE        0x00000002
#define OF_SHARE_COMPAT     0x00000000
#define OF_SHARE_EXCLUSIVE  0x00000010
#define OF_SHARE_DENY_WRITE 0x00000020
#define OF_SHARE_DENY_READ  0x00000030
#define OF_SHARE_DENY_NONE  0x00000040
#define OF_PARSE            0x00000100
#define OF_DELETE           0x00000200
#define OF_VERIFY           0x00000400
#define OF_CANCEL           0x00000800
#define OF_CREATE           0x00001000
#define OF_PROMPT           0x00002000
#define OF_EXIST            0x00004000
#define OF_REOPEN           0x00008000
};


value DWORD FileChangeType 
{
#define FILE_ACTION_ADDED                   0x00000001   
#define FILE_ACTION_REMOVED                 0x00000002   
#define FILE_ACTION_MODIFIED                0x00000003   
#define FILE_ACTION_RENAMED_OLD_NAME        0x00000004   
#define FILE_ACTION_RENAMED_NEW_NAME        0x00000005   
};    

typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    FileChangeType Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *LPFILE_NOTIFY_INFORMATION;

typedef DWORD NumberOfClusters;
alias NumberOfClusters;

typedef DWORD SectorsPerCluster;
alias SectorsPerCluster;


value DWORD SetFilePointerReturn
{
#define INVALID_SET_POINTER         -1 [fail]
};

FileErrorReturnValue [gle] _hread(
                                  HFILE hFile,      
                                  [out] LPVOID lpBuffer,  
                                  long lBytes       
                                  );

FileErrorReturnValue [gle] _hwrite(
                                   HFILE hFile,      
                                   LPCSTR lpBuffer,  
                                   long lBytes       
                                   );

FileErrorReturnValue [gle] _lclose(
                                   [out] HFILE hFile   
                                   );

FileErrorReturnValue [gle] _lcreat(
                                   LPCSTR lpPathName,  
                                   _lcreatFileAttributes iAttribute      
                                   );

FileErrorReturnValue [gle] _llseek(
                                   HFILE hFile,  
                                   LONG lOffset, 
                                   FilePointerStartingPosition iOrigin   
                                   );

FileErrorReturnValue [gle] _lopen(
                                  LPCSTR lpPathName,  
                                  OpenFileStyle iReadWrite      
                                  );

FileErrorReturnValue [gle] _lread(
                                  HFILE hFile,      
                                  [out] LPVOID lpBuffer,  
                                  UINT uBytes       
                                  );

FileErrorReturnValue [gle] _lwrite(
                                   HFILE hFile,      
                                   LPCSTR lpBuffer,  
                                   UINT uBytes       
                                   );

FailOnFalse AreFileApisANSI();

FailOnFalse [gle] CancelIo(
                           HANDLE hFile  
                           );

FailOnFalse [gle] CopyFileA(
                            LPCSTR lpExistingFileName,
                            LPCSTR lpNewFileName,
                            BOOL bFailIfExists
                            );

FailOnFalse [gle] CopyFileW(
                            LPCWSTR lpExistingFileName,
                            LPCWSTR lpNewFileName,
                            BOOL bFailIfExists
                            );

FailOnFalse [gle] CopyFileExA(
                              LPCSTR lpExistingFileName,
                              LPCSTR lpNewFileName,
                              LPVOID lpProgressRoutine,
                              LPVOID lpData,
                              LPBOOL pbCancel,
                              CopyFlags dwCopyFlags
                              );

FailOnFalse [gle] CopyFileExW(
                              LPCWSTR lpExistingFileName,
                              LPCWSTR lpNewFileName,
                              LPVOID lpProgressRoutine,
                              LPVOID lpData,
                              LPBOOL pbCancel,
                              CopyFlags dwCopyFlags
                              );

FailOnFalse [gle] CreateDirectoryA(
                                   LPCSTR lpPathName,
                                   LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                   );

FailOnFalse [gle] CreateDirectoryW(
                                   LPCWSTR lpPathName,
                                   LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                   );

FailOnFalse [gle] CreateDirectoryExA(
                                     LPCSTR lpTemplateDirectory,
                                     LPCSTR lpNewDirectory,
                                     LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                     );

FailOnFalse [gle] CreateDirectoryExW(
                                     LPCWSTR lpTemplateDirectory,
                                     LPCWSTR lpNewDirectory,                                                          
                                     LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                     );

HANDLE [gle] CreateFileA(
                              LPCSTR lpFileName,
                              DWORD dwDesiredAccess,
                              GenericAccessRights dwShareMode,
                              LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                              CreationActions dwCreationDisposition,
                              FileFlagsAndAttributes dwFlagsAndAttributes,
                              HANDLE hTemplateFile
                              );

HANDLE [gle] CreateFileW(
                              LPCWSTR lpFileName,
                              GenericAccessRights dwDesiredAccess,
                              ShareRights dwShareMode,
                              LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                              CreationActions dwCreationDisposition,
                              FileFlagsAndAttributes dwFlagsAndAttributes,
                              HANDLE hTemplateFile
                              );

HANDLE [gle] CreateIoCompletionPort (
                                               HANDLE FileHandle,              
                                               HANDLE ExistingCompletionPort,  
                                               ULONG_PTR CompletionKey,        
                                               DWORD NumberOfConcurrentThreads 
                                               );

FailOnFalse [gle] DefineDosDeviceA(
                                   DefineDosDeviceFlags dwFlags,
                                   LPCSTR lpDeviceName,
                                   LPCSTR lpTargetPath
                                   );

FailOnFalse [gle] DefineDosDeviceW(
                                   DefineDosDeviceFlags dwFlags,
                                   LPCWSTR lpDeviceName,
                                   LPCWSTR lpTargetPath
                                   );

FailOnFalse [gle] DeleteFileA(
                              LPCSTR lpFileName
                              );

FailOnFalse [gle] DeleteFileW(
                              LPCWSTR lpFileName
                              );

FailOnFalse [gle] FindClose(
                            [out] HANDLE hFindFile   
                            );

FailOnFalse [gle] FindCloseChangeNotification(
                                              HANDLE hChangeHandle   
                                              ); 

HANDLE [gle] FindFirstChangeNotificationA(
                                                       LPCSTR lpPathName,
                                                       BOOL bWatchSubtree,
                                                       DWORD dwNotifyFilter
                                                       );

HANDLE [gle] FindFirstChangeNotificationW(
                                                       LPCWSTR lpPathName,
                                                       BOOL bWatchSubtree,
                                                       DWORD ChangeNotifications
                                                       );

HANDLE [gle] FindFirstFileA(
                                         LPCSTR lpFileName,
                                         [out] LPWIN32_FIND_DATAA lpFindFileData
                                         );

HANDLE [gle] FindFirstFileW(
                                         LPCWSTR lpFileName,
                                         [out] LPWIN32_FIND_DATAW lpFindFileData
                                         );

HANDLE [gle] FindFirstFileExA(
                                           LPCSTR lpFileName,
                                           FINDEX_INFO_LEVELS fInfoLevelId,
                                           [out] LPWIN32_FIND_DATAA lpFindFileData,
                                           FINDEX_SEARCH_OPS fSearchOp,
                                           LPVOID lpSearchFilter,
                                           DWORD dwAdditionalFlags
                                           );

HANDLE [gle] FindFirstFileExW(
                                           LPCWSTR lpFileName,
                                           FINDEX_INFO_LEVELS fInfoLevelId,
                                           [out] LPWIN32_FIND_DATAW lpFindFileData,
                                           FINDEX_SEARCH_OPS fSearchOp,
                                           LPVOID lpSearchFilter,
                                           DWORD dwAdditionalFlags
                                           );

FailOnFalse [gle] FindNextChangeNotification(
                                             HANDLE hChangeHandle   
                                             );

FailOnFalse [gle] FindNextFileA(
                                HANDLE hFindFile,                
                                [out] LPWIN32_FIND_DATAA lpFindFileData 
                                );

FailOnFalse [gle] FindNextFileW(
                                HANDLE hFindFile,
                                [out] LPWIN32_FIND_DATAW lpFindFileData
                                );

FailOnFalse [gle] FlushFileBuffers(
                                   HANDLE hFile  
                                   );

FailOnFalse [gle] GetBinaryTypeA(
                                 LPCSTR lpApplicationName,
                                 [out] GetBinaryTypeValues lpBinaryType
                                 );

FailOnFalse [gle] GetBinaryTypeW(
                                 LPCWSTR lpApplicationName,
                                 [out] GetBinaryTypeValues lpBinaryType
                                 );

DwordFailIfZero [gle] GetCurrentDirectoryA(
                                           DWORD nBufferLength,
                                           [out] LPSTR lpBuffer
                                           );

DwordFailIfZero [gle] GetCurrentDirectoryW(
                                           DWORD nBufferLength,
                                           [out] LPWSTR lpBuffer
                                           );

DwordFailIfZero [gle] GetWindowsDirectoryA(
                                   [out] LPSTR lpBuffer,
                                   UINT uSize
                                   );

DwordFailIfZero [gle] GetWindowsDirectoryW(
                                   [out] LPWSTR lpBuffer,
                                   UINT uSize
                                   );

DwordFailIfZero [gle] GetSystemDirectoryA(
                                   [out] LPSTR lpBuffer,
                                   UINT uSize
                                   );

DwordFailIfZero [gle] GetSystemDirectoryW(
                                   [out] LPWSTR lpBuffer,
                                   UINT uSize
                                   );

DwordFailIfZero [gle] GetSystemWindowsDirectoryA(
                                   [out] LPSTR lpBuffer,
                                   UINT uSize
                                   );

DwordFailIfZero [gle] GetSystemWindowsDirectoryW(
                                   [out] LPWSTR lpBuffer,
                                   UINT uSize
                                   );

FailOnFalse [gle] GetDiskFreeSpaceA(
                                    LPCSTR lpRootPathName,          
                                    [out] SectorsPerCluster* lpSectorsPerCluster,     
                                    [out] LPDWORD lpBytesPerSector,        
                                    [out] NumberOfClusters* lpNumberOfFreeClusters,  
                                    [out] NumberOfClusters* lpTotalNumberOfClusters  
                                    );

FailOnFalse [gle] GetDiskFreeSpaceW(
                                    LPCWSTR lpRootPathName,
                                    [out] SectorsPerCluster* lpSectorsPerCluster,
                                    [out] LPDWORD lpBytesPerSector,
                                    [out] NumberOfClusters* lpNumberOfFreeClusters,
                                    [out] NumberOfClusters* lpTotalNumberOfClusters
                                    );

typedef DWORD DiskBytesDWORD;
alias DiskBytesDWORD;

typedef struct _DiskBytes
{
    DiskBytesDWORD   Low;
    DiskBytesDWORD   High;
} DiskBytes,*PDiskBytes;


FailOnFalse [gle] GetDiskFreeSpaceExA(
                                      LPCSTR lpDirectoryName,                 
                                      [out] PDiskBytes lpFreeBytesAvailable,    
                                      [out] PDiskBytes lpTotalNumberOfBytes,    
                                      [out] PDiskBytes lpTotalNumberOfFreeBytes 
                                      );

FailOnFalse [gle] GetDiskFreeSpaceExW(
                                      LPCWSTR lpDirectoryName,
                                      [out] PDiskBytes lpFreeBytesAvailableToCaller,
                                      [out] PDiskBytes lpTotalNumberOfBytes,
                                      [out] PDiskBytes lpTotalNumberOfFreeBytes
                                      );

DriveTypes GetDriveTypeA(
                         LPCSTR lpRootPathName
                         );

DriveTypes GetDriveTypeW(
                         LPCWSTR lpRootPathName
                         );

FileFlagsAndAttributes [gle] GetFileAttributesA(
                                                LPCSTR lpFileName
                                                );

FileFlagsAndAttributes [gle] GetFileAttributesW(
                                                LPCWSTR lpFileName
                                                );

FailOnFalse [gle] GetFileAttributesExA(
                                       LPCSTR lpFileName,
                                       GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                       [out] LPVOID lpFileInformation
                                       );

FailOnFalse [gle] GetFileAttributesExW(
                                       LPCWSTR lpFileName,
                                       GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                       [out] LPVOID lpFileInformation
                                       );

FailOnFalse [gle] GetFileInformationByHandle(
                                             HANDLE hFile,                                  
                                             [out] LPBY_HANDLE_FILE_INFORMATION lpFileInformation 
                                             );

DwordFailIfNeg1 [gle] GetFileSize(
                                  HANDLE hFile,           
                                  [out] LPDWORD lpFileSizeHigh  
                                  );

FailOnFalse [gle] GetFileSizeEx(
                                HANDLE hFile,              
                                [out] PLARGE_INTEGER lpFileSize  
                                );

GetFileTypeReturnValue GetFileType(
                                   HANDLE hFile   
                                   );

DwordFailIfZero [gle] GetFullPathNameA(
                                       LPCSTR lpFileName,
                                       DWORD nBufferLength,
                                       [out] LPSTR lpBuffer,
                                       [out] LPSTR *lpFilePart
                                       );

DwordFailIfZero [gle] GetFullPathNameW(
                                       LPCWSTR lpFileName,
                                       DWORD nBufferLength,
                                       [out] LPWSTR lpBuffer,
                                       [out] LPWSTR *lpFilePart
                                       );

DwordFailIfZero [gle] GetLogicalDrives();

DwordFailIfZero [gle] GetLogicalDriveStringsA(
                                              DWORD nBufferLength,
                                              [out] LPSTR lpBuffer
                                              );

DwordFailIfZero [gle] GetLogicalDriveStringsW(
                                              DWORD nBufferLength,
                                              [out] LPWSTR lpBuffer
                                              );

DwordFailIfZero [gle] GetLongPathNameA(
                                       LPCSTR lpszShortPath,
                                       [out] LPSTR  lpszLongPath,
                                       DWORD    cchBuffer
                                       );

DwordFailIfZero [gle] GetLongPathNameW(
                                       LPCWSTR lpszShortPath,
                                       [out] LPWSTR  lpszLongPath,
                                       DWORD    cchBuffer
                                       );

FailOnFalse [gle] GetQueuedCompletionStatus(
                                            HANDLE CompletionPort,       
                                            [out] LPDWORD lpNumberOfBytes,     
                                            [out] PULONG_PTR lpCompletionKey,  
                                            [out] LPOVERLAPPED *lpOverlapped,  
                                            DWORD dwMilliseconds         
                                            );

DwordFailIfZero [gle] GetShortPathNameA(
                                        LPCSTR lpszLongPath,
                                        [out] LPSTR  lpszShortPath,
                                        DWORD    cchBuffer
                                        );

DwordFailIfZero [gle] GetShortPathNameW(
                                        LPCWSTR lpszLongPath,
                                        [out] LPWSTR  lpszShortPath,
                                        DWORD    cchBuffer
                                        );

UintFailIfZero [gle] GetTempFileNameA(
                                      LPCSTR lpPathName,      
                                      LPCSTR lpPrefixString,  
                                      UINT uUnique,            
                                      [out] LPSTR lpTempFileName    
                                      );

UintFailIfZero [gle] GetTempFileNameW(
                                      LPCWSTR lpPathName,
                                      LPCWSTR lpPrefixString,
                                      UINT uUnique,
                                      [out] LPWSTR lpTempFileName
                                      );

DwordFailIfZero [gle] GetTempPathA(
                                   DWORD nBufferLength,
                                   [out] LPSTR lpBuffer
                                   );

DwordFailIfZero [gle] GetTempPathW(
                                   DWORD nBufferLength,
                                   [out] LPWSTR lpBuffer
                                   );

FailOnFalse [gle] LockFile(
                           HANDLE hFile,                   
                           DWORD dwFileOffsetLow,          
                           DWORD dwFileOffsetHigh,         
                           DWORD nNumberOfBytesToLockLow,  
                           DWORD nNumberOfBytesToLockHigh  
                           );

FailOnFalse [gle] LockFileEx(
                             HANDLE hFile,                   
                             LockOptions dwFlags,                  
                             DWORD dwReserved,               
                             DWORD nNumberOfBytesToLockLow,  
                             DWORD nNumberOfBytesToLockHigh, 
                             LPOVERLAPPED lpOverlapped       
                             );

FailOnFalse [gle] MoveFileA(
                            LPCSTR lpExistingFileName,
                            LPCSTR lpNewFileName
                            );

FailOnFalse [gle] MoveFileW(
                            LPCWSTR lpExistingFileName,
                            LPCWSTR lpNewFileName
                            );

FailOnFalse [gle] MoveFileExA(
                              LPCSTR lpExistingFileName,
                              LPCSTR lpNewFileName,
                              MoveFilePossibilities dwFlags
                              );

FailOnFalse [gle] MoveFileExW(
                              LPCWSTR lpExistingFileName,
                              LPCWSTR lpNewFileName,
                              MoveFilePossibilities dwFlags
                              );

FailOnFalse [gle] MoveFileWithProgressA(
                                        LPCSTR lpExistingFileName,
                                        LPCSTR lpNewFileName,
                                        LPVOID lpProgressRoutine ,
                                        LPVOID lpData ,
                                        DWORD dwFlags
                                        );

FailOnFalse [gle] MoveFileWithProgressW(
                                        LPCWSTR lpExistingFileName,
                                        LPCWSTR lpNewFileName,
                                        LPVOID  lpProgressRoutine ,
                                        LPVOID lpData ,
                                        MoveFilePossibilities dwFlags
                                        );

IntFailIfNeg1 MulDiv(
                     int nNumber,       
                     int nNumerator,    
                     int nDenominator   
                     );

HFILE OpenFile(
               LPCSTR lpFileName,        
               [out] LPOFSTRUCT lpReOpenBuff,  
               OpenFileActions uStyle               
               );

FailOnFalse [gle] PostQueuedCompletionStatus(
                                             HANDLE CompletionPort,            
                                             DWORD dwNumberOfBytesTransferred, 
                                             ULONG_PTR dwCompletionKey,        
                                             LPOVERLAPPED lpOverlapped         
                                             );

FailOnFalse [gle] PrivCopyFileExA(
                                  LPCSTR lpExistingFileName,
                                  LPCSTR lpNewFileName,
                                  LPVOID lpProgressRoutine,
                                  LPVOID lpData,
                                  LPBOOL pbCancel,
                                  CopyFlags dwCopyFlags
                                  );

FailOnFalse [gle] PrivCopyFileExW(
                                  LPCWSTR lpExistingFileName,
                                  LPCWSTR lpNewFileName,
                                  LPVOID lpProgressRoutine,
                                  LPVOID lpData,
                                  LPBOOL pbCancel,
                                  CopyFlags dwCopyFlags
                                  );

DwordFailIfZero [gle] QueryDosDeviceA(
                                      LPCSTR lpDeviceName,
                                      [out] LPSTR lpTargetPath,
                                      DWORD ucchMax
                                      );

DwordFailIfZero [gle] QueryDosDeviceW(
                                      LPCWSTR lpDeviceName,
                                      [out] LPWSTR lpTargetPath,
                                      DWORD ucchMax
                                      );

FailOnFalse [gle] ReadDirectoryChangesW(
                                        HANDLE hDirectory,                                  
                                        [out] LPVOID lpBuffer,                                    
                                        DWORD nBufferLength,                                
                                        BOOL bWatchSubtree,                                 
                                        DWORD dwNotifyFilter,                               
                                        LPDWORD lpBytesReturned,                            
                                        LPOVERLAPPED lpOverlapped,                          
                                        LPVOID lpCompletionRoutine 
                                        );

FailOnFalse [gle] ReadFile(
                           HANDLE hFile,                
                           [out] LPVOID lpBuffer,             
                           DWORD nNumberOfBytesToRead,  
                           LPDWORD lpNumberOfBytesRead, 
                           LPOVERLAPPED lpOverlapped    
                           );

FailOnFalse [gle] ReadFileEx(
                             HANDLE hFile,                                       
                             [out] LPVOID lpBuffer,                              
                             DWORD nNumberOfBytesToRead,                         
                             LPOVERLAPPED lpOverlapped,                          
                             LPVOID lpCompletionRoutine 
                             );

// cjc ULONGLONGFILE_SEGMENT_ELEMENT aSegmentArray[ ], 
FailOnFalse [gle] ReadFileScatter(
                                  HANDLE hFile,                          
                                  ULONGLONG aSegmentArray, 
                                  DWORD nNumberOfBytesToRead,            
                                  LPDWORD lpReserved,                    
                                  LPOVERLAPPED lpOverlapped              
                                  );

FailOnFalse [gle] RemoveDirectoryA(
                                   LPCSTR lpPathName
                                   );

FailOnFalse [gle] RemoveDirectoryW(
                                   LPCWSTR lpPathName
                                   );

FailOnFalse [gle] ReplaceFile(
                              LPCSTR lpReplacedFileName,    
                              LPCSTR lpReplacementFileName, 
                              LPCSTR lpBackupFileName,      
                              DWORD dwReplaceFlags,          
                              LPVOID lpExclude,              
                              LPVOID lpReserved              
                              );

FailOnFalse [gle] ReplaceFileW(
                              LPCWSTR lpReplacedFileName,    
                              LPCWSTR lpReplacementFileName, 
                              LPCWSTR lpBackupFileName,      
                              DWORD dwReplaceFlags,          
                              LPVOID lpExclude,              
                              LPVOID lpReserved              
                              );

DwordFailIfZero [gle] SearchPathA(
                                  LPCSTR lpPath,
                                  LPCSTR lpFileName,
                                  LPCSTR lpExtension,
                                  DWORD nBufferLength,
                                  [out] LPSTR lpBuffer,
                                  [out] LPSTR *lpFilePart
                                  );

DwordFailIfZero [gle] SearchPathW(
                                  LPCWSTR lpPath,
                                  LPCWSTR lpFileName,
                                  LPCWSTR lpExtension,
                                  DWORD nBufferLength,
                                  [out] LPWSTR lpBuffer,
                                  [out] LPWSTR *lpFilePart
                                  );

FailOnFalse [gle] SetCurrentDirectoryA(
                                       LPCSTR lpPathName
                                       );

FailOnFalse [gle] SetCurrentDirectoryW(
                                       LPCWSTR lpPathName
                                       );

FailOnFalse [gle] SetEndOfFile(
                               HANDLE hFile   
                               );

VOID SetFileApisToANSI();

VOID SetFileApisToOEM();

FailOnFalse [gle] SetFileAttributesA(
                                     LPCSTR lpFileName,
                                     FileFlagsAndAttributes dwFileAttributes
                                     );

FailOnFalse [gle] SetFileAttributesW(
                                     LPCWSTR lpFileName,
                                     FileFlagsAndAttributes dwFileAttributes
                                     );

SetFilePointerReturn [gle] SetFilePointer(
                                          HANDLE hFile,                
                                          LONG lDistanceToMove,        
                                          PLONG lpDistanceToMoveHigh,  
                                          FilePointerStartingPosition dwMoveMethod           
                                          );

FailOnFalse [gle] SetFilePointerEx(
                                   HANDLE hFile,                    
                                   LARGE_INTEGER liDistanceToMove,  
                                   PLARGE_INTEGER lpNewFilePointer, 
                                   FilePointerStartingPosition dwMoveMethod               
                                   );

UINT SetHandleCount(
                    UINT uNumber   
                    );

FailOnFalse [gle] SetVolumeLabelA(
                                  LPCSTR lpRootPathName,
                                  LPCSTR lpVolumeName
                                  );

FailOnFalse [gle] SetVolumeLabelW(
                                  LPCWSTR lpRootPathName,
                                  LPCWSTR lpVolumeName
                                  );

FailOnFalse [gle] UnlockFile(
                             HANDLE hFile,                    
                             DWORD dwFileOffsetLow,           
                             DWORD dwFileOffsetHigh,          
                             DWORD nNumberOfBytesToUnlockLow, 
                             DWORD nNumberOfBytesToUnlockHigh 
                             );

FailOnFalse [gle] UnlockFileEx(
                               HANDLE hFile,                     
                               DWORD dwReserved,                 
                               DWORD nNumberOfBytesToUnlockLow,  
                               DWORD nNumberOfBytesToUnlockHigh, 
                               LPOVERLAPPED lpOverlapped         
                               );

FailOnFalse [gle] WriteFile(
                            HANDLE hFile,                    
                            LPCVOID lpBuffer,                
                            DWORD nNumberOfBytesToWrite,     
                            LPDWORD lpNumberOfBytesWritten,  
                            LPOVERLAPPED lpOverlapped        
                            );

FailOnFalse [gle] WriteFileEx(
                              HANDLE hFile,                                       
                              LPCVOID lpBuffer,                                   
                              DWORD nNumberOfBytesToWrite,                        
                              LPOVERLAPPED lpOverlapped,                          
                              LPVOID lpCompletionRoutine 
                              );

// cjc[out] FILE_SEGMENT_ELEMENT aSegmentArray[ ], 
FailOnFalse [gle] WriteFileGather(
                                  HANDLE hFile,                          
                                  [out] ULONGLONG aSegmentArray, 
                                  DWORD nNumberOfBytesToWrite,           
                                  LPDWORD lpReserved,                    
                                  LPOVERLAPPED lpOverlapped              
                                  );


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         File System Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
mask LPDWORD FileSystemFlags 
{
#define FS_CASE_SENSITIVE               0x00000001
#define FS_CASE_IS_PRESERVED            0x00000002
#define FS_UNICODE_STORED_ON_DISK       0x00000004
#define FS_PERSISTENT_ACLS              0x00000008
#define FS_VOL_IS_COMPRESSED            0x00008000
#define FS_FILE_COMPRESSION             0x00000010
#define FILE_SUPPORTS_OBJECT_IDS        0x00010000  
#define FILE_SUPPORTS_ENCRYPTION        0x00020000  
#define FILE_SUPPORTS_REPARSE_POINTS    0x00000080  
#define FILE_SUPPORTS_REMOTE_STORAGE    0x00000100  
};

typedef struct _EFS_HASH_BLOB {
    DWORD cbData;
    PBYTE pbData;
} EFS_HASH_BLOB, *LPEFS_HASH_BLOB, *PEFS_HASH_BLOB;

typedef struct _CERTIFICATE_BLOB {
    DWORD dwCertEncodingType;
    DWORD cbData;
    PBYTE pbData;
} EFS_CERTIFICATE_BLOB, *PEFS_CERTIFICATE_BLOB;

//cjc SID *pUserSid;
typedef struct _ENCRYPTION_CERTIFICATE_HASH {
    DWORD cbTotalLength;
    VOID *pUserSid;
    PEFS_HASH_BLOB pHash;
    LPWSTR lpDisplayInformation;
} ENCRYPTION_CERTIFICATE_HASH, *LPENCRYPTION_CERTIFICATE_HASH, *PENCRYPTION_CERTIFICATE_HASH;

typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST {
    DWORD nCert_Hash;
    PENCRYPTION_CERTIFICATE_HASH *pUsers;
} ENCRYPTION_CERTIFICATE_HASH_LIST, *LPENCRYPTION_CERTIFICATE_HASH_LIST, *PENCRYPTION_CERTIFICATE_HASH_LIST;


//cjc SID *pUserSid;
typedef struct _ENCRYPTION_CERTIFICATE {
    DWORD cbTotalLength;
    VOID *pUserSid;
    PEFS_CERTIFICATE_BLOB pCertBlob;
} ENCRYPTION_CERTIFICATE, *LPENCRYPTION_CERTIFICATE, *PENCRYPTION_CERTIFICATE;

typedef struct _ENCRYPTION_CERTIFICATE_LIST {
    DWORD nUsers;
    PENCRYPTION_CERTIFICATE * pUsers;
} ENCRYPTION_CERTIFICATE_LIST, *LPENCRYPTION_CERTIFICATE_LIST, *PENCRYPTION_CERTIFICATE_LIST;

FailOnFalse [gle] CreateHardLinkA(
                                  LPCSTR lpFileName,
                                  LPCSTR lpExistingFileName,
                                  LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                  );

FailOnFalse [gle] CreateHardLinkW(
                                  LPCWSTR lpFileName,
                                  LPCWSTR lpExistingFileName,
                                  LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                  );

module ADVAPI32.DLL:
WinError AddUsersToEncryptedFile(
                                 LPCWSTR lpFileName,                  
                                 PENCRYPTION_CERTIFICATE_LIST pUsers  
                                 );

FailOnFalse [gle] DecryptFileA(
                               LPCSTR lpFileName,
                               DWORD    dwReserved
                               );

FailOnFalse [gle] DecryptFileW(
                               LPCWSTR lpFileName,
                               DWORD    dwReserved
                               );

module KERNEL32.DLL:
FailOnFalse [gle] DeleteVolumeMountPointA(
                                         LPCSTR lpszVolumeMountPoint  
                                         );

FailOnFalse [gle] DeleteVolumeMountPointW(
                                         LPCWSTR lpszVolumeMountPoint  
                                         );


module ADVAPI32.DLL:
FailOnFalse [gle] EncryptFileA(
                               LPCSTR lpFileName
                               );

FailOnFalse [gle] EncryptFileW(
                               LPCWSTR lpFileName
                               );

FailOnFalse [gle] EncryptionDisable(
                                    LPCWSTR DirPath,  
                                    BOOL Disable      
                                    );

FailOnFalse [gle] FileEncryptionStatusA(
                                       LPCSTR lpFileName,  
                                       LPDWORD lpStatus     
                                       );

FailOnFalse [gle] FileEncryptionStatusW(
                                       LPCWSTR lpFileName,  
                                       LPDWORD lpStatus     
                                       );

module KERNEL32.DLL:

HANDLE FindFirstVolumeA(
                                    [out] LPCSTR lpszVolumeName,   
                                    DWORD cchBufferLength    
                                    );

HANDLE FindFirstVolumeW(
                                    [out] LPCWSTR lpszVolumeName,   
                                    DWORD cchBufferLength    
                                    );

HANDLE FindFirstVolumeMountPointA(
                                              LPSTR lpszRootPathName,     
                                              [out] LPSTR lpszVolumeMountPoint, 
                                              DWORD cchBufferLength        
                                              );


HANDLE FindFirstVolumeMountPointW(
                                              LPWSTR lpszRootPathName,     
                                              [out] LPWSTR lpszVolumeMountPoint, 
                                              DWORD cchBufferLength        
                                              );

FailOnFalse [gle] FindNextVolumeA(
                                 HANDLE hFindVolume,      
                                 [out] LPSTR lpszVolumeName,   
                                 DWORD cchBufferLength    
                                 );

FailOnFalse [gle] FindNextVolumeW(
                                 HANDLE hFindVolume,      
                                 [out] LPWSTR lpszVolumeName,   
                                 DWORD cchBufferLength    
                                 );


FailOnFalse [gle] FindNextVolumeMountPointA(
                                           HANDLE hFindVolumeMountPoint,    
                                           [out] LPSTR lpszVolumeMountPoint,     
                                           DWORD cchBufferLength            
                                           );

FailOnFalse [gle] FindNextVolumeMountPointW(
                                           HANDLE hFindVolumeMountPoint,    
                                           [out] LPWSTR lpszVolumeMountPoint,     
                                           DWORD cchBufferLength            
                                           );


FailOnFalse [gle] FindVolumeClose(
                                  HANDLE hFindVolume       
                                  );

FailOnFalse [gle] FindVolumeMountPointClose(
                                            HANDLE hFindVolumeMountPoint 
                                            );

module ADVAPI32.DLL:
VOID FreeEncryptionCertificateHashList(
                                       PENCRYPTION_CERTIFICATE_HASH_LIST pHashes  
                                       );

module KERNEL32.DLL:

DwordFailIfNeg1 [gle] GetCompressedFileSizeA(
                                             LPCSTR lpFileName,
                                             [out] LPDWORD lpFileSizeHigh
                                             );

DwordFailIfNeg1 [gle] GetCompressedFileSizeW(
                                             LPCWSTR lpFileName,
                                             [out] LPDWORD lpFileSizeHigh
                                             );

FailOnFalse [gle] GetVolumeInformationA(
                                        LPCSTR lpRootPathName,
                                        LPSTR lpVolumeNameBuffer,
                                        DWORD nVolumeNameSize,
                                        LPDWORD lpVolumeSerialNumber,
                                        LPDWORD lpMaximumComponentLength,
                                        LPDWORD lpFileSystemFlags,
                                        LPSTR lpFileSystemNameBuffer,
                                        DWORD nFileSystemNameSize
                                        );

FailOnFalse [gle] GetVolumeInformationW(
                                        LPCWSTR lpRootPathName,
                                        [out] LPWSTR lpVolumeNameBuffer,
                                        DWORD nVolumeNameSize,
                                        [out] LPDWORD lpVolumeSerialNumber,
                                        [out] LPDWORD lpMaximumComponentLength,
                                        [out] FileSystemFlags lpFileSystemFlags,
                                        [out] LPWSTR lpFileSystemNameBuffer,
                                        DWORD nFileSystemNameSize
                                        );

FailOnFalse [gle] GetVolumeNameForVolumeMountPointA(
                                                   LPCSTR lpszVolumeMountPoint, 
                                                   [out] LPSTR lpszVolumeName,        
                                                   DWORD cchBufferLength         
                                                   );

FailOnFalse [gle] GetVolumeNameForVolumeMountPointW(
                                                   LPCWSTR lpszVolumeMountPoint, 
                                                   [out] LPWSTR lpszVolumeName,        
                                                   DWORD cchBufferLength         
                                                   );


FailOnFalse [gle] GetVolumePathNameA(
                                    LPCSTR lpszFileName,         
                                    [out] LPSTR lpszVolumePathName,    
                                    DWORD cchBufferLength         
                                    );

FailOnFalse [gle] GetVolumePathNameW(
                                    LPCWSTR lpszFileName,         
                                    [out] LPWSTR lpszVolumePathName,    
                                    DWORD cchBufferLength         
                                    );


module ADVAPI32.DLL:
WinError QueryRecoveryAgentsOnEncryptedFile(
                                            LPCWSTR lpFileName,                                 
                                            [out] LPENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents  
                                            ); 

WinError QueryUsersOnEncryptedFile(
                                   LPCWSTR lpFileName,                        
                                   [out] LPENCRYPTION_CERTIFICATE_HASH_LIST *pUsers  
                                   );

WinError RemoveUsersFromEncryptedFile(
                                      LPCWSTR lpFileName,                        
                                      LPENCRYPTION_CERTIFICATE_HASH_LIST pHashes  
                                      );

DWORD SetUserFileEncryptionKey(
                               LPENCRYPTION_CERTIFICATE pEncryptionCertificate  
                               );

module KERNEL32.DLL:
FailOnFalse [gle] SetVolumeMountPointA(
                                      LPCSTR lpszVolumeMountPoint, 
                                      LPCSTR lpszVolumeName        
                                      ); 


FailOnFalse [gle] SetVolumeMountPointW(
                                      LPCWSTR lpszVolumeMountPoint, 
                                      LPCWSTR lpszVolumeName        
                                      ); 


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         Tape Backup Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category DeviceFunctions:

value DWORD StreamIds
{
#define BACKUP_DATA             0x00000001
#define BACKUP_EA_DATA          0x00000002
#define BACKUP_SECURITY_DATA    0x00000003
#define BACKUP_ALTERNATE_DATA   0x00000004
#define BACKUP_LINK             0x00000005
#define BACKUP_PROPERTY_DATA    0x00000006
#define BACKUP_OBJECT_ID        0x00000007
#define BACKUP_REPARSE_DATA     0x00000008
#define BACKUP_SPARSE_BLOCK     0x00000009
};

value DWORD StreamAttributes
{
#define STREAM_MODIFIED_WHEN_READ       0x00000001
#define STREAM_CONTAINS_SECURITY        0x00000002
};

typedef struct _WIN32_STREAM_ID { 
    StreamIds         dwStreamId; 
    StreamAttributes         dwStreamAttributes; 
    LARGE_INTEGER Size; 
    DWORD         dwStreamNameSize; 
    WCHAR         cStreamName[1]; 
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID;

value DWORD TapeCreateDefinitions
{
#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L
};

value DWORD EraseTypeToPerform 
{
#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L
};

value DWORD TypeOfInformation
{
#define GET_TAPE_MEDIA_INFORMATION 0
#define GET_TAPE_DRIVE_INFORMATION 1
};

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER   Capacity; 
    LARGE_INTEGER   Remaining; 
    DWORD   BlockSize; 
    DWORD   PartitionCount; 
    BOOLEAN WriteProtected; 
} TAPE_GET_MEDIA_PARAMETERS, *LPTAPE_GET_MEDIA_PARAMETERS; 

typedef struct _TAPE_GET_DRIVE_PARAMETERS { 
    BOOLEAN ECC; 
    BOOLEAN Compression; 
    BOOLEAN DataPadding; 
    BOOLEAN ReportSetmarks; 
    DWORD   DefaultBlockSize; 
    DWORD   MaximumBlockSize; 
    DWORD   MinimumBlockSize; 
    DWORD   MaximumPartitionCount; 
    DWORD   FeaturesLow; 
    DWORD   FeaturesHigh; 
    DWORD   EOTWarningZoneSize; 
} TAPE_GET_DRIVE_PARAMETERS, *LPTAPE_GET_DRIVE_PARAMETERS; 

value DWORD TapePosition
{
#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L
};

value DWORD TapeDevicePreparation
{
#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L
};

value DWORD InformationToBeSet
{
#define SET_TAPE_MEDIA_INFORMATION 0
#define SET_TAPE_DRIVE_INFORMATION 1
};

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize; 
} TAPE_SET_MEDIA_PARAMETERS, *LPTAPE_SET_MEDIA_PARAMETERS; 

typedef struct _TAPE_SET_DRIVE_PARAMETERS { 
    BOOLEAN ECC; 
    BOOLEAN Compression; 
    BOOLEAN DataPadding; 
    BOOLEAN ReportSetmarks; 
    DWORD   EOTWarningZoneSize; 
} TAPE_SET_DRIVE_PARAMETERS, *LPTAPE_SET_DRIVE_PARAMETERS; 

value DWORD TypeOfPositioning
{
#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L
};

value DWORD TapeMarksToWrite
{
#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L
};

FailOnFalse [gle] BackupRead(
                             HANDLE hFile,                
                             [out] LPBYTE lpBuffer,             
                             DWORD nNumberOfBytesToRead,  
                             LPDWORD lpNumberOfBytesRead, 
                             BOOL bAbort,                 
                             BOOL bProcessSecurity,       
                             [out] LPVOID *lpContext            
                             );

FailOnFalse [gle] BackupSeek(
                             HANDLE hFile,               
                             DWORD dwLowBytesToSeek,     
                             DWORD dwHighBytesToSeek,    
                             [out] LPDWORD lpdwLowByteSeeked,  
                             [out] LPDWORD lpdwHighByteSeeked, 
                             LPVOID *lpContext           
                             );

FailOnFalse [gle] BackupWrite(
                              HANDLE hFile,                   
                              LPBYTE lpBuffer,                
                              DWORD nNumberOfBytesToWrite,    
                              [out] LPDWORD lpNumberOfBytesWritten, 
                              BOOL bAbort,                    
                              BOOL bProcessSecurity,          
                              [out] LPVOID *lpContext               
                              );

WinError CreateTapePartition(
                             HANDLE hDevice,           
                             TapeCreateDefinitions dwPartitionMethod,  
                             DWORD dwCount,            
                             DWORD dwSize              
                             );

WinError EraseTape(
                   HANDLE hDevice,     
                   EraseTypeToPerform dwEraseType,  
                   BOOL bImmediate     
                   );

WinError GetTapeParameters(
                           HANDLE hDevice,           
                           TypeOfInformation dwOperation,        
                           [out] LPDWORD lpdwSize,         
                           [out] LPVOID lpTapeInformation  
                           );

WinError GetTapePosition(
                         HANDLE hDevice,
                         TapePosition dwPositionType,
                         [out] LPDWORD lpdwPartition,
                         [out] LPDWORD lpdwOffsetLow,
                         [out] LPDWORD lpdwOffsetHigh
                         );

WinError GetTapeStatus(
                       HANDLE hDevice
                       );

WinError PrepareTape(
                     HANDLE hDevice,
                     TapeDevicePreparation dwOperation,
                     BOOL bImmediate
                     );

WinError SetTapeParameters(
                           HANDLE hDevice,
                           InformationToBeSet dwOperation,
                           LPVOID lpTapeInformation
                           );

WinError SetTapePosition(
                         HANDLE hDevice,
                         TypeOfPositioning dwPositionMethod,
                         DWORD dwPartition,
                         DWORD dwOffsetLow,
                         DWORD dwOffsetHigh,
                         BOOL bImmediate
                         );

WinError WriteTapemark(
                       HANDLE hDevice,
                       TapeMarksToWrite dwTapemarkType,
                       DWORD dwTapemarkCount,
                       BOOL bImmediate
                       );





// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         Device Input and Output Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FailOnFalse [gle] DeviceIoControl(
                                  HANDLE hDevice,              
                                  DWORD dwIoControlCode,       
                                  LPVOID lpInBuffer,           
                                  DWORD nInBufferSize,         
                                  LPVOID lpOutBuffer,          
                                  DWORD nOutBufferSize,        
                                  [out] LPDWORD lpBytesReturned,     
                                  LPOVERLAPPED lpOverlapped    
                                  );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         Device Management Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _DEV_BROADCAST_HDR {
    DWORD dbch_size; 
    DWORD dbch_devicetype; 
    DWORD dbch_reserved; 
} DEV_BROADCAST_HDR;
typedef DEV_BROADCAST_HDR *LPDEV_BROADCAST_HDR;

value DWORD HandleType
{
#define DEVICE_NOTIFY_WINDOW_HANDLE     0x00000000
};

value HANDLE HdevnotifyFailNull
{
#define NULL                0 [fail]
};

value HANDLE HdevinfoFailInvalid
{
#define INVALID_HANDLE_VALUE            -1 [fail]
};

value HKEY HkeyFailInvalid
{
#define INVALID_HANDLE_VALUE            -1 [fail]
};

mask DWORD DeviceInterfaceFlags
{
#define SPINT_ACTIVE  0x00000001
#define SPINT_DEFAULT 0x00000002
#define SPINT_REMOVED 0x00000004
};

typedef struct _SP_DEVINFO_DATA {
    DWORD cbSize;
    GUID  ClassGuid;
    DWORD DevInst;
    ULONG_PTR Reserved;
} SP_DEVINFO_DATA, *PSP_DEVINFO_DATA;

value DWORD ControlOptionFlags
{
#define DIGCF_DEFAULT           0x00000001  // only valid with DIGCF_DEVICEINTERFACE
#define DIGCF_PRESENT           0x00000002
#define DIGCF_ALLCLASSES        0x00000004
#define DIGCF_PROFILE           0x00000008
#define DIGCF_DEVICEINTERFACE   0x00000010
};

value DWORD SetupDiopenClassRegKeyExFlags
{
#define DIOCR_INSTALLER   0x00000001    // class installer registry branch
#define DIOCR_INTERFACE   0x00000002    // interface class registry branch
};

module USER32.DLL:
HdevnotifyFailNull [gle] RegisterDeviceNotificationA(
                                                     HANDLE hRecipient,
                                                     LPVOID NotificationFilter,
                                                     HandleType Flags
                                                     );

HdevnotifyFailNull [gle] RegisterDeviceNotificationW(
                                                     HANDLE hRecipient,
                                                     LPVOID NotificationFilter,
                                                     HandleType Flags
                                                     );

FailOnFalse [gle] UnregisterDeviceNotification(
                                               HDEVNOTIFY Handle
                                               ); 

module SETUPAPI.DLL:
HdevinfoFailInvalid [gle] SetupDiCreateDeviceInfoList(
                                                      LPGUID ClassGuid, 
                                                      HWND hwndParent 
                                                      );

HdevinfoFailInvalid [gle] SetupDiCreateDeviceInfoListExA(
                                                         LPGUID ClassGuid, 
                                                         HWND hwndParent, 
                                                         LPCSTR MachineName,
                                                         PVOID Reserved
                                                         );

HdevinfoFailInvalid [gle] SetupDiCreateDeviceInfoListExW(
                                                         LPGUID ClassGuid,   
                                                         HWND   hwndParent,  
                                                         LPCWSTR MachineName, 
                                                         PVOID  Reserved
                                                         );

HkeyFailInvalid [gle] SetupDiCreateDeviceInterfaceRegKeyA(
                                                          HDEVINFO DeviceInfoSet,
                                                          PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                          DWORD Reserved,
                                                          DesiredSecurityAccess samDesired,
                                                          HINF InfHandle, 
                                                          LPCSTR InfSectionName 
                                                          );

HkeyFailInvalid [gle] SetupDiCreateDeviceInterfaceRegKeyW(
                                                          HDEVINFO                  DeviceInfoSet,
                                                          PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                          DWORD                     Reserved,
                                                          DesiredSecurityAccess                    samDesired,
                                                          HINF                      InfHandle,           
                                                          LPCWSTR                   InfSectionName       
                                                          );

FailOnFalse [gle] SetupDiDeleteDeviceInterfaceData(
                                                   HDEVINFO DeviceInfoSet,
                                                   PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
                                                   );

FailOnFalse [gle] SetupDiDeleteDeviceInterfaceRegKey(
                                                     HDEVINFO DeviceInfoSet,
                                                     PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                     DWORD Reserved
                                                     );

FailOnFalse [gle] SetupDiDestroyDeviceInfoList(
                                               HDEVINFO DeviceInfoSet
                                               );

FailOnFalse [gle] SetupDiEnumDeviceInterfaces(
                                              HDEVINFO DeviceInfoSet,
                                              PSP_DEVINFO_DATA DeviceInfoData, 
                                              LPGUID InterfaceClassGuid,
                                              DWORD MemberIndex,
                                              [out] PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
                                              );

HdevinfoFailInvalid [gle] SetupDiGetClassDevsA(
                                               LPGUID ClassGuid, 
                                               LPCSTR Enumerator, 
                                               HWND hwndParent, 
                                               ControlOptionFlags Flags
                                               );

HdevinfoFailInvalid [gle] SetupDiGetClassDevsW(
                                               LPGUID ClassGuid,  
                                               LPCWSTR Enumerator, 
                                               HWND   hwndParent, 
                                               ControlOptionFlags  Flags
                                               );

HdevinfoFailInvalid [gle] SetupDiGetClassDevsExA(
                                                 LPGUID ClassGuid, 
                                                 LPCSTR Enumerator, 
                                                 HWND hwndParent, 
                                                 ControlOptionFlags Flags,
                                                 HDEVINFO DeviceInfoSet, 
                                                 LPCSTR MachineName, 
                                                 PVOID Reserved
                                                 );

HdevinfoFailInvalid [gle] SetupDiGetClassDevsExW(
                                                 LPGUID ClassGuid,   
                                                 LPCWSTR Enumerator,  
                                                 HWND   hwndParent,  
                                                 ControlOptionFlags Flags,
                                                 HDEVINFO DeviceInfoSet, 
                                                 LPCWSTR MachineName, 
                                                 PVOID  Reserved
                                                 );

FailOnFalse [gle] SetupDiGetDeviceInterfaceAlias(
                                                 HDEVINFO DeviceInfoSet,
                                                 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                 LPGUID AliasInterfaceClassGuid,
                                                 [out] PSP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData
                                                 );

FailOnFalse [gle] SetupDiGetDeviceInterfaceDetailA(
                                                   HDEVINFO DeviceInfoSet,
                                                   PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                   [out] PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData, 
                                                   DWORD DeviceInterfaceDetailDataSize,
                                                   [out] PDWORD RequiredSize, 
                                                   [out] PSP_DEVINFO_DATA DeviceInfoData 
                                                   );

FailOnFalse [gle] SetupDiGetDeviceInterfaceDetailW(
                                                   HDEVINFO                           DeviceInfoSet,
                                                   PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
                                                   [out] PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     
                                                   DWORD                              DeviceInterfaceDetailDataSize,
                                                   [out] PDWORD                       RequiredSize,                  
                                                   [out] PSP_DEVINFO_DATA             DeviceInfoData                 
                                                   );

HkeyFailInvalid [gle] SetupDiOpenClassRegKeyExA(
                                                LPGUID ClassGuid,  
                                                DesiredSecurityAccess samDesired,
                                                SetupDiopenClassRegKeyExFlags Flags,
                                                LPCSTR MachineName, 
                                                PVOID Reserved
                                                );

HkeyFailInvalid [gle] SetupDiOpenClassRegKeyExW(
                                                LPGUID ClassGuid,   
                                                DesiredSecurityAccess samDesired,
                                                SetupDiopenClassRegKeyExFlags Flags,
                                                LPCWSTR MachineName, 
                                                PVOID  Reserved
                                                );

FailOnFalse [gle] SetupDiOpenDeviceInterfaceA(
                                              HDEVINFO DeviceInfoSet,
                                              LPCSTR DevicePath,
                                              DWORD OpenFlags,
                                              [out] PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
                                              );

FailOnFalse [gle] SetupDiOpenDeviceInterfaceW(
                                              HDEVINFO                  DeviceInfoSet,
                                              LPCWSTR                   DevicePath,
                                              DWORD                     OpenFlags,
                                              [out] PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData 
                                              );

HkeyFailInvalid [gle] SetupDiOpenDeviceInterfaceRegKey(
                                                       HDEVINFO DeviceInfoSet,
                                                       PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                       DWORD Reserved,
                                                       DesiredSecurityAccess samDesired
                                                       );
module KERNEL32.DLL:

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         Power Management Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

value BYTE ACLineStatusValues
{
#define Offline         0
#define Online          1
#define Unknown         255
};

value BYTE BatteryFlags
{
#define High                    1
#define Low                     2
#define Critical                4
#define Charging                8
#define No_system_battery       128
#define Unknown_status          255
};

typedef struct _SYSTEM_POWER_STATUS {
    ACLineStatusValues ACLineStatus;           
    BatteryFlags  BatteryFlag;           
    BYTE  BatteryLifePercent;    
    BYTE  Reserved1;             
    DWORD  BatteryLifeTime;      
    DWORD  BatteryFullLifeTime;  
} SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

mask DWORD ExecutionRequirements
{
#define ES_SYSTEM_REQUIRED  0x00000001
#define ES_DISPLAY_REQUIRED 0x00000002
#define ES_USER_PRESENT     0x00000004
#define ES_CONTINUOUS       0x80000000
};


value DWORD LATENCY_TIME
{
#define LT_DONT_CARE      0
#define LT_LOWEST_LATENCY 1
};

FailOnFalse GetDevicePowerState(
                                HANDLE hDevice,    
                                [out] BOOL *pfOn         
                                );

FailOnFalse [gle] GetSystemPowerStatus(
                                       LPSYSTEM_POWER_STATUS lpSystemPowerStatus  
                                       );

FailOnFalse IsSystemResumeAutomatic();

FailOnFalse RequestWakeupLatency(
                                 LATENCY_TIME latency      
                                 );

FailOnFalse [gle] SetSystemPowerState(
                                      BOOL fSuspend,  
                                      BOOL fForce     
                                      );

ULONG SetThreadExecutionState(
                                        ExecutionRequirements esFlags  
                                        );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                         Atom Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category AtomFunctions:

value ATOM AtomFailIfZero
{
#define ZERO            0 [fail]
};

AtomFailIfZero [gle] AddAtomA(
                              LPCSTR lpString
                              );

AtomFailIfZero [gle] AddAtomW(
                              LPCWSTR lpString
                              );

ATOM [gle] DeleteAtom(
                      ATOM nAtom   
                      );

AtomFailIfZero [gle] FindAtomA(
                              LPCSTR lpString   
                              );

AtomFailIfZero [gle] FindAtomW(
                              LPCWSTR lpString   
                              );

UintFailIfZero [gle] GetAtomNameA(
                                 ATOM nAtom,       
                                 [out] LPSTR lpBuffer,  
                                 int nSize         
                                 );

UintFailIfZero [gle] GetAtomNameW(
                                 ATOM nAtom,       
                                 [out] LPWSTR lpBuffer,  
                                 int nSize         
                                 );



AtomFailIfZero [gle] GlobalAddAtomA(
                                    LPCSTR lpString
                                    );

AtomFailIfZero [gle] GlobalAddAtomW(
                                    LPCWSTR lpString
                                    );

ATOM [gle] GlobalDeleteAtom(
                            ATOM nAtom
                            );

AtomFailIfZero [gle] GlobalFindAtomA(
                                     LPCSTR lpString
                                     );

AtomFailIfZero [gle] GlobalFindAtomW(
                                     LPCWSTR lpString
                                     );

UintFailIfZero [gle] GlobalGetAtomNameA(
                                        ATOM nAtom,
                                        [out] LPSTR lpBuffer,
                                        int nSize
                                        );

UintFailIfZero [gle] GlobalGetAtomNameW(
                                        ATOM nAtom,
                                        [out] LPWSTR lpBuffer,
                                        int nSize
                                        );

FailOnFalse InitAtomTable(
                          DWORD nSize   
                          );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                        Handle and Object Functions

//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category HandleAndObjectFunctions:

mask DWORD OptionalActions
{
#define DUPLICATE_CLOSE_SOURCE      0x00000001  
#define DUPLICATE_SAME_ACCESS       0x00000002  
};

mask LPDWORD HandleProperties
{
#define HANDLE_FLAG_INHERIT             0x00000001
#define HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002
};

FailOnFalse [gle] CloseHandle(
                              [out] HANDLE hObject   
                              );

FailOnFalse [gle] DuplicateHandle(
                                  HANDLE hSourceProcessHandle,  
                                  HANDLE hSourceHandle,         
                                  HANDLE hTargetProcessHandle,  
                                  [out] LPHANDLE lpTargetHandle,      
                                  DWORD dwDesiredAccess,        
                                  BOOL bInheritHandle,          
                                  OptionalActions dwOptions               
                                  );

FailOnFalse [gle] GetHandleInformation(
                                       HANDLE hObject,    
                                       [out] HandleProperties lpdwFlags  
                                       );

FailOnFalse [gle] SetHandleInformation(
                                       HANDLE hObject,  
                                       DWORD dwMask,    
                                       HandleProperties dwFlags    
                                       );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                Mailslot Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category IOFunctions:

value DWORD MessageWaitLength
{
#define NoMessage                       0 
#define MAILSLOT_WAIT_FOREVER           -1 
};

value LPDWORD NextSizeValue
{
#define MAILSLOT_NO_MESSAGE             -1 
};

HANDLE [gle] CreateMailslotA(
                                          LPCSTR lpName,
                                          DWORD nMaxMessageSize,
                                          MessageWaitLength lReadTimeout,
                                          LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                          );

HANDLE [gle] CreateMailslotW(
                                          LPCWSTR lpName,
                                          DWORD nMaxMessageSize,
                                          MessageWaitLength lReadTimeout,
                                          LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                          );

FailOnFalse [gle] GetMailslotInfo(
                                  HANDLE hMailslot,          
                                  LPDWORD lpMaxMessageSize,  
                                  NextSizeValue lpNextSize,        
                                  LPDWORD lpMessageCount,    
                                  LPDWORD lpReadTimeout      
                                  );

FailOnFalse [gle] SetMailslotInfo(
                                  HANDLE hMailslot,    
                                  MessageWaitLength lReadTimeout   
                                  );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                              Pipe Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category IOFunctions:

value DWORD TimeOutValue
{
#define NMPWAIT_WAIT_FOREVER            0xffffffff
#define NMPWAIT_NOWAIT                  0x00000001
#define NMPWAIT_USE_DEFAULT_WAIT        0x00000000
};


mask DWORD PipeSpecificModes
{
#define PIPE_TYPE_BYTE              0x00000000
#define PIPE_TYPE_MESSAGE           0x00000004
#define PIPE_READMODE_MESSAGE       0x00000002
    // #define PIPE_READMODE_BYTE          0x00000000
    // #define PIPE_WAIT                   0x00000000
#define PIPE_NOWAIT                 0x00000001
};

value LPDWORD PipeType
{
#define PIPE_CLIENT_END             0x00000000
#define PIPE_SERVER_END             0x00000001
    // #define PIPE_TYPE_BYTE              0x00000000
#define PIPE_TYPE_MESSAGE           0x00000004
};




FailOnFalse [gle] CallNamedPipeA(
                                 LPCSTR lpNamedPipeName,  
                                 LPVOID lpInBuffer,        
                                 DWORD nInBufferSize,      
                                 [out] LPVOID lpOutBuffer,       
                                 DWORD nOutBufferSize,     
                                 [out] LPDWORD lpBytesRead,      
                                 TimeOutValue nTimeOut            
                                 );

FailOnFalse [gle] CallNamedPipeW(
                                 LPCWSTR lpNamedPipeName,
                                 LPVOID lpInBuffer,
                                 DWORD nInBufferSize,
                                 [out] LPVOID lpOutBuffer,
                                 DWORD nOutBufferSize,
                                 [out] LPDWORD lpBytesRead,
                                 TimeOutValue nTimeOut
                                 );

FailOnFalse [gle] ConnectNamedPipe(
                                   HANDLE hNamedPipe,          
                                   LPOVERLAPPED lpOverlapped   
                                   );

HANDLE [gle] CreateNamedPipeA(
                                           LPCSTR lpName,                             
                                           AccessMode dwOpenMode,                           
                                           PipeSpecificModes dwPipeMode,                           
                                           DWORD nMaxInstances,                        
                                           DWORD nOutBufferSize,                       
                                           DWORD nInBufferSize,                        
                                           DWORD nDefaultTimeOut,                      
                                           LPSECURITY_ATTRIBUTES lpSecurityAttributes  
                                           );

HANDLE [gle] CreateNamedPipeW(
                                           LPCWSTR lpName,
                                           AccessMode dwOpenMode,
                                           PipeSpecificModes dwPipeMode,
                                           DWORD nMaxInstances,
                                           DWORD nOutBufferSize,
                                           DWORD nInBufferSize,
                                           DWORD nDefaultTimeOut,
                                           LPSECURITY_ATTRIBUTES lpSecurityAttributes
                                           );

FailOnFalse [gle] CreatePipe(
                             [out] PHANDLE hReadPipe,                       
                             [out] PHANDLE hWritePipe,                      
                             LPSECURITY_ATTRIBUTES lpPipeAttributes,  
                             DWORD nSize                              
                             );

FailOnFalse [gle] DisconnectNamedPipe(
                                      HANDLE hNamedPipe   
                                      ); 

FailOnFalse [gle] GetNamedPipeHandleStateA(
                                           HANDLE hNamedPipe,             
                                           [out] PipeSpecificModes lpState,               
                                           [out] LPDWORD lpCurInstances,        
                                           [out] LPDWORD lpMaxCollectionCount,  
                                           [out] LPDWORD lpCollectDataTimeout,  
                                           [out] LPSTR lpUserName,             
                                           DWORD nMaxUserNameSize         
                                           );

FailOnFalse [gle] GetNamedPipeHandleStateW(
                                           HANDLE hNamedPipe,
                                           [out] PipeSpecificModes lpState,
                                           [out] LPDWORD lpCurInstances,
                                           [out] LPDWORD lpMaxCollectionCount,
                                           [out] LPDWORD lpCollectDataTimeout,
                                           [out] LPWSTR lpUserName,
                                           DWORD nMaxUserNameSize
                                           );

FailOnFalse [gle] GetNamedPipeInfo(
                                   HANDLE hNamedPipe,        
                                   PipeType lpFlags,          
                                   [out] LPDWORD lpOutBufferSize,  
                                   [out] LPDWORD lpInBufferSize,   
                                   [out] LPDWORD lpMaxInstances    
                                   );

FailOnFalse [gle] PeekNamedPipe(
                                HANDLE hNamedPipe,              
                                [out] LPVOID lpBuffer,                
                                DWORD nBufferSize,              
                                [out] LPDWORD lpBytesRead,            
                                [out] LPDWORD lpTotalBytesAvail,      
                                [out] LPDWORD lpBytesLeftThisMessage  
                                );

FailOnFalse [gle] SetNamedPipeHandleState(
                                          HANDLE hNamedPipe,             
                                          PipeSpecificModes lpMode,                
                                          LPDWORD lpMaxCollectionCount,  
                                          LPDWORD lpCollectDataTimeout   
                                          );

FailOnFalse [gle] TransactNamedPipe(
                                    HANDLE hNamedPipe,          
                                    LPVOID lpInBuffer,          
                                    DWORD nInBufferSize,        
                                    LPVOID lpOutBuffer,         
                                    DWORD nOutBufferSize,       
                                    [out] LPDWORD lpBytesRead,        
                                    LPOVERLAPPED lpOverlapped   
                                    );

FailOnFalse [gle] WaitNamedPipeA(
                                 LPCSTR lpNamedPipeName,  
                                 TimeOutValue nTimeOut            
                                 );

FailOnFalse [gle] WaitNamedPipeW(
                                 LPCWSTR lpNamedPipeName,
                                 TimeOutValue nTimeOut
                                 );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\memory.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                       Memory Management Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category MemoryManagementFunctions:

mask DWORD AccessProtectionType
{
#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define SEC_FILE           0x800000     
#define SEC_IMAGE         0x1000000     
#define SEC_VLM           0x2000000     
#define SEC_RESERVE       0x4000000     
#define SEC_COMMIT        0x8000000     
#define SEC_NOCACHE      0x10000000     
};


value UINT UintFailIfGlobalMemInvalid
{
#define GMEM_INVALID_HANDLE 0x8000 [fail]
};

value UINT UintFailIfLocalMemInvalid
{
#define LMEM_INVALID_HANDLE 0x8000     [fail]
};

value PVOID64 Pvoid64FailIfNull
{
#define NULL                0    [fail]
};

value LPVOID HeapAllocFailureReturns
{
#define NULL                             0           [fail]
#define STATUS_NO_MEMORY                 0xC0000017L    [fail]
#define STATUS_ACCESS_VIOLATION          0xC0000005L    [fail]
};

mask UINT AllocationAttributes
{
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
// #define GMEM_DDESHARE       0x2000
#define GMEM_SHARE          0x2000
#define GMEM_DISCARDABLE    0x0100
#define GMEM_LOWER          0x1000
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_NOT_BANKED     0x1000
#define GMEM_NOTIFY         0x4000
#define GMEM_ZEROINIT       0x0040
// #define GMEM_MODIFY         0x0080
// #define GMEM_VALID_FLAGS    0x7F72
// #define GMEM_INVALID_HANDLE 0x8000
};

mask UINT LocalAllocationAttributes
{
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_DISCARDABLE    0x0F00
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
// #define LMEM_MODIFY         0x0080
// #define LMEM_VALID_FLAGS    0x0F72
// #define LMEM_INVALID_HANDLE 0x8000
};

typedef struct _MEMORYSTATUS { 
    DWORD dwLength; 
    DWORD dwMemoryLoad; 
    SIZE_T dwTotalPhys; 
    SIZE_T dwAvailPhys; 
    SIZE_T dwTotalPageFile; 
    SIZE_T dwAvailPageFile; 
    SIZE_T dwTotalVirtual; 
    SIZE_T dwAvailVirtual; 
} MEMORYSTATUS, *LPMEMORYSTATUS; 

typedef struct _MEMORYSTATUSEX {
    DWORD dwLength; 
    DWORD dwMemoryLoad; 
    DWORDLONG ullTotalPhys; 
    DWORDLONG ullAvailPhys; 
    DWORDLONG ullTotalPageFile; 
    DWORDLONG ullAvailPageFile; 
    DWORDLONG ullTotalVirtual; 
    DWORDLONG ullAvailVirtual; 
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX; 

mask DWORD HeapAllocationControl
{
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      
#define HEAP_NO_SERIALIZE               0x00000001      
#define HEAP_ZERO_MEMORY                0x00000008      
};

typedef struct _Region {
        DWORD dwCommittedSize;
        DWORD dwUnCommittedSize;
        LPVOID lpFirstBlock;
        LPVOID lpLastBlock;
    } Region;

typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    Region Region;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY; 

value DWORD FileAccessMode
{
#define FILE_MAP_COPY       0x0001
#define FILE_MAP_WRITE      0x0002
#define FILE_MAP_READ       0x0004
};

mask DWORD AllocationType
{
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_4MB_PAGES    0x80000000     
//#define MEM_IMAGE         SEC_IMAGE     
};

typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress; 
    PVOID AllocationBase; 
    AccessProtectionType AllocationProtect; 
    SIZE_T RegionSize; 
    AllocationType State; 
    AllocationType Protect; 
    DWORD Type; 
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION; 

typedef struct _MEMORY_BASIC_INFORMATION_VLM {
    PVOID64 BaseAddress;
    // ULONGLONG BaseAddressAsUlongLong;        Part of a Union
    PVOID64 AllocationBase;
    // ULONGLONG AllocationBaseAsUlongLong;     Part of a Union
    ULONGLONG RegionSize;
    AccessProtectionType AllocationProtect;
    AllocationType State;
    AllocationType Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION_VLM, *PMEMORY_BASIC_INFORMATION_VLM;

typedef struct _SYSTEM_INFO { 
  DWORD  dwOemId; 
  DWORD  dwPageSize; 
  LPVOID lpMinimumApplicationAddress; 
  LPVOID lpMaximumApplicationAddress; 
  DWORD_PTR dwActiveProcessorMask; 
  DWORD dwNumberOfProcessors; 
  DWORD dwProcessorType; 
  DWORD dwAllocationGranularity; 
  WORD wProcessorLevel; 
  WORD wProcessorRevision; 
} SYSTEM_INFO; 

typedef HANDLE HeapHandle;

alias HeapHandle;


module KERNEL32.DLL:

FailOnFalse       [gle] AllocateUserPhysicalPages(HANDLE hProcess,[out] PULONG_PTR NumberOfPages,[out] PULONG_PTR UserPfnArray);
FailOnFalse       [gle] FreeUserPhysicalPages(HANDLE hProcess,[out] PULONG_PTR NumberOfPages,PULONG_PTR UserPfnArray); 
HANDLE            [gle] GetProcessHeap();
DwordFailIfZero   [gle] GetProcessHeaps(DWORD NumberOfHeaps,[out] PHANDLE ProcessHeaps);
UINT                    GetWriteWatch(DWORD dwFlags,PVOID lpBaseAddress,SIZE_T dwRegionSize,[out] PVOID  *lpAddresses,[out] PULONG_PTR lpdwCount,[out] PULONG lpdwGranularity); 
HGLOBAL           [gle] GlobalAlloc(AllocationAttributes uFlags,SIZE_T dwBytes); 
UintFailIfGlobalMemInvalid [gle] GlobalFlags(HGLOBAL hMem);
HGLOBAL           [gle] GlobalFree(HGLOBAL hMem);
HGLOBAL           [gle] GlobalHandle(LPCVOID pMem);
LpvoidFailIfNull  [gle] GlobalLock(HGLOBAL hMem);
VOID                    GlobalMemoryStatus([out] LPMEMORYSTATUS lpBuffer);
FailOnFalse       [gle] GlobalMemoryStatusEx([out] LPMEMORYSTATUSEX lpBuffer);
HGLOBAL           [gle] GlobalReAlloc(HGLOBAL hMem,SIZE_T dwBytes,AllocationAttributes uFlags);
DwordFailIfZero   [gle] GlobalSize(HGLOBAL hMem);
FailOnFalse       [gle] GlobalUnlock(HGLOBAL hMem);

HeapAllocFailureReturns HeapAlloc(HeapHandle hHeap,HeapAllocationControl dwFlags,SIZE_T dwBytes);
LongFailIfZero    [gle] HeapCompact(HeapHandle hHeap,HeapAllocationControl dwFlags);
HeapHandle        [gle] HeapCreate(HeapAllocationControl flOptions,SIZE_T dwInitialSize,SIZE_T dwMaximumSize);
FailOnFalse       [gle] HeapDestroy( [da] HeapHandle hHeap);
FailOnFalse       [gle] HeapFree(HeapHandle hHeap,HeapAllocationControl dwFlags,LPVOID lpMem);
FailOnFalse       [gle] HeapLock(HeapHandle hHeap);
HeapAllocFailureReturns HeapReAlloc(HeapHandle hHeap,HeapAllocationControl dwFlags,LPVOID lpMem,SIZE_T dwBytes);
DwordFailIfNeg1         HeapSize(HeapHandle hHeap,HeapAllocationControl dwFlags,LPCVOID lpMem);
FailOnFalse       [gle] HeapUnlock(HeapHandle hHeap);
FailOnFalse             HeapValidate(HeapHandle hHeap,HeapAllocationControl dwFlags,LPCVOID lpMem);
FailOnFalse       [gle] HeapWalk(HeapHandle hHeap,[out] LPPROCESS_HEAP_ENTRY lpEntry);

HLOCAL            [gle] LocalAlloc(LocalAllocationAttributes uFlags,SIZE_T uBytes);
UintFailIfLocalMemInvalid LocalFlags(HLOCAL hMem);
HLOCAL            [gle] LocalFree(HLOCAL hMem);
HLOCAL            [gle] LocalHandle(LPCVOID pMem);
LpvoidFailIfNull  [gle] LocalLock(HLOCAL hMem);
HLOCAL            [gle] LocalReAlloc(HLOCAL hMem,SIZE_T uBytes,LocalAllocationAttributes uFlags);
LongFailIfZero    [gle] LocalSize(HLOCAL  hMem);
FailOnFalse       [gle] LocalUnlock(HLOCAL hMem);
FailOnFalse       [gle] MapUserPhysicalPages(PVOID lpAddress,ULONG_PTR NumberOfPages,PULONG_PTR UserPfnArray);
FailOnFalse       [gle] MapUserPhysicalPagesScatter(PVOID *VirtualAddresses,ULONG_PTR NumberOfPages,PULONG_PTR PageArray);
UINT                    ResetWriteWatch(LPVOID lpBaseAddress,SIZE_T dwRegionSize); 
LpvoidFailIfNull  [gle] VirtualAlloc(LPVOID lpAddress,SIZE_T dwSize,AllocationType flAllocationType,AccessProtectionType flProtect);
LpvoidFailIfNull  [gle] VirtualAllocEx(HANDLE hProcess,LPVOID lpAddress,SIZE_T dwSize,AllocationType flAllocationType,AccessProtectionType flProtect);
FailOnFalse       [gle] VirtualFree(LPVOID lpAddress,SIZE_T dwSize,AllocationType dwFreeType);
FailOnFalse       [gle] VirtualFreeEx(HANDLE hProcess,LPVOID lpAddress,SIZE_T dwSize,AllocationType dwFreeType);
FailOnFalse       [gle] VirtualLock(LPVOID lpAddress,SIZE_T dwSize);
FailOnFalse       [gle] VirtualProtect(LPVOID lpAddress,SIZE_T dwSize,AccessProtectionType flNewProtect,[out] PDWORD lpflOldProtect);
FailOnFalse       [gle] VirtualProtectEx(HANDLE hProcess,LPVOID lpAddress,SIZE_T dwSize,AccessProtectionType flNewProtect,[out] PDWORD lpflOldProtect);
DWORD                   VirtualQuery(LPCVOID lpAddress,[out] PMEMORY_BASIC_INFORMATION lpBuffer,DWORD dwLength);
DWORD                   VirtualQueryEx(HANDLE hProcess,LPCVOID lpAddress,[out] PMEMORY_BASIC_INFORMATION lpBuffer,DWORD dwLength);
FailOnFalse       [gle] VirtualUnlock(LPVOID lpAddress,SIZE_T dwSize);

// File mapping functions
HANDLE            [gle] CreateFileMappingA(HANDLE hFile,LPSECURITY_ATTRIBUTES lpAttributes,AccessProtectionType flProtect,DWORD dwMaximumSizeHigh,DWORD dwMaximumSizeLow,LPCSTR lpName);
HANDLE            [gle] CreateFileMappingW(HANDLE hFile,LPSECURITY_ATTRIBUTES lpFileMappingAttributes,AccessProtectionType flProtect,DWORD dwMaximumSizeHigh,DWORD dwMaximumSizeLow,LPCWSTR lpName);
FailOnFalse       [gle] FlushViewOfFile (LPCVOID lpBaseAddress,SIZE_T dwNumberOfBytesToFlush);
LpvoidFailIfNull  [gle] MapViewOfFile(HANDLE hFileMappingObject,FileAccessMode dwDesiredAccess,DWORD dwFileOffsetHigh,DWORD dwFileOffsetLow,SIZE_T dwNumberOfBytesToMap);
LpvoidFailIfNull  [gle] MapViewOfFileEx(HANDLE hFileMappingObject,FileAccessMode dwDesiredAccess,DWORD dwFileOffsetHigh,DWORD dwFileOffsetLow,SIZE_T dwNumberOfBytesToMap,LPVOID lpBaseAddress);
HANDLE            [gle] OpenFileMappingA(FileAccessMode dwDesiredAccess,BOOL bInheritHandle,LPCSTR lpName);
HANDLE            [gle] OpenFileMappingW(FileAccessMode dwDesiredAccess,BOOL bInheritHandle,LPCWSTR lpName);
FailOnFalse       [gle] UnmapViewOfFile(LPCVOID lpBaseAddress);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\main.h ===
// ---------------------------------------------------------------------------
// LogExts API Logging Manifest
//
// Created  05-Jan-2000     markder
// ---------------------------------------------------------------------------



// ---------------------------------------------------------------------------
//
// Built-In Types
//
// VOID                 -- 0 bytes
// BYTE                 -- 1 byte   (hex)
// WORD                 -- 2 bytes  (hex)
// DWORD                -- 4 bytes  (hex)
// LONG                 -- 4 bytes  (dec)
// BOOL                 -- Boolean
// FLOAT                -- Float
// DOUBLE               -- Double
// CHAR                 -- Character
// WCHAR                -- Wide character
// LPSTR                -- ANSI string
// LPWSTR               -- Wide character string
//
// GUID                 -- Globally Unique Identifier
// COM_INTERFACE_PTR    -- COM interface pointer
//
// ---------------------------------------------------------------------------

// -------------------------------------- Basic type definitions
typedef LONG            int;
typedef LONG            long;
typedef CHAR            char;
typedef WORD            short;
typedef LONG            INT;
typedef LONG            UINT;
typedef LPSTR           LPCSTR;
typedef LPSTR           *PSTR;
typedef LPWSTR          LPCWSTR;
typedef WORD            USHORT;
typedef WORD *          LPWORD;
typedef DWORD           ULONG;
typedef DWORD           LPVOID;
typedef LPVOID          PVOID;
typedef LPVOID          LPCVOID;
typedef BYTE            *LPBYTE;
typedef BYTE            *PBYTE;
typedef BOOL            *PBOOL;
typedef BOOL            *LPBOOL;
typedef DWORD           *LPDWORD;
typedef DWORD           *PDWORD;
typedef LONG            *LPLONG;
typedef LONG            *PLONG;
typedef LONG            *PULONG;
typedef BYTE            BOOLEAN;
typedef DWORD           HINF;
typedef FLOAT           float;
typedef VOID            void;

// -------------------------------------- Memory management definitions

value DWORD HANDLE
{
#define NULL                       0 [fail]
#define INVALID_HANDLE_VALUE      -1 [fail]
};

typedef HANDLE          HGLOBAL;
typedef HANDLE          HLOCAL;

// -------------------------------------- Windows definitions
typedef DWORD           ATOM;
typedef GUID            *LPGUID;
typedef GUID            *PGUID;
typedef DWORD           HDEVNOTIFY;
typedef DWORD           HDEVINFO;
typedef HANDLE          *LPHANDLE;
typedef DWORD           HMETAFILE;
typedef DWORD           WPARAM;
typedef DWORD           LPARAM;
typedef DWORD           HKEY;
typedef HKEY            *PHKEY;
typedef LPVOID          LPTOP_LEVEL_EXCEPTION_FILTER;
typedef LPVOID          LPTHREAD_START_ROUTINE;
typedef LPVOID          LPFIBER_START_ROUTINE;
typedef DWORD           SIZE_T;
typedef DWORD           LRESULT;
typedef DWORD           HOOKPROC;
typedef DWORD           FARPROC;
typedef LPVOID          LPOVERLAPPED;

// -------------------------------------- 64-bit definitions
typedef DWORD           __int64;
typedef LPVOID          UINT_PTR;
typedef LPVOID          ULONG_PTR;
typedef LPVOID          DWORD_PTR;
typedef LPVOID          PULONG_PTR;

//
// Include winerror.h for the definition of HRESULT
//
#include "winerror.h"

// -------------------------------------- COM definitions
typedef HRESULT         STDAPI;
typedef LPWSTR	        BSTR;
typedef DWORD	        LCID;
typedef WCHAR	        LPOLECHAR;
typedef LPWSTR	        LPOLESTR;
typedef LPWSTR	        LPCOLESTR;
typedef DWORD	        DISPID;
typedef DWORD	        DISPPARAMS;
typedef DWORD	        VARIANT;
typedef DWORD	        EXCEPINFO;
typedef GUID	        *REFGUID;
typedef GUID	        *REFCLSID;
typedef GUID	        *REFIID;


typedef struct _CLSID
{
    DWORD x;
    WORD  s1;
    WORD  s2;
    BYTE  c[8];
} CLSID;


value DWORD ThreadId
{
#define NULL                    0  [fail]
};

value DWORD ProcessId
{
#define NULL                    0  [fail]
};


typedef struct _LONGLONG
{
    DWORD   Low;
    LONG   High;
} LONGLONG;


typedef struct _ULONGLONG
{
    DWORD   Low;
    DWORD   High;
} ULONGLONG;

typedef struct _ULARGE_INTEGER
{
    DWORD   Low;
    DWORD   High;
} ULARGE_INTEGER,*PULARGE_INTEGER;

typedef struct _LARGE_INTEGER
{
    ULONG   Low;
    LONG    High;
} LARGE_INTEGER,*PLARGE_INTEGER;

typedef struct _DWORDLONG
{
    DWORD   Low;
    DWORD   High;
} DWORDLONG;

typedef LPVOID          PVOID64;

typedef WORD        SHORT;
typedef int        *LPINT;
typedef float      *LPFLOAT;
typedef float      *PFLOAT;

// -------------------------------------- Basic error definitions
value BOOL FailOnFalse
{
#define FALSE                   0 [fail]
#define TRUE                    1
};

value LONG IntFailIfNeg1
{
#define NEGATIVE_ONE              -1 [fail]
};

value LONG IntFailIfZero
{
#define ZERO                      0 [fail]
};

value LONG LongFailIfNeg1
{
#define NEGATIVE_ONE              -1 [fail]
};

value LONG LongFailIfZero
{
#define ZERO                       0 [fail]
};

value WORD WordFailIfZero
{
#define ZERO                       0 [fail]
};

value DWORD DwordFailIfZero
{
#define ZERO                       0 [fail]
};

value DWORD HMODULE
{
#define NULL                       0 [fail]
};

value DWORD HINSTANCE
{
#define NULL                       0 [fail]
};

value DWORD UintFailIfZero
{
#define ZERO                       0 [fail]
};


value DWORD DwordFailIf0xFFFFFFFF
{
#define _0xFFFFFFFF                0xFFFFFFFF [fail]
};

value DWORD DwordFailIfNeg1
{
#define NEGATIVE_ONE              -1 [fail]
};

value LPSTR LpstrFailIfNull
{
#define NULL                       0 [fail]
};

value LPWSTR LpwstrFailIfNull
{
#define NULL                       0 [fail]
};

value LPVOID LpvoidFailIfNull
{
#define NULL                       0 [fail]
};

typedef HANDLE  *PHANDLE;
typedef HANDLE  HFILE;

value DWORD HWND
{
#define NULL                       0  [fail]
#define HWND_BOTTOM                1
#define HWND_TOPMOST              -1
#define HWND_NOTOPMOST            -2
};

value int SpoolerError
{
/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000 [fail]
#define SP_ZERO                       0  [fail]
#define SP_ERROR                     -1 [fail]
#define SP_APPABORT                  -2 [fail]
#define SP_USERABORT                 -3 [fail]
#define SP_OUTOFDISK                 -4 [fail]
#define SP_OUTOFMEMORY               -5 [fail]
};

value LONG UnhandledException
{
#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
};

mask DWORD FileFlagsAndAttributes
{
#define FILE_ATTRIBUTE_READONLY             0x00000001  
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  
#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  
#define FILE_ATTRIBUTE_ENCRYPTED            0x00000040  
#define FILE_ATTRIBUTE_NORMAL               0x00000080  
#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200  
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400  
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  
#define FILE_ATTRIBUTE_OFFLINE              0x00001000  
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000  
};

typedef DWORD FTime;

alias FTime;

typedef struct _FILETIME {
    FTime dwLowDateTime; 
    FTime dwHighDateTime; 
} FILETIME, *LPFILETIME, *PFILETIME; 

typedef struct _STARTUPINFOA { 
    DWORD   cb; 
    LPSTR  lpReserved; 
    LPSTR  lpDesktop; 
    LPSTR  lpTitle; 
    DWORD   dwX; 
    DWORD   dwY; 
    DWORD   dwXSize; 
    DWORD   dwYSize; 
    DWORD   dwXCountChars; 
    DWORD   dwYCountChars; 
    DWORD   dwFillAttribute; 
    DWORD   dwFlags; 
    WORD    wShowWindow; 
    WORD    cbReserved2; 
    LPBYTE  lpReserved2; 
    HANDLE  hStdInput; 
    HANDLE  hStdOutput; 
    HANDLE  hStdError; 
} STARTUPINFOA, *LPSTARTUPINFOA; 

typedef struct _STARTUPINFOW { 
    DWORD   cb; 
    LPWSTR  lpReserved; 
    LPWSTR  lpDesktop; 
    LPWSTR  lpTitle; 
    DWORD   dwX; 
    DWORD   dwY; 
    DWORD   dwXSize; 
    DWORD   dwYSize; 
    DWORD   dwXCountChars; 
    DWORD   dwYCountChars; 
    DWORD   dwFillAttribute; 
    DWORD   dwFlags; 
    WORD    wShowWindow; 
    WORD    cbReserved2; 
    LPBYTE  lpReserved2; 
    HANDLE  hStdInput; 
    HANDLE  hStdOutput; 
    HANDLE  hStdError; 
} STARTUPINFOW, *LPSTARTUPINFOW; 

typedef struct _PROCESS_INFORMATION { 
    HANDLE    hProcess; 
    HANDLE    hThread; 
    ProcessId dwProcessId; 
    ThreadId  dwThreadId; 
} PROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _WIN32_FIND_DATAW {
    FileFlagsAndAttributes dwFileAttributes; 
    FILETIME ftCreationTime; 
    FILETIME ftLastAccessTime; 
    FILETIME ftLastWriteTime; 
    DWORD    nFileSizeHigh; 
    DWORD    nFileSizeLow; 
    DWORD    dwReserved0; 
    DWORD    dwReserved1; 
    WCHAR    cFileName[ 260 ]; 
    WCHAR    cAlternateFileName[ 14 ]; 
} WIN32_FIND_DATAW, *LPWIN32_FIND_DATAW; 

typedef struct _WIN32_FIND_DATAA {
    FileFlagsAndAttributes dwFileAttributes; 
    FILETIME ftCreationTime; 
    FILETIME ftLastAccessTime; 
    FILETIME ftLastWriteTime; 
    DWORD    nFileSizeHigh; 
    DWORD    nFileSizeLow; 
    DWORD    dwReserved0; 
    DWORD    dwReserved1; 
    CHAR     cFileName[ 260 ]; 
    CHAR     cAlternateFileName[ 14 ]; 
} WIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; 

typedef struct tagPOINT { 
  LONG x; 
  LONG y; 
} POINT, *PPOINT, *LPPOINT; 

typedef struct _RECT { 
  LONG left; 
  LONG top; 
  LONG right; 
  LONG bottom; 
} RECT, *PRECT, *LPRECT;

typedef struct tagPALETTEENTRY { 
  BYTE peRed; 
  BYTE peGreen; 
  BYTE peBlue; 
  BYTE peFlags; 
} PALETTEENTRY, *LPPALETTEENTRY;

typedef struct tagSIZE { 
  LONG cx; 
  LONG cy; 
} SIZE, *PSIZE, *LPSIZE;

typedef struct  _RGNDATAHEADER
    {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
    }   RGNDATAHEADER;

typedef struct _RGNDATA { 
    RGNDATAHEADER rdh; 
    char          Buffer[1]; 
} RGNDATA, *PRGNDATA, *LPRGNDATA;

typedef struct _RECTL
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;
typedef struct  tagSIZEL
    {
    LONG cx;
    LONG cy;
    }   SIZEL;
typedef SIZEL *PSIZEL;
typedef SIZEL *LPSIZEL;

value DWORD HDC
{
#define NULL                0  [fail]
};

value DWORD HRGN
{
#define ERROR               0  [fail]
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3
};

value DWORD HMENU
{
#define NULL                    0  [fail]
};

value DWORD HRSRC
{
#define NULL                    0  [fail]
};

value DWORD HACCEL
{
#define NULL                    0  [fail]
};

value DWORD WNDPROC
{
#define NULL                    0  [fail]
};

value DWORD HKL
{
#define NULL                    0  [fail]
#define HKL_NEXT                1
};

value DWORD HHOOK
{
#define NULL                    0  [fail]
};


value DWORD WaitReturnValues
{
#define WAIT_OBJECT_0                  0x00000000
#define WAIT_OBJECT_1                  0x00000001
#define WAIT_OBJECT_2                  0x00000002
#define WAIT_OBJECT_3                  0x00000003
#define WAIT_OBJECT_4                  0x00000004
#define WAIT_OBJECT_5                  0x00000005
#define WAIT_OBJECT_6                  0x00000006
#define WAIT_OBJECT_7                  0x00000007
#define WAIT_OBJECT_8                  0x00000008
#define WAIT_OBJECT_9                  0x00000009
#define WAIT_OBJECT_10                 0x0000000A
#define WAIT_OBJECT_11                 0x0000000B
#define WAIT_OBJECT_12                 0x0000000C
#define WAIT_ABANDONED_0               0x00000080
#define WAIT_ABANDONED_1               0x00000081
#define WAIT_ABANDONED_2               0x00000082
#define WAIT_ABANDONED_3               0x00000083
#define WAIT_ABANDONED_4               0x00000084
#define WAIT_ABANDONED_5               0x00000085
#define WAIT_ABANDONED_6               0x00000086
#define WAIT_ABANDONED_7               0x00000087
#define WAIT_ABANDONED_8               0x00000088
#define WAIT_ABANDONED_9               0x00000089
#define WAIT_ABANDONED_10              0x0000008A
#define WAIT_ABANDONED_11              0x0000008B
#define WAIT_ABANDONED_12              0x0000008C
#define WAIT_IO_COMPLETION             0x000000C0
#define WAIT_TIMEOUT                   0x00000102
#define WAIT_FAILED                    0xFFFFFFFF [fail]
};

value DWORD HDESK
{
#define NULL                    0  [fail]
};

value DWORD HWINSTA
{
#define NULL                    0  [fail]
};

value DWORD HMONITOR
{
#define NULL                    0  [fail]
};

value DWORD HPRINTER
{
#define NULL                    0  [fail]
};

typedef DWORD ACCESS_MASK;


typedef struct _SECURITY_ATTRIBUTES { 
    DWORD  nLength; 
    LPVOID lpSecurityDescriptor; 
    BOOL   bInheritHandle; 
} SECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; 




mask DWORD DMFieldFlags
{
/* field selection bits */
#define DM_ORIENTATION      0x00000001L
#define DM_PAPERSIZE        0x00000002L
#define DM_PAPERLENGTH      0x00000004L
#define DM_PAPERWIDTH       0x00000008L
#define DM_SCALE            0x00000010L
#define DM_POSITION         0x00000020L
#define DM_NUP              0x00000040L
#define DM_COPIES           0x00000100L
#define DM_DEFAULTSOURCE    0x00000200L
#define DM_PRINTQUALITY     0x00000400L
#define DM_COLOR            0x00000800L
#define DM_DUPLEX           0x00001000L
#define DM_YRESOLUTION      0x00002000L
#define DM_TTOPTION         0x00004000L
#define DM_COLLATE          0x00008000L
#define DM_FORMNAME         0x00010000L
#define DM_LOGPIXELS        0x00020000L
#define DM_BITSPERPEL       0x00040000L
#define DM_PELSWIDTH        0x00080000L
#define DM_PELSHEIGHT       0x00100000L
#define DM_DISPLAYFLAGS     0x00200000L
#define DM_DISPLAYFREQUENCY 0x00400000L
#define DM_ICMMETHOD        0x00800000L
#define DM_ICMINTENT        0x01000000L
#define DM_MEDIATYPE        0x02000000L
#define DM_DITHERTYPE       0x04000000L
#define DM_PANNINGWIDTH     0x08000000L
#define DM_PANNINGHEIGHT    0x10000000L
};

value WORD DMBinValues
{
/* bin selections */
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_FORMSOURCE    15
#define DMBIN_USER          256     /* device specific bins start here */
};


value WORD DMPrintQualityValues
{
/* print qualities */
#define DMRES_DRAFT         -1
#define DMRES_LOW           -2
#define DMRES_MEDIUM        -3
#define DMRES_HIGH          -4
};

value WORD DMColorEnableValues
{
/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR       2
};

value WORD DMDuplexValues
{
/* duplex enable */
#define DMDUP_SIMPLEX    1
#define DMDUP_VERTICAL   2
#define DMDUP_HORIZONTAL 3
};

value WORD DMTrueTypeValues
{
/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */
#define DMTT_DOWNLOAD_OUTLINE 4 /* download TT fonts as outline soft fonts */
};

value WORD DMCollateValues
{
/* Collation selections */
#define DMCOLLATE_FALSE  0
#define DMCOLLATE_TRUE   1
};

/* DEVMODE dmDisplayFlags flags */

value DWORD DMDisplayFlagFields
{
#define DM_GRAYSCALE            0x00000001 /* This flag is no longer valid */
#define DM_INTERLACED           0x00000002 /* This flag is no longer valid */
#define DMDISPLAYFLAGS_TEXTMODE 0x00000004
};

value DWORD DMLogicalPageValues
{
/* dmNup , multiple logical page per physical page options */
#define DMNUP_SYSTEM        1
#define DMNUP_ONEUP         2
};

value DWORD DMICMMethodValues
{
/* ICM methods */
#define DMICMMETHOD_NONE    1   /* ICM disabled */
#define DMICMMETHOD_SYSTEM  2   /* ICM handled by system */
#define DMICMMETHOD_DRIVER  3   /* ICM handled by driver */
#define DMICMMETHOD_DEVICE  4   /* ICM handled by device */

#define DMICMMETHOD_USER  256   /* Device-specific methods start here */
};
value DWORD DMICMIntentsValues
{
/* ICM Intents */
#define DMICM_SATURATE          1   /* Maximize color saturation */
#define DMICM_CONTRAST          2   /* Maximize color contrast */
#define DMICM_COLORIMETRIC       3   /* Use specific color metric */
#define DMICM_ABS_COLORIMETRIC   4   /* Use specific color metric */

#define DMICM_USER        256   /* Device-specific intents start here */
};
value DWORD DMMediaTypeValues
{
/* Media types */
#define DMMEDIA_STANDARD      1   /* Standard paper */
#define DMMEDIA_TRANSPARENCY  2   /* Transparency */
#define DMMEDIA_GLOSSY        3   /* Glossy paper */

#define DMMEDIA_USER        256   /* Device-specific media start here */
};
value DWORD DMDitherTypeValues
{
/* Dither types */
#define DMDITHER_NONE       1      /* No dithering */
#define DMDITHER_COARSE     2      /* Dither with a coarse brush */
#define DMDITHER_FINE       3      /* Dither with a fine brush */
#define DMDITHER_LINEART    4      /* LineArt dithering */
#define DMDITHER_ERRORDIFFUSION 5  /* LineArt dithering */
#define DMDITHER_RESERVED6      6      /* LineArt dithering */
#define DMDITHER_RESERVED7      7      /* LineArt dithering */
#define DMDITHER_RESERVED8      8      /* LineArt dithering */
#define DMDITHER_RESERVED9      9      /* LineArt dithering */
#define DMDITHER_GRAYSCALE  10     /* Device does grayscaling */

#define DMDITHER_USER     256   /* Device-specific dithers start here */
};


value WORD DMOrientationValues
{
/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2
};

value WORD DMPaperSelectionValues
{
/* paper selections */
#define DMPAPER_LETTER               1  /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL          2  /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID              3  /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER               4  /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL                5  /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT            6  /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE            7  /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3                   8  /* A3 297 x 420 mm                    */
#define DMPAPER_A4                   9  /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL             10  /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5                  11  /* A5 148 x 210 mm                    */
#define DMPAPER_B4                  12  /* B4 (JIS) 250 x 354                 */
#define DMPAPER_B5                  13  /* B5 (JIS) 182 x 257 mm              */
#define DMPAPER_FOLIO               14  /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO              15  /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14               16  /* 10x14 in                           */
#define DMPAPER_11X17               17  /* 11x17 in                           */
#define DMPAPER_NOTE                18  /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9               19  /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10              20  /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11              21  /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12              22  /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14              23  /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET              24  /* C size sheet                       */
#define DMPAPER_DSHEET              25  /* D size sheet                       */
#define DMPAPER_ESHEET              26  /* E size sheet                       */
#define DMPAPER_ENV_DL              27  /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5              28  /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3              29  /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4              30  /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6              31  /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65             32  /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4              33  /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5              34  /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6              35  /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY           36  /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH         37  /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL        38  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US          39  /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
#define DMPAPER_ISO_B4              42  /* B4 (ISO) 250 x 353 mm              */
#define DMPAPER_JAPANESE_POSTCARD   43  /* Japanese Postcard 100 x 148 mm     */
#define DMPAPER_9X11                44  /* 9 x 11 in                          */
#define DMPAPER_10X11               45  /* 10 x 11 in                         */
#define DMPAPER_15X11               46  /* 15 x 11 in                         */
#define DMPAPER_ENV_INVITE          47  /* Envelope Invite 220 x 220 mm       */
#define DMPAPER_RESERVED_48         48  /* RESERVED--DO NOT USE               */
#define DMPAPER_RESERVED_49         49  /* RESERVED--DO NOT USE               */
#define DMPAPER_LETTER_EXTRA        50  /* Letter Extra 9 \275 x 12 in        */
#define DMPAPER_LEGAL_EXTRA         51  /* Legal Extra 9 \275 x 15 in         */
#define DMPAPER_TABLOID_EXTRA       52  /* Tabloid Extra 11.69 x 18 in        */
#define DMPAPER_A4_EXTRA            53  /* A4 Extra 9.27 x 12.69 in           */
#define DMPAPER_LETTER_TRANSVERSE   54  /* Letter Transverse 8 \275 x 11 in   */
#define DMPAPER_A4_TRANSVERSE       55  /* A4 Transverse 210 x 297 mm         */
#define DMPAPER_LETTER_EXTRA_TRANSVERSE 56 /* Letter Extra Transverse 9\275 x 12 in */
#define DMPAPER_A_PLUS              57  /* SuperA/SuperA/A4 227 x 356 mm      */
#define DMPAPER_B_PLUS              58  /* SuperB/SuperB/A3 305 x 487 mm      */
#define DMPAPER_LETTER_PLUS         59  /* Letter Plus 8.5 x 12.69 in         */
#define DMPAPER_A4_PLUS             60  /* A4 Plus 210 x 330 mm               */
#define DMPAPER_A5_TRANSVERSE       61  /* A5 Transverse 148 x 210 mm         */
#define DMPAPER_B5_TRANSVERSE       62  /* B5 (JIS) Transverse 182 x 257 mm   */
#define DMPAPER_A3_EXTRA            63  /* A3 Extra 322 x 445 mm              */
#define DMPAPER_A5_EXTRA            64  /* A5 Extra 174 x 235 mm              */
#define DMPAPER_B5_EXTRA            65  /* B5 (ISO) Extra 201 x 276 mm        */
#define DMPAPER_A2                  66  /* A2 420 x 594 mm                    */
#define DMPAPER_A3_TRANSVERSE       67  /* A3 Transverse 297 x 420 mm         */
#define DMPAPER_A3_EXTRA_TRANSVERSE 68  /* A3 Extra Transverse 322 x 445 mm   */

#define DMPAPER_DBL_JAPANESE_POSTCARD 69 /* Japanese Double Postcard 200 x 148 mm */
#define DMPAPER_A6                  70  /* A6 105 x 148 mm                 */
#define DMPAPER_JENV_KAKU2          71  /* Japanese Envelope Kaku #2       */
#define DMPAPER_JENV_KAKU3          72  /* Japanese Envelope Kaku #3       */
#define DMPAPER_JENV_CHOU3          73  /* Japanese Envelope Chou #3       */
#define DMPAPER_JENV_CHOU4          74  /* Japanese Envelope Chou #4       */
#define DMPAPER_LETTER_ROTATED      75  /* Letter Rotated 11 x 8 1/2 11 in */
#define DMPAPER_A3_ROTATED          76  /* A3 Rotated 420 x 297 mm         */
#define DMPAPER_A4_ROTATED          77  /* A4 Rotated 297 x 210 mm         */
#define DMPAPER_A5_ROTATED          78  /* A5 Rotated 210 x 148 mm         */
#define DMPAPER_B4_JIS_ROTATED      79  /* B4 (JIS) Rotated 364 x 257 mm   */
#define DMPAPER_B5_JIS_ROTATED      80  /* B5 (JIS) Rotated 257 x 182 mm   */
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81 /* Japanese Postcard Rotated 148 x 100 mm */
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82 /* Double Japanese Postcard Rotated 148 x 200 mm */
#define DMPAPER_A6_ROTATED          83  /* A6 Rotated 148 x 105 mm         */
#define DMPAPER_JENV_KAKU2_ROTATED  84  /* Japanese Envelope Kaku #2 Rotated */
#define DMPAPER_JENV_KAKU3_ROTATED  85  /* Japanese Envelope Kaku #3 Rotated */
#define DMPAPER_JENV_CHOU3_ROTATED  86  /* Japanese Envelope Chou #3 Rotated */
#define DMPAPER_JENV_CHOU4_ROTATED  87  /* Japanese Envelope Chou #4 Rotated */
#define DMPAPER_B6_JIS              88  /* B6 (JIS) 128 x 182 mm           */
#define DMPAPER_B6_JIS_ROTATED      89  /* B6 (JIS) Rotated 182 x 128 mm   */
#define DMPAPER_12X11               90  /* 12 x 11 in                      */
#define DMPAPER_JENV_YOU4           91  /* Japanese Envelope You #4        */
#define DMPAPER_JENV_YOU4_ROTATED   92  /* Japanese Envelope You #4 Rotated*/
#define DMPAPER_P16K                93  /* PRC 16K 146 x 215 mm            */
#define DMPAPER_P32K                94  /* PRC 32K 97 x 151 mm             */
#define DMPAPER_P32KBIG             95  /* PRC 32K(Big) 97 x 151 mm        */
#define DMPAPER_PENV_1              96  /* PRC Envelope #1 102 x 165 mm    */
#define DMPAPER_PENV_2              97  /* PRC Envelope #2 102 x 176 mm    */
#define DMPAPER_PENV_3              98  /* PRC Envelope #3 125 x 176 mm    */
#define DMPAPER_PENV_4              99  /* PRC Envelope #4 110 x 208 mm    */
#define DMPAPER_PENV_5              100 /* PRC Envelope #5 110 x 220 mm    */
#define DMPAPER_PENV_6              101 /* PRC Envelope #6 120 x 230 mm    */
#define DMPAPER_PENV_7              102 /* PRC Envelope #7 160 x 230 mm    */
#define DMPAPER_PENV_8              103 /* PRC Envelope #8 120 x 309 mm    */
#define DMPAPER_PENV_9              104 /* PRC Envelope #9 229 x 324 mm    */
#define DMPAPER_PENV_10             105 /* PRC Envelope #10 324 x 458 mm   */
#define DMPAPER_P16K_ROTATED        106 /* PRC 16K Rotated                 */
#define DMPAPER_P32K_ROTATED        107 /* PRC 32K Rotated                 */
#define DMPAPER_P32KBIG_ROTATED     108 /* PRC 32K(Big) Rotated            */
#define DMPAPER_PENV_1_ROTATED      109 /* PRC Envelope #1 Rotated 165 x 102 mm */
#define DMPAPER_PENV_2_ROTATED      110 /* PRC Envelope #2 Rotated 176 x 102 mm */
#define DMPAPER_PENV_3_ROTATED      111 /* PRC Envelope #3 Rotated 176 x 125 mm */
#define DMPAPER_PENV_4_ROTATED      112 /* PRC Envelope #4 Rotated 208 x 110 mm */
#define DMPAPER_PENV_5_ROTATED      113 /* PRC Envelope #5 Rotated 220 x 110 mm */
#define DMPAPER_PENV_6_ROTATED      114 /* PRC Envelope #6 Rotated 230 x 120 mm */
#define DMPAPER_PENV_7_ROTATED      115 /* PRC Envelope #7 Rotated 230 x 160 mm */
#define DMPAPER_PENV_8_ROTATED      116 /* PRC Envelope #8 Rotated 309 x 120 mm */
#define DMPAPER_PENV_9_ROTATED      117 /* PRC Envelope #9 Rotated 324 x 229 mm */
#define DMPAPER_PENV_10_ROTATED     118 /* PRC Envelope #10 Rotated 458 x 324 mm */

#define DMPAPER_USER                256
};


/* size of a device name string */
//#define CCHDEVICENAME 32

/* size of a form name string */
//#define CCHFORMNAME 32

typedef struct _devicemodeA {
    BYTE   dmDeviceName[/*CCHDEVICENAME */ 32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DMFieldFlags dmFields;
//    union {
//      struct {
        DMOrientationValues dmOrientation;
        DMPaperSelectionValues dmPaperSize;
        WORD dmPaperLength;
        WORD dmPaperWidth;
      //};
//      POINTL dmPosition;
//    };
    WORD dmScale;
    WORD dmCopies;
    DMBinValues dmDefaultSource;
    DMPrintQualityValues dmPrintQuality;
    DMColorEnableValues dmColor;
    DMDuplexValues dmDuplex;
    WORD dmYResolution;
    DMTrueTypeValues dmTTOption;
    DMCollateValues dmCollate;
    BYTE   dmFormName[/*CCHFORMNAME */ 32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DMDisplayFlagFields  dmDisplayFlags_OR_Nup;
    DWORD  dmDisplayFrequency;
    DMICMMethodValues  dmICMMethod;
    DMICMIntentsValues  dmICMIntent;
    DMMediaTypeValues  dmMediaType;
    DMDitherTypeValues  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;

typedef struct _devicemodeW {
    WCHAR  dmDeviceName[/*CCHDEVICENAME */ 32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DMFieldFlags dmFields;
//    union {
//      struct {
        DMOrientationValues dmOrientation;
        DMPaperSelectionValues dmPaperSize;
        WORD dmPaperLength;
        WORD dmPaperWidth;
//      };
//      POINTL dmPosition;
//    };
    WORD dmScale;
    WORD dmCopies;
    DMBinValues dmDefaultSource;
    DMPrintQualityValues dmPrintQuality;
    DMColorEnableValues dmColor;
    DMDuplexValues dmDuplex;
    WORD dmYResolution;
    DMTrueTypeValues dmTTOption;
    DMCollateValues dmCollate;
    WCHAR   dmFormName[/*CCHFORMNAME */ 32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DMDisplayFlagFields  dmDisplayFlags_OR_Nup;
    DWORD  dmDisplayFrequency;
    DMICMMethodValues  dmICMMethod;
    DMICMIntentsValues  dmICMIntent;
    DMMediaTypeValues  dmMediaType;
    DMDitherTypeValues  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;





value LONG GdiEscapeCode
{
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define MOUSETRAILS                  39
#define GETDEVICEUNITS               42

#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define DOWNLOADFACE                 514
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048
#define METAFILE_DRIVER              2049
#define GETSETSCREENPARAMS           3072
#define QUERYDIBSUPPORT              3073
#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109
#define SET_MIRROR_MODE              4110
#define OPENCHANNEL                  4110
#define DOWNLOADHEADER               4111
#define CLOSECHANNEL                 4112
#define POSTSCRIPT_PASSTHROUGH       4115
#define ENCAPSULATED_POSTSCRIPT      4116

#define POSTSCRIPT_IDENTIFY          4117   /* new escape for NT5 pscript driver */
#define POSTSCRIPT_INJECTION         4118   /* new escape for NT5 pscript driver */

#define CHECKJPEGFORMAT              4119
#define CHECKPNGFORMAT               4120

#define GET_PS_FEATURESETTING        4121   /* new escape for NT5 pscript driver */

#define SPCLPASSTHROUGH2             4568   /* new escape for NT5 pscript driver */
};

value LONG RegistryType
{
#define REG_NONE                        0   // No value type
#define REG_SZ                          1   // Unicode nul terminated string
#define REG_EXPAND_SZ                   2   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                      3   // Free form binary
#define REG_DWORD                       4   // 32-bit number
#define REG_DWORD_BIG_ENDIAN            5   // 32-bit number
#define REG_LINK                        6   // Symbolic Link (unicode)
#define REG_MULTI_SZ                    7   // Multiple Unicode strings
#define REG_RESOURCE_LIST               8   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR    9  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST  10
#define REG_QWORD                       11  // 64-bit number
};

value LONG ShowWindowCommand
{
#define SW_HIDE             0
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_FORCEMINIMIZE    11
};

mask DWORD AccessMode
{
#define PIPE_ACCESS_INBOUND             0x00000001
#define PIPE_ACCESS_OUTBOUND            0x00000002
#define PIPE_ACCESS_DUPLEX              0x00000003
#define FILE_FLAG_WRITE_THROUGH         0x80000000
#define FILE_FLAG_OVERLAPPED            0x40000000
#define ACCESS_SYSTEM_SECURITY          0x01000000

#define DELETE                          0x00010000
#define READ_CONTROL                    0x00020000
#define WRITE_DAC                       0x00040000
#define WRITE_OWNER                     0x00080000
#define SYNCHRONIZE                     0x00100000

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY          0x01000000

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                 0x02000000

//
//  These are the generic rights.
//

#define GENERIC_READ                    0x80000000
#define GENERIC_WRITE                   0x40000000
#define GENERIC_EXECUTE                 0x20000000
#define GENERIC_ALL                     0x10000000
};

alias HWND;
alias LPVOID;
alias HANDLE;
alias HDC;
alias HRGN;
alias HMENU;
alias HRSRC;
alias HACCEL;
alias HHOOK;
alias HINSTANCE;
alias HMODULE;
alias HKL;
alias HDESK;
alias HWINSTA;
alias HMONITOR;
alias WNDPROC;
alias HPRINTER;
alias ThreadId;
alias ProcessId;

#include "kernel32.h"
#include "user32.h"
#include "gdi32.h"
#include "winspool.h"
#include "version.h"
#include "winsock2.h"
#include "advapi32.h"

//
// uuids.h and com.h are needed for all the headers that have COM definitions.
// Those headers are: shell.h ole32.h ddraw.h dplay.h
//
#include "uuids.h"
#include "com.h"

#include "shell.h"
#include "ole32.h"

//
// ddraw is needed for all the headers that have DirectX definitions.
// Those headers are: d3d.h d3d8.h
//
#include "ddraw.h"
#include "winmm.h"
#include "avifile.h"
#include "dplay.h"
#include "d3d.h"
#include "d3d8.h"
#include "dsound.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\ole32.h ===
module OLE32.DLL:
category ComponentObjectModel:

value DWORD CLSCTX
{
#define CLSCTX_INPROC_SERVER   1 
#define CLSCTX_INPROC_HANDLER  2
#define CLSCTX_LOCAL_SERVER    4
#define CLSCTX_REMOTE_SERVER   16
};

typedef struct  _COAUTHIDENTITY
    {
    USHORT *User;
    ULONG UserLength;
    USHORT *Domain;
    ULONG DomainLength;
    USHORT *Password;
    ULONG PasswordLength;
    ULONG Flags;
    }	COAUTHIDENTITY;

typedef struct  _COAUTHINFO
    {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    LPWSTR pwszServerPrincName;
    DWORD dwAuthnLevel;
    DWORD dwImpersonationLevel;
    COAUTHIDENTITY *pAuthIdentityData;
    DWORD dwCapabilities;
    }	COAUTHINFO;

typedef struct  _COSERVERINFO
    {
    DWORD dwReserved1;
    LPWSTR pwszName;
    COAUTHINFO *pAuthInfo;
    DWORD dwReserved2;
    }	COSERVERINFO;

typedef struct  _COSERVERINFO2
    {
    DWORD dwFlags;
    LPWSTR pwszName;
    COAUTHINFO *pAuthInfo;
    IUnknown** ppCall;
    LPWSTR pwszCodeURL;
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;
    LPWSTR pwszContentType;
    }	COSERVERINFO2;


STDAPI CoCreateInstance(
  REFCLSID rclsid,     //Class identifier (CLSID) of the object
  LPUNKNOWN pUnkOuter, //Pointer to controlling IUnknown
  CLSCTX dwClsContext,  //Context for running executable code
  [iid] REFIID riid,         //Reference to the identifier of the interface
  [out] COM_INTERFACE_PTR * ppv         //Address of output variable that receives 
                       // the interface pointer requested in riid
);

HRESULT CoCreateInstanceEx(
  REFCLSID rclsid,             //CLSID of the object to be created
  IUnknown *punkOuter,         //If part of an aggregate, the 
                               // controlling IUnknown
  CLSCTX dwClsCtx,              //CLSCTX values
  COSERVERINFO *pServerInfo,   //Machine on which the object is to 
                               // be instantiated
  ULONG cmq,                   //Number of MULTI_QI structures in 
                               // pResults
  PVOID *pResults           //Array of MULTI_QI structures
);

STDAPI CoGetClassObject(
  REFCLSID rclsid,  //CLSID associated with the class object
  CLSCTX dwClsContext,
                    //Context for running executable code
  COSERVERINFO * pServerInfo,
                    //Pointer to machine on which the object is to 
                    // be instantiated
  [iid] REFIID riid,      //Reference to the identifier of the interface
  [out] COM_INTERFACE_PTR * ppv      //Address of output variable that receives the 
                    // interface pointer requested in riid
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\processes.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                          Processes and Threads
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category ProcessesAndThreads:

mask DWORD CreateProcessCreationFlags
{     
#define DEBUG_PROCESS               0x00000001
#define DEBUG_ONLY_THIS_PROCESS     0x00000002
#define CREATE_SUSPENDED            0x00000004
#define DETACHED_PROCESS            0x00000008
#define CREATE_NEW_CONSOLE          0x00000010
#define NORMAL_PRIORITY_CLASS       0x00000020
#define IDLE_PRIORITY_CLASS         0x00000040
#define HIGH_PRIORITY_CLASS         0x00000080
#define REALTIME_PRIORITY_CLASS     0x00000100
#define CREATE_NEW_PROCESS_GROUP    0x00000200
#define CREATE_UNICODE_ENVIRONMENT  0x00000400
#define CREATE_SEPARATE_WOW_VDM     0x00000800
#define CREATE_SHARED_WOW_VDM       0x00001000
#define CREATE_FORCEDOS             0x00002000
#define CREATE_DEFAULT_ERROR_MODE   0x04000000
#define CREATE_NO_WINDOW            0x08000000
    
};

value DWORD DLLReason
{
#define DLL_PROCESS_DETACH 0  
#define DLL_PROCESS_ATTACH 1  
#define DLL_THREAD_ATTACH  2  
#define DLL_THREAD_DETACH  3  
};

mask DWORD LoadLibFlags
{
#define DONT_RESOLVE_DLL_REFERENCES     0x00000001
#define LOAD_LIBRARY_AS_DATAFILE        0x00000002
#define LOAD_WITH_ALTERED_SEARCH_PATH   0x00000008
};


value DWORD GetGuiResourcesFlags
{
#define GR_GDIOBJECTS     0
#define GR_USEROBJECTS    1
};

typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *LPIO_COUNTERS;

value LPDWORD ProcessShutdownFlags
{
#define SHUTDOWN_NORETRY                0x00000001
};

/*
typedef struct _FILETIME { 
    DWORD dwLowDateTime; 
    DWORD dwHighDateTime; 
} FILETIME, *LPFILETIME; 
*/

mask DWORD JobObjectAccess
{
#define JOB_OBJECT_ASSIGN_PROCESS           0x0001
#define JOB_OBJECT_SET_ATTRIBUTES           0x0002
#define JOB_OBJECT_QUERY                    0x0004
#define JOB_OBJECT_TERMINATE                0x0008
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES  0x0010
};

mask DWORD ProcessAccess
{
#define PROCESS_CREATE_PROCESS    0x0080  
#define PROCESS_CREATE_THREAD     0x0002  
#define PROCESS_DUP_HANDLE        0x0040  
#define PROCESS_QUERY_INFORMATION 0x0400  
#define PROCESS_SET_QUOTA         0x0100  
#define PROCESS_SET_INFORMATION   0x0200  
#define PROCESS_TERMINATE         0x0001  
#define PROCESS_VM_OPERATION      0x0008  
#define PROCESS_VM_READ           0x0010  
#define PROCESS_VM_WRITE          0x0020  
#define SYNCHRONIZE               0x00100000L
};

mask DWORD ThreadAccess
{
#define SYNCHRONIZE               0x00100000L
#define THREAD_TERMINATE               0x0001  
#define THREAD_SUSPEND_RESUME          0x0002  
#define THREAD_GET_CONTEXT             0x0008  
#define THREAD_SET_CONTEXT             0x0010  
#define THREAD_SET_INFORMATION         0x0020  
#define THREAD_QUERY_INFORMATION       0x0040  
#define THREAD_SET_THREAD_TOKEN        0x0080
};

mask ULONG QueueUserWorkItemFlags
{
#define WT_EXECUTEDEFAULT      0x00000000                           
#define WT_EXECUTEINIOTHREAD   0x00000001                           
#define WT_EXECUTEINUITHREAD   0x00000002                           
#define WT_EXECUTEINWAITTHREAD 0x00000004                           
#define WT_EXECUTEDELETEWAIT   0x00000008                           
#define WT_EXECUTEINLONGTHREAD 0x00000010                           
};

value DWORD SleepExReturnValue
{
#define Interval_Expired            0
#define Returned_due_to_CallBack    0x000000C0 
};

value DWORD ExceptionFlags
{
#define NULL                        0
#define EXCEPTION_NONCONTINUABLE    0x1
};

module KERNEL32.DLL:

FailOnFalse AssignProcessToJobObject(
                                     HANDLE hJob,
                                     HANDLE hProcess
                                     );

module SHELL32.DLL:
LpwstrFailIfNull * [gle] CommandLineToArgvW(
                                            LPCWSTR lpCmdLine,  
                                            INT *pNumArgs       
                                            );

module KERNEL32.DLL:
LpvoidFailIfNull [gle] ConvertThreadToFiber(
                                            LPVOID lpParameter  
                                            );

LpvoidFailIfNull [gle] CreateFiber(
                                   DWORD dwStackSize,  
                                   LPFIBER_START_ROUTINE lpStartAddress, 
                                   LPVOID lpParameter                    
                                   );

HANDLE [gle] CreateJobObjectA(
                                        LPSECURITY_ATTRIBUTES lpJobAttributes,
                                        LPCSTR lpName
                                        );

HANDLE [gle] CreateJobObjectW(
                                        LPSECURITY_ATTRIBUTES lpJobAttributes,
                                        LPCWSTR lpName
                                        );

FailOnFalse [gle] CreateProcessA(
                                 LPCSTR lpApplicationName,  
                                 LPSTR lpCommandLine,       
                                 LPSECURITY_ATTRIBUTES lpProcessAttributes, 
                                 LPSECURITY_ATTRIBUTES lpThreadAttributes, 
                                 BOOL bInheritHandles,       
                                 CreateProcessCreationFlags dwCreationFlags,      
                                 LPVOID lpEnvironment,       
                                 LPCSTR lpCurrentDirectory, 
                                 [out] LPSTARTUPINFOA lpStartupInfo, 
                                 [out] LPPROCESS_INFORMATION lpProcessInformation 
                                 );

FailOnFalse [gle] CreateProcessW(
                                 LPCWSTR lpApplicationName,  
                                 LPWSTR lpCommandLine,       
                                 LPSECURITY_ATTRIBUTES lpProcessAttributes, 
                                 LPSECURITY_ATTRIBUTES lpThreadAttributes, 
                                 BOOL bInheritHandles,       
                                 CreateProcessCreationFlags dwCreationFlags,      
                                 LPVOID lpEnvironment,       
                                 LPCWSTR lpCurrentDirectory, 
                                 LPSTARTUPINFOW lpStartupInfo, 
                                 LPPROCESS_INFORMATION lpProcessInformation 
                                 );

module ADVAPI32.DLL:
FailOnFalse [gle] CreateProcessAsUserA (
                                        HANDLE hToken,
                                        LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        CreateProcessCreationFlags dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation
                                        );

FailOnFalse [gle] CreateProcessAsUserW (
                                        HANDLE hToken,
                                        LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        CreateProcessCreationFlags dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation
                                        );

FailOnFalse [gle] CreateProcessWithLogonW(
                                          LPCWSTR lpUsername,            
                                          LPCWSTR lpDomain,              
                                          LPCWSTR lpPassword,            
                                          LPCWSTR lpApplicationName,     
                                          LPWSTR lpCommandLine,          
                                          CreateProcessCreationFlags dwCreationFlags,         
                                          LPVOID lpEnvironment,          
                                          LPCWSTR lpCurrentDirectory,    
                                          LPSTARTUPINFOW lpStartupInfo, 
                                          LPPROCESS_INFORMATION lpProcessInformation 
                                          );

module KERNEL32.DLL:
HANDLE [gle] CreateRemoteThread(
                                          HANDLE hProcess,        
                                          LPSECURITY_ATTRIBUTES lpThreadAttributes,  
                                          DWORD dwStackSize,      
                                          LPTHREAD_START_ROUTINE lpStartAddress, 
                                          LPVOID lpParameter,     
                                          CreateProcessCreationFlags dwCreationFlags,  
                                          LPDWORD lpThreadId      
                                          );

HANDLE [gle] CreateThread(
                                    LPSECURITY_ATTRIBUTES lpThreadAttributes,  
                                    DWORD dwStackSize,                         
                                    LPTHREAD_START_ROUTINE lpStartAddress,     
                                    LPVOID lpParameter,                        
                                    CreateProcessCreationFlags dwCreationFlags,                     
                                    LPDWORD lpThreadId                         
                                    );

VOID DeleteFiber(
                 LPVOID lpFiber   
                 );

VOID ExitProcess(
                 UINT uExitCode   
                 );

VOID ExitThread(
                DWORD dwExitCode   
                );

FailOnFalse [gle] FreeEnvironmentStringsA(
                                          LPSTR lpszEnvironmentBlock
                                          );

FailOnFalse [gle] FreeEnvironmentStringsW(
                                          LPWSTR lpszEnvironmentBlock
                                          );

LPSTR GetCommandLineA();

LPWSTR GetCommandLineW();

DWORD GetCurrentProcess();

ProcessId GetCurrentProcessId();
ThreadId GetCurrentThreadId();

HANDLE GetCurrentThread();

LPSTR GetEnvironmentStrings();

LPWSTR GetEnvironmentStringsW();

DwordFailIfZero GetEnvironmentVariableA(
                                        LPCSTR lpName,
                                        [out] LPSTR lpBuffer,
                                        DWORD nSize
                                        );

DwordFailIfZero GetEnvironmentVariableW(
                                        LPCWSTR lpName,
                                        [out] LPWSTR lpBuffer,
                                        DWORD nSize
                                        );

FailOnFalse [gle] GetExitCodeProcess(
                                     HANDLE hProcess,     
                                     [out] LPDWORD lpExitCode   
                                     );

FailOnFalse [gle] GetExitCodeThread(
                                    HANDLE hThread,      
                                    [out] LPDWORD lpExitCode   
                                    );

module USER32.DLL:
DwordFailIfZero GetGuiResources (
                                 HANDLE hProcess,  
                                 GetGuiResourcesFlags uiFlags
                                 );

module KERNEL32.DLL:
DWORD GetPriorityClass(
                       HANDLE hProcess   
                       );

FailOnFalse [gle] GetProcessAffinityMask(
                                         HANDLE hProcess,                
                                         [out] LPDWORD lpProcessAffinityMask,  
                                         [out] LPDWORD lpSystemAffinityMask    
                                         );

FailOnFalse [gle] GetProcessIoCounters(
                                       HANDLE hProcess,
                                       [out] LPIO_COUNTERS lpIoCounters
                                       );

FailOnFalse [gle] GetProcessPriorityBoost(
                                          HANDLE hProcess,  
                                          [out] PBOOL pDisablePriorityBoost     
                                          );

FailOnFalse [gle] GetProcessShutdownParameters(
                                               [out] LPDWORD lpdwLevel, 
                                               [out] ProcessShutdownFlags *lpdwFlags  
                                               );

FailOnFalse [gle] GetProcessTimes(
                                  HANDLE hProcess,           
                                  [out] LPFILETIME lpCreationTime, 
                                  [out] LPFILETIME lpExitTime,     
                                  [out] LPFILETIME lpKernelTime,   
                                  [out] LPFILETIME lpUserTime      
                                  );

DwordFailIfZero [gle] GetProcessVersion(
                                        ProcessId dwProcessId
                                        );

FailOnFalse [gle] GetProcessWorkingSetSize(
                                           HANDLE hProcess,                 
                                           [out] LPDWORD lpMinimumWorkingSetSize, 
                                           [out] LPDWORD lpMaximumWorkingSetSize  
                                           );

VOID GetStartupInfoA(
                    [out] LPSTARTUPINFOA lpStartupInfo   
                    );

VOID GetStartupInfoW(
                    [out] LPSTARTUPINFOW lpStartupInfo   
                    );

ThreadPriority [gle] GetThreadPriority(
                                                     HANDLE hThread   
                                                     );

FailOnFalse [gle] GetThreadPriorityBoost(
                                         HANDLE hThread,              
                                         [out] PBOOL pDisablePriorityBoost  
                                         );

FailOnFalse [gle] GetThreadTimes(
                                 HANDLE hThread,             
                                 [out] LPFILETIME lpCreationTime,  
                                 [out] LPFILETIME lpExitTime,      
                                 [out] LPFILETIME lpKernelTime,    
                                 [out] LPFILETIME lpUserTime       
                                 );

HANDLE [gle] OpenJobObjectA(
                                     JobObjectAccess dwDesiredAccess,
                                     BOOL bInheritHandles,
                                     LPCSTR lpName
                                     );

HANDLE [gle] OpenJobObjectW(
                                     JobObjectAccess dwDesiredAccess,
                                     BOOL bInheritHandles,
                                     LPCWSTR lpName
                                     );

HANDLE [gle] OpenProcess(
                                   ProcessAccess dwDesiredAccess,  
                                   BOOL bInheritHandle,    
                                   DWORD dwProcessId       
                                   );

HANDLE [gle] OpenThread(
                                  ThreadAccess dwDesiredAccess,
                                  BOOL bInheritHandle,
                                  DWORD dwThreadId
                                  );

FailOnFalse [gle] QueryInformationJobObject(
                                            HANDLE hJob,
                                            DWORD JobObjectInformationClass,
                                            LPVOID lpJobObjectInformation,
                                            DWORD cbJobObjectInformationLength,
                                            [out] LPDWORD lpReturnLength
                                            );

FailOnFalse QueueUserWorkItem(
                              LPTHREAD_START_ROUTINE Function,
                              PVOID Context,
                              QueueUserWorkItemFlags Flags
                              );

VOID RaiseException(DWORD  dwExceptionCode,
                    ExceptionFlags dwExceptionFlags,
                    DWORD  nNumberOfArguments,
                    DWORD* lpArguments);

DwordFailIf0xFFFFFFFF [gle] ResumeThread(
                                         HANDLE hThread   
                                         );

FailOnFalse [gle] SetEnvironmentVariableA(
                                          LPCSTR lpName,
                                          LPCSTR lpValue
                                          );

FailOnFalse [gle] SetEnvironmentVariableW(
                                          LPCWSTR lpName,
                                          LPCWSTR lpValue
                                          );

BOOL SetInformationJobObject(
                             HANDLE hJob,
                             DWORD JobObjectInformationClass,
                             LPVOID lpJobObjectInformation,
                             DWORD cbJobObjectInformationLength
                             );

FailOnFalse [gle] SetPriorityClass(
                                   HANDLE hProcess,        
                                   CreateProcessCreationFlags dwPriorityClass   
                                   );

FailOnFalse [gle] SetProcessAffinityMask(
                                         HANDLE hProcess,             
                                         DWORD dwProcessAffinityMask  
                                         );

FailOnFalse [gle] SetProcessPriorityBoost(
                                          HANDLE hProcess,           
                                          BOOL DisablePriorityBoost  
                                          );

FailOnFalse [gle] SetProcessShutdownParameters(
                                               DWORD dwLevel,  
                                               ProcessShutdownFlags dwFlags   
                                               );

FailOnFalse [gle] SetProcessWorkingSetSize(
                                           HANDLE hProcess,                
                                           DWORD dwMinimumWorkingSetSize,  
                                           DWORD dwMaximumWorkingSetSize   
                                           );

DwordFailIfZero SetThreadAffinityMask (
                                       HANDLE hThread,             
                                       DWORD dwThreadAffinityMask  
                                       );

DwordFailIfNeg1 [gle] SetThreadIdealProcessor(
                                              HANDLE hThread,         
                                              DWORD dwIdealProcessor  
                                              );

FailOnFalse [gle] SetThreadPriority(
                                    HANDLE hThread, 
                                    ThreadPriority nPriority   
                                    );

FailOnFalse [gle] SetThreadPriorityBoost(
                                         HANDLE hThread,            
                                         BOOL DisablePriorityBoost  
                                         );

VOID Sleep(
           DWORD dwMilliseconds   
           );

SleepExReturnValue SleepEx(
                           DWORD dwMilliseconds,  
                           BOOL bAlertable        
                           );

DwordFailIf0xFFFFFFFF [gle] SuspendThread(
                                          HANDLE hThread   
                                          );

VOID SwitchToFiber(
                   LPVOID lpFiber  
                   );

BOOL SwitchToThread();

FailOnFalse [gle] TerminateJobObject(
                                     HANDLE hJob,
                                     UINT uExitCode
                                     );

FailOnFalse [gle] TerminateProcess(
                                   HANDLE hProcess, 
                                   UINT uExitCode   
                                   );

FailOnFalse [gle] TerminateThread(
                                  HANDLE hThread,    
                                  DWORD dwExitCode   
                                  );

category ThreadLocalStorage:
DwordFailIf0xFFFFFFFF [gle] TlsAlloc();

FailOnFalse [gle] TlsFree(
                          DWORD dwTlsIndex   
                          );

LpvoidFailIfNull [gle] TlsGetValue(DWORD dwTlsIndex);

FailOnFalse [gle] TlsSetValue(
                              DWORD dwTlsIndex,  
                              LPVOID lpTlsValue  
                              );

category ProcessesAndThreads:

module USER32.DLL:
FailOnFalse [gle] UserHandleGrantAccess(
                                        HANDLE hUserHandle,
                                        HANDLE hJob, 
                                        BOOL bGrant
                                        );

module KERNEL32.DLL:
WinError WinExec(
                 LPCSTR lpCmdLine,  
                 UINT uCmdShow      
                 );



DwordFailIfZero [gle] DisableThreadLibraryCalls(HMODULE hLibModule);

DwordFailIfZero [gle] FreeLibrary(
                             HMODULE hLibModule
                             );

DwordFailIfZero [gle] GetModuleFileNameA(
                                  HMODULE hModule,   
                                  [out] LPSTR lpFilename, 
                                  DWORD nSize        
                                  );
  
DwordFailIfZero [gle] GetModuleFileNameW(
                                  HMODULE hModule,   
                                  [out] LPWSTR lpFilename, 
                                  DWORD nSize        
                                  );


VOID FreeLibraryAndExitThread(
                              HMODULE hLibModule,
                              DWORD dwExitCode
                             );
  


DwordFailIfZero [gle] GetModuleHandleA(
                                       LPCSTR lpModuleName
                                       );

DwordFailIfZero [gle] GetModuleHandleW(
                                       LPCWSTR lpModuleName
                                       );



LpvoidFailIfNull [gle] GetProcAddress(
                                      HMODULE hModule,
                                      LPCSTR lpProcName
                                      );

HMODULE [gle] LoadLibraryA(LPCSTR lpLibFileName);
HMODULE [gle] LoadLibraryW(LPCWSTR lpLibFileName);

                                
HMODULE [gle] LoadLibraryExA(LPCSTR lpLibFileName,
                             HANDLE hFile,
                             LoadLibFlags dwFlags);

HMODULE [gle] LoadLibraryExW(LPCWSTR lpLibFileName,
                             HANDLE hFile,
                             LoadLibFlags dwFlags);

DWORD LoadModule(
                LPCSTR lpModuleName,     
                LPVOID lpParameterBlock  
                );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\registry.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                              Registry Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
category RegistryFunctions:


value DWORD SpecialOptions
{
#define REG_OPTION_RESERVED        0x00000000L
#define REG_OPTION_NON_VOLATILE    0x00000000L   
#define REG_OPTION_VOLATILE        0x00000001L   
#define REG_OPTION_CREATE_LINK     0x00000002L   
#define REG_OPTION_BACKUP_RESTORE  0x00000004L   
#define REG_OPTION_OPEN_LINK       0x00000008L   
};


value LPDWORD DispositionValue 
{
#define REG_CREATED_NEW_KEY         0x00000001L   
#define REG_OPENED_EXISTING_KEY     0x00000002L
};

value HKEY HandleToOpenKey
{
#define HKEY_CLASSES_ROOT           0x80000000
#define HKEY_CURRENT_USER           0x80000001
#define HKEY_LOCAL_MACHINE          0x80000002
#define HKEY_USERS                  0x80000003
#define HKEY_PERFORMANCE_DATA       0x80000004
#define HKEY_CURRENT_CONFIG         0x80000005
#define HKEY_DYN_DATA               0x80000006
};

alias HandleToOpenKey;

mask DWORD ChangesToReport
{
#define REG_NOTIFY_CHANGE_NAME          0x00000001L
#define REG_NOTIFY_CHANGE_ATTRIBUTES    0x00000002L
#define REG_NOTIFY_CHANGE_LAST_SET      0x00000004L
#define REG_NOTIFY_CHANGE_SECURITY      0x00000008L
};

/*
typedef struct _FILETIME { 
    FTime dwLowDateTime; 
    FTime dwHighDateTime; 
}FILETIME, *PFILETIME; 
*/

module KERNEL32.DLL:

UINT        GetPrivateProfileIntA(LPCSTR lpAppName,LPCSTR lpKeyName,INT nDefault,LPCSTR lpFileName);
UINT        GetPrivateProfileIntW(LPCWSTR lpAppName,LPCWSTR lpKeyName,INT nDefault,LPCWSTR lpFileName); 
DWORD       GetPrivateProfileSectionA(LPCSTR lpAppName,[out] LPSTR lpReturnedString,DWORD nSize,LPCSTR lpFileName);
DWORD       GetPrivateProfileSectionW(LPCWSTR lpAppName,[out] LPWSTR lpReturnedString,DWORD nSize,LPCWSTR lpFileName);
DWORD       GetPrivateProfileSectionNamesA([out] LPSTR lpszReturnBuffer,DWORD nSize,LPCSTR lpFileName);
DWORD       GetPrivateProfileSectionNamesW([out] LPWSTR lpszReturnBuffer,DWORD nSize,LPCWSTR lpFileName);
DWORD       GetPrivateProfileStringA(LPCSTR lpAppName,LPCSTR lpKeyName,LPCSTR lpDefault,[out] LPSTR lpReturnedString,DWORD nSize,LPCSTR lpFileName);
DWORD       GetPrivateProfileStringW(LPCWSTR lpAppName,LPCWSTR lpKeyName,LPCWSTR lpDefault,[out] LPWSTR lpReturnedString,DWORD nSize,LPCWSTR lpFileName);
FailOnFalse GetPrivateProfileStructA(LPCSTR lpszSection,LPCSTR lpszKey,[out] LPVOID lpStruct,UINT uSizeStruct,LPCSTR szFile);
FailOnFalse GetPrivateProfileStructW(LPCWSTR lpszSection,LPCWSTR lpszKey,[out] LPVOID   lpStruct,UINT uSizeStruct,LPCWSTR szFile);
UINT        GetProfileIntA(LPCSTR lpAppName,LPCSTR lpKeyName,INT nDefault);
UINT        GetProfileIntW(LPCWSTR lpAppName,LPCWSTR lpKeyName,INT nDefault);
DWORD       GetProfileSectionA(LPCSTR lpAppName,[out] LPSTR lpReturnedString,DWORD nSize);
DWORD       GetProfileSectionW(LPCWSTR lpAppName,[out] LPWSTR lpReturnedString,DWORD nSize);
DWORD       GetProfileStringA(LPCSTR lpAppName,LPCSTR lpKeyName,LPCSTR lpDefault,[out] LPSTR lpReturnedString,DWORD nSize);
DWORD       GetProfileStringW(LPCWSTR lpAppName,LPCWSTR lpKeyName,LPCWSTR lpDefault,[out] LPWSTR lpReturnedString,DWORD nSize);
FailOnFalse  [gle]  WritePrivateProfileSectionA(LPCSTR lpAppName,LPCSTR lpString,LPCSTR lpFileName);
FailOnFalse  [gle]  WritePrivateProfileSectionW(LPCWSTR lpAppName,LPCWSTR lpString,LPCWSTR lpFileName);
FailOnFalse  [gle]  WritePrivateProfileStringA(LPCSTR lpAppName,LPCSTR lpKeyName,LPCSTR lpString,LPCSTR lpFileName);
FailOnFalse  [gle]  WritePrivateProfileStringW(LPCWSTR lpAppName,LPCWSTR lpKeyName,LPCWSTR lpString,LPCWSTR lpFileName);
FailOnFalse  [gle]  WritePrivateProfileStructA(LPCSTR lpszSection,LPCSTR lpszKey,LPVOID lpStruct,UINT uSizeStruct,LPCSTR szFile);
FailOnFalse  [gle]  WritePrivateProfileStructW(LPCWSTR lpszSection,LPCWSTR lpszKey,LPVOID lpStruct,UINT uSizeStruct,LPCWSTR szFile);
FailOnFalse  [gle]  WriteProfileSectionA(LPCSTR lpAppName,LPCSTR lpString);
FailOnFalse  [gle]  WriteProfileSectionW(LPCWSTR lpAppName,LPCWSTR lpString);
FailOnFalse  [gle]  WriteProfileStringA(LPCSTR lpAppName,LPCSTR lpKeyName,LPCSTR lpString);
FailOnFalse  [gle]  WriteProfileStringW(LPCWSTR lpAppName,LPCWSTR lpKeyName,LPCWSTR lpString);

module  ADVAPI32.DLL:

WinError    RegCloseKey( [da] HandleToOpenKey hKey);
WinError    RegConnectRegistryA(LPCSTR lpMachineName,HandleToOpenKey hKey,[out] HandleToOpenKey* phkResult);
WinError    RegConnectRegistryW(LPCWSTR lpMachineName,HandleToOpenKey hKey,[out] HandleToOpenKey* phkResult);
WinError    RegCreateKeyA(HandleToOpenKey hKey,LPCSTR lpSubKey,[out] HandleToOpenKey* phkResult);
WinError    RegCreateKeyW(HandleToOpenKey hKey,LPCWSTR lpSubKey,[out] HandleToOpenKey* phkResult);
WinError    RegCreateKeyExA(HandleToOpenKey hKey,LPCSTR lpSubKey,DWORD Reserved,LPSTR lpClass,SpecialOptions dwOptions,DesiredSecurityAccess samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,[out] HandleToOpenKey* phkResult,[out] DispositionValue lpdwDisposition);
WinError    RegCreateKeyExW(HandleToOpenKey hKey,LPCWSTR lpSubKey,DWORD Reserved,LPWSTR lpClass,SpecialOptions dwOptions,DesiredSecurityAccess samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,[out] HandleToOpenKey* phkResult,[out] DispositionValue lpdwDisposition);
WinError    RegDeleteKeyA(HandleToOpenKey hKey,LPCSTR lpSubKey);
WinError    RegDeleteKeyW(HandleToOpenKey hKey,LPCWSTR lpSubKey);
WinError    RegDeleteValueA(HandleToOpenKey hKey,LPCSTR lpValueName);
WinError    RegDeleteValueW(HandleToOpenKey hKey,LPCWSTR lpValueName);
WinError    RegEnumKeyA(HandleToOpenKey hKey,DWORD dwIndex,[out] LPSTR lpName,DWORD cbName);
WinError    RegEnumKeyW(HandleToOpenKey hKey,DWORD dwIndex,[out] LPWSTR lpName,DWORD cbName);
WinError    RegEnumKeyExA(HandleToOpenKey hKey,DWORD dwIndex,[out] LPSTR lpName,[out] LPDWORD lpcName,LPDWORD lpReserved,[out] LPSTR lpClass,[out] LPDWORD lpcClass,[out] PFILETIME lpftLastWriteTime);
WinError    RegEnumKeyExW(HandleToOpenKey hKey,DWORD dwIndex,[out] LPWSTR lpName,[out] LPDWORD lpcbName,LPDWORD lpReserved,[out] LPWSTR lpClass,[out] LPDWORD lpcbClass,[out] PFILETIME lpftLastWriteTime);
WinError    RegEnumValueA(HandleToOpenKey hKey,DWORD dwIndex,[out] LPSTR lpValueName,[out] LPDWORD lpcValueName,LPDWORD lpReserved,[out] LPDWORD lpType,[out] LPBYTE lpData,LPDWORD lpcbData);
WinError    RegEnumValueW(HandleToOpenKey hKey,DWORD dwIndex,[out] LPWSTR lpValueName,[out] LPDWORD lpcbValueName,LPDWORD lpReserved,[out] LPDWORD lpType,[out] LPBYTE lpData,LPDWORD lpcbData);
WinError    RegFlushKey(HandleToOpenKey hKey);
WinError    RegLoadKeyA(HandleToOpenKey hKey,LPCSTR lpSubKey,LPCSTR lpFile);
WinError    RegLoadKeyW(HandleToOpenKey    hKey,LPCWSTR  lpSubKey,LPCWSTR  lpFile);
WinError    RegNotifyChangeKeyValue(HandleToOpenKey hKey,BOOL bWatchSubtree,ChangesToReport dwNotifyFilter,HANDLE hEvent,BOOL fAsynchronous);
WinError    RegOpenCurrentUser(DesiredSecurityAccess samDesired,[out] HandleToOpenKey* phkResult);
WinError    RegOpenKeyA(HandleToOpenKey hKey,LPCSTR lpSubKey,[out] HandleToOpenKey* phkResult);
WinError    RegOpenKeyW(HandleToOpenKey hKey,LPCWSTR lpSubKey,[out] HandleToOpenKey* phkResult);
WinError    RegOpenKeyExA(HandleToOpenKey hKey,LPCSTR lpSubKey,DWORD ulOptions,DesiredSecurityAccess samDesired,[out] HandleToOpenKey* phkResult);
WinError    RegOpenKeyExW(HandleToOpenKey hKey,LPCWSTR lpSubKey,DWORD ulOptions,DesiredSecurityAccess samDesired,[out] HandleToOpenKey* phkResult);
WinError    RegOpenUserClassesRoot(HANDLE hToken,DWORD  dwOptions,DesiredSecurityAccess samDesired,[out] HandleToOpenKey*  phkResult);
WinError    RegOverridePredefKey(HandleToOpenKey hKey,HandleToOpenKey hNewHKey);
WinError    RegQueryInfoKeyA(HandleToOpenKey hKey,[out] LPSTR lpClass,[out] LPDWORD lpcClass,LPDWORD lpReserved,[out] LPDWORD lpcSubKeys,[out] LPDWORD lpcMaxSubKeyLen,[out] LPDWORD lpcMaxClassLen,[out] LPDWORD lpcValues,[out] LPDWORD lpcMaxValueNameLen,[out] LPDWORD lpcMaxValueLen,[out] LPDWORD lpcbSecurityDescriptor,[out] PFILETIME lpftLastWriteTime);
WinError    RegQueryInfoKeyW(HandleToOpenKey hKey,[out] LPWSTR lpClass,[out] LPDWORD lpcbClass,LPDWORD lpReserved,[out] LPDWORD lpcSubKeys,[out] LPDWORD lpcbMaxSubKeyLen,[out] LPDWORD lpcbMaxClassLen,[out] LPDWORD lpcValues,    [out] LPDWORD lpcbMaxValueNameLen,[out] LPDWORD lpcbMaxValueLen,[out] LPDWORD lpcbSecurityDescriptor,[out] PFILETIME lpftLastWriteTime);
WinError    RegQueryMultipleValuesA(HandleToOpenKey hKey,[out] LPVOID val_list,DWORD num_vals,[out] LPSTR lpValueBuf,[out] LPDWORD ldwTotsize);
WinError    RegQueryMultipleValuesW(HandleToOpenKey hKey,[out] LPVOID val_list,DWORD num_vals,[out] LPWSTR lpValueBuf,[out] LPDWORD ldwTotsize);
WinError    RegQueryValueA(HandleToOpenKey hKey,LPCSTR lpSubKey,[out] LPSTR lpValue,[out] PLONG lpcbValue);
WinError    RegQueryValueW(HandleToOpenKey hKey,LPCWSTR lpSubKey,[out] LPWSTR lpValue,[out] PLONG   lpcbValue);
WinError    RegQueryValueExA(HandleToOpenKey hKey,LPCSTR lpValueName,LPDWORD lpReserved,[out] LPDWORD lpType,[out] LPBYTE lpData,[out] LPDWORD lpcbData);
WinError    RegQueryValueExW(HandleToOpenKey hKey,LPCWSTR lpValueName,LPDWORD lpReserved,[out] LPDWORD lpType,[out] LPBYTE lpData,[out] LPDWORD lpcbData);
WinError    RegReplaceKeyA(HandleToOpenKey hKey,LPCSTR lpSubKey,LPCSTR lpNewFile,LPCSTR lpOldFile);
WinError    RegReplaceKeyW(HandleToOpenKey  hKey,LPCWSTR  lpSubKey,LPCWSTR  lpNewFile,LPCWSTR  lpOldFile);
WinError    RegRestoreKeyA(HandleToOpenKey hKey,LPCSTR lpFile,DWORD dwFlags);
WinError    RegRestoreKeyW(HandleToOpenKey hKey,LPCWSTR lpFile,DWORD   dwFlags);
WinError    RegSaveKeyA(HandleToOpenKey hKey,LPCSTR lpFile,LPSECURITY_ATTRIBUTES lpSecurityAttributes);
WinError    RegSaveKeyW(HandleToOpenKey hKey,LPCWSTR lpFile,LPSECURITY_ATTRIBUTES lpSecurityAttributes);
WinError    RegSetValueA(HandleToOpenKey hKey,LPCSTR lpSubKey,DWORD dwType,LPCSTR lpData,DWORD cbData);
WinError    RegSetValueW(HandleToOpenKey hKey,LPCWSTR lpSubKey,DWORD dwType,LPCWSTR lpData,DWORD cbData);
WinError    RegSetValueExA(HandleToOpenKey hKey,LPCSTR lpValueName,DWORD Reserved,DWORD dwType,BYTE *lpData,DWORD cbData);
WinError    RegSetValueExW(HandleToOpenKey hKey,LPCWSTR lpValueName,DWORD Reserved,DWORD dwType,BYTE* lpData,DWORD cbData);
WinError    RegUnLoadKeyA(HandleToOpenKey hKey,LPCSTR lpSubKey);
WinError    RegUnLoadKeyW(HandleToOpenKey hKey,LPCWSTR lpSubKey);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\strings.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                String manipulation Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
module KERNEL32.DLL:
category StringManipulation:

int CompareStringA(
  LCID Locale,       // locale identifier
  DWORD dwCmpFlags,  // comparison-style options
  LPCSTR lpString1, // first string
  int cchCount1,     // size of first string
  LPCSTR lpString2, // second string
  int cchCount2      // size of second string
);

int CompareStringW(
  LCID Locale,       // locale identifier
  DWORD dwCmpFlags,  // comparison-style options
  LPCWSTR lpString1, // first string
  int cchCount1,     // size of first string
  LPCWSTR lpString2, // second string
  int cchCount2      // size of second string
);

LPSTR lstrcat(
  LPSTR lpString1,  // first string
  LPCSTR lpString2  // second string
);

LPSTR lstrcatA(
  LPSTR lpString1,  // first string
  LPCSTR lpString2  // second string
);

LPWSTR lstrcatW(
  LPWSTR lpString1,  // first string
  LPCWSTR lpString2  // second string
);

int lstrcmp(
  LPCSTR lpString1,  // first string
  LPCSTR lpString2   // second string
);

int lstrcmpA(
  LPCSTR lpString1,  // first string
  LPCSTR lpString2   // second string
);

int lstrcmpW(
  LPCWSTR lpString1,  // first string
  LPCWSTR lpString2   // second string
);

int lstrcmpi(
  LPCSTR lpString1,  // first string
  LPCSTR lpString2   // second string
);

int lstrcmpiA(
  LPCSTR lpString1,  // first string
  LPCSTR lpString2   // second string
);

int lstrcmpiW(
  LPCWSTR lpString1,  // first string
  LPCWSTR lpString2   // second string
);

LPSTR lstrcpy(
  LPSTR lpString1,  // destination buffer
  LPCSTR lpString2  // string
);

LPSTR lstrcpyA(
  LPSTR lpString1,  // destination buffer
  LPCSTR lpString2  // string
);

LPWSTR lstrcpyW(
  LPWSTR lpString1,  // destination buffer
  LPCWSTR lpString2  // string
);

LPSTR lstrcpyn(
  [out] LPSTR lpString1,  // destination buffer
  LPCSTR lpString2, // string
  int iMaxLength     // number of characters to copy
);

LPSTR lstrcpynA(
  LPSTR lpString1,  // destination buffer
  LPCSTR lpString2, // string
  int iMaxLength     // number of characters to copy
);

LPWSTR lstrcpynW(
  LPWSTR lpString1,  // destination buffer
  LPCWSTR lpString2, // string
  int iMaxLength     // number of characters to copy
);

int lstrlen(
    LPCSTR lpszString
    );

int lstrlenA(
    LPCSTR lpszString
    );

int lstrlenW(
    LPCWSTR lpszString
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\uuids.h ===
struct __declspec(uuid("00000000-0000-0000-C000-000000000046")) IUnknown;
struct __declspec(uuid("00000001-0000-0000-C000-000000000046")) IClassFactory;
struct __declspec(uuid("00000002-0000-0000-C000-000000000046")) IMalloc;
struct __declspec(uuid("00020400-0000-0000-C000-000000000046")) IDispatch;
struct __declspec(uuid("0000010b-0000-0000-C000-000000000046")) IPersistFile;
struct __declspec(uuid("0000010c-0000-0000-C000-000000000046")) IPersist;
struct __declspec(uuid("0000013D-0000-0000-C000-000000000046")) IClientSecurity;
struct __declspec(uuid("0000013E-0000-0000-C000-000000000046")) IServerSecurity;
struct __declspec(uuid("00000140-0000-0000-C000-000000000046")) IClassActivator;
struct __declspec(uuid("00020d00-0000-0000-c000-000000000046")) IRichEditOle;
struct __declspec(uuid("00020d03-0000-0000-c000-000000000046")) IRichEditOleCallback;
struct __declspec(uuid("000214e1-0000-0000-c000-000000000046")) INewShortcutHookA;
struct __declspec(uuid("000214e2-0000-0000-c000-000000000046")) IShellBrowser;
struct __declspec(uuid("000214e3-0000-0000-c000-000000000046")) IShellView;
struct __declspec(uuid("000214e4-0000-0000-c000-000000000046")) IContextMenu;
struct __declspec(uuid("000214e5-0000-0000-c000-000000000046")) IShellIcon;
struct __declspec(uuid("000214e6-0000-0000-c000-000000000046")) IShellFolder;
struct __declspec(uuid("000214e8-0000-0000-c000-000000000046")) IShellExtInit;
struct __declspec(uuid("000214e9-0000-0000-c000-000000000046")) IShellPropSheetExt;
struct __declspec(uuid("000214ea-0000-0000-c000-000000000046")) IPersistFolder;
struct __declspec(uuid("000214eb-0000-0000-c000-000000000046")) IExtractIconA;
struct __declspec(uuid("000214ee-0000-0000-c000-000000000046")) IShellLinkA;
struct __declspec(uuid("000214f0-0000-0000-c000-000000000046")) IFileViewerA;
struct __declspec(uuid("000214f1-0000-0000-c000-000000000046")) ICommDlgBrowser;
struct __declspec(uuid("000214f2-0000-0000-c000-000000000046")) IEnumIDList;
struct __declspec(uuid("000214f3-0000-0000-c000-000000000046")) IFileViewerSite;
struct __declspec(uuid("000214f4-0000-0000-c000-000000000046")) IContextMenu2;
struct __declspec(uuid("000214f5-0000-0000-c000-000000000046")) IShellExecuteHookA;
struct __declspec(uuid("000214f7-0000-0000-c000-000000000046")) INewShortcutHookW;
struct __declspec(uuid("000214f8-0000-0000-c000-000000000046")) IFileViewerW;
struct __declspec(uuid("000214f9-0000-0000-c000-000000000046")) IShellLinkW;
struct __declspec(uuid("000214fa-0000-0000-c000-000000000046")) IExtractIconW;
struct __declspec(uuid("000214fb-0000-0000-c000-000000000046")) IShellExecuteHookW;
struct __declspec(uuid("00021500-0000-0000-c000-000000000046")) IQueryInfo;
struct __declspec(uuid("0002DF05-0000-0000-C000-000000000046")) IWebBrowserApp;
struct __declspec(uuid("0002E000-0000-0000-C000-000000000046")) IEnumGUID;
struct __declspec(uuid("0002E011-0000-0000-C000-000000000046")) IEnumCATEGORYINFO;
struct __declspec(uuid("0002E012-0000-0000-C000-000000000046")) ICatRegister;
struct __declspec(uuid("0002E013-0000-0000-C000-000000000046")) ICatInformation;
struct __declspec(uuid("012dd920-7b26-11d0-8ca9-00a0c92dbfe8")) IDockingWindow;
struct __declspec(uuid("3050f4e9-98b5-11cf-bb82-00aa00bdce0b")) IHTMLControlElement;
struct __declspec(uuid("085FB2C0-0DF8-11D1-8F4B-00A0C905413F")) ISubscriptionMgr;
struct __declspec(uuid("08EC3E00-50B0-11CF-960C-0080C7F4EE85")) FolderItemVerb;
struct __declspec(uuid("0c6c4200-c589-11d0-999a-00c04fd655e1")) IShellIconOverlayIdentifier;
struct __declspec(uuid("1008C4A0-7613-11CF-9AF1-0020AF6E72F4")) IChannelHook;
struct __declspec(uuid("163BB1E0-6E00-11CF-837A-48DC04C10000")) IHTMLLocation;
struct __declspec(uuid("1CFF0050-6FDD-11D0-9328-00A0C90DCAA9")) IActiveScriptParseProcedureOld;
struct __declspec(uuid("1F8352C0-50B0-11CF-960C-0080C7F4EE85")) FolderItemVerbs;
struct __declspec(uuid("1ac3d9f0-175c-11d1-95be-00609797ea4f")) IPersistFolder2;
struct __declspec(uuid("275C23E1-3747-11D0-9FEA-00AA003F8646")) IMultiLanguage;
struct __declspec(uuid("275C23E3-3747-11D0-9FEA-00AA003F8646")) IEnumCodePage;
struct __declspec(uuid("2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8")) IDockingWindowSite;
struct __declspec(uuid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBodyElement;
struct __declspec(uuid("3050F1D9-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontElement;
struct __declspec(uuid("3050F1DA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAnchorElement;
struct __declspec(uuid("3050F1DD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLUListElement;
struct __declspec(uuid("3050F1DE-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOListElement;
struct __declspec(uuid("3050F1E0-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLIElement;
struct __declspec(uuid("3050F1F0-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBRElement;
struct __declspec(uuid("3050F1F1-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDListElement;
struct __declspec(uuid("3050F1F2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDDElement;
struct __declspec(uuid("3050F1F3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDTElement;
struct __declspec(uuid("3050F1F4-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLHRElement;
struct __declspec(uuid("3050F1F5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLParaElement;
struct __declspec(uuid("3050F1F6-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLHeaderElement;
struct __declspec(uuid("3050F1F7-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFormElement;
struct __declspec(uuid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLElement;
struct __declspec(uuid("3050F200-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDivElement;
struct __declspec(uuid("3050F202-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBaseFontElement;
struct __declspec(uuid("3050F203-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMetaElement;
struct __declspec(uuid("3050F204-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBaseElement;
struct __declspec(uuid("3050F205-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLinkElement;
struct __declspec(uuid("3050F206-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLIsIndexElement;
struct __declspec(uuid("3050F207-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLNextIdElement;
struct __declspec(uuid("3050F208-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBlockElement;
struct __declspec(uuid("3050F209-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLUnknownElement;
struct __declspec(uuid("3050F20A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLPhraseElement;
struct __declspec(uuid("3050F20C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLCommentElement;
struct __declspec(uuid("3050F20E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLListElement;
struct __declspec(uuid("3050F211-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionElement;
struct __declspec(uuid("3050F212-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDivPosition;
struct __declspec(uuid("3050F216-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDialog;
struct __declspec(uuid("3050F218-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextElement;
struct __declspec(uuid("3050F21E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTable;
struct __declspec(uuid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLElementCollection;
struct __declspec(uuid("3050F220-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTxtRange;
struct __declspec(uuid("3050F230-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextContainer;
struct __declspec(uuid("3050F23A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCol;
struct __declspec(uuid("3050F23B-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableSection;
struct __declspec(uuid("3050F23C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableRow;
struct __declspec(uuid("3050F23D-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCell;
struct __declspec(uuid("3050F240-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLImgElement;
struct __declspec(uuid("3050F244-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSelectElement;
struct __declspec(uuid("3050F24F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLObjectElement;
struct __declspec(uuid("3050F25A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSelectionObject;
struct __declspec(uuid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyle;
struct __declspec(uuid("3050F25F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLEmbedElement;
struct __declspec(uuid("3050F265-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAreaElement;
struct __declspec(uuid("3050F266-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMapElement;
struct __declspec(uuid("3050F28B-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLScriptElement;
struct __declspec(uuid("3050F29C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLControlRange;
struct __declspec(uuid("3050F2A4-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputHiddenElement;
struct __declspec(uuid("3050F2A6-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputTextElement;
struct __declspec(uuid("3050F2AA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextAreaElement;
struct __declspec(uuid("3050F2AD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputFileElement;
struct __declspec(uuid("3050F2B2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputButtonElement;
struct __declspec(uuid("3050F2B5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMarqueeElement;
struct __declspec(uuid("3050F2BB-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLButtonElement;
struct __declspec(uuid("3050F2BC-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionButtonElement;
struct __declspec(uuid("3050F2C2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputImage;
struct __declspec(uuid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheet;
struct __declspec(uuid("3050F2E5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetRulesCollection;
struct __declspec(uuid("3050F2EB-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCaption;
struct __declspec(uuid("3050F2F4-98B5-11CF-BB82-00AA00BDCE0B")) IViewFilterSite;
struct __declspec(uuid("3050F311-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameBase;
struct __declspec(uuid("3050F313-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameElement;
struct __declspec(uuid("3050F315-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLIFrameElement;
struct __declspec(uuid("3050F319-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameSetElement;
struct __declspec(uuid("3050F322-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTitleElement;
struct __declspec(uuid("3050F32A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLabelElement;
struct __declspec(uuid("3050F32D-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLEventObj;
struct __declspec(uuid("3050F357-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetRule;
struct __declspec(uuid("3050F35C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLScreen;
struct __declspec(uuid("3050F35F-98B5-11CF-BB82-00AA00BDCE0B")) ITimerService;
struct __declspec(uuid("3050F360-98B5-11CF-BB82-00AA00BDCE0B")) ITimer;
struct __declspec(uuid("3050F361-98B5-11CF-BB82-00AA00BDCE0B")) ITimerSink;
struct __declspec(uuid("3050F369-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBGsound;
struct __declspec(uuid("3050F372-98B5-11CF-BB82-00AA00BDCE0B")) IViewTransition;
struct __declspec(uuid("3050F373-98B5-11CF-BB82-00AA00BDCE0B")) IViewTransitionSite;
struct __declspec(uuid("3050F375-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleElement;
struct __declspec(uuid("3050F376-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontNamesCollection;
struct __declspec(uuid("3050F377-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontSizesCollection;
struct __declspec(uuid("3050F378-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionsHolder;
struct __declspec(uuid("3050F37E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetsCollection;
struct __declspec(uuid("3050F383-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAreasCollection;
struct __declspec(uuid("3050F38A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLNoShowElement;
struct __declspec(uuid("3050F38C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionElementFactory;
struct __declspec(uuid("3050F38E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLImageElementFactory;
struct __declspec(uuid("3050F3CF-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLRuleStyle;
struct __declspec(uuid("3050F3D5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleFontFace;
struct __declspec(uuid("3050F3E5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSpanFlow;
struct __declspec(uuid("3050F3E7-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFieldSetElement;
struct __declspec(uuid("3050F3EA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLegendElement;
struct __declspec(uuid("3050F3EC-98B5-11CF-BB82-00AA00BDCE0B")) ICSSFilter;
struct __declspec(uuid("3050F3ED-98B5-11CF-BB82-00AA00BDCE0B")) ICSSFilterSite;
struct __declspec(uuid("3050F3EE-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFiltersCollection;
struct __declspec(uuid("3050F3F0-98B5-11CF-BB82-00AA00BDCE0B")) ICustomDoc;
struct __declspec(uuid("3050F3F2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDatabinding;
struct __declspec(uuid("3050F3F3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSpanElement;
struct __declspec(uuid("3050F3FC-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMimeTypesCollection;
struct __declspec(uuid("3050F3FD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLPluginsCollection;
struct __declspec(uuid("3050F401-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOpsProfile;
struct __declspec(uuid("3050f3d7-98b5-11cf-bb82-00aa00bdce0b")) IImgCtx;
struct __declspec(uuid("332C4425-26CB-11D0-B483-00C04FD90119")) IHTMLDocument2;
struct __declspec(uuid("332C4426-26CB-11D0-B483-00C04FD90119")) IHTMLFramesCollection2;
struct __declspec(uuid("332C4427-26CB-11D0-B483-00C04FD90119")) IHTMLWindow2;
struct __declspec(uuid("359F3441-BD4A-11D0-B188-00AA0038C969")) IMLangFontLink;
struct __declspec(uuid("359F3443-BD4A-11D0-B188-00AA0038C969")) IMLangCodePages;
struct __declspec(uuid("3C374A41-BAE4-11CF-BF7D-00AA006946EE")) IUrlHistoryStg;
struct __declspec(uuid("3C374A42-BAE4-11CF-BF7D-00AA006946EE")) IEnumSTATURL;
struct __declspec(uuid("3DC39D1D-C030-11D0-B81B-00C04FC9B31F")) IEnumRfc1766;
struct __declspec(uuid("47d2657a-7b27-11d0-8ca9-00a0c92dbfe8")) IDockingWindowFrame;
struct __declspec(uuid("539698A0-CDCA-11CF-A5EB-00AA0047A063")) IActiveScriptSiteInterruptPoll;
struct __declspec(uuid("618736e0-3c3d-11cf-810c-00aa00389b71")) IAccessible;
struct __declspec(uuid("626FC520-A41E-11CF-A731-00A0C9082637")) IHTMLDocument;
struct __declspec(uuid("63CDBCB0-C1B1-11D0-9336-00A0C90DCAA9")) IBindEventHandler;
struct __declspec(uuid("68284faa-6a48-11d0-8c78-00c04fd918b4")) IInputObject;
struct __declspec(uuid("71EE5B20-FB04-11d1-B3A8-00A0C911E8B2")) IActiveScriptParseProcedure2;
struct __declspec(uuid("729FE2F8-1EA8-11D1-8F85-00C04FC2FBE1")) IShellUIHelper;
struct __declspec(uuid("744129E0-CBE5-11CE-8350-444553540000")) FolderItems;
struct __declspec(uuid("79EAC9C2-BAF9-11CE-8C82-00AA004BA90B")) IHlinkSite;
struct __declspec(uuid("79EAC9C3-BAF9-11CE-8C82-00AA004BA90B")) IHlink;
struct __declspec(uuid("79EAC9C4-BAF9-11CE-8C82-00AA004BA90B")) IHlinkTarget;
struct __declspec(uuid("79EAC9C5-BAF9-11CE-8C82-00AA004BA90B")) IHlinkFrame;
struct __declspec(uuid("79EAC9C6-BAF9-11CE-8C82-00AA004BA90B")) IEnumHLITEM;
struct __declspec(uuid("79EAC9C7-BAF9-11CE-8C82-00AA004BA90B")) IHlinkBrowseContext;
struct __declspec(uuid("79EAC9CB-BAF9-11CE-8C82-00AA004BA90B")) IExtensionServices;
struct __declspec(uuid("7d688a70-c613-11d0-999b-00c04fd655e1")) IShellIconOverlay;
struct __declspec(uuid("85BD8E82-0FBA-11D1-90C3-00C04FC2F568")) IChannelMgr;
struct __declspec(uuid("85CB6900-4D95-11CF-960C-0080C7F4EE85")) IShellWindows;
struct __declspec(uuid("88A05C00-F000-11CE-8350-444553540000")) IShellLinkDual;
struct __declspec(uuid("88e39e80-3578-11cf-ae69-08002b2e1262")) IShellView2;
struct __declspec(uuid("89BCB740-6119-101A-BCB7-00DD010655AF")) IFilter;
struct __declspec(uuid("91A565C1-E38F-11D0-94BF-00A0C9055CBF")) IPersistHistory;
struct __declspec(uuid("9BA05970-F6A8-11CF-A442-00A0C90A8F39")) IFolderViewOC;
struct __declspec(uuid("A3CCEDF3-2DE2-11D0-86F4-00A0C913F750")) IImageDecodeFilter;
struct __declspec(uuid("A4C65425-0F82-11D1-90C3-00C04FC2F568")) IEnumChannels;
struct __declspec(uuid("A6EF9860-C720-11D0-9337-00A0C90DCAA9")) IDispatchEx;
struct __declspec(uuid("A6EF9861-C720-11D0-9337-00A0C90DCAA9")) IDispError;
struct __declspec(uuid("A6EF9862-C720-11D0-9337-00A0C90DCAA9")) IVariantChangeType;
struct __declspec(uuid("AA5B6A80-B834-11D0-932F-00A0C90DCAA9")) IActiveScriptParseProcedure;
struct __declspec(uuid("AFA0DC11-C313-11D0-831A-00C04FD5AE38")) IUrlHistoryStg2;
struct __declspec(uuid("B722BCC5-4E68-101B-A2BC-00AA00404770")) IOleDocument;
struct __declspec(uuid("B722BCC6-4E68-101B-A2BC-00AA00404770")) IOleDocumentView;
struct __declspec(uuid("B722BCC7-4E68-101B-A2BC-00AA00404770")) IOleDocumentSite;
struct __declspec(uuid("B722BCC8-4E68-101B-A2BC-00AA00404770")) IEnumOleDocumentViews;
struct __declspec(uuid("B722BCC9-4E68-101B-A2BC-00AA00404770")) IPrint;
struct __declspec(uuid("B722BCCA-4E68-101B-A2BC-00AA00404770")) IContinueCallback;
struct __declspec(uuid("B722BCCB-4E68-101B-A2BC-00AA00404770")) IOleCommandTarget;
struct __declspec(uuid("B8DA6310-E19B-11D0-933C-00A0C90DCAA9")) IActiveScriptStats;
struct __declspec(uuid("BAA342A0-2DED-11D0-86F4-00A0C913F750")) IImageDecodeEventSink;
struct __declspec(uuid("BB1A2AE1-A4F9-11CF-8F20-00805F2CD064")) IActiveScript;
struct __declspec(uuid("BB1A2AE2-A4F9-11CF-8F20-00805F2CD064")) IActiveScriptParse;
struct __declspec(uuid("BC40BEC1-C493-11D0-831B-00C04FD5AE38")) IUrlHistoryNotify;
struct __declspec(uuid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A")) IDocHostUIHandler;
struct __declspec(uuid("C04D65CE-B70D-11D0-B188-00AA0038C969")) IMLangString;
struct __declspec(uuid("C04D65D0-B70D-11D0-B188-00AA0038C969")) IMLangStringWStr;
struct __declspec(uuid("C04D65D2-B70D-11D0-B188-00AA0038C969")) IMLangStringAStr;
struct __declspec(uuid("C4D244B0-D43E-11CF-893B-00AA00BDCE1A")) IDocHostShowUI;
struct __declspec(uuid("CA04B7E6-0D21-11D1-8CC5-00C04FC2B085")) IObjectIdentity;
struct __declspec(uuid("CB5BDC81-93C1-11CF-8F20-00805F2CD064")) IObjectSafety;
struct __declspec(uuid("D10F6761-83E9-11CF-8F20-00805F2CD064")) IActiveScriptSiteWindow;
struct __declspec(uuid("D24ACD21-BA72-11D0-B188-00AA0038C969")) IMLangStringBufW;
struct __declspec(uuid("D24ACD23-BA72-11D0-B188-00AA0038C969")) IMLangStringBufA;
struct __declspec(uuid("D30C1661-CDAF-11D0-8A3E-00C04FC9E26E")) IWebBrowser2;
struct __declspec(uuid("D66D6F98-CDAA-11D0-B822-00C04FC9B31F")) IMLangConvertCharset;
struct __declspec(uuid("D8F015C0-C278-11CE-A49E-444553540000")) IShellDispatch;
struct __declspec(uuid("D9E89500-30FA-11D0-B724-00AA006C1A01")) IMapMIMEToCLSID;
struct __declspec(uuid("DB01A1E3-A42B-11CF-8F20-00805F2CD064")) IActiveScriptSite;
struct __declspec(uuid("E0E270C0-C0BE-11D0-8FE4-00A0C90A6341")) OLEDBSimpleProvider;
struct __declspec(uuid("E0E270C1-C0BE-11D0-8FE4-00A0C90A6341")) OLEDBSimpleProviderListener;
struct __declspec(uuid("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")) IShellFolderViewDual;
struct __declspec(uuid("EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B")) IWebBrowser;
struct __declspec(uuid("EAE1BA61-A4ED-11CF-8F20-00805F2CD064")) IActiveScriptError;
struct __declspec(uuid("F5BE2EE1-BFD7-11D0-B188-00AA0038C969")) IMLangLineBreakConsole;
struct __declspec(uuid("F77459A0-BF9A-11CF-BA4E-00C04FD70816")) IMimeInfo;
struct __declspec(uuid("FAC32C80-CBE4-11CE-8350-444553540000")) FolderItem;
struct __declspec(uuid("FECEAAA2-8405-11CF-8BA1-00AA00476DA6")) IOmHistory;
struct __declspec(uuid("FECEAAA5-8405-11CF-8BA1-00AA00476DA6")) IOmNavigator;
struct __declspec(uuid("ac60f6a0-0fd9-11d0-99cb-00c04fd64497")) IURLSearchHook;
struct __declspec(uuid("bcfce0a0-ec17-11d0-8d10-00a0c90f2719")) IContextMenu3;
struct __declspec(uuid("cabb0da0-da57-11cf-9974-0020afd79762")) IUniformResourceLocatorW;
struct __declspec(uuid("eb0fe172-1a3a-11d0-89b3-00a0c90a90ac")) IDeskBand;
struct __declspec(uuid("f1db8392-7331-11d0-8c99-00a0c92dbfe8")) IInputObjectSite;
struct __declspec(uuid("f490eb00-1240-11d1-9888-006097deacf9")) IActiveDesktop;
struct __declspec(uuid("fbf23b80-e3f0-101b-8488-00aa003e56f8")) IUniformResourceLocatorA;

// CoClasses:

class __declspec(uuid("00000017-0000-0000-c000-000000000046")) StdMarshal;
class __declspec(uuid("0000001b-0000-0000-c000-000000000046")) IdentityUnmarshal;
class __declspec(uuid("0000001c-0000-0000-c000-000000000046")) InProcFreeMarshaler;
class __declspec(uuid("0000030c-0000-0000-c000-000000000046")) PSGenObject;
class __declspec(uuid("0000030d-0000-0000-c000-000000000046")) PSClientSite;
class __declspec(uuid("0000030e-0000-0000-c000-000000000046")) PSClassObject;
class __declspec(uuid("0000030f-0000-0000-c000-000000000046")) PSInPlaceActive;
class __declspec(uuid("00000310-0000-0000-c000-000000000046")) PSInPlaceFrame;
class __declspec(uuid("00000311-0000-0000-c000-000000000046")) PSDragDrop;
class __declspec(uuid("00000312-0000-0000-c000-000000000046")) PSBindCtx;
class __declspec(uuid("00000313-0000-0000-c000-000000000046")) PSEnumerators;
class __declspec(uuid("00000315-0000-0000-c000-000000000046")) Picture_Metafile;
class __declspec(uuid("00000315-0000-0000-c000-000000000046")) StaticMetafile;
class __declspec(uuid("00000316-0000-0000-c000-000000000046")) Picture_Dib;
class __declspec(uuid("00000316-0000-0000-c000-000000000046")) StaticDib;
class __declspec(uuid("00000319-0000-0000-c000-000000000046")) Picture_EnhMetafile;
class __declspec(uuid("0000031d-0000-0000-c000-000000000046")) DCOMAccessControl;
class __declspec(uuid("00021400-0000-0000-c000-000000000046")) ShellDesktop;
class __declspec(uuid("00021401-0000-0000-c000-000000000046")) ShellLink;
class __declspec(uuid("0002DF01-0000-0000-C000-000000000046")) InternetExplorer;
class __declspec(uuid("0002e005-0000-0000-c000-000000000046")) StdComponentCategoriesMgr;
class __declspec(uuid("08165ea0-e946-11cf-9c87-00aa005127ed")) WebCrawlerAgent;
class __declspec(uuid("0A89A860-D7B1-11CE-8350-444553540000")) ShellDispatchInproc;
class __declspec(uuid("0D04D285-6BEC-11CF-8B97-00AA00476DA6")) OldHTMLFormElement;
class __declspec(uuid("0be35200-8f91-11ce-9de3-00aa004bb851")) CFontPropPage;
class __declspec(uuid("0be35201-8f91-11ce-9de3-00aa004bb851")) CColorPropPage;
class __declspec(uuid("0be35202-8f91-11ce-9de3-00aa004bb851")) CPicturePropPage;
class __declspec(uuid("0be35203-8f91-11ce-9de3-00aa004bb851")) StdFont;
class __declspec(uuid("0be35204-8f91-11ce-9de3-00aa004bb851")) StdPicture;
class __declspec(uuid("11219420-1768-11D1-95BE-00609797EA4F")) ShellLinkObject;
class __declspec(uuid("163BB1E1-6E00-11CF-837A-48DC04C10000")) HTMLLocation;
class __declspec(uuid("1820FED0-473E-11D0-A96C-00C04FD705A2")) WebViewFolderContents;
class __declspec(uuid("25336920-03F9-11CF-8FD0-00AA00686F13")) HTMLDocument;
class __declspec(uuid("25336921-03f9-11cf-8fd0-00aa00686f13")) HTMLPluginDocument;
class __declspec(uuid("275C23E2-3747-11D0-9FEA-00AA003F8646")) CMultiLanguage;
class __declspec(uuid("3050F241-98B5-11CF-BB82-00AA00BDCE0B")) HTMLImg;
class __declspec(uuid("3050F245-98B5-11CF-BB82-00AA00BDCE0B")) HTMLSelectElement;
class __declspec(uuid("3050F246-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCell;
class __declspec(uuid("3050F248-98B5-11CF-BB82-00AA00BDCE0B")) HTMLAnchorElement;
class __declspec(uuid("3050F249-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDivPosition;
class __declspec(uuid("3050F24A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBody;
class __declspec(uuid("3050F24D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionElement;
class __declspec(uuid("3050F24E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLObjectElement;
class __declspec(uuid("3050F251-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFormElement;
class __declspec(uuid("3050F252-98B5-11CF-BB82-00AA00BDCE0B")) HTMLHRElement;
class __declspec(uuid("3050F25D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLEmbed;
class __declspec(uuid("3050F268-98B5-11CF-BB82-00AA00BDCE0B")) HTMLUnknownElement;
class __declspec(uuid("3050F269-98B5-11CF-BB82-00AA00BDCE0B")) HTMLUListElement;
class __declspec(uuid("3050F26A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTextElement;
class __declspec(uuid("3050F26B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTable;
class __declspec(uuid("3050F26C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCol;
class __declspec(uuid("3050F26D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableRow;
class __declspec(uuid("3050F26E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLPhraseElement;
class __declspec(uuid("3050F26F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLParaElement;
class __declspec(uuid("3050F270-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOListElement;
class __declspec(uuid("3050F271-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMapElement;
class __declspec(uuid("3050F272-98B5-11CF-BB82-00AA00BDCE0B")) HTMLListElement;
class __declspec(uuid("3050F273-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLIElement;
class __declspec(uuid("3050F275-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMetaElement;
class __declspec(uuid("3050F276-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBaseElement;
class __declspec(uuid("3050F277-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLinkElement;
class __declspec(uuid("3050F278-98B5-11CF-BB82-00AA00BDCE0B")) HTMLIsIndexElement;
class __declspec(uuid("3050F279-98B5-11CF-BB82-00AA00BDCE0B")) HTMLNextIdElement;
class __declspec(uuid("3050F27A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLHeaderElement;
class __declspec(uuid("3050F27B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFontElement;
class __declspec(uuid("3050F27C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDTElement;
class __declspec(uuid("3050F27D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDListElement;
class __declspec(uuid("3050F27E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDivElement;
class __declspec(uuid("3050F27F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDDElement;
class __declspec(uuid("3050F280-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBRElement;
class __declspec(uuid("3050F281-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBlockElement;
class __declspec(uuid("3050F282-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBaseFontElement;
class __declspec(uuid("3050F283-98B5-11CF-BB82-00AA00BDCE0B")) HTMLAreaElement;
class __declspec(uuid("3050F284-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTitleElement;
class __declspec(uuid("3050F285-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyle;
class __declspec(uuid("3050F28A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDialog;
class __declspec(uuid("3050F28C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLScriptElement;
class __declspec(uuid("3050F2AB-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputTextElement;
class __declspec(uuid("3050F2AC-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTextAreaElement;
class __declspec(uuid("3050F2AE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputFileElement;
class __declspec(uuid("3050F2B4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputButtonElement;
class __declspec(uuid("3050F2B9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMarqueeElement;
class __declspec(uuid("3050F2BE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionButtonElement;
class __declspec(uuid("3050F2C4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputImage;
class __declspec(uuid("3050F2C6-98B5-11CF-BB82-00AA00BDCE0B")) HTMLButtonElement;
class __declspec(uuid("3050F2E4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheet;
class __declspec(uuid("3050F2E9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableSection;
class __declspec(uuid("3050F2EC-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCaption;
class __declspec(uuid("3050F312-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameBase;
class __declspec(uuid("3050F314-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameElement;
class __declspec(uuid("3050F316-98B5-11CF-BB82-00AA00BDCE0B")) HTMLIFrame;
class __declspec(uuid("3050F317-98B5-11CF-BB82-00AA00BDCE0B")) HTMLCommentElement;
class __declspec(uuid("3050F31A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameSetSite;
class __declspec(uuid("3050F32B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLabelElement;
class __declspec(uuid("3050F35D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLScreen;
class __declspec(uuid("3050F370-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBGsound;
class __declspec(uuid("3050F37D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleElement;
class __declspec(uuid("3050F37F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetsCollection;
class __declspec(uuid("3050F38B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLNoShowElement;
class __declspec(uuid("3050F38D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionElementFactory;
class __declspec(uuid("3050F38F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLImageElementFactory;
class __declspec(uuid("3050F391-98B5-11CF-BB82-00AA00BDCE0B")) HTMLWindowProxy;
class __declspec(uuid("3050F3CD-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetRulesCollection;
class __declspec(uuid("3050F3CE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetRule;
class __declspec(uuid("3050F3D0-98B5-11CF-BB82-00AA00BDCE0B")) HTMLRuleStyle;
class __declspec(uuid("3050F3D4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleFontFace;
class __declspec(uuid("3050F3E6-98B5-11CF-BB82-00AA00BDCE0B")) HTMLSpanFlow;
class __declspec(uuid("3050F3E8-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFieldSetElement;
class __declspec(uuid("3050F3E9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLegendElement;
class __declspec(uuid("3050F3EF-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFiltersCollection;
class __declspec(uuid("3050F3F5-98B4-11CF-BB82-00AA00BDCE0B")) HTMLSpanElement;
class __declspec(uuid("3050F3FE-98B5-11CF-BB82-00AA00BDCE0B")) CMimeTypes;
class __declspec(uuid("3050F3FF-98B5-11CF-BB82-00AA00BDCE0B")) CPlugins;
class __declspec(uuid("3050F402-98B5-11CF-BB82-00AA00BDCE0B")) COpsProfile;
class __declspec(uuid("3050f3d9-98b5-11cf-bb82-00aa00bdce0b")) MHTMLDocument;
class __declspec(uuid("32b533bb-edae-11d0-bd5a-00aa00b92af1")) ClassInstallFilter;
class __declspec(uuid("3c374a40-bae4-11cf-bf7d-00aa006946ee")) CUrlHistory;
class __declspec(uuid("3dd53d40-7b8b-11d0-b013-00aa0059ce02")) CdlProtocol;
class __declspec(uuid("54c37cd0-d944-11d0-a9f4-006097942311")) StdEncodingFilterFac;
class __declspec(uuid("56fdf344-fd6d-11d0-958a-006097c9a090")) TaskbarList;
class __declspec(uuid("62112AA1-EBE4-11CF-A5FB-0020AFE7292D")) ShellFolderView;
class __declspec(uuid("63b51f81-c868-11d0-999c-00c04fd655e1")) CFSIconOverlayManager;
class __declspec(uuid("64AB4BB7-111E-11D1-8F79-00C04FC2FBE1")) ShellUIHelper;
class __declspec(uuid("75048700-ef1f-11d0-9888-006097deacf9")) ActiveDesktop;
class __declspec(uuid("79eac9d0-baf9-11ce-8c82-00aa004ba90b")) StdHlink;
class __declspec(uuid("79eac9d1-baf9-11ce-8c82-00aa004ba90b")) StdHlinkBrowseContext;
class __declspec(uuid("79eac9e0-baf9-11ce-8c82-00aa004ba90b")) StdURLMoniker;
class __declspec(uuid("79eac9e1-baf9-11ce-8c82-00aa004ba90b")) StdURLProtocol;
class __declspec(uuid("79eac9e2-baf9-11ce-8c82-00aa004ba90b")) HttpProtocol;
class __declspec(uuid("79eac9e3-baf9-11ce-8c82-00aa004ba90b")) FtpProtocol;
class __declspec(uuid("79eac9e4-baf9-11ce-8c82-00aa004ba90b")) GopherProtocol;
class __declspec(uuid("79eac9e5-baf9-11ce-8c82-00aa004ba90b")) HttpSProtocol;
class __declspec(uuid("79eac9e6-baf9-11ce-8c82-00aa004ba90b")) MkProtocol;
class __declspec(uuid("79eac9e7-baf9-11ce-8c82-00aa004ba90b")) FileProtocol;
class __declspec(uuid("79eac9f2-baf9-11ce-8c82-00aa004ba90b")) UrlMkBindCtx;
class __declspec(uuid("7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4")) InternetSecurityManager;
class __declspec(uuid("7b8a2d95-0ac9-11d1-896c-00c04fb6bfc4")) InternetZoneManager;
class __declspec(uuid("7d559c10-9fe9-11d0-93f7-00aa0059ce02")) CDLAgent;
class __declspec(uuid("7d688a77-c613-11d0-999b-00c04fd655e1")) OverlayIdentifier_SlowFile;
class __declspec(uuid("7ebdaae0-8120-11cf-899f-00aa00688b10")) StockFontPage;
class __declspec(uuid("7ebdaae1-8120-11cf-899f-00aa00688b10")) StockColorPage;
class __declspec(uuid("7ebdaae2-8120-11cf-899f-00aa00688b10")) StockPicturePage;
class __declspec(uuid("8856F961-340A-11D0-A96B-00C04FD705A2")) WebBrowser;
class __declspec(uuid("8f6b0360-b80d-11d0-a9b3-006097942311")) DeCompMimeFilter;
class __declspec(uuid("9BA05971-F6A8-11CF-A442-00A0C90A8F39")) ShellFolderViewOC;
class __declspec(uuid("9BA05972-F6A8-11CF-A442-00A0C90A8F39")) ShellWindows;
class __declspec(uuid("ABBE31D0-6DAE-11D0-BECA-00C04FD940BE")) SubscriptionMgr;
class __declspec(uuid("B3CDAE90-D170-11D0-802B-00C04FD75D13")) ChannelMgr;
class __declspec(uuid("C04D65CF-B70D-11D0-B188-00AA0038C969")) CMLangString;
class __declspec(uuid("D48A6EC6-6A4A-11CF-94A7-444553540000")) HTMLWindow2;
class __declspec(uuid("D48A6EC9-6A4A-11CF-94A7-444553540000")) OldHTMLDocument;
class __declspec(uuid("D66D6F99-CDAA-11D0-B822-00C04FC9B31F")) CMLangConvertCharset;
class __declspec(uuid("EAB22AC3-30C1-11CF-A7EB-0000C05BAE0B")) WebBrowser_V1;
class __declspec(uuid("FECEAAA3-8405-11CF-8BA1-00AA00476DA6")) HTMLHistory;
class __declspec(uuid("FECEAAA6-8405-11CF-8BA1-00AA00476DA6")) HTMLNavigator;
class __declspec(uuid("b15b8dc0-c7e1-11d0-8680-00aa00bdcb71")) SoftDistExt;
class __declspec(uuid("cfbfae00-17a6-11d0-99cb-00c04fd64497")) CURLSearchHook;
class __declspec(uuid("e3a8bde6-abce-11d0-bc4b-00c04fd929db")) ChannelAgent;
class __declspec(uuid("fb8f0821-0164-101b-84ed-08002b2ec713")) PersistPropset;
class __declspec(uuid("fb8f0822-0164-101b-84ed-08002b2ec713")) ConvertVBX;
class __declspec(uuid("fbf23b40-e3f0-101b-8488-00aa003e56f8")) InternetShortcut;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\version.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//                              Versioning Functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

category Version:
module VERSION.DLL:


/*
export VerFindFileA;
export VerFindFileW;
export VerInstallFileA;
export VerInstallFileW;
export VerQueryValueA;
export VerQueryValueIndexA;
export VerQueryValueIndexW;
export VerQueryValueW;
*/

DWORD
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        [out] LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        [out] LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
FailOnFalse
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        [out] LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
FailOnFalse
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        [out] LPVOID lpData
        );                      /* Buffer to place the data structure */


module KERNEL32.DLL:

value LONG PlatformId
{
#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2
};

typedef struct _OSVERSIONINFOA{ 
    DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion; 
    DWORD dwMinorVersion; 
    DWORD dwBuildNumber; 
    PlatformId dwPlatformId; 
    CHAR szCSDVersion[ 128 ]; 
} OSVERSIONINFOA, *LPOSVERSIONINFOA; 

typedef struct _OSVERSIONINFOW{ 
    DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion; 
    DWORD dwMinorVersion; 
    DWORD dwBuildNumber; 
    PlatformId dwPlatformId; 
    WCHAR szCSDVersion[ 128 ]; 
} OSVERSIONINFOW, *LPOSVERSIONINFOW; 

DWORD GetVersion();

FailOnFalse [gle] GetVersionExA(
                                [out] LPOSVERSIONINFOA lpVersionInfo 
                                );

FailOnFalse [gle] GetVersionExW(
                                [out] LPOSVERSIONINFOW lpVersionInfo 
                                );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\shell.h ===
typedef HANDLE HDROP;

typedef LPVOID LPSHELLFLAGSTATE;
typedef LPVOID LPBC;
typedef LPVOID IEnumIDList;
typedef LPVOID LPSOFTDISTINFO;

typedef struct _SHITEMID        // mkid
{
    USHORT      cb;             // Size of the ID (including cb itself)
    BYTE        abID[1];        // The item ID (variable length)
} SHITEMID;
typedef SHITEMID *LPSHITEMID;
typedef SHITEMID *LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
typedef struct _ITEMIDLIST      // idl
{
    SHITEMID    mkid;
} ITEMIDLIST;
typedef ITEMIDLIST * LPITEMIDLIST;
typedef ITEMIDLIST * LPCITEMIDLIST;

value UINT AppBarEdge
{
#define ABE_LEFT        0
#define ABE_TOP         1
#define ABE_RIGHT       2
#define ABE_BOTTOM      3
};

typedef struct _AppBarData {
    DWORD  cbSize; 
    HWND   hWnd; 
    UINT   uCallbackMessage;
    AppBarEdge   uEdge; 
    RECT   rc; 
    LPARAM lParam; 
} APPBARDATA, *PAPPBARDATA; 

value DWORD AppBarMessage
{
#define ABM_NEW           0x00000000
#define ABM_REMOVE        0x00000001
#define ABM_QUERYPOS      0x00000002
#define ABM_SETPOS        0x00000003
#define ABM_GETSTATE      0x00000004
#define ABM_GETTASKBARPOS 0x00000005
#define ABM_ACTIVATE      0x00000006  // lParam == TRUE/FALSE means activate/deactivate
#define ABM_GETAUTOHIDEBAR 0x00000007
#define ABM_SETAUTOHIDEBAR 0x00000008  // this can fail at any time.  MUST check the result
                                        // lParam = TRUE/FALSE  Set/Unset
                                        // uEdge = what edge
#define ABM_WINDOWPOSCHANGED 0x0000009
};

value DWORD FindExecutableError
{
#define OutOfMemory                      0L           [fail]
#define ERROR_FILE_NOT_FOUND             2L           [fail]
#define ERROR_PATH_NOT_FOUND             3L           [fail]
#define ERROR_BAD_FORMAT                 11L          [fail]
#define NoAssociation                    31L          [fail]
};

value UINT SHAddToRecentDocsFlags
{
#define SHARD_PIDL      0x00000001L
#define SHARD_PATHA     0x00000002L
#define SHARD_PATHW     0x00000003L
};

mask UINT BrowseInfoFlags
{
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010
#define BIF_VALIDATE           0x0020   // insist on valid result (or CANCEL)

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers
#define BIF_BROWSEINCLUDEFILES 0x4000  // Browsing for Everything
};

typedef struct _browseinfoA {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;// Return display name of item selected.
    LPCSTR       lpszTitle;      // text to go in the banner over the tree.
    BrowseInfoFlags ulFlags;       // Flags that control the return stuff
    LPVOID      lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

typedef struct _browseinfoW {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPWSTR       pszDisplayName;// Return display name of item selected.
    LPCWSTR      lpszTitle;      // text to go in the banner over the tree.
    BrowseInfoFlags ulFlags;       // Flags that control the return stuff
    LPVOID      lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;


value LONG ChangeNotifyEventId
{
#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L

#define SHCNE_EXTENDED_EVENT      0x04000000L
#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0581E0L
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.
};


value LONG ChangeNotifyFlags
{
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
};

mask ULONG SHCreateProcessInfoMask
{
#define SEE_MASK_CLASSNAME        0x00000001
#define SEE_MASK_CLASSKEY         0x00000003
#define SEE_MASK_IDLIST           0x00000004
#define SEE_MASK_INVOKEIDLIST     0x0000000c
#define SEE_MASK_ICON             0x00000010
#define SEE_MASK_HOTKEY           0x00000020
#define SEE_MASK_NOCLOSEPROCESS   0x00000040
#define SEE_MASK_CONNECTNETDRV    0x00000080
#define SEE_MASK_FLAG_DDEWAIT     0x00000100
#define SEE_MASK_DOENVSUBST       0x00000200
#define SEE_MASK_FLAG_NO_UI       0x00000400
#define SEE_MASK_UNICODE          0x00004000
#define SEE_MASK_NO_CONSOLE       0x00008000
#define SEE_MASK_ASYNCOK          0x00100000
#define SEE_MASK_HMONITOR         0x00200000
#define SEE_MASK_NOQUERYCLASSSTORE 0x01000000
#define SEE_MASK_WAITFORINPUTIDLE  0x02000000
};

typedef struct _SHCREATEPROCESSINFOW
{
        DWORD cbSize;
        SHCreateProcessInfoMask fMask;
        HWND hwnd;
        LPCWSTR  pwszFile;
        LPCWSTR  pwszParameters;
        LPCWSTR  pwszCurrentDirectory;
        HANDLE hUserToken;
        LPSECURITY_ATTRIBUTES lpProcessAttributes;
        LPSECURITY_ATTRIBUTES lpThreadAttributes;
        BOOL bInheritHandles;
        DWORD dwCreationFlags;
        LPSTARTUPINFOW lpStartupInfo;
        LPPROCESS_INFORMATION lpProcessInformation;
} SHCREATEPROCESSINFOW, *PSHCREATEPROCESSINFOW;

value DWORD NotifyIconMessage
{
#define NIM_ADD         0x00000000
#define NIM_MODIFY      0x00000001
#define NIM_DELETE      0x00000002
#define NIM_SETFOCUS    0x00000003
#define NIM_SETVERSION  0x00000004
};

typedef LPVOID PNOTIFYICONDATA;
/*   --- Can't handle variable length structures
typedef struct _NOTIFYICONDATA { 
    DWORD cbSize; 
    HWND hWnd; 
    UINT uID; 
    UINT uFlags; 
    UINT uCallbackMessage; 
    HICON hIcon; 
    TCHAR szTip[64];
    DWORD dwState; //Version 5.0
    DWORD dwStateMask; //Version 5.0
    TCHAR szInfo[256]; //Version 5.0
    union {
        UINT  uTimeout; //Version 5.0
        UINT  uVersion; //Version 5.0
    } DUMMYUNIONNAME;
    TCHAR szInfoTitle[64]; //Version 5.0
    DWORD dwInfoFlags; //Version 5.0
} NOTIFYICONDATA, *PNOTIFYICONDATA; 
*/

value DWORD ShellExecuteError
{
#define OutOfMemory                      0L           [fail]
#define ERROR_FILE_NOT_FOUND             2L           [fail]
#define ERROR_PATH_NOT_FOUND             3L           [fail]
#define ERROR_BAD_FORMAT                 11L          [fail]
#define SE_ERR_ACCESSDENIED              5             [fail]
#define SE_ERR_OOM                      8             [fail]
#define SE_ERR_DLLNOTFOUND              32             [fail]
#define SE_ERR_SHARE                    26             [fail]
#define SE_ERR_ASSOCINCOMPLETE          27             [fail]
#define SE_ERR_DDETIMEOUT               28             [fail]
#define SE_ERR_DDEFAIL                  29             [fail]
#define SE_ERR_DDEBUSY                  30             [fail]
#define SE_ERR_NOASSOC                  31             [fail]
};

typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        INT nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HRSRC  hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFOA, *LPSHELLEXECUTEINFOA;

typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        INT nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HRSRC hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFOW, *LPSHELLEXECUTEINFOW;

mask DWORD SHEmptyRecycleBinFlags
{
#define SHERB_NOCONFIRMATION    0x00000001
#define SHERB_NOPROGRESSUI      0x00000002
#define SHERB_NOSOUND           0x00000004
};

mask DWORD FILEOP_FLAGS
{
#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs
#define FOF_NOERRORUI              0x0400  // don't put up error UI
#define FOF_NOCOPYSECURITYATTRIBS  0x0800  // dont copy NT file Security Attributes
#define FOF_NORECURSION            0x1000  // don't recurse into directories.
#define FOF_NO_CONNECTED_ELEMENTS  0x2000  // don't operate on connected elements.
#define FOF_WANTNUKEWARNING        0x4000  // during delete operation, warn if nuking instead of recycling (partially overrides FOF_NOCONFIRMATION)
};

typedef struct _SHFILEOPSTRUCTA
{
        HWND            hwnd;
        UINT            wFunc;
        LPCSTR          pFrom;
        LPCSTR          pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCSTR           lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTA, *LPSHFILEOPSTRUCTA;

typedef struct _SHFILEOPSTRUCTW
{
        HWND            hwnd;
        UINT            wFunc;
        LPCWSTR         pFrom;
        LPCWSTR         pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCWSTR          lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTW, *LPSHFILEOPSTRUCTW;

value INT SHGetDataFromIDListFormat
{
#define SHGDFIL_FINDDATA        1
#define SHGDFIL_NETRESOURCE     2
#define SHGDFIL_DESCRIPTIONID   3
};

mask UINT SHGetFileInfoFlags
{
#define SHGFI_ICON              0x000000100     // get icon
#define SHGFI_DISPLAYNAME       0x000000200     // get display name
#define SHGFI_TYPENAME          0x000000400     // get type name
#define SHGFI_ATTRIBUTES        0x000000800     // get attributes
#define SHGFI_ICONLOCATION      0x000001000     // get icon location
#define SHGFI_EXETYPE           0x000002000     // return exe type
#define SHGFI_SYSICONINDEX      0x000004000     // get system icon index
#define SHGFI_LINKOVERLAY       0x000008000     // put a link overlay on icon
#define SHGFI_SELECTED          0x000010000     // show icon in selected state
#define SHGFI_ATTR_SPECIFIED    0x000020000     // get only specified attributes
#define SHGFI_LARGEICON         0x000000000     // get large icon
#define SHGFI_SMALLICON         0x000000001     // get small icon
#define SHGFI_OPENICON          0x000000002     // get open icon
#define SHGFI_SHELLICONSIZE     0x000000004     // get shell size icon
#define SHGFI_PIDL              0x000000008     // pszPath is a pidl
#define SHGFI_USEFILEATTRIBUTES 0x000000010     // use passed dwFileAttribute
#define SHGFI_ADDOVERLAYS       0x000000020     // apply the appropriate overlays
#define SHGFI_OVERLAYINDEX      0x000000040     // Get the index of the overlay
                                                // in the upper 8 bits of the iIcon 
};

mask DWORD ShellFolderGetAttributesOf
{
#define SFGAO_CANCOPY           0x1 // Objects can be copied    (0x1)
#define SFGAO_CANMOVE           0x2 // Objects can be moved     (0x2)
#define SFGAO_CANLINK           0x4 // Objects can be linked    (0x4)
#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed
#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted
#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets
#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target
#define SFGAO_CAPABILITYMASK    0x00000177L
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_SHARE             0x00020000L     // shared
#define SFGAO_READONLY          0x00040000L     // read-only
#define SFGAO_GHOSTED           0x00080000L     // ghosted icon
#define SFGAO_HIDDEN            0x00080000L     // hidden object
#define SFGAO_DISPLAYATTRMASK   0x000F0000L
#define SFGAO_FILESYSANCESTOR   0x10000000L     // It contains file system folder
#define SFGAO_FOLDER            0x20000000L     // It's a folder.
#define SFGAO_FILESYSTEM        0x40000000L     // is a file system thing (file/folder/root)
#define SFGAO_HASSUBFOLDER      0x80000000L     // Expandable in the map pane
#define SFGAO_CONTENTSMASK      0x80000000L
#define SFGAO_VALIDATE          0x01000000L     // invalidate cached information
#define SFGAO_REMOVABLE         0x02000000L     // is this removeable media?
#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)
#define SFGAO_BROWSABLE         0x08000000L     // is in-place browsable
#define SFGAO_NONENUMERATED     0x00100000L     // is a non-enumerated object
#define SFGAO_NEWCONTENT        0x00200000L     // should show bold in explorer tree
#define SFGAO_CANMONIKER        0x00400000L     // can create monikers for its objects
};

typedef struct _SHFILEINFOA
{
        HRSRC       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        ShellFolderGetAttributesOf dwAttributes;               // out: SFGAO_ flags
        CHAR        szDisplayName[260];    // out: display name (or path)
        CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
        HRSRC       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        ShellFolderGetAttributesOf dwAttributes;               // out: SFGAO_ flags
        WCHAR       szDisplayName[260];    // out: display name (or path)
        WCHAR       szTypeName[80];             // out: type name
} SHFILEINFOW;

value DWORD SHGetFolderPathFlags
{
#define SHGFP_TYPE_CURRENT   0   // current value for user, verify it exists
#define SHGFP_TYPE_DEFAULT   1   // default value, may not exist
};

value int SHGetIconOverlayIndexValue
{
#define IDO_SHGIOI_SHARE  0x0FFFFFFF
#define IDO_SHGIOI_LINK   0x0FFFFFFE
#define IDO_SHGIOI_SLOWFILE 0x0FFFFFFFD
};

mask DWORD SHGetSettingsMask
{
#define SSF_SHOWALLOBJECTS          0x00000001
#define SSF_SHOWEXTENSIONS          0x00000002
#define SSF_SHOWCOMPCOLOR           0x00000008
#define SSF_SHOWSYSFILES            0x00000020
#define SSF_DOUBLECLICKINWEBVIEW    0x00000080
#define SSF_SHOWATTRIBCOL           0x00000100
#define SSF_DESKTOPHTML             0x00000200
#define SSF_WIN95CLASSIC            0x00000400
#define SSF_DONTPRETTYPATH          0x00000800
#define SSF_SHOWINFOTIP             0x00002000
#define SSF_MAPNETDRVBUTTON         0x00001000
#define SSF_NOCONFIRMRECYCLE        0x00008000
#define SSF_HIDEICONS               0x00004000
};


value int CSIDL
{
#define CSIDL_DESKTOP                   0x0000        // <desktop>
#define CSIDL_INTERNET                  0x0001        // Internet Explorer (icon on desktop)
#define CSIDL_PROGRAMS                  0x0002        // Start Menu\Programs
#define CSIDL_CONTROLS                  0x0003        // My Computer\Control Panel
#define CSIDL_PRINTERS                  0x0004        // My Computer\Printers
#define CSIDL_PERSONAL                  0x0005        // My Documents
#define CSIDL_FAVORITES                 0x0006        // <user name>\Favorites
#define CSIDL_STARTUP                   0x0007        // Start Menu\Programs\Startup
#define CSIDL_RECENT                    0x0008        // <user name>\Recent
#define CSIDL_SENDTO                    0x0009        // <user name>\SendTo
#define CSIDL_BITBUCKET                 0x000a        // <desktop>\Recycle Bin
#define CSIDL_STARTMENU                 0x000b        // <user name>\Start Menu
#define CSIDL_DESKTOPDIRECTORY          0x0010        // <user name>\Desktop
#define CSIDL_DRIVES                    0x0011        // My Computer
#define CSIDL_NETWORK                   0x0012        // Network Neighborhood
#define CSIDL_NETHOOD                   0x0013        // <user name>\nethood
#define CSIDL_FONTS                     0x0014        // windows\fonts
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016        // All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS           0X0017        // All Users\Programs
#define CSIDL_COMMON_STARTUP            0x0018        // All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019        // All Users\Desktop
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
#define CSIDL_PRINTHOOD                 0x001b        // <user name>\PrintHood
#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#define CSIDL_ALTSTARTUP                0x001d        // non localized startup
#define CSIDL_COMMON_ALTSTARTUP         0x001e        // non localized common startup
#define CSIDL_COMMON_FAVORITES          0x001f
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025        // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026        // C:\Program Files
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#define CSIDL_PROFILE                   0x0028        // USERPROFILE
#define CSIDL_SYSTEMX86                 0x0029        // x86 system directory on RISC
#define CSIDL_PROGRAM_FILESX86          0x002a        // x86 C:\Program Files on RISC
#define CSIDL_PROGRAM_FILES_COMMON      0x002b        // C:\Program Files\Common
#define CSIDL_PROGRAM_FILES_COMMONX86   0x002c        // x86 Program Files\Common on RISC
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates
#define CSIDL_COMMON_DOCUMENTS          0x002e        // All Users\Documents
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools
#define CSIDL_CONNECTIONS               0x0031        // Network and Dial-up Connections

#define CSIDL_FLAG_CREATE               0x8000        // combine with CSIDL_ value to force folder creation in SHGetFolderPath()
#define CSIDL_FLAG_DONT_VERIFY          0x4000        // combine with CSIDL_ value to return an unverified folder path
#define CSIDL_FLAG_MASK                 0xFF00        // mask for all possible flag values
};

value UINT SHInvokePrinterCommandAction
{
#define PRINTACTION_OPEN           0
#define PRINTACTION_PROPERTIES     1
#define PRINTACTION_NETINSTALL     2
#define PRINTACTION_NETINSTALLLINK 3
#define PRINTACTION_TESTPAGE       4
#define PRINTACTION_OPENNETPRN     5
#define PRINTACTION_DOCUMENTDEFAULTS 6
#define PRINTACTION_SERVERPROPERTIES 7
};

typedef struct _SHQUERYRBINFO {
    DWORD cbSize;     
    __int64 i64Size;
    __int64 i64NumItems;
} SHQUERYRBINFO, *LPSHQUERYRBINFO;

value DWORD TranslateUrlFlags
{
#define TRANSLATEURL_FL_GUESS_PROTOCOL         0x0001     // Guess protocol if missing
#define TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL   0x0002     // Use default protocol if missing
};

value DWORD URLAssociationDialogFlags
{
#define URLASSOCDLG_FL_USE_DEFAULT_NAME        0x0001
#define URLASSOCDLG_FL_REGISTER_ASSOC          0x0002
};

value UINT WinHelpCommands
{
#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_QUIT         0x0002L  /* Terminate help */
#define HELP_INDEX        0x0003L  /* Display index */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_SETINDEX     0x0005L  /* Set current Index for multi index help */
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE    0x0009L
#define HELP_KEY          0x0101L  /* Display topic for keyword in offabData */
#define HELP_COMMAND      0x0102L
#define HELP_PARTIALKEY   0x0105L
#define HELP_MULTIKEY     0x0201L
#define HELP_SETWINPOS    0x0203L
#define HELP_CONTEXTMENU  0x000a
#define HELP_FINDER       0x000b
#define HELP_WM_HELP      0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD              0x8000
#define HELP_TCARD_DATA         0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011
};

typedef struct _STRRET {
   UINT uType; 
   CHAR cStr[260];
} STRRET, *LPSTRRET; 


module SHELL32.DLL:
category Shell:

HRESULT DllGetClassObject(
                         REFCLSID rclsid,
                         [iid] REFIID riid,
                         [out] COM_INTERFACE_PTR * ppv
                         );

interface IShellFolder : IUnknown
{
    HRESULT ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
                            [out] ULONG *pchEaten, [out] LPITEMIDLIST *ppidl, [out] ULONG *pdwAttributes);

    HRESULT EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);

    HRESULT BindToObject(LPCITEMIDLIST pidl, LPBC pbc, [iid] REFIID riid, [out] COM_INTERFACE_PTR *ppv);
    HRESULT BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, [iid] REFIID riid, [out] COM_INTERFACE_PTR *ppv);
    HRESULT CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    HRESULT CreateViewObject(HWND hwndOwner, [iid] REFIID riid, [out] COM_INTERFACE_PTR *ppv);
    HRESULT GetAttributesOf(UINT cidl, [out] LPCITEMIDLIST * apidl, [out] ULONG * rgfInOut);
    HRESULT GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                         [iid] REFIID riid, UINT * prgfInOut, [out] COM_INTERFACE_PTR *ppv);
    HRESULT GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, [out] LPSTRRET lpName);
    HRESULT SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName,
                     DWORD uFlags, LPITEMIDLIST *ppidlOut);
};

interface IShellLinkA : IUnknown
{
    HRESULT GetPath( [out] LPSTR pszFile, INT cchMaxPath, [out] LPWIN32_FIND_DATAA pfd, DWORD fFlags );
    
    HRESULT GetIDList([out] LPITEMIDLIST * ppidl);
    HRESULT SetIDList(LPCITEMIDLIST pidl);
    
    HRESULT GetDescription([out] LPSTR pszName, INT cchMaxName);
    HRESULT SetDescription(LPCSTR pszName);
    
    HRESULT GetWorkingDirectory([out] LPSTR pszDir, INT cchMaxPath);
    HRESULT SetWorkingDirectory(LPCSTR pszDir);
    
    HRESULT GetArguments([out] LPSTR pszArgs, INT cchMaxPath);
    HRESULT SetArguments(LPCSTR pszArgs);
    
    HRESULT GetHotkey([out] WORD *pwHotkey);
    HRESULT SetHotkey(WORD wHotkey);
    
    HRESULT GetShowCmd([out] INT *piShowCmd);
    HRESULT SetShowCmd(INT iShowCmd);
    
    HRESULT GetIconLocation([out] LPSTR pszIconPath, INT cchIconPath, [out] INT *piIcon);
    HRESULT SetIconLocation(LPCSTR pszIconPath, INT iIcon);
    
    HRESULT SetRelativePath(LPCSTR pszPathRel, DWORD dwReserved);
    
    HRESULT Resolve(HWND hwnd, DWORD fFlags);
    
    HRESULT SetPath(LPCSTR pszFile);
};

interface IShellLinkW : IUnknown
{
    HRESULT GetPath( [out] LPWSTR pszFile, INT cchMaxPath, [out] LPWIN32_FIND_DATAW pfd, DWORD fFlags );
    
    HRESULT GetIDList([out] LPITEMIDLIST * ppidl);
    HRESULT SetIDList(LPCITEMIDLIST pidl);
    
    HRESULT GetDescription([out] LPWSTR pszName, INT cchMaxName);
    HRESULT SetDescription(LPCWSTR pszName);
    
    HRESULT GetWorkingDirectory([out] LPWSTR pszDir, INT cchMaxPath);
    HRESULT SetWorkingDirectory(LPCWSTR pszDir);
    
    HRESULT GetArguments([out] LPWSTR pszArgs, INT cchMaxPath);
    HRESULT SetArguments(LPCWSTR pszArgs);
    
    HRESULT GetHotkey([out] WORD *pwHotkey);
    HRESULT SetHotkey(WORD wHotkey);
    
    HRESULT GetShowCmd([out] INT *piShowCmd);
    HRESULT SetShowCmd(INT iShowCmd);
    
    HRESULT GetIconLocation([out] LPWSTR pszIconPath, INT cchIconPath, [out] INT *piIcon);
    HRESULT SetIconLocation(LPCWSTR pszIconPath, INT iIcon);
    
    HRESULT SetRelativePath(LPCWSTR pszPathRel, DWORD dwReserved);
    
    HRESULT Resolve(HWND hwnd, DWORD fFlags);
    
    HRESULT SetPath(LPCWSTR pszFile);
};

DWORD DoEnvironmentSubstA(
    LPCSTR pszString,
    UINT cbSize
);

DWORD DoEnvironmentSubstW(
    LPCWSTR pszString,
    UINT cbSize
);

VOID DragAcceptFiles(
    HWND hWnd,
    BOOL fAccept
);

VOID DragFinish(
    HDROP hDrop
);

UINT DragQueryFileA(
    HDROP hDrop,
    UINT iFile,
    [out] LPSTR lpszFile,
    UINT cch
);

UINT DragQueryFileW(
    HDROP hDrop,
    UINT iFile,
    [out] LPWSTR lpszFile,
    UINT cch
);

BOOL DragQueryPoint(
    HDROP hDrop,
    LPPOINT lppt
);

FindExecutableError FindExecutableA(
    LPCSTR lpFile,
    LPCSTR lpDirectory,
    [out] LPSTR lpResult
);

FindExecutableError FindExecutableW(
    LPCWSTR lpFile,
    LPCWSTR lpDirectory,
    [out] LPWSTR lpResult
);

VOID SHAddToRecentDocs(
    SHAddToRecentDocsFlags uFlags, 
    LPCVOID pv
); 

UINT SHAppBarMessage(
    DWORD dwMessage, 
    PAPPBARDATA pData
); 

HRESULT SHBindToParent(
  LPCITEMIDLIST pidl, 
  [iid] REFIID riid, 
  [out] COM_INTERFACE_PTR *ppv, 
  [out] LPCITEMIDLIST *ppidlLast
);

LPITEMIDLIST SHBrowseForFolderA(
    LPBROWSEINFOA lpbi
); 

LPITEMIDLIST SHBrowseForFolderW(
    LPBROWSEINFOW lpbi
); 

VOID SHChangeNotify(
    ChangeNotifyEventId wEventId, 
    ChangeNotifyFlags uFlags, 
    LPCVOID dwItem1, 
    LPCVOID dwItem2
);  

int SHCreateDirectoryExA(
    HWND hwnd, 
    LPCSTR pszPath, 
    SECURITY_ATTRIBUTES *psa
);

int SHCreateDirectoryExW(
    HWND hwnd, 
    LPCWSTR pszPath, 
    SECURITY_ATTRIBUTES *psa
);

BOOL Shell_NotifyIcon(
    NotifyIconMessage dwMessage, 
    PNOTIFYICONDATA pnid
);

int ShellAboutA(
   HWND hWnd,
   LPCSTR szApp, 
   LPCSTR szOtherStuff, 
   HRSRC hIcon
);  

int ShellAboutW(
   HWND hWnd,
   LPCWSTR szApp, 
   LPCWSTR szOtherStuff, 
   HRSRC hIcon
);  

ShellExecuteError ShellExecuteA(
    HWND hwnd, 
    LPCSTR lpVerb,
    LPCSTR lpFile, 
    LPCSTR lpParameters, 
    LPCSTR lpDirectory,
    ShowWindowCommand nShowCmd
);

ShellExecuteError ShellExecuteW(
    HWND hwnd, 
    LPCSTR lpVerb,
    LPCSTR lpFile, 
    LPCSTR lpParameters, 
    LPCSTR lpDirectory,
    ShowWindowCommand nShowCmd
);

FailOnFalse [gle] ShellExecuteExA(
    LPSHELLEXECUTEINFOA lpExecInfo
);

FailOnFalse [gle] ShellExecuteExW(
    LPSHELLEXECUTEINFOW lpExecInfo
);

HRESULT SHEmptyRecycleBinA(
    HWND hwnd, 
    LPCSTR pszRootPath, 
    DWORD dwFlags
);

HRESULT SHEmptyRecycleBinW(
    HWND hwnd, 
    LPCWSTR pszRootPath, 
    SHEmptyRecycleBinFlags dwFlags
);

INT SHFileOperationA(
    LPSHFILEOPSTRUCTA lpFileOp
);

INT SHFileOperationW(
    LPSHFILEOPSTRUCTW lpFileOp
);

VOID SHFreeNameMappings(
    HANDLE hNameMappings    
);

HRESULT SHGetDataFromIDListA(
    IShellFolder* psf,
    LPCITEMIDLIST pidl,
    SHGetDataFromIDListFormat nFormat,
    PVOID pv,
    int cb
);

HRESULT SHGetDataFromIDListW(
    IShellFolder* psf,
    LPCITEMIDLIST pidl,
    SHGetDataFromIDListFormat nFormat,
    PVOID pv,
    int cb
);

HRESULT SHGetDesktopFolder(
    [out] IShellFolder **ppshf
);

FailOnFalse SHGetDiskFreeSpaceA(
    LPCSTR pszVolume,
    [out] ULARGE_INTEGER *pqwFreeCaller,
    [out] ULARGE_INTEGER *pqwTot,
    [out] ULARGE_INTEGER *pqwFree
);

DWORD_PTR SHGetFileInfoA(
    LPCSTR pszPath,
    ShellFolderGetAttributesOf dwFileAttributes,
    [out] SHFILEINFOA *psfi,
    UINT cbFileInfo,
    SHGetFileInfoFlags uFlags
);

DWORD_PTR SHGetFileInfoW(
    LPCWSTR pszPath,
    ShellFolderGetAttributesOf dwFileAttributes,
    [out] SHFILEINFOW *psfi,
    UINT cbFileInfo,
    SHGetFileInfoFlags uFlags
);

HRESULT SHGetFolderLocation(
    HWND hwndOwner,
    int nFolder,
    HANDLE hToken,
    DWORD dwReserved,
    LPITEMIDLIST *ppidl
);

HRESULT SHGetFolderPathA(
    HWND hwndOwner,
    CSIDL nFolder,
    HANDLE hToken,
    SHGetFolderPathFlags dwFlags,
    [out] LPSTR pszPath
);

HRESULT SHGetFolderPathW(
    HWND hwndOwner,
    CSIDL nFolder,
    HANDLE hToken,
    SHGetFolderPathFlags dwFlags,
    [out] LPWSTR pszPath
);

int SHGetIconOverlayIndexA(
    LPCSTR pszIconPath, 
    SHGetIconOverlayIndexValue iIconIndex
);

int SHGetIconOverlayIndexW(
    LPCWSTR pszIconPath, 
    SHGetIconOverlayIndexValue iIconIndex
);

HRESULT SHGetInstanceExplorer(
    [out] IUnknown **ppunk
);

//HRESULT SHGetMalloc(
//    [out] IMalloc **ppMalloc
//);

HRESULT SHGetMalloc(
    LPVOID ppMalloc
);

FailOnFalse SHGetNewLinkInfoA(
    LPCSTR pszLinkTo,
    LPCSTR pszDir,
    [out] LPSTR pszName,
    [out] BOOL *pfMustCopy,
    UINT uFlags
);

FailOnFalse SHGetNewLinkInfoW(
    LPCWSTR pszLinkTo,
    LPCWSTR pszDir,
    [out] LPWSTR pszName,
    [out] BOOL *pfMustCopy,
    UINT uFlags
);

FailOnFalse SHGetPathFromIDListA(
    LPCITEMIDLIST pidl,
    [out] LPSTR pszPath
);

FailOnFalse SHGetPathFromIDListW(
    LPCITEMIDLIST pidl,
    [out] LPWSTR pszPath
);

VOID SHGetSettings(
    LPSHELLFLAGSTATE lpsfs,
    SHGetSettingsMask dwMask
);

HRESULT SHGetSpecialFolderLocation(
    HWND hwndOwner,
    CSIDL nFolder,
    [out] LPITEMIDLIST *ppidl
);

FailOnFalse SHGetSpecialFolderPathA(
    HWND hwndOwner,
    [out] LPSTR lpszPath,
    CSIDL nFolder,
    BOOL fCreate
);

FailOnFalse SHGetSpecialFolderPathW(
    HWND hwndOwner,
    [out] LPWSTR lpszPath,
    CSIDL nFolder,
    BOOL fCreate
);

FailOnFalse SHInvokePrinterCommandW(
    HWND hwnd,
    SHInvokePrinterCommandAction uAction,
    LPCWSTR lpBuf1,
    LPCWSTR lpBuf2,
    BOOL fModal
);

FailOnFalse SHInvokePrinterCommandA(
    HWND hwnd,
    SHInvokePrinterCommandAction uAction,
    LPCSTR lpBuf1,
    LPCSTR lpBuf2,
    BOOL fModal
);

HRESULT SHLoadInProc(
    REFCLSID rclsid
);

HRESULT SHQueryRecycleBinA(
    LPCSTR pszRootPath, 
    LPSHQUERYRBINFO pSHQueryRBInfo
);

HRESULT SHQueryRecycleBinW(
    LPCWSTR pszRootPath, 
    LPSHQUERYRBINFO pSHQueryRBInfo
);

module USER32.DLL:
FailOnFalse [gle] WinHelpA(
    HWND hWndMain,
    LPCSTR lpszHelp,
    WinHelpCommands uCommand,
    DWORD dwData
);

FailOnFalse [gle] WinHelpW(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    WinHelpCommands uCommand,
    DWORD dwData
);


module URL.DLL:

BOOL InetIsOffline(
  DWORD dwFlags
);

HRESULT MIMEAssociationDialogA(
  HWND     hwndParent, 
  DWORD    dwInFlags, 
  LPCSTR   pcszFile, 
  LPCSTR   pcszMIMEContentType, 
  LPSTR    pszAppBuf, 
  UINT     ucAppBufLen
);

HRESULT MIMEAssociationDialogW(
  HWND     hwndParent, 
  DWORD    dwInFlags, 
  LPCWSTR   pcszFile, 
  LPCWSTR   pcszMIMEContentType, 
  LPWSTR    pszAppBuf, 
  UINT     ucAppBufLen
);

HRESULT TranslateURL(
  LPCSTR pcszURL, 
  TranslateUrlFlags dwInFlags, 
  [out] LPSTR *ppszTranslatedURL
);

HRESULT URLAssociationDialog(
  HWND hwndParent, 
  URLAssociationDialogFlags dwInFlags, 
  LPCSTR pcszFile, 
  LPCSTR pcszURL, 
  LPSTR pszAppBuf, 
  UINT ucAppBufLen
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\user32.h ===
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
//                              USER32 API Set
//
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
module USER32.DLL:
category User32:

value DWORD PeekMessageOptions
{
#define PM_NOREMOVE         0x0000
#define PM_REMOVE           0x0001
#define PM_NOYIELD          0x0002
};

value DWORD WindowsMessage
{
#define WM_NULL                         0x0000
#define WM_CREATE                       0x0001
#define WM_DESTROY                      0x0002
#define WM_MOVE                         0x0003
#define WM_SIZE                         0x0005
#define WM_ACTIVATE                     0x0006
#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#define WM_QUERYENDSESSION              0x0011
#define WM_QUIT                         0x0012
#define WM_QUERYOPEN                    0x0013
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_ENDSESSION                   0x0016
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#define WM_DEVMODECHANGE                0x001B
#define WM_ACTIVATEAPP                  0x001C
#define WM_FONTCHANGE                   0x001D
#define WM_TIMECHANGE                   0x001E
#define WM_CANCELMODE                   0x001F
#define WM_SETCURSOR                    0x0020
#define WM_MOUSEACTIVATE                0x0021
#define WM_CHILDACTIVATE                0x0022
#define WM_QUEUESYNC                    0x0023
#define WM_GETMINMAXINFO                0x0024
#define WM_PAINTICON                    0x0026
#define WM_ICONERASEBKGND               0x0027
#define WM_NEXTDLGCTL                   0x0028
#define WM_SPOOLERSTATUS                0x002A
#define WM_DRAWITEM                     0x002B
#define WM_MEASUREITEM                  0x002C
#define WM_DELETEITEM                   0x002D
#define WM_VKEYTOITEM                   0x002E
#define WM_CHARTOITEM                   0x002F
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define WM_GETHOTKEY                    0x0033
#define WM_QUERYDRAGICON                0x0037
#define WM_COMPAREITEM                  0x0039
#define WM_GETOBJECT                    0x003D
#define WM_COMPACTING                   0x0041
#define WM_COMMNOTIFY                   0x0044
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_WINDOWPOSCHANGED             0x0047
#define WM_POWER                        0x0048
#define WM_COPYDATA                     0x004A
#define WM_CANCELJOURNAL                0x004B
#define WM_NOTIFY                       0x004E
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define WM_INPUTLANGCHANGE              0x0051
#define WM_TCARD                        0x0052
#define WM_HELP                         0x0053
#define WM_USERCHANGED                  0x0054
#define WM_NOTIFYFORMAT                 0x0055
#define WM_CONTEXTMENU                  0x007B
#define WM_STYLECHANGING                0x007C
#define WM_STYLECHANGED                 0x007D
#define WM_DISPLAYCHANGE                0x007E
#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087
#define WM_SYNCPAINT                    0x0088
#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9

#define EM_GETSEL                       0x00B0
#define EM_SETSEL                       0x00B1
#define EM_GETRECT                      0x00B2
#define EM_SETRECT                      0x00B3
#define EM_SETRECTNP                    0x00B4
#define EM_SCROLL                       0x00B5
#define EM_LINESCROLL                   0x00B6
#define EM_SCROLLCARET                  0x00B7
#define EM_GETMODIFY                    0x00B8
#define EM_SETMODIFY                    0x00B9
#define EM_GETLINECOUNT                 0x00BA
#define EM_LINEINDEX                    0x00BB
#define EM_SETHANDLE                    0x00BC
#define EM_GETHANDLE                    0x00BD
#define EM_GETTHUMB                     0x00BE
#define EM_LINELENGTH                   0x00C1
#define EM_REPLACESEL                   0x00C2
#define EM_GETLINE                      0x00C4
#define EM_LIMITTEXT                    0x00C5
#define EM_CANUNDO                      0x00C6
#define EM_UNDO                         0x00C7
#define EM_FMTLINES                     0x00C8
#define EM_LINEFROMCHAR                 0x00C9
#define EM_SETTABSTOPS                  0x00CB
#define EM_SETPASSWORDCHAR              0x00CC
#define EM_EMPTYUNDOBUFFER              0x00CD
#define EM_GETFIRSTVISIBLELINE          0x00CE
#define EM_SETREADONLY                  0x00CF
#define EM_SETWORDBREAKPROC             0x00D0
#define EM_GETWORDBREAKPROC             0x00D1
#define EM_GETPASSWORDCHAR              0x00D2
#define EM_SETMARGINS                   0x00D3
#define EM_GETMARGINS                   0x00D4
#define EM_GETLIMITTEXT                 0x00D5
#define EM_POSFROMCHAR                  0x00D6
#define EM_CHARFROMPOS                  0x00D7
#define EM_SETIMESTATUS                 0x00D8
#define EM_GETIMESTATUS                 0x00D9

#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_KEYLAST                      0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_SYSTIMER                     0x0118
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121
#define WM_MENURBUTTONUP                0x0122
#define WM_MENUDRAG                     0x0123
#define WM_MENUGETOBJECT                0x0124
#define WM_UNINITMENUPOPUP              0x0125
#define WM_MENUCOMMAND                  0x0126
#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138
#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#define WM_MOUSEWHEEL                   0x020A
#define WM_MOUSELAST                    0x0209
#define WM_PARENTNOTIFY                 0x0210
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212
#define WM_NEXTMENU                     0x0213
#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#define WM_POWERBROADCAST               0x0218
#define WM_DEVICECHANGE                 0x0219
#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229
#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234
#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_REQUEST                  0x0288
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#define WM_MOUSEHOVER                   0x02A1
#define WM_MOUSELEAVE                   0x02A3
#define WM_CUT                          0x0300
#define WM_COPY                         0x0301
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318
#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F
#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
};

value DWORD SystemObjectId
{
#define     OBJID_WINDOW            0x00000000
#define     OBJID_SYSMENU           0xFFFFFFFF
#define     OBJID_TITLEBAR          0xFFFFFFFE
#define     OBJID_MENU              0xFFFFFFFD
#define     OBJID_CLIENT            0xFFFFFFFC
#define     OBJID_VSCROLL           0xFFFFFFFB
#define     OBJID_HSCROLL           0xFFFFFFFA
#define     OBJID_SIZEGRIP          0xFFFFFFF9
#define     OBJID_CARET             0xFFFFFFF8
#define     OBJID_CURSOR            0xFFFFFFF7
#define     OBJID_ALERT             0xFFFFFFF6
#define     OBJID_SOUND             0xFFFFFFF5
#define     OBJID_QUERYCLASSNAMEIDX 0xFFFFFFF4
#define     OBJID_NATIVEOM          0xFFFFFFF0
};

typedef struct tagMSG {     // msg  
    HWND            hwnd;      
    WindowsMessage  message;
    WPARAM          wParam;
    LPARAM          lParam;
    DWORD           time;
    POINT           pt;
} MSG, *LPMSG;

mask DWORD WindowStyle
{
#define WS_OVERLAPPED       0x00000000
#define WS_POPUP            0x80000000
#define WS_CHILD            0x40000000
#define WS_MINIMIZE         0x20000000
#define WS_VISIBLE          0x10000000
#define WS_DISABLED         0x08000000
#define WS_CLIPSIBLINGS     0x04000000
#define WS_CLIPCHILDREN     0x02000000
#define WS_MAXIMIZE         0x01000000
#define WS_BORDER           0x00800000
#define WS_DLGFRAME         0x00400000
#define WS_VSCROLL          0x00200000
#define WS_HSCROLL          0x00100000
#define WS_SYSMENU          0x00080000
#define WS_THICKFRAME       0x00040000
#define WS_GROUP            0x00020000
#define WS_TABSTOP          0x00010000
#define WS_ACTIVECAPTION    0x00000001
};

mask DWORD WindowStyleEx
{
#define WS_EX_LEFT              0x00000000

#define WS_EX_DLGMODALFRAME     0x00000001
#define WS_EX_NOPARENTNOTIFY    0x00000004
#define WS_EX_TOPMOST           0x00000008
#define WS_EX_ACCEPTFILES       0x00000010
#define WS_EX_TRANSPARENT       0x00000020
#define WS_EX_MDICHILD          0x00000040
#define WS_EX_TOOLWINDOW        0x00000080
#define WS_EX_WINDOWEDGE        0x00000100
#define WS_EX_CLIENTEDGE        0x00000200
#define WS_EX_CONTEXTHELP       0x00000400

#define WS_EX_RIGHT             0x00001000
#define WS_EX_RTLREADING        0x00002000
#define WS_EX_LEFTSCROLLBAR     0x00004000

#define WS_EX_CONTROLPARENT     0x00010000
#define WS_EX_STATICEDGE        0x00020000
#define WS_EX_APPWINDOW         0x00040000
#define WS_EX_LAYERED           0x00080000

#define WS_EX_NOINHERITLAYOUT   0x00100000
#define WS_EX_LAYOUTRTL         0x00400000
#define WS_EX_COMPOSITED        0x02000000
#define WS_EX_NOACTIVATE        0x08000000
};


HWND [gle] CreateWindowExA(
    WindowStyleEx dwExStyle,
    LPCSTR        lpClassName,
    LPCSTR        lpWindowName,
    WindowStyle   dwStyle,
    int           X,
    int           Y,
    int           nWidth,
    int           nHeight,
    HWND          hWndParent,
    ULONG         hMenu,
    HINSTANCE     hInstance,
    LPVOID        lpParam);

HWND [gle] CreateWindowExW(
    WindowStyleEx dwExStyle,
    LPCWSTR       lpClassName,
    LPCWSTR       lpWindowName,
    WindowStyle   dwStyle,
    int           X,
    int           Y,
    int           nWidth,
    int           nHeight,
    HWND          hWndParent,
    ULONG         hMenu,
    HINSTANCE     hInstance,
    LPVOID        lpParam);

FailOnFalse [gle] DestroyWindow( [da] HWND hWnd);

FailOnFalse [gle] CloseWindow(HWND hWnd);

mask DWORD ActivateKeyboardLayoutFlags
{
#define KLF_ACTIVATE        0x00000001
#define KLF_SUBSTITUTE_OK   0x00000002
#define KLF_REORDER         0x00000008
#define KLF_REPLACELANG     0x00000010
#define KLF_NOTELLSHELL     0x00000080
#define KLF_SETFORPROCESS   0x00000100
#define KLF_SHIFTLOCK       0x00010000
#define KLF_RESET           0x40000000
};


HKL ActivateKeyboardLayout(HKL hkl, ActivateKeyboardLayoutFlags Flags);
HKL GetKeyboardLayout(ThreadId idThread);

// BUGBUG: lpList is an array but there is no easy way to show all the values in it.
LongFailIfZero [gle] GetKeyboardLayoutList(int nBuff, [out] HKL* lpList);

FailOnFalse [gle] GetKeyboardLayoutNameA([out] LPSTR pwszKLID);
FailOnFalse [gle] GetKeyboardLayoutNameW([out] LPWSTR pwszKLID);


UINT GetKBCodePage();

mask DWORD KeyboardLayoutFlags
{
#define KLF_ACTIVATE        0x00000001
#define KLF_SUBSTITUTE_OK   0x00000002
#define KLF_REORDER         0x00000008
#define KLF_REPLACELANG     0x00000010
#define KLF_NOTELLSHELL     0x00000080
#define KLF_SETFORPROCESS   0x00000100
#define KLF_SHIFTLOCK       0x00010000
#define KLF_RESET           0x40000000
};

HKL [gle] LoadKeyboardLayoutA(LPCSTR pwszKLID, KeyboardLayoutFlags Flags);
HKL [gle] LoadKeyboardLayoutW(LPCWSTR pwszKLID, KeyboardLayoutFlags Flags);

FailOnFalse [gle] UnloadKeyboardLayout([da] HKL hkl);

FailOnFalse [gle] SetProcessDefaultLayout(DWORD dwDefaultLayout);
FailOnFalse [gle] GetProcessDefaultLayout([out] LPDWORD lpdwDefaultLayout);



FailOnFalse AdjustWindowRect([out] LPRECT lpRect, WindowStyle dwStyle, BOOL bMenu);
FailOnFalse AdjustWindowRectEx([out] LPRECT lpRect, WindowStyle dwStyle, BOOL bMenu, WindowStyleEx dwExStyle);

FailOnFalse AllowSetForegroundWindow(ProcessId dwProcessId);

HWND GetForegroundWindow();
FailOnFalse SetForegroundWindow(HWND hWnd);

value DWORD LockForegroundFlags
{
#define LSFW_LOCK       1
#define LSFW_UNLOCK     2
};

FailOnFalse [gle] LockSetForegroundWindow(LockForegroundFlags uLockCode);

HWND GetActiveWindow();
HWND [gle] SetActiveWindow(HWND hWnd);


mask DWORD AnimateWindowFlags
{
#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000
};

FailOnFalse AnimateWindow(HWND hWnd, DWORD dwTime, AnimateWindowFlags dwFlags);

FailOnFalse AnyPopup();

// Menu flags:

mask DWORD MenuFlags
{
#define MF_ENABLED          0x00000000
#define MF_GRAYED           0x00000001
#define MF_DISABLED         0x00000002
#define MF_BITMAP           0x00000004
#define MF_CHECKED          0x00000008
#define MF_POPUP            0x00000010
#define MF_MENUBARBREAK     0x00000020
#define MF_MENUBREAK        0x00000040
#define MF_CHANGE_HILITE    0x00000080
#define MF_OWNERDRAW        0x00000100
#define MF_DELETE           0x00000200
#define MF_BYPOSITION       0x00000400
#define MF_SEPARATOR        0x00000800
};



FailOnFalse [gle] AppendMenuA(HMENU hMenu, MenuFlags uFlags, DWORD uIDNewItem, LPCSTR lpNewItem);
FailOnFalse [gle] AppendMenuW(HMENU hMenu, MenuFlags uFlags, DWORD uIDNewItem, LPCWSTR lpNewItem);

HMENU [gle] LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName);
HMENU [gle] LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);

HMENU [gle] LoadMenuIndirectA(LPVOID lpMenuTemplate);
HMENU [gle] LoadMenuIndirectW(LPVOID lpMenuTemplate);


HMENU [gle] CreateMenu();

FailOnFalse [gle] DestroyMenu( [da] HMENU hMenu);

FailOnFalse [gle] DeleteMenu(HMENU hMenu, UINT uPosition, MenuFlags uFlags);

MenuFlags CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, MenuFlags uCheck);

FailOnFalse [gle] CheckMenuRadioItem(HMENU     hMenu,
                                     UINT      idFirst,
                                     UINT      idLast,
                                     UINT      idCheck,
                                     MenuFlags uFlags);

HMENU [gle] CreatePopupMenu();

FailOnFalse [gle] DrawMenuBar(HWND hWnd);

MenuFlags EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, MenuFlags uEnable);

FailOnFalse [gle] EndMenu();

HMENU GetMenu(HWND hWnd);

typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT  rcBar;
    HMENU hMenu;
    HWND  hwndMenu;
    DWORD fFocused;
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

FailOnFalse [gle] GetMenuBarInfo(HWND              hwnd,
                                 SystemObjectId    idObject,
                                 LONG              idItem,
                                 [out] MENUBARINFO pmbi);

LONG GetMenuCheckMarkDimensions();

DWORD GetMenuContextHelpId(HMENU hmenu);

mask DWORD GetMenuDefItemFlags
{
#define GMDI_USEDISABLED    0x0001
#define GMDI_GOINTOPOPUPS   0x0002
};

LongFailIfNeg1 [gle] GetMenuDefaultItem(HMENU hMenu, BOOL bByPos, GetMenuDefItemFlags gmdiFlags);

mask DWORD MenuInfoMask
{
#define MIM_MAXHEIGHT               0x00000001
#define MIM_BACKGROUND              0x00000002
#define MIM_HELPID                  0x00000004
#define MIM_MENUDATA                0x00000008
#define MIM_STYLE                   0x00000010
#define MIM_APPLYTOSUBMENUS         0x80000000
};

mask DWORD MenuInfoStyle
{
#define MNS_NOCHECK         0x80000000
#define MNS_MODELESS        0x40000000
#define MNS_DRAGDROP        0x20000000
#define MNS_AUTODISMISS     0x10000000
#define MNS_NOTIFYBYPOS     0x08000000
#define MNS_CHECKORBMP      0x04000000
};

typedef struct tagMENUINFO
{
    DWORD         cbSize;
    MenuInfoMask  fMask;
    MenuInfoStyle dwStyle;
    UINT          cyMax;
    HRSRC         hbrBack;
    DWORD         dwContextHelpID;
    DWORD         dwMenuData;
} MENUINFO, *LPMENUINFO;

FailOnFalse [gle] GetMenuInfo(HMENU hMenu, [out] LPMENUINFO lpmi);

LongFailIfNeg1 [gle] GetMenuItemCount(HMENU hMenu);

LongFailIfNeg1 GetMenuItemID(HMENU hMenu, int nPos);

mask DWORD MenuItemInfoMask
{
#define MIIM_STATE       0x00000001
#define MIIM_ID          0x00000002
#define MIIM_SUBMENU     0x00000004
#define MIIM_CHECKMARKS  0x00000008
#define MIIM_TYPE        0x00000010
#define MIIM_DATA        0x00000020

#define MIIM_STRING      0x00000040
#define MIIM_BITMAP      0x00000080
#define MIIM_FTYPE       0x00000100
};

mask DWORD MenuItemInfoType
{
#define MFT_STRING          0x00000000
#define MFT_BITMAP          0x00000004
#define MFT_MENUBARBREAK    0x00000020
#define MFT_MENUBREAK       0x00000040
#define MFT_OWNERDRAW       0x00000100
#define MFT_RADIOCHECK      0x00000200
#define MFT_SEPARATOR       0x00000800
#define MFT_RIGHTORDER      0x00002000
#define MFT_RIGHTJUSTIFY    0x00004000
};

mask DWORD MenuItemInfoState
{
#define MFS_CHECKED         0x00000008
#define MFS_DEFAULT         0x00001000
#define MFS_DISABLED1       0x00000001
#define MFS_DISABLED2       0x00000002
#define MFS_HILITE          0x00000080
};

typedef struct tagMENUITEMINFOA
{
    UINT              cbSize;
    MenuItemInfoMask  fMask;
    MenuItemInfoType  fType;
    MenuItemInfoState fState;
    UINT              wID;
    HMENU             hSubMenu;
    HRSRC             hbmpChecked;
    HRSRC             hbmpUnchecked;
    DWORD             dwItemData;
    LPSTR             dwTypeData;
    UINT              cch;
    HRSRC             hbmpItem;
}   MENUITEMINFOA, *LPMENUITEMINFOA;

typedef struct tagMENUITEMINFOW
{
    UINT              cbSize;
    MenuItemInfoMask  fMask;
    MenuItemInfoType  fType;
    MenuItemInfoState fState;
    UINT              wID;
    HMENU             hSubMenu;
    HRSRC             hbmpChecked;
    HRSRC             hbmpUnchecked;
    DWORD             dwItemData;
    LPWSTR            dwTypeData;
    UINT              cch;
    HRSRC             hbmpItem;
}   MENUITEMINFOW, *LPMENUITEMINFOW;


FailOnFalse [gle] GetMenuItemInfoA(HMENU hMenu,
                                   UINT  uItem,
                                   BOOL  fByPosition,
                                   [out] LPMENUITEMINFOA lpmii);

FailOnFalse [gle] GetMenuItemInfoW(HMENU hMenu,
                                   UINT  uItem,
                                   BOOL  fByPosition,
                                   [out] LPMENUITEMINFOW lpmii);

FailOnFalse [gle] GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, [out] LPRECT lprcItem);

MenuFlags GetMenuState(HMENU hMenu, UINT uId, MenuFlags uFlags);

UintFailIfZero GetMenuStringA(HMENU       hMenu,
                              UINT        uIDItem,
                              [out] LPSTR lpString,
                              int         nMaxCount,
                              MenuFlags   uFlag);

UintFailIfZero GetMenuStringW(HMENU        hMenu,
                              UINT         uIDItem,
                              [out] LPWSTR lpString,
                              int          nMaxCount,
                              MenuFlags    uFlag);

HMENU GetSubMenu(HMENU hMenu, int nPos);

HMENU GetSystemMenu(HWND hWnd, BOOL bRevert);

FailOnFalse HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, MenuFlags uHilite);

FailOnFalse [gle] InsertMenuA(HMENU     hMenu,
                              UINT      uPosition,
                              MenuFlags uFlags,
                              DWORD     uIDNewItem,
                              DWORD     lpNewItem);

FailOnFalse [gle] InsertMenuW(HMENU     hMenu,
                              UINT      uPosition,
                              MenuFlags uFlags,
                              DWORD     uIDNewItem,
                              DWORD     lpNewItem);

FailOnFalse InsertMenuItemA(HMENU           hMenu,
                            UINT            uItem,
                            BOOL            bByPosition,
                            LPMENUITEMINFOA lpmii);

FailOnFalse InsertMenuItemW(HMENU           hMenu,
                            UINT            uItem,
                            BOOL            bByPosition,
                            LPMENUITEMINFOW lpmii);


LongFailIfNeg1 MenuItemFromPoint(HWND hWnd, HMENU hMenu, int x, int y);

FailOnFalse [gle] ModifyMenuA(HMENU     hMenu,
                              UINT      uPosition,
                              MenuFlags uFlags,
                              DWORD     uIDNewItem,
                              DWORD     lpNewItem);

FailOnFalse [gle] ModifyMenuW(HMENU     hMenu,
                              UINT      uPosition,
                              MenuFlags uFlags,
                              DWORD     uIDNewItem,
                              DWORD     lpNewItem);


FailOnFalse [gle] RemoveMenu(HMENU     hMenu,
                             UINT      uPosition,
                             MenuFlags uFlags);

FailOnFalse [gle] SetMenu(HWND hWnd, HMENU hMenu);

FailOnFalse [gle] SetMenuContextHelpId(HMENU hmenu, DWORD dwContextHelpId);

FailOnFalse [gle] SetMenuDefaultItem(HMENU hMenu, UINT uItem, BOOL fByPos);

FailOnFalse [gle] SetMenuInfo(HMENU hMenu, LPMENUINFO lpmi);

FailOnFalse [gle] SetMenuItemBitmaps(HMENU     hMenu,
                                     UINT      uPosition,
                                     MenuFlags uFlags,
                                     HRSRC     hBitmapUnchecked,
                                     HRSRC     hBitmapChecked);

FailOnFalse [gle] SetMenuItemInfoA(HMENU           hMenu,
                                   UINT            uItem,
                                   BOOL            fByPosition,
                                   LPMENUITEMINFOA lpmii);

FailOnFalse [gle] SetMenuItemInfoW(HMENU           hMenu,
                                   UINT            uItem,
                                   BOOL            fByPosition,
                                   LPMENUITEMINFOW lpmii);

mask DWORD TrackPopupMenuFlags
{
#define TPM_LEFTTOPALIGN    0x0000
#define TPM_RECURSE         0x0001
#define TPM_RIGHTBUTTON     0x0002
#define TPM_CENTERALIGN     0x0004
#define TPM_RIGHTALIGN      0x0008
#define TPM_VCENTERALIGN    0x0010
#define TPM_BOTTOMALIGN     0x0020
#define TPM_VERTICAL        0x0040
#define TPM_NONOTIFY        0x0080
#define TPM_RETURNCMD       0x0100
#define TPM_HORPOSANIMATION 0x0400
#define TPM_HORNEGANIMATION 0x0800
#define TPM_VERPOSANIMATION 0x1000
#define TPM_VERNEGANIMATION 0x2000
#define TPM_NOANIMATION     0x4000
};


LongFailIfZero [gle] TrackPopupMenu(HMENU               hMenu,
                                    TrackPopupMenuFlags uFlags,
                                    int                 x,
                                    int                 y,
                                    int                 nReserved,
                                    HWND                hWnd,
                                    LPRECT              lprect);

typedef struct tagTPMPARAMS
{
    UINT    cbSize;
    RECT    rcExclude;
} TPMPARAMS, *LPTPMPARAMS;

LongFailIfZero [gle] TrackPopupMenuEx(HMENU hMenu,
                                      TrackPopupMenuFlags uFlags,
                                      int                 x,
                                      int                 y,
                                      HWND                hWnd,
                                      LPTPMPARAMS         lpParams);


FailOnFalse [gle] ArrangeIconicWindows(HWND hwnd);

FailOnFalse [gle] AttachThreadInput(ThreadId idAttach, ThreadId idAttachTo, BOOL fAttach);

value DWORD HDWP
{
#define NULL                    0  [fail]
};

alias HDWP;

mask DWORD SetWindowPosFlags
{
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_ASYNCWINDOWPOS  0x4000
};

FailOnFalse [gle] SetWindowPos(HWND              hWnd,
                               HWND              hWndInsertAfter,
                               int               x,
                               int               y,
                               int               cx,
                               int               cy,
                               SetWindowPosFlags uFlags);

BOOL ShowWindow(HWND hWnd, ShowWindowCommand nCmdShow);

BOOL ShowWindowAsync(HWND hWnd, ShowWindowCommand nCmdShow);

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT, *LPWINDOWPLACEMENT;


FailOnFalse [gle] SetWindowPlacement(HWND              hWnd,
                                     LPWINDOWPLACEMENT lpwndpl);

FailOnFalse [gle] GetWindowPlacement(HWND hWnd, [out] LPWINDOWPLACEMENT lpwndpl);


HDWP BeginDeferWindowPos(int nNumWindows);
HDWP DeferWindowPos(HDWP              hWinPosInfo,
                    HWND              hWnd,
                    HWND              hWndInsertAfter,
                    int               x,
                    int               y,
                    int               cx,
                    int               cy,
                    SetWindowPosFlags uFlags);

FailOnFalse [gle] EndDeferWindowPos( [da] HDWP hWinPosInfo);

FailOnFalse [gle] MoveWindow(HWND hWnd,
                             int  X,
                             int  Y,
                             int  nWidth,
                             int  nHeight,
                             BOOL bRepaint);

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *LPPAINTSTRUCT;


HDC  BeginPaint(HWND hWnd, [out] LPPAINTSTRUCT lpPaint);
FailOnFalse EndPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);

mask DWORD RedrawWindowFlags
{
#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800
};

FailOnFalse [gle] RedrawWindow(HWND              hWnd,
                               LPRECT            lprcUpdate,
                               HRGN              hrgnUpdate,
                               RedrawWindowFlags flags);

FailOnFalse [gle] PaintDesktop(HDC hdc);

HWND GetDesktopWindow();

HDC [gle] GetDC(HWND hWnd);

mask DWORD GetDCExFlags
{
#define DCX_WINDOW           0x00000001
#define DCX_CACHE            0x00000002
#define DCX_NORESETATTRS     0x00000004
#define DCX_CLIPCHILDREN     0x00000008
#define DCX_CLIPSIBLINGS     0x00000010
#define DCX_PARENTCLIP       0x00000020
#define DCX_EXCLUDERGN       0x00000040
#define DCX_INTERSECTRGN     0x00000080
#define DCX_EXCLUDEUPDATE    0x00000100
#define DCX_INTERSECTUPDATE  0x00000200
#define DCX_LOCKWINDOWUPDATE 0x00000400
#define DCX_VALIDATE         0x00200000
};

HDC [gle] GetDCEx(HWND hWnd, HRGN hrgnClip, GetDCExFlags flags);

HDC [gle] GetWindowDC(HWND hWnd);

FailOnFalse ReleaseDC(HWND hWnd, [da] HDC hDC);

FailOnFalse [gle] ScrollDC(HDC          hDC,
                           int          dx,
                           int          dy,
                           LPRECT       lprcScroll,
                           LPRECT       lprcClip,
                           HRGN         hrgnUpdate,
                           [out] LPRECT lprcUpdate);

FailOnFalse [gle] UpdateWindow(HWND hWnd);

FailOnFalse [gle] InvalidateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);
FailOnFalse [gle] InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);

FailOnFalse [gle] ValidateRect(HWND hWnd, LPRECT lpRect);
FailOnFalse [gle] ValidateRgn(HWND hWnd, HRGN hRgn);

HRGN ExcludeUpdateRgn(HDC hDC, HWND hWnd);

FailOnFalse [gle] GetUpdateRect(HWND         hWnd,
                                [out] LPRECT lpRect,
                                BOOL         bErase);

HRGN GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);


HWND WindowFromDC(HDC hDC);

HWND WindowFromPoint(long x, long y);

HWND ChildWindowFromPoint(HWND hWndParent, int x, int y);

mask DWORD ChildWindowFromPointExFlags
{
#define CWP_ALL             0x0000
#define CWP_SKIPINVISIBLE   0x0001
#define CWP_SKIPDISABLED    0x0002
#define CWP_SKIPTRANSPARENT 0x0004
};

HWND ChildWindowFromPointEx(HWND hwndParent, int x, int y, ChildWindowFromPointExFlags dwFlags);

HWND RealChildWindowFromPoint(HWND hwndParent, int x, int y);

// BUGBUG: need to use [in] [ou]
FailOnFalse [gle] ClientToScreen(HWND hWnd, [out] LPPOINT lpPoint);
FailOnFalse [gle] ScreenToClient(HWND hWnd, [out] LPPOINT lpPoint);


FailOnFalse [gle] ScrollWindow(HWND   hWnd,
                               int    XAmount,
                               int    YAmount,
                               LPRECT lpRect,
                               LPRECT lpClipRect);

mask DWORD ScrollWindowExFlags
{
#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004
#define SW_SMOOTHSCROLL     0x0010
};

HRGN [gle] ScrollWindowEx(HWND                hWnd,
                          int                 dx,
                          int                 dy,
                          LPRECT              lprcScroll,
                          LPRECT              lprcClip,
                          HRGN                hrgnUpdate,
                          [out] LPRECT        lprcUpdate,
                          ScrollWindowExFlags flags);



LRESULT SendMessageA(HWND hWnd, WindowsMessage Msg, WPARAM wParam, LPARAM lParam);
LRESULT SendMessageW(HWND hWnd, WindowsMessage Msg, WPARAM wParam, LPARAM lParam);

LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, WindowsMessage Msg, WPARAM wParam, LPARAM lParam);
LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, WindowsMessage Msg, WPARAM wParam, LPARAM lParam);

FailOnFalse [gle] PostMessageA(HWND           hWnd,
                               WindowsMessage Msg,
                               WPARAM         wParam,
                               LPARAM         lParam);

FailOnFalse [gle] PostMessageW(HWND           hWnd,
                               WindowsMessage Msg,
                               WPARAM         wParam,
                               LPARAM         lParam);

VOID PostQuitMessage(int nExitCode);

FailOnFalse [gle] PostThreadMessageA(ThreadId       idThread,
                                     WindowsMessage Msg,
                                     WPARAM         wParam,
                                     LPARAM         lParam);

FailOnFalse [gle] PostThreadMessageW(ThreadId       idThread,
                                     WindowsMessage Msg,
                                     WPARAM         wParam,
                                     LPARAM         lParam);

BOOL TranslateMessage(MSG* lpMsg);


typedef DWORD SENDASYNCPROC;

alias SENDASYNCPROC;

FailOnFalse [gle] SendMessageCallbackA(HWND           hWnd,
                                       WindowsMessage Msg,
                                       WPARAM         wParam,
                                       LPARAM         lParam,
                                       SENDASYNCPROC  lpResultCallBack,
                                       ULONG_PTR      dwData);

FailOnFalse [gle] SendMessageCallbackW(HWND           hWnd,
                                       WindowsMessage Msg,
                                       WPARAM         wParam,
                                       LPARAM         lParam,
                                       SENDASYNCPROC  lpResultCallBack,
                                       ULONG_PTR      dwData);

mask DWORD SendMessageTimeoutFlags
{
#define SMTO_NORMAL             0x0000
#define SMTO_BLOCK              0x0001
#define SMTO_ABORTIFHUNG        0x0002
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008
};

LRESULT SendMessageTimeoutA(HWND                    hWnd,
                            WindowsMessage          Msg,
                            WPARAM                  wParam,
                            LPARAM                  lParam,
                            SendMessageTimeoutFlags fuFlags,
                            UINT                    uTimeout,
                            [out] LPDWORD           lpdwResult);

LRESULT SendMessageTimeoutW(HWND                    hWnd,
                            WindowsMessage          Msg,
                            WPARAM                  wParam,
                            LPARAM                  lParam,
                            SendMessageTimeoutFlags fuFlags,
                            UINT                    uTimeout,
                            [out] LPDWORD           lpdwResult);

FailOnFalse [gle] SendNotifyMessageA(HWND           hWnd,
                                     WindowsMessage Msg,
                                     WPARAM         wParam,
                                     LPARAM         lParam);

FailOnFalse [gle] SendNotifyMessageW(HWND           hWnd,
                                     WindowsMessage Msg,
                                     WPARAM         wParam,
                                     LPARAM         lParam);


BOOL InSendMessage();

mask DWORD InSendMessageExFlags
{
#define ISMEX_NOSEND      0x00000000
#define ISMEX_SEND        0x00000001
#define ISMEX_NOTIFY      0x00000002
#define ISMEX_CALLBACK    0x00000004
#define ISMEX_REPLIED     0x00000008
};

InSendMessageExFlags InSendMessageEx(LPVOID lpReserved);


mask DWORD BroadcastSystemMessageFlags
{
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002
#define BSF_FLUSHDISK           0x00000004
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040
#define BSF_ALLOWSFW            0x00000080
#define BSF_SENDNOTIFYMESSAGE   0x00000100
#define BSF_RETURNHDESK         0x00000200
#define BSF_LUID                0x00000400
};

mask DWORD BroadcastSystemMessageRecipients
{
#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008
#define BSM_ALLDESKTOPS         0x00000010
};

LongFailIfNeg1 [gle] BroadcastSystemMessageA(BroadcastSystemMessageFlags             Flags,
                                             [out] BroadcastSystemMessageRecipients* lpRecipients,
                                             WindowsMessage                          Msg,
                                             WPARAM                                  wParam,
                                             LPARAM                                  lParam);

LongFailIfNeg1 [gle] BroadcastSystemMessageW(BroadcastSystemMessageFlags             Flags,
                                             [out] BroadcastSystemMessageRecipients* lpRecipients,
                                             WindowsMessage                          Msg,
                                             WPARAM                                  wParam,
                                             LPARAM                                  lParam);

LRESULT DispatchMessageA(MSG* lpMsg);
LRESULT DispatchMessageW(MSG* lpMsg);

LongFailIfNeg1 [gle] GetMessageA( [out] LPMSG   lpMsg,
                                 HWND           hWnd,
                                 WindowsMessage wMsgFilterMin,
                                 WindowsMessage wMsgFilterMax);

LongFailIfNeg1 [gle] GetMessageW( [out] LPMSG   lpMsg,
                                 HWND           hWnd,
                                 WindowsMessage wMsgFilterMin,
                                 WindowsMessage wMsgFilterMax);

FailOnFalse [gle] WaitMessage();

BOOL ReplyMessage(LRESULT lResult);

mask DWORD PeekMessageFlags
{
#define PM_NOREMOVE         0x0000
#define PM_REMOVE           0x0001
#define PM_NOYIELD          0x0002
};

BOOL PeekMessageA( [out] LPMSG      lpMsg,
                  HWND              hWnd,
                  WindowsMessage    wMsgFilterMin,
                  WindowsMessage    wMsgFilterMax,
                  PeekMessageFlags  wRemoveMsg);

BOOL PeekMessageW( [out] LPMSG      lpMsg,
                  HWND              hWnd,
                  WindowsMessage    wMsgFilterMin,
                  WindowsMessage    wMsgFilterMax,
                  PeekMessageFlags  wRemoveMsg);


LPARAM GetMessageExtraInfo();
DWORD  GetMessagePos();
LONG   GetMessageTime();

LRESULT DefWindowProcA(HWND           hWnd,
                       WindowsMessage Msg,
                       WPARAM         wParam,
                       LPARAM         lParam);

LRESULT DefWindowProcW(HWND           hWnd,
                       WindowsMessage Msg,
                       WPARAM         wParam,
                       LPARAM         lParam);

LRESULT DefDlgProcA(HWND           hDlg,
                    WindowsMessage Msg,
                    WPARAM         wParam,
                    LPARAM         lParam);

LRESULT DefDlgProcW(HWND           hDlg,
                    WindowsMessage Msg,
                    WPARAM         wParam,
                    LPARAM         lParam);

LRESULT DefFrameProcA(HWND           hWnd,
                      HWND           hWndMDIClient,
                      WindowsMessage uMsg,
                      WPARAM         wParam,
                      LPARAM         lParam);

LRESULT DefFrameProcW(HWND           hWnd,
                      HWND           hWndMDIClient,
                      WindowsMessage uMsg,
                      WPARAM         wParam,
                      LPARAM         lParam);


LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, WindowsMessage Msg, WPARAM wParam, LPARAM lParam);
LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, WindowsMessage Msg, WPARAM wParam, LPARAM lParam);



value DWORD WindowLongIndex
{
#define GWL_WNDPROC         -4
#define GWL_HINSTANCE       -6
#define GWL_HWNDPARENT      -8
#define GWL_STYLE           -16
#define GWL_EXSTYLE         -20
#define GWL_USERDATA        -21
#define GWL_ID              -12
#define DWL_MSGRESULT       0
#define DWL_DLGPROC         4
#define DWL_USER            8
};

DwordFailIfZero [gle] GetWindowLongA(HWND hWnd, WindowLongIndex nIndex);
DwordFailIfZero [gle] GetWindowLongW(HWND hWnd, WindowLongIndex nIndex);

DwordFailIfZero [gle] SetWindowLongA(HWND hWnd, WindowLongIndex nIndex, DWORD dwNewLong);
DwordFailIfZero [gle] SetWindowLongW(HWND hWnd, WindowLongIndex nIndex, DWORD dwNewLong);

DwordFailIfZero [gle] GetWindowWord(HWND hWnd, int nIndex);
DwordFailIfZero [gle] SetWindowWord(HWND hWnd, int nIndex, DWORD wNewWord);


LongFailIfZero [gle] SetWindowTextA(HWND hWnd, LPCSTR lpString);
LongFailIfZero [gle] SetWindowTextW(HWND hWnd, LPCWSTR lpString);

LongFailIfZero [gle] GetWindowTextA(HWND hWnd, [out] LPSTR lpString, int nMaxCount);
LongFailIfZero [gle] GetWindowTextW(HWND hWnd, [out] LPWSTR lpString, int nMaxCount);

LongFailIfZero [gle] GetWindowTextLengthA(HWND hWnd);
LongFailIfZero [gle] GetWindowTextLengthW(HWND hWnd);

LongFailIfZero [gle] GetDlgItemTextA(HWND hDlg, int nIDDlgItem, [out] LPSTR lpString, int nMaxCount);
LongFailIfZero [gle] GetDlgItemTextW(HWND hDlg, int nIDDlgItem, [out] LPWSTR lpString, int nMaxCount);

FailOnFalse [gle] SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned);

FailOnFalse [gle] SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString);
FailOnFalse [gle] SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);

HWND [gle] GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
HWND [gle] GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious);

mask DWORD DlgDirListType
{
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000
};

LongFailIfZero [gle] DlgDirListA(HWND           hDlg,
                                 [out] LPSTR    lpPathSpec,
                                 int            nIDListBox,
                                 int            nIDStaticPath,
                                 DlgDirListType uFileType);

LongFailIfZero [gle] DlgDirListW(HWND           hDlg,
                                 [out] LPWSTR   lpPathSpec,
                                 int            nIDListBox,
                                 int            nIDStaticPath,
                                 DlgDirListType uFileType);

BOOL DlgDirSelectExA(HWND        hDlg,
                     [out] LPSTR lpString,
                     int         nCount,
                     int         nIDListBox);

BOOL DlgDirSelectExW(HWND         hDlg,
                     [out] LPWSTR lpString,
                     int          nCount,
                     int          nIDListBox);

LongFailIfZero [gle] DlgDirListComboBoxA(HWND           hDlg,
                                         [out] LPSTR    lpPathSpec,
                                         int            nIDComboBox,
                                         int            nIDStaticPath,
                                         DlgDirListType uFiletype);

LongFailIfZero [gle] DlgDirListComboBoxW(HWND           hDlg,
                                         [out] LPWSTR   lpPathSpec,
                                         int            nIDComboBox,
                                         int            nIDStaticPath,
                                         DlgDirListType uFiletype);

BOOL DlgDirSelectComboBoxExA(HWND        hDlg,
                             [out] LPSTR lpString,
                             int         nCount,
                             int         nIDComboBox);

BOOL DlgDirSelectComboBoxExW(HWND         hDlg,
                             [out] LPWSTR lpString,
                             int          nCount,
                             int          nIDComboBox);


value DWORD ChangeDisplaySettingsRet
{
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1 [fail]
#define DISP_CHANGE_FAILED          -1 [fail]
#define DISP_CHANGE_BADMODE         -2 [fail]
#define DISP_CHANGE_NOTUPDATED      -3 [fail]
#define DISP_CHANGE_BADFLAGS        -4 [fail]
#define DISP_CHANGE_BADPARAM        -5 [fail]
};


mask DWORD ChangeDisplaySettingsFlags
{
#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004
#define CDS_GLOBAL          0x00000008
#define CDS_SET_PRIMARY     0x00000010
#define CDS_VIDEOPARAMETERS 0x00000020
#define CDS_RESET           0x40000000
#define CDS_NORESET         0x10000000
};

ChangeDisplaySettingsRet ChangeDisplaySettingsA(LPDEVMODEA lpDevMode, ChangeDisplaySettingsFlags dwFlags);
ChangeDisplaySettingsRet ChangeDisplaySettingsW(LPDEVMODEW lpDevMode, ChangeDisplaySettingsFlags dwFlags);

ChangeDisplaySettingsRet ChangeDisplaySettingsExA(LPCSTR                     lpszDeviceName,
                                                  LPDEVMODEA                 lpDevMode,
                                                  HWND                       hwnd,
                                                  ChangeDisplaySettingsFlags dwflags,
                                                  LPVOID                     lParam);

ChangeDisplaySettingsRet ChangeDisplaySettingsExW(LPCWSTR                    lpszDeviceName,
                                                  LPDEVMODEW                 lpDevMode,
                                                  HWND                       hwnd,
                                                  ChangeDisplaySettingsFlags dwflags,
                                                  LPVOID                     lParam);

typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    char   DeviceName[32];
    char   DeviceString[128];
    DWORD  StateFlags;
    char   DeviceID[128];
    char   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;

typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;


LongFailIfZero EnumDisplayDevicesA(LPCSTR                 lpDevice,
                                   DWORD                  iDevNum,
                                   [out] PDISPLAY_DEVICEA lpDisplayDevice,
                                   DWORD                  dwFlags);

LongFailIfZero EnumDisplayDevicesW(LPCWSTR                lpDevice,
                                   DWORD                  iDevNum,
                                   [out] PDISPLAY_DEVICEW lpDisplayDevice,
                                   DWORD                  dwFlags);

typedef LPVOID MONITORENUMPROC;

FailOnFalse [gle] EnumDisplayMonitors(HDC             hdc,
                                      LPRECT          lprcClip,
                                      MONITORENUMPROC lpfnEnum,
                                      LPARAM          dwData);

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

FailOnFalse [gle] GetMonitorInfoA(HMONITOR hMonitor, [out] LPMONITORINFO lpmi);
FailOnFalse [gle] GetMonitorInfoW(HMONITOR hMonitor, [out] LPMONITORINFO lpmi);

mask DWORD MonitorFlags
{
#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002
};

HMONITOR MonitorFromPoint(int x, int y, MonitorFlags dwFlags);
HMONITOR MonitorFromRect(LPRECT lprc, MonitorFlags dwFlags);
HMONITOR MonitorFromWindow(HWND hwnd, MonitorFlags dwFlags);


value DWORD EnumDisplaySettingsIndex
{
#define ENUM_CURRENT_SETTINGS       -1
#define ENUM_REGISTRY_SETTINGS      -2
};

FailOnFalse [gle] EnumDisplaySettingsA(LPCSTR                   lpszDeviceName,
                                       EnumDisplaySettingsIndex iModeNum,
                                       [out] LPDEVMODEA         lpDevMode);

FailOnFalse [gle] EnumDisplaySettingsW(LPCWSTR                  lpszDeviceName,
                                       EnumDisplaySettingsIndex iModeNum,
                                       [out] LPDEVMODEW         lpDevMode);

FailOnFalse [gle] EnumDisplaySettingsExA(LPCSTR                   lpszDeviceName,
                                         EnumDisplaySettingsIndex iModeNum,
                                         [out] LPDEVMODEA         lpDevMode,
                                         DWORD                    dwFlags);

FailOnFalse [gle] EnumDisplaySettingsExW(LPCWSTR                  lpszDeviceName,
                                         EnumDisplaySettingsIndex iModeNum,
                                         [out] LPDEVMODEW         lpDevMode,
                                         DWORD                    dwFlags);



HWND [gle] SetFocus(HWND hWnd);
HWND GetFocus();

FailOnFalse [gle] DrawFocusRect(HDC hDC, LPRECT* lprc);

mask DWORD GetGUIThreadInfoFlags
{
#define GUI_CARETBLINKING   0x00000001
#define GUI_INMOVESIZE      0x00000002
#define GUI_INMENUMODE      0x00000004
#define GUI_SYSTEMMENUMODE  0x00000008
#define GUI_POPUPMENUMODE   0x00000010
};

typedef struct tagGUITHREADINFO
{
    DWORD                 cbSize;
    GetGUIThreadInfoFlags flags;
    HWND                  hwndActive;
    HWND                  hwndFocus;
    HWND                  hwndCapture;
    HWND                  hwndMenuOwner;
    HWND                  hwndMoveSize;
    HWND                  hwndCaret;
    RECT                  rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;

FailOnFalse [gle] GetGUIThreadInfo(ThreadId idThread, [out] PGUITHREADINFO pgui);

HWND SetCapture(HWND hWnd);
HWND GetCapture();

FailOnFalse [gle] ReleaseCapture();


HRSRC SetCursor(HRSRC hCursor);

value LPSTR CursorValueA
{
#define IDC_ARROW           32512
#define IDC_IBEAM           32513
#define IDC_WAIT            32514
#define IDC_CROSS           32515
#define IDC_UPARROW         32516
#define IDC_SIZE            32640
#define IDC_ICON            32641
#define IDC_SIZENWSE        32642
#define IDC_SIZENESW        32643
#define IDC_SIZEWE          32644
#define IDC_SIZENS          32645
#define IDC_SIZEALL         32646
#define IDC_NO              32648
#define IDC_HAND            32649
#define IDC_APPSTARTING     32650
#define IDC_HELP            32651
};

value LPWSTR CursorValueW
{
#define IDC_ARROW           32512
#define IDC_IBEAM           32513
#define IDC_WAIT            32514
#define IDC_CROSS           32515
#define IDC_UPARROW         32516
#define IDC_SIZE            32640
#define IDC_ICON            32641
#define IDC_SIZENWSE        32642
#define IDC_SIZENESW        32643
#define IDC_SIZEWE          32644
#define IDC_SIZENS          32645
#define IDC_SIZEALL         32646
#define IDC_NO              32648
#define IDC_HAND            32649
#define IDC_APPSTARTING     32650
#define IDC_HELP            32651
};

HRSRC [gle] LoadCursorA(HINSTANCE hInstance, CursorValueA lpCursorName);
HRSRC [gle] LoadCursorW(HINSTANCE hInstance, CursorValueW lpCursorName);

value LPSTR IconValueA
{
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#define IDI_WINLOGO         32517
};

value LPWSTR IconValueW
{
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#define IDI_WINLOGO         32517
};

HRSRC [gle] LoadIconA(HINSTANCE hInstance, IconValueA lpIconName);
HRSRC [gle] LoadIconW(HINSTANCE hInstance, IconValueW lpIconName);

mask DWORD ImageType
{
#define IMAGE_BITMAP        0
#define IMAGE_ICON          1
#define IMAGE_CURSOR        2
#define IMAGE_ENHMETAFILE   3
};

mask DWORD LoadImageFlags
{
#define LR_DEFAULTCOLOR     0x0000
#define LR_MONOCHROME       0x0001
#define LR_COLOR            0x0002
#define LR_COPYRETURNORG    0x0004
#define LR_COPYDELETEORG    0x0008
#define LR_LOADFROMFILE     0x0010
#define LR_LOADTRANSPARENT  0x0020
#define LR_DEFAULTSIZE      0x0040
#define LR_VGACOLOR         0x0080
#define LR_LOADMAP3DCOLORS  0x1000
#define LR_CREATEDIBSECTION 0x2000
#define LR_COPYFROMRESOURCE 0x4000
#define LR_SHARED           0x8000
};

value LPSTR ImageValueA
{
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647
#define OCR_NO              32648
#define OCR_HAND            32649
#define OCR_APPSTARTING     32650

#define OIC_WINLOGO         32517
};

value LPWSTR ImageValueW
{
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647
#define OCR_NO              32648
#define OCR_HAND            32649
#define OCR_APPSTARTING     32650

#define OIC_WINLOGO         32517
};

HRSRC [gle] LoadImageA(HINSTANCE      hInstance,
                       ImageValueA    lpszName,
                       ImageType      uType,
                       int            cxDesired,
                       int            cyDesired,
                       LoadImageFlags fuLoad);

HRSRC [gle] LoadImageW(HINSTANCE      hInstance,
                       ImageValueW    lpszName,
                       ImageType      uType,
                       int            cxDesired,
                       int            cyDesired,
                       LoadImageFlags fuLoad);

HRSRC [gle] CopyImage(HRSRC          hImage,
                      ImageType      uType,
                      int            x,
                      int            y,
                      LoadImageFlags fuFlags);

HRSRC [gle] CopyIcon(HRSRC hIcon);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HRSRC   hbmMask;
    HRSRC   hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

FailOnFalse [gle] GetIconInfo(HRSRC hIcon, [out] PICONINFO piconinfo);

HRSRC [gle] CreateIcon(HINSTANCE  hInstance,
                       int        nWidth,
                       int        nHeight,
                       BYTE       cPlanes,
                       BYTE       cBitsPixel,
                       BYTE*      lpbANDbits,
                       BYTE*      lpbXORbits);

FailOnFalse [gle] OpenIcon(HWND hWnd);

HRSRC [gle] CreateIconFromResource(PBYTE presbits,
                                   DWORD dwResSize,
                                   BOOL  fIcon,
                                   DWORD dwVer);

HRSRC [gle] CreateIconFromResourceEx(PBYTE          presbits,
                                     DWORD          dwResSize,
                                     BOOL           fIcon,
                                     DWORD          dwVer,
                                     int            cxDesired,
                                     int            cyDesired,
                                     LoadImageFlags Flags);

HRSRC [gle]  CreateIconIndirect(PICONINFO piconinfo);

DwordFailIfZero [gle] LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon);

DwordFailIfZero [gle] LookupIconIdFromDirectoryEx(PBYTE          presbits,
                                                  BOOL           fIcon,
                                                  int            cxDesired,
                                                  int            cyDesired,
                                                  LoadImageFlags Flags);

FailOnFalse [gle] DestroyCursor( [da] HRSRC hCursor);
FailOnFalse [gle] DestroyIcon( [da] HRSRC hIcon);

value DWORD SystemMetric
{
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43

#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#define SM_SHOWSOUNDS           70
#define SM_CXMENUCHECK          71
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74

#define SM_MOUSEWHEELPRESENT    75
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#define SM_IMMENABLED           82
#define SM_CXFOCUSBORDER        83
#define SM_CYFOCUSBORDER        84

#define SM_REMOTESESSION        0x1000
};

LongFailIfZero GetSystemMetrics(SystemMetric nIndex);

HACCEL [gle] LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
HACCEL [gle] LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName);

FailOnFalse [gle] DestroyAcceleratorTable( [da] HACCEL hAccel);

int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);

mask DWORD ClassStyles
{
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_DBLCLKS          0x0008
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000
#define CS_IME              0x00010000
#define CS_DROPSHADOW       0x00020000
};

typedef struct tagWNDCLASSA {
    ClassStyles style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HRSRC       hIcon;
    HRSRC       hCursor;
    HRSRC       hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA, *LPWNDCLASSA;

typedef struct tagWNDCLASSW {
    ClassStyles style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HRSRC       hIcon;
    HRSRC       hCursor;
    HRSRC       hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *LPWNDCLASSW;


DwordFailIfZero [gle] RegisterClassA(WNDCLASSA* lpWndClass);
DwordFailIfZero [gle] RegisterClassW(WNDCLASSW* lpWndClass);

FailOnFalse [gle] UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance);
FailOnFalse [gle] UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance);

typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    ClassStyles style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HRSRC       hIcon;
    HRSRC       hCursor;
    HRSRC       hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    HRSRC       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, *LPWNDCLASSEXA;

typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    ClassStyles style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HRSRC       hIcon;
    HRSRC       hCursor;
    HRSRC       hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    HRSRC       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, *LPWNDCLASSEXW;

DwordFailIfZero [gle] RegisterClassExA(WNDCLASSEXA* lpWndClass);
DwordFailIfZero [gle] RegisterClassExW(WNDCLASSEXW* lpWndClass);

typedef struct tagDLGTEMPLATE {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD  cdit;
    DWORD x_y;
    DWORD cx_cy;
} DLGTEMPLATE;

typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;

HWND [gle] CreateDialogIndirectParamA(HINSTANCE      hInstance,
                                      LPDLGTEMPLATEA lpTemplate,
                                      HWND           hWndParent,
                                      WNDPROC        lpDialogFunc,
                                      LPARAM         dwInitParam);

HWND [gle] CreateDialogIndirectParamW(HINSTANCE      hInstance,
                                      LPDLGTEMPLATEA lpTemplate,
                                      HWND           hWndParent,
                                      WNDPROC        lpDialogFunc,
                                      LPARAM         dwInitParam);

HWND [gle] CreateDialogParamA(HINSTANCE hInstance,
                              LPCSTR    lpTemplateName,
                              HWND      hWndParent,
                              WNDPROC   lpDialogFunc,
                              LPARAM    dwInitParam);

HWND [gle] CreateDialogParamW(HINSTANCE hInstance,
                              LPCWSTR   lpTemplateName,
                              HWND      hWndParent,
                              WNDPROC   lpDialogFunc,
                              LPARAM    dwInitParam);

LongFailIfNeg1 [gle] DialogBoxIndirectParamA(HINSTANCE      hInstance,
                                             LPDLGTEMPLATEA hDialogTemplate,
                                             HWND           hWndParent,
                                             WNDPROC        lpDialogFunc,
                                             LPARAM         dwInitParam);

LongFailIfNeg1 [gle] DialogBoxIndirectParamW(HINSTANCE      hInstance,
                                             LPDLGTEMPLATEW hDialogTemplate,
                                             HWND           hWndParent,
                                             WNDPROC        lpDialogFunc,
                                             LPARAM         dwInitParam);

LongFailIfNeg1 [gle] DialogBoxParamA(HINSTANCE hInstance,
                                     LPCSTR    lpTemplateName,
                                     HWND      hWndParent,
                                     WNDPROC   lpDialogFunc,
                                     LPARAM    dwInitParam);

LongFailIfNeg1 [gle] DialogBoxParamW(HINSTANCE hInstance,
                                     LPCWSTR   lpTemplateName,
                                     HWND      hWndParent,
                                     WNDPROC   lpDialogFunc,
                                     LPARAM    dwInitParam);

FailOnFalse [gle] EndDialog(HWND hDlg, int nResult);

DWORD GetDialogBaseUnits();

FailOnFalse [gle] MapDialogRect(HWND hDlg, [out] LPRECT lpRect);


HWND [gle] CreateMDIWindowA(LPCSTR      lpClassName,
                            LPCSTR      lpWindowName,
                            WindowStyle dwStyle,
                            int         X,
                            int         Y,
                            int         nWidth,
                            int         nHeight,
                            HWND        hWndParent,
                            HINSTANCE   hInstance,
                            LPARAM      lParam);

HWND [gle] CreateMDIWindowW(LPCWSTR     lpClassName,
                            LPCWSTR     lpWindowName,
                            WindowStyle dwStyle,
                            int         X,
                            int         Y,
                            int         nWidth,
                            int         nHeight,
                            HWND        hWndParent,
                            HINSTANCE   hInstance,
                            LPARAM      lParam);

LRESULT DefMDIChildProcA(HWND           hWnd,
                         WindowsMessage uMsg,
                         WPARAM         wParam,
                         LPARAM         lParam);

LRESULT DefMDIChildProcW(HWND           hWnd,
                         WindowsMessage uMsg,
                         WPARAM         wParam,
                         LPARAM         lParam);

BOOL TranslateMDISysAccel(HWND  hWndClient,
                          LPMSG lpMsg);

value DWORD MessageBoxReturn
{
#define ERROR               0 [fail]
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7
#define IDCLOSE             8
#define IDHELP              9
#define IDTRYAGAIN          10
#define IDCONTINUE          11
};

mask DWORD MessageBoxType
{
#define MB_OK                       0x00000000
#define MB_OKCANCEL                 0x00000001
#define MB_ABORTRETRYIGNORE         0x00000002
#define MB_YESNOCANCEL              0x00000003
#define MB_YESNO                    0x00000004
#define MB_RETRYCANCEL              0x00000005
#define MB_CANCELTRYCONTINUE        0x00000006

#define MB_ICONHAND                 0x00000010
#define MB_ICONQUESTION             0x00000020
#define MB_ICONEXCLAMATION          0x00000030
#define MB_ICONASTERISK             0x00000040
#define MB_USERICON                 0x00000080

#define MB_DEFBUTTON1               0x00000000
#define MB_DEFBUTTON2               0x00000100
#define MB_DEFBUTTON3               0x00000200

#define MB_SYSTEMMODAL              0x00001000
#define MB_TASKMODAL                0x00002000
#define MB_HELP                     0x00004000

#define MB_NOFOCUS                  0x00008000
#define MB_SETFOREGROUND            0x00010000
#define MB_DEFAULT_DESKTOP_ONLY     0x00020000

#define MB_TOPMOST                  0x00040000
#define MB_RIGHT                    0x00080000
#define MB_RTLREADING               0x00100000
#define MB_SERVICE_NOTIFICATION     0x00200000
};

MessageBoxReturn [gle] MessageBoxA(HWND           hWnd,
                                   LPCSTR         lpText,
                                   LPCSTR         lpCaption,
                                   MessageBoxType uType);

MessageBoxReturn [gle] MessageBoxW(HWND           hWnd,
                                   LPCWSTR        lpText,
                                   LPCWSTR        lpCaption,
                                   MessageBoxType uType);

value DWORD LanguageId
{
#define LANG_NEUTRAL                     0x00
#define LANG_INVARIANT                   0x7f

#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_ARABIC                      0x01
#define LANG_ARMENIAN                    0x2b
#define LANG_ASSAMESE                    0x4d
#define LANG_AZERI                       0x2c
#define LANG_BASQUE                      0x2d
#define LANG_BELARUSIAN                  0x23
#define LANG_BENGALI                     0x45
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GEORGIAN                    0x37
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_GUJARATI                    0x47
#define LANG_HEBREW                      0x0d
#define LANG_HINDI                       0x39
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_INDONESIAN                  0x21
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KANNADA                     0x4b
#define LANG_KASHMIRI                    0x60
#define LANG_KAZAK                       0x3f
#define LANG_KONKANI                     0x57
#define LANG_KOREAN                      0x12
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_MACEDONIAN                  0x2f
#define LANG_MALAY                       0x3e
#define LANG_MALAYALAM                   0x4c
#define LANG_MANIPURI                    0x58
#define LANG_MARATHI                     0x4e
#define LANG_NEPALI                      0x61
#define LANG_NORWEGIAN                   0x14
#define LANG_ORIYA                       0x48
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_PUNJABI                     0x46
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SANSKRIT                    0x4f
#define LANG_SERBIAN                     0x1a
#define LANG_SINDHI                      0x59
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWAHILI                     0x41
#define LANG_SWEDISH                     0x1d
#define LANG_TAMIL                       0x49
#define LANG_TATAR                       0x44
#define LANG_TELUGU                      0x4a
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_UKRAINIAN                   0x22
#define LANG_URDU                        0x20
#define LANG_UZBEK                       0x43
#define LANG_VIETNAMESE                  0x2a
};

MessageBoxReturn [gle] MessageBoxExA(HWND           hWnd,
                                     LPCSTR         lpText,
                                     LPCSTR         lpCaption,
                                     MessageBoxType uType,
                                     LanguageId     dwLanguageId);

MessageBoxReturn [gle] MessageBoxExW(HWND           hWnd,
                                     LPCWSTR        lpText,
                                     LPCWSTR        lpCaption,
                                     MessageBoxType uType,
                                     LanguageId     dwLanguageId);

typedef struct tagMSGBOXPARAMSA
{
    UINT            cbSize;
    HWND            hwndOwner;
    HINSTANCE       hInstance;
    LPCSTR          lpszText;
    LPCSTR          lpszCaption;
    MessageBoxType  dwStyle;
    LPCSTR          lpszIcon;
    DWORD           dwContextHelpId;
    WNDPROC         lpfnMsgBoxCallback;
    LanguageId      dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;

typedef struct tagMSGBOXPARAMSW
{
    UINT            cbSize;
    HWND            hwndOwner;
    HINSTANCE       hInstance;
    LPCWSTR         lpszText;
    LPCWSTR         lpszCaption;
    MessageBoxType  dwStyle;
    LPCWSTR         lpszIcon;
    DWORD           dwContextHelpId;
    WNDPROC         lpfnMsgBoxCallback;
    LanguageId      dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;


MessageBoxReturn MessageBoxIndirectA(MSGBOXPARAMSA* lpMsgBoxParam);
MessageBoxReturn MessageBoxIndirectW(MSGBOXPARAMSW* lpMsgBoxParam);

BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg);
BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg);

BOOL IsChild(HWND hWndParent, HWND hWnd);

BOOL IsIconic(HWND hWnd);

BOOL IsMenu(HMENU hMenu);

BOOL IsRectEmpty(LPRECT lprc);

BOOL IntersectRect([out] LPRECT lprcDst, LPRECT lprcSrc1, LPRECT lprcSrc2);

BOOL UnionRect([out] LPRECT lprcDst, LPRECT lprcSrc1, LPRECT lprcSrc2);

FailOnFalse [gle] CopyRect([out] LPRECT lprcDst, LPRECT lprcSrc);

BOOL SubtractRect([out] LPRECT lprcDst, LPRECT lprcSrc1, LPRECT lprcSrc2);


FailOnFalse [gle] InvertRect(HDC hDC, LPRECT lprc);


BOOL PtInRect(LPRECT lprc, int x, int y);

FailOnFalse IsWindow(HWND hWnd);

BOOL IsWindowEnabled(HWND hWnd);

BOOL IsWindowUnicode(HWND hWnd);

BOOL IsWindowVisible(HWND hWnd);

BOOL IsZoomed(HWND hWnd);

DwordFailIfZero [gle] RegisterWindowMessageA(LPCSTR lpString);
DwordFailIfZero [gle] RegisterWindowMessageW(LPCWSTR lpString);

FailOnFalse [gle] SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData);
FailOnFalse [gle] SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);

HANDLE GetPropA(HWND hWnd, LPCSTR lpString);
HANDLE GetPropW(HWND hWnd, LPCWSTR lpString);

HANDLE RemovePropA(HWND hWnd, LPCSTR lpString);
HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString);

typedef LPVOID PROPENUMPROCA;
typedef LPVOID PROPENUMPROCW;
typedef LPVOID PROPENUMPROCEXA;
typedef LPVOID PROPENUMPROCEXW;

LongFailIfNeg1 EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc);
LongFailIfNeg1 EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc);

LongFailIfNeg1 EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam);
LongFailIfNeg1 EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam);

mask DWORD QueueStates
{
#define QS_KEY              0x0001
#define QS_MOUSEMOVE        0x0002
#define QS_MOUSEBUTTON      0x0004
#define QS_POSTMESSAGE      0x0008
#define QS_TIMER            0x0010
#define QS_PAINT            0x0020
#define QS_SENDMESSAGE      0x0040
#define QS_HOTKEY           0x0080
#define QS_ALLPOSTMESSAGE   0x0100
#define QS_RAWINPUT         0x0400
};

WaitReturnValues [gle] MsgWaitForMultipleObjects(DWORD       nCount,
                                                 HANDLE*     pHandles,
                                                 BOOL        fWaitAll,
                                                 DWORD       dwMilliseconds,
                                                 QueueStates dwWakeMask);

mask DWORD MWMOFlags
{
#define MWMO_WAITALL        0x0001
#define MWMO_ALERTABLE      0x0002
#define MWMO_INPUTAVAILABLE 0x0004
};

WaitReturnValues [gle] MsgWaitForMultipleObjectsEx(DWORD       nCount,
                                                   HANDLE*     pHandles,
                                                   DWORD       dwMilliseconds,
                                                   QueueStates dwWakeMask,
                                                   MWMOFlags   dwFlags);

WaitReturnValues [gle] WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds);

value DWORD GetWindowCmd
{
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5
#define GW_ENABLEDPOPUP     6
};

HWND [gle] GetWindow(HWND hWnd, GetWindowCmd uCmd);

DWORD GetWindowContextHelpId(HWND hwnd);

FailOnFalse [gle] SetWindowContextHelpId(HWND hwnd, DWORD dwHelpId);

typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT  rcWindow;
    RECT  rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT  cxWindowBorders;
    UINT  cyWindowBorders;
    ATOM  atomWindowType;
    WORD  wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;


FailOnFalse [gle] GetWindowInfo(HWND hwnd, [out] PWINDOWINFO pwi);

UINT GetWindowModuleFileNameA(HWND hwnd, [out] LPSTR pszFileName, UINT cchFileNameMax);
UINT GetWindowModuleFileNameW(HWND hwnd, [out] LPWSTR pszFileName, UINT cchFileNameMax);


FailOnFalse [gle] GetWindowRect(HWND hWnd, [out] LPRECT lpRect);
FailOnFalse [gle] GetClientRect(HWND hwnd, [out] LPRECT lprect);

FailOnFalse [gle] SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw);

HRGN GetWindowRgn(HWND hWnd, HRGN hRgn);

ThreadId GetWindowThreadProcessId(HWND hWnd, [out] ProcessId* lpdwProcessId);

FailOnFalse [gle] EnableWindow(HWND hWnd, BOOL bEnable);

value DWORD SPIValues
{
#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_GETKEYBOARDSPEED       10
#define SPI_SETKEYBOARDSPEED       11
#define SPI_LANGDRIVER             12
#define SPI_ICONHORIZONTALSPACING  13
#define SPI_GETSCREENSAVETIMEOUT   14
#define SPI_SETSCREENSAVETIMEOUT   15
#define SPI_GETSCREENSAVEACTIVE    16
#define SPI_SETSCREENSAVEACTIVE    17
#define SPI_GETGRIDGRANULARITY     18
#define SPI_SETGRIDGRANULARITY     19
#define SPI_SETDESKWALLPAPER       20
#define SPI_SETDESKPATTERN         21
#define SPI_GETKEYBOARDDELAY       22
#define SPI_SETKEYBOARDDELAY       23
#define SPI_ICONVERTICALSPACING    24
#define SPI_GETICONTITLEWRAP       25
#define SPI_SETICONTITLEWRAP       26
#define SPI_GETMENUDROPALIGNMENT   27
#define SPI_SETMENUDROPALIGNMENT   28
#define SPI_SETDOUBLECLKWIDTH      29
#define SPI_SETDOUBLECLKHEIGHT     30
#define SPI_GETICONTITLELOGFONT    31
#define SPI_SETDOUBLECLICKTIME     32
#define SPI_SETMOUSEBUTTONSWAP     33
#define SPI_SETICONTITLELOGFONT    34
#define SPI_GETFASTTASKSWITCH      35
#define SPI_SETFASTTASKSWITCH      36
#define SPI_SETDRAGFULLWINDOWS     37
#define SPI_GETDRAGFULLWINDOWS     38
#define SPI_GETNONCLIENTMETRICS    41
#define SPI_SETNONCLIENTMETRICS    42
#define SPI_GETMINIMIZEDMETRICS    43
#define SPI_SETMINIMIZEDMETRICS    44
#define SPI_GETICONMETRICS         45
#define SPI_SETICONMETRICS         46
#define SPI_SETWORKAREA            47
#define SPI_GETWORKAREA            48
#define SPI_SETPENWINDOWS          49

#define SPI_GETFILTERKEYS          50
#define SPI_SETFILTERKEYS          51
#define SPI_GETTOGGLEKEYS          52
#define SPI_SETTOGGLEKEYS          53
#define SPI_GETMOUSEKEYS           54
#define SPI_SETMOUSEKEYS           55
#define SPI_GETSHOWSOUNDS          56
#define SPI_SETSHOWSOUNDS          57
#define SPI_GETSTICKYKEYS          58
#define SPI_SETSTICKYKEYS          59
#define SPI_GETACCESSTIMEOUT       60
#define SPI_SETACCESSTIMEOUT       61
#define SPI_GETSERIALKEYS          62
#define SPI_SETSERIALKEYS          63
#define SPI_GETSOUNDSENTRY         64
#define SPI_SETSOUNDSENTRY         65

#define SPI_GETHIGHCONTRAST        66
#define SPI_SETHIGHCONTRAST        67
#define SPI_GETKEYBOARDPREF        68
#define SPI_SETKEYBOARDPREF        69
#define SPI_GETSCREENREADER        70
#define SPI_SETSCREENREADER        71
#define SPI_GETANIMATION           72
#define SPI_SETANIMATION           73
#define SPI_GETFONTSMOOTHING       74
#define SPI_SETFONTSMOOTHING       75
#define SPI_SETDRAGWIDTH           76
#define SPI_SETDRAGHEIGHT          77
#define SPI_SETHANDHELD            78
#define SPI_GETLOWPOWERTIMEOUT     79
#define SPI_GETPOWEROFFTIMEOUT     80
#define SPI_SETLOWPOWERTIMEOUT     81
#define SPI_SETPOWEROFFTIMEOUT     82
#define SPI_GETLOWPOWERACTIVE      83
#define SPI_GETPOWEROFFACTIVE      84
#define SPI_SETLOWPOWERACTIVE      85
#define SPI_SETPOWEROFFACTIVE      86
#define SPI_SETCURSORS             87
#define SPI_SETICONS               88
#define SPI_GETDEFAULTINPUTLANG    89
#define SPI_SETDEFAULTINPUTLANG    90
#define SPI_SETLANGTOGGLE          91
#define SPI_GETWINDOWSEXTENSION    92
#define SPI_SETMOUSETRAILS         93
#define SPI_GETMOUSETRAILS         94

#define SPI_GETSNAPTODEFBUTTON     95
#define SPI_SETSNAPTODEFBUTTON     96

#define SPI_SETSCREENSAVERRUNNING  97

#define SPI_GETMOUSEHOVERWIDTH     98
#define SPI_SETMOUSEHOVERWIDTH     99
#define SPI_GETMOUSEHOVERHEIGHT   100
#define SPI_SETMOUSEHOVERHEIGHT   101
#define SPI_GETMOUSEHOVERTIME     102
#define SPI_SETMOUSEHOVERTIME     103
#define SPI_GETWHEELSCROLLLINES   104
#define SPI_SETWHEELSCROLLLINES   105
#define SPI_GETMENUSHOWDELAY      106
#define SPI_SETMENUSHOWDELAY      107

#define SPI_GETSHOWIMEUI          110
#define SPI_SETSHOWIMEUI          111


#define SPI_GETMOUSESPEED         112
#define SPI_SETMOUSESPEED         113
#define SPI_GETSCREENSAVERRUNNING 114
#define SPI_GETDESKWALLPAPER      115

#define SPI_GETACTIVEWINDOWTRACKING         0x1000
#define SPI_SETACTIVEWINDOWTRACKING         0x1001
#define SPI_GETMENUANIMATION                0x1002
#define SPI_SETMENUANIMATION                0x1003
#define SPI_GETCOMBOBOXANIMATION            0x1004
#define SPI_SETCOMBOBOXANIMATION            0x1005
#define SPI_GETLISTBOXSMOOTHSCROLLING       0x1006
#define SPI_SETLISTBOXSMOOTHSCROLLING       0x1007
#define SPI_GETGRADIENTCAPTIONS             0x1008
#define SPI_SETGRADIENTCAPTIONS             0x1009
#define SPI_GETKEYBOARDCUES                 0x100A
#define SPI_SETKEYBOARDCUES                 0x100B
#define SPI_GETACTIVEWNDTRKZORDER           0x100C
#define SPI_SETACTIVEWNDTRKZORDER           0x100D
#define SPI_GETHOTTRACKING                  0x100E
#define SPI_SETHOTTRACKING                  0x100F
#define SPI_GETMENUFADE                     0x1012
#define SPI_SETMENUFADE                     0x1013
#define SPI_GETSELECTIONFADE                0x1014
#define SPI_SETSELECTIONFADE                0x1015
#define SPI_GETTOOLTIPANIMATION             0x1016
#define SPI_SETTOOLTIPANIMATION             0x1017
#define SPI_GETTOOLTIPFADE                  0x1018
#define SPI_SETTOOLTIPFADE                  0x1019
#define SPI_GETCURSORSHADOW                 0x101A
#define SPI_SETCURSORSHADOW                 0x101B
#define SPI_GETMOUSESONAR                   0x101C
#define SPI_SETMOUSESONAR                   0x101D
#define SPI_GETMOUSECLICKLOCK               0x101E
#define SPI_SETMOUSECLICKLOCK               0x101F
#define SPI_GETMOUSEVANISH                  0x1020
#define SPI_SETMOUSEVANISH                  0x1021
#define SPI_GETFLATMENU                     0x1022
#define SPI_SETFLATMENU                     0x1023
#define SPI_GETDROPSHADOW                   0x1024
#define SPI_SETDROPSHADOW                   0x1025

#define SPI_GETUIEFFECTS                    0x103E
#define SPI_SETUIEFFECTS                    0x103F

#define SPI_GETFOREGROUNDLOCKTIMEOUT        0x2000
#define SPI_SETFOREGROUNDLOCKTIMEOUT        0x2001
#define SPI_GETACTIVEWNDTRKTIMEOUT          0x2002
#define SPI_SETACTIVEWNDTRKTIMEOUT          0x2003
#define SPI_GETFOREGROUNDFLASHCOUNT         0x2004
#define SPI_SETFOREGROUNDFLASHCOUNT         0x2005
#define SPI_GETCARETWIDTH                   0x2006
#define SPI_SETCARETWIDTH                   0x2007

#define SPI_GETMOUSECLICKLOCKTIME           0x2008
#define SPI_SETMOUSECLICKLOCKTIME           0x2009
#define SPI_GETFONTSMOOTHINGTYPE            0x200A
#define SPI_SETFONTSMOOTHINGTYPE            0x200B

#define SPI_GETFONTSMOOTHINGGAMMA           0x200C
#define SPI_SETFONTSMOOTHINGGAMMA           0x200D

#define SPI_GETFOCUSBORDERWIDTH             0x200E
#define SPI_SETFOCUSBORDERWIDTH             0x200F
#define SPI_GETFOCUSBORDERHEIGHT            0x2010
#define SPI_SETFOCUSBORDERHEIGHT            0x2011
};

mask DWORD SPIWinini
{
#define SPIF_UPDATEINIFILE    0x0001
#define SPIF_SENDWININICHANGE 0x0002
};

FailOnFalse [gle] SystemParametersInfoA(SPIValues uiAction,
                                        UINT      uiParam,
                            /* [out] */ LPVOID    pvParam,
                                        SPIWinini fWinIni);

FailOnFalse [gle] SystemParametersInfoW(SPIValues uiAction,
                                        UINT      uiParam,
                            /* [out] */ LPVOID    pvParam,
                                        SPIWinini fWinIni);

value DWORD ColorIndex
{
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            7

#define COLOR_SCROLLBAR         0
#define COLOR_BACKGROUND        1
#define COLOR_ACTIVECAPTION     2
#define COLOR_INACTIVECAPTION   3
#define COLOR_MENU              4
#define COLOR_WINDOW            5
#define COLOR_WINDOWFRAME       6
#define COLOR_MENUTEXT          7
#define COLOR_WINDOWTEXT        8
#define COLOR_CAPTIONTEXT       9
#define COLOR_ACTIVEBORDER      10
#define COLOR_INACTIVEBORDER    11
#define COLOR_APPWORKSPACE      12
#define COLOR_HIGHLIGHT         13
#define COLOR_HIGHLIGHTTEXT     14
#define COLOR_BTNFACE           15
#define COLOR_BTNSHADOW         16
#define COLOR_GRAYTEXT          17
#define COLOR_BTNTEXT           18
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT      20

#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24

#define COLOR_HOTLIGHT          26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT       29
#define COLOR_MENUBAR           30
};

DWORD GetSysColor(ColorIndex nIndex);

FailOnFalse [gle] SetSysColors(int         cElements,
                               ColorIndex* lpaElements,
                               DWORD*      lpaRgbValues);

HRSRC GetSysColorBrush(ColorIndex nIndex);

HWND [gle] SetParent(HWND hWndChild, HWND hWndNewParent);
HWND [gle] GetParent(HWND hWnd);

value DWORD GetAncestorType
{
#define     GA_PARENT       1
#define     GA_ROOT         2
#define     GA_ROOTOWNER    3
};

HWND GetAncestor(HWND hwnd, GetAncestorType gaFlags);

HWND [gle] GetTopWindow(HWND hWnd);

FailOnFalse [gle] ClipCursor(LPRECT lpRect);
FailOnFalse [gle] GetClipCursor([out] LPRECT lpRect);

HRSRC [gle] CreateCursor(HINSTANCE hInst,
                         int xHotSpot,
                         int yHotSpot,
                         int nWidth,
                         int nHeight,
                         LPVOID pvANDPlane,
                         LPVOID pvXORPlane);

HRSRC [gle] LoadCursorFromFileA(LPCSTR lpFileName);
HRSRC [gle] LoadCursorFromFileW(LPCWSTR lpFileName);

HRSRC GetCursor();

value DWORD CursorInfoFlags
{
#define CURSOR_HIDDEN      0x00000000
#define CURSOR_SHOWING     0x00000001
};

typedef struct tagCURSORINFO
{
    DWORD           cbSize;
    CursorInfoFlags flags;
    HRSRC           hCursor;
    POINT           ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

FailOnFalse [gle] GetCursorInfo([out] PCURSORINFO pci);

FailOnFalse [gle] SetCursorPos(int X, int Y);
FailOnFalse [gle] GetCursorPos( [out] LPPOINT lpPoint);

FailOnFalse [gle] SetSystemCursor(HRSRC hcur, ImageValueA id);

int ShowCursor(BOOL bShow);


FailOnFalse [gle] GetClassInfoA(HINSTANCE         hInstance,
                                LPCSTR            lpClassName,
                                [out] LPWNDCLASSA lpWndClass);

FailOnFalse [gle] GetClassInfoW(HINSTANCE         hInstance,
                                LPCWSTR           lpClassName,
                                [out] LPWNDCLASSW lpWndClass);

FailOnFalse [gle] GetClassInfoExA(HINSTANCE           hInstance,
                                  LPCSTR              lpClassName,
                                  [out] LPWNDCLASSEXA lpWndClassEx);

FailOnFalse [gle] GetClassInfoExW(HINSTANCE           hInstance,
                                  LPCWSTR             lpClassName,
                                  [out] LPWNDCLASSEXW lpWndClassEx);

value DWORD ClassLongIndex
{
#define GWLP_WNDPROC        -4
#define GWLP_HINSTANCE      -6
#define GWLP_HWNDPARENT     -8
#define GWLP_USERDATA       -21
#define GWLP_ID             -12

#define GCL_MENUNAME        -8
#define GCL_HBRBACKGROUND   -10
#define GCL_HCURSOR         -12
#define GCL_HICON           -14
#define GCL_HMODULE         -16
#define GCL_CBWNDEXTRA      -18
#define GCL_CBCLSEXTRA      -20
#define GCL_WNDPROC         -24
#define GCL_STYLE           -26
#define GCW_ATOM            -32
};

DwordFailIfZero [gle] GetClassLongA(HWND hWnd, ClassLongIndex nIndex);
DwordFailIfZero [gle] GetClassLongW(HWND hWnd, ClassLongIndex nIndex);

DwordFailIfZero [gle] SetClassLongA(HWND hWnd, ClassLongIndex nIndex, DWORD dwNewLong);
DwordFailIfZero [gle] SetClassLongW(HWND hWnd, ClassLongIndex nIndex, DWORD dwNewLong);

LongFailIfZero [gle] GetClassNameA(HWND hWnd, [out] LPSTR lpClassName, int nMaxCount);
LongFailIfZero [gle] GetClassNameW(HWND hWnd, [out] LPWSTR lpClassName, int nMaxCount);

HWND GetLastActivePopup(HWND hWnd);

FailOnFalse [gle] ShowOwnedPopups(HWND hWnd, BOOL fShow);

mask DWORD ExitWindowsExFlags
{
#define EWX_LOGOFF          0x00000000
#define EWX_SHUTDOWN        0x00000001
#define EWX_REBOOT          0x00000002
#define EWX_FORCE           0x00000004
#define EWX_POWEROFF        0x00000008
#define EWX_FORCEIFHUNG     0x00000010
};

FailOnFalse [gle] ExitWindowsEx(ExitWindowsExFlags uFlags, DWORD dwReserved);

LongFailIfZero [gle] FillRect(HDC hDC, LPRECT lprc, HRSRC hbr);

HWND [gle] FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
HWND [gle] FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);

HWND [gle] FindWindowExA(HWND hwndParent, HWND hwndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow);
HWND [gle] FindWindowExW(HWND hwndParent, HWND hwndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);

BOOL FlashWindow(HWND hWnd, BOOL bInvert);

mask DWORD FlashWindowExFlags
{
#define FLASHW_STOP         0
#define FLASHW_CAPTION      0x00000001
#define FLASHW_TRAY         0x00000002
#define FLASHW_TIMER        0x00000004
#define FLASHW_TIMERNOFG    0x00000008
};

typedef struct _FLASHWINFO {
    UINT  cbSize;
    HWND  hwnd;
    FlashWindowExFlags dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

BOOL FlashWindowEx(PFLASHWINFO pfwi);

LongFailIfZero [gle] FrameRect(HDC hDC, LPRECT lprc, HRSRC hbr);

FailOnFalse [gle] SetRect([out] LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);

FailOnFalse [gle] SetRectEmpty([out] LPRECT lprc);

FailOnFalse [gle] EqualRect(LPRECT lprc1, LPRECT lprc2);

FailOnFalse [gle] OffsetRect([out] LPRECT lprc, int dx, int dy);

FailOnFalse [gle] InflateRect([out] LPRECT lprc, int dx, int dy);

value DWORD VirtualKey
{
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04

#define VK_XBUTTON1       0x05
#define VK_XBUTTON2       0x06

#define VK_BACK           0x08
#define VK_TAB            0x09

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14

#define VK_KANA           0x15
#define VK_JUNJA          0x17
#define VK_FINAL          0x18
#define VK_KANJI          0x19

#define VK_ESCAPE         0x1B

#define VK_CONVERT        0x1C
#define VK_NONCONVERT     0x1D
#define VK_ACCEPT         0x1E
#define VK_MODECHANGE     0x1F

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

#define VK_0              0x30
#define VK_1              0x31
#define VK_2              0x32
#define VK_3              0x33
#define VK_4              0x34
#define VK_5              0x35
#define VK_6              0x36
#define VK_7              0x37
#define VK_8              0x38
#define VK_9              0x39

#define VK_A              0x41
#define VK_B              0x42
#define VK_C              0x43
#define VK_D              0x44
#define VK_E              0x45
#define VK_F              0x46
#define VK_G              0x47
#define VK_H              0x48
#define VK_I              0x49
#define VK_J              0x4A
#define VK_K              0x4B
#define VK_L              0x4C
#define VK_M              0x4D
#define VK_N              0x4E
#define VK_O              0x4F
#define VK_P              0x50
#define VK_Q              0x51
#define VK_R              0x52
#define VK_S              0x53
#define VK_T              0x54
#define VK_U              0x55
#define VK_V              0x56
#define VK_W              0x57
#define VK_X              0x58
#define VK_Y              0x59
#define VK_Z              0x5A

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

#define VK_SLEEP          0x5F

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

#define VK_OEM_FJ_JISHO   0x92
#define VK_OEM_FJ_MASSHOU 0x93
#define VK_OEM_FJ_TOUROKU 0x94
#define VK_OEM_FJ_LOYA    0x95
#define VK_OEM_FJ_ROYA    0x96

#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#define VK_BROWSER_BACK        0xA6
#define VK_BROWSER_FORWARD     0xA7
#define VK_BROWSER_REFRESH     0xA8
#define VK_BROWSER_STOP        0xA9
#define VK_BROWSER_SEARCH      0xAA
#define VK_BROWSER_FAVORITES   0xAB
#define VK_BROWSER_HOME        0xAC

#define VK_VOLUME_MUTE         0xAD
#define VK_VOLUME_DOWN         0xAE
#define VK_VOLUME_UP           0xAF
#define VK_MEDIA_NEXT_TRACK    0xB0
#define VK_MEDIA_PREV_TRACK    0xB1
#define VK_MEDIA_STOP          0xB2
#define VK_MEDIA_PLAY_PAUSE    0xB3
#define VK_LAUNCH_MAIL         0xB4
#define VK_LAUNCH_MEDIA_SELECT 0xB5
#define VK_LAUNCH_APP1         0xB6
#define VK_LAUNCH_APP2         0xB7

#define VK_OEM_1          0xBA
#define VK_OEM_PLUS       0xBB
#define VK_OEM_COMMA      0xBC
#define VK_OEM_MINUS      0xBD
#define VK_OEM_PERIOD     0xBE
#define VK_OEM_2          0xBF
#define VK_OEM_3          0xC0

#define VK_OEM_4          0xDB
#define VK_OEM_5          0xDC
#define VK_OEM_6          0xDD
#define VK_OEM_7          0xDE
#define VK_OEM_8          0xDF

#define VK_OEM_AX         0xE1
#define VK_OEM_102        0xE2
#define VK_ICO_HELP       0xE3
#define VK_ICO_00         0xE4

#define VK_PROCESSKEY     0xE5

#define VK_ICO_CLEAR      0xE6

#define VK_PACKET         0xE7

#define VK_OEM_RESET      0xE9
#define VK_OEM_JUMP       0xEA
#define VK_OEM_PA1        0xEB
#define VK_OEM_PA2        0xEC
#define VK_OEM_PA3        0xED
#define VK_OEM_WSCTRL     0xEE
#define VK_OEM_CUSEL      0xEF
#define VK_OEM_ATTN       0xF0
#define VK_OEM_FINISH     0xF1
#define VK_OEM_COPY       0xF2
#define VK_OEM_AUTO       0xF3
#define VK_OEM_ENLW       0xF4
#define VK_OEM_BACKTAB    0xF5

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE
};

DWORD GetKeyState(VirtualKey nVirtKey);
DWORD GetAsyncKeyState(VirtualKey vKey);

DwordFailIfNeg1 VkKeyScanA(char ch);
DwordFailIfNeg1 VkKeyScanW(WCHAR ch);

DwordFailIfNeg1 VkKeyScanExA(char ch, HKL dwhkl);
DwordFailIfNeg1 VkKeyScanExW(WCHAR ch, HKL dwhkl);


mask DWORD KeyModifier
{
#define MOD_ALT         0x0001
#define MOD_CONTROL     0x0002
#define MOD_SHIFT       0x0004
#define MOD_WIN         0x0008
};

FailOnFalse [gle] RegisterHotKey(HWND        hWnd,
                                 int         id,
                                 KeyModifier fsModifiers,
                                 VirtualKey  vk);

FailOnFalse [gle] UnregisterHotKey(HWND hWnd, int id);


LongFailIfZero [gle] GetKeyNameTextA(LONG lParam, [out] LPSTR lpString, int nSize);
LongFailIfZero [gle] GetKeyNameTextW(LONG lParam, [out] LPWSTR lpString, int nSize);

typedef struct tagKEYSTATE
{
    BYTE st[256];
} KEYSTATE, *LPKEYSTATE;

FailOnFalse [gle] GetKeyboardState([out] LPKEYSTATE lpKeyState);
FailOnFalse [gle] SetKeyboardState(LPKEYSTATE lpKeyState);

LongFailIfZero [gle] GetKeyboardType(int nTypeFlag);

typedef struct tagLASTINPUTINFO {
    UINT  cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

FailOnFalse GetLastInputInfo([out] PLASTINPUTINFO plii);

typedef LPVOID WNDENUMPROC;

FailOnFalse [gle] EnumThreadWindows(ThreadId dwThreadId, WNDENUMPROC lpfn, LPARAM lParam);

FailOnFalse [gle] EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);

FailOnFalse [gle] EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);

FailOnFalse [gle] EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam);

HDESK [gle] GetThreadDesktop(ThreadId dwThreadId);

FailOnFalse [gle] CloseDesktop(HDESK hDesktop);

mask DWORD DesktopAccessMask
{
#define DESKTOP_READOBJECTS         0x0001
#define DESKTOP_CREATEWINDOW        0x0002
#define DESKTOP_CREATEMENU          0x0004
#define DESKTOP_HOOKCONTROL         0x0008
#define DESKTOP_JOURNALRECORD       0x0010
#define DESKTOP_JOURNALPLAYBACK     0x0020
#define DESKTOP_ENUMERATE           0x0040
#define DESKTOP_WRITEOBJECTS        0x0080
#define DESKTOP_SWITCHDESKTOP       0x0100
};

HDESK [gle] CreateDesktopA(LPCSTR                lpszDesktop,
                           LPCSTR                lpszDevice,
                           LPDEVMODEA            pDevmode,
                           DWORD                 dwFlags,
                           DesktopAccessMask     dwDesiredAccess,
                           LPSECURITY_ATTRIBUTES lpsa);

HDESK [gle] CreateDesktopW(LPCWSTR               lpszDesktop,
                           LPCWSTR               lpszDevice,
                           LPDEVMODEW            pDevmode,
                           DWORD                 dwFlags,
                           DesktopAccessMask     dwDesiredAccess,
                           LPSECURITY_ATTRIBUTES lpsa);

typedef LPVOID DESKTOPENUMPROCA;
typedef LPVOID DESKTOPENUMPROCW;

FailOnFalse [gle] EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam);
FailOnFalse [gle] EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam);

HDESK [gle] OpenInputDesktop(DWORD dwFlags, BOOL fInherit, DesktopAccessMask dwDesiredAccess);

FailOnFalse [gle] SetThreadDesktop(HDESK hDesktop);

HDESK [gle] OpenDesktopA(LPCSTR            lpszDesktop,
                         DWORD             dwFlags,
                         BOOL              fInherit,
                         DesktopAccessMask dwDesiredAccess);

HDESK [gle] OpenDesktopW(LPCWSTR           lpszDesktop,
                         DWORD             dwFlags,
                         BOOL              fInherit,
                         DesktopAccessMask dwDesiredAccess);

FailOnFalse [gle] SwitchDesktop(HDESK hDesktop);

LongFailIfZero [gle] TileWindows(HWND   hwndParent,
                                 UINT   wHow,
                                 LPRECT lpRect,
                                 UINT   cKids,
                                 HWND*  lpKids);

LongFailIfZero [gle] CascadeWindows(HWND   hwndParent,
                                    UINT   wHow,
                                    LPRECT lpRect,
                                    UINT   cKids,
                                    HWND*  lpKids);

FailOnFalse [gle] BringWindowToTop(HWND hWnd);

mask DWORD ButtonState
{
#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008
};

FailOnFalse [gle] CheckDlgButton(HWND hDlg, int nIDButton, ButtonState uCheck);

FailOnFalse [gle] CheckRadioButton(HWND hDlg,
                                   int  nIDFirstButton,
                                   int  nIDLastButton,
                                   int  nIDCheckButton);

ButtonState IsDlgButtonChecked(HWND hDlg, int nIDButton);

LongFailIfZero [gle] GetDlgCtrlID(HWND hWnd);

HWND [gle] GetDlgItem(HWND hDlg, int nIDDlgItem);

LongFailIfZero [gle] GetDlgItemInt(HWND        hDlg,
                                   int         nIDDlgItem,
                                   [out] BOOL* lpTranslated,
                                   BOOL        bSigned);


mask DWORD DrawTextFlags
{
#define DT_TOP                      0x00000000
#define DT_LEFT                     0x00000000
#define DT_CENTER                   0x00000001
#define DT_RIGHT                    0x00000002
#define DT_VCENTER                  0x00000004
#define DT_BOTTOM                   0x00000008
#define DT_WORDBREAK                0x00000010
#define DT_SINGLELINE               0x00000020
#define DT_EXPANDTABS               0x00000040
#define DT_TABSTOP                  0x00000080
#define DT_NOCLIP                   0x00000100
#define DT_EXTERNALLEADING          0x00000200
#define DT_CALCRECT                 0x00000400
#define DT_NOPREFIX                 0x00000800
#define DT_INTERNAL                 0x00001000

#define DT_EDITCONTROL              0x00002000
#define DT_PATH_ELLIPSIS            0x00004000
#define DT_END_ELLIPSIS             0x00008000
#define DT_MODIFYSTRING             0x00010000
#define DT_RTLREADING               0x00020000
#define DT_WORD_ELLIPSIS            0x00040000
#define DT_NOFULLWIDTHCHARBREAK     0x00080000
#define DT_HIDEPREFIX               0x00100000
#define DT_PREFIXONLY               0x00200000
};

LongFailIfZero [gle] DrawTextA(HDC           hDC,
                               LPCSTR        lpString,
                               int           nCount,
                               [out] LPRECT  lpRect,
                               DrawTextFlags uFormat);

LongFailIfZero [gle] DrawTextW(HDC           hDC,
                               LPCWSTR       lpString,
                               int           nCount,
                               [out] LPRECT  lpRect,
                               DrawTextFlags uFormat);

typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS, *LPDRAWTEXTPARAMS;

LongFailIfZero [gle] DrawTextExA(HDC              hDC,
                                 [out] LPSTR      lpString,
                                 int              nCount,
                                 [out] LPRECT     lpRect,
                                 DrawTextFlags    uFormat,
                                 LPDRAWTEXTPARAMS lpDrawTextParams);

LongFailIfZero [gle] DrawTextExW(HDC              hDC,
                                 [out] LPWSTR     lpString,
                                 int              nCount,
                                 [out] LPRECT     lpRect,
                                 DrawTextFlags    uFormat,
                                 LPDRAWTEXTPARAMS lpDrawTextParams);

DwordFailIfZero [gle] GetTabbedTextExtentA(HDC    hDC,
                                           LPCSTR lpString,
                                           int    nCount,
                                           int    nTabPositions,
                                           int*   lpnTabStopPositions);

DwordFailIfZero [gle] GetTabbedTextExtentW(HDC     hDC,
                                           LPCWSTR lpString,
                                           int     nCount,
                                           int     nTabPositions,
                                           int*    lpnTabStopPositions);

DwordFailIfZero [gle] TabbedTextOutA(HDC     hDC,
                                     int     X,
                                     int     Y,
                                     LPCSTR  lpString,
                                     int     nCount,
                                     int     nTabPositions,
                                     int*    lpnTabStopPositions,
                                     int     nTabOrigin);

DwordFailIfZero [gle] TabbedTextOutW(HDC     hDC,
                                     int     X,
                                     int     Y,
                                     LPCWSTR lpString,
                                     int     nCount,
                                     int     nTabPositions,
                                     int*    lpnTabStopPositions,
                                     int     nTabOrigin);



typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int   cItems;
    int   cColumns;
    int   cRows;
    int   iColFocus;
    int   iRowFocus;
    int   cxItem;
    int   cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

FailOnFalse [gle] GetAltTabInfoA(HWND              hwnd,
                                 int               iItem,
                                 [out] PALTTABINFO pati,
                                 [out] LPSTR       pszItemText,
                                 UINT              cchItemText);

FailOnFalse [gle] GetAltTabInfoW(HWND              hwnd,
                                 int               iItem,
                                 [out] PALTTABINFO pati,
                                 [out] LPWSTR      pszItemText,
                                 UINT              cchItemText);

LongFailIfZero [gle] RealGetWindowClassA(HWND  hwnd, [out] LPSTR pszType, UINT cchType);
LongFailIfZero [gle] RealGetWindowClassW(HWND  hwnd, [out] LPWSTR pszType, UINT cchType);

DWORD GetQueueStatus(QueueStates flags);

FailOnFalse [gle] BlockInput(BOOL fBlockIt);

// not detailed
// export SendInput;

mask DWORD KeybdEventFlags
{
#define KEYEVENTF_EXTENDEDKEY 0x0001
#define KEYEVENTF_KEYUP       0x0002
#define KEYEVENTF_UNICODE     0x0004
#define KEYEVENTF_SCANCODE    0x0008
};

VOID keybd_event(VirtualKey bVk, BYTE bScan, KeybdEventFlags dwFlags, DWORD dwExtraInfo);

mask DWORD MouseEventFlags
{
#define MOUSEEVENTF_MOVE        0x0001
#define MOUSEEVENTF_LEFTDOWN    0x0002
#define MOUSEEVENTF_LEFTUP      0x0004
#define MOUSEEVENTF_RIGHTDOWN   0x0008
#define MOUSEEVENTF_RIGHTUP     0x0010
#define MOUSEEVENTF_MIDDLEDOWN  0x0020
#define MOUSEEVENTF_MIDDLEUP    0x0040
#define MOUSEEVENTF_XDOWN       0x0080
#define MOUSEEVENTF_XUP         0x0100
#define MOUSEEVENTF_WHEEL       0x0800
#define MOUSEEVENTF_VIRTUALDESK 0x4000
#define MOUSEEVENTF_ABSOLUTE    0x8000
};

VOID mouse_event(MouseEventFlags dwFlags, DWORD dx, DWORD dy, DWORD dwData, DWORD dwExtraInfo);


BOOL GetInputState();

mask DWORD DrawCaptionFlags
{
#define DC_ACTIVE           0x0001
#define DC_SMALLCAP         0x0002
#define DC_ICON             0x0004
#define DC_TEXT             0x0008
#define DC_INBUTTON         0x0010
#define DC_GRADIENT         0x0020
};

FailOnFalse [gle] DrawCaption(HWND hwnd, HDC hdc, LPRECT lprc, DrawCaptionFlags dwFlags);

FailOnFalse [gle] DrawAnimatedRects(HWND   hwnd,
                                    int    idAni,
                                    LPRECT lprcFrom,
                                    LPRECT lprcTo);

mask DWORD BorderStyle
{
#define BDR_RAISEDOUTER 0x0001
#define BDR_SUNKENOUTER 0x0002
#define BDR_RAISEDINNER 0x0004
#define BDR_SUNKENINNER 0x0008
};

mask DWORD BorderType
{
#define BF_LEFT         0x0001
#define BF_TOP          0x0002
#define BF_RIGHT        0x0004
#define BF_BOTTOM       0x0008

#define BF_DIAGONAL     0x0010

#define BF_MIDDLE       0x0800
#define BF_SOFT         0x1000
#define BF_ADJUST       0x2000
#define BF_FLAT         0x4000
#define BF_MONO         0x8000
};

FailOnFalse [gle] DrawEdge(HDC          hdc,
                           [out] LPRECT lprc,
                           BorderStyle  edge,
                           BorderType   grfFlags);

value DWORD DrawFrameControlType
{
#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#define DFC_POPUPMENU           5
};

mask DWORD DrawFrameControlState
{
#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000
};

FailOnFalse [gle] DrawFrameControl(HDC                   hDC,
                                   [out] LPRECT          lprc,
                                   DrawFrameControlType  type,
                                   DrawFrameControlState state);

FailOnFalse [gle] DrawIcon(HDC hDC, int X, int Y, HRSRC hIcon);

value DWORD DrawIconExFlags
{
#define DI_MASK         0x0001
#define DI_IMAGE        0x0002
#define DI_NORMAL       0x0003
#define DI_COMPAT       0x0004
#define DI_DEFAULTSIZE  0x0008
};


FailOnFalse [gle] DrawIconEx(HDC             hdc,
                             int             xLeft, 
                             int             yTop,
                             HRSRC           hIcon,
                             int             cxWidth,
                             int             cyWidth,
                             UINT            istepIfAniCur,
                             HRSRC           hbrFlickerFreeDraw,
                             DrawIconExFlags diFlags);

typedef LPVOID DRAWSTATEPROC;

mask DWORD DrawStateFlags
{
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010
#define DSS_DISABLED    0x0020
#define DSS_MONO        0x0080
#define DSS_HIDEPREFIX  0x0200
#define DSS_PREFIXONLY  0x0400
#define DSS_RIGHT       0x8000
};

FailOnFalse [gle] DrawStateA(HDC            hDC,
                             HRSRC          hBrush,
                             DRAWSTATEPROC  pfnOutput,
                             LPARAM         lParam,
                             WPARAM         wParam,
                             int            x,
                             int            y,
                             int            cx,
                             int            cy,
                             DrawStateFlags flags);

FailOnFalse [gle] DrawStateW(HDC            hDC,
                             HRSRC          hBrush,
                             DRAWSTATEPROC  pfnOutput,
                             LPARAM         lParam,
                             WPARAM         wParam,
                             int            x,
                             int            y,
                             int            cx,
                             int            cy,
                             DrawStateFlags flags);

typedef LPVOID GRAYSTRINGPROC;

FailOnFalse [gle] GrayStringA(HDC            hDC,
                              HRSRC          hBrush,
                              GRAYSTRINGPROC lpOutputFunc,
                              LPARAM         lpData,
                              int            nCount,
                              int            X,
                              int            Y,
                              int            nWidth,
                              int            nHeight);

FailOnFalse [gle] GrayStringW(HDC            hDC,
                              HRSRC          hBrush,
                              GRAYSTRINGPROC lpOutputFunc,
                              LPARAM         lpData,
                              int            nCount,
                              int            X,
                              int            Y,
                              int            nWidth,
                              int            nHeight);

FailOnFalse [gle] CreateCaret(HWND  hWnd,
                              HRSRC hBitmap,
                              int   nWidth,
                              int   nHeight);

FailOnFalse [gle] DestroyCaret();

FailOnFalse [gle] SetCaretBlinkTime(UINT uMSeconds);

LongFailIfZero [gle] GetCaretBlinkTime();

FailOnFalse [gle] SetCaretPos(int X, int Y);

FailOnFalse [gle] GetCaretPos([out] LPPOINT lpPoint);

FailOnFalse [gle] ShowCaret(HWND hWnd);

FailOnFalse [gle] HideCaret(HWND hWnd);

// WindowStation APIs

mask DWORD WinstaAccessMask
{
#define WINSTA_ENUMDESKTOPS         0x0001
#define WINSTA_READATTRIBUTES       0x0002
#define WINSTA_ACCESSCLIPBOARD      0x0004
#define WINSTA_CREATEDESKTOP        0x0008
#define WINSTA_WRITEATTRIBUTES      0x0010
#define WINSTA_ACCESSGLOBALATOMS    0x0020
#define WINSTA_EXITWINDOWS          0x0040
#define WINSTA_ENUMERATE            0x0100
#define WINSTA_READSCREEN           0x0200
};

HWINSTA [gle] CreateWindowStationA(LPCSTR                lpwinsta,
                                   DWORD                 dwReserved,
                                   WinstaAccessMask      dwDesiredAccess,
                                   LPSECURITY_ATTRIBUTES lpsa);

HWINSTA [gle] CreateWindowStationW(LPCWSTR               lpwinsta,
                                   DWORD                 dwReserved,
                                   WinstaAccessMask      dwDesiredAccess,
                                   LPSECURITY_ATTRIBUTES lpsa);

FailOnFalse [gle] CloseWindowStation([da] HWINSTA hWinSta);

typedef LPVOID WINSTAENUMPROCA;
typedef LPVOID WINSTAENUMPROCW;

FailOnFalse [gle] EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam);
FailOnFalse [gle] EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam);

HWINSTA [gle] GetProcessWindowStation();

FailOnFalse [gle] SetProcessWindowStation(HWINSTA hWinSta);

HWINSTA [gle] OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, WinstaAccessMask dwDesiredAccess);
HWINSTA [gle] OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, WinstaAccessMask dwDesiredAccess);

// scrollbar

value DWORD ScrollWhich
{
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3
};

mask DWORD ScrollEnableFlags
{
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002
};

FailOnFalse [gle] EnableScrollBar(HWND hWnd, ScrollWhich wSBflags, ScrollEnableFlags wArrows);

mask DWORD ScrollInfoFlags
{
#define SIF_RANGE           0x0001
#define SIF_PAGE            0x0002
#define SIF_POS             0x0004
#define SIF_DISABLENOSCROLL 0x0008
#define SIF_TRACKPOS        0x0010
};

typedef struct tagSCROLLINFO
{
    UINT            cbSize;
    ScrollInfoFlags fMask;
    int             nMin;
    int             nMax;
    UINT            nPage;
    int             nPos;
    int             nTrackPos;
} SCROLLINFO, *LPSCROLLINFO;

int SetScrollInfo(HWND hWnd, ScrollWhich nWhich, LPSCROLLINFO lpScrollInfo, BOOL fRedraw);

LongFailIfZero [gle] SetScrollPos(HWND hWnd, ScrollWhich nBar, int nPos, BOOL bRedraw);

FailOnFalse [gle] SetScrollRange(HWND        hWnd,
                                 ScrollWhich nBar,
                                 int         nMinPos,
                                 int         nMaxPos,
                                 BOOL        bRedraw);

typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT  rcScrollBar;
    int   dxyLineButton;
    int   xyThumbTop;
    int   xyThumbBottom;
    int   reserved;
    DWORD rgstate[6];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

FailOnFalse [gle] GetScrollBarInfo(HWND hwnd, SystemObjectId idObject, [out] PSCROLLBARINFO psbi);

FailOnFalse [gle] GetScrollInfo(HWND hwnd, ScrollWhich nBar, [out] LPSCROLLINFO lpScrollInfo);

LongFailIfZero [gle] GetScrollPos(HWND hWnd, ScrollWhich nBar);

FailOnFalse [gle] GetScrollRange(HWND        hWnd,
                                 ScrollWhich nBar,
                                 [out] int*  lpMinPos,
                                 [out] int*  lpMaxPos);

FailOnFalse [gle] ShowScrollBar(HWND hWnd, ScrollWhich nBar, BOOL bShow);

typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT  rcItem;
    RECT  rcButton;
    DWORD stateButton;
    HWND  hwndCombo;
    HWND  hwndItem;
    HWND  hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

FailOnFalse [gle] GetComboBoxInfo(HWND hwndCombo, [out] PCOMBOBOXINFO pcbi);

int GetListBoxInfo(HWND hwnd);

typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT  rcTitleBar;
    DWORD rgstate[6];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

BOOL GetTitleBarInfo(HWND hwnd, [out] PTITLEBARINFO pti);

typedef LPVOID TIMERPROC;

DwordFailIfZero [gle] SetTimer(HWND hWnd, DWORD nIDEvent, int uElapse, TIMERPROC lpTimerFunc);

FailOnFalse [gle] KillTimer(HWND hWnd, DWORD uIDEvent);

FailOnFalse [gle] SetDoubleClickTime(int nTimeout);

int GetDoubleClickTime();

LPARAM SetMessageExtraInfo(LPARAM lParam);

mask DWORD TrackMouseEventFlags
{
#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#define TME_NONCLIENT   0x00000010
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000
};

typedef struct tagTRACKMOUSEEVENT {
    DWORD                cbSize;
    TrackMouseEventFlags dwFlags;
    HWND                 hwndTrack;
    DWORD                dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;


// BUGBUG: this is [in] and [out]
FailOnFalse [gle] TrackMouseEvent([out] LPTRACKMOUSEEVENT lpEventTrack);

BOOL SwapMouseButton(BOOL fSwap);

LongFailIfZero [gle] MapWindowPoints(HWND          hWndFrom,
                                     HWND          hWndTo,
                                     [out] LPPOINT lpPoints,
                                     int           cPoints);


category User32StringExports:

LongFailIfZero [gle] LoadStringA(HINSTANCE hInstance, UINT uID, [out] LPSTR lpBuffer, int nBufferMax);
LongFailIfZero [gle] LoadStringW(HINSTANCE hInstance, UINT uID, [out] LPWSTR lpBuffer, int nBufferMax);

#include "clipboard.h"
#include "hook.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\winerror.h ===
value LONG WinError
{
#define ERROR_SUCCESS                    0L
#define ERROR_INVALID_FUNCTION           1L           [fail]
#define ERROR_FILE_NOT_FOUND             2L           [fail]
#define ERROR_PATH_NOT_FOUND             3L           [fail]
#define ERROR_TOO_MANY_OPEN_FILES        4L           [fail]
#define ERROR_ACCESS_DENIED              5L           [fail]
#define ERROR_INVALID_HANDLE             6L           [fail]
#define ERROR_ARENA_TRASHED              7L           [fail]
#define ERROR_NOT_ENOUGH_MEMORY          8L           [fail]
#define ERROR_INVALID_BLOCK              9L           [fail]
#define ERROR_BAD_ENVIRONMENT            10L          [fail]
#define ERROR_BAD_FORMAT                 11L          [fail]
#define ERROR_INVALID_ACCESS             12L          [fail]
#define ERROR_INVALID_DATA               13L          [fail]
#define ERROR_OUTOFMEMORY                14L          [fail]
#define ERROR_INVALID_DRIVE              15L          [fail]
#define ERROR_CURRENT_DIRECTORY          16L          [fail]
#define ERROR_NOT_SAME_DEVICE            17L          [fail]
#define ERROR_NO_MORE_FILES              18L          [fail]
#define ERROR_WRITE_PROTECT              19L          [fail]
#define ERROR_BAD_UNIT                   20L          [fail]
#define ERROR_NOT_READY                  21L          [fail]
#define ERROR_BAD_COMMAND                22L          [fail]
#define ERROR_CRC                        23L          [fail]
#define ERROR_BAD_LENGTH                 24L          [fail]
#define ERROR_SEEK                       25L          [fail]
#define ERROR_NOT_DOS_DISK               26L          [fail]
#define ERROR_SECTOR_NOT_FOUND           27L          [fail]
#define ERROR_OUT_OF_PAPER               28L          [fail]
#define ERROR_WRITE_FAULT                29L          [fail]
#define ERROR_READ_FAULT                 30L          [fail]
#define ERROR_GEN_FAILURE                31L          [fail]
#define ERROR_SHARING_VIOLATION          32L          [fail]
#define ERROR_LOCK_VIOLATION             33L          [fail]
#define ERROR_WRONG_DISK                 34L          [fail]
#define ERROR_SHARING_BUFFER_EXCEEDED    36L          [fail]
#define ERROR_HANDLE_EOF                 38L          [fail]
#define ERROR_HANDLE_DISK_FULL           39L          [fail]
#define ERROR_NOT_SUPPORTED              50L          [fail]
#define ERROR_REM_NOT_LIST               51L          [fail]
#define ERROR_DUP_NAME                   52L          [fail]
#define ERROR_BAD_NETPATH                53L          [fail]
#define ERROR_NETWORK_BUSY               54L          [fail]
#define ERROR_DEV_NOT_EXIST              55L          [fail]
#define ERROR_TOO_MANY_CMDS              56L          [fail]
#define ERROR_ADAP_HDW_ERR               57L          [fail]
#define ERROR_BAD_NET_RESP               58L          [fail]
#define ERROR_UNEXP_NET_ERR              59L          [fail]
#define ERROR_BAD_REM_ADAP               60L          [fail]
#define ERROR_PRINTQ_FULL                61L          [fail]
#define ERROR_NO_SPOOL_SPACE             62L          [fail]
#define ERROR_PRINT_CANCELLED            63L          [fail]
#define ERROR_NETNAME_DELETED            64L          [fail]
#define ERROR_NETWORK_ACCESS_DENIED      65L          [fail]
#define ERROR_BAD_DEV_TYPE               66L          [fail]
#define ERROR_BAD_NET_NAME               67L          [fail]
#define ERROR_TOO_MANY_NAMES             68L          [fail]
#define ERROR_TOO_MANY_SESS              69L          [fail]
#define ERROR_SHARING_PAUSED             70L          [fail]
#define ERROR_REQ_NOT_ACCEP              71L          [fail]
#define ERROR_REDIR_PAUSED               72L          [fail]
#define ERROR_FILE_EXISTS                80L          [fail]
#define ERROR_CANNOT_MAKE                82L          [fail]
#define ERROR_FAIL_I24                   83L          [fail]
#define ERROR_OUT_OF_STRUCTURES          84L          [fail]
#define ERROR_ALREADY_ASSIGNED           85L          [fail]
#define ERROR_INVALID_PASSWORD           86L          [fail]
#define ERROR_INVALID_PARAMETER          87L          [fail]
#define ERROR_NET_WRITE_FAULT            88L          [fail]
#define ERROR_NO_PROC_SLOTS              89L          [fail]
#define ERROR_TOO_MANY_SEMAPHORES        100L         [fail]
#define ERROR_EXCL_SEM_ALREADY_OWNED     101L         [fail]
#define ERROR_SEM_IS_SET                 102L         [fail]
#define ERROR_TOO_MANY_SEM_REQUESTS      103L         [fail]
#define ERROR_INVALID_AT_INTERRUPT_TIME  104L         [fail]
#define ERROR_SEM_OWNER_DIED             105L         [fail]
#define ERROR_SEM_USER_LIMIT             106L         [fail]
#define ERROR_DISK_CHANGE                107L         [fail]
#define ERROR_DRIVE_LOCKED               108L         [fail]
#define ERROR_BROKEN_PIPE                109L         [fail]
#define ERROR_OPEN_FAILED                110L         [fail]
#define ERROR_BUFFER_OVERFLOW            111L         [fail]
#define ERROR_DISK_FULL                  112L         [fail]
#define ERROR_NO_MORE_SEARCH_HANDLES     113L         [fail]
#define ERROR_INVALID_TARGET_HANDLE      114L         [fail]
#define ERROR_INVALID_CATEGORY           117L         [fail]
#define ERROR_INVALID_VERIFY_SWITCH      118L         [fail]
#define ERROR_BAD_DRIVER_LEVEL           119L         [fail]
#define ERROR_CALL_NOT_IMPLEMENTED       120L         [fail]
#define ERROR_SEM_TIMEOUT                121L         [fail]
#define ERROR_INSUFFICIENT_BUFFER        122L         [fail]
#define ERROR_INVALID_NAME               123L         [fail]
#define ERROR_INVALID_LEVEL              124L         [fail]
#define ERROR_NO_VOLUME_LABEL            125L         [fail]
#define ERROR_MOD_NOT_FOUND              126L         [fail]
#define ERROR_PROC_NOT_FOUND             127L         [fail]
#define ERROR_WAIT_NO_CHILDREN           128L         [fail]
#define ERROR_CHILD_NOT_COMPLETE         129L         [fail]
#define ERROR_DIRECT_ACCESS_HANDLE       130L         [fail]
#define ERROR_NEGATIVE_SEEK              131L         [fail]
#define ERROR_SEEK_ON_DEVICE             132L         [fail]
#define ERROR_IS_JOIN_TARGET             133L         [fail]
#define ERROR_IS_JOINED                  134L         [fail]
#define ERROR_IS_SUBSTED                 135L         [fail]
#define ERROR_NOT_JOINED                 136L         [fail]
#define ERROR_NOT_SUBSTED                137L         [fail]
#define ERROR_JOIN_TO_JOIN               138L         [fail]
#define ERROR_SUBST_TO_SUBST             139L         [fail]
#define ERROR_JOIN_TO_SUBST              140L         [fail]
#define ERROR_SUBST_TO_JOIN              141L         [fail]
#define ERROR_BUSY_DRIVE                 142L         [fail]
#define ERROR_SAME_DRIVE                 143L         [fail]
#define ERROR_DIR_NOT_ROOT               144L         [fail]
#define ERROR_DIR_NOT_EMPTY              145L         [fail]
#define ERROR_IS_SUBST_PATH              146L         [fail]
#define ERROR_IS_JOIN_PATH               147L         [fail]
#define ERROR_PATH_BUSY                  148L         [fail]
#define ERROR_IS_SUBST_TARGET            149L         [fail]
#define ERROR_SYSTEM_TRACE               150L         [fail]
#define ERROR_INVALID_EVENT_COUNT        151L         [fail]
#define ERROR_TOO_MANY_MUXWAITERS        152L         [fail]
#define ERROR_INVALID_LIST_FORMAT        153L         [fail]
#define ERROR_LABEL_TOO_LONG             154L         [fail]
#define ERROR_TOO_MANY_TCBS              155L         [fail]
#define ERROR_SIGNAL_REFUSED             156L         [fail]
#define ERROR_DISCARDED                  157L         [fail]
#define ERROR_NOT_LOCKED                 158L         [fail]
#define ERROR_BAD_THREADID_ADDR          159L         [fail]
#define ERROR_BAD_ARGUMENTS              160L         [fail]
#define ERROR_BAD_PATHNAME               161L         [fail]
#define ERROR_SIGNAL_PENDING             162L         [fail]
#define ERROR_MAX_THRDS_REACHED          164L         [fail]
#define ERROR_LOCK_FAILED                167L         [fail]
#define ERROR_BUSY                       170L         [fail]
#define ERROR_CANCEL_VIOLATION           173L         [fail]
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174L         [fail]
#define ERROR_INVALID_SEGMENT_NUMBER     180L         [fail]
#define ERROR_INVALID_ORDINAL            182L         [fail]
#define ERROR_ALREADY_EXISTS             183L         [fail]
#define ERROR_INVALID_FLAG_NUMBER        186L         [fail]
#define ERROR_SEM_NOT_FOUND              187L         [fail]
#define ERROR_INVALID_STARTING_CODESEG   188L         [fail]
#define ERROR_INVALID_STACKSEG           189L         [fail]
#define ERROR_INVALID_MODULETYPE         190L         [fail]
#define ERROR_INVALID_EXE_SIGNATURE      191L         [fail]
#define ERROR_EXE_MARKED_INVALID         192L         [fail]
#define ERROR_BAD_EXE_FORMAT             193L         [fail]
#define ERROR_ITERATED_DATA_EXCEEDS_64k  194L         [fail]
#define ERROR_INVALID_MINALLOCSIZE       195L         [fail]
#define ERROR_DYNLINK_FROM_INVALID_RING  196L         [fail]
#define ERROR_IOPL_NOT_ENABLED           197L         [fail]
#define ERROR_INVALID_SEGDPL             198L         [fail]
#define ERROR_AUTODATASEG_EXCEEDS_64k    199L         [fail]
#define ERROR_RING2SEG_MUST_BE_MOVABLE   200L         [fail]
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM   201L         [fail]
#define ERROR_INFLOOP_IN_RELOC_CHAIN     202L         [fail]
#define ERROR_ENVVAR_NOT_FOUND           203L         [fail]
#define ERROR_NO_SIGNAL_SENT             205L         [fail]
#define ERROR_FILENAME_EXCED_RANGE       206L         [fail]
#define ERROR_RING2_STACK_IN_USE         207L         [fail]
#define ERROR_META_EXPANSION_TOO_LONG    208L         [fail]
#define ERROR_INVALID_SIGNAL_NUMBER      209L         [fail]
#define ERROR_THREAD_1_INACTIVE          210L         [fail]
#define ERROR_LOCKED                     212L         [fail]
#define ERROR_TOO_MANY_MODULES           214L         [fail]
#define ERROR_NESTING_NOT_ALLOWED        215L         [fail]
#define ERROR_EXE_MACHINE_TYPE_MISMATCH  216L         [fail]
#define ERROR_BAD_PIPE                   230L         [fail]
#define ERROR_PIPE_BUSY                  231L         [fail]
#define ERROR_NO_DATA                    232L         [fail]
#define ERROR_PIPE_NOT_CONNECTED         233L         [fail]
#define ERROR_MORE_DATA                  234L         [fail]
#define ERROR_VC_DISCONNECTED            240L         [fail]
#define ERROR_INVALID_EA_NAME            254L         [fail]
#define ERROR_EA_LIST_INCONSISTENT       255L         [fail]
#define ERROR_NO_MORE_ITEMS              259L         [fail]
#define ERROR_CANNOT_COPY                266L         [fail]
#define ERROR_DIRECTORY                  267L         [fail]
#define ERROR_EAS_DIDNT_FIT              275L         [fail]
#define ERROR_EA_FILE_CORRUPT            276L         [fail]
#define ERROR_EA_TABLE_FULL              277L         [fail]
#define ERROR_INVALID_EA_HANDLE          278L         [fail]
#define ERROR_EAS_NOT_SUPPORTED          282L         [fail]
#define ERROR_NOT_OWNER                  288L         [fail]
#define ERROR_TOO_MANY_POSTS             298L         [fail]
#define ERROR_PARTIAL_COPY               299L         [fail]
#define ERROR_OPLOCK_NOT_GRANTED         300L         [fail]
#define ERROR_INVALID_OPLOCK_PROTOCOL    301L         [fail]
#define ERROR_MR_MID_NOT_FOUND           317L         [fail]
#define ERROR_INVALID_ADDRESS            487L         [fail]
#define ERROR_ARITHMETIC_OVERFLOW        534L         [fail]
#define ERROR_PIPE_CONNECTED             535L         [fail]
#define ERROR_PIPE_LISTENING             536L         [fail]
#define ERROR_EA_ACCESS_DENIED           994L         [fail]
#define ERROR_OPERATION_ABORTED          995L         [fail]
#define ERROR_IO_INCOMPLETE              996L         [fail]
#define ERROR_IO_PENDING                 997L         [fail]
#define ERROR_NOACCESS                   998L         [fail]
#define ERROR_SWAPERROR                  999L         [fail]
#define ERROR_STACK_OVERFLOW             1001L        [fail]
#define ERROR_INVALID_MESSAGE            1002L        [fail]
#define ERROR_CAN_NOT_COMPLETE           1003L        [fail]
#define ERROR_INVALID_FLAGS              1004L        [fail]
#define ERROR_UNRECOGNIZED_VOLUME        1005L        [fail]
#define ERROR_FILE_INVALID               1006L        [fail]
#define ERROR_FULLSCREEN_MODE            1007L        [fail]
#define ERROR_NO_TOKEN                   1008L        [fail]
#define ERROR_BADDB                      1009L        [fail]
#define ERROR_BADKEY                     1010L        [fail]
#define ERROR_CANTOPEN                   1011L        [fail]
#define ERROR_CANTREAD                   1012L        [fail]
#define ERROR_CANTWRITE                  1013L        [fail]
#define ERROR_REGISTRY_RECOVERED         1014L        [fail]
#define ERROR_REGISTRY_CORRUPT           1015L        [fail]
#define ERROR_REGISTRY_IO_FAILED         1016L        [fail]
#define ERROR_NOT_REGISTRY_FILE          1017L        [fail]
#define ERROR_KEY_DELETED                1018L        [fail]
#define ERROR_NO_LOG_SPACE               1019L        [fail]
#define ERROR_KEY_HAS_CHILDREN           1020L        [fail]
#define ERROR_CHILD_MUST_BE_VOLATILE     1021L        [fail]
#define ERROR_NOTIFY_ENUM_DIR            1022L        [fail]
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L        [fail]
#define ERROR_INVALID_SERVICE_CONTROL    1052L        [fail]
#define ERROR_SERVICE_REQUEST_TIMEOUT    1053L        [fail]
#define ERROR_SERVICE_NO_THREAD          1054L        [fail]
#define ERROR_SERVICE_DATABASE_LOCKED    1055L        [fail]
#define ERROR_SERVICE_ALREADY_RUNNING    1056L        [fail]
#define ERROR_INVALID_SERVICE_ACCOUNT    1057L        [fail]
#define ERROR_SERVICE_DISABLED           1058L        [fail]
#define ERROR_CIRCULAR_DEPENDENCY        1059L        [fail]
#define ERROR_SERVICE_DOES_NOT_EXIST     1060L        [fail]
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L        [fail]
#define ERROR_SERVICE_NOT_ACTIVE         1062L        [fail]
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063L [fail]
#define ERROR_EXCEPTION_IN_SERVICE       1064L        [fail]
#define ERROR_DATABASE_DOES_NOT_EXIST    1065L        [fail]
#define ERROR_SERVICE_SPECIFIC_ERROR     1066L        [fail]
#define ERROR_PROCESS_ABORTED            1067L        [fail]
#define ERROR_SERVICE_DEPENDENCY_FAIL    1068L        [fail]
#define ERROR_SERVICE_LOGON_FAILED       1069L        [fail]
#define ERROR_SERVICE_START_HANG         1070L        [fail]
#define ERROR_INVALID_SERVICE_LOCK       1071L        [fail]
#define ERROR_SERVICE_MARKED_FOR_DELETE  1072L        [fail]
#define ERROR_SERVICE_EXISTS             1073L        [fail]
#define ERROR_ALREADY_RUNNING_LKG        1074L        [fail]
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L        [fail]
#define ERROR_BOOT_ALREADY_ACCEPTED      1076L        [fail]
#define ERROR_SERVICE_NEVER_STARTED      1077L        [fail]
#define ERROR_DUPLICATE_SERVICE_NAME     1078L        [fail]
#define ERROR_DIFFERENT_SERVICE_ACCOUNT  1079L        [fail]
#define ERROR_CANNOT_DETECT_DRIVER_FAILURE 1080L      [fail]
#define ERROR_CANNOT_DETECT_PROCESS_ABORT 1081L       [fail]
#define ERROR_NO_RECOVERY_PROGRAM        1082L        [fail]
#define ERROR_END_OF_MEDIA               1100L        [fail]
#define ERROR_FILEMARK_DETECTED          1101L        [fail]
#define ERROR_BEGINNING_OF_MEDIA         1102L        [fail]
#define ERROR_SETMARK_DETECTED           1103L        [fail]
#define ERROR_NO_DATA_DETECTED           1104L        [fail]
#define ERROR_PARTITION_FAILURE          1105L        [fail]
#define ERROR_INVALID_BLOCK_LENGTH       1106L        [fail]
#define ERROR_DEVICE_NOT_PARTITIONED     1107L        [fail]
#define ERROR_UNABLE_TO_LOCK_MEDIA       1108L        [fail]
#define ERROR_UNABLE_TO_UNLOAD_MEDIA     1109L        [fail]
#define ERROR_MEDIA_CHANGED              1110L        [fail]
#define ERROR_BUS_RESET                  1111L        [fail]
#define ERROR_NO_MEDIA_IN_DRIVE          1112L        [fail]
#define ERROR_NO_UNICODE_TRANSLATION     1113L        [fail]
#define ERROR_DLL_INIT_FAILED            1114L        [fail]
#define ERROR_SHUTDOWN_IN_PROGRESS       1115L        [fail]
#define ERROR_NO_SHUTDOWN_IN_PROGRESS    1116L        [fail]
#define ERROR_IO_DEVICE                  1117L        [fail]
#define ERROR_SERIAL_NO_DEVICE           1118L        [fail]
#define ERROR_IRQ_BUSY                   1119L        [fail]
#define ERROR_MORE_WRITES                1120L        [fail]
#define ERROR_COUNTER_TIMEOUT            1121L        [fail]
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND   1122L        [fail]
#define ERROR_FLOPPY_WRONG_CYLINDER      1123L        [fail]
#define ERROR_FLOPPY_UNKNOWN_ERROR       1124L        [fail]
#define ERROR_FLOPPY_BAD_REGISTERS       1125L        [fail]
#define ERROR_DISK_RECALIBRATE_FAILED    1126L        [fail]
#define ERROR_DISK_OPERATION_FAILED      1127L        [fail]
#define ERROR_DISK_RESET_FAILED          1128L        [fail]
#define ERROR_EOM_OVERFLOW               1129L        [fail]
#define ERROR_NOT_ENOUGH_SERVER_MEMORY   1130L        [fail]
#define ERROR_POSSIBLE_DEADLOCK          1131L        [fail]
#define ERROR_MAPPED_ALIGNMENT           1132L        [fail]
#define ERROR_SET_POWER_STATE_VETOED     1140L        [fail]
#define ERROR_SET_POWER_STATE_FAILED     1141L        [fail]
#define ERROR_TOO_MANY_LINKS             1142L        [fail]
#define ERROR_OLD_WIN_VERSION            1150L        [fail]
#define ERROR_APP_WRONG_OS               1151L        [fail]
#define ERROR_SINGLE_INSTANCE_APP        1152L        [fail]
#define ERROR_RMODE_APP                  1153L        [fail]
#define ERROR_INVALID_DLL                1154L        [fail]
#define ERROR_NO_ASSOCIATION             1155L        [fail]
#define ERROR_DDE_FAIL                   1156L        [fail]
#define ERROR_DLL_NOT_FOUND              1157L        [fail]
#define ERROR_NO_MORE_USER_HANDLES       1158L        [fail]
#define ERROR_MESSAGE_SYNC_ONLY          1159L        [fail]
#define ERROR_SOURCE_ELEMENT_EMPTY       1160L        [fail]
#define ERROR_DESTINATION_ELEMENT_FULL   1161L        [fail]
#define ERROR_ILLEGAL_ELEMENT_ADDRESS    1162L        [fail]
#define ERROR_MAGAZINE_NOT_PRESENT       1163L        [fail]
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    [fail]
#define ERROR_DEVICE_REQUIRES_CLEANING   1165L        [fail]
#define ERROR_DEVICE_DOOR_OPEN           1166L        [fail]
#define ERROR_DEVICE_NOT_CONNECTED       1167L        [fail]
#define ERROR_NOT_FOUND                  1168L        [fail]
#define ERROR_NO_MATCH                   1169L        [fail]
#define ERROR_SET_NOT_FOUND              1170L        [fail]
#define ERROR_POINT_NOT_FOUND            1171L        [fail]
#define ERROR_NO_TRACKING_SERVICE        1172L        [fail]
#define ERROR_NO_VOLUME_ID               1173L        [fail]
#define ERROR_CONNECTED_OTHER_PASSWORD   2108L        [fail]
#define ERROR_BAD_USERNAME               2202L        [fail]
#define ERROR_NOT_CONNECTED              2250L        [fail]
#define ERROR_OPEN_FILES                 2401L        [fail]
#define ERROR_ACTIVE_CONNECTIONS         2402L        [fail]
#define ERROR_DEVICE_IN_USE              2404L        [fail]
#define ERROR_BAD_DEVICE                 1200L        [fail]
#define ERROR_CONNECTION_UNAVAIL         1201L        [fail]
#define ERROR_DEVICE_ALREADY_REMEMBERED  1202L        [fail]
#define ERROR_NO_NET_OR_BAD_PATH         1203L        [fail]
#define ERROR_BAD_PROVIDER               1204L        [fail]
#define ERROR_CANNOT_OPEN_PROFILE        1205L        [fail]
#define ERROR_BAD_PROFILE                1206L        [fail]
#define ERROR_NOT_CONTAINER              1207L        [fail]
#define ERROR_EXTENDED_ERROR             1208L        [fail]
#define ERROR_INVALID_GROUPNAME          1209L        [fail]
#define ERROR_INVALID_COMPUTERNAME       1210L        [fail]
#define ERROR_INVALID_EVENTNAME          1211L        [fail]
#define ERROR_INVALID_DOMAINNAME         1212L        [fail]
#define ERROR_INVALID_SERVICENAME        1213L        [fail]
#define ERROR_INVALID_NETNAME            1214L        [fail]
#define ERROR_INVALID_SHARENAME          1215L        [fail]
#define ERROR_INVALID_PASSWORDNAME       1216L        [fail]
#define ERROR_INVALID_MESSAGENAME        1217L        [fail]
#define ERROR_INVALID_MESSAGEDEST        1218L        [fail]
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219L       [fail]
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220L     [fail]
#define ERROR_DUP_DOMAINNAME             1221L        [fail]
#define ERROR_NO_NETWORK                 1222L        [fail]
#define ERROR_CANCELLED                  1223L        [fail]
#define ERROR_USER_MAPPED_FILE           1224L        [fail]
#define ERROR_CONNECTION_REFUSED         1225L        [fail]
#define ERROR_GRACEFUL_DISCONNECT        1226L        [fail]
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227L        [fail]
#define ERROR_ADDRESS_NOT_ASSOCIATED     1228L        [fail]
#define ERROR_CONNECTION_INVALID         1229L        [fail]
#define ERROR_CONNECTION_ACTIVE          1230L        [fail]
#define ERROR_NETWORK_UNREACHABLE        1231L        [fail]
#define ERROR_HOST_UNREACHABLE           1232L        [fail]
#define ERROR_PROTOCOL_UNREACHABLE       1233L        [fail]
#define ERROR_PORT_UNREACHABLE           1234L        [fail]
#define ERROR_REQUEST_ABORTED            1235L        [fail]
#define ERROR_CONNECTION_ABORTED         1236L        [fail]
#define ERROR_RETRY                      1237L        [fail]
#define ERROR_CONNECTION_COUNT_LIMIT     1238L        [fail]
#define ERROR_LOGIN_TIME_RESTRICTION     1239L        [fail]
#define ERROR_LOGIN_WKSTA_RESTRICTION    1240L        [fail]
#define ERROR_INCORRECT_ADDRESS          1241L        [fail]
#define ERROR_ALREADY_REGISTERED         1242L        [fail]
#define ERROR_SERVICE_NOT_FOUND          1243L        [fail]
#define ERROR_NOT_AUTHENTICATED          1244L        [fail]
#define ERROR_NOT_LOGGED_ON              1245L        [fail]
#define ERROR_CONTINUE                   1246L        [fail]
#define ERROR_ALREADY_INITIALIZED        1247L        [fail]
#define ERROR_NO_MORE_DEVICES            1248L        [fail]
#define ERROR_NO_SUCH_SITE               1249L        [fail]
#define ERROR_DOMAIN_CONTROLLER_EXISTS   1250L        [fail]
#define ERROR_DS_NOT_INSTALLED           1251L        [fail]
#define ERROR_NOT_ALL_ASSIGNED           1300L        [fail]
#define ERROR_SOME_NOT_MAPPED            1301L        [fail]
#define ERROR_NO_QUOTAS_FOR_ACCOUNT      1302L        [fail]
#define ERROR_LOCAL_USER_SESSION_KEY     1303L        [fail]
#define ERROR_NULL_LM_PASSWORD           1304L        [fail]
#define ERROR_UNKNOWN_REVISION           1305L        [fail]
#define ERROR_REVISION_MISMATCH          1306L        [fail]
#define ERROR_INVALID_OWNER              1307L        [fail]
#define ERROR_INVALID_PRIMARY_GROUP      1308L        [fail]
#define ERROR_NO_IMPERSONATION_TOKEN     1309L        [fail]
#define ERROR_CANT_DISABLE_MANDATORY     1310L        [fail]
#define ERROR_NO_LOGON_SERVERS           1311L        [fail]
#define ERROR_NO_SUCH_LOGON_SESSION      1312L        [fail]
#define ERROR_NO_SUCH_PRIVILEGE          1313L        [fail]
#define ERROR_PRIVILEGE_NOT_HELD         1314L        [fail]
#define ERROR_INVALID_ACCOUNT_NAME       1315L        [fail]
#define ERROR_USER_EXISTS                1316L        [fail]
#define ERROR_NO_SUCH_USER               1317L        [fail]
#define ERROR_GROUP_EXISTS               1318L        [fail]
#define ERROR_NO_SUCH_GROUP              1319L        [fail]
#define ERROR_MEMBER_IN_GROUP            1320L        [fail]
#define ERROR_MEMBER_NOT_IN_GROUP        1321L        [fail]
#define ERROR_LAST_ADMIN                 1322L        [fail]
#define ERROR_WRONG_PASSWORD             1323L        [fail]
#define ERROR_ILL_FORMED_PASSWORD        1324L        [fail]
#define ERROR_PASSWORD_RESTRICTION       1325L        [fail]
#define ERROR_LOGON_FAILURE              1326L        [fail]
#define ERROR_ACCOUNT_RESTRICTION        1327L        [fail]
#define ERROR_INVALID_LOGON_HOURS        1328L        [fail]
#define ERROR_INVALID_WORKSTATION        1329L        [fail]
#define ERROR_PASSWORD_EXPIRED           1330L        [fail]
#define ERROR_ACCOUNT_DISABLED           1331L        [fail]
#define ERROR_NONE_MAPPED                1332L        [fail]
#define ERROR_TOO_MANY_LUIDS_REQUESTED   1333L        [fail]
#define ERROR_LUIDS_EXHAUSTED            1334L        [fail]
#define ERROR_INVALID_SUB_AUTHORITY      1335L        [fail]
#define ERROR_INVALID_ACL                1336L        [fail]
#define ERROR_INVALID_SID                1337L        [fail]
#define ERROR_INVALID_SECURITY_DESCR     1338L        [fail]
#define ERROR_BAD_INHERITANCE_ACL        1340L        [fail]
#define ERROR_SERVER_DISABLED            1341L        [fail]
#define ERROR_SERVER_NOT_DISABLED        1342L        [fail]
#define ERROR_INVALID_ID_AUTHORITY       1343L        [fail]
#define ERROR_ALLOTTED_SPACE_EXCEEDED    1344L        [fail]
#define ERROR_INVALID_GROUP_ATTRIBUTES   1345L        [fail]
#define ERROR_BAD_IMPERSONATION_LEVEL    1346L        [fail]
#define ERROR_CANT_OPEN_ANONYMOUS        1347L        [fail]
#define ERROR_BAD_VALIDATION_CLASS       1348L        [fail]
#define ERROR_BAD_TOKEN_TYPE             1349L        [fail]
#define ERROR_NO_SECURITY_ON_OBJECT      1350L        [fail]
#define ERROR_CANT_ACCESS_DOMAIN_INFO    1351L        [fail]
#define ERROR_INVALID_SERVER_STATE       1352L        [fail]
#define ERROR_INVALID_DOMAIN_STATE       1353L        [fail]
#define ERROR_INVALID_DOMAIN_ROLE        1354L        [fail]
#define ERROR_NO_SUCH_DOMAIN             1355L        [fail]
#define ERROR_DOMAIN_EXISTS              1356L        [fail]
#define ERROR_DOMAIN_LIMIT_EXCEEDED      1357L        [fail]
#define ERROR_INTERNAL_DB_CORRUPTION     1358L        [fail]
#define ERROR_INTERNAL_ERROR             1359L        [fail]
#define ERROR_GENERIC_NOT_MAPPED         1360L        [fail]
#define ERROR_BAD_DESCRIPTOR_FORMAT      1361L        [fail]
#define ERROR_NOT_LOGON_PROCESS          1362L        [fail]
#define ERROR_LOGON_SESSION_EXISTS       1363L        [fail]
#define ERROR_NO_SUCH_PACKAGE            1364L        [fail]
#define ERROR_BAD_LOGON_SESSION_STATE    1365L        [fail]
#define ERROR_LOGON_SESSION_COLLISION    1366L        [fail]
#define ERROR_INVALID_LOGON_TYPE         1367L        [fail]
#define ERROR_CANNOT_IMPERSONATE         1368L        [fail]
#define ERROR_RXACT_INVALID_STATE        1369L        [fail]
#define ERROR_RXACT_COMMIT_FAILURE       1370L        [fail]
#define ERROR_SPECIAL_ACCOUNT            1371L        [fail]
#define ERROR_SPECIAL_GROUP              1372L        [fail]
#define ERROR_SPECIAL_USER               1373L        [fail]
#define ERROR_MEMBERS_PRIMARY_GROUP      1374L        [fail]
#define ERROR_TOKEN_ALREADY_IN_USE       1375L        [fail]
#define ERROR_NO_SUCH_ALIAS              1376L        [fail]
#define ERROR_MEMBER_NOT_IN_ALIAS        1377L        [fail]
#define ERROR_MEMBER_IN_ALIAS            1378L        [fail]
#define ERROR_ALIAS_EXISTS               1379L        [fail]
#define ERROR_LOGON_NOT_GRANTED          1380L        [fail]
#define ERROR_TOO_MANY_SECRETS           1381L        [fail]
#define ERROR_SECRET_TOO_LONG            1382L        [fail]
#define ERROR_INTERNAL_DB_ERROR          1383L        [fail]
#define ERROR_TOO_MANY_CONTEXT_IDS       1384L        [fail]
#define ERROR_LOGON_TYPE_NOT_GRANTED     1385L        [fail]
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386L      [fail]
#define ERROR_NO_SUCH_MEMBER             1387L        [fail]
#define ERROR_INVALID_MEMBER             1388L        [fail]
#define ERROR_TOO_MANY_SIDS              1389L        [fail]
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390L      [fail]
#define ERROR_NO_INHERITANCE             1391L        [fail]
#define ERROR_FILE_CORRUPT               1392L        [fail]
#define ERROR_DISK_CORRUPT               1393L        [fail]
#define ERROR_NO_USER_SESSION_KEY        1394L        [fail]
#define ERROR_LICENSE_QUOTA_EXCEEDED     1395L        [fail]
#define ERROR_INVALID_WINDOW_HANDLE      1400L        [fail]
#define ERROR_INVALID_MENU_HANDLE        1401L        [fail]
#define ERROR_INVALID_CURSOR_HANDLE      1402L        [fail]
#define ERROR_INVALID_ACCEL_HANDLE       1403L        [fail]
#define ERROR_INVALID_HOOK_HANDLE        1404L        [fail]
#define ERROR_INVALID_DWP_HANDLE         1405L        [fail]
#define ERROR_TLW_WITH_WSCHILD           1406L        [fail]
#define ERROR_CANNOT_FIND_WND_CLASS      1407L        [fail]
#define ERROR_WINDOW_OF_OTHER_THREAD     1408L        [fail]
#define ERROR_HOTKEY_ALREADY_REGISTERED  1409L        [fail]
#define ERROR_CLASS_ALREADY_EXISTS       1410L        [fail]
#define ERROR_CLASS_DOES_NOT_EXIST       1411L        [fail]
#define ERROR_CLASS_HAS_WINDOWS          1412L        [fail]
#define ERROR_INVALID_INDEX              1413L        [fail]
#define ERROR_INVALID_ICON_HANDLE        1414L        [fail]
#define ERROR_PRIVATE_DIALOG_INDEX       1415L        [fail]
#define ERROR_LISTBOX_ID_NOT_FOUND       1416L        [fail]
#define ERROR_NO_WILDCARD_CHARACTERS     1417L        [fail]
#define ERROR_CLIPBOARD_NOT_OPEN         1418L        [fail]
#define ERROR_HOTKEY_NOT_REGISTERED      1419L        [fail]
#define ERROR_WINDOW_NOT_DIALOG          1420L        [fail]
#define ERROR_CONTROL_ID_NOT_FOUND       1421L        [fail]
#define ERROR_INVALID_COMBOBOX_MESSAGE   1422L        [fail]
#define ERROR_WINDOW_NOT_COMBOBOX        1423L        [fail]
#define ERROR_INVALID_EDIT_HEIGHT        1424L        [fail]
#define ERROR_DC_NOT_FOUND               1425L        [fail]
#define ERROR_INVALID_HOOK_FILTER        1426L        [fail]
#define ERROR_INVALID_FILTER_PROC        1427L        [fail]
#define ERROR_HOOK_NEEDS_HMOD            1428L        [fail]
#define ERROR_GLOBAL_ONLY_HOOK           1429L        [fail]
#define ERROR_JOURNAL_HOOK_SET           1430L        [fail]
#define ERROR_HOOK_NOT_INSTALLED         1431L        [fail]
#define ERROR_INVALID_LB_MESSAGE         1432L        [fail]
#define ERROR_SETCOUNT_ON_BAD_LB         1433L        [fail]
#define ERROR_LB_WITHOUT_TABSTOPS        1434L        [fail]
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435L    [fail]
#define ERROR_CHILD_WINDOW_MENU          1436L        [fail]
#define ERROR_NO_SYSTEM_MENU             1437L        [fail]
#define ERROR_INVALID_MSGBOX_STYLE       1438L        [fail]
#define ERROR_INVALID_SPI_VALUE          1439L        [fail]
#define ERROR_SCREEN_ALREADY_LOCKED      1440L        [fail]
#define ERROR_HWNDS_HAVE_DIFF_PARENT     1441L        [fail]
#define ERROR_NOT_CHILD_WINDOW           1442L        [fail]
#define ERROR_INVALID_GW_COMMAND         1443L        [fail]
#define ERROR_INVALID_THREAD_ID          1444L        [fail]
#define ERROR_NON_MDICHILD_WINDOW        1445L        [fail]
#define ERROR_POPUP_ALREADY_ACTIVE       1446L        [fail]
#define ERROR_NO_SCROLLBARS              1447L        [fail]
#define ERROR_INVALID_SCROLLBAR_RANGE    1448L        [fail]
#define ERROR_INVALID_SHOWWIN_COMMAND    1449L        [fail]
#define ERROR_NO_SYSTEM_RESOURCES        1450L        [fail]
#define ERROR_NONPAGED_SYSTEM_RESOURCES  1451L        [fail]
#define ERROR_PAGED_SYSTEM_RESOURCES     1452L        [fail]
#define ERROR_WORKING_SET_QUOTA          1453L        [fail]
#define ERROR_PAGEFILE_QUOTA             1454L        [fail]
#define ERROR_COMMITMENT_LIMIT           1455L        [fail]
#define ERROR_MENU_ITEM_NOT_FOUND        1456L        [fail]
#define ERROR_INVALID_KEYBOARD_HANDLE    1457L        [fail]
#define ERROR_HOOK_TYPE_NOT_ALLOWED      1458L        [fail]
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459L[fail]
#define ERROR_TIMEOUT                    1460L        [fail]
#define ERROR_INVALID_MONITOR_HANDLE     1461L        [fail]
#define ERROR_EVENTLOG_FILE_CORRUPT      1500L        [fail]
#define ERROR_EVENTLOG_CANT_START        1501L        [fail]
#define ERROR_LOG_FILE_FULL              1502L        [fail]
#define ERROR_EVENTLOG_FILE_CHANGED      1503L        [fail]
#define ERROR_INSTALL_SERVICE            1601L        [fail]
#define ERROR_INSTALL_USEREXIT           1602L        [fail]
#define ERROR_INSTALL_FAILURE            1603L        [fail]
#define ERROR_INSTALL_SUSPEND            1604L        [fail]
#define ERROR_UNKNOWN_PRODUCT            1605L        [fail]
#define ERROR_UNKNOWN_FEATURE            1606L        [fail]
#define ERROR_UNKNOWN_COMPONENT          1607L        [fail]
#define ERROR_UNKNOWN_PROPERTY           1608L        [fail]
#define ERROR_INVALID_HANDLE_STATE       1609L        [fail]
#define ERROR_BAD_CONFIGURATION          1610L        [fail]
#define ERROR_INDEX_ABSENT               1611L        [fail]
#define ERROR_INSTALL_SOURCE_ABSENT      1612L        [fail]
#define ERROR_BAD_DATABASE_VERSION       1613L        [fail]
#define ERROR_PRODUCT_UNINSTALLED        1614L        [fail]
#define ERROR_BAD_QUERY_SYNTAX           1615L        [fail]
#define ERROR_INVALID_FIELD              1616L        [fail]
#define RPC_S_INVALID_STRING_BINDING     1700L        [fail]
#define RPC_S_WRONG_KIND_OF_BINDING      1701L        [fail]
#define RPC_S_INVALID_BINDING            1702L        [fail]
#define RPC_S_PROTSEQ_NOT_SUPPORTED      1703L        [fail]
#define RPC_S_INVALID_RPC_PROTSEQ        1704L        [fail]
#define RPC_S_INVALID_STRING_UUID        1705L        [fail]
#define RPC_S_INVALID_ENDPOINT_FORMAT    1706L        [fail]
#define RPC_S_INVALID_NET_ADDR           1707L        [fail]
#define RPC_S_NO_ENDPOINT_FOUND          1708L        [fail]
#define RPC_S_INVALID_TIMEOUT            1709L        [fail]
#define RPC_S_OBJECT_NOT_FOUND           1710L        [fail]
#define RPC_S_ALREADY_REGISTERED         1711L        [fail]
#define RPC_S_TYPE_ALREADY_REGISTERED    1712L        [fail]
#define RPC_S_ALREADY_LISTENING          1713L        [fail]
#define RPC_S_NO_PROTSEQS_REGISTERED     1714L        [fail]
#define RPC_S_NOT_LISTENING              1715L        [fail]
#define RPC_S_UNKNOWN_MGR_TYPE           1716L        [fail]
#define RPC_S_UNKNOWN_IF                 1717L        [fail]
#define RPC_S_NO_BINDINGS                1718L        [fail]
#define RPC_S_NO_PROTSEQS                1719L        [fail]
#define RPC_S_CANT_CREATE_ENDPOINT       1720L        [fail]
#define RPC_S_OUT_OF_RESOURCES           1721L        [fail]
#define RPC_S_SERVER_UNAVAILABLE         1722L        [fail]
#define RPC_S_SERVER_TOO_BUSY            1723L        [fail]
#define RPC_S_INVALID_NETWORK_OPTIONS    1724L        [fail]
#define RPC_S_NO_CALL_ACTIVE             1725L        [fail]
#define RPC_S_CALL_FAILED                1726L        [fail]
#define RPC_S_CALL_FAILED_DNE            1727L        [fail]
#define RPC_S_PROTOCOL_ERROR             1728L        [fail]
#define RPC_S_UNSUPPORTED_TRANS_SYN      1730L        [fail]
#define RPC_S_UNSUPPORTED_TYPE           1732L        [fail]
#define RPC_S_INVALID_TAG                1733L        [fail]
#define RPC_S_INVALID_BOUND              1734L        [fail]
#define RPC_S_NO_ENTRY_NAME              1735L        [fail]
#define RPC_S_INVALID_NAME_SYNTAX        1736L        [fail]
#define RPC_S_UNSUPPORTED_NAME_SYNTAX    1737L        [fail]
#define RPC_S_UUID_NO_ADDRESS            1739L        [fail]
#define RPC_S_DUPLICATE_ENDPOINT         1740L        [fail]
#define RPC_S_UNKNOWN_AUTHN_TYPE         1741L        [fail]
#define RPC_S_MAX_CALLS_TOO_SMALL        1742L        [fail]
#define RPC_S_STRING_TOO_LONG            1743L        [fail]
#define RPC_S_PROTSEQ_NOT_FOUND          1744L        [fail]
#define RPC_S_PROCNUM_OUT_OF_RANGE       1745L        [fail]
#define RPC_S_BINDING_HAS_NO_AUTH        1746L        [fail]
#define RPC_S_UNKNOWN_AUTHN_SERVICE      1747L        [fail]
#define RPC_S_UNKNOWN_AUTHN_LEVEL        1748L        [fail]
#define RPC_S_INVALID_AUTH_IDENTITY      1749L        [fail]
#define RPC_S_UNKNOWN_AUTHZ_SERVICE      1750L        [fail]
#define EPT_S_INVALID_ENTRY              1751L        [fail]
#define EPT_S_CANT_PERFORM_OP            1752L        [fail]
#define EPT_S_NOT_REGISTERED             1753L        [fail]
#define RPC_S_NOTHING_TO_EXPORT          1754L        [fail]
#define RPC_S_INCOMPLETE_NAME            1755L        [fail]
#define RPC_S_INVALID_VERS_OPTION        1756L        [fail]
#define RPC_S_NO_MORE_MEMBERS            1757L        [fail]
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED    1758L        [fail]
#define RPC_S_INTERFACE_NOT_FOUND        1759L        [fail]
#define RPC_S_ENTRY_ALREADY_EXISTS       1760L        [fail]
#define RPC_S_ENTRY_NOT_FOUND            1761L        [fail]
#define RPC_S_NAME_SERVICE_UNAVAILABLE   1762L        [fail]
#define RPC_S_INVALID_NAF_ID             1763L        [fail]
#define RPC_S_CANNOT_SUPPORT             1764L        [fail]
#define RPC_S_NO_CONTEXT_AVAILABLE       1765L        [fail]
#define RPC_S_INTERNAL_ERROR             1766L        [fail]
#define RPC_S_ZERO_DIVIDE                1767L        [fail]
#define RPC_S_ADDRESS_ERROR              1768L        [fail]
#define RPC_S_FP_DIV_ZERO                1769L        [fail]
#define RPC_S_FP_UNDERFLOW               1770L        [fail]
#define RPC_S_FP_OVERFLOW                1771L        [fail]
#define RPC_X_NO_MORE_ENTRIES            1772L        [fail]
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL    1773L        [fail]
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE   1774L        [fail]
#define RPC_X_SS_IN_NULL_CONTEXT         1775L        [fail]
#define RPC_X_SS_CONTEXT_DAMAGED         1777L        [fail]
#define RPC_X_SS_HANDLES_MISMATCH        1778L        [fail]
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE  1779L        [fail]
#define RPC_X_NULL_REF_POINTER           1780L        [fail]
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE    1781L        [fail]
#define RPC_X_BYTE_COUNT_TOO_SMALL       1782L        [fail]
#define RPC_X_BAD_STUB_DATA              1783L        [fail]
#define ERROR_INVALID_USER_BUFFER        1784L        [fail]
#define ERROR_UNRECOGNIZED_MEDIA         1785L        [fail]
#define ERROR_NO_TRUST_LSA_SECRET        1786L        [fail]
#define ERROR_NO_TRUST_SAM_ACCOUNT       1787L        [fail]
#define ERROR_TRUSTED_DOMAIN_FAILURE     1788L        [fail]
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789L      [fail]
#define ERROR_TRUST_FAILURE              1790L        [fail]
#define RPC_S_CALL_IN_PROGRESS           1791L        [fail]
#define ERROR_NETLOGON_NOT_STARTED       1792L        [fail]
#define ERROR_ACCOUNT_EXPIRED            1793L        [fail]
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794L       [fail]
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795L  [fail]
#define ERROR_UNKNOWN_PORT               1796L        [fail]
#define ERROR_UNKNOWN_PRINTER_DRIVER     1797L        [fail]
#define ERROR_UNKNOWN_PRINTPROCESSOR     1798L        [fail]
#define ERROR_INVALID_SEPARATOR_FILE     1799L        [fail]
#define ERROR_INVALID_PRIORITY           1800L        [fail]
#define ERROR_INVALID_PRINTER_NAME       1801L        [fail]
#define ERROR_PRINTER_ALREADY_EXISTS     1802L        [fail]
#define ERROR_INVALID_PRINTER_COMMAND    1803L        [fail]
#define ERROR_INVALID_DATATYPE           1804L        [fail]
#define ERROR_INVALID_ENVIRONMENT        1805L        [fail]
#define RPC_S_NO_MORE_BINDINGS           1806L        [fail]
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807L [fail]
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808L [fail]
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809L      [fail]
#define ERROR_DOMAIN_TRUST_INCONSISTENT  1810L        [fail]
#define ERROR_SERVER_HAS_OPEN_HANDLES    1811L        [fail]
#define ERROR_RESOURCE_DATA_NOT_FOUND    1812L        [fail]
#define ERROR_RESOURCE_TYPE_NOT_FOUND    1813L        [fail]
#define ERROR_RESOURCE_NAME_NOT_FOUND    1814L        [fail]
#define ERROR_RESOURCE_LANG_NOT_FOUND    1815L        [fail]
#define ERROR_NOT_ENOUGH_QUOTA           1816L        [fail]
#define RPC_S_NO_INTERFACES              1817L        [fail]
#define RPC_S_CALL_CANCELLED             1818L        [fail]
#define RPC_S_BINDING_INCOMPLETE         1819L        [fail]
#define RPC_S_COMM_FAILURE               1820L        [fail]
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL    1821L        [fail]
#define RPC_S_NO_PRINC_NAME              1822L        [fail]
#define RPC_S_NOT_RPC_ERROR              1823L        [fail]
#define RPC_S_UUID_LOCAL_ONLY            1824L        [fail]
#define RPC_S_SEC_PKG_ERROR              1825L        [fail]
#define RPC_S_NOT_CANCELLED              1826L        [fail]
#define RPC_X_INVALID_ES_ACTION          1827L        [fail]
#define RPC_X_WRONG_ES_VERSION           1828L        [fail]
#define RPC_X_WRONG_STUB_VERSION         1829L        [fail]
#define RPC_X_INVALID_PIPE_OBJECT        1830L        [fail]
#define RPC_X_WRONG_PIPE_ORDER           1831L        [fail]
#define RPC_X_WRONG_PIPE_VERSION         1832L        [fail]
#define RPC_S_GROUP_MEMBER_NOT_FOUND     1898L        [fail]
#define EPT_S_CANT_CREATE                1899L        [fail]
#define RPC_S_INVALID_OBJECT             1900L        [fail]
#define ERROR_INVALID_TIME               1901L        [fail]
#define ERROR_INVALID_FORM_NAME          1902L        [fail]
#define ERROR_INVALID_FORM_SIZE          1903L        [fail]
#define ERROR_ALREADY_WAITING            1904L        [fail]
#define ERROR_PRINTER_DELETED            1905L        [fail]
#define ERROR_INVALID_PRINTER_STATE      1906L        [fail]
#define ERROR_PASSWORD_MUST_CHANGE       1907L        [fail]
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908L       [fail]
#define ERROR_ACCOUNT_LOCKED_OUT         1909L        [fail]
#define OR_INVALID_OXID                  1910L        [fail]
#define OR_INVALID_OID                   1911L        [fail]
#define OR_INVALID_SET                   1912L        [fail]
#define RPC_S_SEND_INCOMPLETE            1913L        [fail]
#define RPC_S_INVALID_ASYNC_HANDLE       1914L        [fail]
#define RPC_S_INVALID_ASYNC_CALL         1915L        [fail]
#define RPC_X_PIPE_CLOSED                1916L        [fail]
#define RPC_X_PIPE_DISCIPLINE_ERROR      1917L        [fail]
#define RPC_X_PIPE_EMPTY                 1918L        [fail]
#define ERROR_NO_SITENAME                1919L        [fail]
#define ERROR_CANT_ACCESS_FILE           1920L        [fail]
#define ERROR_CANT_RESOLVE_FILENAME      1921L        [fail]
#define ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY 1922L   [fail]
#define ERROR_DS_NO_ATTRIBUTE_OR_VALUE   1923L        [fail]
#define ERROR_DS_INVALID_ATTRIBUTE_SYNTAX 1924L       [fail]
#define ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED 1925L       [fail]
#define ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS 1926L      [fail]
#define ERROR_DS_BUSY                    1927L        [fail]
#define ERROR_DS_UNAVAILABLE             1928L        [fail]
#define ERROR_DS_NO_RIDS_ALLOCATED       1929L        [fail]
#define ERROR_DS_NO_MORE_RIDS            1930L        [fail]
#define ERROR_DS_INCORRECT_ROLE_OWNER    1931L        [fail]
#define ERROR_DS_RIDMGR_INIT_ERROR       1932L        [fail]
#define ERROR_DS_OBJ_CLASS_VIOLATION     1933L        [fail]
#define ERROR_DS_CANT_ON_NON_LEAF        1934L        [fail]
#define ERROR_DS_CANT_ON_RDN             1935L        [fail]
#define ERROR_DS_CANT_MOD_OBJ_CLASS      1936L        [fail]
#define ERROR_DS_CROSS_DOM_MOVE_ERROR    1937L        [fail]
#define ERROR_DS_GC_NOT_AVAILABLE        1938L        [fail]
#define ERROR_NO_BROWSER_SERVERS_FOUND   6118L        [fail]
#define ERROR_INVALID_PIXEL_FORMAT       2000L        [fail]
#define ERROR_BAD_DRIVER                 2001L        [fail]
#define ERROR_INVALID_WINDOW_STYLE       2002L        [fail]        
#define ERROR_METAFILE_NOT_SUPPORTED     2003L        [fail]
#define ERROR_TRANSFORM_NOT_SUPPORTED    2004L        [fail]                  
#define ERROR_CLIPPING_NOT_SUPPORTED     2005L        [fail]

// End of OpenGL error codes                                                  


///////////////////////////////////////////           
//                                       //           
//   Image Color Management Error Code   //           
//                                       //           
///////////////////////////////////////////           


#define ERROR_INVALID_CMM                2300L               [fail]
#define ERROR_INVALID_PROFILE            2301L               [fail]
#define ERROR_TAG_NOT_FOUND              2302L               [fail]
#define ERROR_TAG_NOT_PRESENT            2303L               [fail]
#define ERROR_DUPLICATE_TAG              2304L               [fail]
#define ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE 2305L       [fail]
#define ERROR_PROFILE_NOT_FOUND          2306L               [fail]
#define ERROR_INVALID_COLORSPACE         2307L               [fail]
#define ERROR_ICM_NOT_ENABLED            2308L               [fail]
#define ERROR_DELETING_ICM_XFORM         2309L               [fail]
#define ERROR_INVALID_TRANSFORM          2310L               [fail]


////////////////////////////////////
//                                //
//     Win32 Spooler Error Codes  //
//                                //
////////////////////////////////////


#define ERROR_UNKNOWN_PRINT_MONITOR      3000L               [fail]
#define ERROR_PRINTER_DRIVER_IN_USE      3001L               [fail]
#define ERROR_SPOOL_FILE_NOT_FOUND       3002L               [fail]
#define ERROR_SPL_NO_STARTDOC            3003L               [fail]
#define ERROR_SPL_NO_ADDJOB              3004L               [fail]
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005L        [fail]
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006L          [fail]
#define ERROR_INVALID_PRINT_MONITOR      3007L               [fail]
#define ERROR_PRINT_MONITOR_IN_USE       3008L               [fail]
#define ERROR_PRINTER_HAS_JOBS_QUEUED    3009L               [fail]
#define ERROR_SUCCESS_REBOOT_REQUIRED    3010L               [fail]
#define ERROR_SUCCESS_RESTART_REQUIRED   3011L               [fail]

////////////////////////////////////
//                                //
//     Wins Error Codes           //
//                                //
////////////////////////////////////

#define ERROR_WINS_INTERNAL              4000L               [fail]
#define ERROR_CAN_NOT_DEL_LOCAL_WINS     4001L               [fail]
#define ERROR_STATIC_INIT                4002L               [fail]
#define ERROR_INC_BACKUP                 4003L               [fail]
#define ERROR_FULL_BACKUP                4004L               [fail]
#define ERROR_REC_NON_EXISTENT           4005L               [fail]
#define ERROR_RPL_NOT_ALLOWED            4006L               [fail]


////////////////////////////////////
//                                //
//     DHCP Error Codes           //
//                                //
////////////////////////////////////


#define ERROR_DHCP_ADDRESS_CONFLICT      4100L               [fail]


////////////////////////////////////                         
//                                //                         
//     WMI Error Codes            //                         
//                                //                         
////////////////////////////////////                         

#define ERROR_WMI_GUID_NOT_FOUND         4200L               [fail]
#define ERROR_WMI_INSTANCE_NOT_FOUND     4201L               [fail]
#define ERROR_WMI_ITEMID_NOT_FOUND       4202L               [fail]
#define ERROR_WMI_TRY_AGAIN              4203L               [fail]
#define ERROR_WMI_DP_NOT_FOUND           4204L               [fail]
#define ERROR_WMI_UNRESOLVED_INSTANCE_REF 4205L              [fail]
#define ERROR_WMI_ALREADY_ENABLED        4206L               [fail]
#define ERROR_WMI_GUID_DISCONNECTED      4207L               [fail]
#define ERROR_WMI_SERVER_UNAVAILABLE     4208L               [fail]
#define ERROR_WMI_DP_FAILED              4209L               [fail]
#define ERROR_WMI_INVALID_MOF            4210L               [fail]
#define ERROR_WMI_INVALID_REGINFO        4211L               [fail]

////////////////////////////////////
//                                //
// NT Media Services Error Codes  //
//                                //
////////////////////////////////////


#define ERROR_INVALID_MEDIA              4300L               [fail]
#define ERROR_INVALID_LIBRARY            4301L               [fail]
#define ERROR_INVALID_MEDIA_POOL         4302L               [fail]
#define ERROR_DRIVE_MEDIA_MISMATCH       4303L               [fail]
#define ERROR_MEDIA_OFFLINE              4304L               [fail]
#define ERROR_LIBRARY_OFFLINE            4305L               [fail]
#define ERROR_EMPTY                      4306L               [fail]
#define ERROR_NOT_EMPTY                  4307L               [fail]
#define ERROR_MEDIA_UNAVAILABLE          4308L               [fail]
#define ERROR_RESOURCE_DISABLED          4309L               [fail]
#define ERROR_INVALID_CLEANER            4310L               [fail]
#define ERROR_UNABLE_TO_CLEAN            4311L               [fail]
#define ERROR_OBJECT_NOT_FOUND           4312L               [fail]
#define ERROR_DATABASE_FAILURE           4313L               [fail]
#define ERROR_DATABASE_FULL              4314L               [fail]
#define ERROR_MEDIA_INCOMPATIBLE         4315L               [fail]
#define ERROR_RESOURCE_NOT_PRESENT       4316L               [fail]
#define ERROR_INVALID_OPERATION          4317L               [fail]
#define ERROR_MEDIA_NOT_AVAILABLE        4318L               [fail]
#define ERROR_DEVICE_NOT_AVAILABLE       4319L               [fail]
#define ERROR_REQUEST_REFUSED            4320L               [fail]

////////////////////////////////////////////                 
//                                        //                 
// NT Remote Storage Service Error Codes  //
//                                        //
////////////////////////////////////////////


#define ERROR_FILE_OFFLINE               4350L               [fail]
#define ERROR_REMOTE_STORAGE_NOT_ACTIVE  4351L               [fail]
#define ERROR_REMOTE_STORAGE_MEDIA_ERROR 4352L               [fail]

////////////////////////////////////////////                 
//                                        //                 
// NT Reparse Points Error Codes          //                 
//                                        //                 
////////////////////////////////////////////                 


#define ERROR_NOT_A_REPARSE_POINT        4390L               [fail]
#define ERROR_REPARSE_ATTRIBUTE_CONFLICT 4391L               [fail]

////////////////////////////////////                         
//                                //                         
//     Cluster Error Codes        //                         
//                                //                         
////////////////////////////////////                         


#define ERROR_DEPENDENT_RESOURCE_EXISTS  5001L               [fail]
#define ERROR_DEPENDENCY_NOT_FOUND       5002L               [fail]
#define ERROR_DEPENDENCY_ALREADY_EXISTS  5003L               [fail]
#define ERROR_RESOURCE_NOT_ONLINE        5004L               [fail]
#define ERROR_HOST_NODE_NOT_AVAILABLE    5005L               [fail]
#define ERROR_RESOURCE_NOT_AVAILABLE     5006L               [fail]
#define ERROR_RESOURCE_NOT_FOUND         5007L               [fail]
#define ERROR_SHUTDOWN_CLUSTER           5008L               [fail]
#define ERROR_CANT_EVICT_ACTIVE_NODE     5009L               [fail]
#define ERROR_OBJECT_ALREADY_EXISTS      5010L               [fail]
#define ERROR_OBJECT_IN_LIST             5011L               [fail]
#define ERROR_GROUP_NOT_AVAILABLE        5012L               [fail]
#define ERROR_GROUP_NOT_FOUND            5013L               [fail]
#define ERROR_GROUP_NOT_ONLINE           5014L               [fail]
#define ERROR_HOST_NODE_NOT_RESOURCE_OWNER 5015L             [fail]
#define ERROR_HOST_NODE_NOT_GROUP_OWNER  5016L               [fail]
#define ERROR_RESMON_CREATE_FAILED       5017L               [fail]
#define ERROR_RESMON_ONLINE_FAILED       5018L               [fail]
#define ERROR_RESOURCE_ONLINE            5019L               [fail]
#define ERROR_QUORUM_RESOURCE            5020L               [fail]
#define ERROR_NOT_QUORUM_CAPABLE         5021L               [fail]
#define ERROR_CLUSTER_SHUTTING_DOWN      5022L               [fail]
#define ERROR_INVALID_STATE              5023L               [fail]
#define ERROR_RESOURCE_PROPERTIES_STORED 5024L               [fail]
#define ERROR_NOT_QUORUM_CLASS           5025L               [fail]
#define ERROR_CORE_RESOURCE              5026L               [fail]
#define ERROR_QUORUM_RESOURCE_ONLINE_FAILED 5027L            [fail]
#define ERROR_QUORUMLOG_OPEN_FAILED      5028L               [fail]
#define ERROR_CLUSTERLOG_CORRUPT         5029L               [fail]
#define ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE 5030L        [fail]
#define ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE 5031L               [fail]
#define ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND 5032L            [fail]
#define ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE 5033L              [fail]

////////////////////////////////////
//                                //
//     EFS Error Codes            //
//                                //
////////////////////////////////////


#define ERROR_ENCRYPTION_FAILED          6000L               [fail]
#define ERROR_DECRYPTION_FAILED          6001L               [fail]
#define ERROR_FILE_ENCRYPTED             6002L               [fail]
#define ERROR_NO_RECOVERY_POLICY         6003L               [fail]
#define ERROR_NO_EFS                     6004L               [fail]
#define ERROR_WRONG_EFS                  6005L               [fail]
#define ERROR_NO_USER_KEYS               6006L               [fail]
#define ERROR_FILE_NOT_ENCRYPTED         6007L               [fail]
#define ERROR_NOT_EXPORT_FORMAT          6008L               [fail]
};                                                           


value DWORD HRESULT
{
//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
//  Catastrophic failure
//
#define E_UNEXPECTED                     0x8000FFFFL           [fail]

//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        0x80004001L           [fail]

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    0x8007000EL           [fail]

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     0x80070057L           [fail]

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    0x80004002L           [fail]

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        0x80004003L           [fail]

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         0x80070006L           [fail]

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          0x80004004L           [fail]

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           0x80004005L           [fail]

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   0x80070005L           [fail]

//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        0x80000001L           [fail]

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    0x80000002L           [fail]

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     0x80000003L           [fail]

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    0x80000004L           [fail]

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        0x80000005L           [fail]

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         0x80000006L           [fail]

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          0x80000007L           [fail]

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           0x80000008L           [fail]

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   0x80000009L           [fail]

//
// MessageId: E_PENDING
//
// MessageText:
//
//  The data necessary to complete this operation is not yet available.
//
#define E_PENDING                        0x8000000AL           [fail]

//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
//  Thread local storage failure
//
#define CO_E_INIT_TLS                    0x80004006L           [fail]

//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
//  Get shared memory allocator failure
//
#define CO_E_INIT_SHARED_ALLOCATOR       0x80004007L           [fail]

//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
//  Get memory allocator failure
//
#define CO_E_INIT_MEMORY_ALLOCATOR       0x80004008L           [fail]

//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
//  Unable to initialize class cache
//
#define CO_E_INIT_CLASS_CACHE            0x80004009L           [fail]

//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
//  Unable to initialize RPC services
//
#define CO_E_INIT_RPC_CHANNEL            0x8000400AL           [fail]

//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
//  Cannot set thread local storage channel control
//
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL 0x8000400BL           [fail]

//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
//  Could not allocate thread local storage channel control
//
#define CO_E_INIT_TLS_CHANNEL_CONTROL    0x8000400CL           [fail]

//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
//  The user supplied memory allocator is unacceptable
//
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR 0x8000400DL           [fail]

//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
//  The OLE service mutex already exists
//
#define CO_E_INIT_SCM_MUTEX_EXISTS       0x8000400EL           [fail]

//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
//  The OLE service file mapping already exists
//
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS 0x8000400FL           [fail]

//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
//  Unable to map view of file for OLE service
//
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE   0x80004010L           [fail]

//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
//  Failure attempting to launch OLE service
//
#define CO_E_INIT_SCM_EXEC_FAILURE       0x80004011L           [fail]

//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
//  There was an attempt to call CoInitialize a second time while single threaded
//
#define CO_E_INIT_ONLY_SINGLE_THREADED   0x80004012L           [fail]

//
// MessageId: CO_E_CANT_REMOTE
//
// MessageText:
//
//  A Remote activation was necessary but was not allowed
//
#define CO_E_CANT_REMOTE                 0x80004013L           [fail]

//
// MessageId: CO_E_BAD_SERVER_NAME
//
// MessageText:
//
//  A Remote activation was necessary but the server name provided was invalid
//
#define CO_E_BAD_SERVER_NAME             0x80004014L           [fail]

//
// MessageId: CO_E_WRONG_SERVER_IDENTITY
//
// MessageText:
//
//  The class is configured to run as a security id different from the caller
//
#define CO_E_WRONG_SERVER_IDENTITY       0x80004015L           [fail]

//
// MessageId: CO_E_OLE1DDE_DISABLED
//
// MessageText:
//
//  Use of Ole1 services requiring DDE windows is disabled
//
#define CO_E_OLE1DDE_DISABLED            0x80004016L           [fail]

//
// MessageId: CO_E_RUNAS_SYNTAX
//
// MessageText:
//
//  A RunAs specification must be <domain name>\<user name> or simply <user name>
//
#define CO_E_RUNAS_SYNTAX                0x80004017L           [fail]

//
// MessageId: CO_E_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  The server process could not be started.  The pathname may be incorrect.
//
#define CO_E_CREATEPROCESS_FAILURE       0x80004018L           [fail]

//
// MessageId: CO_E_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  The server process could not be started as the configured identity.  The pathname may be incorrect or unavailable.
//
#define CO_E_RUNAS_CREATEPROCESS_FAILURE 0x80004019L           [fail]

//
// MessageId: CO_E_RUNAS_LOGON_FAILURE
//
// MessageText:
//
//  The server process could not be started because the configured identity is incorrect.  Check the username and password.
//
#define CO_E_RUNAS_LOGON_FAILURE         0x8000401AL           [fail]

//
// MessageId: CO_E_LAUNCH_PERMSSION_DENIED
//
// MessageText:
//
//  The client is not allowed to launch this server.
//
#define CO_E_LAUNCH_PERMSSION_DENIED     0x8000401BL           [fail]

//
// MessageId: CO_E_START_SERVICE_FAILURE
//
// MessageText:
//
//  The service providing this server could not be started.
//
#define CO_E_START_SERVICE_FAILURE       0x8000401CL           [fail]

//
// MessageId: CO_E_REMOTE_COMMUNICATION_FAILURE
//
// MessageText:
//
//  This computer was unable to communicate with the computer providing the server.
//
#define CO_E_REMOTE_COMMUNICATION_FAILURE 0x8000401DL           [fail]

//
// MessageId: CO_E_SERVER_START_TIMEOUT
//
// MessageText:
//
//  The server did not respond after being launched.
//
#define CO_E_SERVER_START_TIMEOUT        0x8000401EL           [fail]

//
// MessageId: CO_E_CLSREG_INCONSISTENT
//
// MessageText:
//
//  The registration information for this server is inconsistent or incomplete.
//
#define CO_E_CLSREG_INCONSISTENT         0x8000401FL           [fail]

//
// MessageId: CO_E_IIDREG_INCONSISTENT
//
// MessageText:
//
//  The registration information for this interface is inconsistent or incomplete.
//
#define CO_E_IIDREG_INCONSISTENT         0x80004020L           [fail]

//
// MessageId: CO_E_NOT_SUPPORTED
//
// MessageText:
//
//  The operation attempted is not supported.
//
#define CO_E_NOT_SUPPORTED               0x80004021L           [fail]

//
// MessageId: CO_E_RELOAD_DLL
//
// MessageText:
//
//  A dll must be loaded.
//
#define CO_E_RELOAD_DLL                  0x80004022L           [fail]

//
// MessageId: CO_E_MSI_ERROR
//
// MessageText:
//
//  A Microsoft Software Installer error was encountered.
//
#define CO_E_MSI_ERROR                   0x80004023L           [fail]


//
// Success codes
//
#define S_OK                                   0x00000000L       
#define S_FALSE                                0x00000001L       

// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many inerfaces
//

#define OLE_E_FIRST 0x80040000L   
#define OLE_E_LAST  0x800400FFL   
#define OLE_S_FIRST 0x00040000L   
#define OLE_S_LAST  0x000400FFL   

//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
//  Invalid OLEVERB structure
//
#define OLE_E_OLEVERB                    0x80040000L           [fail]

//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
//  Invalid advise flags
//
#define OLE_E_ADVF                       0x80040001L           [fail]

//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
//  Can't enumerate any more, because the associated data is missing
//
#define OLE_E_ENUM_NOMORE                0x80040002L           [fail]

//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
//  This implementation doesn't take advises
//
#define OLE_E_ADVISENOTSUPPORTED         0x80040003L           [fail]

//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection for this connection ID
//
#define OLE_E_NOCONNECTION               0x80040004L           [fail]

//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
//  Need to run the object to perform this operation
//
#define OLE_E_NOTRUNNING                 0x80040005L           [fail]

//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
//  There is no cache to operate on
//
#define OLE_E_NOCACHE                    0x80040006L           [fail]

//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
//  Uninitialized object
//
#define OLE_E_BLANK                      0x80040007L           [fail]

//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
//  Linked object's source class has changed
//
#define OLE_E_CLASSDIFF                  0x80040008L           [fail]

//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
//  Not able to get the moniker of the object
//
#define OLE_E_CANT_GETMONIKER            0x80040009L           [fail]

//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
//  Not able to bind to the source
//
#define OLE_E_CANT_BINDTOSOURCE          0x8004000AL           [fail]

//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
//  Object is static; operation not allowed
//
#define OLE_E_STATIC                     0x8004000BL           [fail]

//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
//  User canceled out of save dialog
//
#define OLE_E_PROMPTSAVECANCELLED        0x8004000CL           [fail]

//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
//  Invalid rectangle
//
#define OLE_E_INVALIDRECT                0x8004000DL           [fail]

//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
//  compobj.dll is too old for the ole2.dll initialized
//
#define OLE_E_WRONGCOMPOBJ               0x8004000EL           [fail]

//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define OLE_E_INVALIDHWND                0x8004000FL           [fail]

//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
//  Object is not in any of the inplace active states
//
#define OLE_E_NOT_INPLACEACTIVE          0x80040010L           [fail]

//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
//  Not able to convert object
//
#define OLE_E_CANTCONVERT                0x80040011L           [fail]

//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
//  Not able to perform the operation because object is not given storage yet
//  
//
#define OLE_E_NOSTORAGE                  0x80040012L           [fail]

//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
//  Invalid FORMATETC structure
//
#define DV_E_FORMATETC                   0x80040064L           [fail]

//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
//  Invalid DVTARGETDEVICE structure
//
#define DV_E_DVTARGETDEVICE              0x80040065L           [fail]

//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
//  Invalid STDGMEDIUM structure
//
#define DV_E_STGMEDIUM                   0x80040066L           [fail]

//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
//  Invalid STATDATA structure
//
#define DV_E_STATDATA                    0x80040067L           [fail]

//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
//  Invalid lindex
//
#define DV_E_LINDEX                      0x80040068L           [fail]

//
// MessageId: DV_E_TYMED
//
// MessageText:
//
//  Invalid tymed
//
#define DV_E_TYMED                       0x80040069L           [fail]

//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
//  Invalid clipboard format
//
#define DV_E_CLIPFORMAT                  0x8004006AL           [fail]

//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
//  Invalid aspect(s)
//
#define DV_E_DVASPECT                    0x8004006BL           [fail]

//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
//  tdSize parameter of the DVTARGETDEVICE structure is invalid
//
#define DV_E_DVTARGETDEVICE_SIZE         0x8004006CL           [fail]

//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
//  Object doesn't support IViewObject interface
//
#define DV_E_NOIVIEWOBJECT               0x8004006DL           [fail]

#define DRAGDROP_E_FIRST 0x80040100L
#define DRAGDROP_E_LAST  0x8004010FL
#define DRAGDROP_S_FIRST 0x00040100L
#define DRAGDROP_S_LAST  0x0004010FL
//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
//  Trying to revoke a drop target that has not been registered
//
#define DRAGDROP_E_NOTREGISTERED         0x80040100L           [fail]

//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
//  This window has already been registered as a drop target
//
#define DRAGDROP_E_ALREADYREGISTERED     0x80040101L           [fail]

//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define DRAGDROP_E_INVALIDHWND           0x80040102L           [fail]

#define CLASSFACTORY_E_FIRST  0x80040110L
#define CLASSFACTORY_E_LAST   0x8004011FL
#define CLASSFACTORY_S_FIRST  0x00040110L
#define CLASSFACTORY_S_LAST   0x0004011FL
//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
//  Class does not support aggregation (or class object is remote)
//
#define CLASS_E_NOAGGREGATION            0x80040110L           [fail]

//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
//  ClassFactory cannot supply requested class
//
#define CLASS_E_CLASSNOTAVAILABLE        0x80040111L           [fail]

//
// MessageId: CLASS_E_NOTLICENSED
//
// MessageText:
//
//  Class is not licensed for use
//
#define CLASS_E_NOTLICENSED              0x80040112L           [fail]

#define MARSHAL_E_FIRST  0x80040120L
#define MARSHAL_E_LAST   0x8004012FL
#define MARSHAL_S_FIRST  0x00040120L
#define MARSHAL_S_LAST   0x0004012FL
#define DATA_E_FIRST     0x80040130L
#define DATA_E_LAST      0x8004013FL
#define DATA_S_FIRST     0x00040130L
#define DATA_S_LAST      0x0004013FL
#define VIEW_E_FIRST     0x80040140L
#define VIEW_E_LAST      0x8004014FL
#define VIEW_S_FIRST     0x00040140L
#define VIEW_S_LAST      0x0004014FL
//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
//  Error drawing view
//
#define VIEW_E_DRAW                      0x80040140L           [fail]

#define REGDB_E_FIRST     0x80040150L
#define REGDB_E_LAST      0x8004015FL
#define REGDB_S_FIRST     0x00040150L
#define REGDB_S_LAST      0x0004015FL
//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
//  Could not read key from registry
//
#define REGDB_E_READREGDB                0x80040150L           [fail]

//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
//  Could not write key to registry
//
#define REGDB_E_WRITEREGDB               0x80040151L           [fail]

//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
//  Could not find the key in the registry
//
#define REGDB_E_KEYMISSING               0x80040152L           [fail]

//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
//  Invalid value for registry
//
#define REGDB_E_INVALIDVALUE             0x80040153L           [fail]

//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
//  Class not registered
//
#define REGDB_E_CLASSNOTREG              0x80040154L           [fail]

//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
//  Interface not registered
//
#define REGDB_E_IIDNOTREG                0x80040155L           [fail]

#define CAT_E_FIRST     0x80040160L
#define CAT_E_LAST      0x80040161L
//
// MessageId: CAT_E_CATIDNOEXIST
//
// MessageText:
//
//  CATID does not exist
//
#define CAT_E_CATIDNOEXIST               0x80040160L           [fail]

//
// MessageId: CAT_E_NODESCRIPTION
//
// MessageText:
//
//  Description not found
//
#define CAT_E_NODESCRIPTION              0x80040161L           [fail]

////////////////////////////////////
//                                //
//     Class Store Error Codes    //
//                                //
////////////////////////////////////
#define CS_E_FIRST     0x80040164L
#define CS_E_LAST      0x80040168L
//
// MessageId: CS_E_PACKAGE_NOTFOUND
//
// MessageText:
//
//  No package in Class Store meets this criteria
//
#define CS_E_PACKAGE_NOTFOUND            0x80040164L           [fail]

//
// MessageId: CS_E_NOT_DELETABLE
//
// MessageText:
//
//  Deleting this will break referential integrity
//
#define CS_E_NOT_DELETABLE               0x80040165L           [fail]

//
// MessageId: CS_E_CLASS_NOTFOUND
//
// MessageText:
//
//  No such CLSID in Class Store
//
#define CS_E_CLASS_NOTFOUND              0x80040166L           [fail]

//
// MessageId: CS_E_INVALID_VERSION
//
// MessageText:
//
//  The Class Store is corrupted or has a version that is no more supported
//
#define CS_E_INVALID_VERSION             0x80040167L           [fail]

//
// MessageId: CS_E_NO_CLASSSTORE
//
// MessageText:
//
//  No such Class Store
//
#define CS_E_NO_CLASSSTORE               0x80040168L           [fail]

#define CACHE_E_FIRST     0x80040170L
#define CACHE_E_LAST      0x8004017FL
#define CACHE_S_FIRST     0x00040170L
#define CACHE_S_LAST      0x0004017FL
//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
//  Cache not updated
//
#define CACHE_E_NOCACHE_UPDATED          0x80040170L           [fail]

#define OLEOBJ_E_FIRST     0x80040180L
#define OLEOBJ_E_LAST      0x8004018FL
#define OLEOBJ_S_FIRST     0x00040180L
#define OLEOBJ_S_LAST      0x0004018FL
//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
//  No verbs for OLE object
//
#define OLEOBJ_E_NOVERBS                 0x80040180L           [fail]

//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_E_INVALIDVERB             0x80040181L           [fail]

#define CLIENTSITE_E_FIRST     0x80040190L
#define CLIENTSITE_E_LAST      0x8004019FL
#define CLIENTSITE_S_FIRST     0x00040190L
#define CLIENTSITE_S_LAST      0x0004019FL
//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
//  Undo is not available
//
#define INPLACE_E_NOTUNDOABLE            0x800401A0L           [fail]

//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
//  Space for tools is not available
//
#define INPLACE_E_NOTOOLSPACE            0x800401A1L           [fail]

#define INPLACE_E_FIRST     0x800401A0L
#define INPLACE_E_LAST      0x800401AFL
#define INPLACE_S_FIRST     0x000401A0L
#define INPLACE_S_LAST      0x000401AFL
#define ENUM_E_FIRST        0x800401B0L
#define ENUM_E_LAST         0x800401BFL
#define ENUM_S_FIRST        0x000401B0L
#define ENUM_S_LAST         0x000401BFL
#define CONVERT10_E_FIRST        0x800401C0L
#define CONVERT10_E_LAST         0x800401CFL
#define CONVERT10_S_FIRST        0x000401C0L
#define CONVERT10_S_LAST         0x000401CFL
//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
//  OLESTREAM Get method failed
//
#define CONVERT10_E_OLESTREAM_GET        0x800401C0L           [fail]

//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
//  OLESTREAM Put method failed
//
#define CONVERT10_E_OLESTREAM_PUT        0x800401C1L           [fail]

//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
//  Contents of the OLESTREAM not in correct format
//
#define CONVERT10_E_OLESTREAM_FMT        0x800401C2L           [fail]

//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the bitmap to a DIB
//
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB 0x800401C3L           [fail]

//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
//  Contents of the IStorage not in correct format
//
#define CONVERT10_E_STG_FMT              0x800401C4L           [fail]

//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
//  Contents of IStorage is missing one of the standard streams
//
#define CONVERT10_E_STG_NO_STD_STREAM    0x800401C5L           [fail]

//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the DIB to a bitmap.
//  
//
#define CONVERT10_E_STG_DIB_TO_BITMAP    0x800401C6L           [fail]

#define CLIPBRD_E_FIRST        0x800401D0L
#define CLIPBRD_E_LAST         0x800401DFL
#define CLIPBRD_S_FIRST        0x000401D0L
#define CLIPBRD_S_LAST         0x000401DFL
//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
//  OpenClipboard Failed
//
#define CLIPBRD_E_CANT_OPEN              0x800401D0L           [fail]

//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
//  EmptyClipboard Failed
//
#define CLIPBRD_E_CANT_EMPTY             0x800401D1L           [fail]

//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
//  SetClipboard Failed
//
#define CLIPBRD_E_CANT_SET               0x800401D2L           [fail]

//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
//  Data on clipboard is invalid
//
#define CLIPBRD_E_BAD_DATA               0x800401D3L           [fail]

//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
//  CloseClipboard Failed
//
#define CLIPBRD_E_CANT_CLOSE             0x800401D4L           [fail]

#define MK_E_FIRST        0x800401E0L
#define MK_E_LAST         0x800401EFL
#define MK_S_FIRST        0x000401E0L
#define MK_S_LAST         0x000401EFL
//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
//  Moniker needs to be connected manually
//
#define MK_E_CONNECTMANUALLY             0x800401E0L           [fail]

//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
//  Operation exceeded deadline
//
#define MK_E_EXCEEDEDDEADLINE            0x800401E1L           [fail]

//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
//  Moniker needs to be generic
//
#define MK_E_NEEDGENERIC                 0x800401E2L           [fail]

//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
//  Operation unavailable
//
#define MK_E_UNAVAILABLE                 0x800401E3L           [fail]

//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
//  Invalid syntax
//
#define MK_E_SYNTAX                      0x800401E4L           [fail]

//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
//  No object for moniker
//
#define MK_E_NOOBJECT                    0x800401E5L           [fail]

//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
//  Bad extension for file
//
#define MK_E_INVALIDEXTENSION            0x800401E6L           [fail]

//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
//  Intermediate operation failed
//
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED 0x800401E7L           [fail]

//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
//  Moniker is not bindable
//
#define MK_E_NOTBINDABLE                 0x800401E8L           [fail]

//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
//  Moniker is not bound
//
#define MK_E_NOTBOUND                    0x800401E9L           [fail]

//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
//  Moniker cannot open file
//
#define MK_E_CANTOPENFILE                0x800401EAL           [fail]

//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
//  User input required for operation to succeed
//
#define MK_E_MUSTBOTHERUSER              0x800401EBL           [fail]

//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
//  Moniker class has no inverse
//
#define MK_E_NOINVERSE                   0x800401ECL           [fail]

//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
//  Moniker does not refer to storage
//
#define MK_E_NOSTORAGE                   0x800401EDL           [fail]

//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
//  No common prefix
//
#define MK_E_NOPREFIX                    0x800401EEL           [fail]

//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
//  Moniker could not be enumerated
//
#define MK_E_ENUMERATION_FAILED          0x800401EFL           [fail]

#define CO_E_FIRST        0x800401F0L
#define CO_E_LAST         0x800401FFL
#define CO_S_FIRST        0x000401F0L
#define CO_S_LAST         0x000401FFL
//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
//  CoInitialize has not been called.
//
#define CO_E_NOTINITIALIZED              0x800401F0L           [fail]

//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
//  CoInitialize has already been called.
//
#define CO_E_ALREADYINITIALIZED          0x800401F1L           [fail]

//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
//  Class of object cannot be determined
//
#define CO_E_CANTDETERMINECLASS          0x800401F2L           [fail]

//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
//  Invalid class string
//
#define CO_E_CLASSSTRING                 0x800401F3L           [fail]

//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
//  Invalid interface string
//
#define CO_E_IIDSTRING                   0x800401F4L           [fail]

//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
//  Application not found
//
#define CO_E_APPNOTFOUND                 0x800401F5L           [fail]

//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
//  Application cannot be run more than once
//
#define CO_E_APPSINGLEUSE                0x800401F6L           [fail]

//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
//  Some error in application program
//
#define CO_E_ERRORINAPP                  0x800401F7L           [fail]

//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
//  DLL for class not found
//
#define CO_E_DLLNOTFOUND                 0x800401F8L           [fail]

//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
//  Error in the DLL
//
#define CO_E_ERRORINDLL                  0x800401F9L           [fail]

//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
//  Wrong OS or OS version for application
//
#define CO_E_WRONGOSFORAPP               0x800401FAL           [fail]

//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
//  Object is not registered
//
#define CO_E_OBJNOTREG                   0x800401FBL           [fail]

//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
//  Object is already registered
//
#define CO_E_OBJISREG                    0x800401FCL           [fail]

//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
//  Object is not connected to server
//
#define CO_E_OBJNOTCONNECTED             0x800401FDL           [fail]

//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
//  Application was launched but it didn't register a class factory
//
#define CO_E_APPDIDNTREG                 0x800401FEL           [fail]

//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
//  Object has been released
//
#define CO_E_RELEASED                    0x800401FFL           [fail]

//
// MessageId: CO_E_FAILEDTOIMPERSONATE
//
// MessageText:
//
//  Unable to impersonate DCOM client
//
#define CO_E_FAILEDTOIMPERSONATE         0x80040200L           [fail]

//
// MessageId: CO_E_FAILEDTOGETSECCTX
//
// MessageText:
//
//  Unable to obtain server's security context
//
#define CO_E_FAILEDTOGETSECCTX           0x80040201L           [fail]

//
// MessageId: CO_E_FAILEDTOOPENTHREADTOKEN
//
// MessageText:
//
//  Unable to open the access token of the current thread
//
#define CO_E_FAILEDTOOPENTHREADTOKEN     0x80040202L           [fail]

//
// MessageId: CO_E_FAILEDTOGETTOKENINFO
//
// MessageText:
//
//  Unable to obtain user info from an access token
//
#define CO_E_FAILEDTOGETTOKENINFO        0x80040203L           [fail]

//
// MessageId: CO_E_TRUSTEEDOESNTMATCHCLIENT
//
// MessageText:
//
//  The client who called IAccessControl::IsAccessPermitted was the trustee provided tot he method
//
#define CO_E_TRUSTEEDOESNTMATCHCLIENT    0x80040204L           [fail]

//
// MessageId: CO_E_FAILEDTOQUERYCLIENTBLANKET
//
// MessageText:
//
//  Unable to obtain the client's security blanket
//
#define CO_E_FAILEDTOQUERYCLIENTBLANKET  0x80040205L           [fail]

//
// MessageId: CO_E_FAILEDTOSETDACL
//
// MessageText:
//
//  Unable to set a discretionary ACL into a security descriptor
//
#define CO_E_FAILEDTOSETDACL             0x80040206L           [fail]

//
// MessageId: CO_E_ACCESSCHECKFAILED
//
// MessageText:
//
//  The system function, AccessCheck, returned false
//
#define CO_E_ACCESSCHECKFAILED           0x80040207L           [fail]

//
// MessageId: CO_E_NETACCESSAPIFAILED
//
// MessageText:
//
//  Either NetAccessDel or NetAccessAdd returned an error code.
//
#define CO_E_NETACCESSAPIFAILED          0x80040208L           [fail]

//
// MessageId: CO_E_WRONGTRUSTEENAMESYNTAX
//
// MessageText:
//
//  One of the trustee strings provided by the user did not conform to the <Domain>\<Name> syntax and it was not the "*" string
//
#define CO_E_WRONGTRUSTEENAMESYNTAX      0x80040209L           [fail]

//
// MessageId: CO_E_INVALIDSID
//
// MessageText:
//
//  One of the security identifiers provided by the user was invalid
//
#define CO_E_INVALIDSID                  0x8004020AL           [fail]

//
// MessageId: CO_E_CONVERSIONFAILED
//
// MessageText:
//
//  Unable to convert a wide character trustee string to a multibyte trustee string
//
#define CO_E_CONVERSIONFAILED            0x8004020BL           [fail]

//
// MessageId: CO_E_NOMATCHINGSIDFOUND
//
// MessageText:
//
//  Unable to find a security identifier that corresponds to a trustee string provided by the user
//
#define CO_E_NOMATCHINGSIDFOUND          0x8004020CL           [fail]

//
// MessageId: CO_E_LOOKUPACCSIDFAILED
//
// MessageText:
//
//  The system function, LookupAccountSID, failed
//
#define CO_E_LOOKUPACCSIDFAILED          0x8004020DL           [fail]

//
// MessageId: CO_E_NOMATCHINGNAMEFOUND
//
// MessageText:
//
//  Unable to find a trustee name that corresponds to a security identifier provided by the user
//
#define CO_E_NOMATCHINGNAMEFOUND         0x8004020EL           [fail]

//
// MessageId: CO_E_LOOKUPACCNAMEFAILED
//
// MessageText:
//
//  The system function, LookupAccountName, failed
//
#define CO_E_LOOKUPACCNAMEFAILED         0x8004020FL           [fail]

//
// MessageId: CO_E_SETSERLHNDLFAILED
//
// MessageText:
//
//  Unable to set or reset a serialization handle
//
#define CO_E_SETSERLHNDLFAILED           0x80040210L           [fail]

//
// MessageId: CO_E_FAILEDTOGETWINDIR
//
// MessageText:
//
//  Unable to obtain the Windows directory
//
#define CO_E_FAILEDTOGETWINDIR           0x80040211L           [fail]

//
// MessageId: CO_E_PATHTOOLONG
//
// MessageText:
//
//  Path too long
//
#define CO_E_PATHTOOLONG                 0x80040212L           [fail]

//
// MessageId: CO_E_FAILEDTOGENUUID
//
// MessageText:
//
//  Unable to generate a uuid.
//
#define CO_E_FAILEDTOGENUUID             0x80040213L           [fail]

//
// MessageId: CO_E_FAILEDTOCREATEFILE
//
// MessageText:
//
//  Unable to create file
//
#define CO_E_FAILEDTOCREATEFILE          0x80040214L           [fail]

//
// MessageId: CO_E_FAILEDTOCLOSEHANDLE
//
// MessageText:
//
//  Unable to close a serialization handle or a file handle.
//
#define CO_E_FAILEDTOCLOSEHANDLE         0x80040215L           [fail]

//
// MessageId: CO_E_EXCEEDSYSACLLIMIT
//
// MessageText:
//
//  The number of ACEs in an ACL exceeds the system limit
//
#define CO_E_EXCEEDSYSACLLIMIT           0x80040216L           [fail]

//
// MessageId: CO_E_ACESINWRONGORDER
//
// MessageText:
//
//  Not all the DENY_ACCESS ACEs are arranged in front of the GRANT_ACCESS ACEs in the stream
//
#define CO_E_ACESINWRONGORDER            0x80040217L           [fail]

//
// MessageId: CO_E_INCOMPATIBLESTREAMVERSION
//
// MessageText:
//
//  The version of ACL format in the stream is not supported by this implementation of IAccessControl
//
#define CO_E_INCOMPATIBLESTREAMVERSION   0x80040218L           [fail]

//
// MessageId: CO_E_FAILEDTOOPENPROCESSTOKEN
//
// MessageText:
//
//  Unable to open the access token of the server process
//
#define CO_E_FAILEDTOOPENPROCESSTOKEN    0x80040219L           [fail]

//
// MessageId: CO_E_DECODEFAILED
//
// MessageText:
//
//  Unable to decode the ACL in the stream provided by the user
//
#define CO_E_DECODEFAILED                0x8004021AL           [fail]

//
// MessageId: CO_E_ACNOTINITIALIZED
//
// MessageText:
//
//  The COM IAccessControl object is not initialized
//
#define CO_E_ACNOTINITIALIZED            0x8004021BL           [fail]

//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
//  Use the registry database to provide the requested information
//
#define OLE_S_USEREG                     0x00040000L           [fail]

//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
//  Success, but static
//
#define OLE_S_STATIC                     0x00040001L           [fail]

//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
//  Macintosh clipboard format
//
#define OLE_S_MAC_CLIPFORMAT             0x00040002L           [fail]

//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
//  Successful drop took place
//
#define DRAGDROP_S_DROP                  0x00040100L           [fail]

//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
//  Drag-drop operation canceled
//
#define DRAGDROP_S_CANCEL                0x00040101L           [fail]

//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
//  Use the default cursor
//
#define DRAGDROP_S_USEDEFAULTCURSORS     0x00040102L           [fail]

//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
//  Data has same FORMATETC
//
#define DATA_S_SAMEFORMATETC             0x00040130L           [fail]

//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
//  View is already frozen
//
#define VIEW_S_ALREADY_FROZEN            0x00040140L           [fail]

//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
//  FORMATETC not supported
//
#define CACHE_S_FORMATETC_NOTSUPPORTED   0x00040170L           [fail]

//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
//  Same cache
//
#define CACHE_S_SAMECACHE                0x00040171L           [fail]

//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
//  Some cache(s) not updated
//
#define CACHE_S_SOMECACHES_NOTUPDATED    0x00040172L           [fail]

//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_S_INVALIDVERB             0x00040180L           [fail]

//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
//  Verb number is valid but verb cannot be done now
//
#define OLEOBJ_S_CANNOT_DOVERB_NOW       0x00040181L           [fail]

//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle passed
//
#define OLEOBJ_S_INVALIDHWND             0x00040182L           [fail]

//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
//  Message is too long; some of it had to be truncated before displaying
//
#define INPLACE_S_TRUNCATED              0x000401A0L           [fail]

//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
//  Unable to convert OLESTREAM to IStorage
//
#define CONVERT10_S_NO_PRESENTATION      0x000401C0L           [fail]

//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
//  Moniker reduced to itself
//
#define MK_S_REDUCED_TO_SELF             0x000401E2L           [fail]

//
// MessageId: MK_S_ME
//
// MessageText:
//
//  Common prefix is this moniker
//
#define MK_S_ME                          0x000401E4L           [fail]

//
// MessageId: MK_S_HIM
//
// MessageText:
//
//  Common prefix is input moniker
//
#define MK_S_HIM                         0x000401E5L           [fail]

//
// MessageId: MK_S_US
//
// MessageText:
//
//  Common prefix is both monikers
//
#define MK_S_US                          0x000401E6L           [fail]

//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
//  Moniker is already registered in running object table
//
#define MK_S_MONIKERALREADYREGISTERED    0x000401E7L           [fail]

// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
//  Attempt to create a class object failed
//
#define CO_E_CLASS_CREATE_FAILED         0x80080001L           [fail]

//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
//  OLE service could not bind object
//
#define CO_E_SCM_ERROR                   0x80080002L           [fail]

//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
//  RPC communication failed with OLE service
//
#define CO_E_SCM_RPC_FAILURE             0x80080003L           [fail]

//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
//  Bad path to object
//
#define CO_E_BAD_PATH                    0x80080004L           [fail]

//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
//  Server execution failed
//
#define CO_E_SERVER_EXEC_FAILURE         0x80080005L           [fail]

//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
//  OLE service could not communicate with the object server
//
#define CO_E_OBJSRV_RPC_FAILURE          0x80080006L           [fail]

//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
//  Moniker path could not be normalized
//
#define MK_E_NO_NORMALIZED               0x80080007L           [fail]

//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
//  Object server is stopping when OLE service contacts it
//
#define CO_E_SERVER_STOPPING             0x80080008L           [fail]

//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
//  An invalid root block pointer was specified
//
#define MEM_E_INVALID_ROOT               0x80080009L           [fail]

//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
//  An allocation chain contained an invalid link pointer
//
#define MEM_E_INVALID_LINK               0x80080010L           [fail]

//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
//  The requested allocation size was too large
//
#define MEM_E_INVALID_SIZE               0x80080011L           [fail]

//
// MessageId: CO_S_NOTALLINTERFACES
//
// MessageText:
//
//  Not all the requested interfaces were available
//
#define CO_S_NOTALLINTERFACES            0x00080012L           [fail]

// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
//  Unknown interface.
//
#define DISP_E_UNKNOWNINTERFACE          0x80020001L           [fail]

//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
//  Member not found.
//
#define DISP_E_MEMBERNOTFOUND            0x80020003L           [fail]

//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
//  Parameter not found.
//
#define DISP_E_PARAMNOTFOUND             0x80020004L           [fail]

//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define DISP_E_TYPEMISMATCH              0x80020005L           [fail]

//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
//  Unknown name.
//
#define DISP_E_UNKNOWNNAME               0x80020006L           [fail]

//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
//  No named arguments.
//
#define DISP_E_NONAMEDARGS               0x80020007L           [fail]

//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
//  Bad variable type.
//
#define DISP_E_BADVARTYPE                0x80020008L           [fail]

//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
//  Exception occurred.
//
#define DISP_E_EXCEPTION                 0x80020009L           [fail]

//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
//  Out of present range.
//
#define DISP_E_OVERFLOW                  0x8002000AL           [fail]

//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
//  Invalid index.
//
#define DISP_E_BADINDEX                  0x8002000BL           [fail]

//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown language.
//
#define DISP_E_UNKNOWNLCID               0x8002000CL           [fail]

//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
//  Memory is locked.
//
#define DISP_E_ARRAYISLOCKED             0x8002000DL           [fail]

//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
//  Invalid number of parameters.
//
#define DISP_E_BADPARAMCOUNT             0x8002000EL           [fail]

//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
//  Parameter not optional.
//
#define DISP_E_PARAMNOTOPTIONAL          0x8002000FL           [fail]

//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
//  Invalid callee.
//
#define DISP_E_BADCALLEE                 0x80020010L           [fail]

//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
//  Does not support a collection.
//
#define DISP_E_NOTACOLLECTION            0x80020011L           [fail]

//
// MessageId: DISP_E_DIVBYZERO
//
// MessageText:
//
//  Division by zero.
//
#define DISP_E_DIVBYZERO                 0x80020012L           [fail]

//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer too small.
//
#define TYPE_E_BUFFERTOOSMALL            0x80028016L           [fail]

//
// MessageId: TYPE_E_FIELDNOTFOUND
//
// MessageText:
//
//  Field name not defined in the record.
//
#define TYPE_E_FIELDNOTFOUND             0x80028017L           [fail]

//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_INVDATAREAD               0x80028018L           [fail]

//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_UNSUPFORMAT               0x80028019L           [fail]

//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
//  Error accessing the OLE registry.
//
#define TYPE_E_REGISTRYACCESS            0x8002801CL           [fail]

//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
//  Library not registered.
//
#define TYPE_E_LIBNOTREGISTERED          0x8002801DL           [fail]

//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
//  Bound to unknown type.
//
#define TYPE_E_UNDEFINEDTYPE             0x80028027L           [fail]

//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
//  Qualified name disallowed.
//
#define TYPE_E_QUALIFIEDNAMEDISALLOWED   0x80028028L           [fail]

//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
//  Invalid forward reference, or reference to uncompiled type.
//
#define TYPE_E_INVALIDSTATE              0x80028029L           [fail]

//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_WRONGTYPEKIND             0x8002802AL           [fail]

//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
//  Element not found.
//
#define TYPE_E_ELEMENTNOTFOUND           0x8002802BL           [fail]

//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
//  Ambiguous name.
//
#define TYPE_E_AMBIGUOUSNAME             0x8002802CL           [fail]

//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
//  Name already exists in the library.
//
#define TYPE_E_NAMECONFLICT              0x8002802DL           [fail]

//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown LCID.
//
#define TYPE_E_UNKNOWNLCID               0x8002802EL           [fail]

//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
//  Function not defined in specified DLL.
//
#define TYPE_E_DLLFUNCTIONNOTFOUND       0x8002802FL           [fail]

//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
//  Wrong module kind for the operation.
//
#define TYPE_E_BADMODULEKIND             0x800288BDL           [fail]

//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
//  Size may not exceed 64K.
//
#define TYPE_E_SIZETOOBIG                0x800288C5L           [fail]

//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
//  Duplicate ID in inheritance hierarchy.
//
#define TYPE_E_DUPLICATEID               0x800288C6L           [fail]

//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
//  Incorrect inheritance depth in standard OLE hmember.
//
#define TYPE_E_INVALIDID                 0x800288CFL           [fail]

//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_TYPEMISMATCH              0x80028CA0L           [fail]

//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
//  Invalid number of arguments.
//
#define TYPE_E_OUTOFBOUNDS               0x80028CA1L           [fail]

//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
//  I/O Error.
//
#define TYPE_E_IOERROR                   0x80028CA2L           [fail]

//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
//  Error creating unique tmp file.
//
#define TYPE_E_CANTCREATETMPFILE         0x80028CA3L           [fail]

//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
//  Error loading type library/DLL.
//
#define TYPE_E_CANTLOADLIBRARY           0x80029C4AL           [fail]

//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
//  Inconsistent property functions.
//
#define TYPE_E_INCONSISTENTPROPFUNCS     0x80029C83L           [fail]

//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
//  Circular dependency between types/modules.
//
#define TYPE_E_CIRCULARTYPE              0x80029C84L           [fail]

// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
//  Unable to perform requested operation.
//
#define STG_E_INVALIDFUNCTION            0x80030001L           [fail]

//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
//  %1 could not be found.
//
#define STG_E_FILENOTFOUND               0x80030002L           [fail]

//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
//  The path %1 could not be found.
//
#define STG_E_PATHNOTFOUND               0x80030003L           [fail]

//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
//  There are insufficient resources to open another file.
//
#define STG_E_TOOMANYOPENFILES           0x80030004L           [fail]

//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
//  Access Denied.
//
#define STG_E_ACCESSDENIED               0x80030005L           [fail]

//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
//  Attempted an operation on an invalid object.
//
#define STG_E_INVALIDHANDLE              0x80030006L           [fail]

//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
//  There is insufficient memory available to complete operation.
//
#define STG_E_INSUFFICIENTMEMORY         0x80030008L           [fail]

//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
//  Invalid pointer error.
//
#define STG_E_INVALIDPOINTER             0x80030009L           [fail]

//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
//  There are no more entries to return.
//
#define STG_E_NOMOREFILES                0x80030012L           [fail]

//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
//  Disk is write-protected.
//
#define STG_E_DISKISWRITEPROTECTED       0x80030013L           [fail]

//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
//  An error occurred during a seek operation.
//
#define STG_E_SEEKERROR                  0x80030019L           [fail]

//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
//  A disk error occurred during a write operation.
//
#define STG_E_WRITEFAULT                 0x8003001DL           [fail]

//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
//  A disk error occurred during a read operation.
//
#define STG_E_READFAULT                  0x8003001EL           [fail]

//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
//  A share violation has occurred.
//
#define STG_E_SHAREVIOLATION             0x80030020L           [fail]

//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
//  A lock violation has occurred.
//
#define STG_E_LOCKVIOLATION              0x80030021L           [fail]

//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
//  %1 already exists.
//
#define STG_E_FILEALREADYEXISTS          0x80030050L           [fail]

//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
//  Invalid parameter error.
//
#define STG_E_INVALIDPARAMETER           0x80030057L           [fail]

//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
//  There is insufficient disk space to complete operation.
//
#define STG_E_MEDIUMFULL                 0x80030070L           [fail]

//
// MessageId: STG_E_PROPSETMISMATCHED
//
// MessageText:
//
//  Illegal write of non-simple property to simple property set.
//
#define STG_E_PROPSETMISMATCHED          0x800300F0L           [fail]

//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
//  An API call exited abnormally.
//
#define STG_E_ABNORMALAPIEXIT            0x800300FAL           [fail]

//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
//  The file %1 is not a valid compound file.
//
#define STG_E_INVALIDHEADER              0x800300FBL           [fail]

//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
//  The name %1 is not valid.
//
#define STG_E_INVALIDNAME                0x800300FCL           [fail]

//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
//  An unexpected error occurred.
//
#define STG_E_UNKNOWN                    0x800300FDL           [fail]

//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
//  That function is not implemented.
//
#define STG_E_UNIMPLEMENTEDFUNCTION      0x800300FEL           [fail]

//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
//  Invalid flag error.
//
#define STG_E_INVALIDFLAG                0x800300FFL           [fail]

//
// MessageId: STG_E_INUSE
//
// MessageText:
//
//  Attempted to use an object that is busy.
//
#define STG_E_INUSE                      0x80030100L           [fail]

//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
//  The storage has been changed since the last commit.
//
#define STG_E_NOTCURRENT                 0x80030101L           [fail]

//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
//  Attempted to use an object that has ceased to exist.
//
#define STG_E_REVERTED                   0x80030102L           [fail]

//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
//  Can't save.
//
#define STG_E_CANTSAVE                   0x80030103L           [fail]

//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
//  The compound file %1 was produced with an incompatible version of storage.
//
#define STG_E_OLDFORMAT                  0x80030104L           [fail]

//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
//  The compound file %1 was produced with a newer version of storage.
//
#define STG_E_OLDDLL                     0x80030105L           [fail]

//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
//  Share.exe or equivalent is required for operation.
//
#define STG_E_SHAREREQUIRED              0x80030106L           [fail]

//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
//  Illegal operation called on non-file based storage.
//
#define STG_E_NOTFILEBASEDSTORAGE        0x80030107L           [fail]

//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
//  Illegal operation called on object with extant marshallings.
//
#define STG_E_EXTANTMARSHALLINGS         0x80030108L           [fail]

//
// MessageId: STG_E_DOCFILECORRUPT
//
// MessageText:
//
//  The docfile has been corrupted.
//
#define STG_E_DOCFILECORRUPT             0x80030109L           [fail]

//
// MessageId: STG_E_BADBASEADDRESS
//
// MessageText:
//
//  OLE32.DLL has been loaded at the wrong address.
//
#define STG_E_BADBASEADDRESS             0x80030110L           [fail]

//
// MessageId: STG_E_INCOMPLETE
//
// MessageText:
//
//  The file download was aborted abnormally.  The file is incomplete.
//
#define STG_E_INCOMPLETE                 0x80030201L           [fail]

//
// MessageId: STG_E_TERMINATED
//
// MessageText:
//
//  The file download has been terminated.
//
#define STG_E_TERMINATED                 0x80030202L           [fail]

//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
//  The underlying file was converted to compound file format.
//
#define STG_S_CONVERTED                  0x00030200L           [fail]

//
// MessageId: STG_S_BLOCK
//
// MessageText:
//
//  The storage operation should block until more data is available.
//
#define STG_S_BLOCK                      0x00030201L           [fail]

//
// MessageId: STG_S_RETRYNOW
//
// MessageText:
//
//  The storage operation should retry immediately.
//
#define STG_S_RETRYNOW                   0x00030202L           [fail]

//
// MessageId: STG_S_MONITORING
//
// MessageText:
//
//  The notified event sink will not influence the storage operation.
//
#define STG_S_MONITORING                 0x00030203L           [fail]

//
// MessageId: STG_S_MULTIPLEOPENS
//
// MessageText:
//
//  Multiple opens prevent consolidated. (commit succeeded).
//
#define STG_S_MULTIPLEOPENS              0x00030204L           [fail]

//
// MessageId: STG_S_CONSOLIDATIONFAILED
//
// MessageText:
//
//  Consolidation of the storage file failed. (commit succeeded).
//
#define STG_S_CONSOLIDATIONFAILED        0x00030205L           [fail]

//
// MessageId: STG_S_CANNOTCONSOLIDATE
//
// MessageText:
//
//  Consolidation of the storage file is inappropriate. (commit succeeded).
//
#define STG_S_CANNOTCONSOLIDATE          0x00030206L           [fail]

// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propagated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED              0x80010001L           [fail]

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceled by the message filter.
//
#define RPC_E_CALL_CANCELED              0x80010002L           [fail]

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  cannot call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL        0x80010003L           [fail]

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronous call and cannot
//  make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL    0x80010004L           [fail]

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  It is illegal to call out while inside message filter.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL 0x80010005L           [fail]

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and cannot be used any more. Other connections
//  are still valid.
//
#define RPC_E_CONNECTION_TERMINATED      0x80010006L           [fail]

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//
#define RPC_E_SERVER_DIED                0x80010007L           [fail]

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client) disappeared while the callee (server) was
//  processing a call.
//
#define RPC_E_CLIENT_DIED                0x80010008L           [fail]

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The data packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET         0x80010009L           [fail]

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL          0x8001000AL           [fail]

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot marshall the parameter data - low memory, etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA    0x8001000BL           [fail]

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot unmarshall the return data - low memory, etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA  0x8001000CL           [fail]

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot marshall the return data - low memory, etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA    0x8001000DL           [fail]

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot unmarshall the parameter data - low memory, etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA  0x8001000EL           [fail]

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data is invalid; could be server or client data.
//
#define RPC_E_INVALID_DATA               0x8001000FL           [fail]

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and cannot be (un)marshalled.
//
#define RPC_E_INVALID_PARAMETER          0x80010010L           [fail]

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN          0x80010011L           [fail]

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE            0x80010012L           [fail]

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//
#define RPC_E_SYS_CALL_FAILED            0x80010100L           [fail]

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES           0x80010101L           [fail]

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more than one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD      0x80010102L           [fail]

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED             0x80010103L           [fail]

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT                      0x80010104L           [fail]

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//
#define RPC_E_SERVERFAULT                0x80010105L           [fail]

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE               0x80010106L           [fail]

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD              0x80010107L           [fail]

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED               0x80010108L           [fail]

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked chose not to process the call now.  Try again later.
//
#define RPC_E_RETRY                      0x80010109L           [fail]

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The message filter indicated that the application is busy.
//
#define RPC_E_SERVERCALL_RETRYLATER      0x8001010AL           [fail]

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The message filter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED        0x8001010BL           [fail]

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  A call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA           0x8001010CL           [fail]

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL 0x8001010DL           [fail]

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The application called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD               0x8001010EL           [fail]

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT            0x8001010FL           [fail]

//
// MessageId: RPC_E_VERSION_MISMATCH
//
// MessageText:
//
//  The version of OLE on the client and server machines does not match.
//
#define RPC_E_VERSION_MISMATCH           0x80010110L           [fail]

//
// MessageId: RPC_E_INVALID_HEADER
//
// MessageText:
//
//  OLE received a packet with an invalid header.
//
#define RPC_E_INVALID_HEADER             0x80010111L           [fail]

//
// MessageId: RPC_E_INVALID_EXTENSION
//
// MessageText:
//
//  OLE received a packet with an invalid extension.
//
#define RPC_E_INVALID_EXTENSION          0x80010112L           [fail]

//
// MessageId: RPC_E_INVALID_IPID
//
// MessageText:
//
//  The requested object or interface does not exist.
//
#define RPC_E_INVALID_IPID               0x80010113L           [fail]

//
// MessageId: RPC_E_INVALID_OBJECT
//
// MessageText:
//
//  The requested object does not exist.
//
#define RPC_E_INVALID_OBJECT             0x80010114L           [fail]

//
// MessageId: RPC_S_CALLPENDING
//
// MessageText:
//
//  OLE has sent a request and is waiting for a reply.
//
#define RPC_S_CALLPENDING                0x80010115L           [fail]

//
// MessageId: RPC_S_WAITONTIMER
//
// MessageText:
//
//  OLE is waiting before retrying a request.
//
#define RPC_S_WAITONTIMER                0x80010116L           [fail]

//
// MessageId: RPC_E_CALL_COMPLETE
//
// MessageText:
//
//  Call context cannot be accessed after call completed.
//
#define RPC_E_CALL_COMPLETE              0x80010117L           [fail]

//
// MessageId: RPC_E_UNSECURE_CALL
//
// MessageText:
//
//  Impersonate on unsecure calls is not supported.
//
#define RPC_E_UNSECURE_CALL              0x80010118L           [fail]

//
// MessageId: RPC_E_TOO_LATE
//
// MessageText:
//
//  Security must be initialized before any interfaces are marshalled or
//  unmarshalled.  It cannot be changed once initialized.
//
#define RPC_E_TOO_LATE                   0x80010119L           [fail]

//
// MessageId: RPC_E_NO_GOOD_SECURITY_PACKAGES
//
// MessageText:
//
//  No security packages are installed on this machine or the user is not logged
//  on or there are no compatible security packages between the client and server.
//
#define RPC_E_NO_GOOD_SECURITY_PACKAGES  0x8001011AL           [fail]

//
// MessageId: RPC_E_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define RPC_E_ACCESS_DENIED              0x8001011BL           [fail]

//
// MessageId: RPC_E_REMOTE_DISABLED
//
// MessageText:
//
//  Remote calls are not allowed for this process.
//
#define RPC_E_REMOTE_DISABLED            0x8001011CL           [fail]

//
// MessageId: RPC_E_INVALID_OBJREF
//
// MessageText:
//
//  The marshaled interface data packet (OBJREF) has an invalid or unknown format.
//
#define RPC_E_INVALID_OBJREF             0x8001011DL           [fail]

//
// MessageId: RPC_E_NO_CONTEXT
//
// MessageText:
//
//  No context is associated with this call.  This happens for some custom
//  marshalled calls and on the client side of the call.
//
#define RPC_E_NO_CONTEXT                 0x8001011EL           [fail]

//
// MessageId: RPC_E_TIMEOUT
//
// MessageText:
//
//  This operation returned because the timeout period expired.
//
#define RPC_E_TIMEOUT                    0x8001011FL           [fail]

//
// MessageId: RPC_E_NO_SYNC
//
// MessageText:
//
//  There are no synchronize objects to wait on.
//
#define RPC_E_NO_SYNC                    0x80010120L           [fail]

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occurred.
//
#define RPC_E_UNEXPECTED                 0x8001FFFFL           [fail]


 /////////////////
 //
 //  FACILITY_SSPI
 //
 /////////////////

//
// MessageId: NTE_BAD_UID
//
// MessageText:
//
//  Bad UID.
//
#define NTE_BAD_UID                      0x80090001L           [fail]

//
// MessageId: NTE_BAD_HASH
//
// MessageText:
//
//  Bad Hash.
//
#define NTE_BAD_HASH                     0x80090002L           [fail]

//
// MessageId: NTE_BAD_KEY
//
// MessageText:
//
//  Bad Key.
//
#define NTE_BAD_KEY                      0x80090003L           [fail]

//
// MessageId: NTE_BAD_LEN
//
// MessageText:
//
//  Bad Length.
//
#define NTE_BAD_LEN                      0x80090004L           [fail]

//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
//  Bad Data.
//
#define NTE_BAD_DATA                     0x80090005L           [fail]

//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
//  Invalid Signature.
//
#define NTE_BAD_SIGNATURE                0x80090006L           [fail]

//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
//  Bad Version of provider.
//
#define NTE_BAD_VER                      0x80090007L           [fail]

//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
//  Invalid algorithm specified.
//
#define NTE_BAD_ALGID                    0x80090008L           [fail]

//
// MessageId: NTE_BAD_FLAGS
//
// MessageText:
//
//  Invalid flags specified.
//
#define NTE_BAD_FLAGS                    0x80090009L           [fail]

//
// MessageId: NTE_BAD_TYPE
//
// MessageText:
//
//  Invalid type specified.
//
#define NTE_BAD_TYPE                     0x8009000AL           [fail]

//
// MessageId: NTE_BAD_KEY_STATE
//
// MessageText:
//
//  Key not valid for use in specified state.
//
#define NTE_BAD_KEY_STATE                0x8009000BL           [fail]

//
// MessageId: NTE_BAD_HASH_STATE
//
// MessageText:
//
//  Hash not valid for use in specified state.
//
#define NTE_BAD_HASH_STATE               0x8009000CL           [fail]

//
// MessageId: NTE_NO_KEY
//
// MessageText:
//
//  Key does not exist.
//
#define NTE_NO_KEY                       0x8009000DL           [fail]

//
// MessageId: NTE_NO_MEMORY
//
// MessageText:
//
//  Insufficient memory available for the operation.
//
#define NTE_NO_MEMORY                    0x8009000EL           [fail]

//
// MessageId: NTE_EXISTS
//
// MessageText:
//
//  Object already exists.
//
#define NTE_EXISTS                       0x8009000FL           [fail]

//
// MessageId: NTE_PERM
//
// MessageText:
//
//  Access denied.
//
#define NTE_PERM                         0x80090010L           [fail]

//
// MessageId: NTE_NOT_FOUND
//
// MessageText:
//
//  Object was not found.
//
#define NTE_NOT_FOUND                    0x80090011L           [fail]

//
// MessageId: NTE_DOUBLE_ENCRYPT
//
// MessageText:
//
//  Data already encrypted.
//
#define NTE_DOUBLE_ENCRYPT               0x80090012L           [fail]

//
// MessageId: NTE_BAD_PROVIDER
//
// MessageText:
//
//  Invalid provider specified.
//
#define NTE_BAD_PROVIDER                 0x80090013L           [fail]

//
// MessageId: NTE_BAD_PROV_TYPE
//
// MessageText:
//
//  Invalid provider type specified.
//
#define NTE_BAD_PROV_TYPE                0x80090014L           [fail]

//
// MessageId: NTE_BAD_PUBLIC_KEY
//
// MessageText:
//
//  Provider's public key is invalid.
//
#define NTE_BAD_PUBLIC_KEY               0x80090015L           [fail]

//
// MessageId: NTE_BAD_KEYSET
//
// MessageText:
//
//  Keyset does not exist
//
#define NTE_BAD_KEYSET                   0x80090016L           [fail]

//
// MessageId: NTE_PROV_TYPE_NOT_DEF
//
// MessageText:
//
//  Provider type not defined.
//
#define NTE_PROV_TYPE_NOT_DEF            0x80090017L           [fail]

//
// MessageId: NTE_PROV_TYPE_ENTRY_BAD
//
// MessageText:
//
//  Provider type as registered is invalid.
//
#define NTE_PROV_TYPE_ENTRY_BAD          0x80090018L           [fail]

//
// MessageId: NTE_KEYSET_NOT_DEF
//
// MessageText:
//
//  The keyset is not defined.
//
#define NTE_KEYSET_NOT_DEF               0x80090019L           [fail]

//
// MessageId: NTE_KEYSET_ENTRY_BAD
//
// MessageText:
//
//  Keyset as registered is invalid.
//
#define NTE_KEYSET_ENTRY_BAD             0x8009001AL           [fail]

//
// MessageId: NTE_PROV_TYPE_NO_MATCH
//
// MessageText:
//
//  Provider type does not match registered value.
//
#define NTE_PROV_TYPE_NO_MATCH           0x8009001BL           [fail]

//
// MessageId: NTE_SIGNATURE_FILE_BAD
//
// MessageText:
//
//  The digital signature file is corrupt.
//
#define NTE_SIGNATURE_FILE_BAD           0x8009001CL           [fail]

//
// MessageId: NTE_PROVIDER_DLL_FAIL
//
// MessageText:
//
//  Provider DLL failed to initialize correctly.
//
#define NTE_PROVIDER_DLL_FAIL            0x8009001DL           [fail]

//
// MessageId: NTE_PROV_DLL_NOT_FOUND
//
// MessageText:
//
//  Provider DLL could not be found.
//
#define NTE_PROV_DLL_NOT_FOUND           0x8009001EL           [fail]

//
// MessageId: NTE_BAD_KEYSET_PARAM
//
// MessageText:
//
//  The Keyset parameter is invalid.
//
#define NTE_BAD_KEYSET_PARAM             0x8009001FL           [fail]

//
// MessageId: NTE_FAIL
//
// MessageText:
//
//  An internal error occurred.
//
#define NTE_FAIL                         0x80090020L           [fail]

//
// MessageId: NTE_SYS_ERR
//
// MessageText:
//
//  A base error occurred.
//
#define NTE_SYS_ERR                      0x80090021L           [fail]

//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
//  An error was encountered doing a cryptographic message operation.
//
#define CRYPT_E_MSG_ERROR                0x80091001L           [fail]

//
// MessageId: CRYPT_E_UNKNOWN_ALGO
//
// MessageText:
//
//  The cryptographic algorithm is unknown.
//
#define CRYPT_E_UNKNOWN_ALGO             0x80091002L           [fail]

//
// MessageId: CRYPT_E_OID_FORMAT
//
// MessageText:
//
//  The object identifier is badly formatted.
//
#define CRYPT_E_OID_FORMAT               0x80091003L           [fail]

//
// MessageId: CRYPT_E_INVALID_MSG_TYPE
//
// MessageText:
//
//  The message type is invalid.
//
#define CRYPT_E_INVALID_MSG_TYPE         0x80091004L           [fail]

//
// MessageId: CRYPT_E_UNEXPECTED_ENCODING
//
// MessageText:
//
//  The message is not encoded as expected.
//
#define CRYPT_E_UNEXPECTED_ENCODING      0x80091005L           [fail]

//
// MessageId: CRYPT_E_AUTH_ATTR_MISSING
//
// MessageText:
//
//  The message does not contain an expected authenticated attribute.
//
#define CRYPT_E_AUTH_ATTR_MISSING        0x80091006L           [fail]

//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
//  The hash value is not correct.
//
#define CRYPT_E_HASH_VALUE               0x80091007L           [fail]

//
// MessageId: CRYPT_E_INVALID_INDEX
//
// MessageText:
//
//  The index value is not valid.
//
#define CRYPT_E_INVALID_INDEX            0x80091008L           [fail]

//
// MessageId: CRYPT_E_ALREADY_DECRYPTED
//
// MessageText:
//
//  The message content has already been decrypted.
//
#define CRYPT_E_ALREADY_DECRYPTED        0x80091009L           [fail]

//
// MessageId: CRYPT_E_NOT_DECRYPTED
//
// MessageText:
//
//  The message content has not been decrypted yet.
//
#define CRYPT_E_NOT_DECRYPTED            0x8009100AL           [fail]

//
// MessageId: CRYPT_E_RECIPIENT_NOT_FOUND
//
// MessageText:
//
//  The enveloped-data message does not contain the specified recipient.
//
#define CRYPT_E_RECIPIENT_NOT_FOUND      0x8009100BL           [fail]

//
// MessageId: CRYPT_E_CONTROL_TYPE
//
// MessageText:
//
//  The control type is not valid.
//
#define CRYPT_E_CONTROL_TYPE             0x8009100CL           [fail]

//
// MessageId: CRYPT_E_ISSUER_SERIALNUMBER
//
// MessageText:
//
//  The issuer and/or serial number are/is not valid.
//
#define CRYPT_E_ISSUER_SERIALNUMBER      0x8009100DL           [fail]

//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
//  The original signer is not found.
//
#define CRYPT_E_SIGNER_NOT_FOUND         0x8009100EL           [fail]

//
// MessageId: CRYPT_E_ATTRIBUTES_MISSING
//
// MessageText:
//
//  The message does not contain the requested attributes.
//
#define CRYPT_E_ATTRIBUTES_MISSING       0x8009100FL           [fail]

//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
//  The steamed message is note yet able to return the requested data.
//
#define CRYPT_E_STREAM_MSG_NOT_READY     0x80091010L           [fail]

//
// MessageId: CRYPT_E_STREAM_INSUFFICIENT_DATA
//
// MessageText:
//
//  The streamed message needs more data before the decode can complete.
//
#define CRYPT_E_STREAM_INSUFFICIENT_DATA 0x80091011L           [fail]

//
// MessageId: CRYPT_E_BAD_LEN
//
// MessageText:
//
//  The length specified for the output data was insufficient.
//
#define CRYPT_E_BAD_LEN                  0x80092001L           [fail]

//
// MessageId: CRYPT_E_BAD_ENCODE
//
// MessageText:
//
//  An error was encountered while encoding or decoding.
//
#define CRYPT_E_BAD_ENCODE               0x80092002L           [fail]

//
// MessageId: CRYPT_E_FILE_ERROR
//
// MessageText:
//
//  An error occurred while reading or writing to the file
//
#define CRYPT_E_FILE_ERROR               0x80092003L           [fail]

//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
//  The object or property wasn't found
//
#define CRYPT_E_NOT_FOUND                0x80092004L           [fail]

//
// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
//  The object or property already exists
//
#define CRYPT_E_EXISTS                   0x80092005L           [fail]

//
// MessageId: CRYPT_E_NO_PROVIDER
//
// MessageText:
//
//  No provider was specified for the store or object
//
#define CRYPT_E_NO_PROVIDER              0x80092006L           [fail]

//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
//  The specified certificate is self signed.
//
#define CRYPT_E_SELF_SIGNED              0x80092007L           [fail]

//
// MessageId: CRYPT_E_DELETED_PREV
//
// MessageText:
//
//  The previous certificate or CRL context was deleted.
//
#define CRYPT_E_DELETED_PREV             0x80092008L           [fail]

//
// MessageId: CRYPT_E_NO_MATCH
//
// MessageText:
//
//  No match when trying to find the object.
//
#define CRYPT_E_NO_MATCH                 0x80092009L           [fail]

//
// MessageId: CRYPT_E_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
//  The type of the cryptographic message being decoded is different than what was expected.
//
#define CRYPT_E_UNEXPECTED_MSG_TYPE      0x8009200AL           [fail]

//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
//  The certificate doesn't have a private key property
//
#define CRYPT_E_NO_KEY_PROPERTY          0x8009200BL           [fail]

//
// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
//  No certificate was found having a private key property to use for decrypting.
//
#define CRYPT_E_NO_DECRYPT_CERT          0x8009200CL           [fail]

//
// MessageId: CRYPT_E_BAD_MSG
//
// MessageText:
//
//  Either, not a cryptographic message or incorrectly formatted.
//
#define CRYPT_E_BAD_MSG                  0x8009200DL           [fail]

//
// MessageId: CRYPT_E_NO_SIGNER
//
// MessageText:
//
//  The signed message doesn't have a signer for the specified signer index
//
#define CRYPT_E_NO_SIGNER                0x8009200EL           [fail]

//
// MessageId: CRYPT_E_PENDING_CLOSE
//
// MessageText:
//
//  Final closure is pending until additional frees or closes.
//
#define CRYPT_E_PENDING_CLOSE            0x8009200FL           [fail]

//
// MessageId: CRYPT_E_REVOKED
//
// MessageText:
//
//  The certificate or signature has been revoked
//
#define CRYPT_E_REVOKED                  0x80092010L           [fail]

//
// MessageId: CRYPT_E_NO_REVOCATION_DLL
//
// MessageText:
//
//  No Dll or exported function was found to verify revocation.
//
#define CRYPT_E_NO_REVOCATION_DLL        0x80092011L           [fail]

//
// MessageId: CRYPT_E_NO_REVOCATION_CHECK
//
// MessageText:
//
//  The called function wasn't able to do a revocation check on the certificate or signature.
//
#define CRYPT_E_NO_REVOCATION_CHECK      0x80092012L           [fail]

//
// MessageId: CRYPT_E_REVOCATION_OFFLINE
//
// MessageText:
//
//  Since the revocation server was offline, the called function wasn't able to complete the revocation check.
//
#define CRYPT_E_REVOCATION_OFFLINE       0x80092013L           [fail]

//
// MessageId: CRYPT_E_NOT_IN_REVOCATION_DATABASE
//
// MessageText:
//
//  The certificate or signature to be checked was not found in the revocation servers database.
//
#define CRYPT_E_NOT_IN_REVOCATION_DATABASE 0x80092014L           [fail]

//
// MessageId: CRYPT_E_INVALID_NUMERIC_STRING
//
// MessageText:
//
//  The string contains a non-numeric character.
//
#define CRYPT_E_INVALID_NUMERIC_STRING   0x80092020L           [fail]

//
// MessageId: CRYPT_E_INVALID_PRINTABLE_STRING
//
// MessageText:
//
//  The string contains a non-printable character.
//
#define CRYPT_E_INVALID_PRINTABLE_STRING 0x80092021L           [fail]

//
// MessageId: CRYPT_E_INVALID_IA5_STRING
//
// MessageText:
//
//  The string contains a character not in the 7 bit ASCII character set.
//
#define CRYPT_E_INVALID_IA5_STRING       0x80092022L           [fail]

//
// MessageId: CRYPT_E_INVALID_X500_STRING
//
// MessageText:
//
//  The string contains an invalid X500 name attribute key, oid, value or delimiter.
//
#define CRYPT_E_INVALID_X500_STRING      0x80092023L           [fail]

//
// MessageId: CRYPT_E_NOT_CHAR_STRING
//
// MessageText:
//
//  The dwValueType for the CERT_NAME_VALUE is not one of the character strings.  Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_TDN_OCTED_STRING.
//
#define CRYPT_E_NOT_CHAR_STRING          0x80092024L           [fail]

//
// MessageId: CRYPT_E_FILERESIZED
//
// MessageText:
//
//  The Put operation can not continue.  The file needs to be resized.  However, there is already a signature present.  A complete signing operation must be done.
//
#define CRYPT_E_FILERESIZED              0x80092025L           [fail]

//
// MessageId: CRYPT_E_SECURITY_SETTINGS
//
// MessageText:
//
//  The cryptography operation has failed due to a local security option setting.
//
#define CRYPT_E_SECURITY_SETTINGS        0x80092026L           [fail]

//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_DLL
//
// MessageText:
//
//  No DLL or exported function was found to verify subject usage.
//
#define CRYPT_E_NO_VERIFY_USAGE_DLL      0x80092027L           [fail]

//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_CHECK
//
// MessageText:
//
//  The called function wasn't able to do a usage check on the subject.
//
#define CRYPT_E_NO_VERIFY_USAGE_CHECK    0x80092028L           [fail]

//
// MessageId: CRYPT_E_VERIFY_USAGE_OFFLINE
//
// MessageText:
//
//  Since the server was offline, the called function wasn't able to complete the usage check.
//
#define CRYPT_E_VERIFY_USAGE_OFFLINE     0x80092029L           [fail]

//
// MessageId: CRYPT_E_NOT_IN_CTL
//
// MessageText:
//
//  The subject was not found in a Certificate Trust List (CTL           [fail].
//
#define CRYPT_E_NOT_IN_CTL               0x8009202AL           [fail]

//
// MessageId: CRYPT_E_NO_TRUSTED_SIGNER
//
// MessageText:
//
//  No trusted signer was found to verify the signature of the message or trust list.
//
#define CRYPT_E_NO_TRUSTED_SIGNER        0x8009202BL           [fail]

//
// MessageId: CRYPT_E_OSS_ERROR
//
// MessageText:
//
//  OSS Certificate encode/decode error code base
//  
//  See asn1code.h for a definition of the OSS runtime errors. The OSS
//  error values are offset by CRYPT_E_OSS_ERROR.
//
#define CRYPT_E_OSS_ERROR                0x80093000L           [fail]

//
// MessageId: CERTSRV_E_BAD_REQUESTSUBJECT
//
// MessageText:
//
//  The request subject name is invalid or too long.
//
#define CERTSRV_E_BAD_REQUESTSUBJECT     0x80094001L           [fail]

//
// MessageId: CERTSRV_E_NO_REQUEST
//
// MessageText:
//
//  The request does not exist.
//
#define CERTSRV_E_NO_REQUEST             0x80094002L           [fail]

//
// MessageId: CERTSRV_E_BAD_REQUESTSTATUS
//
// MessageText:
//
//  The request's current status does not allow this operation.
//
#define CERTSRV_E_BAD_REQUESTSTATUS      0x80094003L           [fail]

//
// MessageId: CERTSRV_E_PROPERTY_EMPTY
//
// MessageText:
//
//  The requested property value is empty.
//
#define CERTSRV_E_PROPERTY_EMPTY         0x80094004L           [fail]

//
// MessageId: CERTDB_E_JET_ERROR
//
// MessageText:
//
//  Jet error code base
//  
//  See jet.h for a definition of the Jet runtime errors.
//  Negative Jet error values are masked to three digits and offset by CERTDB_E_JET_ERROR.
//
#define CERTDB_E_JET_ERROR               0x80095000L           [fail]

//
// MessageId: TRUST_E_SYSTEM_ERROR
//
// MessageText:
//
//  A system-level error occured while verifying trust.
//
#define TRUST_E_SYSTEM_ERROR             0x80096001L           [fail]

//
// MessageId: TRUST_E_NO_SIGNER_CERT
//
// MessageText:
//
//  The certificate for the signer of the message is invalid or not found.
//
#define TRUST_E_NO_SIGNER_CERT           0x80096002L           [fail]

//
// MessageId: TRUST_E_COUNTER_SIGNER
//
// MessageText:
//
//  One of the counter signers was invalid.
//
#define TRUST_E_COUNTER_SIGNER           0x80096003L           [fail]

//
// MessageId: TRUST_E_CERT_SIGNATURE
//
// MessageText:
//
//  The signature of the certificate can not be verified.
//
#define TRUST_E_CERT_SIGNATURE           0x80096004L           [fail]

//
// MessageId: TRUST_E_TIME_STAMP
//
// MessageText:
//
//  The time stamp signer and or certificate could not be verified or is malformed.
//
#define TRUST_E_TIME_STAMP               0x80096005L           [fail]

//
// MessageId: TRUST_E_BAD_DIGEST
//
// MessageText:
//
//  The objects digest did not verify.
//
#define TRUST_E_BAD_DIGEST               0x80096010L           [fail]

//
// MessageId: TRUST_E_BASIC_CONSTRAINTS
//
// MessageText:
//
//  The cerficates basic constraints are invalid or missing.
//
#define TRUST_E_BASIC_CONSTRAINTS        0x80096019L           [fail]

//
// MessageId: TRUST_E_FINANCIAL_CRITERIA
//
// MessageText:
//
//  The certificate does not meet or contain the Authenticode financial extensions.
//
#define TRUST_E_FINANCIAL_CRITERIA       0x8009601EL           [fail]

#define NTE_OP_OK 0

//
// Note that additional FACILITY_SSPI errors are in issperr.h
//
// ******************
// FACILITY_CERT
// ******************
//
// MessageId: TRUST_E_PROVIDER_UNKNOWN
//
// MessageText:
//
//  The specified trust provider is not known on this system.
//
#define TRUST_E_PROVIDER_UNKNOWN         0x800B0001L           [fail]

//
// MessageId: TRUST_E_ACTION_UNKNOWN
//
// MessageText:
//
//  The trust verification action specified is not supported by the specified trust provider.
//
#define TRUST_E_ACTION_UNKNOWN           0x800B0002L           [fail]

//
// MessageId: TRUST_E_SUBJECT_FORM_UNKNOWN
//
// MessageText:
//
//  The form specified for the subject is not one supported or known by the specified trust provider.
//
#define TRUST_E_SUBJECT_FORM_UNKNOWN     0x800B0003L           [fail]

//
// MessageId: TRUST_E_SUBJECT_NOT_TRUSTED
//
// MessageText:
//
//  The subject is not trusted for the specified action.
//
#define TRUST_E_SUBJECT_NOT_TRUSTED      0x800B0004L           [fail]

//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
//  Error due to problem in ASN.1 encoding process.
//
#define DIGSIG_E_ENCODE                  0x800B0005L           [fail]

//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
//  Error due to problem in ASN.1 decoding process.
//
#define DIGSIG_E_DECODE                  0x800B0006L           [fail]

//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
//  Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
#define DIGSIG_E_EXTENSIBILITY           0x800B0007L           [fail]

//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
//  Unspecified cryptographic failure.
//
#define DIGSIG_E_CRYPTO                  0x800B0008L           [fail]

//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
//  The size of the data could not be determined.
//
#define PERSIST_E_SIZEDEFINITE           0x800B0009L           [fail]

//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
//  The size of the indefinite-sized data could not be determined.
//
#define PERSIST_E_SIZEINDEFINITE         0x800B000AL           [fail]

//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
//  This object does not read and write self-sizing data.
//
#define PERSIST_E_NOTSELFSIZING          0x800B000BL           [fail]

//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
//  No signature was present in the subject.
//
#define TRUST_E_NOSIGNATURE              0x800B0100L           [fail]

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
//  A required certificate is not within its validity period.
//
#define CERT_E_EXPIRED                   0x800B0101L           [fail]

//
// MessageId: CERT_E_VALIDITYPERIODNESTING
//
// MessageText:
//
//  The validity periods of the certification chain do not nest correctly.
//
#define CERT_E_VALIDITYPERIODNESTING     0x800B0102L           [fail]

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
//  A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
#define CERT_E_ROLE                      0x800B0103L           [fail]

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
//  A path length constraint in the certification chain has been violated.
//
#define CERT_E_PATHLENCONST              0x800B0104L           [fail]

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
//  An extension of unknown type that is labeled 'critical' is present in a certificate.
//
#define CERT_E_CRITICAL                  0x800B0105L           [fail]

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
//  A certificate is being used for a purpose other than that for which it is permitted.
//
#define CERT_E_PURPOSE                   0x800B0106L           [fail]

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
//  A parent of a given certificate in fact did not issue that child certificate.
//
#define CERT_E_ISSUERCHAINING            0x800B0107L           [fail]

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
//  A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
#define CERT_E_MALFORMED                 0x800B0108L           [fail]

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
//  A certification chain processed correctly, but terminated in a root certificate which isn't trusted by the trust provider.
//
#define CERT_E_UNTRUSTEDROOT             0x800B0109L           [fail]

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
//  A chain of certs didn't chain as they should in a certain application of chaining.
//
#define CERT_E_CHAINING                  0x800B010AL           [fail]

//
// MessageId: TRUST_E_FAIL
//
// MessageText:
//
//  Generic Trust Failure.
//
#define TRUST_E_FAIL                     0x800B010BL           [fail]

//
// MessageId: CERT_E_REVOKED
//
// MessageText:
//
//  A certificate was explicitly revoked by its issuer.
//
#define CERT_E_REVOKED                   0x800B010CL           [fail]

//
// MessageId: CERT_E_UNTRUSTEDTESTROOT
//
// MessageText:
//
//  The root certificate is a testing certificate and the policy settings disallow test certificates.
//
#define CERT_E_UNTRUSTEDTESTROOT         0x800B010DL           [fail]

//
// MessageId: CERT_E_REVOCATION_FAILURE
//
// MessageText:
//
//  The revocation process could not continue - the certificate(s) could not be checked.
//
#define CERT_E_REVOCATION_FAILURE        0x800B010EL           [fail]

//
// MessageId: CERT_E_CN_NO_MATCH
//
// MessageText:
//
//  The certificate's CN name does not match the passed value.
//
#define CERT_E_CN_NO_MATCH               0x800B010FL           [fail]

//
// MessageId: CERT_E_WRONG_USAGE
//
// MessageText:
//
//  The certificate is not valid for the requested usage.
//
#define CERT_E_WRONG_USAGE               0x800B0110L           [fail]

// *****************
// FACILITY_SETUPAPI
// *****************
//
//
// MessageId: SPAPI_E_EXPECTED_SECTION_NAME
//
// MessageText:
//
//  A non-empty line was encountered in the INF before the start of a section.
//
#define SPAPI_E_EXPECTED_SECTION_NAME    0x800F0000L           [fail]

//
// MessageId: SPAPI_E_BAD_SECTION_NAME_LINE
//
// MessageText:
//
//  A section name marker in the INF is not complete, or does not exist on a line by itself.
//
#define SPAPI_E_BAD_SECTION_NAME_LINE    0x800F0001L           [fail]

//
// MessageId: SPAPI_E_SECTION_NAME_TOO_LONG
//
// MessageText:
//
//  An INF section was encountered whose name exceeds the maximum section name length.
//
#define SPAPI_E_SECTION_NAME_TOO_LONG    0x800F0002L           [fail]

//
// MessageId: SPAPI_E_GENERAL_SYNTAX
//
// MessageText:
//
//  The syntax of the INF is invalid.
//
#define SPAPI_E_GENERAL_SYNTAX           0x800F0003L           [fail]

//
// MessageId: SPAPI_E_WRONG_INF_STYLE
//
// MessageText:
//
//  The style of the INF is different than what was requested.
//
#define SPAPI_E_WRONG_INF_STYLE          0x800F0100L           [fail]

//
// MessageId: SPAPI_E_SECTION_NOT_FOUND
//
// MessageText:
//
//  The required section was not found in the INF.
//
#define SPAPI_E_SECTION_NOT_FOUND        0x800F0101L           [fail]

//
// MessageId: SPAPI_E_LINE_NOT_FOUND
//
// MessageText:
//
//  The required line was not found in the INF.
//
#define SPAPI_E_LINE_NOT_FOUND           0x800F0102L           [fail]

//
// MessageId: SPAPI_E_NO_ASSOCIATED_CLASS
//
// MessageText:
//
//  The INF or the device information set or element does not have an associated install class.
//
#define SPAPI_E_NO_ASSOCIATED_CLASS      0x800F0200L           [fail]

//
// MessageId: SPAPI_E_CLASS_MISMATCH
//
// MessageText:
//
//  The INF or the device information set or element does not match the specified install class.
//
#define SPAPI_E_CLASS_MISMATCH           0x800F0201L           [fail]

//
// MessageId: SPAPI_E_DUPLICATE_FOUND
//
// MessageText:
//
//  An existing device was found that is a duplicate of the device being manually installed.
//
#define SPAPI_E_DUPLICATE_FOUND          0x800F0202L           [fail]

//
// MessageId: SPAPI_E_NO_DRIVER_SELECTED
//
// MessageText:
//
//  There is no driver selected for the device information set or element.
//
#define SPAPI_E_NO_DRIVER_SELECTED       0x800F0203L           [fail]

//
// MessageId: SPAPI_E_KEY_DOES_NOT_EXIST
//
// MessageText:
//
//  The requested device registry key does not exist.
//
#define SPAPI_E_KEY_DOES_NOT_EXIST       0x800F0204L           [fail]

//
// MessageId: SPAPI_E_INVALID_DEVINST_NAME
//
// MessageText:
//
//  The device instance name is invalid.
//
#define SPAPI_E_INVALID_DEVINST_NAME     0x800F0205L           [fail]

//
// MessageId: SPAPI_E_INVALID_CLASS
//
// MessageText:
//
//  The install class is not present or is invalid.
//
#define SPAPI_E_INVALID_CLASS            0x800F0206L           [fail]

//
// MessageId: SPAPI_E_DEVINST_ALREADY_EXISTS
//
// MessageText:
//
//  The device instance cannot be created because it already exists.
//
#define SPAPI_E_DEVINST_ALREADY_EXISTS   0x800F0207L           [fail]

//
// MessageId: SPAPI_E_DEVINFO_NOT_REGISTERED
//
// MessageText:
//
//  The operation cannot be performed on a device information element that has not been registered.
//
#define SPAPI_E_DEVINFO_NOT_REGISTERED   0x800F0208L           [fail]

//
// MessageId: SPAPI_E_INVALID_REG_PROPERTY
//
// MessageText:
//
//  The device property code is invalid.
//
#define SPAPI_E_INVALID_REG_PROPERTY     0x800F0209L           [fail]

//
// MessageId: SPAPI_E_NO_INF
//
// MessageText:
//
//  The INF from which a driver list is to be built does not exist.
//
#define SPAPI_E_NO_INF                   0x800F020AL           [fail]

//
// MessageId: SPAPI_E_NO_SUCH_DEVINST
//
// MessageText:
//
//  The device instance does not exist in the hardware tree.
//
#define SPAPI_E_NO_SUCH_DEVINST          0x800F020BL           [fail]

//
// MessageId: SPAPI_E_CANT_LOAD_CLASS_ICON
//
// MessageText:
//
//  The icon representing this install class cannot be loaded.
//
#define SPAPI_E_CANT_LOAD_CLASS_ICON     0x800F020CL           [fail]

//
// MessageId: SPAPI_E_INVALID_CLASS_INSTALLER
//
// MessageText:
//
//  The class installer registry entry is invalid.
//
#define SPAPI_E_INVALID_CLASS_INSTALLER  0x800F020DL           [fail]

//
// MessageId: SPAPI_E_DI_DO_DEFAULT
//
// MessageText:
//
//  The class installer has indicated that the default action should be performed for this installation request.
//
#define SPAPI_E_DI_DO_DEFAULT            0x800F020EL           [fail]

//
// MessageId: SPAPI_E_DI_NOFILECOPY
//
// MessageText:
//
//  The operation does not require any files to be copied.
//
#define SPAPI_E_DI_NOFILECOPY            0x800F020FL           [fail]

//
// MessageId: SPAPI_E_INVALID_HWPROFILE
//
// MessageText:
//
//  The specified hardware profile does not exist.
//
#define SPAPI_E_INVALID_HWPROFILE        0x800F0210L           [fail]

//
// MessageId: SPAPI_E_NO_DEVICE_SELECTED
//
// MessageText:
//
//  There is no device information element currently selected for this device information set.
//
#define SPAPI_E_NO_DEVICE_SELECTED       0x800F0211L           [fail]

//
// MessageId: SPAPI_E_DEVINFO_LIST_LOCKED
//
// MessageText:
//
//  The operation cannot be performed because the device information set is locked.
//
#define SPAPI_E_DEVINFO_LIST_LOCKED      0x800F0212L           [fail]

//
// MessageId: SPAPI_E_DEVINFO_DATA_LOCKED
//
// MessageText:
//
//  The operation cannot be performed because the device information element is locked.
//
#define SPAPI_E_DEVINFO_DATA_LOCKED      0x800F0213L           [fail]

//
// MessageId: SPAPI_E_DI_BAD_PATH
//
// MessageText:
//
//  The specified path does not contain any applicable device INFs.
//
#define SPAPI_E_DI_BAD_PATH              0x800F0214L           [fail]

//
// MessageId: SPAPI_E_NO_CLASSINSTALL_PARAMS
//
// MessageText:
//
//  No class installer parameters have been set for the device information set or element.
//
#define SPAPI_E_NO_CLASSINSTALL_PARAMS   0x800F0215L           [fail]

//
// MessageId: SPAPI_E_FILEQUEUE_LOCKED
//
// MessageText:
//
//  The operation cannot be performed because the file queue is locked.
//
#define SPAPI_E_FILEQUEUE_LOCKED         0x800F0216L           [fail]

//
// MessageId: SPAPI_E_BAD_SERVICE_INSTALLSECT
//
// MessageText:
//
//  A service installation section in this INF is invalid.
//
#define SPAPI_E_BAD_SERVICE_INSTALLSECT  0x800F0217L           [fail]

//
// MessageId: SPAPI_E_NO_CLASS_DRIVER_LIST
//
// MessageText:
//
//  There is no class driver list for the device information element.
//
#define SPAPI_E_NO_CLASS_DRIVER_LIST     0x800F0218L           [fail]

//
// MessageId: SPAPI_E_NO_ASSOCIATED_SERVICE
//
// MessageText:
//
//  The installation failed because a function driver was not specified for this device instance.
//
#define SPAPI_E_NO_ASSOCIATED_SERVICE    0x800F0219L           [fail]

//
// MessageId: SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE
//
// MessageText:
//
//  There is presently no default device interface designated for this interface class.
//
#define SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE 0x800F021AL           [fail]

//
// MessageId: SPAPI_E_DEVICE_INTERFACE_ACTIVE
//
// MessageText:
//
//  The operation cannot be performed because the device interface is currently active.
//
#define SPAPI_E_DEVICE_INTERFACE_ACTIVE  0x800F021BL           [fail]

//
// MessageId: SPAPI_E_DEVICE_INTERFACE_REMOVED
//
// MessageText:
//
//  The operation cannot be performed because the device interface has been removed from the system.
//
#define SPAPI_E_DEVICE_INTERFACE_REMOVED 0x800F021CL           [fail]

//
// MessageId: SPAPI_E_BAD_INTERFACE_INSTALLSECT
//
// MessageText:
//
//  An interface installation section in this INF is invalid.
//
#define SPAPI_E_BAD_INTERFACE_INSTALLSECT 0x800F021DL           [fail]

//
// MessageId: SPAPI_E_NO_SUCH_INTERFACE_CLASS
//
// MessageText:
//
//  This interface class does not exist in the system.
//
#define SPAPI_E_NO_SUCH_INTERFACE_CLASS  0x800F021EL           [fail]

//
// MessageId: SPAPI_E_INVALID_REFERENCE_STRING
//
// MessageText:
//
//  The reference string supplied for this interface device is invalid.
//
#define SPAPI_E_INVALID_REFERENCE_STRING 0x800F021FL           [fail]

//
// MessageId: SPAPI_E_INVALID_MACHINENAME
//
// MessageText:
//
//  The specified machine name does not conform to UNC naming conventions.
//
#define SPAPI_E_INVALID_MACHINENAME      0x800F0220L           [fail]

//
// MessageId: SPAPI_E_REMOTE_COMM_FAILURE
//
// MessageText:
//
//  A general remote communication error occurred.
//
#define SPAPI_E_REMOTE_COMM_FAILURE      0x800F0221L           [fail]

//
// MessageId: SPAPI_E_MACHINE_UNAVAILABLE
//
// MessageText:
//
//  The machine selected for remote communication is not available at this time.
//
#define SPAPI_E_MACHINE_UNAVAILABLE      0x800F0222L           [fail]

//
// MessageId: SPAPI_E_NO_CONFIGMGR_SERVICES
//
// MessageText:
//
//  The Plug and Play service is not available on the remote machine.
//
#define SPAPI_E_NO_CONFIGMGR_SERVICES    0x800F0223L           [fail]

//
// MessageId: SPAPI_E_INVALID_PROPPAGE_PROVIDER
//
// MessageText:
//
//  The property page provider registry entry is invalid.
//
#define SPAPI_E_INVALID_PROPPAGE_PROVIDER 0x800F0224L           [fail]

//
// MessageId: SPAPI_E_NO_SUCH_DEVICE_INTERFACE
//
// MessageText:
//
//  The requested device interface is not present in the system.
//
#define SPAPI_E_NO_SUCH_DEVICE_INTERFACE 0x800F0225L           [fail]

//
// MessageId: SPAPI_E_DI_POSTPROCESSING_REQUIRED
//
// MessageText:
//
//  The device's co-installer has additional work to perform after installation is complete.
//
#define SPAPI_E_DI_POSTPROCESSING_REQUIRED 0x800F0226L           [fail]

//
// MessageId: SPAPI_E_INVALID_COINSTALLER
//
// MessageText:
//
//  The device's co-installer is invalid.
//
#define SPAPI_E_INVALID_COINSTALLER      0x800F0227L           [fail]

//
// MessageId: SPAPI_E_NO_COMPAT_DRIVERS
//
// MessageText:
//
//  There are no compatible drivers for this device.
//
#define SPAPI_E_NO_COMPAT_DRIVERS        0x800F0228L           [fail]

//
// MessageId: SPAPI_E_NO_DEVICE_ICON
//
// MessageText:
//
//  There is no icon that represents this device or device type.
//
#define SPAPI_E_NO_DEVICE_ICON           0x800F0229L           [fail]

//
// MessageId: SPAPI_E_INVALID_INF_LOGCONFIG
//
// MessageText:
//
//  A logical configuration specified in this INF is invalid.
//
#define SPAPI_E_INVALID_INF_LOGCONFIG    0x800F022AL           [fail]

//
// MessageId: SPAPI_E_DI_DONT_INSTALL
//
// MessageText:
//
//  The class installer has denied the request to install or upgrade this device.
//
#define SPAPI_E_DI_DONT_INSTALL          0x800F022BL           [fail]

//
// MessageId: SPAPI_E_INVALID_FILTER_DRIVER
//
// MessageText:
//
//  One of the filter drivers installed for this device is invalid.
//
#define SPAPI_E_INVALID_FILTER_DRIVER    0x800F022CL           [fail]

//
// MessageId: SPAPI_E_ERROR_NOT_INSTALLED
//
// MessageText:
//
//  No installed components were detected.
//

#define SPAPI_E_ERROR_NOT_INSTALLED      0x800F1000L           [fail]


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\winmm.h ===
mask DWORD PlaySoundFlags
{     
#define SND_SYNC            0x00000000L  /* play synchronously (default) */
#define SND_ASYNC           0x00000001L  /* play asynchronously */
#define SND_NODEFAULT       0x00000002L  /* silence (!default) if sound not found */
#define SND_MEMORY          0x00000004L  /* pszSound points to a memory file */
#define SND_LOOP            0x00000008L  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x00000010L  /* don't stop any currently playing sound */

#define SND_PURGE           0x00000040L  /* purge non-static events for task */
#define SND_APPLICATION     0x00000080L  /* look for application specific association */

#define SND_NOWAIT	        0x00002000L /* don't wait if the driver is busy */
#define SND_ALIAS           0x00010000L /* name is a registry alias */
#define SND_FILENAME        0x00020000L /* name is file name */
#define SND_RESOURCE        0x00040000L /* name is resource name or atom */

#define SND_ALIAS_ID	    0x00100000L /* alias is a predefined ID */
};

mask DWORD WaveOutCapsFlags
{     
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010
#define WAVECAPS_SAMPLEACCURATE 0x0020
#define WAVECAPS_DIRECTSOUND    0x0040
};

mask DWORD WaveCapsFormatFlags
{     
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */
};

mask DWORD WAVE_OUT_OPEN_FLAGS
{
/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY         0x0001
#define  WAVE_ALLOWSYNC            0x0002
#define  WAVE_MAPPED               0x0004
#define  WAVE_FORMAT_DIRECT        0x0008
#define CALLBACK_WINDOW     0x000100000    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x000200000    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x000300000    /* dwCallback is a FARPROC */
};

value DWORD MMRESULT_VALUES
{
#define MMSYSERR_NOERROR      0
#define MMSYSERR_ERROR        1     [fail]
#define MMSYSERR_BADDEVICEID  2     [fail]
#define MMSYSERR_NOTENABLED   3     [fail]
#define MMSYSERR_ALLOCATED    4     [fail]
#define MMSYSERR_INVALHANDLE  5     [fail]
#define MMSYSERR_NODRIVER     6     [fail]
#define MMSYSERR_NOMEM        7     [fail]
#define MMSYSERR_NOTSUPPORTED 8     [fail]
#define MMSYSERR_BADERRNUM    9     [fail]
#define MMSYSERR_INVALFLAG    10     [fail]
#define MMSYSERR_INVALPARAM   11     [fail]
#define MMSYSERR_HANDLEBUSY   12     [fail]
#define MMSYSERR_INVALIDALIAS 13     [fail]
#define MMSYSERR_BADDB        14     [fail]
#define MMSYSERR_KEYNOTFOUND  15     [fail]
#define MMSYSERR_READERROR    16     [fail]
#define MMSYSERR_WRITEERROR   17     [fail]
#define MMSYSERR_DELETEERROR  18     [fail]
#define MMSYSERR_VALNOTFOUND  19     [fail]
#define MMSYSERR_NODRIVERCB   20     [fail]
#define MMSYSERR_LASTERROR    20     [fail]
};

value UINT PRODUCT_ID_VALUE
{
/* MM_MICROSOFT product IDs */
#define  MM_MIDI_MAPPER                     1       /*  Midi Mapper  */
#define  MM_WAVE_MAPPER                     2       /*  Wave Mapper  */
#define  MM_SNDBLST_MIDIOUT                 3       /*  Sound Blaster MIDI output port  */
#define  MM_SNDBLST_MIDIIN                  4       /*  Sound Blaster MIDI input port  */
#define  MM_SNDBLST_SYNTH                   5       /*  Sound Blaster internal synth  */
#define  MM_SNDBLST_WAVEOUT                 6       /*  Sound Blaster waveform output  */
#define  MM_SNDBLST_WAVEIN                  7       /*  Sound Blaster waveform input  */
#define  MM_ADLIB                           9       /*  Ad Lib Compatible synth  */
#define  MM_MPU401_MIDIOUT                  10      /*  MPU 401 compatible MIDI output port  */
#define  MM_MPU401_MIDIIN                   11      /*  MPU 401 compatible MIDI input port  */
#define  MM_PC_JOYSTICK                     12      /*  Joystick adapter  */
#define  MM_PCSPEAKER_WAVEOUT               13      /*  PC speaker waveform output  */
#define  MM_MSFT_WSS_WAVEIN                 14      /*  MS Audio Board waveform input  */
#define  MM_MSFT_WSS_WAVEOUT                15      /*  MS Audio Board waveform output  */
#define  MM_MSFT_WSS_FMSYNTH_STEREO         16      /*  MS Audio Board  Stereo FM synth  */
#define  MM_MSFT_WSS_MIXER                  17      /*  MS Audio Board Mixer Driver  */
#define  MM_MSFT_WSS_OEM_WAVEIN             18      /*  MS OEM Audio Board waveform input  */
#define  MM_MSFT_WSS_OEM_WAVEOUT            19      /*  MS OEM Audio Board waveform output  */
#define  MM_MSFT_WSS_OEM_FMSYNTH_STEREO     20      /*  MS OEM Audio Board Stereo FM Synth  */
#define  MM_MSFT_WSS_AUX                    21      /*  MS Audio Board Aux. Port  */
#define  MM_MSFT_WSS_OEM_AUX                22      /*  MS OEM Audio Aux Port  */
#define  MM_MSFT_GENERIC_WAVEIN             23      /*  MS Vanilla driver waveform input  */
#define  MM_MSFT_GENERIC_WAVEOUT            24      /*  MS Vanilla driver wavefrom output  */
#define  MM_MSFT_GENERIC_MIDIIN             25      /*  MS Vanilla driver MIDI in  */
#define  MM_MSFT_GENERIC_MIDIOUT            26      /*  MS Vanilla driver MIDI  external out  */
#define  MM_MSFT_GENERIC_MIDISYNTH          27      /*  MS Vanilla driver MIDI synthesizer  */
#define  MM_MSFT_GENERIC_AUX_LINE           28      /*  MS Vanilla driver aux (line in)  */
#define  MM_MSFT_GENERIC_AUX_MIC            29      /*  MS Vanilla driver aux (mic)  */
#define  MM_MSFT_GENERIC_AUX_CD             30      /*  MS Vanilla driver aux (CD)  */
#define  MM_MSFT_WSS_OEM_MIXER              31      /*  MS OEM Audio Board Mixer Driver  */
#define  MM_MSFT_MSACM                      32      /*  MS Audio Compression Manager  */
#define  MM_MSFT_ACM_MSADPCM                33      /*  MS ADPCM Codec  */
#define  MM_MSFT_ACM_IMAADPCM               34      /*  IMA ADPCM Codec  */
#define  MM_MSFT_ACM_MSFILTER               35      /*  MS Filter  */
#define  MM_MSFT_ACM_GSM610                 36      /*  GSM 610 codec  */
#define  MM_MSFT_ACM_G711                   37      /*  G.711 codec  */
#define  MM_MSFT_ACM_PCM                    38      /*  PCM converter  */

   // Microsoft Windows Sound System drivers

#define  MM_WSS_SB16_WAVEIN                 39      /*  Sound Blaster 16 waveform input  */
#define  MM_WSS_SB16_WAVEOUT                40      /*  Sound Blaster 16  waveform output  */
#define  MM_WSS_SB16_MIDIIN                 41      /*  Sound Blaster 16 midi-in  */
#define  MM_WSS_SB16_MIDIOUT                42      /*  Sound Blaster 16 midi out  */
#define  MM_WSS_SB16_SYNTH                  43      /*  Sound Blaster 16 FM Synthesis  */
#define  MM_WSS_SB16_AUX_LINE               44      /*  Sound Blaster 16 aux (line in)  */
#define  MM_WSS_SB16_AUX_CD                 45      /*  Sound Blaster 16 aux (CD)  */
#define  MM_WSS_SB16_MIXER                  46      /*  Sound Blaster 16 mixer device  */
#define  MM_WSS_SBPRO_WAVEIN                47      /*  Sound Blaster Pro waveform input  */
#define  MM_WSS_SBPRO_WAVEOUT               48      /*  Sound Blaster Pro waveform output  */
#define  MM_WSS_SBPRO_MIDIIN                49      /*  Sound Blaster Pro midi in  */
#define  MM_WSS_SBPRO_MIDIOUT               50      /*  Sound Blaster Pro midi out  */
#define  MM_WSS_SBPRO_SYNTH                 51      /*  Sound Blaster Pro FM synthesis  */
#define  MM_WSS_SBPRO_AUX_LINE              52      /*  Sound Blaster Pro aux (line in )  */
#define  MM_WSS_SBPRO_AUX_CD                53      /*  Sound Blaster Pro aux (CD)  */
#define  MM_WSS_SBPRO_MIXER                 54      /*  Sound Blaster Pro mixer  */

#define  MM_MSFT_WSS_NT_WAVEIN              55      /*  WSS NT wave in  */
#define  MM_MSFT_WSS_NT_WAVEOUT             56      /*  WSS NT wave out  */
#define  MM_MSFT_WSS_NT_FMSYNTH_STEREO      57      /*  WSS NT FM synth  */
#define  MM_MSFT_WSS_NT_MIXER               58      /*  WSS NT mixer  */
#define  MM_MSFT_WSS_NT_AUX                 59      /*  WSS NT aux  */

#define  MM_MSFT_SB16_WAVEIN                60      /*  Sound Blaster 16 waveform input  */
#define  MM_MSFT_SB16_WAVEOUT               61      /*  Sound Blaster 16  waveform output  */
#define  MM_MSFT_SB16_MIDIIN                62      /*  Sound Blaster 16 midi-in  */
#define  MM_MSFT_SB16_MIDIOUT               63      /*  Sound Blaster 16 midi out  */
#define  MM_MSFT_SB16_SYNTH                 64      /*  Sound Blaster 16 FM Synthesis  */
#define  MM_MSFT_SB16_AUX_LINE              65      /*  Sound Blaster 16 aux (line in)  */
#define  MM_MSFT_SB16_AUX_CD                66      /*  Sound Blaster 16 aux (CD)  */
#define  MM_MSFT_SB16_MIXER                 67      /*  Sound Blaster 16 mixer device  */
#define  MM_MSFT_SBPRO_WAVEIN               68      /*  Sound Blaster Pro waveform input  */
#define  MM_MSFT_SBPRO_WAVEOUT              69      /*  Sound Blaster Pro waveform output  */
#define  MM_MSFT_SBPRO_MIDIIN               70      /*  Sound Blaster Pro midi in  */
#define  MM_MSFT_SBPRO_MIDIOUT              71      /*  Sound Blaster Pro midi out  */
#define  MM_MSFT_SBPRO_SYNTH                72      /*  Sound Blaster Pro FM synthesis  */
#define  MM_MSFT_SBPRO_AUX_LINE             73      /*  Sound Blaster Pro aux (line in )  */
#define  MM_MSFT_SBPRO_AUX_CD               74      /*  Sound Blaster Pro aux (CD)  */
#define  MM_MSFT_SBPRO_MIXER                75      /*  Sound Blaster Pro mixer  */

#define  MM_MSFT_MSOPL_SYNTH                76      /* Yamaha OPL2/OPL3 compatible FM synthesis */

#define  MM_MSFT_VMDMS_LINE_WAVEIN          80     /* Voice Modem Serial Line Wave Input */
#define  MM_MSFT_VMDMS_LINE_WAVEOUT         81     /* Voice Modem Serial Line Wave Output */
#define  MM_MSFT_VMDMS_HANDSET_WAVEIN       82     /* Voice Modem Serial Handset Wave Input */
#define  MM_MSFT_VMDMS_HANDSET_WAVEOUT      83     /* Voice Modem Serial Handset Wave Output */
#define  MM_MSFT_VMDMW_LINE_WAVEIN          84     /* Voice Modem Wrapper Line Wave Input */
#define  MM_MSFT_VMDMW_LINE_WAVEOUT         85     /* Voice Modem Wrapper Line Wave Output */
#define  MM_MSFT_VMDMW_HANDSET_WAVEIN       86     /* Voice Modem Wrapper Handset Wave Input */
#define  MM_MSFT_VMDMW_HANDSET_WAVEOUT      87     /* Voice Modem Wrapper Handset Wave Output */
#define  MM_MSFT_VMDMW_MIXER                88     /* Voice Modem Wrapper Mixer */
#define  MM_MSFT_VMDM_GAME_WAVEOUT          89     /* Voice Modem Game Compatible Wave Device */
#define  MM_MSFT_VMDM_GAME_WAVEIN           90     /* Voice Modem Game Compatible Wave Device */

#define  MM_MSFT_ACM_MSNAUDIO               91     /* */
#define  MM_MSFT_ACM_MSG723                 92     /* */

#define  MM_MSFT_WDMAUDIO_WAVEOUT           100    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_WAVEIN            101    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_MIDIOUT           102    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_MIDIIN            103    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_MIXER             104    /* Generic id for WDM Audio drivers */
};

typedef UINT        MMVERSION;  /* major (high byte), minor (low byte) */
typedef UINT       *LPUINT;
typedef HANDLE      HWAVEOUT;
typedef HANDLE      HWAVEIN;
typedef UINT        MMRESULT;   /* error return code, 0 means no error */

typedef struct mmtime_tag
{
    UINT            wType;      /* indicates the contents of the union */
	DWORD       ms;         /* milliseconds */
	DWORD       sample;     /* samples */
	DWORD       cb;         /* byte count */
	DWORD       ticks;      /* ticks in MIDI stream */

} MMTIME;
typedef MMTIME *PMMTIME;
typedef MMTIME *NPMMTIME;
typedef MMTIME *LPMMTIME;

typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    DWORD       lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR;
typedef WAVEHDR *PWAVEHDR;
typedef WAVEHDR *NPWAVEHDR;
typedef WAVEHDR *LPWAVEHDR;

typedef struct tagWAVEOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[32];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSA;
typedef WAVEOUTCAPSA *PWAVEOUTCAPSA;
typedef WAVEOUTCAPSA *NPWAVEOUTCAPSA;
typedef WAVEOUTCAPSA *LPWAVEOUTCAPSA;


typedef struct tagWAVEOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[32];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSW;
typedef WAVEOUTCAPSW *PWAVEOUTCAPSW;
typedef WAVEOUTCAPSW  *NPWAVEOUTCAPSW;
typedef WAVEOUTCAPSW  *LPWAVEOUTCAPSW;


//typedef void (CALLBACK DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
typedef DWORD DRVCALLBACK;


typedef HWAVEIN *LPHWAVEIN;
typedef HWAVEOUT *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK *LPWAVECALLBACK;

value WORD FORMAT_TAG_VALUE
{
#define  WAVE_FORMAT_UNKNOWN    0x0000  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_ADPCM      0x0002  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_IEEE_FLOAT 0x0003  /*  Microsoft Corporation  */
                                        /*  IEEE754: range (+1, -1]  */
                                        /*  32-bit/64-bit format as defined by */
                                        /*  MSVC++ float/double type */
#define  WAVE_FORMAT_IBM_CVSD   0x0005  /*  IBM Corporation  */
#define  WAVE_FORMAT_ALAW       0x0006  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_MULAW      0x0007  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_OKI_ADPCM  0x0010  /*  OKI  */
#define  WAVE_FORMAT_DVI_ADPCM  0x0011  /*  Intel Corporation  */
#define  WAVE_FORMAT_IMA_ADPCM  0x0011 /*  Intel Corporation  */
#define  WAVE_FORMAT_MEDIASPACE_ADPCM   0x0012  /*  Videologic  */
#define  WAVE_FORMAT_SIERRA_ADPCM       0x0013  /*  Sierra Semiconductor Corp  */
#define  WAVE_FORMAT_G723_ADPCM 0x0014  /*  Antex Electronics Corporation  */
#define  WAVE_FORMAT_DIGISTD    0x0015  /*  DSP Solutions, Inc.  */
#define  WAVE_FORMAT_DIGIFIX    0x0016  /*  DSP Solutions, Inc.  */
#define  WAVE_FORMAT_DIALOGIC_OKI_ADPCM 0x0017  /*  Dialogic Corporation  */
#define  WAVE_FORMAT_MEDIAVISION_ADPCM  0x0018  /*  Media Vision, Inc. */
#define  WAVE_FORMAT_YAMAHA_ADPCM       0x0020  /*  Yamaha Corporation of America  */
#define  WAVE_FORMAT_SONARC     0x0021  /*  Speech Compression  */
#define  WAVE_FORMAT_DSPGROUP_TRUESPEECH        0x0022  /*  DSP Group, Inc  */
#define  WAVE_FORMAT_ECHOSC1    0x0023  /*  Echo Speech Corporation  */
#define  WAVE_FORMAT_AUDIOFILE_AF36     0x0024  /*    */
#define  WAVE_FORMAT_APTX       0x0025  /*  Audio Processing Technology  */
#define  WAVE_FORMAT_AUDIOFILE_AF10     0x0026  /*    */
#define  WAVE_FORMAT_DOLBY_AC2  0x0030  /*  Dolby Laboratories  */
#define  WAVE_FORMAT_GSM610     0x0031  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_MSNAUDIO   0x0032  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_ANTEX_ADPCME       0x0033  /*  Antex Electronics Corporation  */
#define  WAVE_FORMAT_CONTROL_RES_VQLPC  0x0034  /*  Control Resources Limited  */
#define  WAVE_FORMAT_DIGIREAL   0x0035  /*  DSP Solutions, Inc.  */
#define  WAVE_FORMAT_DIGIADPCM  0x0036  /*  DSP Solutions, Inc.  */
#define  WAVE_FORMAT_CONTROL_RES_CR10   0x0037  /*  Control Resources Limited  */
#define  WAVE_FORMAT_NMS_VBXADPCM       0x0038  /*  Natural MicroSystems  */
#define  WAVE_FORMAT_CS_IMAADPCM 0x0039 /* Crystal Semiconductor IMA ADPCM */
#define  WAVE_FORMAT_ECHOSC3     0x003A /* Echo Speech Corporation */
#define  WAVE_FORMAT_ROCKWELL_ADPCM     0x003B  /* Rockwell International */
#define  WAVE_FORMAT_ROCKWELL_DIGITALK  0x003C  /* Rockwell International */
#define  WAVE_FORMAT_XEBEC      0x003D  /* Xebec Multimedia Solutions Limited */
#define  WAVE_FORMAT_G721_ADPCM 0x0040  /*  Antex Electronics Corporation  */
#define  WAVE_FORMAT_G728_CELP  0x0041  /*  Antex Electronics Corporation  */
#define  WAVE_FORMAT_MPEG       0x0050  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_MPEGLAYER3 0x0055  /*  ISO/MPEG Layer3 Format Tag */
#define  WAVE_FORMAT_CIRRUS     0x0060  /*  Cirrus Logic  */
#define  WAVE_FORMAT_ESPCM      0x0061  /*  ESS Technology  */
#define  WAVE_FORMAT_VOXWARE    0x0062  /*  Voxware Inc  */
#define  WAVEFORMAT_CANOPUS_ATRAC       0x0063  /*  Canopus, co., Ltd.  */
#define  WAVE_FORMAT_G726_ADPCM 0x0064  /*  APICOM  */
#define  WAVE_FORMAT_G722_ADPCM 0x0065  /*  APICOM      */
#define  WAVE_FORMAT_DSAT       0x0066  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_DSAT_DISPLAY       0x0067  /*  Microsoft Corporation  */
#define  WAVE_FORMAT_SOFTSOUND  0x0080  /*  Softsound, Ltd.      */
#define  WAVE_FORMAT_RHETOREX_ADPCM     0x0100  /*  Rhetorex Inc  */
#define  WAVE_FORMAT_CREATIVE_ADPCM     0x0200  /*  Creative Labs, Inc  */
#define  WAVE_FORMAT_CREATIVE_FASTSPEECH8       0x0202  /*  Creative Labs, Inc  */
#define  WAVE_FORMAT_CREATIVE_FASTSPEECH10      0x0203  /*  Creative Labs, Inc  */
#define  WAVE_FORMAT_QUARTERDECK 0x0220 /*  Quarterdeck Corporation  */
#define  WAVE_FORMAT_FM_TOWNS_SND       0x0300  /*  Fujitsu Corp.  */
#define  WAVE_FORMAT_BTV_DIGITAL        0x0400  /*  Brooktree Corporation  */
#define  WAVE_FORMAT_OLIGSM     0x1000  /*  Ing C. Olivetti & C., S.p.A.  */
#define  WAVE_FORMAT_OLIADPCM   0x1001  /*  Ing C. Olivetti & C., S.p.A.  */
#define  WAVE_FORMAT_OLICELP    0x1002  /*  Ing C. Olivetti & C., S.p.A.  */
#define  WAVE_FORMAT_OLISBC     0x1003  /*  Ing C. Olivetti & C., S.p.A.  */
#define  WAVE_FORMAT_OLIOPR     0x1004  /*  Ing C. Olivetti & C., S.p.A.  */
#define  WAVE_FORMAT_LH_CODEC   0x1100  /*  Lernout & Hauspie  */
#define  WAVE_FORMAT_NORRIS     0x1400  /*  Norris Communications, Inc.  */

};

typedef struct waveformat_tag {
    FORMAT_TAG_VALUE    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT *PWAVEFORMAT;
typedef WAVEFORMAT *NPWAVEFORMAT;
typedef WAVEFORMAT *LPWAVEFORMAT;

typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT *LPPCMWAVEFORMAT;

typedef struct tWAVEFORMATEX
{
    WORD        wFormatTag;         /* format type */
    WORD        nChannels;          /* number of channels (i.e. mono, stereo...) */
    DWORD       nSamplesPerSec;     /* sample rate */
    DWORD       nAvgBytesPerSec;    /* for buffer estimation */
    WORD        nBlockAlign;        /* block size of data */
    WORD        wBitsPerSample;     /* number of bits per sample of mono data */
    WORD        cbSize;             /* the count in bytes of the size of */
				    /* extra information (after cbSize) */
} WAVEFORMATEX;
typedef WAVEFORMATEX *PWAVEFORMATEX;
typedef WAVEFORMATEX *NPWAVEFORMATEX;
typedef WAVEFORMATEX *LPWAVEFORMATEX;
typedef WAVEFORMATEX *LPCWAVEFORMATEX;

typedef struct tagWAVEINCAPSA {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    CHAR    szPname[32];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    WCHAR   szPname[32];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSW;

typedef WAVEINCAPSW *PWAVEINCAPSW;
typedef WAVEINCAPSW *NPWAVEINCAPSW;
typedef WAVEINCAPSW *LPWAVEINCAPSW;

category Multimedia:
module WINMM.DLL:

BOOL                    sndPlaySoundA(LPCSTR pszSound, PlaySoundFlags fuSound);
BOOL                    sndPlaySoundW(LPCWSTR pszSound, PlaySoundFlags fuSound);
BOOL                    PlaySound(LPCSTR pszSound, HMODULE hmod, PlaySoundFlags fdwSound);
BOOL                    PlaySoundA(LPCSTR pszSound, HMODULE hmod, PlaySoundFlags fdwSound);
BOOL                    PlaySoundW(LPCWSTR pszSound, HMODULE hmod, PlaySoundFlags fdwSound);

MMRESULT                waveOutGetDevCapsA(PRODUCT_ID_VALUE uDeviceID, [out] LPWAVEOUTCAPSA pwoc, UINT cbwoc);
MMRESULT_VALUES         waveOutGetDevCapsW(PRODUCT_ID_VALUE uDeviceID, [out] LPWAVEOUTCAPSW pwoc, UINT cbwoc);
MMRESULT_VALUES         waveOutGetVolume(HWAVEOUT hwo, [out] LPDWORD pdwVolume);
MMRESULT_VALUES         waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);
MMRESULT_VALUES         waveOutGetErrorTextA(MMRESULT_VALUES mmrError, [out] LPSTR pszText, UINT cchText);
MMRESULT_VALUES         waveOutGetErrorTextW(MMRESULT_VALUES mmrError, [out] LPWSTR pszText, UINT cchText);
MMRESULT_VALUES         waveOutOpen(LPHWAVEOUT phwo, PRODUCT_ID_VALUE uDeviceID, LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, WAVE_OUT_OPEN_FLAGS fdwOpen);
UINT                    waveOutGetNumDevs(); 
MMRESULT_VALUES         waveOutClose(HWAVEOUT hwo);
MMRESULT_VALUES         waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
MMRESULT_VALUES         waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
MMRESULT_VALUES         waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
MMRESULT_VALUES         waveOutPause(HWAVEOUT hwo);
MMRESULT_VALUES         waveOutRestart(HWAVEOUT hwo);
MMRESULT_VALUES         waveOutReset(HWAVEOUT hwo);
MMRESULT_VALUES         waveOutBreakLoop(HWAVEOUT hwo);
MMRESULT_VALUES         waveOutGetPosition(HWAVEOUT hwo, [out] LPMMTIME pmmt, UINT cbmmt);
MMRESULT_VALUES         waveOutGetPitch(HWAVEOUT hwo, [out] LPDWORD pdwPitch);
MMRESULT_VALUES         waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);
MMRESULT_VALUES         waveOutGetPlaybackRate(HWAVEOUT hwo, [out] LPDWORD pdwRate);
MMRESULT_VALUES         waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);
MMRESULT_VALUES         waveOutGetID(HWAVEOUT hwo, [out] LPUINT puDeviceID);
MMRESULT_VALUES         waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);


MMRESULT_VALUES         waveInGetDevCapsA(PRODUCT_ID_VALUE uDeviceID, [out] LPWAVEINCAPSA pwic, UINT cbwic);
MMRESULT_VALUES         waveInGetDevCapsW(PRODUCT_ID_VALUE uDeviceID, [out] LPWAVEINCAPSW pwic, UINT cbwic);
MMRESULT_VALUES         waveInGetErrorTextA(MMRESULT_VALUES mmrError, [out] LPSTR pszText, UINT cchText);
MMRESULT_VALUES         waveInGetErrorTextW(MMRESULT_VALUES mmrError, [out] LPWSTR pszText, UINT cchText);
MMRESULT_VALUES         waveInOpen(LPHWAVEIN phwi, PRODUCT_ID_VALUE uDeviceID, LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, WAVE_OUT_OPEN_FLAGS fdwOpen);
MMRESULT_VALUES         waveInClose(HWAVEIN hwi);
MMRESULT_VALUES         waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
MMRESULT_VALUES         waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
MMRESULT_VALUES         waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
MMRESULT_VALUES         waveInStart(HWAVEIN hwi);
MMRESULT_VALUES         waveInStop(HWAVEIN hwi);
MMRESULT_VALUES         waveInReset(HWAVEIN hwi);
MMRESULT_VALUES         waveInGetPosition(HWAVEIN hwi, [out] LPMMTIME pmmt, UINT cbmmt);
MMRESULT_VALUES         waveInGetID(HWAVEIN hwi, [out] LPUINT puDeviceID);

value DWORD MCIERROR
{
#define MCIERR_NO_ERROR                  0
#define MCIERR_UNRECOGNIZED_KEYWORD      259
#define MCIERR_UNRECOGNIZED_COMMAND      261
#define MCIERR_HARDWARE                  262
#define MCIERR_INVALID_DEVICE_NAME       263
#define MCIERR_OUT_OF_MEMORY             264
#define MCIERR_DEVICE_OPEN               265
#define MCIERR_CANNOT_LOAD_DRIVER        266
#define MCIERR_MISSING_COMMAND_STRING    267
#define MCIERR_PARAM_OVERFLOW            268
#define MCIERR_MISSING_STRING_ARGUMENT   269
#define MCIERR_BAD_INTEGER               270
#define MCIERR_PARSER_INTERNAL           271
#define MCIERR_DRIVER_INTERNAL           272
#define MCIERR_MISSING_PARAMETER         273
#define MCIERR_UNSUPPORTED_FUNCTION      274
#define MCIERR_FILE_NOT_FOUND            275
#define MCIERR_DEVICE_NOT_READY          276
#define MCIERR_INTERNAL                  277
#define MCIERR_DRIVER                    278
#define MCIERR_CANNOT_USE_ALL            279
#define MCIERR_MULTIPLE                  280
#define MCIERR_EXTENSION_NOT_FOUND       281
#define MCIERR_OUTOFRANGE                282
#define MCIERR_FLAGS_NOT_COMPATIBLE      284
#define MCIERR_FILE_NOT_SAVED            286
#define MCIERR_DEVICE_TYPE_REQUIRED      287
#define MCIERR_DEVICE_LOCKED             288
#define MCIERR_DUPLICATE_ALIAS           289
#define MCIERR_BAD_CONSTANT              290
#define MCIERR_MUST_USE_SHAREABLE        291
#define MCIERR_MISSING_DEVICE_NAME       292
#define MCIERR_BAD_TIME_FORMAT           293
#define MCIERR_NO_CLOSING_QUOTE          294
#define MCIERR_DUPLICATE_FLAGS           295
#define MCIERR_INVALID_FILE              296
#define MCIERR_NULL_PARAMETER_BLOCK      297
#define MCIERR_UNNAMED_RESOURCE          298
#define MCIERR_NEW_REQUIRES_ALIAS        299
#define MCIERR_NOTIFY_ON_AUTO_OPEN       300
#define MCIERR_NO_ELEMENT_ALLOWED        301
#define MCIERR_NONAPPLICABLE_FUNCTION    302
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN     303
#define MCIERR_FILENAME_REQUIRED         304
#define MCIERR_EXTRA_CHARACTERS          305
#define MCIERR_DEVICE_NOT_INSTALLED      306
#define MCIERR_GET_CD                    307
#define MCIERR_SET_CD                    308
#define MCIERR_SET_DRIVE                 309
#define MCIERR_DEVICE_LENGTH             310
#define MCIERR_DEVICE_ORD_LENGTH         311
#define MCIERR_NO_INTEGER                312
#define MCIERR_WAVE_OUTPUTSINUSE         320
#define MCIERR_WAVE_SETOUTPUTINUSE       321
#define MCIERR_WAVE_INPUTSINUSE          322
#define MCIERR_WAVE_SETINPUTINUSE        323
#define MCIERR_WAVE_OUTPUTUNSPECIFIED    324
#define MCIERR_WAVE_INPUTUNSPECIFIED     325
#define MCIERR_WAVE_OUTPUTSUNSUITABLE    326
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE  327
#define MCIERR_WAVE_INPUTSUNSUITABLE     328
#define MCIERR_WAVE_SETINPUTUNSUITABLE   329
#define MCIERR_SEQ_DIV_INCOMPATIBLE      336
#define MCIERR_SEQ_PORT_INUSE            337
#define MCIERR_SEQ_PORT_NONEXISTENT      338
#define MCIERR_SEQ_PORT_MAPNODEVICE      339
#define MCIERR_SEQ_PORT_MISCERROR        340
#define MCIERR_SEQ_TIMER                 341
#define MCIERR_SEQ_PORTUNSPECIFIED       342
#define MCIERR_SEQ_NOMIDIPRESENT         343
#define MCIERR_NO_WINDOW                 346
#define MCIERR_CREATEWINDOW              347
#define MCIERR_FILE_READ                 348
#define MCIERR_FILE_WRITE                349
#define MCIERR_NO_IDENTITY               350
#define MCIERR_CUSTOM_DRIVER_BASE        512
};

typedef UINT    MCIDEVICEID;    /* MCI device ID type */
typedef HANDLE      HTASK;

value UINT MCI_COMMAND_MESSAGE_VALUE
{
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856
};

mask DWORD MCI_SEND_COMMAND_MASK
{
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L
#define MCI_COMMAND1                    0x00000020L
#define MCI_COMMAND2                    0x00000040L
#define MCI_COMMAND3                    0x00000080L
#define MCI_COMMAND4                    0x00000100L
#define MCI_COMMAND5                    0x00000200L
#define MCI_COMMAND6                    0x00000400L
#define MCI_COMMAND7                    0x00000800L
#define MCI_COMMAND8                    0x00001000L
#define MCI_COMMAND9                    0x00002000L
#define MCI_COMMAND10                   0x00004000L
#define MCI_COMMAND11                   0x00008000L
};


MCIERROR                     mciSendCommandA(MCIDEVICEID mciId, MCI_COMMAND_MESSAGE_VALUE uMsg, MCI_SEND_COMMAND_MASK dwParam1, DWORD dwParam2);
MCIERROR                     mciSendCommandW(MCIDEVICEID mciId, MCI_COMMAND_MESSAGE_VALUE uMsg, MCI_SEND_COMMAND_MASK dwParam1, DWORD dwParam2);
MCIERROR                     mciSendStringA(LPCSTR lpstrCommand, [out] LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
MCIERROR                     mciSendStringW(LPCWSTR lpstrCommand, [out] LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
MCIDEVICEID                  mciGetDeviceIDA(LPCSTR pszDevice);
MCIDEVICEID                  mciGetDeviceIDW(LPCWSTR pszDevice);
MCIDEVICEID                  mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType );
MCIDEVICEID                  mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );
BOOL                         mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
BOOL                         mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);

BOOL                         mciSetYieldProc(MCIDEVICEID mciId, DWORD fpYieldProc, DWORD dwYieldData);
HTASK                        mciGetCreatorTask(MCIDEVICEID mciId);
DWORD                        mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
BOOL                         mciExecute(LPCSTR pszCommand);


/****************************************************************************

			Multimedia File I/O support

****************************************************************************/
typedef DWORD           FOURCC;         /* a four character code */
typedef char            HPSTR;          /* a huge version of LPSTR */
typedef DWORD           LPMMIOPROC;
typedef HANDLE          HMMIO;

typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */
	FOURCC          fccIOProc;      /* pointer to I/O procedure */
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
	UINT            wErrorRet;      /* place for error to be returned */
	HTASK           htask;          /* alternate local task */

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
	HPSTR           pchNext;        /* pointer to next byte to read/write */
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */
	HPSTR           pchEndWrite;    /* pointer to last byte to write */
	LONG            lBufOffset;     /* disk offset of start of buffer */

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */
	DWORD           dwReserved2;    /* reserved for MMIO use */
	HMMIO           hmmio;          /* handle to open file */
} MMIOINFO;

typedef MMIOINFO *PMMIOINFO;
typedef MMIOINFO *NPMMIOINFO;
typedef MMIOINFO *LPMMIOINFO;
typedef MMIOINFO *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */
	DWORD           cksize;         /* chunk size */
	FOURCC          fccType;        /* form type or list type */
	DWORD           dwDataOffset;   /* offset of data portion of chunk */
	DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO;
typedef MMCKINFO *PMMCKINFO;
typedef MMCKINFO *NPMMCKINFO;
typedef MMCKINFO *LPMMCKINFO;
typedef MMCKINFO *LPCMMCKINFO;

mask DWORD MMIOINFO_MASK
{
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */
};

value DWORD MMIO_SEEK_VALUE
{
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
};

value DWORD MMIO_RW_VALUE
{
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */
};

FOURCC          mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
FOURCC          mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
LPMMIOPROC      mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
LPMMIOPROC      mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO           mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, MMIOINFO_MASK fdwOpen);
HMMIO           mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, MMIOINFO_MASK fdwOpen);
MMRESULT        mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
MMRESULT        mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
FOURCC          mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC      mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO           mmioOpen(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
MMRESULT        mmioRename(LPCSTR pszFileName, LPCSTR pszNewFileName, MMIOINFO * pmmioinfo, DWORD fdwRename);
MMRESULT        mmioClose(HMMIO hmmio, UINT fuClose);
LONG            mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
LONG            mmioWrite(HMMIO hmmio, char * pch, LONG cch);
LONG            mmioSeek(HMMIO hmmio, LONG lOffset, MMIO_SEEK_VALUE iOrigin);
MMRESULT        mmioGetInfo(HMMIO hmmio, [out] LPMMIOINFO pmmioinfo, UINT fuInfo);
MMRESULT        mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
MMRESULT        mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer);
MMRESULT        mmioFlush(HMMIO hmmio, UINT fuFlush);
MMRESULT        mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, MMIO_RW_VALUE fuAdvance);
LRESULT         mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
MMRESULT        mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki, MMCKINFO * pmmckiParent, UINT fuDescend);
MMRESULT        mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
MMRESULT        mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\winsock2.h ===
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
//                              WinSock 2 API Set
//
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

category WinSock2:
module WS2_32.DLL:


typedef UINT* SOCKET;

typedef struct sockaddr 
{
        short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
}sockaddr;
typedef struct  hostent {
        LPSTR   h_name;           /* official name of host */
        LPSTR   * h_aliases;  /* alias list */
        short     h_addrtype;             /* host address type */
        short     h_length;               /* length of address */
        LPSTR   * h_addr_list; /* list of addresses */
}hostent;
typedef struct  servent {
        LPSTR   s_name;           /* official service name */
        LPSTR   * s_aliases;  /* alias list */
        short     s_port;                 /* port # */
        LPSTR   s_proto;          /* protocol to use */
}servent;
typedef struct  protoent {
        LPSTR   p_name;           /* official protocol name */
        LPSTR   * p_aliases;  /* alias list */
        short     p_proto;                /* protocol # */
}protoent;
typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription;
        char                    szSystemStatus;
        USHORT                  iMaxSockets;
        USHORT                  iMaxUdpDg;
        LPSTR                   lpVendorInfo;
} WSADATA, * LPWSADATA;
SOCKET

accept(
    SOCKET s,
    [out] sockaddr * addr,
    [out] int * addrlen
    );


int

bind(
    SOCKET s,
    sockaddr * name,
    int namelen
    );



int

closesocket(
    SOCKET s
    );



int

connect(
    SOCKET s,
    sockaddr * name,
    int namelen
    );



int

ioctlsocket(
    SOCKET s,
    long cmd,
    [out] int * argp
    );


int

getpeername(
    SOCKET s,
    [out] sockaddr * name,
    [out] int * namelen
    );


int

getsockname(
    SOCKET s,
    [out] sockaddr * name,
    [out] int * namelen
    );



int

getsockopt(
    SOCKET s,
    int level,
    int optname,
    [out] LPSTR optval,
    [out] int * optlen
    );


int

htonl(
    int hostlong
    );


int

htons(
    int hostshort
    );

int

inet_addr(
    LPSTR cp
    );

int

listen(
    SOCKET s,
    int backlog
    );


int

ntohl(
    int netlong
    );

int

ntohs(
    int netshort
    );


int

recv(
    SOCKET s,
    [out] LPSTR buf,
    int len,
    int flags
    );


int

recvfrom(
    SOCKET s,
    [out] LPSTR buf,
    int len,
    int flags,
    [out] sockaddr * from,
    [out] int * fromlen
    );


int

send(
    SOCKET s,
    LPSTR buf,
    int len,
    int flags
    );


int

sendto(
    SOCKET s,
    LPSTR buf,
    int len,
    int flags,
    sockaddr * to,
    int tolen
    );


int

setsockopt(
    SOCKET s,
    int level,
    int optname,
    LPSTR optval,
    int optlen
    );




int

shutdown(
    SOCKET s,
    int how
    );




SOCKET

socket(
    int af,
    int type,
    int protocol
    );


/* Database function prototypes */

hostent *
gethostbyaddr(
    LPSTR addr,
    int len,
    int type
    );
hostent *
gethostbyname(
    LPSTR name
    );

int
gethostname(
    [out] LPSTR name,
    int namelen
    );


servent *
getservbyport(
    int port,
    LPSTR proto
    );



servent *
getservbyname(
    LPSTR name,
    LPSTR proto
    );

protoent *
getprotobynumber(
    int number
    );

protoent *
getprotobyname(
    LPSTR name
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\dbg\x86\winext\manifest\winspool.h ===
category Printing:
module WINSPOOL.DRV:

mask DWORD PrinterEnum
{
#define PRINTER_ENUM_DEFAULT     0x00000001
#define PRINTER_ENUM_LOCAL       0x00000002
#define PRINTER_ENUM_CONNECTIONS 0x00000004
#define PRINTER_ENUM_FAVORITE    0x00000004
#define PRINTER_ENUM_NAME        0x00000008
#define PRINTER_ENUM_REMOTE      0x00000010
#define PRINTER_ENUM_SHARED      0x00000020
#define PRINTER_ENUM_NETWORK     0x00000040

#define PRINTER_ENUM_EXPAND      0x00004000
#define PRINTER_ENUM_CONTAINER   0x00008000

#define PRINTER_ENUM_ICON1       0x00010000
#define PRINTER_ENUM_ICON2       0x00020000
#define PRINTER_ENUM_ICON3       0x00040000
#define PRINTER_ENUM_ICON4       0x00080000
#define PRINTER_ENUM_ICON5       0x00100000
#define PRINTER_ENUM_ICON6       0x00200000
#define PRINTER_ENUM_ICON7       0x00400000
#define PRINTER_ENUM_ICON8       0x00800000
#define PRINTER_ENUM_HIDE        0x01000000
};

FailOnFalse [gle] EnumPrintersA(PrinterEnum   Flags,        // printer object types
                                LPSTR         Name,         // name of printer object
                                int           Level,        // information level
                                LPBYTE        pPrinterEnum, // printer information buffer
                                int           cbBuf,        // size of printer information buffer
                                [out] int*    pcbNeeded,    // bytes received or required
                                [out] int*    pcReturned);  // number of printers enumerated

FailOnFalse [gle] EnumPrintersW(PrinterEnum   Flags,        // printer object types
                                LPWSTR        Name,         // name of printer object
                                int           Level,        // information level
                                LPBYTE        pPrinterEnum, // printer information buffer
                                int           cbBuf,        // size of printer information buffer
                                [out] int*    pcbNeeded,    // bytes received or required
                                [out] int*    pcReturned);  // number of printers enumerated

FailOnFalse [gle] GetPrinterA(HPRINTER      hPrinter,
                              int           Level,
                              [out] LPBYTE  pPrinter,
                              int           cbBuf,
                              [out] int*    pcbNeeded);

FailOnFalse [gle] GetPrinterW(HPRINTER      hPrinter,
                              int           Level,
                              [out] LPBYTE  pPrinter,
                              int           cbBuf,
                              [out] int*    pcbNeeded);

mask DWORD PrinterAccessMode
{
#define PRINTER_ACCESS_ADMINISTER   0x00000004
#define PRINTER_ACCESS_USE          0x00000008
#define STANDARD_RIGHTS_REQUIRED    0x000F000

#define DELETE                      0x00010000
#define READ_CONTROL                0x00020000
#define WRITE_DAC                   0x00040000
#define WRITE_OWNER                 0x00080000
#define SYNCHRONIZE                 0x00100000
};

value DWORD SetPrinterCommand
{
#define PRINTER_CONTROL_PAUSE            1
#define PRINTER_CONTROL_RESUME           2
#define PRINTER_CONTROL_PURGE            3
#define PRINTER_CONTROL_SET_STATUS       4
};

FailOnFalse [gle] SetPrinterA(HPRINTER          hPrinter,
                              int               Level,
                              LPBYTE            pPrinter,
                              SetPrinterCommand Command);

FailOnFalse [gle] SetPrinterW(HPRINTER          hPrinter,
                              int               Level,
                              LPBYTE            pPrinter,
                              SetPrinterCommand Command);

HPRINTER [gle] AddPrinterA(LPSTR   pName,
                           int     Level,
                           LPBYTE  pPrinter);

HPRINTER [gle] AddPrinterW(LPWSTR  pName,
                           int     Level,
                           LPBYTE  pPrinter);

FailOnFalse [gle] AbortPrinter(HPRINTER hPrinter);

FailOnFalse [gle] AddFormA(HPRINTER hPrinter,
                           int      Level,
                           LPBYTE   pForm);

FailOnFalse [gle] AddFormW(HPRINTER hPrinter,
                           int      Level,
                           LPBYTE   pForm);

typedef struct _ADDJOB_INFO_1A {
    LPSTR   Path;
    DWORD   JobId;
} ADDJOB_INFO_1A, *LPADDJOB_INFO_1A;

typedef struct _ADDJOB_INFO_1W {
    LPWSTR  Path;
    DWORD   JobId;
} ADDJOB_INFO_1W, *LPADDJOB_INFO_1W;

FailOnFalse [gle] AddJobA(HPRINTER              hPrinter,
                          int                   Level,
                          [out] ADDJOB_INFO_1A* pData,
                          int                   cbBuf,
                          [out] LPDWORD         pcbNeeded);

FailOnFalse [gle] AddJobW(HPRINTER              hPrinter,
                          int                   Level,
                          [out] ADDJOB_INFO_1W* pData,
                          int                   cbBuf,
                          [out] LPDWORD         pcbNeeded);

typedef struct _MONITOR_INFO_2A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} MONITOR_INFO_2A, *LPMONITOR_INFO_2A;

typedef struct _MONITOR_INFO_2W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} MONITOR_INFO_2W, *LPMONITOR_INFO_2W;

FailOnFalse [gle] AddMonitorA(LPSTR             pName,
                              int               Level,
                              MONITOR_INFO_2A*  pMonitors);

FailOnFalse [gle] AddMonitorW(LPSTR             pName,
                              int               Level,
                              MONITOR_INFO_2A*  pMonitors);

FailOnFalse [gle] AddPortA(LPSTR   pName,
                           HWND    hWnd,
                           LPSTR   pMonitorName);

FailOnFalse [gle] AddPortW(LPWSTR  pName,
                           HWND    hWnd,
                           LPWSTR  pMonitorName);

FailOnFalse [gle] AddPrinterConnectionA(LPSTR pName);
FailOnFalse [gle] AddPrinterConnectionW(LPWSTR pName);

FailOnFalse [gle] AddPrinterDriverA(LPSTR        pName,
                                    int          Level,
                                    [out] LPBYTE pDriverInfo);

FailOnFalse [gle] AddPrinterDriverW(LPWSTR       pName,
                                    int          Level,
                                    [out] LPBYTE pDriverInfo);

mask DWORD AddPrinterDriverExFlags
{
#define APD_STRICT_UPGRADE               0x00000001
#define APD_STRICT_DOWNGRADE             0x00000002
#define APD_COPY_ALL_FILES               0x00000004
#define APD_COPY_NEW_FILES               0x00000008
#define APD_COPY_FROM_DIRECTORY          0x00000010
};

FailOnFalse [gle] AddPrinterDriverExA(LPSTR                     pName,
                                      int                       Level,
                                      [out] LPBYTE              pDriverInfo,
                                      AddPrinterDriverExFlags   dwFileCopyFlags);

FailOnFalse [gle] AddPrinterDriverExW(LPWSTR                    pName,
                                      int                       Level,
                                      [out] LPBYTE              pDriverInfo,
                                      AddPrinterDriverExFlags   dwFileCopyFlags);

FailOnFalse [gle] AddPrintProcessorA(LPSTR  pName,
                                     LPSTR  pEnvironment,
                                     LPSTR  pPathName,
                                     LPSTR  pPrintProcessorName);

FailOnFalse [gle] AddPrintProcessorW(LPWSTR pName,
                                     LPWSTR pEnvironment,
                                     LPWSTR pPathName,
                                     LPWSTR pPrintProcessorName);

FailOnFalse [gle] AddPrintProvidorA(LPSTR  pName,
                                    int    level,
                                    LPBYTE pProvidorInfo);

FailOnFalse [gle] AddPrintProvidorW(LPWSTR pName,
                                    int    level,
                                    LPBYTE pProvidorInfo);

FailOnFalse [gle] AdvancedDocumentPropertiesA(HWND              hWnd,
                                              HPRINTER          hPrinter,
                                              LPSTR             pDeviceName,
                                              [out] PDEVMODEA   pDevModeOutput,
                                              PDEVMODEA         pDevModeInput);

FailOnFalse [gle] AdvancedDocumentPropertiesW(HWND              hWnd,
                                              HPRINTER          hPrinter,
                                              LPWSTR            pDeviceName,
                                              [out] PDEVMODEW   pDevModeOutput,
                                              PDEVMODEW         pDevModeInput);

FailOnFalse [gle] ClosePrinter([da] HPRINTER hPrinter);

FailOnFalse [gle] ConfigurePortA(LPSTR   pName,
                                 HWND    hWnd,
                                 LPSTR   pPortName);

FailOnFalse [gle] ConfigurePortW(LPWSTR  pName,
                                 HWND    hWnd,
                                 LPWSTR  pPortName);

HPRINTER ConnectToPrinterDlg(HWND    hwnd,
                             DWORD   Flags);

FailOnFalse [gle] DeleteFormA(HPRINTER hPrinter,
                              LPSTR    pFormName);

FailOnFalse [gle] DeleteFormW(HPRINTER hPrinter,
                              LPWSTR   pFormName);

FailOnFalse [gle] DeleteMonitorA(LPSTR   pName,
                                 LPSTR   pEnvironment,
                                 LPSTR   pMonitorName);

FailOnFalse [gle] DeleteMonitorW(LPWSTR  pName,
                                 LPWSTR  pEnvironment,
                                 LPWSTR  pMonitorName);

FailOnFalse [gle] DeletePortA(LPSTR  pName,
                              HWND   hWnd,
                              LPSTR  pPortName);

FailOnFalse [gle] DeletePortW(LPWSTR pName,
                              HWND   hWnd,
                              LPWSTR pPortName);

FailOnFalse [gle] DeletePrinter(HPRINTER hPrinter);

FailOnFalse [gle] DeletePrinterConnectionA(LPSTR  pName);
FailOnFalse [gle] DeletePrinterConnectionW(LPWSTR pName);

FailOnFalse [gle] DeletePrinterDataA(HPRINTER hPrinter,
                                     LPSTR    pValueName);

FailOnFalse [gle] DeletePrinterDataW(HPRINTER hPrinter,
                                     LPWSTR   pValueName);

FailOnFalse [gle] DeletePrinterDataExA(HPRINTER hPrinter,
                                       LPSTR    pKeyName,
                                       LPSTR    pValueName);

FailOnFalse [gle] DeletePrinterDataExW(HPRINTER hPrinter,
                                       LPWSTR   pKeyName,
                                       LPWSTR   pValueName);

FailOnFalse [gle] DeletePrinterDriverA(LPSTR  pName,
                                       LPSTR  pEnvironment,
                                       LPSTR  pDriverName);

FailOnFalse [gle] DeletePrinterDriverW(LPWSTR pName,
                                       LPWSTR pEnvironment,
                                       LPWSTR pDriverName);
mask DWORD DPDFlags
{
// FLAGS for DeletePrinterDriverEx.
#define DPD_DELETE_UNUSED_FILES          0x00000001
#define DPD_DELETE_SPECIFIC_VERSION      0x00000002
#define DPD_DELETE_ALL_FILES             0x00000004
};

FailOnFalse [gle] DeletePrinterDriverExA(LPSTR    pName,
                                         LPSTR    pEnvironment,
                                         LPSTR    pDriverName,
                                         DPDFlags dwDeleteFlag,
                                         DWORD    dwVersionFlag);

FailOnFalse [gle] DeletePrinterDriverExW(LPWSTR   pName,
                                         LPWSTR   pEnvironment,
                                         LPWSTR   pDriverName,
                                         DPDFlags dwDeleteFlag,
                                         DWORD    dwVersionFlag);

WinError DeletePrinterKeyA(HPRINTER hPrinter, LPSTR  pKeyName);
WinError DeletePrinterKeyW(HPRINTER hPrinter, LPWSTR pKeyName);

FailOnFalse [gle] DeletePrintProcessorA(LPSTR  pName,
                                        LPSTR  pEnvironment,
                                        LPSTR  pPrintProcessorName);

FailOnFalse [gle] DeletePrintProcessorW(LPWSTR pName,
                                        LPWSTR pEnvironment,
                                        LPWSTR pPrintProcessorName);

FailOnFalse [gle] DeletePrintProvidorA(LPSTR  pName,
                                       LPSTR  pEnvironment,
                                       LPSTR  pPrintProvidorName);

FailOnFalse [gle] DeletePrintProvidorW(LPWSTR pName,
                                       LPWSTR pEnvironment,
                                       LPWSTR pPrintProvidorName);

mask DWORD DPFlags
{
#define DM_IN_BUFFER        8
#define DM_IN_PROMPT        4
#define DM_OUT_BUFFER       2
#define DM_OUT_DEFAULT      1
};

LongFailIfNeg1 [gle] DocumentPropertiesA(HWND            hWnd,
                                         HPRINTER        hPrinter,
                                         LPSTR           pDeviceName,
                                         [out] PDEVMODEA pDevModeOutput,
                                         PDEVMODEA       pDevModeInput,
                                         DPFlags         fMode);

LongFailIfNeg1 [gle] DocumentPropertiesW(HWND            hWnd,
                                         HPRINTER        hPrinter,
                                         LPWSTR          pDeviceName,
                                         [out] PDEVMODEW pDevModeOutput,
                                         PDEVMODEW       pDevModeInput,
                                         DPFlags         fMode);

FailOnFalse [gle] EndDocPrinter(HPRINTER hPrinter);

FailOnFalse [gle] EndPagePrinter(HPRINTER hPrinter);


mask DWORD FormInfoFlags
{
#define FORM_USER       0x00000000
#define FORM_BUILTIN    0x00000001
#define FORM_PRINTER    0x00000002
};

typedef struct _FORM_INFO_1A {
    FormInfoFlags Flags;
    LPSTR         pName;
    SIZE          Size;
    RECT          ImageableArea;
} FORM_INFO_1A, *LPFORM_INFO_1A, *PFORM_INFO_1A;

typedef struct _FORM_INFO_1W {
    FormInfoFlags Flags;
    LPWSTR        pName;
    SIZE          Size;
    RECT          ImageableArea;
} FORM_INFO_1W, *LPFORM_INFO_1W, *PFORM_INFO_1W;

FailOnFalse [gle] EnumFormsA(HPRINTER               hPrinter,
                             DWORD                  Level,
                             [out] LPFORM_INFO_1A   pForm,
                             int                    cbBuf,
                             [out] int*             pcbNeeded,
                             [out] int*             pcReturned);

FailOnFalse [gle] EnumFormsW(HPRINTER               hPrinter,
                             DWORD                  Level,
                             [out] LPFORM_INFO_1W   pForm,
                             int                    cbBuf,
                             [out] int*             pcbNeeded,
                             [out] int*             pcReturned);

FailOnFalse [gle] EnumJobsA(HPRINTER     hPrinter,
                            int          FirstJob,
                            int          NoJobs,
                            int          Level,
                            [out] LPBYTE pJob,
                            int          cbBuf,
                            [out] int*   pcbNeeded,
                            [out] int*   pcReturned);

FailOnFalse [gle] EnumJobsW(HPRINTER     hPrinter,
                            int          FirstJob,
                            int          NoJobs,
                            int          Level,
                            [out] LPBYTE pJob,
                            int          cbBuf,
                            [out] int*   pcbNeeded,
                            [out] int*   pcReturned);

FailOnFalse [gle] EnumMonitorsA(LPSTR        pName,
                                int          Level,
                                [out] LPBYTE pMonitors,
                                int          cbBuf,
                                [out] int*   pcbNeeded,
                                [out] int*   pcReturned);

FailOnFalse [gle] EnumMonitorsW(LPWSTR       pName,
                                int          Level,
                                [out] LPBYTE pMonitors,
                                int          cbBuf,
                                [out] int*   pcbNeeded,
                                [out] int*   pcReturned);

FailOnFalse [gle] EnumPortsA(LPSTR        pName,
                             int          Level,
                             [out] LPBYTE pPorts,
                             int          cbBuf,
                             [out] int*   pcbNeeded,
                             [out] int*   pcReturned);

FailOnFalse [gle] EnumPortsW(LPWSTR       pName,
                             int          Level,
                             [out] LPBYTE pPorts,
                             int          cbBuf,
                             [out] int*   pcbNeeded,
                             [out] int*   pcReturned);

FailOnFalse [gle] EnumPrinterDataA(HPRINTER             hPrinter,
                                   int                  dwIndex,
                                   [out] LPSTR          pValueName,
                                   int                  cbValueName,
                                   [out] int*           pcbValueName,
                                   [out] RegistryType*  pType,
                                   [out] LPBYTE         pData,
                                   int                  cbData,
                                   [out] int*           pcbData);

FailOnFalse [gle] EnumPrinterDataW(HPRINTER             hPrinter,
                                   int                  dwIndex,
                                   [out] LPWSTR         pValueName,
                                   int                  cbValueName,
                                   [out] int*           pcbValueName,
                                   [out] RegistryType*  pType,
                                   [out] LPBYTE         pData,
                                   int                  cbData,
                                   [out] int*           pcbData);

FailOnFalse [gle] EnumPrinterDataExA(HPRINTER       hPrinter,
                                     LPSTR          pKeyName,
                                     [out] LPBYTE   pEnumValues,
                                     int            cbEnumValues,
                                     [out] int*     pcbEnumValues,
                                     [out] int*     pnEnumValues);

FailOnFalse [gle] EnumPrinterDataExW(HPRINTER       hPrinter,
                                     LPWSTR         pKeyName,
                                     [out] LPBYTE   pEnumValues,
                                     int            cbEnumValues,
                                     [out] int*     pcbEnumValues,
                                     [out] int*     pnEnumValues);

FailOnFalse [gle] EnumPrinterDriversA(LPSTR         pName,
                                      LPSTR         pEnvironment,
                                      int           Level,
                                      [out] LPBYTE  pDriverInfo,
                                      int           cbBuf,
                                      [out] int*    pcbNeeded,
                                      [out] int*    pcReturned);

FailOnFalse [gle] EnumPrinterDriversW(LPWSTR        pName,
                                      LPWSTR        pEnvironment,
                                      int           Level,
                                      [out] LPBYTE  pDriverInfo,
                                      int           cbBuf,
                                      [out] int*    pcbNeeded,
                                      [out] int*    pcReturned);

WinError EnumPrinterKeyA(HPRINTER     hPrinter,
                         LPSTR        pKeyName,
                         [out] LPSTR  pSubkey,
                         int          cbSubkey,
                         [out] int*   pcbSubkey);

WinError EnumPrinterKeyW(HPRINTER     hPrinter,
                         LPWSTR       pKeyName,
                         [out] LPWSTR pSubkey,
                         int          cbSubkey,
                         [out] int*   pcbSubkey);

WinError GetPrinterDataA(HPRINTER            hPrinter,
                         LPSTR               pValueName,
                         [out] RegistryType* pType,
                         [out] LPBYTE        pData,
                         int                 nSize,
                         [out] int*          pcbNeeded);

WinError GetPrinterDataW(HPRINTER            hPrinter,
                         LPWSTR              pValueName,
                         [out] RegistryType* pType,
                         [out] LPBYTE        pData,
                         int                 nSize,
                         [out] int*          pcbNeeded);

WinError SetPrinterDataA(HPRINTER       hPrinter,
                         LPSTR          pValueName,
                         RegistryType   Type,
                         LPBYTE         pData,
                         int            cbData);

WinError SetPrinterDataW(HPRINTER       hPrinter,
                         LPWSTR         pValueName,
                         RegistryType   Type,
                         LPBYTE         pData,
                         int            cbData);

WinError SetPrinterDataExA(HPRINTER     hPrinter,
                           LPSTR        pKeyName,
                           LPSTR        pValueName,
                           RegistryType Type,
                           LPBYTE       pData,
                           int          cbData);

WinError SetPrinterDataExW(HPRINTER     hPrinter,
                           LPWSTR       pKeyName,
                           LPWSTR       pValueName,
                           RegistryType Type,
                           LPBYTE       pData,
                           int          cbData);

FailOnFalse [gle] GetDefaultPrinterA([out] LPSTR  pszBuffer,
                                     [out] int*   pcchBuffer);

FailOnFalse [gle] GetDefaultPrinterW([out] LPWSTR pszBuffer,
                                     [out] int*   pcchBuffer);

value DWORD DILevel
{
#define DRIVER_INFO_1       1
#define DRIVER_INFO_2       2
#define DRIVER_INFO_3       3
#define DRIVER_INFO_4       4
#define DRIVER_INFO_5       5
#define DRIVER_INFO_6       6
};

FailOnFalse [gle] GetPrinterDriverA( HPRINTER       hPrinter,
                                     LPSTR          pEnvironment,
                                     DILevel        Level,
                                     [out] LPBYTE   pDriverInfo,
                                     int            cbBuf,
                                     [out] LPDWORD  pcbNeeded);

FailOnFalse [gle] GetPrinterDriverW( HPRINTER       hPrinter,
                                     LPWSTR         pEnvironment,
                                     DILevel        Level,
                                     [out] LPBYTE   pDriverInfo,
                                     int            cbBuf,
                                     [out] LPDWORD  pcbNeeded);

FailOnFalse [gle] EnumPrintProcessorDatatypesA( LPSTR           pName,
                                                LPSTR           pPrintProcessorName,
                                                int             Level,
                                                [out] LPSTR     pDatatypes,
                                                int             cbBuf,
                                                [out] LPDWORD   pcbNeeded,
                                                [out] LPDWORD   pcReturned);

FailOnFalse [gle] EnumPrintProcessorDatatypesW( LPWSTR          pName,
                                                LPWSTR          pPrintProcessorName,
                                                int             Level,
                                                [out] LPWSTR    pDatatypes,
                                                int             cbBuf,
                                                [out] LPDWORD   pcbNeeded,
                                                [out] LPDWORD   pcReturned);

FailOnFalse [gle] EnumPrintProcessorsA( LPSTR          pName,
                                        LPSTR          pEnvironment,
                                        int            Level,
                                        [out] LPSTR    pPrintProcessorInfo,
                                        int            cbBuf,
                                        [out] LPDWORD  pcbNeeded,
                                        [out] LPDWORD  pcReturned);

FailOnFalse [gle] EnumPrintProcessorsW( LPWSTR         pName,
                                        LPWSTR         pEnvironment,
                                        int            Level,
                                        [out] LPWSTR   pPrintProcessorInfo,
                                        int            cbBuf,
                                        [out] LPDWORD  pcbNeeded,
                                        [out] LPDWORD  pcReturned);

FailOnFalse [gle] FindClosePrinterChangeNotification( HPRINTER hChange );

typedef struct _PRINTER_NOTIFY_OPTIONS_TYPE { 
  WORD      Type; 
  WORD      Reserved0; 
  DWORD     Reserved1; 
  DWORD     Reserved2; 
  DWORD     Count; 
  WORD      *pFields; 
} PRINTER_NOTIFY_OPTIONS_TYPE, *PPRINTER_NOTIFY_OPTIONS_TYPE; 

typedef struct _PRINTER_NOTIFY_OPTIONS { 
  DWORD  Version; 
  DWORD  Flags; 
  DWORD  Count; 
  PPRINTER_NOTIFY_OPTIONS_TYPE  pTypes; 
} PRINTER_NOTIFY_OPTIONS, *PPRINTER_NOTIFY_OPTIONS; 

mask DWORD PCFlags
{
#define PRINTER_CHANGE_ADD_PRINTER                  0x00000001
#define PRINTER_CHANGE_SET_PRINTER                  0x00000002
#define PRINTER_CHANGE_DELETE_PRINTER               0x00000004
#define PRINTER_CHANGE_FAILED_CONNECTION_PRINTER    0x00000008
#define PRINTER_CHANGE_PRINTER                      0x000000FF
#define PRINTER_CHANGE_ADD_JOB                      0x00000100
#define PRINTER_CHANGE_SET_JOB                      0x00000200
#define PRINTER_CHANGE_DELETE_JOB                   0x00000400
#define PRINTER_CHANGE_WRITE_JOB                    0x00000800
#define PRINTER_CHANGE_JOB                          0x0000FF00
#define PRINTER_CHANGE_ADD_FORM                     0x00010000
#define PRINTER_CHANGE_SET_FORM                     0x00020000
#define PRINTER_CHANGE_DELETE_FORM                  0x00040000
#define PRINTER_CHANGE_FORM                         0x00070000
#define PRINTER_CHANGE_ADD_PORT                     0x00100000
#define PRINTER_CHANGE_CONFIGURE_PORT               0x00200000
#define PRINTER_CHANGE_DELETE_PORT                  0x00400000
#define PRINTER_CHANGE_PORT                         0x00700000
#define PRINTER_CHANGE_ADD_PRINT_PROCESSOR          0x01000000
#define PRINTER_CHANGE_DELETE_PRINT_PROCESSOR       0x04000000
#define PRINTER_CHANGE_PRINT_PROCESSOR              0x07000000
#define PRINTER_CHANGE_ADD_PRINTER_DRIVER           0x10000000
#define PRINTER_CHANGE_SET_PRINTER_DRIVER           0x20000000
#define PRINTER_CHANGE_DELETE_PRINTER_DRIVER        0x40000000
#define PRINTER_CHANGE_PRINTER_DRIVER               0x70000000
#define PRINTER_CHANGE_TIMEOUT                      0x80000000
#define PRINTER_CHANGE_ALL                          0x7777FFFF
};

HPRINTER FindFirstPrinterChangeNotification( HPRINTER                hPrinter,
                                             PCFlags                 fdwFlags,
                                             int                     fdwOptions,
                                             PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions);

FailOnFalse [gle] FindNextPrinterChangeNotification( HPRINTER       hChange,
                                                     PDWORD         pdwChange,
                                                     LPVOID         pPrinterNotifyOptions,
                                                     [out] LPVOID   *ppPrinterNotifyInfo);

FailOnFalse [gle] FlushPrinter( HPRINTER       hPrinter,
                                LPVOID         pBuf,
                                int            cbBuf,
                                [out] LPDWORD  pcWritten,
                                DWORD          cSleep);

typedef struct _PRINTER_NOTIFY_INFO_DATA { 
  WORD      Type; 
  WORD      Field; 
  DWORD     Reserved; 
  DWORD     Id; 
  int       cbBuf; 
  LPVOID    pBuf; 
} PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA; 

typedef struct _PRINTER_NOTIFY_INFO { 
  DWORD     Version; 
  DWORD     Flags; 
  DWORD     Count; 
  PRINTER_NOTIFY_INFO_DATA  aData[1]; 
} PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO; 

FailOnFalse [gle] FreePrinterNotifyInfo( PPRINTER_NOTIFY_INFO pPrinterNotifyInfo );

FailOnFalse [gle] GetFormA( HPRINTER            hPrinter,
                            LPSTR               pFormName,
                            int                 Level,
                            [out] PFORM_INFO_1A pForm,
                            int                 cbBuf,
                            [out] LPDWORD       pcbNeeded);

FailOnFalse [gle] GetFormW( HPRINTER            hPrinter,
                            LPWSTR              pFormName,
                            int                 Level,
                            [out] PFORM_INFO_1W pForm,
                            int                 cbBuf,
                            [out] LPDWORD       pcbNeeded);

FailOnFalse [gle] GetJobA( HPRINTER        hPrinter,
                          DWORD           JobId,
                          int             Level,
                          [out] LPBYTE    pJob,
                          int             cbBuf,
                          [out] LPDWORD   pcbNeeded);

FailOnFalse [gle] GetJobW( HPRINTER        hPrinter,
                          DWORD           JobId,
                          int             Level,
                          [out] LPBYTE    pJob,
                          int             cbBuf,
                          [out] LPDWORD   pcbNeeded);

FailOnFalse [gle] GetPrinterDriverDirectoryA( LPSTR         pName,
                                              LPSTR         pEnvironment,
                                              int           Level, 
                                              [out] LPBYTE  pDriverDirectory,
                                              int           cbBuf,
                                              [out] LPDWORD pcbNeeded);

FailOnFalse [gle] GetPrinterDriverDirectoryW( LPWSTR        pName,
                                              LPWSTR        pEnvironment,
                                              int           Level, 
                                              [out] LPBYTE  pDriverDirectory,
                                              int           cbBuf,
                                              [out] LPDWORD pcbNeeded);

FailOnFalse [gle] GetPrintProcessorDirectoryA( LPSTR         pName,
                                               LPSTR         pEnvironment,
                                               int           Level,
                                               [out] LPBYTE  pPrintProcessorInfo,
                                               int           cbBuf, 
                                               [out] LPDWORD pcbNeeded);

FailOnFalse [gle] GetPrintProcessorDirectoryW( LPWSTR        pName,
                                               LPWSTR        pEnvironment,
                                               int           Level,
                                               [out] LPBYTE  pPrintProcessorInfo,
                                               int           cbBuf, 
                                               [out] LPDWORD pcbNeeded);

typedef struct _PRINTER_DEFAULTSA{
    LPSTR             pDatatype;
    LPDEVMODEA        pDevMode;
    PrinterAccessMode DesiredAccess;
} PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA;

typedef struct _PRINTER_DEFAULTSW{
    LPWSTR            pDatatype;
    LPDEVMODEW        pDevMode;
    PrinterAccessMode DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;

FailOnFalse [gle] OpenPrinterA(LPSTR               pPrinterName,
                               [out] HPRINTER*     phPrinter,
                               LPPRINTER_DEFAULTSA pDefault);

FailOnFalse [gle] OpenPrinterW(LPWSTR              pPrinterName,
                               [out] HPRINTER*     phPrinter,
                               LPPRINTER_DEFAULTSW pDefault);

FailOnFalse [gle] PrinterProperties( HWND       hWnd,
                                     HPRINTER   hPrinter);

FailOnFalse [gle] ReadPrinter( HPRINTER       hPrinter,
                               [out] LPVOID   pBuf,
                               int            cbBuf,
                               [out] LPDWORD  pNoBytesRead);
   
FailOnFalse [gle] ResetPrinterA( HPRINTER               hPrinter,
                                 PPRINTER_DEFAULTSA     pDefault);

FailOnFalse [gle] ResetPrinterW( HPRINTER               hPrinter,
                                 PPRINTER_DEFAULTSW     pDefault);

FailOnFalse [gle] ScheduleJob( HPRINTER     hPrinter,
                               DWORD        dwJobID);

FailOnFalse [gle] SetDefaultPrinterA( LPCSTR pszPrinter );

FailOnFalse [gle] SetDefaultPrinterW( LPCWSTR pszPrinter );

FailOnFalse [gle] SetFormA( HPRINTER        hPrinter,
                            LPSTR           pFormName,
                            int             Level,
                            PFORM_INFO_1A   pForm);

FailOnFalse [gle] SetFormW( HPRINTER        hPrinter,
                            LPWSTR          pFormName,
                            int             Level,
                            PFORM_INFO_1W   pForm);

FailOnFalse [gle] SetJobA( HPRINTER      hPrinter,
                           DWORD         JobId,
                           int           Level,
                           LPBYTE        pJob,
                           DWORD         Command);

FailOnFalse [gle] SetJobW( HPRINTER      hPrinter,
                           DWORD         JobId,
                           int           Level,
                           LPBYTE        pJob,
                           DWORD         Command);

typedef struct _PORT_INFO_3A { 
  DWORD dwStatus; 
  LPSTR pszStatus; 
  DWORD dwSeverity; 
} PORT_INFO_3A, *PPORT_INFO_3A; 

typedef struct _PORT_INFO_3W { 
  DWORD dwStatus; 
  LPWSTR pszStatus; 
  DWORD dwSeverity; 
} PORT_INFO_3W, *PPORT_INFO_3W; 

FailOnFalse [gle] SetPortA( LPSTR           pName,
                            LPSTR           pPortName,
                            DWORD           dwLevel,
                            PPORT_INFO_3A   pPortInfo);

FailOnFalse [gle] SetPortW( LPWSTR          pName,
                            LPWSTR          pPortName,
                            DWORD           dwLevel,
                            PPORT_INFO_3W   pPortInfo);

typedef struct _DOC_INFO_1A { 
  LPSTR pDocName; 
  LPSTR pOutputFile; 
  LPSTR pDatatype; 
} DOC_INFO_1A, *PDOC_INFO_1A; 

typedef struct _DOC_INFO_1W { 
  LPWSTR pDocName; 
  LPWSTR pOutputFile; 
  LPWSTR pDatatype; 
} DOC_INFO_1W, *PDOC_INFO_1W; 

FailOnFalse [gle] StartDocPrinterA( HPRINTER        hPrinter,
                                    int             Level,
                                    PDOC_INFO_1A    pDocInfo);

FailOnFalse [gle] StartDocPrinterW( HPRINTER        hPrinter,
                                    int             Level,
                                    PDOC_INFO_1W    pDocInfo);

FailOnFalse [gle] StartPagePrinter( HPRINTER hPrinter );

FailOnFalse [gle] WritePrinter( HPRINTER        hPrinter,
                                LPVOID          pBuf,
                                int             cbBuf,
                                [out] LPDWORD   pcWritten);


//
// The following functions are used to print
//


value DWORD DeviceCapabilitiesEnum
{
#define DC_FIELDS               1
#define DC_PAPERS               2
#define DC_PAPERSIZE            3
#define DC_MINEXTENT            4
#define DC_MAXEXTENT            5
#define DC_BINS                 6
#define DC_DUPLEX               7
#define DC_SIZE                 8
#define DC_EXTRA                9
#define DC_VERSION              10
#define DC_DRIVER               11
#define DC_BINNAMES             12
#define DC_ENUMRESOLUTIONS      13
#define DC_FILEDEPENDENCIES     14
#define DC_TRUETYPE             15
#define DC_PAPERNAMES           16
#define DC_ORIENTATION          17
#define DC_COPIES               18
#define DC_BINADJUST            19
#define DC_EMF_COMPLIANT        20
#define DC_DATATYPE_PRODUCED    21
#define DC_COLLATE              22
#define DC_MANUFACTURER         23
#define DC_MODEL                24
#define DC_PERSONALITY          25
#define DC_PRINTRATE            26
#define DC_PRINTRATEUNIT        27
#define DC_PRINTERMEM           28
#define DC_MEDIAREADY           29
#define DC_STAPLE               30
#define DC_PRINTRATEPPM         31
#define DC_COLORDEVICE          32
#define DC_NUP                  33
};

SpoolerError [gle] DeviceCapabilitiesA(LPSTR                  pszPrinterName,
                                       LPSTR                  pszPortName,
                                       DeviceCapabilitiesEnum capabilities,
                                       [out] LPSTR            pszOutput,
                                       DEVMODEA*              pDevMode);

SpoolerError [gle] DeviceCapabilitiesW(LPWSTR                 pszPrinterName,
                                       LPWSTR                 pszPortName,
                                       DeviceCapabilitiesEnum capabilities,
                                       [out] LPWSTR           pszOutput,
                                       DEVMODEW*              pDevMode);

module GDI32.DLL:

SpoolerError [gle] AbortDoc(HDC hdc);
SpoolerError [gle] EndDoc(HDC hdc);
SpoolerError [gle] EndPage(HDC hdc);


SpoolerError [gle] Escape(HDC           hdc,
                          GdiEscapeCode escapeCode,
                          int           cbSize,
                          LPSTR         pszInData,
                          [out] LPVOID  pOutData);

SpoolerError [gle] ExtEscape(HDC            hdc,
                             GdiEscapeCode  escapeCode,
                             int            cbInput,
                             LPSTR          pszInData,
                             int            cbOutput,
                             [out] LPSTR    lpszOutData);

typedef LPVOID ABORTPROC;

SpoolerError [gle] SetAbortProc(HDC       hdc,
                                ABORTPROC pfnAbort);

value DWORD DocInfoType
{
#define DI_NONE                     0x00000000
#define DI_APPBANDING               0x00000001
#define DI_ROPS_READ_DESTINATION    0x00000002
};

typedef struct _DOCINFOA {
    int      cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;
    LPCSTR   lpszDatatype;
    DocInfoType    fwType;
} DOCINFOA, *LPDOCINFOA;

typedef struct _DOCINFOW {
    int      cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;
    LPCWSTR  lpszDatatype;
    DocInfoType    fwType;
} DOCINFOW, *LPDOCINFOW;

SpoolerError [gle] StartDocA(HDC       hdc,
                             DOCINFOA* pDocInfo);

SpoolerError [gle] StartDocW(HDC       hdc,
                             DOCINFOW* pDocInfo);

SpoolerError [gle] StartPage(HDC hdc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\enlistment\FileReconcile.cs ===
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using Microsoft.XmlDiffPatch;
using System.Diagnostics;

namespace XmlDiffTest
{
    class Program
    {
        static void Main(string[] args)
        {
            string oldFile = args[0];
            string newFile = args[1];
            string outputFile = args[2];

            ScrubFile(oldFile, newFile, outputFile);
        }

        static void ScrubFile(string oldFileName, string newFileName, string outputFileName)
        {
            XmlDiff diff = new XmlDiff(XmlDiffOptions.IgnoreChildOrder | XmlDiffOptions.IgnoreComments | XmlDiffOptions.IgnoreWhitespace);
            diff.Algorithm = XmlDiffAlgorithm.Precise;

            XmlDocument oldDoc = new XmlDocument();
            XmlDocument newDoc = new XmlDocument();
            oldDoc.Load(oldFileName);
            newDoc.Load(newFileName);
            XmlNamespaceManager oldNsManager = new XmlNamespaceManager(oldDoc.NameTable);
            oldNsManager.AddNamespace("x", oldDoc.DocumentElement.NamespaceURI);

            XmlNamespaceManager newNsManager = new XmlNamespaceManager(newDoc.NameTable);
            newNsManager.AddNamespace("x", newDoc.DocumentElement.NamespaceURI);

            XmlNodeList oldNodeList = oldDoc.SelectNodes("/x:database/x:table/x:release/x:row", oldNsManager);
            XmlNodeList newNodeList = newDoc.SelectNodes("/x:database/x:table/x:release/x:row", newNsManager);

            List<XmlNode> keepers = new List<XmlNode>();
            foreach (XmlNode newNode in newNodeList)
            {
                bool foundNode = false;
                foreach (XmlNode oldNode in oldNodeList)
                {
                    if (diff.Compare(oldNode, newNode))
                    {
                        foundNode = true;
                        break;
                    }
                }

                XmlAttribute attr = newNode.Attributes["_qfe"];
                if (attr != null && attr.Value.ToLower().Trim() == "qfeg")
                    foundNode = false;

                if (!foundNode)
                    keepers.Add(newNode);
            }

            XmlNode releaseNode = newDoc.SelectSingleNode("/x:database/x:table/x:release", oldNsManager);
            foreach (XmlNode n in newNodeList)
            {
                releaseNode.RemoveChild(n);
            }

            foreach (XmlNode newNode in keepers)
            {
                newNode.Attributes.Remove(newNode.Attributes["_qfe"]);
                releaseNode.AppendChild(newNode);
            }

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.IndentChars = "\t";
            settings.OmitXmlDeclaration = true;
            using (XmlWriter output = XmlTextWriter.Create(outputFileName, settings))
            {
                newDoc.Save(output);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\ADT\src\ProcessTestResults\Util.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;
using System.Text.RegularExpressions;

namespace ProcessTestResults
{
    static class Util
    {
        #region File Manipulation Methods

        /// <summary>
        /// Deletes a file if it exists
        /// </summary>
        /// <param name="filepath">Filename</param>
        public static void DeleteExistingFile(string filepath)
        {
            if (File.Exists(filepath))
            {
                File.Delete(filepath);
            }
        }

        /// <summary>
        /// Throws an exception if a file does not exist
        /// </summary>
        /// <param name="filepath">Filename</param>
        public static void CheckForExistingFile(string filepath)
        {
            if (!File.Exists(filepath))
            {
                throw new Exception("This source file does not exist: " + filepath);
            }
        }

        #endregion

        public static string GetResponseStatus(string responseXml)
        {
            string result = "Red";
            try
            {
                if (!String.IsNullOrEmpty(responseXml))
                {
                    XmlDocument doc = new XmlDocument();
                    doc.LoadXml(responseXml);
                    XmlNodeList nodes = doc.SelectNodes("/Healthcheck");
                    foreach (XmlNode node in nodes)
                    {
                        foreach (XmlNode attribute in node.Attributes)
                        {
                            if (attribute.Name.Equals("HealthStatus"))
                            {
                                result = attribute.InnerText;
                                break;
                            }
                        }
                        break;
                    }
                }
            }
            catch (System.Xml.XmlException)
            {
                // Allow the exception to happen, but mark it red
            }
            return result;
        }

        public static void AddStatusAttribute(XmlDocument doc, XmlNode node, string status)
        {
            XmlAttribute attrib = doc.CreateAttribute("HealthStatus");
            attrib.Value = status;
            node.Attributes.Append(attrib);
        }

        public static void MergeXmlResults(string srcPath1, string srcPath2, string injectedHeading, string dstPath)
        {
            // Initial Filepath checks
            CheckForExistingFile(srcPath1);
            CheckForExistingFile(srcPath2);

            string srcContent1 = string.Empty;
            string srcContent2 = string.Empty;

            //read in the first file
            using (StreamReader reader = new StreamReader(srcPath1))
            {
                srcContent1 = reader.ReadToEnd();
            }

            //read in the second file if it's there
            if (File.Exists(srcPath2))
            {
                using (StreamReader reader2 = new StreamReader(srcPath2))
                {
                    srcContent2 = reader2.ReadToEnd();
                }
            }

            //trim the xml version info off of the second file contents if it's there
            if (srcContent2.StartsWith("<?xml version"))
            {
                int iCutoff = srcContent2.IndexOf('>');
                srcContent2 = srcContent2.Substring(iCutoff + 1);
            }

            if (srcContent2.StartsWith("\r\n<?xml-stylesheet"))
            {
                int iCutoff = srcContent2.IndexOf('>');
                srcContent2 = srcContent2.Substring(iCutoff + 1);
            }

            if (srcContent2.StartsWith("<SystemCheckResults"))
            {
                int iCutoff = srcContent2.IndexOf('>');
                srcContent2 = srcContent2.Substring(iCutoff + 1);
            }

            if (srcContent2.StartsWith("\r\n<SystemCheckResults"))
            {
                int iCutoff = srcContent2.IndexOf('>');
                srcContent2 = srcContent2.Substring(iCutoff + 1);
            }

            if (srcContent2.EndsWith("</SystemCheckResults>"))
            {
                int iCutoff = srcContent2.IndexOf("</SystemCheckResults>");
                srcContent2 = srcContent2.Substring(0, iCutoff);
            }

            //put the two file contents together into one string
            if (injectedHeading.Length == 0)
            {
                srcContent1 += "\r\n" + srcContent2 + "\r\n";
            }
            else
            {
                srcContent1 += "\r\n<" + injectedHeading + ">\r\n" + srcContent2 + "\r\n</" + injectedHeading + ">\r\n";
            }

            //write the giant xml string out to the results file
            using (StreamWriter writer = new StreamWriter(dstPath))
            {
                writer.Write(srcContent1);
            }
        }

        public static void ScrubXmlFile(string file)
        {
            //Backup file before we remove bad text
            File.Copy(file, String.Format("{0}.orig", file), true);

            //Remove illegal character sequences
            string tmpContents = File.ReadAllText(file, Encoding.UTF8);
            string pattern = "[\x00-\x1F]";
            Regex regex = new Regex(pattern, RegexOptions.IgnoreCase);
            if (regex.IsMatch(tmpContents))
            {
                tmpContents = regex.Replace(tmpContents, String.Empty);
                File.WriteAllText(file, tmpContents, Encoding.UTF8);
            }
            tmpContents = string.Empty;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\ADT\src\ProcessTestResults\Program.cs ===
using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Xsl;

namespace ProcessTestResults
{
    class Program
    {
        static int Main(string[] args)
        {
            try
            {
                // Print Usage in invalid args or help
                string helpMsg = "Usage: ProcessTestResults <path to results directory>";
                if (args.Length != 1 || (args[0].Contains("/?") || args[0].Contains("-?")))
                {
                    System.Console.WriteLine(helpMsg);
                    return -1;
                }

                // Process Results
                ResultProcessor.ProcessResults(args[0]);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                Console.WriteLine(ex.Message);
            }
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\ADT\src\ProcessTestResults\ResultProcessor.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;

namespace ProcessTestResults
{
    static class ResultProcessor
    {
        /// <summary>
        /// Process the Test Results
        /// </summary>
        /// <param name="resultsDir">Results Directory</param>
        public static void ProcessResults(string resultsDir)
        {
            // Check the results directory
            if ((resultsDir == null) || (resultsDir == String.Empty))
            {
                resultsDir = Directory.GetCurrentDirectory();
            }
            if (!Directory.Exists(resultsDir))
            {
                throw new Exception("This directory does not exist: " + resultsDir);
            }

            // Initialize filepaths
            string xmlResultsPath = Path.Combine(resultsDir, "All_Test_Results.xml");
            string healthcheckXmlResultsPath = Path.Combine(resultsDir, "healthchecks");
            string fullHealthcheckXmlResultsPath = Path.Combine(resultsDir, "fullhealthchecks.xml");

            Util.DeleteExistingFile(xmlResultsPath);
            Util.DeleteExistingFile(fullHealthcheckXmlResultsPath);
            mergeHealthchecks(resultsDir, "healthchecks*.xml", fullHealthcheckXmlResultsPath);
            addHealthStatus(fullHealthcheckXmlResultsPath);
            ScrubHealthCheckInfo(resultsDir, "healthchecks*.xml");
            CreateXmlResults(resultsDir, xmlResultsPath, "healthchecks", fullHealthcheckXmlResultsPath);
        }

        #region Private Methods

        /// <summary>
        /// Merge Healthcheck results together into one file
        /// </summary>
        /// <param name="resultsDir">Results directory</param>
        /// <param name="pattern">Healthcheck XML filename pattern</param>
        /// <param name="resultsPath">Full healthchecks file</param>
        private static void mergeHealthchecks(string resultsDir, string pattern, string resultsPath)
        {
            // merge health results into one big xml
            XmlDocument mergedDoc = new XmlDocument();

            // Add instruction header for XSLT
            XmlProcessingInstruction profilePI = mergedDoc.CreateProcessingInstruction("xml-stylesheet", "href='SystemCheckHTML.xslt' type='text/xsl'");
            mergedDoc.AppendChild(profilePI);
            XmlNode outRoot = mergedDoc.CreateElement("SystemCheckResults", "http://tempuri.org/SystemCheck.xsd");

            // Search through healthcheck files and append them to the full health check file
            string[] files = Directory.GetFiles(resultsDir, pattern);
            foreach (string file in files)
            {
                XmlDocument xmlHealthcheck = new XmlDocument();

                xmlHealthcheck.Load(file); // Throws if the XML is not well-formed
                XmlNodeList healthcheckList = xmlHealthcheck.SelectNodes("//*[local-name()='SystemCheckResults']");
                foreach (XmlNode healthcheckResult in healthcheckList)
                {
                    outRoot.InnerXml += healthcheckResult.InnerXml;
                }
            }

            // Save out the file
            mergedDoc.AppendChild(outRoot);
            mergedDoc.Save(resultsPath);
        }

        private static void addHealthStatus(string file)
        {
            try
            {
                XmlDocument doc = new XmlDocument();
                Console.WriteLine(String.Format("Loading file {0}", file));
                doc.Load(file);
                Console.WriteLine(String.Format("Loading file {0}---complete", file));

                XmlNodeList nodes = doc.SelectNodes("//CheckResult");
                foreach (XmlNode node in nodes)
                {
                    XmlNodeList childNodes = node.ChildNodes;
                    foreach (XmlNode child in childNodes)
                    {
                        if (child.Name.Equals("Response"))
                        {
                            XmlNodeList responseNodes = child.ChildNodes;
                            foreach (XmlNode responseChild in responseNodes)
                            {
                                if (responseChild.Name.Equals("ResponseText"))
                                {
                                    string responseText = responseChild.InnerText;
                                    string result = Util.GetResponseStatus(responseText);
                                    Util.AddStatusAttribute(doc, node, result);
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }
                Console.WriteLine(String.Format("Saving file {0}", file));
                doc.Save(file);
            }
            catch (System.Exception ex)
            {
                Console.WriteLine("Exception in AddHealthStatus: " + ex);
            }
        }

        private static void ScrubHealthCheckInfo(string resultsDir, string healthcheckXmlResultsPath)
        {
            string[] files = Directory.GetFiles(resultsDir, healthcheckXmlResultsPath);
            foreach (string file in files)
            {
                string srcContent1 = string.Empty;
                string srcContent2 = string.Empty;
                string srcContent3 = string.Empty;

                //read in the first file
                using (StreamReader reader = new StreamReader(file))
                {
                    srcContent1 = reader.ReadToEnd();
                }

                int startingIndex = srcContent1.IndexOf("<SystemCheckResults");
                srcContent2 = srcContent1.Substring(startingIndex);

                int endingIndex = srcContent1.IndexOf(">", startingIndex);
                srcContent3 = srcContent1.Substring(endingIndex + 1);

                //put the two file contents together into one string
                srcContent1 = String.Format("<SystemCheckResults>\r\n{0}", srcContent3);

                //write the giant xml string out to the results file
                using (StreamWriter writer = new StreamWriter(file))
                {
                    writer.Write(srcContent1);
                }

                addHealthStatus(file);

            }
        }

        private static void CreateXmlResults(string srcDir, string dstFilePath, string healthcheckXmlFilenamePrefix, string fullHealthcheckXmlResultsPath)
        {
            // merge nunit and testapi results into one big xml
            XmlDocument mergedXml = new XmlDocument();

            XmlNode outRoot = mergedXml.CreateElement("tblTestCaseResults");

            string[] resfiles = Directory.GetFiles(srcDir, "*.xml");
            foreach (string resfile in resfiles)
            {
                try
                {
                    // Check that the file exists and is not the same as the output file
                    if (File.Exists(resfile) && (0 != String.Compare(Path.GetFileName(dstFilePath), Path.GetFileName(resfile), true)))
                    {
                        // Check that the file is not the full health results
                        if (0 == String.Compare(Path.GetFileName(fullHealthcheckXmlResultsPath), Path.GetFileName(resfile), true))
                        {
                            continue;
                        }

                        // Check that the file is not the Octopus.xml file
                        if (0 == String.Compare(Path.GetFileName("Octopus.xml"), Path.GetFileName(resfile), true))
                        {
                            continue;
                        }
                        XmlDocument xmlWellFormed = new XmlDocument();
                        try
                        {
                            xmlWellFormed.Load(resfile); // Throws if the XML is not well-formed
                        }
                        catch (XmlException)
                        {
                            // message probably contains binary data
                            Util.ScrubXmlFile(resfile);
                            xmlWellFormed.Load(resfile); // try to load again
                        }

                        if (Path.GetFileName(resfile).StartsWith(healthcheckXmlFilenamePrefix))
                        {
                            XmlNode healthcheckFileNode = mergedXml.CreateElement("healthcheck-file");
                            XmlAttribute healthcheckFileNameAttribute = mergedXml.CreateAttribute("Filename");
                            healthcheckFileNameAttribute.Value = resfile;
                            healthcheckFileNode.Attributes.Append(healthcheckFileNameAttribute);

                            XmlNodeList healthcheckList = xmlWellFormed.SelectNodes("SystemCheckResults");
                            foreach (XmlNode healthcheckResult in healthcheckList)
                            {
                                healthcheckFileNode.InnerXml += healthcheckResult.InnerXml;
                            }
                            outRoot.AppendChild(healthcheckFileNode);
                        }
                        else if (0 == String.Compare(Path.GetFileName(resfile), "fullcomparison.xml", true))
                        {
                            XmlNode comparisonFileNode = mergedXml.CreateElement("comparison-file");
                            XmlAttribute comparisonFileNameAttribute = mergedXml.CreateAttribute("Filename");
                            comparisonFileNameAttribute.Value = resfile;
                            comparisonFileNode.Attributes.Append(comparisonFileNameAttribute);

                            // Generate Comparison Inner XML
                            XmlNodeList actionNodes = xmlWellFormed.SelectNodes("DeploymentComparison/Server/Action");
                            foreach (XmlNode actionNode in actionNodes)
                            {
                                // Add node to the comparison
                                XmlNode profileResult = mergedXml.CreateElement("ProfileResult");
                                TimeSpan timeDifference = TimeSpan.Zero;
                                if (actionNode.Attributes["Difference"].Value != "N/A")
                                {
                                    timeDifference = TimeSpan.Parse(actionNode.Attributes["Difference"].Value);
                                }
                                XmlAttribute significantAttribute = mergedXml.CreateAttribute("Significant");
                                if (timeDifference < TimeSpan.Parse("-00:01:00") ||
                                    timeDifference > TimeSpan.Parse("00:00:30"))
                                {
                                    significantAttribute.Value = "true";
                                }
                                else
                                {
                                    significantAttribute.Value = "false";
                                }
                                profileResult.Attributes.Append(significantAttribute);
                                XmlAttribute statusAttribute = mergedXml.CreateAttribute("Status");
                                if (timeDifference < TimeSpan.Parse("00:00:05"))
                                {
                                    statusAttribute.Value = "Green";
                                }
                                else if (timeDifference <= TimeSpan.Parse("00:00:30"))
                                {
                                    statusAttribute.Value = "Yellow";
                                }
                                else
                                {
                                    statusAttribute.Value = "Red";
                                }
                                profileResult.Attributes.Append(statusAttribute);

                                XmlNode profileAction = mergedXml.CreateElement("Action");
                                profileAction.InnerText = actionNode.Attributes["Name"].Value;
                                profileResult.AppendChild(profileAction);

                                XmlNode profileDuration = mergedXml.CreateElement("Duration");
                                profileDuration.InnerText = actionNode.Attributes["DurationA"].Value;
                                profileResult.AppendChild(profileDuration);

                                XmlNode profileBaseline = mergedXml.CreateElement("Baseline");
                                profileBaseline.InnerText = actionNode.Attributes["DurationB"].Value;
                                profileResult.AppendChild(profileBaseline);

                                comparisonFileNode.AppendChild(profileResult);
                            }

                            outRoot.AppendChild(comparisonFileNode);
                        }
                        else
                        {
                            XmlNode testResultsFileNode = mergedXml.CreateElement("test-results-file");
                            XmlAttribute healthcheckFileNameAttribute = mergedXml.CreateAttribute("Filename");
                            healthcheckFileNameAttribute.Value = resfile;
                            testResultsFileNode.Attributes.Append(healthcheckFileNameAttribute);

                            testResultsFileNode.InnerXml += xmlWellFormed.InnerXml;
                            outRoot.AppendChild(testResultsFileNode);
                        }
                        //Util.MergeXmlResults(dstFilePath, resfile, header, dstFilePath);
                        //XmlNodeList healthcheckList = xmlHealthcheck.SelectNodes("SystemCheckResults");
                        //foreach (XmlNode healthcheckResult in healthcheckList)
                        //{
                        //    outRoot.InnerXml += healthcheckResult.InnerXml;
                        //}
                    }
                }
                catch (XmlException ex)
                {
                    System.Console.WriteLine(ex.Message);
                }
            }

            // Save out the file
            mergedXml.AppendChild(outRoot);
            mergedXml.Save(dstFilePath);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\ADT\src\ProcessTestResults\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ProcessTestResults")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("ProcessTestResults")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("edff98a0-7de1-480a-9dce-7fb50ecdb49f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\managed\urt\v1.1.4322\CORPerfMonSymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\managed\urt\v1.1.4322\aspnet_perf.h ===
#define OBJECT_1                                           0
#define OBJECT_2                                           2
#define ASPNET_APPLICATION_RESTARTS                        4
#define ASPNET_APPLICATIONS_RUNNING                        6
#define ASPNET_REQUESTS_DISCONNECTED                       8
#define ASPNET_REQUEST_EXECUTION_TIME                      10
#define ASPNET_REQUESTS_REJECTED                           12
#define ASPNET_REQUESTS_QUEUED                             14
#define ASPNET_WPS_RUNNING                                 16
#define ASPNET_WPS_RESTARTS                                18
#define ASPNET_REQUEST_WAIT_TIME                           20
#define ASPNET_STATE_SERVER_SESSIONS_ACTIVE                22
#define ASPNET_STATE_SERVER_SESSIONS_ABANDONED             24
#define ASPNET_STATE_SERVER_SESSIONS_TIMED_OUT             26
#define ASPNET_STATE_SERVER_SESSIONS_TOTAL                 28
#define ASPNET_REQUESTS_CURRENT                            30
#define ASPNET_ANONYMOUS_REQUESTS                          32
#define ASPNET_ANONYMOUS_REQUESTS_RATE                     34
#define ASPNET_TOTAL_CACHE_ENTRIES                         36
#define ASPNET_TOTAL_CACHE_TURNOVER_RATE                   38
#define ASPNET_TOTAL_CACHE_HITS                            40
#define ASPNET_TOTAL_CACHE_MISSES                          42
#define ASPNET_TOTAL_CACHE_RATIO                           44
#define ASPNET_TOTAL_CACHE_RATIO_BASE                      46
#define ASPNET_API_CACHE_ENTRIES                           48
#define ASPNET_API_CACHE_TURNOVER_RATE                     50
#define ASPNET_API_CACHE_HITS                              52
#define ASPNET_API_CACHE_MISSES                            54
#define ASPNET_API_CACHE_RATIO                             56
#define ASPNET_API_CACHE_RATIO_BASE                        58
#define ASPNET_OUTPUT_CACHE_ENTRIES                        60
#define ASPNET_OUTPUT_CACHE_TURNOVER_RATE                  62
#define ASPNET_OUTPUT_CACHE_HITS                           64
#define ASPNET_OUTPUT_CACHE_MISSES                         66
#define ASPNET_OUTPUT_CACHE_RATIO                          68
#define ASPNET_OUTPUT_CACHE_RATIO_BASE                     70
#define ASPNET_COMPILATIONS                                72
#define ASPNET_DEBUGGING_REQUESTS                          74
#define ASPNET_ERRORS_PRE_PROCESSING                       76
#define ASPNET_ERRORS_COMPILING                            78
#define ASPNET_ERRORS_DURING_REQUEST                       80
#define ASPNET_ERRORS_UNHANDLED                            82
#define ASPNET_ERRORS_UNHANDLED_RATE                       84
#define ASPNET_ERRORS_TOTAL                                86
#define ASPNET_ERRORS_TOTAL_RATE                           88
#define ASPNET_PIPELINES                                   90
#define ASPNET_REQUEST_BYTES_IN                            92
#define ASPNET_REQUEST_BYTES_OUT                           94
#define ASPNET_REQUESTS_EXECUTING                          96
#define ASPNET_REQUESTS_FAILED                             98
#define ASPNET_REQUESTS_NOT_FOUND                          100
#define ASPNET_REQUESTS_NOT_AUTHORIZED                     102
#define ASPNET_REQUESTS_IN_APPLICATION_QUEUE               104
#define ASPNET_REQUESTS_TIMED_OUT                          106
#define ASPNET_REQUESTS_SUCCEDED                           108
#define ASPNET_REQUESTS_TOTAL                              110
#define ASPNET_REQUESTS_TOTAL_RATE                         112
#define ASPNET_SESSIONS_ACTIVE                             114
#define ASPNET_SESSIONS_ABANDONED                          116
#define ASPNET_SESSIONS_TIMED_OUT                          118
#define ASPNET_SESSIONS_TOTAL                              120
#define ASPNET_TRANSACTIONS_ABORTED                        122
#define ASPNET_TRANSACTIONS_COMMITTED                      124
#define ASPNET_TRANSACTIONS_PENDING                        126
#define ASPNET_TRANSACTIONS_TOTAL                          128
#define ASPNET_TRANSACTIONS_RATE                           130
#define ASPNET_SESSION_STATE_SERVER_CONNECTIONS            132
#define ASPNET_SESSION_SQL_SERVER_CONNECTIONS              134
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\managed\urt\v1.1.4322\_NetworkingPerfCounters.h ===
//------------------------------------------------------------------------------
// <copyright file="_NetworkingPerfCounters.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   _NetworkingPerfCounters.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\managed\urt\v1.1.4322\_DataPerfCounters.h ===
//------------------------------------------------------------------------------
// <copyright file="_dataperfcounters.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   _dataperfcounters.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
#define DEVICE_COUNTER_6 12;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\managed\urt\v2.0.50727\clrdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for clrdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __clrdata_h__
#define __clrdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICLRDataTarget_FWD_DEFINED__
#define __ICLRDataTarget_FWD_DEFINED__
typedef interface ICLRDataTarget ICLRDataTarget;
#endif 	/* __ICLRDataTarget_FWD_DEFINED__ */


#ifndef __ICLRDataTarget2_FWD_DEFINED__
#define __ICLRDataTarget2_FWD_DEFINED__
typedef interface ICLRDataTarget2 ICLRDataTarget2;
#endif 	/* __ICLRDataTarget2_FWD_DEFINED__ */


#ifndef __ICLRMetadataLocator_FWD_DEFINED__
#define __ICLRMetadataLocator_FWD_DEFINED__
typedef interface ICLRMetadataLocator ICLRMetadataLocator;
#endif 	/* __ICLRMetadataLocator_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegionsCallback ICLRDataEnumMemoryRegionsCallback;
#endif 	/* __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegions_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegions_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegions ICLRDataEnumMemoryRegions;
#endif 	/* __ICLRDataEnumMemoryRegions_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_clrdata_0000 */
/* [local] */ 






typedef ULONG64 CLRDATA_ADDRESS;

STDAPI CLRDataCreateInstance(REFIID iid, ICLRDataTarget* target, void** iface);
typedef HRESULT (STDAPICALLTYPE* PFN_CLRDataCreateInstance)(REFIID iid, ICLRDataTarget* target, void** iface);


extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_s_ifspec;

#ifndef __ICLRDataTarget_INTERFACE_DEFINED__
#define __ICLRDataTarget_INTERFACE_DEFINED__

/* interface ICLRDataTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E11CCEE-D08B-43e5-AF01-32717A64DA03")
    ICLRDataTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
            /* [out] */ ULONG32 *machineType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
            /* [out] */ ULONG32 *pointerSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ULONG32 *threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        END_INTERFACE
    } ICLRDataTargetVtbl;

    interface ICLRDataTarget
    {
        CONST_VTBL struct ICLRDataTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetMachineType_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *machineType);


void __RPC_STUB ICLRDataTarget_GetMachineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetPointerSize_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *pointerSize);


void __RPC_STUB ICLRDataTarget_GetPointerSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetImageBase_Proxy( 
    ICLRDataTarget * This,
    /* [string][in] */ LPCWSTR imagePath,
    /* [out] */ CLRDATA_ADDRESS *baseAddress);


void __RPC_STUB ICLRDataTarget_GetImageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_ReadVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesRead);


void __RPC_STUB ICLRDataTarget_ReadVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_WriteVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [size_is][in] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesWritten);


void __RPC_STUB ICLRDataTarget_WriteVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [out] */ CLRDATA_ADDRESS *value);


void __RPC_STUB ICLRDataTarget_GetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [in] */ CLRDATA_ADDRESS value);


void __RPC_STUB ICLRDataTarget_SetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetCurrentThreadID_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *threadID);


void __RPC_STUB ICLRDataTarget_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][in] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_Request_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 reqCode,
    /* [in] */ ULONG32 inBufferSize,
    /* [size_is][in] */ BYTE *inBuffer,
    /* [in] */ ULONG32 outBufferSize,
    /* [size_is][out] */ BYTE *outBuffer);


void __RPC_STUB ICLRDataTarget_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget_INTERFACE_DEFINED__ */


#ifndef __ICLRDataTarget2_INTERFACE_DEFINED__
#define __ICLRDataTarget2_INTERFACE_DEFINED__

/* interface ICLRDataTarget2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d05fae3-189c-4630-a6dc-1c251e1c01ab")
    ICLRDataTarget2 : public ICLRDataTarget
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTarget2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget2 * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *AllocVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt);
        
        HRESULT ( STDMETHODCALLTYPE *FreeVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags);
        
        END_INTERFACE
    } ICLRDataTarget2Vtbl;

    interface ICLRDataTarget2
    {
        CONST_VTBL struct ICLRDataTarget2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget2_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget2_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget2_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget2_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget2_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget2_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget2_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget2_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget2_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)


#define ICLRDataTarget2_AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)	\
    (This)->lpVtbl -> AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)

#define ICLRDataTarget2_FreeVirtual(This,addr,size,typeFlags)	\
    (This)->lpVtbl -> FreeVirtual(This,addr,size,typeFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget2_AllocVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags,
    /* [in] */ ULONG32 protectFlags,
    /* [out] */ CLRDATA_ADDRESS *virt);


void __RPC_STUB ICLRDataTarget2_AllocVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget2_FreeVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags);


void __RPC_STUB ICLRDataTarget2_FreeVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget2_INTERFACE_DEFINED__ */


#ifndef __ICLRMetadataLocator_INTERFACE_DEFINED__
#define __ICLRMetadataLocator_INTERFACE_DEFINED__

/* interface ICLRMetadataLocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRMetadataLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8fa804-bc05-4642-b2c5-c353ed22fc63")
    ICLRMetadataLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadata( 
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMetadataLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMetadataLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMetadataLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMetadataLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadata )( 
            ICLRMetadataLocator * This,
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize);
        
        END_INTERFACE
    } ICLRMetadataLocatorVtbl;

    interface ICLRMetadataLocator
    {
        CONST_VTBL struct ICLRMetadataLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMetadataLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRMetadataLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRMetadataLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRMetadataLocator_GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)	\
    (This)->lpVtbl -> GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRMetadataLocator_GetMetadata_Proxy( 
    ICLRMetadataLocator * This,
    /* [in] */ LPCWSTR imagePath,
    /* [in] */ ULONG32 imageTimestamp,
    /* [in] */ ULONG32 imageSize,
    /* [in] */ GUID *mvid,
    /* [in] */ ULONG32 mdRva,
    /* [in] */ ULONG32 flags,
    /* [in] */ ULONG32 bufferSize,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [out] */ ULONG32 *dataSize);


void __RPC_STUB ICLRMetadataLocator_GetMetadata_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRMetadataLocator_INTERFACE_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegionsCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegionsCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCDD6908-BA2D-4ec5-96CF-DF4D5CDCB4A4")
    ICLRDataEnumMemoryRegionsCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegion )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsCallbackVtbl;

    interface ICLRDataEnumMemoryRegionsCallback
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegionsCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegionsCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegionsCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion(This,address,size)	\
    (This)->lpVtbl -> EnumMemoryRegion(This,address,size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Proxy( 
    ICLRDataEnumMemoryRegionsCallback * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [in] */ ULONG32 size);


void __RPC_STUB ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_clrdata_0012 */
/* [local] */ 

typedef 
enum CLRDataEnumMemoryFlags
    {	CLRDATA_ENUM_MEM_DEFAULT	= 0,
	CLRDATA_ENUM_MEM_MINI	= CLRDATA_ENUM_MEM_DEFAULT,
	CLRDATA_ENUM_MEM_HEAP	= 0x1
    } 	CLRDataEnumMemoryFlags;



extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_s_ifspec;

#ifndef __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegions */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("471c35b4-7c2f-4ef0-a945-00f8c38056f1")
    ICLRDataEnumMemoryRegions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegions( 
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegions * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegions )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsVtbl;

    interface ICLRDataEnumMemoryRegions
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegions_EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)	\
    (This)->lpVtbl -> EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegions_EnumMemoryRegions_Proxy( 
    ICLRDataEnumMemoryRegions * This,
    /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
    /* [in] */ ULONG32 miniDumpFlags,
    /* [in] */ CLRDataEnumMemoryFlags clrFlags);


void __RPC_STUB ICLRDataEnumMemoryRegions_EnumMemoryRegions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\x86\managed\urt\v2.0.50727\wcpcompiler\DummyCodeFile.cs ===
// DummyCode File
// This is used to compile resource xaml file when a project file is not available.
// Please don't edit this file.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\completion.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for completion.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __completion_h__
#define __completion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsCommandWindowCompletion_FWD_DEFINED__
#define __IVsCommandWindowCompletion_FWD_DEFINED__
typedef interface IVsCommandWindowCompletion IVsCommandWindowCompletion;
#endif 	/* __IVsCommandWindowCompletion_FWD_DEFINED__ */


#ifndef __IVsImmediateStatementCompletion_FWD_DEFINED__
#define __IVsImmediateStatementCompletion_FWD_DEFINED__
typedef interface IVsImmediateStatementCompletion IVsImmediateStatementCompletion;
#endif 	/* __IVsImmediateStatementCompletion_FWD_DEFINED__ */


#ifndef __IVsImmediateStatementCompletion2_FWD_DEFINED__
#define __IVsImmediateStatementCompletion2_FWD_DEFINED__
typedef interface IVsImmediateStatementCompletion2 IVsImmediateStatementCompletion2;
#endif 	/* __IVsImmediateStatementCompletion2_FWD_DEFINED__ */


/* header files for imported files */
#include "textmgr.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_completion_0000_0000 */
/* [local] */ 

#pragma once


extern RPC_IF_HANDLE __MIDL_itf_completion_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_completion_0000_0000_v0_0_s_ifspec;

#ifndef __IVsCommandWindowCompletion_INTERFACE_DEFINED__
#define __IVsCommandWindowCompletion_INTERFACE_DEFINED__

/* interface IVsCommandWindowCompletion */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsCommandWindowCompletion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34896BBB-A3D5-4c80-BCCE-E9271BEEDC11")
    IVsCommandWindowCompletion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCompletionContext( 
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsCommandWindowCompletionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsCommandWindowCompletion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsCommandWindowCompletion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsCommandWindowCompletion * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompletionContext )( 
            IVsCommandWindowCompletion * This,
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext);
        
        END_INTERFACE
    } IVsCommandWindowCompletionVtbl;

    interface IVsCommandWindowCompletion
    {
        CONST_VTBL struct IVsCommandWindowCompletionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsCommandWindowCompletion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsCommandWindowCompletion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsCommandWindowCompletion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsCommandWindowCompletion_SetCompletionContext(This,pszFilePath,pBuffer,ptsCurStatement,punkContext)	\
    ( (This)->lpVtbl -> SetCompletionContext(This,pszFilePath,pBuffer,ptsCurStatement,punkContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsCommandWindowCompletion_INTERFACE_DEFINED__ */


#ifndef __IVsImmediateStatementCompletion_INTERFACE_DEFINED__
#define __IVsImmediateStatementCompletion_INTERFACE_DEFINED__

/* interface IVsImmediateStatementCompletion */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsImmediateStatementCompletion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CE7AE60-7B66-4301-8892-90BC0B49A89B")
    IVsImmediateStatementCompletion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallStatementCompletion( 
            /* [in] */ BOOL fInstall,
            /* [in] */ __RPC__in_opt IVsTextView *pCmdWinView,
            /* [in] */ BOOL fInitialEnable) = 0;
        
        virtual /* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE EnableStatementCompletion_Deprecated( 
            /* [in] */ BOOL fEnable,
            /* [in] */ CharIndex iStartIndex,
            /* [in] */ CharIndex iEndIndex) = 0;
        
        virtual /* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE SetCompletionContext_Deprecated( 
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsImmediateStatementCompletionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsImmediateStatementCompletion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsImmediateStatementCompletion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsImmediateStatementCompletion * This);
        
        HRESULT ( STDMETHODCALLTYPE *InstallStatementCompletion )( 
            IVsImmediateStatementCompletion * This,
            /* [in] */ BOOL fInstall,
            /* [in] */ __RPC__in_opt IVsTextView *pCmdWinView,
            /* [in] */ BOOL fInitialEnable);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnableStatementCompletion_Deprecated )( 
            IVsImmediateStatementCompletion * This,
            /* [in] */ BOOL fEnable,
            /* [in] */ CharIndex iStartIndex,
            /* [in] */ CharIndex iEndIndex);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *SetCompletionContext_Deprecated )( 
            IVsImmediateStatementCompletion * This,
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext);
        
        END_INTERFACE
    } IVsImmediateStatementCompletionVtbl;

    interface IVsImmediateStatementCompletion
    {
        CONST_VTBL struct IVsImmediateStatementCompletionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsImmediateStatementCompletion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsImmediateStatementCompletion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsImmediateStatementCompletion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsImmediateStatementCompletion_InstallStatementCompletion(This,fInstall,pCmdWinView,fInitialEnable)	\
    ( (This)->lpVtbl -> InstallStatementCompletion(This,fInstall,pCmdWinView,fInitialEnable) ) 

#define IVsImmediateStatementCompletion_EnableStatementCompletion_Deprecated(This,fEnable,iStartIndex,iEndIndex)	\
    ( (This)->lpVtbl -> EnableStatementCompletion_Deprecated(This,fEnable,iStartIndex,iEndIndex) ) 

#define IVsImmediateStatementCompletion_SetCompletionContext_Deprecated(This,pszFilePath,pBuffer,ptsCurStatement,punkContext)	\
    ( (This)->lpVtbl -> SetCompletionContext_Deprecated(This,pszFilePath,pBuffer,ptsCurStatement,punkContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsImmediateStatementCompletion_INTERFACE_DEFINED__ */


#ifndef __IVsImmediateStatementCompletion2_INTERFACE_DEFINED__
#define __IVsImmediateStatementCompletion2_INTERFACE_DEFINED__

/* interface IVsImmediateStatementCompletion2 */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsImmediateStatementCompletion2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58F03D6E-F781-4e44-BD88-3BDE817CBDCD")
    IVsImmediateStatementCompletion2 : public IVsImmediateStatementCompletion
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableStatementCompletion( 
            /* [in] */ BOOL fEnable,
            /* [in] */ CharIndex iStartIndex,
            /* [in] */ CharIndex iEndIndex,
            /* [in] */ __RPC__in_opt IVsTextView *pTextView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompletionContext( 
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext,
            /* [in] */ __RPC__in_opt IVsTextView *pTextView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilter( 
            /* [in] */ __RPC__in_opt IVsTextView *pTextView,
            /* [out] */ __RPC__deref_out_opt IVsTextViewFilter **ppFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsImmediateStatementCompletion2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsImmediateStatementCompletion2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsImmediateStatementCompletion2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InstallStatementCompletion )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ BOOL fInstall,
            /* [in] */ __RPC__in_opt IVsTextView *pCmdWinView,
            /* [in] */ BOOL fInitialEnable);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnableStatementCompletion_Deprecated )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ BOOL fEnable,
            /* [in] */ CharIndex iStartIndex,
            /* [in] */ CharIndex iEndIndex);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *SetCompletionContext_Deprecated )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext);
        
        HRESULT ( STDMETHODCALLTYPE *EnableStatementCompletion )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ BOOL fEnable,
            /* [in] */ CharIndex iStartIndex,
            /* [in] */ CharIndex iEndIndex,
            /* [in] */ __RPC__in_opt IVsTextView *pTextView);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompletionContext )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ __RPC__in LPCOLESTR pszFilePath,
            /* [in] */ __RPC__in_opt IVsTextLines *pBuffer,
            /* [in] */ __RPC__in const TextSpan *ptsCurStatement,
            /* [in] */ __RPC__in_opt IUnknown *punkContext,
            /* [in] */ __RPC__in_opt IVsTextView *pTextView);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilter )( 
            IVsImmediateStatementCompletion2 * This,
            /* [in] */ __RPC__in_opt IVsTextView *pTextView,
            /* [out] */ __RPC__deref_out_opt IVsTextViewFilter **ppFilter);
        
        END_INTERFACE
    } IVsImmediateStatementCompletion2Vtbl;

    interface IVsImmediateStatementCompletion2
    {
        CONST_VTBL struct IVsImmediateStatementCompletion2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsImmediateStatementCompletion2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsImmediateStatementCompletion2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsImmediateStatementCompletion2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsImmediateStatementCompletion2_InstallStatementCompletion(This,fInstall,pCmdWinView,fInitialEnable)	\
    ( (This)->lpVtbl -> InstallStatementCompletion(This,fInstall,pCmdWinView,fInitialEnable) ) 

#define IVsImmediateStatementCompletion2_EnableStatementCompletion_Deprecated(This,fEnable,iStartIndex,iEndIndex)	\
    ( (This)->lpVtbl -> EnableStatementCompletion_Deprecated(This,fEnable,iStartIndex,iEndIndex) ) 

#define IVsImmediateStatementCompletion2_SetCompletionContext_Deprecated(This,pszFilePath,pBuffer,ptsCurStatement,punkContext)	\
    ( (This)->lpVtbl -> SetCompletionContext_Deprecated(This,pszFilePath,pBuffer,ptsCurStatement,punkContext) ) 


#define IVsImmediateStatementCompletion2_EnableStatementCompletion(This,fEnable,iStartIndex,iEndIndex,pTextView)	\
    ( (This)->lpVtbl -> EnableStatementCompletion(This,fEnable,iStartIndex,iEndIndex,pTextView) ) 

#define IVsImmediateStatementCompletion2_SetCompletionContext(This,pszFilePath,pBuffer,ptsCurStatement,punkContext,pTextView)	\
    ( (This)->lpVtbl -> SetCompletionContext(This,pszFilePath,pBuffer,ptsCurStatement,punkContext,pTextView) ) 

#define IVsImmediateStatementCompletion2_GetFilter(This,pTextView,ppFilter)	\
    ( (This)->lpVtbl -> GetFilter(This,pTextView,ppFilter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsImmediateStatementCompletion2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\activdbg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for activdbg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activdbg_h__
#define __activdbg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveScriptDebug32_FWD_DEFINED__
#define __IActiveScriptDebug32_FWD_DEFINED__
typedef interface IActiveScriptDebug32 IActiveScriptDebug32;
#endif 	/* __IActiveScriptDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptDebug64_FWD_DEFINED__
#define __IActiveScriptDebug64_FWD_DEFINED__
typedef interface IActiveScriptDebug64 IActiveScriptDebug64;
#endif 	/* __IActiveScriptDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug32_FWD_DEFINED__
#define __IActiveScriptSiteDebug32_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug32 IActiveScriptSiteDebug32;
#endif 	/* __IActiveScriptSiteDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug64_FWD_DEFINED__
#define __IActiveScriptSiteDebug64_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug64 IActiveScriptSiteDebug64;
#endif 	/* __IActiveScriptSiteDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebugEx_FWD_DEFINED__
#define __IActiveScriptSiteDebugEx_FWD_DEFINED__
typedef interface IActiveScriptSiteDebugEx IActiveScriptSiteDebugEx;
#endif 	/* __IActiveScriptSiteDebugEx_FWD_DEFINED__ */


#ifndef __IActiveScriptErrorDebug_FWD_DEFINED__
#define __IActiveScriptErrorDebug_FWD_DEFINED__
typedef interface IActiveScriptErrorDebug IActiveScriptErrorDebug;
#endif 	/* __IActiveScriptErrorDebug_FWD_DEFINED__ */


#ifndef __IDebugCodeContext_FWD_DEFINED__
#define __IDebugCodeContext_FWD_DEFINED__
typedef interface IDebugCodeContext IDebugCodeContext;
#endif 	/* __IDebugCodeContext_FWD_DEFINED__ */


#ifndef __IDebugExpression_FWD_DEFINED__
#define __IDebugExpression_FWD_DEFINED__
typedef interface IDebugExpression IDebugExpression;
#endif 	/* __IDebugExpression_FWD_DEFINED__ */


#ifndef __IDebugExpressionContext_FWD_DEFINED__
#define __IDebugExpressionContext_FWD_DEFINED__
typedef interface IDebugExpressionContext IDebugExpressionContext;
#endif 	/* __IDebugExpressionContext_FWD_DEFINED__ */


#ifndef __IDebugExpressionCallBack_FWD_DEFINED__
#define __IDebugExpressionCallBack_FWD_DEFINED__
typedef interface IDebugExpressionCallBack IDebugExpressionCallBack;
#endif 	/* __IDebugExpressionCallBack_FWD_DEFINED__ */


#ifndef __IDebugStackFrame_FWD_DEFINED__
#define __IDebugStackFrame_FWD_DEFINED__
typedef interface IDebugStackFrame IDebugStackFrame;
#endif 	/* __IDebugStackFrame_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSniffer_FWD_DEFINED__
#define __IDebugStackFrameSniffer_FWD_DEFINED__
typedef interface IDebugStackFrameSniffer IDebugStackFrameSniffer;
#endif 	/* __IDebugStackFrameSniffer_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx32_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx32_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx32 IDebugStackFrameSnifferEx32;
#endif 	/* __IDebugStackFrameSnifferEx32_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx64_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx64_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx64 IDebugStackFrameSnifferEx64;
#endif 	/* __IDebugStackFrameSnifferEx64_FWD_DEFINED__ */


#ifndef __IDebugSyncOperation_FWD_DEFINED__
#define __IDebugSyncOperation_FWD_DEFINED__
typedef interface IDebugSyncOperation IDebugSyncOperation;
#endif 	/* __IDebugSyncOperation_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperation_FWD_DEFINED__
#define __IDebugAsyncOperation_FWD_DEFINED__
typedef interface IDebugAsyncOperation IDebugAsyncOperation;
#endif 	/* __IDebugAsyncOperation_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperationCallBack_FWD_DEFINED__
#define __IDebugAsyncOperationCallBack_FWD_DEFINED__
typedef interface IDebugAsyncOperationCallBack IDebugAsyncOperationCallBack;
#endif 	/* __IDebugAsyncOperationCallBack_FWD_DEFINED__ */


#ifndef __IEnumDebugCodeContexts_FWD_DEFINED__
#define __IEnumDebugCodeContexts_FWD_DEFINED__
typedef interface IEnumDebugCodeContexts IEnumDebugCodeContexts;
#endif 	/* __IEnumDebugCodeContexts_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames_FWD_DEFINED__
#define __IEnumDebugStackFrames_FWD_DEFINED__
typedef interface IEnumDebugStackFrames IEnumDebugStackFrames;
#endif 	/* __IEnumDebugStackFrames_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames64_FWD_DEFINED__
#define __IEnumDebugStackFrames64_FWD_DEFINED__
typedef interface IEnumDebugStackFrames64 IEnumDebugStackFrames64;
#endif 	/* __IEnumDebugStackFrames64_FWD_DEFINED__ */


#ifndef __IDebugDocumentInfo_FWD_DEFINED__
#define __IDebugDocumentInfo_FWD_DEFINED__
typedef interface IDebugDocumentInfo IDebugDocumentInfo;
#endif 	/* __IDebugDocumentInfo_FWD_DEFINED__ */


#ifndef __IDebugDocumentProvider_FWD_DEFINED__
#define __IDebugDocumentProvider_FWD_DEFINED__
typedef interface IDebugDocumentProvider IDebugDocumentProvider;
#endif 	/* __IDebugDocumentProvider_FWD_DEFINED__ */


#ifndef __IDebugDocument_FWD_DEFINED__
#define __IDebugDocument_FWD_DEFINED__
typedef interface IDebugDocument IDebugDocument;
#endif 	/* __IDebugDocument_FWD_DEFINED__ */


#ifndef __IDebugDocumentText_FWD_DEFINED__
#define __IDebugDocumentText_FWD_DEFINED__
typedef interface IDebugDocumentText IDebugDocumentText;
#endif 	/* __IDebugDocumentText_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextEvents_FWD_DEFINED__
#define __IDebugDocumentTextEvents_FWD_DEFINED__
typedef interface IDebugDocumentTextEvents IDebugDocumentTextEvents;
#endif 	/* __IDebugDocumentTextEvents_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextAuthor_FWD_DEFINED__
#define __IDebugDocumentTextAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextAuthor IDebugDocumentTextAuthor;
#endif 	/* __IDebugDocumentTextAuthor_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
#define __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextExternalAuthor IDebugDocumentTextExternalAuthor;
#endif 	/* __IDebugDocumentTextExternalAuthor_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper32_FWD_DEFINED__
#define __IDebugDocumentHelper32_FWD_DEFINED__
typedef interface IDebugDocumentHelper32 IDebugDocumentHelper32;
#endif 	/* __IDebugDocumentHelper32_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper64_FWD_DEFINED__
#define __IDebugDocumentHelper64_FWD_DEFINED__
typedef interface IDebugDocumentHelper64 IDebugDocumentHelper64;
#endif 	/* __IDebugDocumentHelper64_FWD_DEFINED__ */


#ifndef __IDebugDocumentHost_FWD_DEFINED__
#define __IDebugDocumentHost_FWD_DEFINED__
typedef interface IDebugDocumentHost IDebugDocumentHost;
#endif 	/* __IDebugDocumentHost_FWD_DEFINED__ */


#ifndef __IDebugDocumentContext_FWD_DEFINED__
#define __IDebugDocumentContext_FWD_DEFINED__
typedef interface IDebugDocumentContext IDebugDocumentContext;
#endif 	/* __IDebugDocumentContext_FWD_DEFINED__ */


#ifndef __IDebugSessionProvider_FWD_DEFINED__
#define __IDebugSessionProvider_FWD_DEFINED__
typedef interface IDebugSessionProvider IDebugSessionProvider;
#endif 	/* __IDebugSessionProvider_FWD_DEFINED__ */


#ifndef __IApplicationDebugger_FWD_DEFINED__
#define __IApplicationDebugger_FWD_DEFINED__
typedef interface IApplicationDebugger IApplicationDebugger;
#endif 	/* __IApplicationDebugger_FWD_DEFINED__ */


#ifndef __IApplicationDebuggerUI_FWD_DEFINED__
#define __IApplicationDebuggerUI_FWD_DEFINED__
typedef interface IApplicationDebuggerUI IApplicationDebuggerUI;
#endif 	/* __IApplicationDebuggerUI_FWD_DEFINED__ */


#ifndef __IMachineDebugManager_FWD_DEFINED__
#define __IMachineDebugManager_FWD_DEFINED__
typedef interface IMachineDebugManager IMachineDebugManager;
#endif 	/* __IMachineDebugManager_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerCookie_FWD_DEFINED__
#define __IMachineDebugManagerCookie_FWD_DEFINED__
typedef interface IMachineDebugManagerCookie IMachineDebugManagerCookie;
#endif 	/* __IMachineDebugManagerCookie_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerEvents_FWD_DEFINED__
#define __IMachineDebugManagerEvents_FWD_DEFINED__
typedef interface IMachineDebugManagerEvents IMachineDebugManagerEvents;
#endif 	/* __IMachineDebugManagerEvents_FWD_DEFINED__ */


#ifndef __IProcessDebugManager32_FWD_DEFINED__
#define __IProcessDebugManager32_FWD_DEFINED__
typedef interface IProcessDebugManager32 IProcessDebugManager32;
#endif 	/* __IProcessDebugManager32_FWD_DEFINED__ */


#ifndef __IProcessDebugManager64_FWD_DEFINED__
#define __IProcessDebugManager64_FWD_DEFINED__
typedef interface IProcessDebugManager64 IProcessDebugManager64;
#endif 	/* __IProcessDebugManager64_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplication_FWD_DEFINED__
#define __IRemoteDebugApplication_FWD_DEFINED__
typedef interface IRemoteDebugApplication IRemoteDebugApplication;
#endif 	/* __IRemoteDebugApplication_FWD_DEFINED__ */


#ifndef __IDebugApplication32_FWD_DEFINED__
#define __IDebugApplication32_FWD_DEFINED__
typedef interface IDebugApplication32 IDebugApplication32;
#endif 	/* __IDebugApplication32_FWD_DEFINED__ */


#ifndef __IDebugApplication64_FWD_DEFINED__
#define __IDebugApplication64_FWD_DEFINED__
typedef interface IDebugApplication64 IDebugApplication64;
#endif 	/* __IDebugApplication64_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationEvents_FWD_DEFINED__
#define __IRemoteDebugApplicationEvents_FWD_DEFINED__
typedef interface IRemoteDebugApplicationEvents IRemoteDebugApplicationEvents;
#endif 	/* __IRemoteDebugApplicationEvents_FWD_DEFINED__ */


#ifndef __IDebugApplicationNode_FWD_DEFINED__
#define __IDebugApplicationNode_FWD_DEFINED__
typedef interface IDebugApplicationNode IDebugApplicationNode;
#endif 	/* __IDebugApplicationNode_FWD_DEFINED__ */


#ifndef __IDebugApplicationNodeEvents_FWD_DEFINED__
#define __IDebugApplicationNodeEvents_FWD_DEFINED__
typedef interface IDebugApplicationNodeEvents IDebugApplicationNodeEvents;
#endif 	/* __IDebugApplicationNodeEvents_FWD_DEFINED__ */


#ifndef __AsyncIDebugApplicationNodeEvents_FWD_DEFINED__
#define __AsyncIDebugApplicationNodeEvents_FWD_DEFINED__
typedef interface AsyncIDebugApplicationNodeEvents AsyncIDebugApplicationNodeEvents;
#endif 	/* __AsyncIDebugApplicationNodeEvents_FWD_DEFINED__ */


#ifndef __IDebugThreadCall32_FWD_DEFINED__
#define __IDebugThreadCall32_FWD_DEFINED__
typedef interface IDebugThreadCall32 IDebugThreadCall32;
#endif 	/* __IDebugThreadCall32_FWD_DEFINED__ */


#ifndef __IDebugThreadCall64_FWD_DEFINED__
#define __IDebugThreadCall64_FWD_DEFINED__
typedef interface IDebugThreadCall64 IDebugThreadCall64;
#endif 	/* __IDebugThreadCall64_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationThread_FWD_DEFINED__
#define __IRemoteDebugApplicationThread_FWD_DEFINED__
typedef interface IRemoteDebugApplicationThread IRemoteDebugApplicationThread;
#endif 	/* __IRemoteDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugApplicationThread_FWD_DEFINED__
#define __IDebugApplicationThread_FWD_DEFINED__
typedef interface IDebugApplicationThread IDebugApplicationThread;
#endif 	/* __IDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugApplicationThread64_FWD_DEFINED__
#define __IDebugApplicationThread64_FWD_DEFINED__
typedef interface IDebugApplicationThread64 IDebugApplicationThread64;
#endif 	/* __IDebugApplicationThread64_FWD_DEFINED__ */


#ifndef __IDebugCookie_FWD_DEFINED__
#define __IDebugCookie_FWD_DEFINED__
typedef interface IDebugCookie IDebugCookie;
#endif 	/* __IDebugCookie_FWD_DEFINED__ */


#ifndef __IEnumDebugApplicationNodes_FWD_DEFINED__
#define __IEnumDebugApplicationNodes_FWD_DEFINED__
typedef interface IEnumDebugApplicationNodes IEnumDebugApplicationNodes;
#endif 	/* __IEnumDebugApplicationNodes_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplications_FWD_DEFINED__
#define __IEnumRemoteDebugApplications_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplications IEnumRemoteDebugApplications;
#endif 	/* __IEnumRemoteDebugApplications_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
#define __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplicationThreads IEnumRemoteDebugApplicationThreads;
#endif 	/* __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__ */


#ifndef __IDebugFormatter_FWD_DEFINED__
#define __IDebugFormatter_FWD_DEFINED__
typedef interface IDebugFormatter IDebugFormatter;
#endif 	/* __IDebugFormatter_FWD_DEFINED__ */


#ifndef __ISimpleConnectionPoint_FWD_DEFINED__
#define __ISimpleConnectionPoint_FWD_DEFINED__
typedef interface ISimpleConnectionPoint ISimpleConnectionPoint;
#endif 	/* __ISimpleConnectionPoint_FWD_DEFINED__ */


#ifndef __IDebugHelper_FWD_DEFINED__
#define __IDebugHelper_FWD_DEFINED__
typedef interface IDebugHelper IDebugHelper;
#endif 	/* __IDebugHelper_FWD_DEFINED__ */


#ifndef __IEnumDebugExpressionContexts_FWD_DEFINED__
#define __IEnumDebugExpressionContexts_FWD_DEFINED__
typedef interface IEnumDebugExpressionContexts IEnumDebugExpressionContexts;
#endif 	/* __IEnumDebugExpressionContexts_FWD_DEFINED__ */


#ifndef __IProvideExpressionContexts_FWD_DEFINED__
#define __IProvideExpressionContexts_FWD_DEFINED__
typedef interface IProvideExpressionContexts IProvideExpressionContexts;
#endif 	/* __IProvideExpressionContexts_FWD_DEFINED__ */


#ifndef __IActiveScriptDebug32_FWD_DEFINED__
#define __IActiveScriptDebug32_FWD_DEFINED__
typedef interface IActiveScriptDebug32 IActiveScriptDebug32;
#endif 	/* __IActiveScriptDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptDebug64_FWD_DEFINED__
#define __IActiveScriptDebug64_FWD_DEFINED__
typedef interface IActiveScriptDebug64 IActiveScriptDebug64;
#endif 	/* __IActiveScriptDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptErrorDebug_FWD_DEFINED__
#define __IActiveScriptErrorDebug_FWD_DEFINED__
typedef interface IActiveScriptErrorDebug IActiveScriptErrorDebug;
#endif 	/* __IActiveScriptErrorDebug_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug32_FWD_DEFINED__
#define __IActiveScriptSiteDebug32_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug32 IActiveScriptSiteDebug32;
#endif 	/* __IActiveScriptSiteDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug64_FWD_DEFINED__
#define __IActiveScriptSiteDebug64_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug64 IActiveScriptSiteDebug64;
#endif 	/* __IActiveScriptSiteDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebugEx_FWD_DEFINED__
#define __IActiveScriptSiteDebugEx_FWD_DEFINED__
typedef interface IActiveScriptSiteDebugEx IActiveScriptSiteDebugEx;
#endif 	/* __IActiveScriptSiteDebugEx_FWD_DEFINED__ */


#ifndef __IApplicationDebugger_FWD_DEFINED__
#define __IApplicationDebugger_FWD_DEFINED__
typedef interface IApplicationDebugger IApplicationDebugger;
#endif 	/* __IApplicationDebugger_FWD_DEFINED__ */


#ifndef __IApplicationDebuggerUI_FWD_DEFINED__
#define __IApplicationDebuggerUI_FWD_DEFINED__
typedef interface IApplicationDebuggerUI IApplicationDebuggerUI;
#endif 	/* __IApplicationDebuggerUI_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplication_FWD_DEFINED__
#define __IRemoteDebugApplication_FWD_DEFINED__
typedef interface IRemoteDebugApplication IRemoteDebugApplication;
#endif 	/* __IRemoteDebugApplication_FWD_DEFINED__ */


#ifndef __IDebugApplication32_FWD_DEFINED__
#define __IDebugApplication32_FWD_DEFINED__
typedef interface IDebugApplication32 IDebugApplication32;
#endif 	/* __IDebugApplication32_FWD_DEFINED__ */


#ifndef __IDebugApplication64_FWD_DEFINED__
#define __IDebugApplication64_FWD_DEFINED__
typedef interface IDebugApplication64 IDebugApplication64;
#endif 	/* __IDebugApplication64_FWD_DEFINED__ */


#ifndef __IDebugDocumentInfo_FWD_DEFINED__
#define __IDebugDocumentInfo_FWD_DEFINED__
typedef interface IDebugDocumentInfo IDebugDocumentInfo;
#endif 	/* __IDebugDocumentInfo_FWD_DEFINED__ */


#ifndef __IDebugDocumentProvider_FWD_DEFINED__
#define __IDebugDocumentProvider_FWD_DEFINED__
typedef interface IDebugDocumentProvider IDebugDocumentProvider;
#endif 	/* __IDebugDocumentProvider_FWD_DEFINED__ */


#ifndef __IDebugApplicationNode_FWD_DEFINED__
#define __IDebugApplicationNode_FWD_DEFINED__
typedef interface IDebugApplicationNode IDebugApplicationNode;
#endif 	/* __IDebugApplicationNode_FWD_DEFINED__ */


#ifndef __IDebugApplicationNodeEvents_FWD_DEFINED__
#define __IDebugApplicationNodeEvents_FWD_DEFINED__
typedef interface IDebugApplicationNodeEvents IDebugApplicationNodeEvents;
#endif 	/* __IDebugApplicationNodeEvents_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationThread_FWD_DEFINED__
#define __IRemoteDebugApplicationThread_FWD_DEFINED__
typedef interface IRemoteDebugApplicationThread IRemoteDebugApplicationThread;
#endif 	/* __IRemoteDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugApplicationThread_FWD_DEFINED__
#define __IDebugApplicationThread_FWD_DEFINED__
typedef interface IDebugApplicationThread IDebugApplicationThread;
#endif 	/* __IDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperation_FWD_DEFINED__
#define __IDebugAsyncOperation_FWD_DEFINED__
typedef interface IDebugAsyncOperation IDebugAsyncOperation;
#endif 	/* __IDebugAsyncOperation_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperationCallBack_FWD_DEFINED__
#define __IDebugAsyncOperationCallBack_FWD_DEFINED__
typedef interface IDebugAsyncOperationCallBack IDebugAsyncOperationCallBack;
#endif 	/* __IDebugAsyncOperationCallBack_FWD_DEFINED__ */


#ifndef __IDebugCodeContext_FWD_DEFINED__
#define __IDebugCodeContext_FWD_DEFINED__
typedef interface IDebugCodeContext IDebugCodeContext;
#endif 	/* __IDebugCodeContext_FWD_DEFINED__ */


#ifndef __IDebugCookie_FWD_DEFINED__
#define __IDebugCookie_FWD_DEFINED__
typedef interface IDebugCookie IDebugCookie;
#endif 	/* __IDebugCookie_FWD_DEFINED__ */


#ifndef __IDebugDocument_FWD_DEFINED__
#define __IDebugDocument_FWD_DEFINED__
typedef interface IDebugDocument IDebugDocument;
#endif 	/* __IDebugDocument_FWD_DEFINED__ */


#ifndef __IDebugDocumentContext_FWD_DEFINED__
#define __IDebugDocumentContext_FWD_DEFINED__
typedef interface IDebugDocumentContext IDebugDocumentContext;
#endif 	/* __IDebugDocumentContext_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper32_FWD_DEFINED__
#define __IDebugDocumentHelper32_FWD_DEFINED__
typedef interface IDebugDocumentHelper32 IDebugDocumentHelper32;
#endif 	/* __IDebugDocumentHelper32_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper64_FWD_DEFINED__
#define __IDebugDocumentHelper64_FWD_DEFINED__
typedef interface IDebugDocumentHelper64 IDebugDocumentHelper64;
#endif 	/* __IDebugDocumentHelper64_FWD_DEFINED__ */


#ifndef __IDebugDocumentHost_FWD_DEFINED__
#define __IDebugDocumentHost_FWD_DEFINED__
typedef interface IDebugDocumentHost IDebugDocumentHost;
#endif 	/* __IDebugDocumentHost_FWD_DEFINED__ */


#ifndef __IDebugDocumentText_FWD_DEFINED__
#define __IDebugDocumentText_FWD_DEFINED__
typedef interface IDebugDocumentText IDebugDocumentText;
#endif 	/* __IDebugDocumentText_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextAuthor_FWD_DEFINED__
#define __IDebugDocumentTextAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextAuthor IDebugDocumentTextAuthor;
#endif 	/* __IDebugDocumentTextAuthor_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextEvents_FWD_DEFINED__
#define __IDebugDocumentTextEvents_FWD_DEFINED__
typedef interface IDebugDocumentTextEvents IDebugDocumentTextEvents;
#endif 	/* __IDebugDocumentTextEvents_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
#define __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextExternalAuthor IDebugDocumentTextExternalAuthor;
#endif 	/* __IDebugDocumentTextExternalAuthor_FWD_DEFINED__ */


#ifndef __IDebugExpression_FWD_DEFINED__
#define __IDebugExpression_FWD_DEFINED__
typedef interface IDebugExpression IDebugExpression;
#endif 	/* __IDebugExpression_FWD_DEFINED__ */


#ifndef __IDebugExpressionCallBack_FWD_DEFINED__
#define __IDebugExpressionCallBack_FWD_DEFINED__
typedef interface IDebugExpressionCallBack IDebugExpressionCallBack;
#endif 	/* __IDebugExpressionCallBack_FWD_DEFINED__ */


#ifndef __IDebugExpressionContext_FWD_DEFINED__
#define __IDebugExpressionContext_FWD_DEFINED__
typedef interface IDebugExpressionContext IDebugExpressionContext;
#endif 	/* __IDebugExpressionContext_FWD_DEFINED__ */


#ifndef __IDebugFormatter_FWD_DEFINED__
#define __IDebugFormatter_FWD_DEFINED__
typedef interface IDebugFormatter IDebugFormatter;
#endif 	/* __IDebugFormatter_FWD_DEFINED__ */


#ifndef __IDebugHelper_FWD_DEFINED__
#define __IDebugHelper_FWD_DEFINED__
typedef interface IDebugHelper IDebugHelper;
#endif 	/* __IDebugHelper_FWD_DEFINED__ */


#ifndef __IDebugSessionProvider_FWD_DEFINED__
#define __IDebugSessionProvider_FWD_DEFINED__
typedef interface IDebugSessionProvider IDebugSessionProvider;
#endif 	/* __IDebugSessionProvider_FWD_DEFINED__ */


#ifndef __IDebugStackFrame_FWD_DEFINED__
#define __IDebugStackFrame_FWD_DEFINED__
typedef interface IDebugStackFrame IDebugStackFrame;
#endif 	/* __IDebugStackFrame_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSniffer_FWD_DEFINED__
#define __IDebugStackFrameSniffer_FWD_DEFINED__
typedef interface IDebugStackFrameSniffer IDebugStackFrameSniffer;
#endif 	/* __IDebugStackFrameSniffer_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx32_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx32_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx32 IDebugStackFrameSnifferEx32;
#endif 	/* __IDebugStackFrameSnifferEx32_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx64_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx64_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx64 IDebugStackFrameSnifferEx64;
#endif 	/* __IDebugStackFrameSnifferEx64_FWD_DEFINED__ */


#ifndef __IDebugSyncOperation_FWD_DEFINED__
#define __IDebugSyncOperation_FWD_DEFINED__
typedef interface IDebugSyncOperation IDebugSyncOperation;
#endif 	/* __IDebugSyncOperation_FWD_DEFINED__ */


#ifndef __IDebugThreadCall32_FWD_DEFINED__
#define __IDebugThreadCall32_FWD_DEFINED__
typedef interface IDebugThreadCall32 IDebugThreadCall32;
#endif 	/* __IDebugThreadCall32_FWD_DEFINED__ */


#ifndef __IDebugThreadCall64_FWD_DEFINED__
#define __IDebugThreadCall64_FWD_DEFINED__
typedef interface IDebugThreadCall64 IDebugThreadCall64;
#endif 	/* __IDebugThreadCall64_FWD_DEFINED__ */


#ifndef __IEnumDebugApplicationNodes_FWD_DEFINED__
#define __IEnumDebugApplicationNodes_FWD_DEFINED__
typedef interface IEnumDebugApplicationNodes IEnumDebugApplicationNodes;
#endif 	/* __IEnumDebugApplicationNodes_FWD_DEFINED__ */


#ifndef __IEnumDebugCodeContexts_FWD_DEFINED__
#define __IEnumDebugCodeContexts_FWD_DEFINED__
typedef interface IEnumDebugCodeContexts IEnumDebugCodeContexts;
#endif 	/* __IEnumDebugCodeContexts_FWD_DEFINED__ */


#ifndef __IEnumDebugExpressionContexts_FWD_DEFINED__
#define __IEnumDebugExpressionContexts_FWD_DEFINED__
typedef interface IEnumDebugExpressionContexts IEnumDebugExpressionContexts;
#endif 	/* __IEnumDebugExpressionContexts_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames_FWD_DEFINED__
#define __IEnumDebugStackFrames_FWD_DEFINED__
typedef interface IEnumDebugStackFrames IEnumDebugStackFrames;
#endif 	/* __IEnumDebugStackFrames_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames64_FWD_DEFINED__
#define __IEnumDebugStackFrames64_FWD_DEFINED__
typedef interface IEnumDebugStackFrames64 IEnumDebugStackFrames64;
#endif 	/* __IEnumDebugStackFrames64_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplications_FWD_DEFINED__
#define __IEnumRemoteDebugApplications_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplications IEnumRemoteDebugApplications;
#endif 	/* __IEnumRemoteDebugApplications_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
#define __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplicationThreads IEnumRemoteDebugApplicationThreads;
#endif 	/* __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__ */


#ifndef __IProcessDebugManager32_FWD_DEFINED__
#define __IProcessDebugManager32_FWD_DEFINED__
typedef interface IProcessDebugManager32 IProcessDebugManager32;
#endif 	/* __IProcessDebugManager32_FWD_DEFINED__ */


#ifndef __IProcessDebugManager64_FWD_DEFINED__
#define __IProcessDebugManager64_FWD_DEFINED__
typedef interface IProcessDebugManager64 IProcessDebugManager64;
#endif 	/* __IProcessDebugManager64_FWD_DEFINED__ */


#ifndef __IProvideExpressionContexts_FWD_DEFINED__
#define __IProvideExpressionContexts_FWD_DEFINED__
typedef interface IProvideExpressionContexts IProvideExpressionContexts;
#endif 	/* __IProvideExpressionContexts_FWD_DEFINED__ */


#ifndef __IMachineDebugManager_FWD_DEFINED__
#define __IMachineDebugManager_FWD_DEFINED__
typedef interface IMachineDebugManager IMachineDebugManager;
#endif 	/* __IMachineDebugManager_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerCookie_FWD_DEFINED__
#define __IMachineDebugManagerCookie_FWD_DEFINED__
typedef interface IMachineDebugManagerCookie IMachineDebugManagerCookie;
#endif 	/* __IMachineDebugManagerCookie_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerEvents_FWD_DEFINED__
#define __IMachineDebugManagerEvents_FWD_DEFINED__
typedef interface IMachineDebugManagerEvents IMachineDebugManagerEvents;
#endif 	/* __IMachineDebugManagerEvents_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationEvents_FWD_DEFINED__
#define __IRemoteDebugApplicationEvents_FWD_DEFINED__
typedef interface IRemoteDebugApplicationEvents IRemoteDebugApplicationEvents;
#endif 	/* __IRemoteDebugApplicationEvents_FWD_DEFINED__ */


#ifndef __ISimpleConnectionPoint_FWD_DEFINED__
#define __ISimpleConnectionPoint_FWD_DEFINED__
typedef interface ISimpleConnectionPoint ISimpleConnectionPoint;
#endif 	/* __ISimpleConnectionPoint_FWD_DEFINED__ */


#ifndef __ProcessDebugManager_FWD_DEFINED__
#define __ProcessDebugManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProcessDebugManager ProcessDebugManager;
#else
typedef struct ProcessDebugManager ProcessDebugManager;
#endif /* __cplusplus */

#endif 	/* __ProcessDebugManager_FWD_DEFINED__ */


#ifndef __DebugHelper_FWD_DEFINED__
#define __DebugHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class DebugHelper DebugHelper;
#else
typedef struct DebugHelper DebugHelper;
#endif /* __cplusplus */

#endif 	/* __DebugHelper_FWD_DEFINED__ */


#ifndef __CDebugDocumentHelper_FWD_DEFINED__
#define __CDebugDocumentHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDebugDocumentHelper CDebugDocumentHelper;
#else
typedef struct CDebugDocumentHelper CDebugDocumentHelper;
#endif /* __cplusplus */

#endif 	/* __CDebugDocumentHelper_FWD_DEFINED__ */


#ifndef __MachineDebugManager_RETAIL_FWD_DEFINED__
#define __MachineDebugManager_RETAIL_FWD_DEFINED__

#ifdef __cplusplus
typedef class MachineDebugManager_RETAIL MachineDebugManager_RETAIL;
#else
typedef struct MachineDebugManager_RETAIL MachineDebugManager_RETAIL;
#endif /* __cplusplus */

#endif 	/* __MachineDebugManager_RETAIL_FWD_DEFINED__ */


#ifndef __MachineDebugManager_DEBUG_FWD_DEFINED__
#define __MachineDebugManager_DEBUG_FWD_DEFINED__

#ifdef __cplusplus
typedef class MachineDebugManager_DEBUG MachineDebugManager_DEBUG;
#else
typedef struct MachineDebugManager_DEBUG MachineDebugManager_DEBUG;
#endif /* __cplusplus */

#endif 	/* __MachineDebugManager_DEBUG_FWD_DEFINED__ */


#ifndef __DefaultDebugSessionProvider_FWD_DEFINED__
#define __DefaultDebugSessionProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class DefaultDebugSessionProvider DefaultDebugSessionProvider;
#else
typedef struct DefaultDebugSessionProvider DefaultDebugSessionProvider;
#endif /* __cplusplus */

#endif 	/* __DefaultDebugSessionProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "activscp.h"
#include "dbgprop.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_activdbg_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ActivDbg.h
//=--------------------------------------------------------------------------=
// (C) Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
#pragma comment(lib,"uuid.lib")
//
// Declarations for ActiveX Scripting authoring/Debugging.
//

#ifndef __ActivDbg_h
#define __ActivDbg_h
























































typedef 
enum tagBREAKPOINT_STATE
    {	BREAKPOINT_DELETED	= 0,
	BREAKPOINT_DISABLED	= 1,
	BREAKPOINT_ENABLED	= 2
    } 	BREAKPOINT_STATE;

typedef DWORD APPBREAKFLAGS;

#define	APPBREAKFLAG_DEBUGGER_BLOCK	( 0x1 )

#define	APPBREAKFLAG_DEBUGGER_HALT	( 0x2 )

#define	APPBREAKFLAG_STEP	( 0x10000 )

#define	APPBREAKFLAG_NESTED	( 0x20000 )

#define	APPBREAKFLAG_STEPTYPE_SOURCE	( 0 )

#define	APPBREAKFLAG_STEPTYPE_BYTECODE	( 0x100000 )

#define	APPBREAKFLAG_STEPTYPE_MACHINE	( 0x200000 )

#define	APPBREAKFLAG_STEPTYPE_MASK	( 0xf00000 )

#define	APPBREAKFLAG_IN_BREAKPOINT	( 0x80000000 )

typedef 
enum tagBREAKREASON
    {	BREAKREASON_STEP	= 0,
	BREAKREASON_BREAKPOINT	= ( BREAKREASON_STEP + 1 ) ,
	BREAKREASON_DEBUGGER_BLOCK	= ( BREAKREASON_BREAKPOINT + 1 ) ,
	BREAKREASON_HOST_INITIATED	= ( BREAKREASON_DEBUGGER_BLOCK + 1 ) ,
	BREAKREASON_LANGUAGE_INITIATED	= ( BREAKREASON_HOST_INITIATED + 1 ) ,
	BREAKREASON_DEBUGGER_HALT	= ( BREAKREASON_LANGUAGE_INITIATED + 1 ) ,
	BREAKREASON_ERROR	= ( BREAKREASON_DEBUGGER_HALT + 1 ) ,
	BREAKREASON_JIT	= ( BREAKREASON_ERROR + 1 ) 
    } 	BREAKREASON;

typedef 
enum tagBREAKRESUME_ACTION
    {	BREAKRESUMEACTION_ABORT	= 0,
	BREAKRESUMEACTION_CONTINUE	= ( BREAKRESUMEACTION_ABORT + 1 ) ,
	BREAKRESUMEACTION_STEP_INTO	= ( BREAKRESUMEACTION_CONTINUE + 1 ) ,
	BREAKRESUMEACTION_STEP_OVER	= ( BREAKRESUMEACTION_STEP_INTO + 1 ) ,
	BREAKRESUMEACTION_STEP_OUT	= ( BREAKRESUMEACTION_STEP_OVER + 1 ) ,
	BREAKRESUMEACTION_IGNORE	= ( BREAKRESUMEACTION_STEP_OUT + 1 ) 
    } 	BREAKRESUMEACTION;

typedef 
enum tagERRORRESUMEACTION
    {	ERRORRESUMEACTION_ReexecuteErrorStatement	= 0,
	ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller	= ( ERRORRESUMEACTION_ReexecuteErrorStatement + 1 ) ,
	ERRORRESUMEACTION_SkipErrorStatement	= ( ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller + 1 ) 
    } 	ERRORRESUMEACTION;

typedef 
enum tagDOCUMENTNAMETYPE
    {	DOCUMENTNAMETYPE_APPNODE	= 0,
	DOCUMENTNAMETYPE_TITLE	= ( DOCUMENTNAMETYPE_APPNODE + 1 ) ,
	DOCUMENTNAMETYPE_FILE_TAIL	= ( DOCUMENTNAMETYPE_TITLE + 1 ) ,
	DOCUMENTNAMETYPE_URL	= ( DOCUMENTNAMETYPE_FILE_TAIL + 1 ) 
    } 	DOCUMENTNAMETYPE;

typedef WORD SOURCE_TEXT_ATTR;

#define	SOURCETEXT_ATTR_KEYWORD	( 0x1 )

#define	SOURCETEXT_ATTR_COMMENT	( 0x2 )

#define	SOURCETEXT_ATTR_NONSOURCE	( 0x4 )

#define	SOURCETEXT_ATTR_OPERATOR	( 0x8 )

#define	SOURCETEXT_ATTR_NUMBER	( 0x10 )

#define	SOURCETEXT_ATTR_STRING	( 0x20 )

#define	SOURCETEXT_ATTR_FUNCTION_START	( 0x40 )

typedef DWORD TEXT_DOC_ATTR;

#define	TEXT_DOC_ATTR_READONLY	( 0x1 )

#define	DEBUG_TEXT_ISEXPRESSION	( 0x1 )

#define	DEBUG_TEXT_RETURNVALUE	( 0x2 )

#define	DEBUG_TEXT_NOSIDEEFFECTS	( 0x4 )

#define	DEBUG_TEXT_ALLOWBREAKPOINTS	( 0x8 )

#define	DEBUG_TEXT_ALLOWERRORREPORT	( 0x10 )

#define	DEBUG_TEXT_EVALUATETOCODECONTEXT	( 0x20 )

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IActiveScriptDebug IActiveScriptDebug64
#define IID_IActiveScriptDebug IID_IActiveScriptDebug64
#else
#define IActiveScriptDebug IActiveScriptDebug32
#define IID_IActiveScriptDebug IID_IActiveScriptDebug32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0000_v0_0_s_ifspec;

#ifndef __IActiveScriptDebug32_INTERFACE_DEFINED__
#define __IActiveScriptDebug32_INTERFACE_DEFINED__

/* interface IActiveScriptDebug32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptDebug32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C10-CB0C-11d0-B5C9-00A0244A0E7A")
    IActiveScriptDebug32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptletTextAttributes( 
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContextsOfPosition( 
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptDebug32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptDebug32 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptDebug32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptDebug32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptTextAttributes )( 
            IActiveScriptDebug32 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptletTextAttributes )( 
            IActiveScriptDebug32 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeContextsOfPosition )( 
            IActiveScriptDebug32 * This,
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc);
        
        END_INTERFACE
    } IActiveScriptDebug32Vtbl;

    interface IActiveScriptDebug32
    {
        CONST_VTBL struct IActiveScriptDebug32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptDebug32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptDebug32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptDebug32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptDebug32_GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)	\
    ( (This)->lpVtbl -> GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr) ) 

#define IActiveScriptDebug32_GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)	\
    ( (This)->lpVtbl -> GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr) ) 

#define IActiveScriptDebug32_EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc)	\
    ( (This)->lpVtbl -> EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptDebug32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptDebug64_INTERFACE_DEFINED__
#define __IActiveScriptDebug64_INTERFACE_DEFINED__

/* interface IActiveScriptDebug64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptDebug64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc437e23-f5b8-47f4-bb79-7d1ce5483b86")
    IActiveScriptDebug64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptletTextAttributes( 
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContextsOfPosition( 
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptDebug64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptDebug64 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptDebug64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptDebug64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptTextAttributes )( 
            IActiveScriptDebug64 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptletTextAttributes )( 
            IActiveScriptDebug64 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeContextsOfPosition )( 
            IActiveScriptDebug64 * This,
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc);
        
        END_INTERFACE
    } IActiveScriptDebug64Vtbl;

    interface IActiveScriptDebug64
    {
        CONST_VTBL struct IActiveScriptDebug64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptDebug64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptDebug64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptDebug64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptDebug64_GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)	\
    ( (This)->lpVtbl -> GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr) ) 

#define IActiveScriptDebug64_GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)	\
    ( (This)->lpVtbl -> GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr) ) 

#define IActiveScriptDebug64_EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc)	\
    ( (This)->lpVtbl -> EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptDebug64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0002 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IActiveScriptSiteDebug IActiveScriptSiteDebug64
#define IID_IActiveScriptSiteDebug IID_IActiveScriptSiteDebug64
#else
#define IActiveScriptSiteDebug IActiveScriptSiteDebug32
#define IID_IActiveScriptSiteDebug IID_IActiveScriptSiteDebug32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0002_v0_0_s_ifspec;

#ifndef __IActiveScriptSiteDebug32_INTERFACE_DEFINED__
#define __IActiveScriptSiteDebug32_INTERFACE_DEFINED__

/* interface IActiveScriptSiteDebug32 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteDebug32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C11-CB0C-11d0-B5C9-00A0244A0E7A")
    IActiveScriptSiteDebug32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContextFromPosition( 
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext **ppsc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [out] */ IDebugApplication32 **ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootApplicationNode( 
            /* [out] */ IDebugApplicationNode **ppdanRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptErrorDebug( 
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [out] */ BOOL *pfEnterDebugger,
            /* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteDebug32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteDebug32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteDebug32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteDebug32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContextFromPosition )( 
            IActiveScriptSiteDebug32 * This,
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext **ppsc);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IActiveScriptSiteDebug32 * This,
            /* [out] */ IDebugApplication32 **ppda);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootApplicationNode )( 
            IActiveScriptSiteDebug32 * This,
            /* [out] */ IDebugApplicationNode **ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnScriptErrorDebug )( 
            IActiveScriptSiteDebug32 * This,
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [out] */ BOOL *pfEnterDebugger,
            /* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing);
        
        END_INTERFACE
    } IActiveScriptSiteDebug32Vtbl;

    interface IActiveScriptSiteDebug32
    {
        CONST_VTBL struct IActiveScriptSiteDebug32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteDebug32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteDebug32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteDebug32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteDebug32_GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc)	\
    ( (This)->lpVtbl -> GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc) ) 

#define IActiveScriptSiteDebug32_GetApplication(This,ppda)	\
    ( (This)->lpVtbl -> GetApplication(This,ppda) ) 

#define IActiveScriptSiteDebug32_GetRootApplicationNode(This,ppdanRoot)	\
    ( (This)->lpVtbl -> GetRootApplicationNode(This,ppdanRoot) ) 

#define IActiveScriptSiteDebug32_OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing)	\
    ( (This)->lpVtbl -> OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteDebug32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteDebug64_INTERFACE_DEFINED__
#define __IActiveScriptSiteDebug64_INTERFACE_DEFINED__

/* interface IActiveScriptSiteDebug64 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteDebug64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d6b96b0a-7463-402c-92ac-89984226942f")
    IActiveScriptSiteDebug64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContextFromPosition( 
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext **ppsc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [out] */ IDebugApplication64 **ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootApplicationNode( 
            /* [out] */ IDebugApplicationNode **ppdanRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptErrorDebug( 
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [out] */ BOOL *pfEnterDebugger,
            /* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteDebug64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteDebug64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteDebug64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteDebug64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContextFromPosition )( 
            IActiveScriptSiteDebug64 * This,
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext **ppsc);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IActiveScriptSiteDebug64 * This,
            /* [out] */ IDebugApplication64 **ppda);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootApplicationNode )( 
            IActiveScriptSiteDebug64 * This,
            /* [out] */ IDebugApplicationNode **ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnScriptErrorDebug )( 
            IActiveScriptSiteDebug64 * This,
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [out] */ BOOL *pfEnterDebugger,
            /* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing);
        
        END_INTERFACE
    } IActiveScriptSiteDebug64Vtbl;

    interface IActiveScriptSiteDebug64
    {
        CONST_VTBL struct IActiveScriptSiteDebug64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteDebug64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteDebug64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteDebug64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteDebug64_GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc)	\
    ( (This)->lpVtbl -> GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc) ) 

#define IActiveScriptSiteDebug64_GetApplication(This,ppda)	\
    ( (This)->lpVtbl -> GetApplication(This,ppda) ) 

#define IActiveScriptSiteDebug64_GetRootApplicationNode(This,ppdanRoot)	\
    ( (This)->lpVtbl -> GetRootApplicationNode(This,ppdanRoot) ) 

#define IActiveScriptSiteDebug64_OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing)	\
    ( (This)->lpVtbl -> OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteDebug64_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteDebugEx_INTERFACE_DEFINED__
#define __IActiveScriptSiteDebugEx_INTERFACE_DEFINED__

/* interface IActiveScriptSiteDebugEx */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteDebugEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB722CCB-6AD2-41c6-B780-AF9C03EE69F5")
    IActiveScriptSiteDebugEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCanNotJITScriptErrorDebug( 
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteDebugExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteDebugEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteDebugEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteDebugEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCanNotJITScriptErrorDebug )( 
            IActiveScriptSiteDebugEx * This,
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing);
        
        END_INTERFACE
    } IActiveScriptSiteDebugExVtbl;

    interface IActiveScriptSiteDebugEx
    {
        CONST_VTBL struct IActiveScriptSiteDebugExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteDebugEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteDebugEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteDebugEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteDebugEx_OnCanNotJITScriptErrorDebug(This,pErrorDebug,pfCallOnScriptErrorWhenContinuing)	\
    ( (This)->lpVtbl -> OnCanNotJITScriptErrorDebug(This,pErrorDebug,pfCallOnScriptErrorWhenContinuing) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteDebugEx_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptErrorDebug_INTERFACE_DEFINED__
#define __IActiveScriptErrorDebug_INTERFACE_DEFINED__

/* interface IActiveScriptErrorDebug */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptErrorDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C12-CB0C-11d0-B5C9-00A0244A0E7A")
    IActiveScriptErrorDebug : public IActiveScriptError
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppssc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackFrame( 
            /* [out] */ __RPC__deref_out_opt IDebugStackFrame **ppdsf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptErrorDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptErrorDebug * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptErrorDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptErrorDebug * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExceptionInfo )( 
            IActiveScriptErrorDebug * This,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IActiveScriptErrorDebug * This,
            /* [out] */ __RPC__out DWORD *pdwSourceContext,
            /* [out] */ __RPC__out ULONG *pulLineNumber,
            /* [out] */ __RPC__out LONG *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLineText )( 
            IActiveScriptErrorDebug * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSourceLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContext )( 
            IActiveScriptErrorDebug * This,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppssc);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackFrame )( 
            IActiveScriptErrorDebug * This,
            /* [out] */ __RPC__deref_out_opt IDebugStackFrame **ppdsf);
        
        END_INTERFACE
    } IActiveScriptErrorDebugVtbl;

    interface IActiveScriptErrorDebug
    {
        CONST_VTBL struct IActiveScriptErrorDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptErrorDebug_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptErrorDebug_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptErrorDebug_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptErrorDebug_GetExceptionInfo(This,pexcepinfo)	\
    ( (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo) ) 

#define IActiveScriptErrorDebug_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition) ) 

#define IActiveScriptErrorDebug_GetSourceLineText(This,pbstrSourceLine)	\
    ( (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine) ) 


#define IActiveScriptErrorDebug_GetDocumentContext(This,ppssc)	\
    ( (This)->lpVtbl -> GetDocumentContext(This,ppssc) ) 

#define IActiveScriptErrorDebug_GetStackFrame(This,ppdsf)	\
    ( (This)->lpVtbl -> GetStackFrame(This,ppdsf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptErrorDebug_INTERFACE_DEFINED__ */


#ifndef __IDebugCodeContext_INTERFACE_DEFINED__
#define __IDebugCodeContext_INTERFACE_DEFINED__

/* interface IDebugCodeContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugCodeContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C13-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugCodeContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppsc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBreakPoint( 
            /* [in] */ BREAKPOINT_STATE bps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugCodeContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugCodeContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugCodeContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugCodeContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContext )( 
            IDebugCodeContext * This,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppsc);
        
        HRESULT ( STDMETHODCALLTYPE *SetBreakPoint )( 
            IDebugCodeContext * This,
            /* [in] */ BREAKPOINT_STATE bps);
        
        END_INTERFACE
    } IDebugCodeContextVtbl;

    interface IDebugCodeContext
    {
        CONST_VTBL struct IDebugCodeContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugCodeContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugCodeContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugCodeContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugCodeContext_GetDocumentContext(This,ppsc)	\
    ( (This)->lpVtbl -> GetDocumentContext(This,ppsc) ) 

#define IDebugCodeContext_SetBreakPoint(This,bps)	\
    ( (This)->lpVtbl -> SetBreakPoint(This,bps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugCodeContext_INTERFACE_DEFINED__ */


#ifndef __IDebugExpression_INTERFACE_DEFINED__
#define __IDebugExpression_INTERFACE_DEFINED__

/* interface IDebugExpression */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpression;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C14-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExpression : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ __RPC__in_opt IDebugExpressionCallBack *pdecb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultAsString( 
            /* [out] */ __RPC__out HRESULT *phrResult,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultAsDebugProperty( 
            /* [out] */ __RPC__out HRESULT *phrResult,
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppdp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExpressionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExpression * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExpression * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExpression * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDebugExpression * This,
            /* [in] */ __RPC__in_opt IDebugExpressionCallBack *pdecb);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IDebugExpression * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryIsComplete )( 
            IDebugExpression * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultAsString )( 
            IDebugExpression * This,
            /* [out] */ __RPC__out HRESULT *phrResult,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultAsDebugProperty )( 
            IDebugExpression * This,
            /* [out] */ __RPC__out HRESULT *phrResult,
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppdp);
        
        END_INTERFACE
    } IDebugExpressionVtbl;

    interface IDebugExpression
    {
        CONST_VTBL struct IDebugExpressionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpression_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugExpression_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugExpression_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugExpression_Start(This,pdecb)	\
    ( (This)->lpVtbl -> Start(This,pdecb) ) 

#define IDebugExpression_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IDebugExpression_QueryIsComplete(This)	\
    ( (This)->lpVtbl -> QueryIsComplete(This) ) 

#define IDebugExpression_GetResultAsString(This,phrResult,pbstrResult)	\
    ( (This)->lpVtbl -> GetResultAsString(This,phrResult,pbstrResult) ) 

#define IDebugExpression_GetResultAsDebugProperty(This,phrResult,ppdp)	\
    ( (This)->lpVtbl -> GetResultAsDebugProperty(This,phrResult,ppdp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugExpression_INTERFACE_DEFINED__ */


#ifndef __IDebugExpressionContext_INTERFACE_DEFINED__
#define __IDebugExpressionContext_INTERFACE_DEFINED__

/* interface IDebugExpressionContext */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpressionContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C15-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExpressionContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseLanguageText( 
            /* [in] */ __RPC__in LPCOLESTR pstrCode,
            /* [in] */ UINT nRadix,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IDebugExpression **ppe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLanguageName,
            /* [out] */ __RPC__out GUID *pLanguageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExpressionContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExpressionContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExpressionContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExpressionContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseLanguageText )( 
            IDebugExpressionContext * This,
            /* [in] */ __RPC__in LPCOLESTR pstrCode,
            /* [in] */ UINT nRadix,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IDebugExpression **ppe);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageInfo )( 
            IDebugExpressionContext * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLanguageName,
            /* [out] */ __RPC__out GUID *pLanguageID);
        
        END_INTERFACE
    } IDebugExpressionContextVtbl;

    interface IDebugExpressionContext
    {
        CONST_VTBL struct IDebugExpressionContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpressionContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugExpressionContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugExpressionContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugExpressionContext_ParseLanguageText(This,pstrCode,nRadix,pstrDelimiter,dwFlags,ppe)	\
    ( (This)->lpVtbl -> ParseLanguageText(This,pstrCode,nRadix,pstrDelimiter,dwFlags,ppe) ) 

#define IDebugExpressionContext_GetLanguageInfo(This,pbstrLanguageName,pLanguageID)	\
    ( (This)->lpVtbl -> GetLanguageInfo(This,pbstrLanguageName,pLanguageID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugExpressionContext_INTERFACE_DEFINED__ */


#ifndef __IDebugExpressionCallBack_INTERFACE_DEFINED__
#define __IDebugExpressionCallBack_INTERFACE_DEFINED__

/* interface IDebugExpressionCallBack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpressionCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C16-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExpressionCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onComplete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExpressionCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExpressionCallBack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExpressionCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExpressionCallBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *onComplete )( 
            IDebugExpressionCallBack * This);
        
        END_INTERFACE
    } IDebugExpressionCallBackVtbl;

    interface IDebugExpressionCallBack
    {
        CONST_VTBL struct IDebugExpressionCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpressionCallBack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugExpressionCallBack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugExpressionCallBack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugExpressionCallBack_onComplete(This)	\
    ( (This)->lpVtbl -> onComplete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugExpressionCallBack_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrame_INTERFACE_DEFINED__
#define __IDebugStackFrame_INTERFACE_DEFINED__

/* interface IDebugStackFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C17-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugStackFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodeContext( 
            /* [out] */ __RPC__deref_out_opt IDebugCodeContext **ppcc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionString( 
            /* [in] */ BOOL fLong,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageString( 
            /* [in] */ BOOL fLong,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ __RPC__deref_out_opt IDebugApplicationThread **ppat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugProperty( 
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugStackFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugStackFrame * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugStackFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugStackFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeContext )( 
            IDebugStackFrame * This,
            /* [out] */ __RPC__deref_out_opt IDebugCodeContext **ppcc);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionString )( 
            IDebugStackFrame * This,
            /* [in] */ BOOL fLong,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageString )( 
            IDebugStackFrame * This,
            /* [in] */ BOOL fLong,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            IDebugStackFrame * This,
            /* [out] */ __RPC__deref_out_opt IDebugApplicationThread **ppat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugProperty )( 
            IDebugStackFrame * This,
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppDebugProp);
        
        END_INTERFACE
    } IDebugStackFrameVtbl;

    interface IDebugStackFrame
    {
        CONST_VTBL struct IDebugStackFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugStackFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugStackFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugStackFrame_GetCodeContext(This,ppcc)	\
    ( (This)->lpVtbl -> GetCodeContext(This,ppcc) ) 

#define IDebugStackFrame_GetDescriptionString(This,fLong,pbstrDescription)	\
    ( (This)->lpVtbl -> GetDescriptionString(This,fLong,pbstrDescription) ) 

#define IDebugStackFrame_GetLanguageString(This,fLong,pbstrLanguage)	\
    ( (This)->lpVtbl -> GetLanguageString(This,fLong,pbstrLanguage) ) 

#define IDebugStackFrame_GetThread(This,ppat)	\
    ( (This)->lpVtbl -> GetThread(This,ppat) ) 

#define IDebugStackFrame_GetDebugProperty(This,ppDebugProp)	\
    ( (This)->lpVtbl -> GetDebugProperty(This,ppDebugProp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugStackFrame_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrameSniffer_INTERFACE_DEFINED__
#define __IDebugStackFrameSniffer_INTERFACE_DEFINED__

/* interface IDebugStackFrameSniffer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrameSniffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C18-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugStackFrameSniffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumStackFrames( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugStackFrameSnifferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugStackFrameSniffer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugStackFrameSniffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugStackFrameSniffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFrames )( 
            IDebugStackFrameSniffer * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        END_INTERFACE
    } IDebugStackFrameSnifferVtbl;

    interface IDebugStackFrameSniffer
    {
        CONST_VTBL struct IDebugStackFrameSnifferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrameSniffer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugStackFrameSniffer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugStackFrameSniffer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugStackFrameSniffer_EnumStackFrames(This,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFrames(This,ppedsf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugStackFrameSniffer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0012 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugStackFrameSnifferEx IDebugStackFrameSnifferEx64
#define IID_IDebugStackFrameSnifferEx IID_IDebugStackFrameSnifferEx64
#define EnumStackFramesEx EnumStackFramesEx64
#else
#define IDebugStackFrameSnifferEx IDebugStackFrameSnifferEx32
#define IID_IDebugStackFrameSnifferEx IID_IDebugStackFrameSnifferEx32
#define EnumStackFramesEx EnumStackFramesEx32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0012_v0_0_s_ifspec;

#ifndef __IDebugStackFrameSnifferEx32_INTERFACE_DEFINED__
#define __IDebugStackFrameSnifferEx32_INTERFACE_DEFINED__

/* interface IDebugStackFrameSnifferEx32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrameSnifferEx32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C19-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugStackFrameSnifferEx32 : public IDebugStackFrameSniffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumStackFramesEx32( 
            /* [in] */ DWORD dwSpMin,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugStackFrameSnifferEx32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugStackFrameSnifferEx32 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugStackFrameSnifferEx32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugStackFrameSnifferEx32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFrames )( 
            IDebugStackFrameSnifferEx32 * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFramesEx32 )( 
            IDebugStackFrameSnifferEx32 * This,
            /* [in] */ DWORD dwSpMin,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        END_INTERFACE
    } IDebugStackFrameSnifferEx32Vtbl;

    interface IDebugStackFrameSnifferEx32
    {
        CONST_VTBL struct IDebugStackFrameSnifferEx32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrameSnifferEx32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugStackFrameSnifferEx32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugStackFrameSnifferEx32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugStackFrameSnifferEx32_EnumStackFrames(This,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFrames(This,ppedsf) ) 


#define IDebugStackFrameSnifferEx32_EnumStackFramesEx32(This,dwSpMin,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFramesEx32(This,dwSpMin,ppedsf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugStackFrameSnifferEx32_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx64_INTERFACE_DEFINED__
#define __IDebugStackFrameSnifferEx64_INTERFACE_DEFINED__

/* interface IDebugStackFrameSnifferEx64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrameSnifferEx64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8cd12af4-49c1-4d52-8d8a-c146f47581aa")
    IDebugStackFrameSnifferEx64 : public IDebugStackFrameSniffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumStackFramesEx64( 
            /* [in] */ DWORDLONG dwSpMin,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames64 **ppedsf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugStackFrameSnifferEx64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugStackFrameSnifferEx64 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugStackFrameSnifferEx64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugStackFrameSnifferEx64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFrames )( 
            IDebugStackFrameSnifferEx64 * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFramesEx64 )( 
            IDebugStackFrameSnifferEx64 * This,
            /* [in] */ DWORDLONG dwSpMin,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames64 **ppedsf);
        
        END_INTERFACE
    } IDebugStackFrameSnifferEx64Vtbl;

    interface IDebugStackFrameSnifferEx64
    {
        CONST_VTBL struct IDebugStackFrameSnifferEx64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrameSnifferEx64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugStackFrameSnifferEx64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugStackFrameSnifferEx64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugStackFrameSnifferEx64_EnumStackFrames(This,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFrames(This,ppedsf) ) 


#define IDebugStackFrameSnifferEx64_EnumStackFramesEx64(This,dwSpMin,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFramesEx64(This,dwSpMin,ppedsf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugStackFrameSnifferEx64_INTERFACE_DEFINED__ */


#ifndef __IDebugSyncOperation_INTERFACE_DEFINED__
#define __IDebugSyncOperation_INTERFACE_DEFINED__

/* interface IDebugSyncOperation */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugSyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1a-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugSyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetThread( 
            /* [out] */ IDebugApplicationThread **ppatTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [out] */ IUnknown **ppunkResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InProgressAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugSyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSyncOperation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSyncOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSyncOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetThread )( 
            IDebugSyncOperation * This,
            /* [out] */ IDebugApplicationThread **ppatTarget);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDebugSyncOperation * This,
            /* [out] */ IUnknown **ppunkResult);
        
        HRESULT ( STDMETHODCALLTYPE *InProgressAbort )( 
            IDebugSyncOperation * This);
        
        END_INTERFACE
    } IDebugSyncOperationVtbl;

    interface IDebugSyncOperation
    {
        CONST_VTBL struct IDebugSyncOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSyncOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugSyncOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugSyncOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugSyncOperation_GetTargetThread(This,ppatTarget)	\
    ( (This)->lpVtbl -> GetTargetThread(This,ppatTarget) ) 

#define IDebugSyncOperation_Execute(This,ppunkResult)	\
    ( (This)->lpVtbl -> Execute(This,ppunkResult) ) 

#define IDebugSyncOperation_InProgressAbort(This)	\
    ( (This)->lpVtbl -> InProgressAbort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugSyncOperation_INTERFACE_DEFINED__ */


#ifndef __IDebugAsyncOperation_INTERFACE_DEFINED__
#define __IDebugAsyncOperation_INTERFACE_DEFINED__

/* interface IDebugAsyncOperation */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugAsyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1b-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugAsyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSyncDebugOperation( 
            /* [out] */ IDebugSyncOperation **ppsdo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            IDebugAsyncOperationCallBack *padocb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ HRESULT *phrResult,
            /* [out] */ IUnknown **ppunkResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugAsyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugAsyncOperation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugAsyncOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugAsyncOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncDebugOperation )( 
            IDebugAsyncOperation * This,
            /* [out] */ IDebugSyncOperation **ppsdo);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDebugAsyncOperation * This,
            IDebugAsyncOperationCallBack *padocb);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IDebugAsyncOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryIsComplete )( 
            IDebugAsyncOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IDebugAsyncOperation * This,
            /* [out] */ HRESULT *phrResult,
            /* [out] */ IUnknown **ppunkResult);
        
        END_INTERFACE
    } IDebugAsyncOperationVtbl;

    interface IDebugAsyncOperation
    {
        CONST_VTBL struct IDebugAsyncOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugAsyncOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugAsyncOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugAsyncOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugAsyncOperation_GetSyncDebugOperation(This,ppsdo)	\
    ( (This)->lpVtbl -> GetSyncDebugOperation(This,ppsdo) ) 

#define IDebugAsyncOperation_Start(This,padocb)	\
    ( (This)->lpVtbl -> Start(This,padocb) ) 

#define IDebugAsyncOperation_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IDebugAsyncOperation_QueryIsComplete(This)	\
    ( (This)->lpVtbl -> QueryIsComplete(This) ) 

#define IDebugAsyncOperation_GetResult(This,phrResult,ppunkResult)	\
    ( (This)->lpVtbl -> GetResult(This,phrResult,ppunkResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugAsyncOperation_INTERFACE_DEFINED__ */


#ifndef __IDebugAsyncOperationCallBack_INTERFACE_DEFINED__
#define __IDebugAsyncOperationCallBack_INTERFACE_DEFINED__

/* interface IDebugAsyncOperationCallBack */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugAsyncOperationCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1c-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugAsyncOperationCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onComplete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugAsyncOperationCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugAsyncOperationCallBack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugAsyncOperationCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugAsyncOperationCallBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *onComplete )( 
            IDebugAsyncOperationCallBack * This);
        
        END_INTERFACE
    } IDebugAsyncOperationCallBackVtbl;

    interface IDebugAsyncOperationCallBack
    {
        CONST_VTBL struct IDebugAsyncOperationCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugAsyncOperationCallBack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugAsyncOperationCallBack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugAsyncOperationCallBack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugAsyncOperationCallBack_onComplete(This)	\
    ( (This)->lpVtbl -> onComplete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugAsyncOperationCallBack_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugCodeContexts_INTERFACE_DEFINED__
#define __IEnumDebugCodeContexts_INTERFACE_DEFINED__

/* interface IEnumDebugCodeContexts */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugCodeContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1d-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugCodeContexts : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDebugCodeContext **pscc,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugCodeContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugCodeContexts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugCodeContexts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugCodeContexts * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumDebugCodeContexts * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDebugCodeContext **pscc,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugCodeContexts * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugCodeContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugCodeContexts * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc);
        
        END_INTERFACE
    } IEnumDebugCodeContextsVtbl;

    interface IEnumDebugCodeContexts
    {
        CONST_VTBL struct IEnumDebugCodeContextsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugCodeContexts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugCodeContexts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugCodeContexts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugCodeContexts_Next(This,celt,pscc,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pscc,pceltFetched) ) 

#define IEnumDebugCodeContexts_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugCodeContexts_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugCodeContexts_Clone(This,ppescc)	\
    ( (This)->lpVtbl -> Clone(This,ppescc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugCodeContexts_RemoteNext_Proxy( 
    IEnumDebugCodeContexts * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IDebugCodeContext **pscc,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumDebugCodeContexts_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugCodeContexts_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0018 */
/* [local] */ 

typedef struct tagDebugStackFrameDescriptor
    {
    IDebugStackFrame *pdsf;
    DWORD dwMin;
    DWORD dwLim;
    BOOL fFinal;
    IUnknown *punkFinal;
    } 	DebugStackFrameDescriptor;

typedef struct tagDebugStackFrameDescriptor64
    {
    IDebugStackFrame *pdsf;
    DWORDLONG dwMin;
    DWORDLONG dwLim;
    BOOL fFinal;
    IUnknown *punkFinal;
    } 	DebugStackFrameDescriptor64;



extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0018_v0_0_s_ifspec;

#ifndef __IEnumDebugStackFrames_INTERFACE_DEFINED__
#define __IEnumDebugStackFrames_INTERFACE_DEFINED__

/* interface IEnumDebugStackFrames */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugStackFrames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1e-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugStackFrames : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor *prgdsfd,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugStackFramesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugStackFrames * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugStackFrames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugStackFrames * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumDebugStackFrames * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor *prgdsfd,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugStackFrames * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugStackFrames * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugStackFrames * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        END_INTERFACE
    } IEnumDebugStackFramesVtbl;

    interface IEnumDebugStackFrames
    {
        CONST_VTBL struct IEnumDebugStackFramesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugStackFrames_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugStackFrames_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugStackFrames_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugStackFrames_Next(This,celt,prgdsfd,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,prgdsfd,pceltFetched) ) 

#define IEnumDebugStackFrames_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugStackFrames_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugStackFrames_Clone(This,ppedsf)	\
    ( (This)->lpVtbl -> Clone(This,ppedsf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames_RemoteNext_Proxy( 
    IEnumDebugStackFrames * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) DebugStackFrameDescriptor *prgdsfd,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumDebugStackFrames_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugStackFrames_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugStackFrames64_INTERFACE_DEFINED__
#define __IEnumDebugStackFrames64_INTERFACE_DEFINED__

/* interface IEnumDebugStackFrames64 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugStackFrames64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0dc38853-c1b0-4176-a984-b298361027af")
    IEnumDebugStackFrames64 : public IEnumDebugStackFrames
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next64( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor64 *prgdsfd,
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugStackFrames64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugStackFrames64 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugStackFrames64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugStackFrames64 * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumDebugStackFrames64 * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor *prgdsfd,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugStackFrames64 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugStackFrames64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugStackFrames64 * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        /* [local] */ HRESULT ( __stdcall *Next64 )( 
            IEnumDebugStackFrames64 * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor64 *prgdsfd,
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } IEnumDebugStackFrames64Vtbl;

    interface IEnumDebugStackFrames64
    {
        CONST_VTBL struct IEnumDebugStackFrames64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugStackFrames64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugStackFrames64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugStackFrames64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugStackFrames64_Next(This,celt,prgdsfd,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,prgdsfd,pceltFetched) ) 

#define IEnumDebugStackFrames64_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugStackFrames64_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugStackFrames64_Clone(This,ppedsf)	\
    ( (This)->lpVtbl -> Clone(This,ppedsf) ) 


#define IEnumDebugStackFrames64_Next64(This,celt,prgdsfd,pceltFetched)	\
    ( (This)->lpVtbl -> Next64(This,celt,prgdsfd,pceltFetched) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames64_RemoteNext64_Proxy( 
    IEnumDebugStackFrames64 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) DebugStackFrameDescriptor64 *prgdsfd,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumDebugStackFrames64_RemoteNext64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugStackFrames64_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentInfo_INTERFACE_DEFINED__
#define __IDebugDocumentInfo_INTERFACE_DEFINED__

/* interface IDebugDocumentInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1f-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentClassId( 
            /* [out] */ __RPC__out CLSID *pclsidDocument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocumentInfo * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocumentInfo * This,
            /* [out] */ __RPC__out CLSID *pclsidDocument);
        
        END_INTERFACE
    } IDebugDocumentInfoVtbl;

    interface IDebugDocumentInfo
    {
        CONST_VTBL struct IDebugDocumentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentInfo_GetName(This,dnt,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,dnt,pbstrName) ) 

#define IDebugDocumentInfo_GetDocumentClassId(This,pclsidDocument)	\
    ( (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentProvider_INTERFACE_DEFINED__
#define __IDebugDocumentProvider_INTERFACE_DEFINED__

/* interface IDebugDocumentProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C20-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentProvider : public IDebugDocumentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ __RPC__deref_out_opt IDebugDocument **ppssd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocumentProvider * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocumentProvider * This,
            /* [out] */ __RPC__out CLSID *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugDocumentProvider * This,
            /* [out] */ __RPC__deref_out_opt IDebugDocument **ppssd);
        
        END_INTERFACE
    } IDebugDocumentProviderVtbl;

    interface IDebugDocumentProvider
    {
        CONST_VTBL struct IDebugDocumentProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentProvider_GetName(This,dnt,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,dnt,pbstrName) ) 

#define IDebugDocumentProvider_GetDocumentClassId(This,pclsidDocument)	\
    ( (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument) ) 


#define IDebugDocumentProvider_GetDocument(This,ppssd)	\
    ( (This)->lpVtbl -> GetDocument(This,ppssd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentProvider_INTERFACE_DEFINED__ */


#ifndef __IDebugDocument_INTERFACE_DEFINED__
#define __IDebugDocument_INTERFACE_DEFINED__

/* interface IDebugDocument */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C21-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocument : public IDebugDocumentInfo
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocument * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocument * This,
            /* [out] */ __RPC__out CLSID *pclsidDocument);
        
        END_INTERFACE
    } IDebugDocumentVtbl;

    interface IDebugDocument
    {
        CONST_VTBL struct IDebugDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocument_GetName(This,dnt,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,dnt,pbstrName) ) 

#define IDebugDocument_GetDocumentClassId(This,pclsidDocument)	\
    ( (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocument_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0023 */
/* [local] */ 

#pragma warning(push)
#pragma warning(disable:28718)	


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0023_v0_0_s_ifspec;

#ifndef __IDebugDocumentText_INTERFACE_DEFINED__
#define __IDebugDocumentText_INTERFACE_DEFINED__

/* interface IDebugDocumentText */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C22-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentText : public IDebugDocument
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentAttributes( 
            /* [out] */ __RPC__out TEXT_DOC_ATTR *ptextdocattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out ULONG *pcNumLines,
            /* [out] */ __RPC__out ULONG *pcNumChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositionOfLine( 
            /* [in] */ ULONG cLineNumber,
            /* [out] */ __RPC__out ULONG *pcCharacterPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineOfPosition( 
            /* [in] */ ULONG cCharacterPosition,
            /* [out] */ __RPC__out ULONG *pcLineNumber,
            /* [out] */ __RPC__out ULONG *pcCharacterOffsetInLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) WCHAR *pcharText,
            /* [full][size_is][length_is][out][in] */ __RPC__inout_ecount_part_opt(cMaxChars, *pcNumChars) SOURCE_TEXT_ATTR *pstaTextAttr,
            /* [out][in] */ __RPC__inout ULONG *pcNumChars,
            /* [in] */ ULONG cMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositionOfContext( 
            /* [in] */ __RPC__in_opt IDebugDocumentContext *psc,
            /* [out] */ __RPC__out ULONG *pcCharacterPosition,
            /* [out] */ __RPC__out ULONG *cNumChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextOfPosition( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppsc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentText * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocumentText * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocumentText * This,
            /* [out] */ __RPC__out CLSID *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentAttributes )( 
            IDebugDocumentText * This,
            /* [out] */ __RPC__out TEXT_DOC_ATTR *ptextdocattr);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugDocumentText * This,
            /* [out] */ __RPC__out ULONG *pcNumLines,
            /* [out] */ __RPC__out ULONG *pcNumChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositionOfLine )( 
            IDebugDocumentText * This,
            /* [in] */ ULONG cLineNumber,
            /* [out] */ __RPC__out ULONG *pcCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineOfPosition )( 
            IDebugDocumentText * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [out] */ __RPC__out ULONG *pcLineNumber,
            /* [out] */ __RPC__out ULONG *pcCharacterOffsetInLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IDebugDocumentText * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) WCHAR *pcharText,
            /* [full][size_is][length_is][out][in] */ __RPC__inout_ecount_part_opt(cMaxChars, *pcNumChars) SOURCE_TEXT_ATTR *pstaTextAttr,
            /* [out][in] */ __RPC__inout ULONG *pcNumChars,
            /* [in] */ ULONG cMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositionOfContext )( 
            IDebugDocumentText * This,
            /* [in] */ __RPC__in_opt IDebugDocumentContext *psc,
            /* [out] */ __RPC__out ULONG *pcCharacterPosition,
            /* [out] */ __RPC__out ULONG *cNumChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextOfPosition )( 
            IDebugDocumentText * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppsc);
        
        END_INTERFACE
    } IDebugDocumentTextVtbl;

    interface IDebugDocumentText
    {
        CONST_VTBL struct IDebugDocumentTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentText_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentText_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentText_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentText_GetName(This,dnt,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,dnt,pbstrName) ) 

#define IDebugDocumentText_GetDocumentClassId(This,pclsidDocument)	\
    ( (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument) ) 



#define IDebugDocumentText_GetDocumentAttributes(This,ptextdocattr)	\
    ( (This)->lpVtbl -> GetDocumentAttributes(This,ptextdocattr) ) 

#define IDebugDocumentText_GetSize(This,pcNumLines,pcNumChars)	\
    ( (This)->lpVtbl -> GetSize(This,pcNumLines,pcNumChars) ) 

#define IDebugDocumentText_GetPositionOfLine(This,cLineNumber,pcCharacterPosition)	\
    ( (This)->lpVtbl -> GetPositionOfLine(This,cLineNumber,pcCharacterPosition) ) 

#define IDebugDocumentText_GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine)	\
    ( (This)->lpVtbl -> GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine) ) 

#define IDebugDocumentText_GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars)	\
    ( (This)->lpVtbl -> GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars) ) 

#define IDebugDocumentText_GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars)	\
    ( (This)->lpVtbl -> GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars) ) 

#define IDebugDocumentText_GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc)	\
    ( (This)->lpVtbl -> GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentText_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0024 */
/* [local] */ 

#pragma warning(pop)


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0024_v0_0_s_ifspec;

#ifndef __IDebugDocumentTextEvents_INTERFACE_DEFINED__
#define __IDebugDocumentTextEvents_INTERFACE_DEFINED__

/* interface IDebugDocumentTextEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentTextEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C23-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentTextEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onDestroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onInsertText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onReplaceText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onUpdateTextAttributes( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToUpdate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onUpdateDocumentAttributes( 
            /* [in] */ TEXT_DOC_ATTR textdocattr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentTextEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentTextEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentTextEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentTextEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *onDestroy )( 
            IDebugDocumentTextEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *onInsertText )( 
            IDebugDocumentTextEvents * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert);
        
        HRESULT ( STDMETHODCALLTYPE *onRemoveText )( 
            IDebugDocumentTextEvents * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove);
        
        HRESULT ( STDMETHODCALLTYPE *onReplaceText )( 
            IDebugDocumentTextEvents * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace);
        
        HRESULT ( STDMETHODCALLTYPE *onUpdateTextAttributes )( 
            IDebugDocumentTextEvents * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToUpdate);
        
        HRESULT ( STDMETHODCALLTYPE *onUpdateDocumentAttributes )( 
            IDebugDocumentTextEvents * This,
            /* [in] */ TEXT_DOC_ATTR textdocattr);
        
        END_INTERFACE
    } IDebugDocumentTextEventsVtbl;

    interface IDebugDocumentTextEvents
    {
        CONST_VTBL struct IDebugDocumentTextEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentTextEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentTextEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentTextEvents_onDestroy(This)	\
    ( (This)->lpVtbl -> onDestroy(This) ) 

#define IDebugDocumentTextEvents_onInsertText(This,cCharacterPosition,cNumToInsert)	\
    ( (This)->lpVtbl -> onInsertText(This,cCharacterPosition,cNumToInsert) ) 

#define IDebugDocumentTextEvents_onRemoveText(This,cCharacterPosition,cNumToRemove)	\
    ( (This)->lpVtbl -> onRemoveText(This,cCharacterPosition,cNumToRemove) ) 

#define IDebugDocumentTextEvents_onReplaceText(This,cCharacterPosition,cNumToReplace)	\
    ( (This)->lpVtbl -> onReplaceText(This,cCharacterPosition,cNumToReplace) ) 

#define IDebugDocumentTextEvents_onUpdateTextAttributes(This,cCharacterPosition,cNumToUpdate)	\
    ( (This)->lpVtbl -> onUpdateTextAttributes(This,cCharacterPosition,cNumToUpdate) ) 

#define IDebugDocumentTextEvents_onUpdateDocumentAttributes(This,textdocattr)	\
    ( (This)->lpVtbl -> onUpdateDocumentAttributes(This,textdocattr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentTextEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0025 */
/* [local] */ 

#pragma warning(push)
#pragma warning(disable:28718)	


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0025_v0_0_s_ifspec;

#ifndef __IDebugDocumentTextAuthor_INTERFACE_DEFINED__
#define __IDebugDocumentTextAuthor_INTERFACE_DEFINED__

/* interface IDebugDocumentTextAuthor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentTextAuthor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C24-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentTextAuthor : public IDebugDocumentText
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert,
            /* [size_is][in] */ __RPC__in_ecount_full(cNumToInsert) OLECHAR pcharText[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace,
            /* [size_is][in] */ __RPC__in_ecount_full(cNumToReplace) OLECHAR pcharText[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentTextAuthorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentTextAuthor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentTextAuthor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocumentTextAuthor * This,
            /* [out] */ __RPC__out CLSID *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentAttributes )( 
            IDebugDocumentTextAuthor * This,
            /* [out] */ __RPC__out TEXT_DOC_ATTR *ptextdocattr);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugDocumentTextAuthor * This,
            /* [out] */ __RPC__out ULONG *pcNumLines,
            /* [out] */ __RPC__out ULONG *pcNumChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositionOfLine )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cLineNumber,
            /* [out] */ __RPC__out ULONG *pcCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineOfPosition )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [out] */ __RPC__out ULONG *pcLineNumber,
            /* [out] */ __RPC__out ULONG *pcCharacterOffsetInLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) WCHAR *pcharText,
            /* [full][size_is][length_is][out][in] */ __RPC__inout_ecount_part_opt(cMaxChars, *pcNumChars) SOURCE_TEXT_ATTR *pstaTextAttr,
            /* [out][in] */ __RPC__inout ULONG *pcNumChars,
            /* [in] */ ULONG cMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositionOfContext )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ __RPC__in_opt IDebugDocumentContext *psc,
            /* [out] */ __RPC__out ULONG *pcCharacterPosition,
            /* [out] */ __RPC__out ULONG *cNumChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextOfPosition )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppsc);
        
        HRESULT ( STDMETHODCALLTYPE *InsertText )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert,
            /* [size_is][in] */ __RPC__in_ecount_full(cNumToInsert) OLECHAR pcharText[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveText )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceText )( 
            IDebugDocumentTextAuthor * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace,
            /* [size_is][in] */ __RPC__in_ecount_full(cNumToReplace) OLECHAR pcharText[  ]);
        
        END_INTERFACE
    } IDebugDocumentTextAuthorVtbl;

    interface IDebugDocumentTextAuthor
    {
        CONST_VTBL struct IDebugDocumentTextAuthorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextAuthor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentTextAuthor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentTextAuthor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentTextAuthor_GetName(This,dnt,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,dnt,pbstrName) ) 

#define IDebugDocumentTextAuthor_GetDocumentClassId(This,pclsidDocument)	\
    ( (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument) ) 



#define IDebugDocumentTextAuthor_GetDocumentAttributes(This,ptextdocattr)	\
    ( (This)->lpVtbl -> GetDocumentAttributes(This,ptextdocattr) ) 

#define IDebugDocumentTextAuthor_GetSize(This,pcNumLines,pcNumChars)	\
    ( (This)->lpVtbl -> GetSize(This,pcNumLines,pcNumChars) ) 

#define IDebugDocumentTextAuthor_GetPositionOfLine(This,cLineNumber,pcCharacterPosition)	\
    ( (This)->lpVtbl -> GetPositionOfLine(This,cLineNumber,pcCharacterPosition) ) 

#define IDebugDocumentTextAuthor_GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine)	\
    ( (This)->lpVtbl -> GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine) ) 

#define IDebugDocumentTextAuthor_GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars)	\
    ( (This)->lpVtbl -> GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars) ) 

#define IDebugDocumentTextAuthor_GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars)	\
    ( (This)->lpVtbl -> GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars) ) 

#define IDebugDocumentTextAuthor_GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc)	\
    ( (This)->lpVtbl -> GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc) ) 


#define IDebugDocumentTextAuthor_InsertText(This,cCharacterPosition,cNumToInsert,pcharText)	\
    ( (This)->lpVtbl -> InsertText(This,cCharacterPosition,cNumToInsert,pcharText) ) 

#define IDebugDocumentTextAuthor_RemoveText(This,cCharacterPosition,cNumToRemove)	\
    ( (This)->lpVtbl -> RemoveText(This,cCharacterPosition,cNumToRemove) ) 

#define IDebugDocumentTextAuthor_ReplaceText(This,cCharacterPosition,cNumToReplace,pcharText)	\
    ( (This)->lpVtbl -> ReplaceText(This,cCharacterPosition,cNumToReplace,pcharText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentTextAuthor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0026 */
/* [local] */ 

#pragma warning(pop)


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0026_v0_0_s_ifspec;

#ifndef __IDebugDocumentTextExternalAuthor_INTERFACE_DEFINED__
#define __IDebugDocumentTextExternalAuthor_INTERFACE_DEFINED__

/* interface IDebugDocumentTextExternalAuthor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentTextExternalAuthor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C25-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentTextExternalAuthor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPathName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLongName,
            /* [out] */ __RPC__out BOOL *pfIsOriginalFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentTextExternalAuthorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentTextExternalAuthor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentTextExternalAuthor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentTextExternalAuthor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPathName )( 
            IDebugDocumentTextExternalAuthor * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLongName,
            /* [out] */ __RPC__out BOOL *pfIsOriginalFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IDebugDocumentTextExternalAuthor * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrShortName);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyChanged )( 
            IDebugDocumentTextExternalAuthor * This);
        
        END_INTERFACE
    } IDebugDocumentTextExternalAuthorVtbl;

    interface IDebugDocumentTextExternalAuthor
    {
        CONST_VTBL struct IDebugDocumentTextExternalAuthorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextExternalAuthor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentTextExternalAuthor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentTextExternalAuthor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentTextExternalAuthor_GetPathName(This,pbstrLongName,pfIsOriginalFile)	\
    ( (This)->lpVtbl -> GetPathName(This,pbstrLongName,pfIsOriginalFile) ) 

#define IDebugDocumentTextExternalAuthor_GetFileName(This,pbstrShortName)	\
    ( (This)->lpVtbl -> GetFileName(This,pbstrShortName) ) 

#define IDebugDocumentTextExternalAuthor_NotifyChanged(This)	\
    ( (This)->lpVtbl -> NotifyChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentTextExternalAuthor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0027 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugDocumentHelper IDebugDocumentHelper64
#define IID_IDebugDocumentHelper IID_IDebugDocumentHelper64
#else
#define IDebugDocumentHelper IDebugDocumentHelper32
#define IID_IDebugDocumentHelper IID_IDebugDocumentHelper32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0027_v0_0_s_ifspec;

#ifndef __IDebugDocumentHelper32_INTERFACE_DEFINED__
#define __IDebugDocumentHelper32_INTERFACE_DEFINED__

/* interface IDebugDocumentHelper32 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHelper32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C26-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentHelper32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ __RPC__in_opt IDebugApplication32 *pda,
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName,
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ __RPC__in_opt IDebugDocumentHelper32 *pddhParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUnicodeText( 
            /* [string][in] */ __RPC__in LPCOLESTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDBCSText( 
            /* [string][in] */ __RPC__in LPCSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugDocumentHost( 
            /* [in] */ __RPC__in_opt IDebugDocumentHost *pddh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDeferredText( 
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineScriptBlock( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ __RPC__in_opt IActiveScript *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ __RPC__out DWORD *pdwSourceContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTextAttr( 
            SOURCE_TEXT_ATTR staTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextAttributes( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ __RPC__in_ecount_part(cChars, cChars) SOURCE_TEXT_ATTR *pstaTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLongName( 
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShortName( 
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentAttr( 
            /* [in] */ TEXT_DOC_ATTR pszAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugApplicationNode( 
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **ppdan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptBlockInfo( 
            /* [in] */ DWORD dwSourceContext,
            /* [out] */ __RPC__deref_out_opt IActiveScript **ppasd,
            /* [out] */ __RPC__out ULONG *piCharPos,
            /* [out] */ __RPC__out ULONG *pcChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentContext( 
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppddc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentToTop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentContextToTop( 
            __RPC__in_opt IDebugDocumentContext *pddc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentHelper32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentHelper32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentHelper32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ __RPC__in_opt IDebugApplication32 *pda,
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName,
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ __RPC__in_opt IDebugDocumentHelper32 *pddhParent);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDebugDocumentHelper32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddUnicodeText )( 
            IDebugDocumentHelper32 * This,
            /* [string][in] */ __RPC__in LPCOLESTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *AddDBCSText )( 
            IDebugDocumentHelper32 * This,
            /* [string][in] */ __RPC__in LPCSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugDocumentHost )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ __RPC__in_opt IDebugDocumentHost *pddh);
        
        HRESULT ( STDMETHODCALLTYPE *AddDeferredText )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DefineScriptBlock )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ __RPC__in_opt IActiveScript *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ __RPC__out DWORD *pdwSourceContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTextAttr )( 
            IDebugDocumentHelper32 * This,
            SOURCE_TEXT_ATTR staTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextAttributes )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ __RPC__in_ecount_part(cChars, cChars) SOURCE_TEXT_ATTR *pstaTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE *SetLongName )( 
            IDebugDocumentHelper32 * This,
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName);
        
        HRESULT ( STDMETHODCALLTYPE *SetShortName )( 
            IDebugDocumentHelper32 * This,
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentAttr )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ TEXT_DOC_ATTR pszAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugApplicationNode )( 
            IDebugDocumentHelper32 * This,
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **ppdan);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptBlockInfo )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ DWORD dwSourceContext,
            /* [out] */ __RPC__deref_out_opt IActiveScript **ppasd,
            /* [out] */ __RPC__out ULONG *piCharPos,
            /* [out] */ __RPC__out ULONG *pcChars);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDebugDocumentContext )( 
            IDebugDocumentHelper32 * This,
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppddc);
        
        HRESULT ( STDMETHODCALLTYPE *BringDocumentToTop )( 
            IDebugDocumentHelper32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BringDocumentContextToTop )( 
            IDebugDocumentHelper32 * This,
            __RPC__in_opt IDebugDocumentContext *pddc);
        
        END_INTERFACE
    } IDebugDocumentHelper32Vtbl;

    interface IDebugDocumentHelper32
    {
        CONST_VTBL struct IDebugDocumentHelper32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHelper32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentHelper32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentHelper32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentHelper32_Init(This,pda,pszShortName,pszLongName,docAttr)	\
    ( (This)->lpVtbl -> Init(This,pda,pszShortName,pszLongName,docAttr) ) 

#define IDebugDocumentHelper32_Attach(This,pddhParent)	\
    ( (This)->lpVtbl -> Attach(This,pddhParent) ) 

#define IDebugDocumentHelper32_Detach(This)	\
    ( (This)->lpVtbl -> Detach(This) ) 

#define IDebugDocumentHelper32_AddUnicodeText(This,pszText)	\
    ( (This)->lpVtbl -> AddUnicodeText(This,pszText) ) 

#define IDebugDocumentHelper32_AddDBCSText(This,pszText)	\
    ( (This)->lpVtbl -> AddDBCSText(This,pszText) ) 

#define IDebugDocumentHelper32_SetDebugDocumentHost(This,pddh)	\
    ( (This)->lpVtbl -> SetDebugDocumentHost(This,pddh) ) 

#define IDebugDocumentHelper32_AddDeferredText(This,cChars,dwTextStartCookie)	\
    ( (This)->lpVtbl -> AddDeferredText(This,cChars,dwTextStartCookie) ) 

#define IDebugDocumentHelper32_DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext)	\
    ( (This)->lpVtbl -> DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext) ) 

#define IDebugDocumentHelper32_SetDefaultTextAttr(This,staTextAttr)	\
    ( (This)->lpVtbl -> SetDefaultTextAttr(This,staTextAttr) ) 

#define IDebugDocumentHelper32_SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr)	\
    ( (This)->lpVtbl -> SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr) ) 

#define IDebugDocumentHelper32_SetLongName(This,pszLongName)	\
    ( (This)->lpVtbl -> SetLongName(This,pszLongName) ) 

#define IDebugDocumentHelper32_SetShortName(This,pszShortName)	\
    ( (This)->lpVtbl -> SetShortName(This,pszShortName) ) 

#define IDebugDocumentHelper32_SetDocumentAttr(This,pszAttributes)	\
    ( (This)->lpVtbl -> SetDocumentAttr(This,pszAttributes) ) 

#define IDebugDocumentHelper32_GetDebugApplicationNode(This,ppdan)	\
    ( (This)->lpVtbl -> GetDebugApplicationNode(This,ppdan) ) 

#define IDebugDocumentHelper32_GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars)	\
    ( (This)->lpVtbl -> GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars) ) 

#define IDebugDocumentHelper32_CreateDebugDocumentContext(This,iCharPos,cChars,ppddc)	\
    ( (This)->lpVtbl -> CreateDebugDocumentContext(This,iCharPos,cChars,ppddc) ) 

#define IDebugDocumentHelper32_BringDocumentToTop(This)	\
    ( (This)->lpVtbl -> BringDocumentToTop(This) ) 

#define IDebugDocumentHelper32_BringDocumentContextToTop(This,pddc)	\
    ( (This)->lpVtbl -> BringDocumentContextToTop(This,pddc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentHelper32_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentHelper64_INTERFACE_DEFINED__
#define __IDebugDocumentHelper64_INTERFACE_DEFINED__

/* interface IDebugDocumentHelper64 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHelper64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c4c7363c-20fd-47f9-bd82-4855e0150871")
    IDebugDocumentHelper64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ __RPC__in_opt IDebugApplication64 *pda,
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName,
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ __RPC__in_opt IDebugDocumentHelper64 *pddhParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUnicodeText( 
            /* [string][in] */ __RPC__in LPCOLESTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDBCSText( 
            /* [string][in] */ __RPC__in LPCSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugDocumentHost( 
            /* [in] */ __RPC__in_opt IDebugDocumentHost *pddh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDeferredText( 
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineScriptBlock( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ __RPC__in_opt IActiveScript *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ __RPC__out DWORDLONG *pdwSourceContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTextAttr( 
            SOURCE_TEXT_ATTR staTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextAttributes( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ __RPC__in_ecount_part(cChars, cChars) SOURCE_TEXT_ATTR *pstaTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLongName( 
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShortName( 
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentAttr( 
            /* [in] */ TEXT_DOC_ATTR pszAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugApplicationNode( 
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **ppdan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptBlockInfo( 
            /* [in] */ DWORDLONG dwSourceContext,
            /* [out] */ __RPC__deref_out_opt IActiveScript **ppasd,
            /* [out] */ __RPC__out ULONG *piCharPos,
            /* [out] */ __RPC__out ULONG *pcChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentContext( 
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppddc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentToTop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentContextToTop( 
            __RPC__in_opt IDebugDocumentContext *pddc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentHelper64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentHelper64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentHelper64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ __RPC__in_opt IDebugApplication64 *pda,
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName,
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ __RPC__in_opt IDebugDocumentHelper64 *pddhParent);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDebugDocumentHelper64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddUnicodeText )( 
            IDebugDocumentHelper64 * This,
            /* [string][in] */ __RPC__in LPCOLESTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *AddDBCSText )( 
            IDebugDocumentHelper64 * This,
            /* [string][in] */ __RPC__in LPCSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugDocumentHost )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ __RPC__in_opt IDebugDocumentHost *pddh);
        
        HRESULT ( STDMETHODCALLTYPE *AddDeferredText )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DefineScriptBlock )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ __RPC__in_opt IActiveScript *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ __RPC__out DWORDLONG *pdwSourceContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTextAttr )( 
            IDebugDocumentHelper64 * This,
            SOURCE_TEXT_ATTR staTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextAttributes )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ __RPC__in_ecount_part(cChars, cChars) SOURCE_TEXT_ATTR *pstaTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE *SetLongName )( 
            IDebugDocumentHelper64 * This,
            /* [string][in] */ __RPC__in LPCOLESTR pszLongName);
        
        HRESULT ( STDMETHODCALLTYPE *SetShortName )( 
            IDebugDocumentHelper64 * This,
            /* [string][in] */ __RPC__in LPCOLESTR pszShortName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentAttr )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ TEXT_DOC_ATTR pszAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugApplicationNode )( 
            IDebugDocumentHelper64 * This,
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **ppdan);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptBlockInfo )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ DWORDLONG dwSourceContext,
            /* [out] */ __RPC__deref_out_opt IActiveScript **ppasd,
            /* [out] */ __RPC__out ULONG *piCharPos,
            /* [out] */ __RPC__out ULONG *pcChars);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDebugDocumentContext )( 
            IDebugDocumentHelper64 * This,
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ __RPC__deref_out_opt IDebugDocumentContext **ppddc);
        
        HRESULT ( STDMETHODCALLTYPE *BringDocumentToTop )( 
            IDebugDocumentHelper64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BringDocumentContextToTop )( 
            IDebugDocumentHelper64 * This,
            __RPC__in_opt IDebugDocumentContext *pddc);
        
        END_INTERFACE
    } IDebugDocumentHelper64Vtbl;

    interface IDebugDocumentHelper64
    {
        CONST_VTBL struct IDebugDocumentHelper64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHelper64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentHelper64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentHelper64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentHelper64_Init(This,pda,pszShortName,pszLongName,docAttr)	\
    ( (This)->lpVtbl -> Init(This,pda,pszShortName,pszLongName,docAttr) ) 

#define IDebugDocumentHelper64_Attach(This,pddhParent)	\
    ( (This)->lpVtbl -> Attach(This,pddhParent) ) 

#define IDebugDocumentHelper64_Detach(This)	\
    ( (This)->lpVtbl -> Detach(This) ) 

#define IDebugDocumentHelper64_AddUnicodeText(This,pszText)	\
    ( (This)->lpVtbl -> AddUnicodeText(This,pszText) ) 

#define IDebugDocumentHelper64_AddDBCSText(This,pszText)	\
    ( (This)->lpVtbl -> AddDBCSText(This,pszText) ) 

#define IDebugDocumentHelper64_SetDebugDocumentHost(This,pddh)	\
    ( (This)->lpVtbl -> SetDebugDocumentHost(This,pddh) ) 

#define IDebugDocumentHelper64_AddDeferredText(This,cChars,dwTextStartCookie)	\
    ( (This)->lpVtbl -> AddDeferredText(This,cChars,dwTextStartCookie) ) 

#define IDebugDocumentHelper64_DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext)	\
    ( (This)->lpVtbl -> DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext) ) 

#define IDebugDocumentHelper64_SetDefaultTextAttr(This,staTextAttr)	\
    ( (This)->lpVtbl -> SetDefaultTextAttr(This,staTextAttr) ) 

#define IDebugDocumentHelper64_SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr)	\
    ( (This)->lpVtbl -> SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr) ) 

#define IDebugDocumentHelper64_SetLongName(This,pszLongName)	\
    ( (This)->lpVtbl -> SetLongName(This,pszLongName) ) 

#define IDebugDocumentHelper64_SetShortName(This,pszShortName)	\
    ( (This)->lpVtbl -> SetShortName(This,pszShortName) ) 

#define IDebugDocumentHelper64_SetDocumentAttr(This,pszAttributes)	\
    ( (This)->lpVtbl -> SetDocumentAttr(This,pszAttributes) ) 

#define IDebugDocumentHelper64_GetDebugApplicationNode(This,ppdan)	\
    ( (This)->lpVtbl -> GetDebugApplicationNode(This,ppdan) ) 

#define IDebugDocumentHelper64_GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars)	\
    ( (This)->lpVtbl -> GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars) ) 

#define IDebugDocumentHelper64_CreateDebugDocumentContext(This,iCharPos,cChars,ppddc)	\
    ( (This)->lpVtbl -> CreateDebugDocumentContext(This,iCharPos,cChars,ppddc) ) 

#define IDebugDocumentHelper64_BringDocumentToTop(This)	\
    ( (This)->lpVtbl -> BringDocumentToTop(This) ) 

#define IDebugDocumentHelper64_BringDocumentContextToTop(This,pddc)	\
    ( (This)->lpVtbl -> BringDocumentContextToTop(This,pddc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentHelper64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0029 */
/* [local] */ 

#pragma warning(push)
#pragma warning(disable:28718)


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0029_v0_0_s_ifspec;

#ifndef __IDebugDocumentHost_INTERFACE_DEFINED__
#define __IDebugDocumentHost_INTERFACE_DEFINED__

/* interface IDebugDocumentHost */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C27-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeferredText( 
            /* [in] */ DWORD dwTextStartCookie,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) WCHAR *pcharText,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) SOURCE_TEXT_ATTR *pstaTextAttr,
            /* [out][in] */ __RPC__inout ULONG *pcNumChars,
            /* [in] */ ULONG cMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCreateDocumentContext( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkOuter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLongName,
            /* [out] */ __RPC__out BOOL *pfIsOriginalFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeferredText )( 
            IDebugDocumentHost * This,
            /* [in] */ DWORD dwTextStartCookie,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) WCHAR *pcharText,
            /* [size_is][length_is][out][in] */ __RPC__inout_ecount_part(cMaxChars, *pcNumChars) SOURCE_TEXT_ATTR *pstaTextAttr,
            /* [out][in] */ __RPC__inout ULONG *pcNumChars,
            /* [in] */ ULONG cMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptTextAttributes )( 
            IDebugDocumentHost * This,
            /* [size_is][in] */ __RPC__in_ecount_full(uNumCodeChars) LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ __RPC__in LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(uNumCodeChars) SOURCE_TEXT_ATTR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE *OnCreateDocumentContext )( 
            IDebugDocumentHost * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkOuter);
        
        HRESULT ( STDMETHODCALLTYPE *GetPathName )( 
            IDebugDocumentHost * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrLongName,
            /* [out] */ __RPC__out BOOL *pfIsOriginalFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IDebugDocumentHost * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrShortName);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyChanged )( 
            IDebugDocumentHost * This);
        
        END_INTERFACE
    } IDebugDocumentHostVtbl;

    interface IDebugDocumentHost
    {
        CONST_VTBL struct IDebugDocumentHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentHost_GetDeferredText(This,dwTextStartCookie,pcharText,pstaTextAttr,pcNumChars,cMaxChars)	\
    ( (This)->lpVtbl -> GetDeferredText(This,dwTextStartCookie,pcharText,pstaTextAttr,pcNumChars,cMaxChars) ) 

#define IDebugDocumentHost_GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)	\
    ( (This)->lpVtbl -> GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr) ) 

#define IDebugDocumentHost_OnCreateDocumentContext(This,ppunkOuter)	\
    ( (This)->lpVtbl -> OnCreateDocumentContext(This,ppunkOuter) ) 

#define IDebugDocumentHost_GetPathName(This,pbstrLongName,pfIsOriginalFile)	\
    ( (This)->lpVtbl -> GetPathName(This,pbstrLongName,pfIsOriginalFile) ) 

#define IDebugDocumentHost_GetFileName(This,pbstrShortName)	\
    ( (This)->lpVtbl -> GetFileName(This,pbstrShortName) ) 

#define IDebugDocumentHost_NotifyChanged(This)	\
    ( (This)->lpVtbl -> NotifyChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0030 */
/* [local] */ 

#pragma warning(pop)


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0030_v0_0_s_ifspec;

#ifndef __IDebugDocumentContext_INTERFACE_DEFINED__
#define __IDebugDocumentContext_INTERFACE_DEFINED__

/* interface IDebugDocumentContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C28-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ __RPC__deref_out_opt IDebugDocument **ppsd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugDocumentContext * This,
            /* [out] */ __RPC__deref_out_opt IDebugDocument **ppsd);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeContexts )( 
            IDebugDocumentContext * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugCodeContexts **ppescc);
        
        END_INTERFACE
    } IDebugDocumentContextVtbl;

    interface IDebugDocumentContext
    {
        CONST_VTBL struct IDebugDocumentContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentContext_GetDocument(This,ppsd)	\
    ( (This)->lpVtbl -> GetDocument(This,ppsd) ) 

#define IDebugDocumentContext_EnumCodeContexts(This,ppescc)	\
    ( (This)->lpVtbl -> EnumCodeContexts(This,ppescc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentContext_INTERFACE_DEFINED__ */


#ifndef __IDebugSessionProvider_INTERFACE_DEFINED__
#define __IDebugSessionProvider_INTERFACE_DEFINED__

/* interface IDebugSessionProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugSessionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C29-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugSessionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugSessionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSessionProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSessionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSessionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartDebugSession )( 
            IDebugSessionProvider * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda);
        
        END_INTERFACE
    } IDebugSessionProviderVtbl;

    interface IDebugSessionProvider
    {
        CONST_VTBL struct IDebugSessionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSessionProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugSessionProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugSessionProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugSessionProvider_StartDebugSession(This,pda)	\
    ( (This)->lpVtbl -> StartDebugSession(This,pda) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugSessionProvider_INTERFACE_DEFINED__ */


#ifndef __IApplicationDebugger_INTERFACE_DEFINED__
#define __IApplicationDebugger_INTERFACE_DEFINED__

/* interface IApplicationDebugger */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IApplicationDebugger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2a-CB0C-11d0-B5C9-00A0244A0E7A")
    IApplicationDebugger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryAlive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceAtDebugger( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onDebugOutput( 
            /* [in] */ __RPC__in LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onHandleBreakPoint( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prpt,
            /* [in] */ BREAKREASON br,
            /* [in] */ __RPC__in_opt IActiveScriptErrorDebug *pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onClose( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onDebuggerEvent( 
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationDebuggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationDebugger * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationDebugger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationDebugger * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAlive )( 
            IApplicationDebugger * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceAtDebugger )( 
            IApplicationDebugger * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *onDebugOutput )( 
            IApplicationDebugger * This,
            /* [in] */ __RPC__in LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE *onHandleBreakPoint )( 
            IApplicationDebugger * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prpt,
            /* [in] */ BREAKREASON br,
            /* [in] */ __RPC__in_opt IActiveScriptErrorDebug *pError);
        
        HRESULT ( STDMETHODCALLTYPE *onClose )( 
            IApplicationDebugger * This);
        
        HRESULT ( STDMETHODCALLTYPE *onDebuggerEvent )( 
            IApplicationDebugger * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IApplicationDebuggerVtbl;

    interface IApplicationDebugger
    {
        CONST_VTBL struct IApplicationDebuggerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationDebugger_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationDebugger_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationDebugger_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationDebugger_QueryAlive(This)	\
    ( (This)->lpVtbl -> QueryAlive(This) ) 

#define IApplicationDebugger_CreateInstanceAtDebugger(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateInstanceAtDebugger(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject) ) 

#define IApplicationDebugger_onDebugOutput(This,pstr)	\
    ( (This)->lpVtbl -> onDebugOutput(This,pstr) ) 

#define IApplicationDebugger_onHandleBreakPoint(This,prpt,br,pError)	\
    ( (This)->lpVtbl -> onHandleBreakPoint(This,prpt,br,pError) ) 

#define IApplicationDebugger_onClose(This)	\
    ( (This)->lpVtbl -> onClose(This) ) 

#define IApplicationDebugger_onDebuggerEvent(This,riid,punk)	\
    ( (This)->lpVtbl -> onDebuggerEvent(This,riid,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationDebugger_INTERFACE_DEFINED__ */


#ifndef __IApplicationDebuggerUI_INTERFACE_DEFINED__
#define __IApplicationDebuggerUI_INTERFACE_DEFINED__

/* interface IApplicationDebuggerUI */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IApplicationDebuggerUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2b-CB0C-11d0-B5C9-00A0244A0E7A")
    IApplicationDebuggerUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BringDocumentToTop( 
            /* [in] */ __RPC__in_opt IDebugDocumentText *pddt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentContextToTop( 
            /* [in] */ __RPC__in_opt IDebugDocumentContext *pddc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationDebuggerUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationDebuggerUI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationDebuggerUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationDebuggerUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *BringDocumentToTop )( 
            IApplicationDebuggerUI * This,
            /* [in] */ __RPC__in_opt IDebugDocumentText *pddt);
        
        HRESULT ( STDMETHODCALLTYPE *BringDocumentContextToTop )( 
            IApplicationDebuggerUI * This,
            /* [in] */ __RPC__in_opt IDebugDocumentContext *pddc);
        
        END_INTERFACE
    } IApplicationDebuggerUIVtbl;

    interface IApplicationDebuggerUI
    {
        CONST_VTBL struct IApplicationDebuggerUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationDebuggerUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationDebuggerUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationDebuggerUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationDebuggerUI_BringDocumentToTop(This,pddt)	\
    ( (This)->lpVtbl -> BringDocumentToTop(This,pddt) ) 

#define IApplicationDebuggerUI_BringDocumentContextToTop(This,pddc)	\
    ( (This)->lpVtbl -> BringDocumentContextToTop(This,pddc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationDebuggerUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0034 */
/* [local] */ 

EXTERN_C const CLSID CLSID_MachineDebugManager;


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0034_v0_0_s_ifspec;

#ifndef __IMachineDebugManager_INTERFACE_DEFINED__
#define __IMachineDebugManager_INTERFACE_DEFINED__

/* interface IMachineDebugManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMachineDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2c-CB0C-11d0-B5C9-00A0244A0E7A")
    IMachineDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [out] */ __RPC__out DWORD *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplications **ppeda) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMachineDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMachineDebugManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMachineDebugManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMachineDebugManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddApplication )( 
            IMachineDebugManager * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [out] */ __RPC__out DWORD *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveApplication )( 
            IMachineDebugManager * This,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *EnumApplications )( 
            IMachineDebugManager * This,
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplications **ppeda);
        
        END_INTERFACE
    } IMachineDebugManagerVtbl;

    interface IMachineDebugManager
    {
        CONST_VTBL struct IMachineDebugManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMachineDebugManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMachineDebugManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMachineDebugManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMachineDebugManager_AddApplication(This,pda,pdwAppCookie)	\
    ( (This)->lpVtbl -> AddApplication(This,pda,pdwAppCookie) ) 

#define IMachineDebugManager_RemoveApplication(This,dwAppCookie)	\
    ( (This)->lpVtbl -> RemoveApplication(This,dwAppCookie) ) 

#define IMachineDebugManager_EnumApplications(This,ppeda)	\
    ( (This)->lpVtbl -> EnumApplications(This,ppeda) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMachineDebugManager_INTERFACE_DEFINED__ */


#ifndef __IMachineDebugManagerCookie_INTERFACE_DEFINED__
#define __IMachineDebugManagerCookie_INTERFACE_DEFINED__

/* interface IMachineDebugManagerCookie */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMachineDebugManagerCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2d-CB0C-11d0-B5C9-00A0244A0E7A")
    IMachineDebugManagerCookie : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [in] */ DWORD dwDebugAppCookie,
            /* [out] */ __RPC__out DWORD *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwDebugAppCookie,
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplications **ppeda) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMachineDebugManagerCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMachineDebugManagerCookie * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMachineDebugManagerCookie * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMachineDebugManagerCookie * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddApplication )( 
            IMachineDebugManagerCookie * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [in] */ DWORD dwDebugAppCookie,
            /* [out] */ __RPC__out DWORD *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveApplication )( 
            IMachineDebugManagerCookie * This,
            /* [in] */ DWORD dwDebugAppCookie,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *EnumApplications )( 
            IMachineDebugManagerCookie * This,
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplications **ppeda);
        
        END_INTERFACE
    } IMachineDebugManagerCookieVtbl;

    interface IMachineDebugManagerCookie
    {
        CONST_VTBL struct IMachineDebugManagerCookieVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMachineDebugManagerCookie_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMachineDebugManagerCookie_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMachineDebugManagerCookie_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMachineDebugManagerCookie_AddApplication(This,pda,dwDebugAppCookie,pdwAppCookie)	\
    ( (This)->lpVtbl -> AddApplication(This,pda,dwDebugAppCookie,pdwAppCookie) ) 

#define IMachineDebugManagerCookie_RemoveApplication(This,dwDebugAppCookie,dwAppCookie)	\
    ( (This)->lpVtbl -> RemoveApplication(This,dwDebugAppCookie,dwAppCookie) ) 

#define IMachineDebugManagerCookie_EnumApplications(This,ppeda)	\
    ( (This)->lpVtbl -> EnumApplications(This,ppeda) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMachineDebugManagerCookie_INTERFACE_DEFINED__ */


#ifndef __IMachineDebugManagerEvents_INTERFACE_DEFINED__
#define __IMachineDebugManagerEvents_INTERFACE_DEFINED__

/* interface IMachineDebugManagerEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMachineDebugManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2e-CB0C-11d0-B5C9-00A0244A0E7A")
    IMachineDebugManagerEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onAddApplication( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveApplication( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [in] */ DWORD dwAppCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMachineDebugManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMachineDebugManagerEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMachineDebugManagerEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMachineDebugManagerEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *onAddApplication )( 
            IMachineDebugManagerEvents * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *onRemoveApplication )( 
            IMachineDebugManagerEvents * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplication *pda,
            /* [in] */ DWORD dwAppCookie);
        
        END_INTERFACE
    } IMachineDebugManagerEventsVtbl;

    interface IMachineDebugManagerEvents
    {
        CONST_VTBL struct IMachineDebugManagerEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMachineDebugManagerEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMachineDebugManagerEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMachineDebugManagerEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMachineDebugManagerEvents_onAddApplication(This,pda,dwAppCookie)	\
    ( (This)->lpVtbl -> onAddApplication(This,pda,dwAppCookie) ) 

#define IMachineDebugManagerEvents_onRemoveApplication(This,pda,dwAppCookie)	\
    ( (This)->lpVtbl -> onRemoveApplication(This,pda,dwAppCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMachineDebugManagerEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0037 */
/* [local] */ 

EXTERN_C const CLSID CLSID_ProcessDebugManager;
#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IProcessDebugManager IProcessDebugManager64
#define IID_IProcessDebugManager IID_IProcessDebugManager64
#else
#define IProcessDebugManager IProcessDebugManager32
#define IID_IProcessDebugManager IID_IProcessDebugManager32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0037_v0_0_s_ifspec;

#ifndef __IProcessDebugManager32_INTERFACE_DEFINED__
#define __IProcessDebugManager32_INTERFACE_DEFINED__

/* interface IProcessDebugManager32 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProcessDebugManager32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2f-CB0C-11d0-B5C9-00A0244A0E7A")
    IProcessDebugManager32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [out] */ IDebugApplication32 **ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultApplication( 
            /* [out] */ IDebugApplication32 **ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ IDebugApplication32 *pda,
            /* [out] */ DWORD *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentHelper( 
            /* [in] */ IUnknown *punkOuter,
            /* [out] */ IDebugDocumentHelper32 **pddh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProcessDebugManager32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProcessDebugManager32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProcessDebugManager32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProcessDebugManager32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateApplication )( 
            IProcessDebugManager32 * This,
            /* [out] */ IDebugApplication32 **ppda);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultApplication )( 
            IProcessDebugManager32 * This,
            /* [out] */ IDebugApplication32 **ppda);
        
        HRESULT ( STDMETHODCALLTYPE *AddApplication )( 
            IProcessDebugManager32 * This,
            /* [in] */ IDebugApplication32 *pda,
            /* [out] */ DWORD *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveApplication )( 
            IProcessDebugManager32 * This,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDebugDocumentHelper )( 
            IProcessDebugManager32 * This,
            /* [in] */ IUnknown *punkOuter,
            /* [out] */ IDebugDocumentHelper32 **pddh);
        
        END_INTERFACE
    } IProcessDebugManager32Vtbl;

    interface IProcessDebugManager32
    {
        CONST_VTBL struct IProcessDebugManager32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessDebugManager32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProcessDebugManager32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProcessDebugManager32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProcessDebugManager32_CreateApplication(This,ppda)	\
    ( (This)->lpVtbl -> CreateApplication(This,ppda) ) 

#define IProcessDebugManager32_GetDefaultApplication(This,ppda)	\
    ( (This)->lpVtbl -> GetDefaultApplication(This,ppda) ) 

#define IProcessDebugManager32_AddApplication(This,pda,pdwAppCookie)	\
    ( (This)->lpVtbl -> AddApplication(This,pda,pdwAppCookie) ) 

#define IProcessDebugManager32_RemoveApplication(This,dwAppCookie)	\
    ( (This)->lpVtbl -> RemoveApplication(This,dwAppCookie) ) 

#define IProcessDebugManager32_CreateDebugDocumentHelper(This,punkOuter,pddh)	\
    ( (This)->lpVtbl -> CreateDebugDocumentHelper(This,punkOuter,pddh) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProcessDebugManager32_INTERFACE_DEFINED__ */


#ifndef __IProcessDebugManager64_INTERFACE_DEFINED__
#define __IProcessDebugManager64_INTERFACE_DEFINED__

/* interface IProcessDebugManager64 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProcessDebugManager64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b9fc1c-63a9-4cc1-ac21-087d69a17fab")
    IProcessDebugManager64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [out] */ IDebugApplication64 **ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultApplication( 
            /* [out] */ IDebugApplication64 **ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ IDebugApplication64 *pda,
            /* [out] */ DWORD *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentHelper( 
            /* [in] */ IUnknown *punkOuter,
            /* [out] */ IDebugDocumentHelper64 **pddh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProcessDebugManager64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProcessDebugManager64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProcessDebugManager64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProcessDebugManager64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateApplication )( 
            IProcessDebugManager64 * This,
            /* [out] */ IDebugApplication64 **ppda);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultApplication )( 
            IProcessDebugManager64 * This,
            /* [out] */ IDebugApplication64 **ppda);
        
        HRESULT ( STDMETHODCALLTYPE *AddApplication )( 
            IProcessDebugManager64 * This,
            /* [in] */ IDebugApplication64 *pda,
            /* [out] */ DWORD *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveApplication )( 
            IProcessDebugManager64 * This,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDebugDocumentHelper )( 
            IProcessDebugManager64 * This,
            /* [in] */ IUnknown *punkOuter,
            /* [out] */ IDebugDocumentHelper64 **pddh);
        
        END_INTERFACE
    } IProcessDebugManager64Vtbl;

    interface IProcessDebugManager64
    {
        CONST_VTBL struct IProcessDebugManager64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessDebugManager64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProcessDebugManager64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProcessDebugManager64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProcessDebugManager64_CreateApplication(This,ppda)	\
    ( (This)->lpVtbl -> CreateApplication(This,ppda) ) 

#define IProcessDebugManager64_GetDefaultApplication(This,ppda)	\
    ( (This)->lpVtbl -> GetDefaultApplication(This,ppda) ) 

#define IProcessDebugManager64_AddApplication(This,pda,pdwAppCookie)	\
    ( (This)->lpVtbl -> AddApplication(This,pda,pdwAppCookie) ) 

#define IProcessDebugManager64_RemoveApplication(This,dwAppCookie)	\
    ( (This)->lpVtbl -> RemoveApplication(This,dwAppCookie) ) 

#define IProcessDebugManager64_CreateDebugDocumentHelper(This,punkOuter,pddh)	\
    ( (This)->lpVtbl -> CreateDebugDocumentHelper(This,punkOuter,pddh) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProcessDebugManager64_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplication_INTERFACE_DEFINED__
#define __IRemoteDebugApplication_INTERFACE_DEFINED__

/* interface IRemoteDebugApplication */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C30-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplication : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResumeFromBreakPoint( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CauseBreak( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDebugger( 
            /* [in] */ __RPC__in_opt IApplicationDebugger *pad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisconnectDebugger( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugger( 
            /* [out] */ __RPC__deref_out_opt IApplicationDebugger **pad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceAtApplication( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAlive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumThreads( 
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplicationThreads **pperdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNode( 
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **ppdanRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumGlobalExpressionContexts( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugExpressionContexts **ppedec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDebugApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDebugApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDebugApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeFromBreakPoint )( 
            IRemoteDebugApplication * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IRemoteDebugApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDebugger )( 
            IRemoteDebugApplication * This,
            /* [in] */ __RPC__in_opt IApplicationDebugger *pad);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectDebugger )( 
            IRemoteDebugApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugger )( 
            IRemoteDebugApplication * This,
            /* [out] */ __RPC__deref_out_opt IApplicationDebugger **pad);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceAtApplication )( 
            IRemoteDebugApplication * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAlive )( 
            IRemoteDebugApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumThreads )( 
            IRemoteDebugApplication * This,
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplicationThreads **pperdat);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IRemoteDebugApplication * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootNode )( 
            IRemoteDebugApplication * This,
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGlobalExpressionContexts )( 
            IRemoteDebugApplication * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugExpressionContexts **ppedec);
        
        END_INTERFACE
    } IRemoteDebugApplicationVtbl;

    interface IRemoteDebugApplication
    {
        CONST_VTBL struct IRemoteDebugApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteDebugApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteDebugApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteDebugApplication_ResumeFromBreakPoint(This,prptFocus,bra,era)	\
    ( (This)->lpVtbl -> ResumeFromBreakPoint(This,prptFocus,bra,era) ) 

#define IRemoteDebugApplication_CauseBreak(This)	\
    ( (This)->lpVtbl -> CauseBreak(This) ) 

#define IRemoteDebugApplication_ConnectDebugger(This,pad)	\
    ( (This)->lpVtbl -> ConnectDebugger(This,pad) ) 

#define IRemoteDebugApplication_DisconnectDebugger(This)	\
    ( (This)->lpVtbl -> DisconnectDebugger(This) ) 

#define IRemoteDebugApplication_GetDebugger(This,pad)	\
    ( (This)->lpVtbl -> GetDebugger(This,pad) ) 

#define IRemoteDebugApplication_CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject) ) 

#define IRemoteDebugApplication_QueryAlive(This)	\
    ( (This)->lpVtbl -> QueryAlive(This) ) 

#define IRemoteDebugApplication_EnumThreads(This,pperdat)	\
    ( (This)->lpVtbl -> EnumThreads(This,pperdat) ) 

#define IRemoteDebugApplication_GetName(This,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,pbstrName) ) 

#define IRemoteDebugApplication_GetRootNode(This,ppdanRoot)	\
    ( (This)->lpVtbl -> GetRootNode(This,ppdanRoot) ) 

#define IRemoteDebugApplication_EnumGlobalExpressionContexts(This,ppedec)	\
    ( (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppedec) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDebugApplication_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0040 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugApplication IDebugApplication64
#define IID_IDebugApplication IID_IDebugApplication64
#else
#define IDebugApplication IDebugApplication32
#define IID_IDebugApplication IID_IDebugApplication32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0040_v0_0_s_ifspec;

#ifndef __IDebugApplication32_INTERFACE_DEFINED__
#define __IDebugApplication32_INTERFACE_DEFINED__

/* interface IDebugApplication32 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplication32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C32-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplication32 : public IRemoteDebugApplication
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCOLESTR pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOutComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugOutput( 
            /* [in] */ LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleBreakPoint( 
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION *pbra) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakFlags( 
            /* [out] */ APPBREAKFLAGS *pabf,
            /* [out] */ IRemoteDebugApplicationThread **pprdatSteppingThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThread( 
            /* [out] */ IDebugApplicationThread **pat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAsyncDebugOperation( 
            /* [in] */ IDebugSyncOperation *psdo,
            /* [out] */ IDebugAsyncOperation **ppado) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStackFrameSniffer( 
            /* [in] */ IDebugStackFrameSniffer *pdsfs,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStackFrameSniffer( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCurrentThreadIsDebuggerThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallInDebuggerThread( 
            /* [in] */ IDebugThreadCall32 *pptc,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationNode( 
            /* [out] */ IDebugApplicationNode **ppdanNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDebuggerEvent( 
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRuntimeError( 
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [in] */ IActiveScriptSite *pScriptSite,
            /* [out] */ BREAKRESUMEACTION *pbra,
            /* [out] */ ERRORRESUMEACTION *perra,
            /* [out] */ BOOL *pfCallOnScriptError) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FCanJitDebug( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FIsAutoJitDebugEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGlobalExpressionContextProvider( 
            /* [in] */ IProvideExpressionContexts *pdsfs,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveGlobalExpressionContextProvider( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplication32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplication32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplication32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeFromBreakPoint )( 
            IDebugApplication32 * This,
            /* [in] */ IRemoteDebugApplicationThread *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDebugger )( 
            IDebugApplication32 * This,
            /* [in] */ IApplicationDebugger *pad);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectDebugger )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugger )( 
            IDebugApplication32 * This,
            /* [out] */ IApplicationDebugger **pad);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceAtApplication )( 
            IDebugApplication32 * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAlive )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumThreads )( 
            IDebugApplication32 * This,
            /* [out] */ IEnumRemoteDebugApplicationThreads **pperdat);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugApplication32 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootNode )( 
            IDebugApplication32 * This,
            /* [out] */ IDebugApplicationNode **ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGlobalExpressionContexts )( 
            IDebugApplication32 * This,
            /* [out] */ IEnumDebugExpressionContexts **ppedec);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IDebugApplication32 * This,
            /* [in] */ LPCOLESTR pstrName);
        
        HRESULT ( STDMETHODCALLTYPE *StepOutComplete )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DebugOutput )( 
            IDebugApplication32 * This,
            /* [in] */ LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE *StartDebugSession )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleBreakPoint )( 
            IDebugApplication32 * This,
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION *pbra);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakFlags )( 
            IDebugApplication32 * This,
            /* [out] */ APPBREAKFLAGS *pabf,
            /* [out] */ IRemoteDebugApplicationThread **pprdatSteppingThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThread )( 
            IDebugApplication32 * This,
            /* [out] */ IDebugApplicationThread **pat);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAsyncDebugOperation )( 
            IDebugApplication32 * This,
            /* [in] */ IDebugSyncOperation *psdo,
            /* [out] */ IDebugAsyncOperation **ppado);
        
        HRESULT ( STDMETHODCALLTYPE *AddStackFrameSniffer )( 
            IDebugApplication32 * This,
            /* [in] */ IDebugStackFrameSniffer *pdsfs,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStackFrameSniffer )( 
            IDebugApplication32 * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCurrentThreadIsDebuggerThread )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCallInDebuggerThread )( 
            IDebugApplication32 * This,
            /* [in] */ IDebugThreadCall32 *pptc,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE *CreateApplicationNode )( 
            IDebugApplication32 * This,
            /* [out] */ IDebugApplicationNode **ppdanNew);
        
        HRESULT ( STDMETHODCALLTYPE *FireDebuggerEvent )( 
            IDebugApplication32 * This,
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRuntimeError )( 
            IDebugApplication32 * This,
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [in] */ IActiveScriptSite *pScriptSite,
            /* [out] */ BREAKRESUMEACTION *pbra,
            /* [out] */ ERRORRESUMEACTION *perra,
            /* [out] */ BOOL *pfCallOnScriptError);
        
        BOOL ( STDMETHODCALLTYPE *FCanJitDebug )( 
            IDebugApplication32 * This);
        
        BOOL ( STDMETHODCALLTYPE *FIsAutoJitDebugEnabled )( 
            IDebugApplication32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddGlobalExpressionContextProvider )( 
            IDebugApplication32 * This,
            /* [in] */ IProvideExpressionContexts *pdsfs,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveGlobalExpressionContextProvider )( 
            IDebugApplication32 * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IDebugApplication32Vtbl;

    interface IDebugApplication32
    {
        CONST_VTBL struct IDebugApplication32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplication32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplication32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplication32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplication32_ResumeFromBreakPoint(This,prptFocus,bra,era)	\
    ( (This)->lpVtbl -> ResumeFromBreakPoint(This,prptFocus,bra,era) ) 

#define IDebugApplication32_CauseBreak(This)	\
    ( (This)->lpVtbl -> CauseBreak(This) ) 

#define IDebugApplication32_ConnectDebugger(This,pad)	\
    ( (This)->lpVtbl -> ConnectDebugger(This,pad) ) 

#define IDebugApplication32_DisconnectDebugger(This)	\
    ( (This)->lpVtbl -> DisconnectDebugger(This) ) 

#define IDebugApplication32_GetDebugger(This,pad)	\
    ( (This)->lpVtbl -> GetDebugger(This,pad) ) 

#define IDebugApplication32_CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject) ) 

#define IDebugApplication32_QueryAlive(This)	\
    ( (This)->lpVtbl -> QueryAlive(This) ) 

#define IDebugApplication32_EnumThreads(This,pperdat)	\
    ( (This)->lpVtbl -> EnumThreads(This,pperdat) ) 

#define IDebugApplication32_GetName(This,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,pbstrName) ) 

#define IDebugApplication32_GetRootNode(This,ppdanRoot)	\
    ( (This)->lpVtbl -> GetRootNode(This,ppdanRoot) ) 

#define IDebugApplication32_EnumGlobalExpressionContexts(This,ppedec)	\
    ( (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppedec) ) 


#define IDebugApplication32_SetName(This,pstrName)	\
    ( (This)->lpVtbl -> SetName(This,pstrName) ) 

#define IDebugApplication32_StepOutComplete(This)	\
    ( (This)->lpVtbl -> StepOutComplete(This) ) 

#define IDebugApplication32_DebugOutput(This,pstr)	\
    ( (This)->lpVtbl -> DebugOutput(This,pstr) ) 

#define IDebugApplication32_StartDebugSession(This)	\
    ( (This)->lpVtbl -> StartDebugSession(This) ) 

#define IDebugApplication32_HandleBreakPoint(This,br,pbra)	\
    ( (This)->lpVtbl -> HandleBreakPoint(This,br,pbra) ) 

#define IDebugApplication32_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IDebugApplication32_GetBreakFlags(This,pabf,pprdatSteppingThread)	\
    ( (This)->lpVtbl -> GetBreakFlags(This,pabf,pprdatSteppingThread) ) 

#define IDebugApplication32_GetCurrentThread(This,pat)	\
    ( (This)->lpVtbl -> GetCurrentThread(This,pat) ) 

#define IDebugApplication32_CreateAsyncDebugOperation(This,psdo,ppado)	\
    ( (This)->lpVtbl -> CreateAsyncDebugOperation(This,psdo,ppado) ) 

#define IDebugApplication32_AddStackFrameSniffer(This,pdsfs,pdwCookie)	\
    ( (This)->lpVtbl -> AddStackFrameSniffer(This,pdsfs,pdwCookie) ) 

#define IDebugApplication32_RemoveStackFrameSniffer(This,dwCookie)	\
    ( (This)->lpVtbl -> RemoveStackFrameSniffer(This,dwCookie) ) 

#define IDebugApplication32_QueryCurrentThreadIsDebuggerThread(This)	\
    ( (This)->lpVtbl -> QueryCurrentThreadIsDebuggerThread(This) ) 

#define IDebugApplication32_SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3) ) 

#define IDebugApplication32_CreateApplicationNode(This,ppdanNew)	\
    ( (This)->lpVtbl -> CreateApplicationNode(This,ppdanNew) ) 

#define IDebugApplication32_FireDebuggerEvent(This,riid,punk)	\
    ( (This)->lpVtbl -> FireDebuggerEvent(This,riid,punk) ) 

#define IDebugApplication32_HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError)	\
    ( (This)->lpVtbl -> HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError) ) 

#define IDebugApplication32_FCanJitDebug(This)	\
    ( (This)->lpVtbl -> FCanJitDebug(This) ) 

#define IDebugApplication32_FIsAutoJitDebugEnabled(This)	\
    ( (This)->lpVtbl -> FIsAutoJitDebugEnabled(This) ) 

#define IDebugApplication32_AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie)	\
    ( (This)->lpVtbl -> AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie) ) 

#define IDebugApplication32_RemoveGlobalExpressionContextProvider(This,dwCookie)	\
    ( (This)->lpVtbl -> RemoveGlobalExpressionContextProvider(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplication32_INTERFACE_DEFINED__ */


#ifndef __IDebugApplication64_INTERFACE_DEFINED__
#define __IDebugApplication64_INTERFACE_DEFINED__

/* interface IDebugApplication64 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplication64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4dedc754-04c7-4f10-9e60-16a390fe6e62")
    IDebugApplication64 : public IRemoteDebugApplication
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCOLESTR pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOutComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugOutput( 
            /* [in] */ LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleBreakPoint( 
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION *pbra) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakFlags( 
            /* [out] */ APPBREAKFLAGS *pabf,
            /* [out] */ IRemoteDebugApplicationThread **pprdatSteppingThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThread( 
            /* [out] */ IDebugApplicationThread **pat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAsyncDebugOperation( 
            /* [in] */ IDebugSyncOperation *psdo,
            /* [out] */ IDebugAsyncOperation **ppado) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStackFrameSniffer( 
            /* [in] */ IDebugStackFrameSniffer *pdsfs,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStackFrameSniffer( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCurrentThreadIsDebuggerThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallInDebuggerThread( 
            /* [in] */ IDebugThreadCall64 *pptc,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationNode( 
            /* [out] */ IDebugApplicationNode **ppdanNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDebuggerEvent( 
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRuntimeError( 
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [in] */ IActiveScriptSite *pScriptSite,
            /* [out] */ BREAKRESUMEACTION *pbra,
            /* [out] */ ERRORRESUMEACTION *perra,
            /* [out] */ BOOL *pfCallOnScriptError) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FCanJitDebug( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FIsAutoJitDebugEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGlobalExpressionContextProvider( 
            /* [in] */ IProvideExpressionContexts *pdsfs,
            /* [out] */ DWORDLONG *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveGlobalExpressionContextProvider( 
            /* [in] */ DWORDLONG dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplication64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplication64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplication64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeFromBreakPoint )( 
            IDebugApplication64 * This,
            /* [in] */ IRemoteDebugApplicationThread *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDebugger )( 
            IDebugApplication64 * This,
            /* [in] */ IApplicationDebugger *pad);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectDebugger )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugger )( 
            IDebugApplication64 * This,
            /* [out] */ IApplicationDebugger **pad);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceAtApplication )( 
            IDebugApplication64 * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAlive )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumThreads )( 
            IDebugApplication64 * This,
            /* [out] */ IEnumRemoteDebugApplicationThreads **pperdat);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugApplication64 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootNode )( 
            IDebugApplication64 * This,
            /* [out] */ IDebugApplicationNode **ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGlobalExpressionContexts )( 
            IDebugApplication64 * This,
            /* [out] */ IEnumDebugExpressionContexts **ppedec);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IDebugApplication64 * This,
            /* [in] */ LPCOLESTR pstrName);
        
        HRESULT ( STDMETHODCALLTYPE *StepOutComplete )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DebugOutput )( 
            IDebugApplication64 * This,
            /* [in] */ LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE *StartDebugSession )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleBreakPoint )( 
            IDebugApplication64 * This,
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION *pbra);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakFlags )( 
            IDebugApplication64 * This,
            /* [out] */ APPBREAKFLAGS *pabf,
            /* [out] */ IRemoteDebugApplicationThread **pprdatSteppingThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThread )( 
            IDebugApplication64 * This,
            /* [out] */ IDebugApplicationThread **pat);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAsyncDebugOperation )( 
            IDebugApplication64 * This,
            /* [in] */ IDebugSyncOperation *psdo,
            /* [out] */ IDebugAsyncOperation **ppado);
        
        HRESULT ( STDMETHODCALLTYPE *AddStackFrameSniffer )( 
            IDebugApplication64 * This,
            /* [in] */ IDebugStackFrameSniffer *pdsfs,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStackFrameSniffer )( 
            IDebugApplication64 * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCurrentThreadIsDebuggerThread )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCallInDebuggerThread )( 
            IDebugApplication64 * This,
            /* [in] */ IDebugThreadCall64 *pptc,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE *CreateApplicationNode )( 
            IDebugApplication64 * This,
            /* [out] */ IDebugApplicationNode **ppdanNew);
        
        HRESULT ( STDMETHODCALLTYPE *FireDebuggerEvent )( 
            IDebugApplication64 * This,
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRuntimeError )( 
            IDebugApplication64 * This,
            /* [in] */ IActiveScriptErrorDebug *pErrorDebug,
            /* [in] */ IActiveScriptSite *pScriptSite,
            /* [out] */ BREAKRESUMEACTION *pbra,
            /* [out] */ ERRORRESUMEACTION *perra,
            /* [out] */ BOOL *pfCallOnScriptError);
        
        BOOL ( STDMETHODCALLTYPE *FCanJitDebug )( 
            IDebugApplication64 * This);
        
        BOOL ( STDMETHODCALLTYPE *FIsAutoJitDebugEnabled )( 
            IDebugApplication64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddGlobalExpressionContextProvider )( 
            IDebugApplication64 * This,
            /* [in] */ IProvideExpressionContexts *pdsfs,
            /* [out] */ DWORDLONG *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveGlobalExpressionContextProvider )( 
            IDebugApplication64 * This,
            /* [in] */ DWORDLONG dwCookie);
        
        END_INTERFACE
    } IDebugApplication64Vtbl;

    interface IDebugApplication64
    {
        CONST_VTBL struct IDebugApplication64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplication64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplication64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplication64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplication64_ResumeFromBreakPoint(This,prptFocus,bra,era)	\
    ( (This)->lpVtbl -> ResumeFromBreakPoint(This,prptFocus,bra,era) ) 

#define IDebugApplication64_CauseBreak(This)	\
    ( (This)->lpVtbl -> CauseBreak(This) ) 

#define IDebugApplication64_ConnectDebugger(This,pad)	\
    ( (This)->lpVtbl -> ConnectDebugger(This,pad) ) 

#define IDebugApplication64_DisconnectDebugger(This)	\
    ( (This)->lpVtbl -> DisconnectDebugger(This) ) 

#define IDebugApplication64_GetDebugger(This,pad)	\
    ( (This)->lpVtbl -> GetDebugger(This,pad) ) 

#define IDebugApplication64_CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject) ) 

#define IDebugApplication64_QueryAlive(This)	\
    ( (This)->lpVtbl -> QueryAlive(This) ) 

#define IDebugApplication64_EnumThreads(This,pperdat)	\
    ( (This)->lpVtbl -> EnumThreads(This,pperdat) ) 

#define IDebugApplication64_GetName(This,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,pbstrName) ) 

#define IDebugApplication64_GetRootNode(This,ppdanRoot)	\
    ( (This)->lpVtbl -> GetRootNode(This,ppdanRoot) ) 

#define IDebugApplication64_EnumGlobalExpressionContexts(This,ppedec)	\
    ( (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppedec) ) 


#define IDebugApplication64_SetName(This,pstrName)	\
    ( (This)->lpVtbl -> SetName(This,pstrName) ) 

#define IDebugApplication64_StepOutComplete(This)	\
    ( (This)->lpVtbl -> StepOutComplete(This) ) 

#define IDebugApplication64_DebugOutput(This,pstr)	\
    ( (This)->lpVtbl -> DebugOutput(This,pstr) ) 

#define IDebugApplication64_StartDebugSession(This)	\
    ( (This)->lpVtbl -> StartDebugSession(This) ) 

#define IDebugApplication64_HandleBreakPoint(This,br,pbra)	\
    ( (This)->lpVtbl -> HandleBreakPoint(This,br,pbra) ) 

#define IDebugApplication64_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IDebugApplication64_GetBreakFlags(This,pabf,pprdatSteppingThread)	\
    ( (This)->lpVtbl -> GetBreakFlags(This,pabf,pprdatSteppingThread) ) 

#define IDebugApplication64_GetCurrentThread(This,pat)	\
    ( (This)->lpVtbl -> GetCurrentThread(This,pat) ) 

#define IDebugApplication64_CreateAsyncDebugOperation(This,psdo,ppado)	\
    ( (This)->lpVtbl -> CreateAsyncDebugOperation(This,psdo,ppado) ) 

#define IDebugApplication64_AddStackFrameSniffer(This,pdsfs,pdwCookie)	\
    ( (This)->lpVtbl -> AddStackFrameSniffer(This,pdsfs,pdwCookie) ) 

#define IDebugApplication64_RemoveStackFrameSniffer(This,dwCookie)	\
    ( (This)->lpVtbl -> RemoveStackFrameSniffer(This,dwCookie) ) 

#define IDebugApplication64_QueryCurrentThreadIsDebuggerThread(This)	\
    ( (This)->lpVtbl -> QueryCurrentThreadIsDebuggerThread(This) ) 

#define IDebugApplication64_SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3) ) 

#define IDebugApplication64_CreateApplicationNode(This,ppdanNew)	\
    ( (This)->lpVtbl -> CreateApplicationNode(This,ppdanNew) ) 

#define IDebugApplication64_FireDebuggerEvent(This,riid,punk)	\
    ( (This)->lpVtbl -> FireDebuggerEvent(This,riid,punk) ) 

#define IDebugApplication64_HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError)	\
    ( (This)->lpVtbl -> HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError) ) 

#define IDebugApplication64_FCanJitDebug(This)	\
    ( (This)->lpVtbl -> FCanJitDebug(This) ) 

#define IDebugApplication64_FIsAutoJitDebugEnabled(This)	\
    ( (This)->lpVtbl -> FIsAutoJitDebugEnabled(This) ) 

#define IDebugApplication64_AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie)	\
    ( (This)->lpVtbl -> AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie) ) 

#define IDebugApplication64_RemoveGlobalExpressionContextProvider(This,dwCookie)	\
    ( (This)->lpVtbl -> RemoveGlobalExpressionContextProvider(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplication64_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationEvents_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationEvents_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplicationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C33-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplicationEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnConnectDebugger( 
            /* [in] */ __RPC__in_opt IApplicationDebugger *pad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDisconnectDebugger( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetName( 
            /* [in] */ __RPC__in LPCOLESTR pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDebugOutput( 
            /* [in] */ __RPC__in LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClose( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnterBreakPoint( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeaveBreakPoint( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCreateThread( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDestroyThread( 
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBreakFlagChange( 
            /* [in] */ APPBREAKFLAGS abf,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdatSteppingThread) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugApplicationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDebugApplicationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDebugApplicationEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnConnectDebugger )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in_opt IApplicationDebugger *pad);
        
        HRESULT ( STDMETHODCALLTYPE *OnDisconnectDebugger )( 
            IRemoteDebugApplicationEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetName )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in LPCOLESTR pstrName);
        
        HRESULT ( STDMETHODCALLTYPE *OnDebugOutput )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE *OnClose )( 
            IRemoteDebugApplicationEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEnterBreakPoint )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat);
        
        HRESULT ( STDMETHODCALLTYPE *OnLeaveBreakPoint )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat);
        
        HRESULT ( STDMETHODCALLTYPE *OnCreateThread )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat);
        
        HRESULT ( STDMETHODCALLTYPE *OnDestroyThread )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdat);
        
        HRESULT ( STDMETHODCALLTYPE *OnBreakFlagChange )( 
            IRemoteDebugApplicationEvents * This,
            /* [in] */ APPBREAKFLAGS abf,
            /* [in] */ __RPC__in_opt IRemoteDebugApplicationThread *prdatSteppingThread);
        
        END_INTERFACE
    } IRemoteDebugApplicationEventsVtbl;

    interface IRemoteDebugApplicationEvents
    {
        CONST_VTBL struct IRemoteDebugApplicationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteDebugApplicationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteDebugApplicationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteDebugApplicationEvents_OnConnectDebugger(This,pad)	\
    ( (This)->lpVtbl -> OnConnectDebugger(This,pad) ) 

#define IRemoteDebugApplicationEvents_OnDisconnectDebugger(This)	\
    ( (This)->lpVtbl -> OnDisconnectDebugger(This) ) 

#define IRemoteDebugApplicationEvents_OnSetName(This,pstrName)	\
    ( (This)->lpVtbl -> OnSetName(This,pstrName) ) 

#define IRemoteDebugApplicationEvents_OnDebugOutput(This,pstr)	\
    ( (This)->lpVtbl -> OnDebugOutput(This,pstr) ) 

#define IRemoteDebugApplicationEvents_OnClose(This)	\
    ( (This)->lpVtbl -> OnClose(This) ) 

#define IRemoteDebugApplicationEvents_OnEnterBreakPoint(This,prdat)	\
    ( (This)->lpVtbl -> OnEnterBreakPoint(This,prdat) ) 

#define IRemoteDebugApplicationEvents_OnLeaveBreakPoint(This,prdat)	\
    ( (This)->lpVtbl -> OnLeaveBreakPoint(This,prdat) ) 

#define IRemoteDebugApplicationEvents_OnCreateThread(This,prdat)	\
    ( (This)->lpVtbl -> OnCreateThread(This,prdat) ) 

#define IRemoteDebugApplicationEvents_OnDestroyThread(This,prdat)	\
    ( (This)->lpVtbl -> OnDestroyThread(This,prdat) ) 

#define IRemoteDebugApplicationEvents_OnBreakFlagChange(This,abf,prdatSteppingThread)	\
    ( (This)->lpVtbl -> OnBreakFlagChange(This,abf,prdatSteppingThread) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDebugApplicationEvents_INTERFACE_DEFINED__ */


#ifndef __IDebugApplicationNode_INTERFACE_DEFINED__
#define __IDebugApplicationNode_INTERFACE_DEFINED__

/* interface IDebugApplicationNode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C34-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationNode : public IDebugDocumentProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugApplicationNodes **pperddp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **pprddp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentProvider( 
            /* [in] */ __RPC__in_opt IDebugDocumentProvider *pddp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *pdanParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplicationNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplicationNode * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplicationNode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplicationNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugApplicationNode * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugApplicationNode * This,
            /* [out] */ __RPC__out CLSID *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugApplicationNode * This,
            /* [out] */ __RPC__deref_out_opt IDebugDocument **ppssd);
        
        HRESULT ( STDMETHODCALLTYPE *EnumChildren )( 
            IDebugApplicationNode * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugApplicationNodes **pperddp);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDebugApplicationNode * This,
            /* [out] */ __RPC__deref_out_opt IDebugApplicationNode **pprddp);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentProvider )( 
            IDebugApplicationNode * This,
            /* [in] */ __RPC__in_opt IDebugDocumentProvider *pddp);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IDebugApplicationNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugApplicationNode * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *pdanParent);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDebugApplicationNode * This);
        
        END_INTERFACE
    } IDebugApplicationNodeVtbl;

    interface IDebugApplicationNode
    {
        CONST_VTBL struct IDebugApplicationNodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationNode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplicationNode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplicationNode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplicationNode_GetName(This,dnt,pbstrName)	\
    ( (This)->lpVtbl -> GetName(This,dnt,pbstrName) ) 

#define IDebugApplicationNode_GetDocumentClassId(This,pclsidDocument)	\
    ( (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument) ) 


#define IDebugApplicationNode_GetDocument(This,ppssd)	\
    ( (This)->lpVtbl -> GetDocument(This,ppssd) ) 


#define IDebugApplicationNode_EnumChildren(This,pperddp)	\
    ( (This)->lpVtbl -> EnumChildren(This,pperddp) ) 

#define IDebugApplicationNode_GetParent(This,pprddp)	\
    ( (This)->lpVtbl -> GetParent(This,pprddp) ) 

#define IDebugApplicationNode_SetDocumentProvider(This,pddp)	\
    ( (This)->lpVtbl -> SetDocumentProvider(This,pddp) ) 

#define IDebugApplicationNode_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IDebugApplicationNode_Attach(This,pdanParent)	\
    ( (This)->lpVtbl -> Attach(This,pdanParent) ) 

#define IDebugApplicationNode_Detach(This)	\
    ( (This)->lpVtbl -> Detach(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplicationNode_INTERFACE_DEFINED__ */


#ifndef __IDebugApplicationNodeEvents_INTERFACE_DEFINED__
#define __IDebugApplicationNodeEvents_INTERFACE_DEFINED__

/* interface IDebugApplicationNodeEvents */
/* [unique][async_uuid][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationNodeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C35-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationNodeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onAddChild( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveChild( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onDetach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onAttach( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplicationNodeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplicationNodeEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *onAddChild )( 
            IDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild);
        
        HRESULT ( STDMETHODCALLTYPE *onRemoveChild )( 
            IDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild);
        
        HRESULT ( STDMETHODCALLTYPE *onDetach )( 
            IDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *onAttach )( 
            IDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpParent);
        
        END_INTERFACE
    } IDebugApplicationNodeEventsVtbl;

    interface IDebugApplicationNodeEvents
    {
        CONST_VTBL struct IDebugApplicationNodeEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationNodeEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplicationNodeEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplicationNodeEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplicationNodeEvents_onAddChild(This,prddpChild)	\
    ( (This)->lpVtbl -> onAddChild(This,prddpChild) ) 

#define IDebugApplicationNodeEvents_onRemoveChild(This,prddpChild)	\
    ( (This)->lpVtbl -> onRemoveChild(This,prddpChild) ) 

#define IDebugApplicationNodeEvents_onDetach(This)	\
    ( (This)->lpVtbl -> onDetach(This) ) 

#define IDebugApplicationNodeEvents_onAttach(This,prddpParent)	\
    ( (This)->lpVtbl -> onAttach(This,prddpParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplicationNodeEvents_INTERFACE_DEFINED__ */


#ifndef __AsyncIDebugApplicationNodeEvents_INTERFACE_DEFINED__
#define __AsyncIDebugApplicationNodeEvents_INTERFACE_DEFINED__

/* interface AsyncIDebugApplicationNodeEvents */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_AsyncIDebugApplicationNodeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a2e3aa3b-aa8d-4ebf-84cd-648b737b8c13")
    AsyncIDebugApplicationNodeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin_onAddChild( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_onAddChild( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_onRemoveChild( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_onRemoveChild( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_onDetach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_onDetach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_onAttach( 
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_onAttach( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AsyncIDebugApplicationNodeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            AsyncIDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_onAddChild )( 
            AsyncIDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_onAddChild )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_onRemoveChild )( 
            AsyncIDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpChild);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_onRemoveChild )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_onDetach )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_onDetach )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_onAttach )( 
            AsyncIDebugApplicationNodeEvents * This,
            /* [in] */ __RPC__in_opt IDebugApplicationNode *prddpParent);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_onAttach )( 
            AsyncIDebugApplicationNodeEvents * This);
        
        END_INTERFACE
    } AsyncIDebugApplicationNodeEventsVtbl;

    interface AsyncIDebugApplicationNodeEvents
    {
        CONST_VTBL struct AsyncIDebugApplicationNodeEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AsyncIDebugApplicationNodeEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define AsyncIDebugApplicationNodeEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define AsyncIDebugApplicationNodeEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define AsyncIDebugApplicationNodeEvents_Begin_onAddChild(This,prddpChild)	\
    ( (This)->lpVtbl -> Begin_onAddChild(This,prddpChild) ) 

#define AsyncIDebugApplicationNodeEvents_Finish_onAddChild(This)	\
    ( (This)->lpVtbl -> Finish_onAddChild(This) ) 

#define AsyncIDebugApplicationNodeEvents_Begin_onRemoveChild(This,prddpChild)	\
    ( (This)->lpVtbl -> Begin_onRemoveChild(This,prddpChild) ) 

#define AsyncIDebugApplicationNodeEvents_Finish_onRemoveChild(This)	\
    ( (This)->lpVtbl -> Finish_onRemoveChild(This) ) 

#define AsyncIDebugApplicationNodeEvents_Begin_onDetach(This)	\
    ( (This)->lpVtbl -> Begin_onDetach(This) ) 

#define AsyncIDebugApplicationNodeEvents_Finish_onDetach(This)	\
    ( (This)->lpVtbl -> Finish_onDetach(This) ) 

#define AsyncIDebugApplicationNodeEvents_Begin_onAttach(This,prddpParent)	\
    ( (This)->lpVtbl -> Begin_onAttach(This,prddpParent) ) 

#define AsyncIDebugApplicationNodeEvents_Finish_onAttach(This)	\
    ( (This)->lpVtbl -> Finish_onAttach(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __AsyncIDebugApplicationNodeEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0045 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugThreadCall IDebugThreadCall64
#define IID_IDebugThreadCall IID_IDebugThreadCall64
#else
#define IDebugThreadCall IDebugThreadCall32
#define IID_IDebugThreadCall IID_IDebugThreadCall32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0045_v0_0_s_ifspec;

#ifndef __IDebugThreadCall32_INTERFACE_DEFINED__
#define __IDebugThreadCall32_INTERFACE_DEFINED__

/* interface IDebugThreadCall32 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadCall32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C36-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugThreadCall32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadCallHandler( 
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugThreadCall32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugThreadCall32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugThreadCall32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugThreadCall32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCallHandler )( 
            IDebugThreadCall32 * This,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        END_INTERFACE
    } IDebugThreadCall32Vtbl;

    interface IDebugThreadCall32
    {
        CONST_VTBL struct IDebugThreadCall32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadCall32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugThreadCall32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugThreadCall32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugThreadCall32_ThreadCallHandler(This,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> ThreadCallHandler(This,dwParam1,dwParam2,dwParam3) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugThreadCall32_INTERFACE_DEFINED__ */


#ifndef __IDebugThreadCall64_INTERFACE_DEFINED__
#define __IDebugThreadCall64_INTERFACE_DEFINED__

/* interface IDebugThreadCall64 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadCall64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb3fa335-e979-42fd-9fcf-a7546a0f3905")
    IDebugThreadCall64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadCallHandler( 
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugThreadCall64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugThreadCall64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugThreadCall64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugThreadCall64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCallHandler )( 
            IDebugThreadCall64 * This,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3);
        
        END_INTERFACE
    } IDebugThreadCall64Vtbl;

    interface IDebugThreadCall64
    {
        CONST_VTBL struct IDebugThreadCall64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadCall64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugThreadCall64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugThreadCall64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugThreadCall64_ThreadCallHandler(This,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> ThreadCallHandler(This,dwParam1,dwParam2,dwParam3) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugThreadCall64_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationThread_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationThread_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationThread */
/* [unique][uuid][object] */ 

typedef DWORD THREAD_STATE;

#define	THREAD_STATE_RUNNING	( 0x1 )

#define	THREAD_STATE_SUSPENDED	( 0x2 )

#define	THREAD_BLOCKED	( 0x4 )

#define	THREAD_OUT_OF_CONTEXT	( 0x8 )


EXTERN_C const IID IID_IRemoteDebugApplicationThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C37-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplicationThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemThreadId( 
            /* [out] */ __RPC__out DWORD *dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [out] */ __RPC__deref_out_opt IRemoteDebugApplication **pprda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStackFrames( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNextStatement( 
            /* [in] */ __RPC__in_opt IDebugStackFrame *pStackFrame,
            /* [in] */ __RPC__in_opt IDebugCodeContext *pCodeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ __RPC__out DWORD *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( 
            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuspendCount( 
            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugApplicationThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDebugApplicationThread * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDebugApplicationThread * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDebugApplicationThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemThreadId )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__out DWORD *dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__deref_out_opt IRemoteDebugApplication **pprda);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFrames )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugStackFrames **ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrState);
        
        HRESULT ( STDMETHODCALLTYPE *SetNextStatement )( 
            IRemoteDebugApplicationThread * This,
            /* [in] */ __RPC__in_opt IDebugStackFrame *pStackFrame,
            /* [in] */ __RPC__in_opt IDebugCodeContext *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__out DWORD *pState);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__out DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__out DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSuspendCount )( 
            IRemoteDebugApplicationThread * This,
            /* [out] */ __RPC__out DWORD *pdwCount);
        
        END_INTERFACE
    } IRemoteDebugApplicationThreadVtbl;

    interface IRemoteDebugApplicationThread
    {
        CONST_VTBL struct IRemoteDebugApplicationThreadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationThread_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteDebugApplicationThread_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteDebugApplicationThread_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteDebugApplicationThread_GetSystemThreadId(This,dwThreadId)	\
    ( (This)->lpVtbl -> GetSystemThreadId(This,dwThreadId) ) 

#define IRemoteDebugApplicationThread_GetApplication(This,pprda)	\
    ( (This)->lpVtbl -> GetApplication(This,pprda) ) 

#define IRemoteDebugApplicationThread_EnumStackFrames(This,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFrames(This,ppedsf) ) 

#define IRemoteDebugApplicationThread_GetDescription(This,pbstrDescription,pbstrState)	\
    ( (This)->lpVtbl -> GetDescription(This,pbstrDescription,pbstrState) ) 

#define IRemoteDebugApplicationThread_SetNextStatement(This,pStackFrame,pCodeContext)	\
    ( (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext) ) 

#define IRemoteDebugApplicationThread_GetState(This,pState)	\
    ( (This)->lpVtbl -> GetState(This,pState) ) 

#define IRemoteDebugApplicationThread_Suspend(This,pdwCount)	\
    ( (This)->lpVtbl -> Suspend(This,pdwCount) ) 

#define IRemoteDebugApplicationThread_Resume(This,pdwCount)	\
    ( (This)->lpVtbl -> Resume(This,pdwCount) ) 

#define IRemoteDebugApplicationThread_GetSuspendCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetSuspendCount(This,pdwCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDebugApplicationThread_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0048 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define SynchronousCallIntoThread SynchronousCallIntoThread64
#else
#define SynchronousCallIntoThread SynchronousCallIntoThread32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0048_v0_0_s_ifspec;

#ifndef __IDebugApplicationThread_INTERFACE_DEFINED__
#define __IDebugApplicationThread_INTERFACE_DEFINED__

/* interface IDebugApplicationThread */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C38-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationThread : public IRemoteDebugApplicationThread
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallIntoThread32( 
            /* [in] */ IDebugThreadCall32 *pstcb,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsCurrentThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsDebuggerThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPCOLESTR pstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStateString( 
            /* [in] */ LPCOLESTR pstrState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplicationThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplicationThread * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplicationThread * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplicationThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemThreadId )( 
            IDebugApplicationThread * This,
            /* [out] */ DWORD *dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IDebugApplicationThread * This,
            /* [out] */ IRemoteDebugApplication **pprda);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFrames )( 
            IDebugApplicationThread * This,
            /* [out] */ IEnumDebugStackFrames **ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IDebugApplicationThread * This,
            /* [out] */ BSTR *pbstrDescription,
            /* [out] */ BSTR *pbstrState);
        
        HRESULT ( STDMETHODCALLTYPE *SetNextStatement )( 
            IDebugApplicationThread * This,
            /* [in] */ IDebugStackFrame *pStackFrame,
            /* [in] */ IDebugCodeContext *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDebugApplicationThread * This,
            /* [out] */ DWORD *pState);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IDebugApplicationThread * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDebugApplicationThread * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSuspendCount )( 
            IDebugApplicationThread * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCallIntoThread32 )( 
            IDebugApplicationThread * This,
            /* [in] */ IDebugThreadCall32 *pstcb,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE *QueryIsCurrentThread )( 
            IDebugApplicationThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryIsDebuggerThread )( 
            IDebugApplicationThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IDebugApplicationThread * This,
            /* [in] */ LPCOLESTR pstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetStateString )( 
            IDebugApplicationThread * This,
            /* [in] */ LPCOLESTR pstrState);
        
        END_INTERFACE
    } IDebugApplicationThreadVtbl;

    interface IDebugApplicationThread
    {
        CONST_VTBL struct IDebugApplicationThreadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationThread_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplicationThread_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplicationThread_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplicationThread_GetSystemThreadId(This,dwThreadId)	\
    ( (This)->lpVtbl -> GetSystemThreadId(This,dwThreadId) ) 

#define IDebugApplicationThread_GetApplication(This,pprda)	\
    ( (This)->lpVtbl -> GetApplication(This,pprda) ) 

#define IDebugApplicationThread_EnumStackFrames(This,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFrames(This,ppedsf) ) 

#define IDebugApplicationThread_GetDescription(This,pbstrDescription,pbstrState)	\
    ( (This)->lpVtbl -> GetDescription(This,pbstrDescription,pbstrState) ) 

#define IDebugApplicationThread_SetNextStatement(This,pStackFrame,pCodeContext)	\
    ( (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext) ) 

#define IDebugApplicationThread_GetState(This,pState)	\
    ( (This)->lpVtbl -> GetState(This,pState) ) 

#define IDebugApplicationThread_Suspend(This,pdwCount)	\
    ( (This)->lpVtbl -> Suspend(This,pdwCount) ) 

#define IDebugApplicationThread_Resume(This,pdwCount)	\
    ( (This)->lpVtbl -> Resume(This,pdwCount) ) 

#define IDebugApplicationThread_GetSuspendCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetSuspendCount(This,pdwCount) ) 


#define IDebugApplicationThread_SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3) ) 

#define IDebugApplicationThread_QueryIsCurrentThread(This)	\
    ( (This)->lpVtbl -> QueryIsCurrentThread(This) ) 

#define IDebugApplicationThread_QueryIsDebuggerThread(This)	\
    ( (This)->lpVtbl -> QueryIsDebuggerThread(This) ) 

#define IDebugApplicationThread_SetDescription(This,pstrDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,pstrDescription) ) 

#define IDebugApplicationThread_SetStateString(This,pstrState)	\
    ( (This)->lpVtbl -> SetStateString(This,pstrState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplicationThread_INTERFACE_DEFINED__ */


#ifndef __IDebugApplicationThread64_INTERFACE_DEFINED__
#define __IDebugApplicationThread64_INTERFACE_DEFINED__

/* interface IDebugApplicationThread64 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationThread64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9dac5886-dbad-456d-9dee-5dec39ab3dda")
    IDebugApplicationThread64 : public IDebugApplicationThread
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallIntoThread64( 
            /* [in] */ IDebugThreadCall64 *pstcb,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplicationThread64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplicationThread64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplicationThread64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplicationThread64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemThreadId )( 
            IDebugApplicationThread64 * This,
            /* [out] */ DWORD *dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IDebugApplicationThread64 * This,
            /* [out] */ IRemoteDebugApplication **pprda);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStackFrames )( 
            IDebugApplicationThread64 * This,
            /* [out] */ IEnumDebugStackFrames **ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IDebugApplicationThread64 * This,
            /* [out] */ BSTR *pbstrDescription,
            /* [out] */ BSTR *pbstrState);
        
        HRESULT ( STDMETHODCALLTYPE *SetNextStatement )( 
            IDebugApplicationThread64 * This,
            /* [in] */ IDebugStackFrame *pStackFrame,
            /* [in] */ IDebugCodeContext *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDebugApplicationThread64 * This,
            /* [out] */ DWORD *pState);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IDebugApplicationThread64 * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDebugApplicationThread64 * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSuspendCount )( 
            IDebugApplicationThread64 * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCallIntoThread32 )( 
            IDebugApplicationThread64 * This,
            /* [in] */ IDebugThreadCall32 *pstcb,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE *QueryIsCurrentThread )( 
            IDebugApplicationThread64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryIsDebuggerThread )( 
            IDebugApplicationThread64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IDebugApplicationThread64 * This,
            /* [in] */ LPCOLESTR pstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetStateString )( 
            IDebugApplicationThread64 * This,
            /* [in] */ LPCOLESTR pstrState);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCallIntoThread64 )( 
            IDebugApplicationThread64 * This,
            /* [in] */ IDebugThreadCall64 *pstcb,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3);
        
        END_INTERFACE
    } IDebugApplicationThread64Vtbl;

    interface IDebugApplicationThread64
    {
        CONST_VTBL struct IDebugApplicationThread64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationThread64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplicationThread64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplicationThread64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplicationThread64_GetSystemThreadId(This,dwThreadId)	\
    ( (This)->lpVtbl -> GetSystemThreadId(This,dwThreadId) ) 

#define IDebugApplicationThread64_GetApplication(This,pprda)	\
    ( (This)->lpVtbl -> GetApplication(This,pprda) ) 

#define IDebugApplicationThread64_EnumStackFrames(This,ppedsf)	\
    ( (This)->lpVtbl -> EnumStackFrames(This,ppedsf) ) 

#define IDebugApplicationThread64_GetDescription(This,pbstrDescription,pbstrState)	\
    ( (This)->lpVtbl -> GetDescription(This,pbstrDescription,pbstrState) ) 

#define IDebugApplicationThread64_SetNextStatement(This,pStackFrame,pCodeContext)	\
    ( (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext) ) 

#define IDebugApplicationThread64_GetState(This,pState)	\
    ( (This)->lpVtbl -> GetState(This,pState) ) 

#define IDebugApplicationThread64_Suspend(This,pdwCount)	\
    ( (This)->lpVtbl -> Suspend(This,pdwCount) ) 

#define IDebugApplicationThread64_Resume(This,pdwCount)	\
    ( (This)->lpVtbl -> Resume(This,pdwCount) ) 

#define IDebugApplicationThread64_GetSuspendCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetSuspendCount(This,pdwCount) ) 


#define IDebugApplicationThread64_SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3) ) 

#define IDebugApplicationThread64_QueryIsCurrentThread(This)	\
    ( (This)->lpVtbl -> QueryIsCurrentThread(This) ) 

#define IDebugApplicationThread64_QueryIsDebuggerThread(This)	\
    ( (This)->lpVtbl -> QueryIsDebuggerThread(This) ) 

#define IDebugApplicationThread64_SetDescription(This,pstrDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,pstrDescription) ) 

#define IDebugApplicationThread64_SetStateString(This,pstrState)	\
    ( (This)->lpVtbl -> SetStateString(This,pstrState) ) 


#define IDebugApplicationThread64_SynchronousCallIntoThread64(This,pstcb,dwParam1,dwParam2,dwParam3)	\
    ( (This)->lpVtbl -> SynchronousCallIntoThread64(This,pstcb,dwParam1,dwParam2,dwParam3) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplicationThread64_INTERFACE_DEFINED__ */


#ifndef __IDebugCookie_INTERFACE_DEFINED__
#define __IDebugCookie_INTERFACE_DEFINED__

/* interface IDebugCookie */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDebugCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C39-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugCookie : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDebugCookie( 
            /* [in] */ DWORD dwDebugAppCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugCookie * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugCookie * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugCookie * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugCookie )( 
            IDebugCookie * This,
            /* [in] */ DWORD dwDebugAppCookie);
        
        END_INTERFACE
    } IDebugCookieVtbl;

    interface IDebugCookie
    {
        CONST_VTBL struct IDebugCookieVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugCookie_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugCookie_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugCookie_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugCookie_SetDebugCookie(This,dwDebugAppCookie)	\
    ( (This)->lpVtbl -> SetDebugCookie(This,dwDebugAppCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugCookie_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugApplicationNodes_INTERFACE_DEFINED__
#define __IEnumDebugApplicationNodes_INTERFACE_DEFINED__

/* interface IEnumDebugApplicationNodes */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugApplicationNodes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3a-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugApplicationNodes : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDebugApplicationNode **pprddp,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugApplicationNodes **pperddp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugApplicationNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugApplicationNodes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugApplicationNodes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugApplicationNodes * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumDebugApplicationNodes * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDebugApplicationNode **pprddp,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugApplicationNodes * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugApplicationNodes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugApplicationNodes * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugApplicationNodes **pperddp);
        
        END_INTERFACE
    } IEnumDebugApplicationNodesVtbl;

    interface IEnumDebugApplicationNodes
    {
        CONST_VTBL struct IEnumDebugApplicationNodesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugApplicationNodes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugApplicationNodes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugApplicationNodes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugApplicationNodes_Next(This,celt,pprddp,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pprddp,pceltFetched) ) 

#define IEnumDebugApplicationNodes_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugApplicationNodes_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugApplicationNodes_Clone(This,pperddp)	\
    ( (This)->lpVtbl -> Clone(This,pperddp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugApplicationNodes_RemoteNext_Proxy( 
    IEnumDebugApplicationNodes * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IDebugApplicationNode **pprddp,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumDebugApplicationNodes_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugApplicationNodes_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteDebugApplications_INTERFACE_DEFINED__
#define __IEnumRemoteDebugApplications_INTERFACE_DEFINED__

/* interface IEnumRemoteDebugApplications */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumRemoteDebugApplications;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3b-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumRemoteDebugApplications : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplication **ppda,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplications **ppessd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteDebugApplicationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRemoteDebugApplications * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRemoteDebugApplications * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRemoteDebugApplications * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumRemoteDebugApplications * This,
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplication **ppda,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRemoteDebugApplications * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRemoteDebugApplications * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRemoteDebugApplications * This,
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplications **ppessd);
        
        END_INTERFACE
    } IEnumRemoteDebugApplicationsVtbl;

    interface IEnumRemoteDebugApplications
    {
        CONST_VTBL struct IEnumRemoteDebugApplicationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteDebugApplications_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRemoteDebugApplications_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRemoteDebugApplications_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRemoteDebugApplications_Next(This,celt,ppda,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppda,pceltFetched) ) 

#define IEnumRemoteDebugApplications_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumRemoteDebugApplications_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRemoteDebugApplications_Clone(This,ppessd)	\
    ( (This)->lpVtbl -> Clone(This,ppessd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplications_RemoteNext_Proxy( 
    IEnumRemoteDebugApplications * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IRemoteDebugApplication **ppda,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumRemoteDebugApplications_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteDebugApplications_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteDebugApplicationThreads_INTERFACE_DEFINED__
#define __IEnumRemoteDebugApplicationThreads_INTERFACE_DEFINED__

/* interface IEnumRemoteDebugApplicationThreads */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumRemoteDebugApplicationThreads;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3c-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumRemoteDebugApplicationThreads : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplicationThread **pprdat,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplicationThreads **pperdat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteDebugApplicationThreadsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRemoteDebugApplicationThreads * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRemoteDebugApplicationThreads * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRemoteDebugApplicationThreads * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumRemoteDebugApplicationThreads * This,
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplicationThread **pprdat,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRemoteDebugApplicationThreads * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRemoteDebugApplicationThreads * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRemoteDebugApplicationThreads * This,
            /* [out] */ __RPC__deref_out_opt IEnumRemoteDebugApplicationThreads **pperdat);
        
        END_INTERFACE
    } IEnumRemoteDebugApplicationThreadsVtbl;

    interface IEnumRemoteDebugApplicationThreads
    {
        CONST_VTBL struct IEnumRemoteDebugApplicationThreadsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteDebugApplicationThreads_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRemoteDebugApplicationThreads_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRemoteDebugApplicationThreads_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRemoteDebugApplicationThreads_Next(This,celt,pprdat,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pprdat,pceltFetched) ) 

#define IEnumRemoteDebugApplicationThreads_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumRemoteDebugApplicationThreads_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRemoteDebugApplicationThreads_Clone(This,pperdat)	\
    ( (This)->lpVtbl -> Clone(This,pperdat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplicationThreads_RemoteNext_Proxy( 
    IEnumRemoteDebugApplicationThreads * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IRemoteDebugApplicationThread **ppdat,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumRemoteDebugApplicationThreads_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteDebugApplicationThreads_INTERFACE_DEFINED__ */


#ifndef __IDebugFormatter_INTERFACE_DEFINED__
#define __IDebugFormatter_INTERFACE_DEFINED__

/* interface IDebugFormatter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugFormatter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C05-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugFormatter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStringForVariant( 
            /* [in] */ VARIANT *pvar,
            /* [in] */ ULONG nRadix,
            /* [out] */ BSTR *pbstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariantForString( 
            /* [in] */ LPCOLESTR pwstrValue,
            /* [out] */ VARIANT *pvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringForVarType( 
            /* [in] */ VARTYPE vt,
            /* [in] */ TYPEDESC *ptdescArrayType,
            /* [out] */ BSTR *pbstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugFormatterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugFormatter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugFormatter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugFormatter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringForVariant )( 
            IDebugFormatter * This,
            /* [in] */ VARIANT *pvar,
            /* [in] */ ULONG nRadix,
            /* [out] */ BSTR *pbstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariantForString )( 
            IDebugFormatter * This,
            /* [in] */ LPCOLESTR pwstrValue,
            /* [out] */ VARIANT *pvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringForVarType )( 
            IDebugFormatter * This,
            /* [in] */ VARTYPE vt,
            /* [in] */ TYPEDESC *ptdescArrayType,
            /* [out] */ BSTR *pbstr);
        
        END_INTERFACE
    } IDebugFormatterVtbl;

    interface IDebugFormatter
    {
        CONST_VTBL struct IDebugFormatterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugFormatter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugFormatter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugFormatter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugFormatter_GetStringForVariant(This,pvar,nRadix,pbstrValue)	\
    ( (This)->lpVtbl -> GetStringForVariant(This,pvar,nRadix,pbstrValue) ) 

#define IDebugFormatter_GetVariantForString(This,pwstrValue,pvar)	\
    ( (This)->lpVtbl -> GetVariantForString(This,pwstrValue,pvar) ) 

#define IDebugFormatter_GetStringForVarType(This,vt,ptdescArrayType,pbstr)	\
    ( (This)->lpVtbl -> GetStringForVarType(This,vt,ptdescArrayType,pbstr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugFormatter_INTERFACE_DEFINED__ */


#ifndef __ISimpleConnectionPoint_INTERFACE_DEFINED__
#define __ISimpleConnectionPoint_INTERFACE_DEFINED__

/* interface ISimpleConnectionPoint */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISimpleConnectionPoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3e-CB0C-11d0-B5C9-00A0244A0E7A")
    ISimpleConnectionPoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DescribeEvents( 
            /* [in] */ ULONG iEvent,
            /* [in] */ ULONG cEvents,
            /* [length_is][size_is][out] */ DISPID *prgid,
            /* [length_is][size_is][out] */ BSTR *prgbstr,
            /* [out] */ ULONG *pcEventsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IDispatch *pdisp,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleConnectionPointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleConnectionPoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleConnectionPoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleConnectionPoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventCount )( 
            ISimpleConnectionPoint * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *DescribeEvents )( 
            ISimpleConnectionPoint * This,
            /* [in] */ ULONG iEvent,
            /* [in] */ ULONG cEvents,
            /* [length_is][size_is][out] */ DISPID *prgid,
            /* [length_is][size_is][out] */ BSTR *prgbstr,
            /* [out] */ ULONG *pcEventsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ISimpleConnectionPoint * This,
            /* [in] */ IDispatch *pdisp,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ISimpleConnectionPoint * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ISimpleConnectionPointVtbl;

    interface ISimpleConnectionPoint
    {
        CONST_VTBL struct ISimpleConnectionPointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleConnectionPoint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISimpleConnectionPoint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISimpleConnectionPoint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISimpleConnectionPoint_GetEventCount(This,pulCount)	\
    ( (This)->lpVtbl -> GetEventCount(This,pulCount) ) 

#define ISimpleConnectionPoint_DescribeEvents(This,iEvent,cEvents,prgid,prgbstr,pcEventsFetched)	\
    ( (This)->lpVtbl -> DescribeEvents(This,iEvent,cEvents,prgid,prgbstr,pcEventsFetched) ) 

#define ISimpleConnectionPoint_Advise(This,pdisp,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pdisp,pdwCookie) ) 

#define ISimpleConnectionPoint_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISimpleConnectionPoint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0000_0056 */
/* [local] */ 

EXTERN_C const CLSID CLSID_DebugHelper;


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0056_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0056_v0_0_s_ifspec;

#ifndef __IDebugHelper_INTERFACE_DEFINED__
#define __IDebugHelper_INTERFACE_DEFINED__

/* interface IDebugHelper */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3f-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyBrowser( 
            /* [in] */ VARIANT *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [out] */ IDebugProperty **ppdob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyBrowserEx( 
            /* [in] */ VARIANT *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [in] */ IDebugFormatter *pdf,
            /* [out] */ IDebugProperty **ppdob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSimpleConnectionPoint( 
            /* [in] */ IDispatch *pdisp,
            /* [out] */ ISimpleConnectionPoint **ppscp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyBrowser )( 
            IDebugHelper * This,
            /* [in] */ VARIANT *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [out] */ IDebugProperty **ppdob);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyBrowserEx )( 
            IDebugHelper * This,
            /* [in] */ VARIANT *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [in] */ IDebugFormatter *pdf,
            /* [out] */ IDebugProperty **ppdob);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSimpleConnectionPoint )( 
            IDebugHelper * This,
            /* [in] */ IDispatch *pdisp,
            /* [out] */ ISimpleConnectionPoint **ppscp);
        
        END_INTERFACE
    } IDebugHelperVtbl;

    interface IDebugHelper
    {
        CONST_VTBL struct IDebugHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugHelper_CreatePropertyBrowser(This,pvar,bstrName,pdat,ppdob)	\
    ( (This)->lpVtbl -> CreatePropertyBrowser(This,pvar,bstrName,pdat,ppdob) ) 

#define IDebugHelper_CreatePropertyBrowserEx(This,pvar,bstrName,pdat,pdf,ppdob)	\
    ( (This)->lpVtbl -> CreatePropertyBrowserEx(This,pvar,bstrName,pdat,pdf,ppdob) ) 

#define IDebugHelper_CreateSimpleConnectionPoint(This,pdisp,ppscp)	\
    ( (This)->lpVtbl -> CreateSimpleConnectionPoint(This,pdisp,ppscp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugHelper_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExpressionContexts_INTERFACE_DEFINED__
#define __IEnumDebugExpressionContexts_INTERFACE_DEFINED__

/* interface IEnumDebugExpressionContexts */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugExpressionContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C40-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExpressionContexts : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDebugExpressionContext **ppdec,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugExpressionContexts **ppedec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExpressionContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugExpressionContexts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugExpressionContexts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugExpressionContexts * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumDebugExpressionContexts * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDebugExpressionContext **ppdec,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugExpressionContexts * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugExpressionContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugExpressionContexts * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugExpressionContexts **ppedec);
        
        END_INTERFACE
    } IEnumDebugExpressionContextsVtbl;

    interface IEnumDebugExpressionContexts
    {
        CONST_VTBL struct IEnumDebugExpressionContextsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExpressionContexts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugExpressionContexts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugExpressionContexts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugExpressionContexts_Next(This,celt,ppdec,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppdec,pceltFetched) ) 

#define IEnumDebugExpressionContexts_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugExpressionContexts_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugExpressionContexts_Clone(This,ppedec)	\
    ( (This)->lpVtbl -> Clone(This,ppedec) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugExpressionContexts_RemoteNext_Proxy( 
    IEnumDebugExpressionContexts * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IDebugExpressionContext **pprgdec,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumDebugExpressionContexts_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExpressionContexts_INTERFACE_DEFINED__ */


#ifndef __IProvideExpressionContexts_INTERFACE_DEFINED__
#define __IProvideExpressionContexts_INTERFACE_DEFINED__

/* interface IProvideExpressionContexts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvideExpressionContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C41-CB0C-11d0-B5C9-00A0244A0E7A")
    IProvideExpressionContexts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumExpressionContexts( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugExpressionContexts **ppedec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideExpressionContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvideExpressionContexts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvideExpressionContexts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvideExpressionContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumExpressionContexts )( 
            IProvideExpressionContexts * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugExpressionContexts **ppedec);
        
        END_INTERFACE
    } IProvideExpressionContextsVtbl;

    interface IProvideExpressionContexts
    {
        CONST_VTBL struct IProvideExpressionContextsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideExpressionContexts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideExpressionContexts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideExpressionContexts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideExpressionContexts_EnumExpressionContexts(This,ppedec)	\
    ( (This)->lpVtbl -> EnumExpressionContexts(This,ppedec) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideExpressionContexts_INTERFACE_DEFINED__ */



#ifndef __ProcessDebugManagerLib_LIBRARY_DEFINED__
#define __ProcessDebugManagerLib_LIBRARY_DEFINED__

/* library ProcessDebugManagerLib */
/* [helpstring][version][uuid] */ 



























































EXTERN_C const CLSID CLSID_CDebugDocumentHelper;
#ifdef DEBUG
#define MachineDebugManger MachineDebugManager_DEBUG
#define CLSID_MachineDebugManager CLSID_MachineDebugManager_DEBUG
#else
#define MachineDebugManger MachineDebugManager_RETAIL
#define CLSID_MachineDebugManager CLSID_MachineDebugManager_RETAIL
#endif

EXTERN_C const IID LIBID_ProcessDebugManagerLib;

EXTERN_C const CLSID CLSID_ProcessDebugManager;

#ifdef __cplusplus

class DECLSPEC_UUID("78a51822-51f4-11d0-8f20-00805f2cd064")
ProcessDebugManager;
#endif

EXTERN_C const CLSID CLSID_DebugHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("0BFCC060-8C1D-11d0-ACCD-00AA0060275C")
DebugHelper;
#endif

EXTERN_C const CLSID CLSID_CDebugDocumentHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("83B8BCA6-687C-11D0-A405-00AA0060275C")
CDebugDocumentHelper;
#endif

EXTERN_C const CLSID CLSID_MachineDebugManager_RETAIL;

#ifdef __cplusplus

class DECLSPEC_UUID("0C0A3666-30C9-11D0-8F20-00805F2CD064")
MachineDebugManager_RETAIL;
#endif

EXTERN_C const CLSID CLSID_MachineDebugManager_DEBUG;

#ifdef __cplusplus

class DECLSPEC_UUID("49769CEC-3A55-4bb0-B697-88FEDE77E8EA")
MachineDebugManager_DEBUG;
#endif

EXTERN_C const CLSID CLSID_DefaultDebugSessionProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("834128a2-51f4-11d0-8f20-00805f2cd064")
DefaultDebugSessionProvider;
#endif
#endif /* __ProcessDebugManagerLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_activdbg_0000_0059 */
/* [local] */ 


#endif  // __ActivDbg_h



extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0059_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_0059_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* [local] */ HRESULT __stdcall IEnumDebugCodeContexts_Next_Proxy( 
    IEnumDebugCodeContexts * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDebugCodeContext **pscc,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugCodeContexts_Next_Stub( 
    IEnumDebugCodeContexts * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IDebugCodeContext **pscc,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugStackFrames_Next_Proxy( 
    IEnumDebugStackFrames * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugStackFrameDescriptor *prgdsfd,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames_Next_Stub( 
    IEnumDebugStackFrames * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) DebugStackFrameDescriptor *prgdsfd,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugStackFrames64_Next64_Proxy( 
    IEnumDebugStackFrames64 * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugStackFrameDescriptor64 *prgdsfd,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames64_Next64_Stub( 
    IEnumDebugStackFrames64 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) DebugStackFrameDescriptor64 *prgdsfd,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugApplicationNodes_Next_Proxy( 
    IEnumDebugApplicationNodes * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDebugApplicationNode **pprddp,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugApplicationNodes_Next_Stub( 
    IEnumDebugApplicationNodes * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IDebugApplicationNode **pprddp,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumRemoteDebugApplications_Next_Proxy( 
    IEnumRemoteDebugApplications * This,
    /* [in] */ ULONG celt,
    /* [out] */ IRemoteDebugApplication **ppda,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplications_Next_Stub( 
    IEnumRemoteDebugApplications * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IRemoteDebugApplication **ppda,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumRemoteDebugApplicationThreads_Next_Proxy( 
    IEnumRemoteDebugApplicationThreads * This,
    /* [in] */ ULONG celt,
    /* [out] */ IRemoteDebugApplicationThread **pprdat,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplicationThreads_Next_Stub( 
    IEnumRemoteDebugApplicationThreads * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IRemoteDebugApplicationThread **ppdat,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugExpressionContexts_Next_Proxy( 
    IEnumDebugExpressionContexts * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDebugExpressionContext **ppdec,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugExpressionContexts_Next_Stub( 
    IEnumDebugExpressionContexts * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IDebugExpressionContext **pprgdec,
    /* [out] */ __RPC__out ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\compsvcspkg80.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for compsvcspkg80.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __compsvcspkg80_h__
#define __compsvcspkg80_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsComponentEnumeratorFactory3_FWD_DEFINED__
#define __IVsComponentEnumeratorFactory3_FWD_DEFINED__
typedef interface IVsComponentEnumeratorFactory3 IVsComponentEnumeratorFactory3;
#endif 	/* __IVsComponentEnumeratorFactory3_FWD_DEFINED__ */


#ifndef __IVsSmartOpenScope_FWD_DEFINED__
#define __IVsSmartOpenScope_FWD_DEFINED__
typedef interface IVsSmartOpenScope IVsSmartOpenScope;
#endif 	/* __IVsSmartOpenScope_FWD_DEFINED__ */


#ifndef __SVsSmartOpenScope_FWD_DEFINED__
#define __SVsSmartOpenScope_FWD_DEFINED__
typedef interface SVsSmartOpenScope SVsSmartOpenScope;
#endif 	/* __SVsSmartOpenScope_FWD_DEFINED__ */


#ifndef __IVsAssemblyNameUnification_FWD_DEFINED__
#define __IVsAssemblyNameUnification_FWD_DEFINED__
typedef interface IVsAssemblyNameUnification IVsAssemblyNameUnification;
#endif 	/* __IVsAssemblyNameUnification_FWD_DEFINED__ */


#ifndef __SVsAssemblyNameUnification_FWD_DEFINED__
#define __SVsAssemblyNameUnification_FWD_DEFINED__
typedef interface SVsAssemblyNameUnification SVsAssemblyNameUnification;
#endif 	/* __SVsAssemblyNameUnification_FWD_DEFINED__ */


#ifndef __IVsSQLCLRReferencesUpdateCallback_FWD_DEFINED__
#define __IVsSQLCLRReferencesUpdateCallback_FWD_DEFINED__
typedef interface IVsSQLCLRReferencesUpdateCallback IVsSQLCLRReferencesUpdateCallback;
#endif 	/* __IVsSQLCLRReferencesUpdateCallback_FWD_DEFINED__ */


#ifndef __IVsSQLCLRReferences_FWD_DEFINED__
#define __IVsSQLCLRReferences_FWD_DEFINED__
typedef interface IVsSQLCLRReferences IVsSQLCLRReferences;
#endif 	/* __IVsSQLCLRReferences_FWD_DEFINED__ */


#ifndef __SVsSQLCLRReferences_FWD_DEFINED__
#define __SVsSQLCLRReferences_FWD_DEFINED__
typedef interface SVsSQLCLRReferences SVsSQLCLRReferences;
#endif 	/* __SVsSQLCLRReferences_FWD_DEFINED__ */


#ifndef __IVsEnumCryptoProviderContainers_FWD_DEFINED__
#define __IVsEnumCryptoProviderContainers_FWD_DEFINED__
typedef interface IVsEnumCryptoProviderContainers IVsEnumCryptoProviderContainers;
#endif 	/* __IVsEnumCryptoProviderContainers_FWD_DEFINED__ */


#ifndef __IVsEnumCryptoProviders_FWD_DEFINED__
#define __IVsEnumCryptoProviders_FWD_DEFINED__
typedef interface IVsEnumCryptoProviders IVsEnumCryptoProviders;
#endif 	/* __IVsEnumCryptoProviders_FWD_DEFINED__ */


#ifndef __IVsStrongNameKeys_FWD_DEFINED__
#define __IVsStrongNameKeys_FWD_DEFINED__
typedef interface IVsStrongNameKeys IVsStrongNameKeys;
#endif 	/* __IVsStrongNameKeys_FWD_DEFINED__ */


#ifndef __SVsStrongNameKeys_FWD_DEFINED__
#define __SVsStrongNameKeys_FWD_DEFINED__
typedef interface SVsStrongNameKeys SVsStrongNameKeys;
#endif 	/* __SVsStrongNameKeys_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vsshell.h"
#include "compsvcspkg.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_compsvcspkg80_0000_0000 */
/* [local] */ 


enum __VSCOMPENUMEXFLAGS
    {	VSCOMPENUM_IncludeRuntimeInfo	= 0x1
    } ;
typedef DWORD VSCOMPENUMEXFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0000_v0_0_s_ifspec;

#ifndef __IVsComponentEnumeratorFactory3_INTERFACE_DEFINED__
#define __IVsComponentEnumeratorFactory3_INTERFACE_DEFINED__

/* interface IVsComponentEnumeratorFactory3 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsComponentEnumeratorFactory3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C2B582A-DDB2-440c-A777-3D46C3502337")
    IVsComponentEnumeratorFactory3 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetComponentsOfPathEx( 
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [in] */ VSCOMPENUMEXFLAGS grfFlags,
            /* [in] */ __RPC__in BSTR bstrPath,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsComponentEnumeratorFactory3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsComponentEnumeratorFactory3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsComponentEnumeratorFactory3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsComponentEnumeratorFactory3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentsOfPathEx )( 
            IVsComponentEnumeratorFactory3 * This,
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [in] */ VSCOMPENUMEXFLAGS grfFlags,
            /* [in] */ __RPC__in BSTR bstrPath,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator);
        
        END_INTERFACE
    } IVsComponentEnumeratorFactory3Vtbl;

    interface IVsComponentEnumeratorFactory3
    {
        CONST_VTBL struct IVsComponentEnumeratorFactory3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsComponentEnumeratorFactory3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsComponentEnumeratorFactory3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsComponentEnumeratorFactory3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsComponentEnumeratorFactory3_GetComponentsOfPathEx(This,bstrMachineName,lEnumType,bForceRefresh,grfFlags,bstrPath,pEnumerator)	\
    ( (This)->lpVtbl -> GetComponentsOfPathEx(This,bstrMachineName,lEnumType,bForceRefresh,grfFlags,bstrPath,pEnumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsComponentEnumeratorFactory3_INTERFACE_DEFINED__ */


#ifndef __IVsSmartOpenScope_INTERFACE_DEFINED__
#define __IVsSmartOpenScope_INTERFACE_DEFINED__

/* interface IVsSmartOpenScope */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IVsSmartOpenScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("677D16F2-982E-49e6-ACDB-797991764AD8")
    IVsSmartOpenScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenScope( 
            /* [in] */ __RPC__in LPCOLESTR wszScope,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppIUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsSmartOpenScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsSmartOpenScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsSmartOpenScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsSmartOpenScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenScope )( 
            IVsSmartOpenScope * This,
            /* [in] */ __RPC__in LPCOLESTR wszScope,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppIUnk);
        
        END_INTERFACE
    } IVsSmartOpenScopeVtbl;

    interface IVsSmartOpenScope
    {
        CONST_VTBL struct IVsSmartOpenScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsSmartOpenScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsSmartOpenScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsSmartOpenScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsSmartOpenScope_OpenScope(This,wszScope,dwOpenFlags,riid,ppIUnk)	\
    ( (This)->lpVtbl -> OpenScope(This,wszScope,dwOpenFlags,riid,ppIUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsSmartOpenScope_INTERFACE_DEFINED__ */


#ifndef __SVsSmartOpenScope_INTERFACE_DEFINED__
#define __SVsSmartOpenScope_INTERFACE_DEFINED__

/* interface SVsSmartOpenScope */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_SVsSmartOpenScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52F0DAB8-99A9-4aea-A037-42581B7009D2")
    SVsSmartOpenScope : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsSmartOpenScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsSmartOpenScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsSmartOpenScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsSmartOpenScope * This);
        
        END_INTERFACE
    } SVsSmartOpenScopeVtbl;

    interface SVsSmartOpenScope
    {
        CONST_VTBL struct SVsSmartOpenScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsSmartOpenScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsSmartOpenScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsSmartOpenScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsSmartOpenScope_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg80_0000_0003 */
/* [local] */ 

#define SID_SVsSmartOpenScope IID_SVsSmartOpenScope


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0003_v0_0_s_ifspec;

#ifndef __IVsAssemblyNameUnification_INTERFACE_DEFINED__
#define __IVsAssemblyNameUnification_INTERFACE_DEFINED__

/* interface IVsAssemblyNameUnification */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IVsAssemblyNameUnification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F33D7D20-49CE-47a7-9E3B-DCC9DD19AF00")
    IVsAssemblyNameUnification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUnifiedAssemblyName( 
            /* [in] */ __RPC__in LPCOLESTR wszFrameworkDirectory,
            /* [in] */ __RPC__in LPCOLESTR wszSimpleAssemblyName,
            /* [in] */ __RPC__in LPCOLESTR wszFullAssemblyName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUnifiedAssemblyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsAssemblyNameUnificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsAssemblyNameUnification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsAssemblyNameUnification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsAssemblyNameUnification * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnifiedAssemblyName )( 
            IVsAssemblyNameUnification * This,
            /* [in] */ __RPC__in LPCOLESTR wszFrameworkDirectory,
            /* [in] */ __RPC__in LPCOLESTR wszSimpleAssemblyName,
            /* [in] */ __RPC__in LPCOLESTR wszFullAssemblyName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUnifiedAssemblyName);
        
        END_INTERFACE
    } IVsAssemblyNameUnificationVtbl;

    interface IVsAssemblyNameUnification
    {
        CONST_VTBL struct IVsAssemblyNameUnificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsAssemblyNameUnification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsAssemblyNameUnification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsAssemblyNameUnification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsAssemblyNameUnification_GetUnifiedAssemblyName(This,wszFrameworkDirectory,wszSimpleAssemblyName,wszFullAssemblyName,pbstrUnifiedAssemblyName)	\
    ( (This)->lpVtbl -> GetUnifiedAssemblyName(This,wszFrameworkDirectory,wszSimpleAssemblyName,wszFullAssemblyName,pbstrUnifiedAssemblyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsAssemblyNameUnification_INTERFACE_DEFINED__ */


#ifndef __SVsAssemblyNameUnification_INTERFACE_DEFINED__
#define __SVsAssemblyNameUnification_INTERFACE_DEFINED__

/* interface SVsAssemblyNameUnification */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_SVsAssemblyNameUnification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B54B4062-117D-46fc-BE19-CD20F2867D52")
    SVsAssemblyNameUnification : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsAssemblyNameUnificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsAssemblyNameUnification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsAssemblyNameUnification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsAssemblyNameUnification * This);
        
        END_INTERFACE
    } SVsAssemblyNameUnificationVtbl;

    interface SVsAssemblyNameUnification
    {
        CONST_VTBL struct SVsAssemblyNameUnificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsAssemblyNameUnification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsAssemblyNameUnification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsAssemblyNameUnification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsAssemblyNameUnification_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg80_0000_0005 */
/* [local] */ 

#define SID_SVsAssemblyNameUnification IID_SVsAssemblyNameUnification

enum _SqlReferenceUpdateFlags
    {	SqlReferenceUpdateFlags_ForceUpdate	= 1
    } ;
typedef DWORD SqlReferenceUpdateFlags;


enum _SqlAddNewReferenceFlags
    {	SqlAddNewReferenceFlags_DownloadSelected	= 1
    } ;
typedef DWORD SqlAddNewReferenceFlags;


enum _SqlReferenceUpdateAction
    {	SqlReferenceUpdateAction_None	= 1,
	SqlReferenceUpdateAction_Delete	= 2,
	SqlReferenceUpdateAction_Update	= 3
    } ;
typedef DWORD SqlReferenceUpdateAction;



extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0005_v0_0_s_ifspec;

#ifndef __IVsSQLCLRReferencesUpdateCallback_INTERFACE_DEFINED__
#define __IVsSQLCLRReferencesUpdateCallback_INTERFACE_DEFINED__

/* interface IVsSQLCLRReferencesUpdateCallback */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsSQLCLRReferencesUpdateCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E6F344E-52C0-4edc-814B-16C6DE4AE9B4")
    IVsSQLCLRReferencesUpdateCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateResult( 
            /* [in] */ __RPC__in LPCWSTR szAssembly,
            /* [in] */ DWORD dwPermisionLevel,
            /* [in] */ HRESULT hrUpdateResult,
            /* [in] */ __RPC__in_opt IErrorInfo *pErrorInfo,
            /* [in] */ SqlReferenceUpdateAction updateAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsSQLCLRReferencesUpdateCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsSQLCLRReferencesUpdateCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsSQLCLRReferencesUpdateCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsSQLCLRReferencesUpdateCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateResult )( 
            IVsSQLCLRReferencesUpdateCallback * This,
            /* [in] */ __RPC__in LPCWSTR szAssembly,
            /* [in] */ DWORD dwPermisionLevel,
            /* [in] */ HRESULT hrUpdateResult,
            /* [in] */ __RPC__in_opt IErrorInfo *pErrorInfo,
            /* [in] */ SqlReferenceUpdateAction updateAction);
        
        END_INTERFACE
    } IVsSQLCLRReferencesUpdateCallbackVtbl;

    interface IVsSQLCLRReferencesUpdateCallback
    {
        CONST_VTBL struct IVsSQLCLRReferencesUpdateCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsSQLCLRReferencesUpdateCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsSQLCLRReferencesUpdateCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsSQLCLRReferencesUpdateCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsSQLCLRReferencesUpdateCallback_UpdateResult(This,szAssembly,dwPermisionLevel,hrUpdateResult,pErrorInfo,updateAction)	\
    ( (This)->lpVtbl -> UpdateResult(This,szAssembly,dwPermisionLevel,hrUpdateResult,pErrorInfo,updateAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsSQLCLRReferencesUpdateCallback_INTERFACE_DEFINED__ */


#ifndef __IVsSQLCLRReferences_INTERFACE_DEFINED__
#define __IVsSQLCLRReferences_INTERFACE_DEFINED__

/* interface IVsSQLCLRReferences */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsSQLCLRReferences;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E6F344D-52C0-4edc-814B-16C6DE4AE9B4")
    IVsSQLCLRReferences : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeNewReferencesDlg( 
            /* [in] */ __RPC__in_opt IUnknown *pConnection,
            /* [in] */ __RPC__in_opt IUnknown *pAssemblySupport,
            /* [in] */ SqlAddNewReferenceFlags dwAddNewReferenceFlags,
            /* [in] */ __RPC__in LPCWSTR szLocalCache,
            /* [in] */ DWORD dwProjectPermisionLevel,
            /* [in] */ __RPC__in_opt IVsComponentUser *pComponentUserCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateReferences( 
            /* [in] */ __RPC__in_opt IUnknown *pConnection,
            /* [in] */ __RPC__in_opt IUnknown *pAssemblySupport,
            /* [in] */ SqlReferenceUpdateFlags dwReferenceUpdateFlags,
            /* [in] */ ULONG cAssemblyCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cAssemblyCount) LPCWSTR rgszAssemblies[  ],
            /* [in] */ __RPC__in LPCWSTR szLocalCache,
            /* [in] */ DWORD dwProjectPermisionLevel,
            /* [in] */ __RPC__in_opt IVsSQLCLRReferencesUpdateCallback *pCallBack) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsSQLCLRReferencesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsSQLCLRReferences * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsSQLCLRReferences * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsSQLCLRReferences * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeNewReferencesDlg )( 
            IVsSQLCLRReferences * This,
            /* [in] */ __RPC__in_opt IUnknown *pConnection,
            /* [in] */ __RPC__in_opt IUnknown *pAssemblySupport,
            /* [in] */ SqlAddNewReferenceFlags dwAddNewReferenceFlags,
            /* [in] */ __RPC__in LPCWSTR szLocalCache,
            /* [in] */ DWORD dwProjectPermisionLevel,
            /* [in] */ __RPC__in_opt IVsComponentUser *pComponentUserCallback);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateReferences )( 
            IVsSQLCLRReferences * This,
            /* [in] */ __RPC__in_opt IUnknown *pConnection,
            /* [in] */ __RPC__in_opt IUnknown *pAssemblySupport,
            /* [in] */ SqlReferenceUpdateFlags dwReferenceUpdateFlags,
            /* [in] */ ULONG cAssemblyCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cAssemblyCount) LPCWSTR rgszAssemblies[  ],
            /* [in] */ __RPC__in LPCWSTR szLocalCache,
            /* [in] */ DWORD dwProjectPermisionLevel,
            /* [in] */ __RPC__in_opt IVsSQLCLRReferencesUpdateCallback *pCallBack);
        
        END_INTERFACE
    } IVsSQLCLRReferencesVtbl;

    interface IVsSQLCLRReferences
    {
        CONST_VTBL struct IVsSQLCLRReferencesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsSQLCLRReferences_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsSQLCLRReferences_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsSQLCLRReferences_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsSQLCLRReferences_InvokeNewReferencesDlg(This,pConnection,pAssemblySupport,dwAddNewReferenceFlags,szLocalCache,dwProjectPermisionLevel,pComponentUserCallback)	\
    ( (This)->lpVtbl -> InvokeNewReferencesDlg(This,pConnection,pAssemblySupport,dwAddNewReferenceFlags,szLocalCache,dwProjectPermisionLevel,pComponentUserCallback) ) 

#define IVsSQLCLRReferences_UpdateReferences(This,pConnection,pAssemblySupport,dwReferenceUpdateFlags,cAssemblyCount,rgszAssemblies,szLocalCache,dwProjectPermisionLevel,pCallBack)	\
    ( (This)->lpVtbl -> UpdateReferences(This,pConnection,pAssemblySupport,dwReferenceUpdateFlags,cAssemblyCount,rgszAssemblies,szLocalCache,dwProjectPermisionLevel,pCallBack) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsSQLCLRReferences_INTERFACE_DEFINED__ */


#ifndef __SVsSQLCLRReferences_INTERFACE_DEFINED__
#define __SVsSQLCLRReferences_INTERFACE_DEFINED__

/* interface SVsSQLCLRReferences */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsSQLCLRReferences;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ED9966C-102F-45b0-8293-BB9F2463A6F2")
    SVsSQLCLRReferences : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsSQLCLRReferencesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsSQLCLRReferences * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsSQLCLRReferences * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsSQLCLRReferences * This);
        
        END_INTERFACE
    } SVsSQLCLRReferencesVtbl;

    interface SVsSQLCLRReferences
    {
        CONST_VTBL struct SVsSQLCLRReferencesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsSQLCLRReferences_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsSQLCLRReferences_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsSQLCLRReferences_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsSQLCLRReferences_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg80_0000_0008 */
/* [local] */ 

#define SID_SVsSQLCLRReferences IID_SVsSQLCLRReferences


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0008_v0_0_s_ifspec;

#ifndef __IVsEnumCryptoProviderContainers_INTERFACE_DEFINED__
#define __IVsEnumCryptoProviderContainers_INTERFACE_DEFINED__

/* interface IVsEnumCryptoProviderContainers */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsEnumCryptoProviderContainers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("af855397-c4dc-478b-abd4-c3dbb3759e72")
    IVsEnumCryptoProviderContainers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) BSTR *pbstrContainers,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsEnumCryptoProviderContainersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsEnumCryptoProviderContainers * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsEnumCryptoProviderContainers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsEnumCryptoProviderContainers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IVsEnumCryptoProviderContainers * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) BSTR *pbstrContainers,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IVsEnumCryptoProviderContainers * This);
        
        END_INTERFACE
    } IVsEnumCryptoProviderContainersVtbl;

    interface IVsEnumCryptoProviderContainers
    {
        CONST_VTBL struct IVsEnumCryptoProviderContainersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsEnumCryptoProviderContainers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsEnumCryptoProviderContainers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsEnumCryptoProviderContainers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsEnumCryptoProviderContainers_Next(This,celt,pbstrContainers,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pbstrContainers,pceltFetched) ) 

#define IVsEnumCryptoProviderContainers_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsEnumCryptoProviderContainers_INTERFACE_DEFINED__ */


#ifndef __IVsEnumCryptoProviders_INTERFACE_DEFINED__
#define __IVsEnumCryptoProviders_INTERFACE_DEFINED__

/* interface IVsEnumCryptoProviders */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsEnumCryptoProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7fc33a9-10da-42be-9f88-9700e583ec33")
    IVsEnumCryptoProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) BSTR *pbstrProviders,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsEnumCryptoProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsEnumCryptoProviders * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsEnumCryptoProviders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsEnumCryptoProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IVsEnumCryptoProviders * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) BSTR *pbstrProviders,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IVsEnumCryptoProviders * This);
        
        END_INTERFACE
    } IVsEnumCryptoProvidersVtbl;

    interface IVsEnumCryptoProviders
    {
        CONST_VTBL struct IVsEnumCryptoProvidersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsEnumCryptoProviders_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsEnumCryptoProviders_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsEnumCryptoProviders_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsEnumCryptoProviders_Next(This,celt,pbstrProviders,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pbstrProviders,pceltFetched) ) 

#define IVsEnumCryptoProviders_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsEnumCryptoProviders_INTERFACE_DEFINED__ */


#ifndef __IVsStrongNameKeys_INTERFACE_DEFINED__
#define __IVsStrongNameKeys_INTERFACE_DEFINED__

/* interface IVsStrongNameKeys */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsStrongNameKeys;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b0de8148-dabc-4ab9-b418-413e63df6e6c")
    IVsStrongNameKeys : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumProviders( 
            /* [out] */ __RPC__deref_out_opt IVsEnumCryptoProviders **ppEnumProviders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContainers( 
            /* [in] */ __RPC__in LPCOLESTR szProvider,
            /* [out] */ __RPC__deref_out_opt IVsEnumCryptoProviderContainers **ppEnumContainers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewKey( 
            /* [in] */ __RPC__in LPCOLESTR szFileLocation,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewKeyNoUI( 
            /* [in] */ __RPC__in LPCOLESTR szFile,
            /* [in] */ __RPC__in LPCOLESTR szPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewKeyWithName( 
            /* [in] */ __RPC__in LPCOLESTR szFile,
            /* [in] */ __RPC__in LPCOLESTR szPassword,
            /* [in] */ __RPC__in LPCOLESTR szSubjectName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportKeyFromPFX( 
            /* [in] */ __RPC__in LPCOLESTR szFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContainerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePassword( 
            /* [in] */ __RPC__in LPCOLESTR szPfxFile,
            /* [in] */ __RPC__in LPCOLESTR szOldPassword,
            /* [in] */ __RPC__in LPCOLESTR szNewPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsStrongNameKeysVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsStrongNameKeys * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsStrongNameKeys * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProviders )( 
            IVsStrongNameKeys * This,
            /* [out] */ __RPC__deref_out_opt IVsEnumCryptoProviders **ppEnumProviders);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContainers )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in LPCOLESTR szProvider,
            /* [out] */ __RPC__deref_out_opt IVsEnumCryptoProviderContainers **ppEnumContainers);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewKey )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in LPCOLESTR szFileLocation,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewKeyNoUI )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in LPCOLESTR szFile,
            /* [in] */ __RPC__in LPCOLESTR szPassword);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewKeyWithName )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in LPCOLESTR szFile,
            /* [in] */ __RPC__in LPCOLESTR szPassword,
            /* [in] */ __RPC__in LPCOLESTR szSubjectName);
        
        HRESULT ( STDMETHODCALLTYPE *ImportKeyFromPFX )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in LPCOLESTR szFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContainerName);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePassword )( 
            IVsStrongNameKeys * This,
            /* [in] */ __RPC__in LPCOLESTR szPfxFile,
            /* [in] */ __RPC__in LPCOLESTR szOldPassword,
            /* [in] */ __RPC__in LPCOLESTR szNewPassword);
        
        END_INTERFACE
    } IVsStrongNameKeysVtbl;

    interface IVsStrongNameKeys
    {
        CONST_VTBL struct IVsStrongNameKeysVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsStrongNameKeys_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsStrongNameKeys_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsStrongNameKeys_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsStrongNameKeys_EnumProviders(This,ppEnumProviders)	\
    ( (This)->lpVtbl -> EnumProviders(This,ppEnumProviders) ) 

#define IVsStrongNameKeys_EnumContainers(This,szProvider,ppEnumContainers)	\
    ( (This)->lpVtbl -> EnumContainers(This,szProvider,ppEnumContainers) ) 

#define IVsStrongNameKeys_CreateNewKey(This,szFileLocation,pbstrFileName)	\
    ( (This)->lpVtbl -> CreateNewKey(This,szFileLocation,pbstrFileName) ) 

#define IVsStrongNameKeys_CreateNewKeyNoUI(This,szFile,szPassword)	\
    ( (This)->lpVtbl -> CreateNewKeyNoUI(This,szFile,szPassword) ) 

#define IVsStrongNameKeys_CreateNewKeyWithName(This,szFile,szPassword,szSubjectName)	\
    ( (This)->lpVtbl -> CreateNewKeyWithName(This,szFile,szPassword,szSubjectName) ) 

#define IVsStrongNameKeys_ImportKeyFromPFX(This,szFile,pbstrContainerName)	\
    ( (This)->lpVtbl -> ImportKeyFromPFX(This,szFile,pbstrContainerName) ) 

#define IVsStrongNameKeys_ChangePassword(This,szPfxFile,szOldPassword,szNewPassword)	\
    ( (This)->lpVtbl -> ChangePassword(This,szPfxFile,szOldPassword,szNewPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsStrongNameKeys_INTERFACE_DEFINED__ */


#ifndef __SVsStrongNameKeys_INTERFACE_DEFINED__
#define __SVsStrongNameKeys_INTERFACE_DEFINED__

/* interface SVsStrongNameKeys */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsStrongNameKeys;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97BAE668-2CF2-4ed8-A019-D279E3D74C80")
    SVsStrongNameKeys : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsStrongNameKeysVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsStrongNameKeys * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsStrongNameKeys * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsStrongNameKeys * This);
        
        END_INTERFACE
    } SVsStrongNameKeysVtbl;

    interface SVsStrongNameKeys
    {
        CONST_VTBL struct SVsStrongNameKeysVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsStrongNameKeys_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsStrongNameKeys_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsStrongNameKeys_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsStrongNameKeys_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg80_0000_0012 */
/* [local] */ 

#define SID_SVsStrongNameKeys IID_SVsStrongNameKeys


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg80_0000_0012_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\compsvcspkg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for compsvcspkg.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __compsvcspkg_h__
#define __compsvcspkg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsAddWebReferenceDlg_FWD_DEFINED__
#define __IVsAddWebReferenceDlg_FWD_DEFINED__
typedef interface IVsAddWebReferenceDlg IVsAddWebReferenceDlg;
#endif 	/* __IVsAddWebReferenceDlg_FWD_DEFINED__ */


#ifndef __IVsAddWebReferenceDlg2_FWD_DEFINED__
#define __IVsAddWebReferenceDlg2_FWD_DEFINED__
typedef interface IVsAddWebReferenceDlg2 IVsAddWebReferenceDlg2;
#endif 	/* __IVsAddWebReferenceDlg2_FWD_DEFINED__ */


#ifndef __IEnumComponents_FWD_DEFINED__
#define __IEnumComponents_FWD_DEFINED__
typedef interface IEnumComponents IEnumComponents;
#endif 	/* __IEnumComponents_FWD_DEFINED__ */


#ifndef __IVsComponentSelectorData_FWD_DEFINED__
#define __IVsComponentSelectorData_FWD_DEFINED__
typedef interface IVsComponentSelectorData IVsComponentSelectorData;
#endif 	/* __IVsComponentSelectorData_FWD_DEFINED__ */


#ifndef __IVsComponentEnumeratorFactory_FWD_DEFINED__
#define __IVsComponentEnumeratorFactory_FWD_DEFINED__
typedef interface IVsComponentEnumeratorFactory IVsComponentEnumeratorFactory;
#endif 	/* __IVsComponentEnumeratorFactory_FWD_DEFINED__ */


#ifndef __IVsComponentEnumeratorFactory2_FWD_DEFINED__
#define __IVsComponentEnumeratorFactory2_FWD_DEFINED__
typedef interface IVsComponentEnumeratorFactory2 IVsComponentEnumeratorFactory2;
#endif 	/* __IVsComponentEnumeratorFactory2_FWD_DEFINED__ */


#ifndef __IVsProvideComponentEnumeration_FWD_DEFINED__
#define __IVsProvideComponentEnumeration_FWD_DEFINED__
typedef interface IVsProvideComponentEnumeration IVsProvideComponentEnumeration;
#endif 	/* __IVsProvideComponentEnumeration_FWD_DEFINED__ */


#ifndef __CCompServicesPackage_FWD_DEFINED__
#define __CCompServicesPackage_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCompServicesPackage CCompServicesPackage;
#else
typedef struct CCompServicesPackage CCompServicesPackage;
#endif /* __cplusplus */

#endif 	/* __CCompServicesPackage_FWD_DEFINED__ */


#ifndef __CCom2Enumerator_FWD_DEFINED__
#define __CCom2Enumerator_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCom2Enumerator CCom2Enumerator;
#else
typedef struct CCom2Enumerator CCom2Enumerator;
#endif /* __cplusplus */

#endif 	/* __CCom2Enumerator_FWD_DEFINED__ */


#ifndef __CComPlusEnumerator_FWD_DEFINED__
#define __CComPlusEnumerator_FWD_DEFINED__

#ifdef __cplusplus
typedef class CComPlusEnumerator CComPlusEnumerator;
#else
typedef struct CComPlusEnumerator CComPlusEnumerator;
#endif /* __cplusplus */

#endif 	/* __CComPlusEnumerator_FWD_DEFINED__ */


#ifndef __IVsTypeLibraryWrapperCallback_FWD_DEFINED__
#define __IVsTypeLibraryWrapperCallback_FWD_DEFINED__
typedef interface IVsTypeLibraryWrapperCallback IVsTypeLibraryWrapperCallback;
#endif 	/* __IVsTypeLibraryWrapperCallback_FWD_DEFINED__ */


#ifndef __IVsTypeLibraryWrapper_FWD_DEFINED__
#define __IVsTypeLibraryWrapper_FWD_DEFINED__
typedef interface IVsTypeLibraryWrapper IVsTypeLibraryWrapper;
#endif 	/* __IVsTypeLibraryWrapper_FWD_DEFINED__ */


#ifndef __VSPIAImporter_FWD_DEFINED__
#define __VSPIAImporter_FWD_DEFINED__

#ifdef __cplusplus
typedef class VSPIAImporter VSPIAImporter;
#else
typedef struct VSPIAImporter VSPIAImporter;
#endif /* __cplusplus */

#endif 	/* __VSPIAImporter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vsshell.h"
#include "discoveryservice.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_compsvcspkg_0000_0000 */
/* [local] */ 


enum CompEnum
    {	CompEnumType_COM2	= 100,
	CompEnumType_COMPlus	= ( CompEnumType_COM2 + 1 ) ,
	CompEnumType_AssemblyPaths	= ( CompEnumType_COMPlus + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg_0000_0000_v0_0_s_ifspec;

#ifndef __IVsAddWebReferenceDlg_INTERFACE_DEFINED__
#define __IVsAddWebReferenceDlg_INTERFACE_DEFINED__

/* interface IVsAddWebReferenceDlg */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsAddWebReferenceDlg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BD71396F-39C6-4e3f-BBA2-79CE33A8B302")
    IVsAddWebReferenceDlg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddWebReferenceDlg( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWebReferenceUrl,
            /* [out] */ __RPC__out BOOL *pfCancelled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsAddWebReferenceDlgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsAddWebReferenceDlg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsAddWebReferenceDlg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsAddWebReferenceDlg * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddWebReferenceDlg )( 
            IVsAddWebReferenceDlg * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWebReferenceUrl,
            /* [out] */ __RPC__out BOOL *pfCancelled);
        
        END_INTERFACE
    } IVsAddWebReferenceDlgVtbl;

    interface IVsAddWebReferenceDlg
    {
        CONST_VTBL struct IVsAddWebReferenceDlgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsAddWebReferenceDlg_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsAddWebReferenceDlg_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsAddWebReferenceDlg_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsAddWebReferenceDlg_AddWebReferenceDlg(This,pbstrWebReferenceUrl,pfCancelled)	\
    ( (This)->lpVtbl -> AddWebReferenceDlg(This,pbstrWebReferenceUrl,pfCancelled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsAddWebReferenceDlg_INTERFACE_DEFINED__ */


#ifndef __IVsAddWebReferenceDlg2_INTERFACE_DEFINED__
#define __IVsAddWebReferenceDlg2_INTERFACE_DEFINED__

/* interface IVsAddWebReferenceDlg2 */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsAddWebReferenceDlg2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE037B96-A8D1-4961-A3F3-E969094BA978")
    IVsAddWebReferenceDlg2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddWebReferenceDlg( 
            /* [in] */ __RPC__in_opt IDiscoverySession *pDiscoverySession,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWebReferenceUrl,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWebReferenceName,
            /* [out] */ __RPC__deref_out_opt IDiscoveryResult **ppIDiscoveryResult,
            /* [out] */ __RPC__out BOOL *pfCancelled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsAddWebReferenceDlg2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsAddWebReferenceDlg2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsAddWebReferenceDlg2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsAddWebReferenceDlg2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddWebReferenceDlg )( 
            IVsAddWebReferenceDlg2 * This,
            /* [in] */ __RPC__in_opt IDiscoverySession *pDiscoverySession,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWebReferenceUrl,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWebReferenceName,
            /* [out] */ __RPC__deref_out_opt IDiscoveryResult **ppIDiscoveryResult,
            /* [out] */ __RPC__out BOOL *pfCancelled);
        
        END_INTERFACE
    } IVsAddWebReferenceDlg2Vtbl;

    interface IVsAddWebReferenceDlg2
    {
        CONST_VTBL struct IVsAddWebReferenceDlg2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsAddWebReferenceDlg2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsAddWebReferenceDlg2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsAddWebReferenceDlg2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsAddWebReferenceDlg2_AddWebReferenceDlg(This,pDiscoverySession,pbstrWebReferenceUrl,pbstrWebReferenceName,ppIDiscoveryResult,pfCancelled)	\
    ( (This)->lpVtbl -> AddWebReferenceDlg(This,pDiscoverySession,pbstrWebReferenceUrl,pbstrWebReferenceName,ppIDiscoveryResult,pfCancelled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsAddWebReferenceDlg2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg_0000_0002 */
/* [local] */ 

#define SID_SVsAddWebReferenceDlg IID_IVsAddWebReferenceDlg


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg_0000_0002_v0_0_s_ifspec;

#ifndef __IEnumComponents_INTERFACE_DEFINED__
#define __IEnumComponents_INTERFACE_DEFINED__

/* interface IEnumComponents */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumComponents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9a04b730-656c-11d3-85fc-00c04f6123b3")
    IEnumComponents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VSCOMPONENTSELECTORDATA *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumComponents **ppIEnumComponents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumComponentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumComponents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumComponents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumComponents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumComponents * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VSCOMPONENTSELECTORDATA *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumComponents * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumComponents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumComponents * This,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **ppIEnumComponents);
        
        END_INTERFACE
    } IEnumComponentsVtbl;

    interface IEnumComponents
    {
        CONST_VTBL struct IEnumComponentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumComponents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumComponents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumComponents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumComponents_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumComponents_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumComponents_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumComponents_Clone(This,ppIEnumComponents)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumComponents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumComponents_INTERFACE_DEFINED__ */


#ifndef __IVsComponentSelectorData_INTERFACE_DEFINED__
#define __IVsComponentSelectorData_INTERFACE_DEFINED__

/* interface IVsComponentSelectorData */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsComponentSelectorData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45bd8e74-6727-11d3-8600-00c04f6123b3")
    IVsComponentSelectorData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ __RPC__out VSCOMPONENTSELECTORDATA *pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsComponentSelectorDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsComponentSelectorData * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsComponentSelectorData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsComponentSelectorData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IVsComponentSelectorData * This,
            /* [out] */ __RPC__out VSCOMPONENTSELECTORDATA *pData);
        
        END_INTERFACE
    } IVsComponentSelectorDataVtbl;

    interface IVsComponentSelectorData
    {
        CONST_VTBL struct IVsComponentSelectorDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsComponentSelectorData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsComponentSelectorData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsComponentSelectorData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsComponentSelectorData_GetData(This,pData)	\
    ( (This)->lpVtbl -> GetData(This,pData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsComponentSelectorData_INTERFACE_DEFINED__ */


#ifndef __IVsComponentEnumeratorFactory_INTERFACE_DEFINED__
#define __IVsComponentEnumeratorFactory_INTERFACE_DEFINED__

/* interface IVsComponentEnumeratorFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsComponentEnumeratorFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("332cedee-6610-11d3-85fd-00c04f6123b3")
    IVsComponentEnumeratorFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetComponents( 
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsComponentEnumeratorFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsComponentEnumeratorFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsComponentEnumeratorFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsComponentEnumeratorFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponents )( 
            IVsComponentEnumeratorFactory * This,
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator);
        
        END_INTERFACE
    } IVsComponentEnumeratorFactoryVtbl;

    interface IVsComponentEnumeratorFactory
    {
        CONST_VTBL struct IVsComponentEnumeratorFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsComponentEnumeratorFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsComponentEnumeratorFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsComponentEnumeratorFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsComponentEnumeratorFactory_GetComponents(This,bstrMachineName,lEnumType,bForceRefresh,pEnumerator)	\
    ( (This)->lpVtbl -> GetComponents(This,bstrMachineName,lEnumType,bForceRefresh,pEnumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsComponentEnumeratorFactory_INTERFACE_DEFINED__ */


#ifndef __IVsComponentEnumeratorFactory2_INTERFACE_DEFINED__
#define __IVsComponentEnumeratorFactory2_INTERFACE_DEFINED__

/* interface IVsComponentEnumeratorFactory2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsComponentEnumeratorFactory2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64F6B8C1-3DEC-4606-8C8C-651A7E26A3DE")
    IVsComponentEnumeratorFactory2 : public IVsComponentEnumeratorFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetComponentsOfPath( 
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [in] */ __RPC__in BSTR bstrPath,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsComponentEnumeratorFactory2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsComponentEnumeratorFactory2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsComponentEnumeratorFactory2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsComponentEnumeratorFactory2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponents )( 
            IVsComponentEnumeratorFactory2 * This,
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentsOfPath )( 
            IVsComponentEnumeratorFactory2 * This,
            /* [in] */ __RPC__in BSTR bstrMachineName,
            /* [in] */ LONG lEnumType,
            /* [in] */ BOOL bForceRefresh,
            /* [in] */ __RPC__in BSTR bstrPath,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **pEnumerator);
        
        END_INTERFACE
    } IVsComponentEnumeratorFactory2Vtbl;

    interface IVsComponentEnumeratorFactory2
    {
        CONST_VTBL struct IVsComponentEnumeratorFactory2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsComponentEnumeratorFactory2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsComponentEnumeratorFactory2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsComponentEnumeratorFactory2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsComponentEnumeratorFactory2_GetComponents(This,bstrMachineName,lEnumType,bForceRefresh,pEnumerator)	\
    ( (This)->lpVtbl -> GetComponents(This,bstrMachineName,lEnumType,bForceRefresh,pEnumerator) ) 


#define IVsComponentEnumeratorFactory2_GetComponentsOfPath(This,bstrMachineName,lEnumType,bForceRefresh,bstrPath,pEnumerator)	\
    ( (This)->lpVtbl -> GetComponentsOfPath(This,bstrMachineName,lEnumType,bForceRefresh,bstrPath,pEnumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsComponentEnumeratorFactory2_INTERFACE_DEFINED__ */


#ifndef __IVsProvideComponentEnumeration_INTERFACE_DEFINED__
#define __IVsProvideComponentEnumeration_INTERFACE_DEFINED__

/* interface IVsProvideComponentEnumeration */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsProvideComponentEnumeration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4df7bba0-660f-11d3-85fd-00c04f6123b3")
    IVsProvideComponentEnumeration : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WriteXMLToFile( 
            /* [in] */ __RPC__in BSTR bstrDesiredFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrActualFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsProvideComponentEnumerationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsProvideComponentEnumeration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsProvideComponentEnumeration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsProvideComponentEnumeration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVsProvideComponentEnumeration * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVsProvideComponentEnumeration * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVsProvideComponentEnumeration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVsProvideComponentEnumeration * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *WriteXMLToFile )( 
            IVsProvideComponentEnumeration * This,
            /* [in] */ __RPC__in BSTR bstrDesiredFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrActualFile);
        
        END_INTERFACE
    } IVsProvideComponentEnumerationVtbl;

    interface IVsProvideComponentEnumeration
    {
        CONST_VTBL struct IVsProvideComponentEnumerationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsProvideComponentEnumeration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsProvideComponentEnumeration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsProvideComponentEnumeration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsProvideComponentEnumeration_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVsProvideComponentEnumeration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVsProvideComponentEnumeration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVsProvideComponentEnumeration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVsProvideComponentEnumeration_WriteXMLToFile(This,bstrDesiredFile,pbstrActualFile)	\
    ( (This)->lpVtbl -> WriteXMLToFile(This,bstrDesiredFile,pbstrActualFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsProvideComponentEnumeration_INTERFACE_DEFINED__ */



#ifndef __CompServicesLib_LIBRARY_DEFINED__
#define __CompServicesLib_LIBRARY_DEFINED__

/* library CompServicesLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CompServicesLib;

EXTERN_C const CLSID CLSID_CCompServicesPackage;

#ifdef __cplusplus

class DECLSPEC_UUID("588205e0-66e0-11d3-8600-00c04f6123b3")
CCompServicesPackage;
#endif

EXTERN_C const CLSID CLSID_CCom2Enumerator;

#ifdef __cplusplus

class DECLSPEC_UUID("3129723e-660f-11d3-85fd-00c04f6123b3")
CCom2Enumerator;
#endif

EXTERN_C const CLSID CLSID_CComPlusEnumerator;

#ifdef __cplusplus

class DECLSPEC_UUID("f5bd4a64-67a2-11d3-8600-00c04f6123b3")
CComPlusEnumerator;
#endif
#endif /* __CompServicesLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_compsvcspkg_0000_0007 */
/* [local] */ 

const IID SID_SCompEnumService = { 0x33a24090, 0x6565, 0x11d3, 0x85, 0xfc, 0x00, 0xc0, 0x4f, 0x61, 0x23, 0xb3 }; 


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg_0000_0007_v0_0_s_ifspec;

#ifndef __IVsTypeLibraryWrapperCallback_INTERFACE_DEFINED__
#define __IVsTypeLibraryWrapperCallback_INTERFACE_DEFINED__

/* interface IVsTypeLibraryWrapperCallback */
/* [object][restricted][hidden][uuid] */ 


EXTERN_C const IID IID_IVsTypeLibraryWrapperCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AFF2B95E-229B-4A14-A422-E99452AD2F8C")
    IVsTypeLibraryWrapperCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssembly( 
            /* [in] */ __RPC__in LPCOLESTR wszFusionName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComClassic( 
            /* [in] */ __RPC__in TLIBATTR *pTypeLibAttr,
            /* [in] */ __RPC__in LPCOLESTR wszWrapperTool,
            /* [out] */ __RPC__out BOOL *pDelaySigned,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWrapperTool,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComClassicByTypeLibName( 
            /* [in] */ __RPC__in LPCOLESTR wszTypeLibName,
            /* [out] */ __RPC__out TLIBATTR *pTypeLibAttr,
            /* [out] */ __RPC__out BOOL *pDelaySigned,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWrapperTool,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsTypeLibraryWrapperCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsTypeLibraryWrapperCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsTypeLibraryWrapperCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsTypeLibraryWrapperCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssembly )( 
            IVsTypeLibraryWrapperCallback * This,
            /* [in] */ __RPC__in LPCOLESTR wszFusionName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetComClassic )( 
            IVsTypeLibraryWrapperCallback * This,
            /* [in] */ __RPC__in TLIBATTR *pTypeLibAttr,
            /* [in] */ __RPC__in LPCOLESTR wszWrapperTool,
            /* [out] */ __RPC__out BOOL *pDelaySigned,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWrapperTool,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetComClassicByTypeLibName )( 
            IVsTypeLibraryWrapperCallback * This,
            /* [in] */ __RPC__in LPCOLESTR wszTypeLibName,
            /* [out] */ __RPC__out TLIBATTR *pTypeLibAttr,
            /* [out] */ __RPC__out BOOL *pDelaySigned,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrWrapperTool,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPath);
        
        END_INTERFACE
    } IVsTypeLibraryWrapperCallbackVtbl;

    interface IVsTypeLibraryWrapperCallback
    {
        CONST_VTBL struct IVsTypeLibraryWrapperCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsTypeLibraryWrapperCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsTypeLibraryWrapperCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsTypeLibraryWrapperCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsTypeLibraryWrapperCallback_GetAssembly(This,wszFusionName,pbstrPath)	\
    ( (This)->lpVtbl -> GetAssembly(This,wszFusionName,pbstrPath) ) 

#define IVsTypeLibraryWrapperCallback_GetComClassic(This,pTypeLibAttr,wszWrapperTool,pDelaySigned,pbstrWrapperTool,pbstrPath)	\
    ( (This)->lpVtbl -> GetComClassic(This,pTypeLibAttr,wszWrapperTool,pDelaySigned,pbstrWrapperTool,pbstrPath) ) 

#define IVsTypeLibraryWrapperCallback_GetComClassicByTypeLibName(This,wszTypeLibName,pTypeLibAttr,pDelaySigned,pbstrWrapperTool,pbstrPath)	\
    ( (This)->lpVtbl -> GetComClassicByTypeLibName(This,wszTypeLibName,pTypeLibAttr,pDelaySigned,pbstrWrapperTool,pbstrPath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsTypeLibraryWrapperCallback_INTERFACE_DEFINED__ */


#ifndef __IVsTypeLibraryWrapper_INTERFACE_DEFINED__
#define __IVsTypeLibraryWrapper_INTERFACE_DEFINED__

/* interface IVsTypeLibraryWrapper */
/* [object][restricted][hidden][uuid] */ 


EXTERN_C const IID IID_IVsTypeLibraryWrapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6065B70-C9B6-4636-80F5-1CF92D7ECE5B")
    IVsTypeLibraryWrapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WrapTypeLibrary( 
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [in] */ __RPC__in LPCOLESTR wszDestinationDirectory,
            /* [in] */ __RPC__in LPCOLESTR wszKeyFile,
            /* [in] */ __RPC__in LPCOLESTR wszKeyContainer,
            /* [in] */ BOOL bDelaySign,
            /* [in] */ __RPC__in_opt IVsTypeLibraryWrapperCallback *pCallback,
            /* [out] */ __RPC__deref_out_opt BSTR **rgbstrWrapperPaths,
            /* [out] */ __RPC__deref_out_opt TLIBATTR **rgWrappedTypeLibs,
            /* [out] */ __RPC__deref_out_opt BOOL **rgbGenerated,
            /* [out] */ __RPC__deref_out_opt BSTR **rgbstrWrapperTools,
            /* [out] */ __RPC__out ULONG *pcWrappedTypeLibs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMainWrapperFilename( 
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsRegeneration( 
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [in] */ __RPC__in LPCOLESTR wszKeyFile,
            /* [in] */ __RPC__in LPCOLESTR wszKeyContainerName,
            /* [in] */ BOOL bDelaySign,
            /* [in] */ BOOL bCurrentlyDelaySigned,
            /* [in] */ __RPC__in LPCOLESTR wszExistingWrapperFilename,
            /* [retval][out] */ __RPC__out BOOL *pbNeedsRegeneration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMainWrapperFriendlyName( 
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsTypeLibraryWrapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsTypeLibraryWrapper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsTypeLibraryWrapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsTypeLibraryWrapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *WrapTypeLibrary )( 
            IVsTypeLibraryWrapper * This,
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [in] */ __RPC__in LPCOLESTR wszDestinationDirectory,
            /* [in] */ __RPC__in LPCOLESTR wszKeyFile,
            /* [in] */ __RPC__in LPCOLESTR wszKeyContainer,
            /* [in] */ BOOL bDelaySign,
            /* [in] */ __RPC__in_opt IVsTypeLibraryWrapperCallback *pCallback,
            /* [out] */ __RPC__deref_out_opt BSTR **rgbstrWrapperPaths,
            /* [out] */ __RPC__deref_out_opt TLIBATTR **rgWrappedTypeLibs,
            /* [out] */ __RPC__deref_out_opt BOOL **rgbGenerated,
            /* [out] */ __RPC__deref_out_opt BSTR **rgbstrWrapperTools,
            /* [out] */ __RPC__out ULONG *pcWrappedTypeLibs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMainWrapperFilename )( 
            IVsTypeLibraryWrapper * This,
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsRegeneration )( 
            IVsTypeLibraryWrapper * This,
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [in] */ __RPC__in LPCOLESTR wszKeyFile,
            /* [in] */ __RPC__in LPCOLESTR wszKeyContainerName,
            /* [in] */ BOOL bDelaySign,
            /* [in] */ BOOL bCurrentlyDelaySigned,
            /* [in] */ __RPC__in LPCOLESTR wszExistingWrapperFilename,
            /* [retval][out] */ __RPC__out BOOL *pbNeedsRegeneration);
        
        HRESULT ( STDMETHODCALLTYPE *GetMainWrapperFriendlyName )( 
            IVsTypeLibraryWrapper * This,
            /* [in] */ __RPC__in TLIBATTR *pTypeLibToWrap,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFileName);
        
        END_INTERFACE
    } IVsTypeLibraryWrapperVtbl;

    interface IVsTypeLibraryWrapper
    {
        CONST_VTBL struct IVsTypeLibraryWrapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsTypeLibraryWrapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsTypeLibraryWrapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsTypeLibraryWrapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsTypeLibraryWrapper_WrapTypeLibrary(This,pTypeLibToWrap,wszDestinationDirectory,wszKeyFile,wszKeyContainer,bDelaySign,pCallback,rgbstrWrapperPaths,rgWrappedTypeLibs,rgbGenerated,rgbstrWrapperTools,pcWrappedTypeLibs)	\
    ( (This)->lpVtbl -> WrapTypeLibrary(This,pTypeLibToWrap,wszDestinationDirectory,wszKeyFile,wszKeyContainer,bDelaySign,pCallback,rgbstrWrapperPaths,rgWrappedTypeLibs,rgbGenerated,rgbstrWrapperTools,pcWrappedTypeLibs) ) 

#define IVsTypeLibraryWrapper_GetMainWrapperFilename(This,pTypeLibToWrap,pbstrFileName)	\
    ( (This)->lpVtbl -> GetMainWrapperFilename(This,pTypeLibToWrap,pbstrFileName) ) 

#define IVsTypeLibraryWrapper_NeedsRegeneration(This,pTypeLibToWrap,wszKeyFile,wszKeyContainerName,bDelaySign,bCurrentlyDelaySigned,wszExistingWrapperFilename,pbNeedsRegeneration)	\
    ( (This)->lpVtbl -> NeedsRegeneration(This,pTypeLibToWrap,wszKeyFile,wszKeyContainerName,bDelaySign,bCurrentlyDelaySigned,wszExistingWrapperFilename,pbNeedsRegeneration) ) 

#define IVsTypeLibraryWrapper_GetMainWrapperFriendlyName(This,pTypeLibToWrap,pbstrFileName)	\
    ( (This)->lpVtbl -> GetMainWrapperFriendlyName(This,pTypeLibToWrap,pbstrFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsTypeLibraryWrapper_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\completionuuids.h ===
#pragma once

#define uuid_IVsCommandWindowCompletion          34896BBB-A3D5-4c80-BCCE-E9271BEEDC11
#define uuid_IVsImmediateStatementCompletion     5CE7AE60-7B66-4301-8892-90BC0B49A89B
#define uuid_IVsImmediateStatementCompletion2    58F03D6E-F781-4e44-BD88-3BDE817CBDCD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\compsvcspkg90.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for compsvcspkg90.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __compsvcspkg90_h__
#define __compsvcspkg90_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumTargetFrameworks_FWD_DEFINED__
#define __IEnumTargetFrameworks_FWD_DEFINED__
typedef interface IEnumTargetFrameworks IEnumTargetFrameworks;
#endif 	/* __IEnumTargetFrameworks_FWD_DEFINED__ */


#ifndef __IEnumSystemAssemblies_FWD_DEFINED__
#define __IEnumSystemAssemblies_FWD_DEFINED__
typedef interface IEnumSystemAssemblies IEnumSystemAssemblies;
#endif 	/* __IEnumSystemAssemblies_FWD_DEFINED__ */


#ifndef __IVsTargetFrameworkAssemblies_FWD_DEFINED__
#define __IVsTargetFrameworkAssemblies_FWD_DEFINED__
typedef interface IVsTargetFrameworkAssemblies IVsTargetFrameworkAssemblies;
#endif 	/* __IVsTargetFrameworkAssemblies_FWD_DEFINED__ */


#ifndef __SVsTargetFrameworkAssemblies_FWD_DEFINED__
#define __SVsTargetFrameworkAssemblies_FWD_DEFINED__
typedef interface SVsTargetFrameworkAssemblies SVsTargetFrameworkAssemblies;
#endif 	/* __SVsTargetFrameworkAssemblies_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vsshell90.h"
#include "compsvcspkg80.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IEnumTargetFrameworks_INTERFACE_DEFINED__
#define __IEnumTargetFrameworks_INTERFACE_DEFINED__

/* interface IEnumTargetFrameworks */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumTargetFrameworks;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D92C0B96-E08D-4268-A941-6D7D670F1820")
    IEnumTargetFrameworks : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) TARGETFRAMEWORKVERSION *rgFrameworks,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ __RPC__out ULONG *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumTargetFrameworks **ppIEnumComponents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTargetFrameworksVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTargetFrameworks * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTargetFrameworks * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTargetFrameworks * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTargetFrameworks * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) TARGETFRAMEWORKVERSION *rgFrameworks,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IEnumTargetFrameworks * This,
            /* [out] */ __RPC__out ULONG *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTargetFrameworks * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTargetFrameworks * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTargetFrameworks * This,
            /* [out] */ __RPC__deref_out_opt IEnumTargetFrameworks **ppIEnumComponents);
        
        END_INTERFACE
    } IEnumTargetFrameworksVtbl;

    interface IEnumTargetFrameworks
    {
        CONST_VTBL struct IEnumTargetFrameworksVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTargetFrameworks_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumTargetFrameworks_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumTargetFrameworks_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumTargetFrameworks_Next(This,celt,rgFrameworks,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgFrameworks,pceltFetched) ) 

#define IEnumTargetFrameworks_Count(This,pCount)	\
    ( (This)->lpVtbl -> Count(This,pCount) ) 

#define IEnumTargetFrameworks_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumTargetFrameworks_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumTargetFrameworks_Clone(This,ppIEnumComponents)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumComponents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumTargetFrameworks_INTERFACE_DEFINED__ */


#ifndef __IEnumSystemAssemblies_INTERFACE_DEFINED__
#define __IEnumSystemAssemblies_INTERFACE_DEFINED__

/* interface IEnumSystemAssemblies */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumSystemAssemblies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7431FCE8-8E4F-49b6-BB50-E295636CBA6B")
    IEnumSystemAssemblies : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) BSTR *rgAssemblies,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ __RPC__out ULONG *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSystemAssemblies **ppIEnumComponents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSystemAssembliesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSystemAssemblies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSystemAssemblies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSystemAssemblies * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSystemAssemblies * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) BSTR *rgAssemblies,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IEnumSystemAssemblies * This,
            /* [out] */ __RPC__out ULONG *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSystemAssemblies * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSystemAssemblies * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSystemAssemblies * This,
            /* [out] */ __RPC__deref_out_opt IEnumSystemAssemblies **ppIEnumComponents);
        
        END_INTERFACE
    } IEnumSystemAssembliesVtbl;

    interface IEnumSystemAssemblies
    {
        CONST_VTBL struct IEnumSystemAssembliesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSystemAssemblies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSystemAssemblies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSystemAssemblies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSystemAssemblies_Next(This,celt,rgAssemblies,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgAssemblies,pceltFetched) ) 

#define IEnumSystemAssemblies_Count(This,pCount)	\
    ( (This)->lpVtbl -> Count(This,pCount) ) 

#define IEnumSystemAssemblies_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSystemAssemblies_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSystemAssemblies_Clone(This,ppIEnumComponents)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumComponents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSystemAssemblies_INTERFACE_DEFINED__ */


#ifndef __IVsTargetFrameworkAssemblies_INTERFACE_DEFINED__
#define __IVsTargetFrameworkAssemblies_INTERFACE_DEFINED__

/* interface IVsTargetFrameworkAssemblies */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsTargetFrameworkAssemblies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("399DC6D4-84D6-4208-AFA6-362098E7972F")
    IVsTargetFrameworkAssemblies : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedFrameworks( 
            /* [out] */ __RPC__deref_out_opt IEnumTargetFrameworks **pTargetFrameworks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetFrameworkDescription( 
            /* [in] */ TARGETFRAMEWORKVERSION targetVersion,
            /* [out] */ __RPC__deref_out_opt BSTR *pszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemAssemblies( 
            /* [in] */ TARGETFRAMEWORKVERSION targetVersion,
            /* [out] */ __RPC__deref_out_opt IEnumSystemAssemblies **pAssemblies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSystemAssembly( 
            /* [in] */ __RPC__in LPCOLESTR szAssemblyFile,
            /* [out] */ __RPC__out BOOL *pIsSystem,
            /* [out] */ __RPC__out TARGETFRAMEWORKVERSION *pTargetFrameworkVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequiredTargetFrameworkVersion( 
            /* [in] */ __RPC__in LPCOLESTR szAssemblyFile,
            /* [out] */ __RPC__out TARGETFRAMEWORKVERSION *pTargetFrameworkVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequiredTargetFrameworkVersionFromDependency( 
            /* [in] */ __RPC__in LPCOLESTR szAssemblyFile,
            /* [out] */ __RPC__out TARGETFRAMEWORKVERSION *pTargetFrameworkVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsTargetFrameworkAssembliesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsTargetFrameworkAssemblies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsTargetFrameworkAssemblies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsTargetFrameworkAssemblies * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedFrameworks )( 
            IVsTargetFrameworkAssemblies * This,
            /* [out] */ __RPC__deref_out_opt IEnumTargetFrameworks **pTargetFrameworks);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetFrameworkDescription )( 
            IVsTargetFrameworkAssemblies * This,
            /* [in] */ TARGETFRAMEWORKVERSION targetVersion,
            /* [out] */ __RPC__deref_out_opt BSTR *pszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemAssemblies )( 
            IVsTargetFrameworkAssemblies * This,
            /* [in] */ TARGETFRAMEWORKVERSION targetVersion,
            /* [out] */ __RPC__deref_out_opt IEnumSystemAssemblies **pAssemblies);
        
        HRESULT ( STDMETHODCALLTYPE *IsSystemAssembly )( 
            IVsTargetFrameworkAssemblies * This,
            /* [in] */ __RPC__in LPCOLESTR szAssemblyFile,
            /* [out] */ __RPC__out BOOL *pIsSystem,
            /* [out] */ __RPC__out TARGETFRAMEWORKVERSION *pTargetFrameworkVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequiredTargetFrameworkVersion )( 
            IVsTargetFrameworkAssemblies * This,
            /* [in] */ __RPC__in LPCOLESTR szAssemblyFile,
            /* [out] */ __RPC__out TARGETFRAMEWORKVERSION *pTargetFrameworkVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequiredTargetFrameworkVersionFromDependency )( 
            IVsTargetFrameworkAssemblies * This,
            /* [in] */ __RPC__in LPCOLESTR szAssemblyFile,
            /* [out] */ __RPC__out TARGETFRAMEWORKVERSION *pTargetFrameworkVersion);
        
        END_INTERFACE
    } IVsTargetFrameworkAssembliesVtbl;

    interface IVsTargetFrameworkAssemblies
    {
        CONST_VTBL struct IVsTargetFrameworkAssembliesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsTargetFrameworkAssemblies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsTargetFrameworkAssemblies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsTargetFrameworkAssemblies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsTargetFrameworkAssemblies_GetSupportedFrameworks(This,pTargetFrameworks)	\
    ( (This)->lpVtbl -> GetSupportedFrameworks(This,pTargetFrameworks) ) 

#define IVsTargetFrameworkAssemblies_GetTargetFrameworkDescription(This,targetVersion,pszDescription)	\
    ( (This)->lpVtbl -> GetTargetFrameworkDescription(This,targetVersion,pszDescription) ) 

#define IVsTargetFrameworkAssemblies_GetSystemAssemblies(This,targetVersion,pAssemblies)	\
    ( (This)->lpVtbl -> GetSystemAssemblies(This,targetVersion,pAssemblies) ) 

#define IVsTargetFrameworkAssemblies_IsSystemAssembly(This,szAssemblyFile,pIsSystem,pTargetFrameworkVersion)	\
    ( (This)->lpVtbl -> IsSystemAssembly(This,szAssemblyFile,pIsSystem,pTargetFrameworkVersion) ) 

#define IVsTargetFrameworkAssemblies_GetRequiredTargetFrameworkVersion(This,szAssemblyFile,pTargetFrameworkVersion)	\
    ( (This)->lpVtbl -> GetRequiredTargetFrameworkVersion(This,szAssemblyFile,pTargetFrameworkVersion) ) 

#define IVsTargetFrameworkAssemblies_GetRequiredTargetFrameworkVersionFromDependency(This,szAssemblyFile,pTargetFrameworkVersion)	\
    ( (This)->lpVtbl -> GetRequiredTargetFrameworkVersionFromDependency(This,szAssemblyFile,pTargetFrameworkVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsTargetFrameworkAssemblies_INTERFACE_DEFINED__ */


#ifndef __SVsTargetFrameworkAssemblies_INTERFACE_DEFINED__
#define __SVsTargetFrameworkAssemblies_INTERFACE_DEFINED__

/* interface SVsTargetFrameworkAssemblies */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsTargetFrameworkAssemblies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C269ADA8-95F9-4987-A247-151FB2DDFB34")
    SVsTargetFrameworkAssemblies : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsTargetFrameworkAssembliesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsTargetFrameworkAssemblies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsTargetFrameworkAssemblies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsTargetFrameworkAssemblies * This);
        
        END_INTERFACE
    } SVsTargetFrameworkAssembliesVtbl;

    interface SVsTargetFrameworkAssemblies
    {
        CONST_VTBL struct SVsTargetFrameworkAssembliesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsTargetFrameworkAssemblies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsTargetFrameworkAssemblies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsTargetFrameworkAssemblies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsTargetFrameworkAssemblies_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg90_0000_0004 */
/* [local] */ 

#define SID_SVsTargetFrameworkAssemblies IID_SVsTargetFrameworkAssemblies


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg90_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg90_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\compsvcspkg100.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for compsvcspkg100.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __compsvcspkg100_h__
#define __compsvcspkg100_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsFrameworkMultiTargeting_FWD_DEFINED__
#define __IVsFrameworkMultiTargeting_FWD_DEFINED__
typedef interface IVsFrameworkMultiTargeting IVsFrameworkMultiTargeting;
#endif 	/* __IVsFrameworkMultiTargeting_FWD_DEFINED__ */


#ifndef __SVsFrameworkMultiTargeting_FWD_DEFINED__
#define __SVsFrameworkMultiTargeting_FWD_DEFINED__
typedef interface SVsFrameworkMultiTargeting SVsFrameworkMultiTargeting;
#endif 	/* __SVsFrameworkMultiTargeting_FWD_DEFINED__ */


#ifndef __IVsFrameworkRetargetingDlg_FWD_DEFINED__
#define __IVsFrameworkRetargetingDlg_FWD_DEFINED__
typedef interface IVsFrameworkRetargetingDlg IVsFrameworkRetargetingDlg;
#endif 	/* __IVsFrameworkRetargetingDlg_FWD_DEFINED__ */


#ifndef __SVsFrameworkRetargetingDlg_FWD_DEFINED__
#define __SVsFrameworkRetargetingDlg_FWD_DEFINED__
typedef interface SVsFrameworkRetargetingDlg SVsFrameworkRetargetingDlg;
#endif 	/* __SVsFrameworkRetargetingDlg_FWD_DEFINED__ */


#ifndef __IVsComponentEnumeratorFactory4_FWD_DEFINED__
#define __IVsComponentEnumeratorFactory4_FWD_DEFINED__
typedef interface IVsComponentEnumeratorFactory4 IVsComponentEnumeratorFactory4;
#endif 	/* __IVsComponentEnumeratorFactory4_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vsshell90.h"
#include "vsshell100.h"
#include "compsvcspkg80.h"
#include "compsvcspkg90.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_compsvcspkg100_0000_0000 */
/* [local] */ 

typedef 
enum _tagVSFRAMEWORKASSEMBLYTYPE
    {	VSFRAMEWORKASSEMBLYTYPE_FRAMEWORK	= 0x1,
	VSFRAMEWORKASSEMBLYTYPE_EXTENSIONS	= 0x2,
	VSFRAMEWORKASSEMBLYTYPE_ALL	= 0x8000
    } 	__VSFRAMEWORKASSEMBLYTYPE;

typedef DWORD VSFRAMEWORKASSEMBLYTYPE;

typedef 
enum _tagVSFRAMEWORKCOMPATIBILITY
    {	VSFRAMEWORKCOMPATIBILITY_COMPATIBLE	= 0,
	VSFRAMEWORKCOMPATIBILITY_INCOMPATIBLEIDENTITY	= 0x1,
	VSFRAMEWORKCOMPATIBILITY_INCOMPATIBLEVERSION	= 0x2,
	VSFRAMEWORKCOMPATIBILITY_INCOMPATIBLEPROFILE	= 0x4
    } 	__VSFRAMEWORKCOMPATIBILITY;

typedef DWORD VSFRAMEWORKCOMPATIBILITY;



extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg100_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg100_0000_0000_v0_0_s_ifspec;

#ifndef __IVsFrameworkMultiTargeting_INTERFACE_DEFINED__
#define __IVsFrameworkMultiTargeting_INTERFACE_DEFINED__

/* interface IVsFrameworkMultiTargeting */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsFrameworkMultiTargeting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B096B75C-5DF5-42c6-888F-A007CCEB6635")
    IVsFrameworkMultiTargeting : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsReferenceableInTargetFx( 
            /* [in] */ __RPC__in LPCWSTR pwszAssemblySpec,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsReferenceable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetFramework( 
            /* [in] */ __RPC__in LPCWSTR pwszAssemblyPath,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkIdentifier,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTargetFrameworkMoniker) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedFrameworks( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *prgSupportedFrameworks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameworkAssemblies( 
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [in] */ VSFRAMEWORKASSEMBLYTYPE atAssemblyType,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *prgAssemblyPaths) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckFrameworkCompatibility( 
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMonikerSource,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMonikerTarget,
            /* [retval][out] */ __RPC__out VSFRAMEWORKCOMPATIBILITY *pdwCompat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveAssemblyPath( 
            /* [in] */ __RPC__in LPCWSTR pwszAssemblySpec,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrResolvedAssemblyPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayNameForTargetFx( 
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveAssemblyPathsInTargetFx( 
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [size_is][in] */ __RPC__in_ecount_full(cAssembliesToResolve) SAFEARRAY * prgAssemblySpecs,
            /* [in] */ ULONG cAssembliesToResolve,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(cAssembliesToResolve) PVsResolvedAssemblyPath prgResolvedAssemblyPaths,
            /* [out] */ __RPC__out ULONG *pcResolvedAssemblyPaths) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInstallableFrameworkForTargetFx( 
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInstallableFrameworkMoniker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsFrameworkMultiTargetingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsFrameworkMultiTargeting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsFrameworkMultiTargeting * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsReferenceableInTargetFx )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszAssemblySpec,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsReferenceable);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetFramework )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszAssemblyPath,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkIdentifier,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTargetFrameworkMoniker);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedFrameworks )( 
            IVsFrameworkMultiTargeting * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *prgSupportedFrameworks);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameworkAssemblies )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [in] */ VSFRAMEWORKASSEMBLYTYPE atAssemblyType,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *prgAssemblyPaths);
        
        HRESULT ( STDMETHODCALLTYPE *CheckFrameworkCompatibility )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMonikerSource,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMonikerTarget,
            /* [retval][out] */ __RPC__out VSFRAMEWORKCOMPATIBILITY *pdwCompat);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveAssemblyPath )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszAssemblySpec,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrResolvedAssemblyPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameForTargetFx )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveAssemblyPathsInTargetFx )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [size_is][in] */ __RPC__in_ecount_full(cAssembliesToResolve) SAFEARRAY * prgAssemblySpecs,
            /* [in] */ ULONG cAssembliesToResolve,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(cAssembliesToResolve) PVsResolvedAssemblyPath prgResolvedAssemblyPaths,
            /* [out] */ __RPC__out ULONG *pcResolvedAssemblyPaths);
        
        HRESULT ( STDMETHODCALLTYPE *GetInstallableFrameworkForTargetFx )( 
            IVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in LPCWSTR pwszTargetFrameworkMoniker,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInstallableFrameworkMoniker);
        
        END_INTERFACE
    } IVsFrameworkMultiTargetingVtbl;

    interface IVsFrameworkMultiTargeting
    {
        CONST_VTBL struct IVsFrameworkMultiTargetingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsFrameworkMultiTargeting_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsFrameworkMultiTargeting_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsFrameworkMultiTargeting_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsFrameworkMultiTargeting_IsReferenceableInTargetFx(This,pwszAssemblySpec,pwszTargetFrameworkMoniker,pbIsReferenceable)	\
    ( (This)->lpVtbl -> IsReferenceableInTargetFx(This,pwszAssemblySpec,pwszTargetFrameworkMoniker,pbIsReferenceable) ) 

#define IVsFrameworkMultiTargeting_GetTargetFramework(This,pwszAssemblyPath,pwszTargetFrameworkIdentifier,pbstrTargetFrameworkMoniker)	\
    ( (This)->lpVtbl -> GetTargetFramework(This,pwszAssemblyPath,pwszTargetFrameworkIdentifier,pbstrTargetFrameworkMoniker) ) 

#define IVsFrameworkMultiTargeting_GetSupportedFrameworks(This,prgSupportedFrameworks)	\
    ( (This)->lpVtbl -> GetSupportedFrameworks(This,prgSupportedFrameworks) ) 

#define IVsFrameworkMultiTargeting_GetFrameworkAssemblies(This,pwszTargetFrameworkMoniker,atAssemblyType,prgAssemblyPaths)	\
    ( (This)->lpVtbl -> GetFrameworkAssemblies(This,pwszTargetFrameworkMoniker,atAssemblyType,prgAssemblyPaths) ) 

#define IVsFrameworkMultiTargeting_CheckFrameworkCompatibility(This,pwszTargetFrameworkMonikerSource,pwszTargetFrameworkMonikerTarget,pdwCompat)	\
    ( (This)->lpVtbl -> CheckFrameworkCompatibility(This,pwszTargetFrameworkMonikerSource,pwszTargetFrameworkMonikerTarget,pdwCompat) ) 

#define IVsFrameworkMultiTargeting_ResolveAssemblyPath(This,pwszAssemblySpec,pwszTargetFrameworkMoniker,pbstrResolvedAssemblyPath)	\
    ( (This)->lpVtbl -> ResolveAssemblyPath(This,pwszAssemblySpec,pwszTargetFrameworkMoniker,pbstrResolvedAssemblyPath) ) 

#define IVsFrameworkMultiTargeting_GetDisplayNameForTargetFx(This,pwszTargetFrameworkMoniker,pbstrDisplayName)	\
    ( (This)->lpVtbl -> GetDisplayNameForTargetFx(This,pwszTargetFrameworkMoniker,pbstrDisplayName) ) 

#define IVsFrameworkMultiTargeting_ResolveAssemblyPathsInTargetFx(This,pwszTargetFrameworkMoniker,prgAssemblySpecs,cAssembliesToResolve,prgResolvedAssemblyPaths,pcResolvedAssemblyPaths)	\
    ( (This)->lpVtbl -> ResolveAssemblyPathsInTargetFx(This,pwszTargetFrameworkMoniker,prgAssemblySpecs,cAssembliesToResolve,prgResolvedAssemblyPaths,pcResolvedAssemblyPaths) ) 

#define IVsFrameworkMultiTargeting_GetInstallableFrameworkForTargetFx(This,pwszTargetFrameworkMoniker,pbstrInstallableFrameworkMoniker)	\
    ( (This)->lpVtbl -> GetInstallableFrameworkForTargetFx(This,pwszTargetFrameworkMoniker,pbstrInstallableFrameworkMoniker) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsFrameworkMultiTargeting_INTERFACE_DEFINED__ */


#ifndef __SVsFrameworkMultiTargeting_INTERFACE_DEFINED__
#define __SVsFrameworkMultiTargeting_INTERFACE_DEFINED__

/* interface SVsFrameworkMultiTargeting */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsFrameworkMultiTargeting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F209208-4D8F-4412-B125-CD839B055D52")
    SVsFrameworkMultiTargeting : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsFrameworkMultiTargetingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsFrameworkMultiTargeting * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsFrameworkMultiTargeting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsFrameworkMultiTargeting * This);
        
        END_INTERFACE
    } SVsFrameworkMultiTargetingVtbl;

    interface SVsFrameworkMultiTargeting
    {
        CONST_VTBL struct SVsFrameworkMultiTargetingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsFrameworkMultiTargeting_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsFrameworkMultiTargeting_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsFrameworkMultiTargeting_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsFrameworkMultiTargeting_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg100_0000_0002 */
/* [local] */ 

#define SID_SVsFrameworkMultiTargeting IID_SVsFrameworkMultiTargeting
typedef 
enum _tagFRD_FLAGS
    {	FRDF_SUPPORTS_RETARGETING	= 1,
	FRDF_DEFAULT	= FRDF_SUPPORTS_RETARGETING
    } 	__FRD_FLAGS;

typedef DWORD FRD_FLAGS;

typedef 
enum _tagFRD_OUTCOME
    {	FRDO_RETARGET_TO_40	= 1,
	FRDO_LEAVE_UNLOADED	= 2,
	FRDO_GOTO_DOWNLOAD_SITE	= 3
    } 	__FRD_OUTCOME;

typedef DWORD FRD_OUTCOME;



extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg100_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg100_0000_0002_v0_0_s_ifspec;

#ifndef __IVsFrameworkRetargetingDlg_INTERFACE_DEFINED__
#define __IVsFrameworkRetargetingDlg_INTERFACE_DEFINED__

/* interface IVsFrameworkRetargetingDlg */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsFrameworkRetargetingDlg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47f60934-4361-443a-9411-020bc2055608")
    IVsFrameworkRetargetingDlg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowFrameworkRetargetingDlg( 
            /* [in] */ __RPC__in LPCWSTR pszProjectType,
            /* [in] */ __RPC__in LPCWSTR pszProjectName,
            /* [in] */ __RPC__in LPCWSTR pszTargetedFrameworkMoniker,
            /* [in] */ FRD_FLAGS dwFlags,
            /* [out] */ __RPC__out FRD_OUTCOME *pdwOutcome,
            /* [out] */ __RPC__out BOOL *pbDontShowAgain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateToFrameworkDownloadUrl( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsFrameworkRetargetingDlgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsFrameworkRetargetingDlg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsFrameworkRetargetingDlg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsFrameworkRetargetingDlg * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFrameworkRetargetingDlg )( 
            IVsFrameworkRetargetingDlg * This,
            /* [in] */ __RPC__in LPCWSTR pszProjectType,
            /* [in] */ __RPC__in LPCWSTR pszProjectName,
            /* [in] */ __RPC__in LPCWSTR pszTargetedFrameworkMoniker,
            /* [in] */ FRD_FLAGS dwFlags,
            /* [out] */ __RPC__out FRD_OUTCOME *pdwOutcome,
            /* [out] */ __RPC__out BOOL *pbDontShowAgain);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateToFrameworkDownloadUrl )( 
            IVsFrameworkRetargetingDlg * This);
        
        END_INTERFACE
    } IVsFrameworkRetargetingDlgVtbl;

    interface IVsFrameworkRetargetingDlg
    {
        CONST_VTBL struct IVsFrameworkRetargetingDlgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsFrameworkRetargetingDlg_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsFrameworkRetargetingDlg_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsFrameworkRetargetingDlg_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsFrameworkRetargetingDlg_ShowFrameworkRetargetingDlg(This,pszProjectType,pszProjectName,pszTargetedFrameworkMoniker,dwFlags,pdwOutcome,pbDontShowAgain)	\
    ( (This)->lpVtbl -> ShowFrameworkRetargetingDlg(This,pszProjectType,pszProjectName,pszTargetedFrameworkMoniker,dwFlags,pdwOutcome,pbDontShowAgain) ) 

#define IVsFrameworkRetargetingDlg_NavigateToFrameworkDownloadUrl(This)	\
    ( (This)->lpVtbl -> NavigateToFrameworkDownloadUrl(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsFrameworkRetargetingDlg_INTERFACE_DEFINED__ */


#ifndef __SVsFrameworkRetargetingDlg_INTERFACE_DEFINED__
#define __SVsFrameworkRetargetingDlg_INTERFACE_DEFINED__

/* interface SVsFrameworkRetargetingDlg */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsFrameworkRetargetingDlg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d4d51b8e-6ecf-4c42-a3e2-e0925e5115d6")
    SVsFrameworkRetargetingDlg : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsFrameworkRetargetingDlgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsFrameworkRetargetingDlg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsFrameworkRetargetingDlg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsFrameworkRetargetingDlg * This);
        
        END_INTERFACE
    } SVsFrameworkRetargetingDlgVtbl;

    interface SVsFrameworkRetargetingDlg
    {
        CONST_VTBL struct SVsFrameworkRetargetingDlgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsFrameworkRetargetingDlg_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsFrameworkRetargetingDlg_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsFrameworkRetargetingDlg_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsFrameworkRetargetingDlg_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_compsvcspkg100_0000_0004 */
/* [local] */ 

#define SID_SVsFrameworkRetargetingDlg IID_SVsFrameworkRetargetingDlg


extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg100_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_compsvcspkg100_0000_0004_v0_0_s_ifspec;

#ifndef __IVsComponentEnumeratorFactory4_INTERFACE_DEFINED__
#define __IVsComponentEnumeratorFactory4_INTERFACE_DEFINED__

/* interface IVsComponentEnumeratorFactory4 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsComponentEnumeratorFactory4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8F18FE7E-ACB7-4031-AAE5-039B49DF5191")
    IVsComponentEnumeratorFactory4 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReferencePathsForTargetFramework( 
            /* [in] */ __RPC__in LPCWSTR targetFrameworkMoniker,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **ppEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsComponentEnumeratorFactory4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsComponentEnumeratorFactory4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsComponentEnumeratorFactory4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsComponentEnumeratorFactory4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferencePathsForTargetFramework )( 
            IVsComponentEnumeratorFactory4 * This,
            /* [in] */ __RPC__in LPCWSTR targetFrameworkMoniker,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **ppEnumerator);
        
        END_INTERFACE
    } IVsComponentEnumeratorFactory4Vtbl;

    interface IVsComponentEnumeratorFactory4
    {
        CONST_VTBL struct IVsComponentEnumeratorFactory4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsComponentEnumeratorFactory4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsComponentEnumeratorFactory4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsComponentEnumeratorFactory4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsComponentEnumeratorFactory4_GetReferencePathsForTargetFramework(This,targetFrameworkMoniker,ppEnumerator)	\
    ( (This)->lpVtbl -> GetReferencePathsForTargetFramework(This,targetFrameworkMoniker,ppEnumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsComponentEnumeratorFactory4_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\context.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for context.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __context_h__
#define __context_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsUserContext_FWD_DEFINED__
#define __IVsUserContext_FWD_DEFINED__
typedef interface IVsUserContext IVsUserContext;
#endif 	/* __IVsUserContext_FWD_DEFINED__ */


#ifndef __IVsUserContextUpdate_FWD_DEFINED__
#define __IVsUserContextUpdate_FWD_DEFINED__
typedef interface IVsUserContextUpdate IVsUserContextUpdate;
#endif 	/* __IVsUserContextUpdate_FWD_DEFINED__ */


#ifndef __IVsProvideUserContext_FWD_DEFINED__
#define __IVsProvideUserContext_FWD_DEFINED__
typedef interface IVsProvideUserContext IVsProvideUserContext;
#endif 	/* __IVsProvideUserContext_FWD_DEFINED__ */


#ifndef __IVsProvideUserContextForObject_FWD_DEFINED__
#define __IVsProvideUserContextForObject_FWD_DEFINED__
typedef interface IVsProvideUserContextForObject IVsProvideUserContextForObject;
#endif 	/* __IVsProvideUserContextForObject_FWD_DEFINED__ */


#ifndef __IVsUserContextItemCollection_FWD_DEFINED__
#define __IVsUserContextItemCollection_FWD_DEFINED__
typedef interface IVsUserContextItemCollection IVsUserContextItemCollection;
#endif 	/* __IVsUserContextItemCollection_FWD_DEFINED__ */


#ifndef __IVsUserContextItem_FWD_DEFINED__
#define __IVsUserContextItem_FWD_DEFINED__
typedef interface IVsUserContextItem IVsUserContextItem;
#endif 	/* __IVsUserContextItem_FWD_DEFINED__ */


#ifndef __IVsHelpAttributeList_FWD_DEFINED__
#define __IVsHelpAttributeList_FWD_DEFINED__
typedef interface IVsHelpAttributeList IVsHelpAttributeList;
#endif 	/* __IVsHelpAttributeList_FWD_DEFINED__ */


#ifndef __IVsMonitorUserContext_FWD_DEFINED__
#define __IVsMonitorUserContext_FWD_DEFINED__
typedef interface IVsMonitorUserContext IVsMonitorUserContext;
#endif 	/* __IVsMonitorUserContext_FWD_DEFINED__ */


#ifndef __IVsUserContextItemProvider_FWD_DEFINED__
#define __IVsUserContextItemProvider_FWD_DEFINED__
typedef interface IVsUserContextItemProvider IVsUserContextItemProvider;
#endif 	/* __IVsUserContextItemProvider_FWD_DEFINED__ */


#ifndef __IVsUserContextCustomize_FWD_DEFINED__
#define __IVsUserContextCustomize_FWD_DEFINED__
typedef interface IVsUserContextCustomize IVsUserContextCustomize;
#endif 	/* __IVsUserContextCustomize_FWD_DEFINED__ */


#ifndef __IVsUserContextItemEvents_FWD_DEFINED__
#define __IVsUserContextItemEvents_FWD_DEFINED__
typedef interface IVsUserContextItemEvents IVsUserContextItemEvents;
#endif 	/* __IVsUserContextItemEvents_FWD_DEFINED__ */


#ifndef __VsContextClass_FWD_DEFINED__
#define __VsContextClass_FWD_DEFINED__

#ifdef __cplusplus
typedef class VsContextClass VsContextClass;
#else
typedef struct VsContextClass VsContextClass;
#endif /* __cplusplus */

#endif 	/* __VsContextClass_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "servprov.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_context_0000_0000 */
/* [local] */ 

#pragma once







typedef DWORD_PTR VSCOOKIE;

typedef DWORD_PTR VSCONTEXTUPDATECOOKIE;

typedef DWORD_PTR VSSUBCONTEXTCOOKIE;

typedef DWORD_PTR VSINFOPROVIDERCOOKIE;

typedef 
enum tagVsUserContextPriority
    {	VSUC_Priority_None	= 0,
	VSUC_Priority_Ambient	= 100,
	VSUC_Priority_State	= 200,
	VSUC_Priority_Project	= 300,
	VSUC_Priority_ProjectItem	= 400,
	VSUC_Priority_Window	= 500,
	VSUC_Priority_Selection	= 600,
	VSUC_Priority_MarkerSel	= 700,
	VSUC_Priority_Enterprise	= 800,
	VSUC_Priority_WindowFrame	= 900,
	VSUC_Priority_ToolWndSel	= 1000,
	VSUC_Priority_Highest	= 1100
    } 	VSUSERCONTEXTPRIORITY;

typedef 
enum tagVsUserContextAttributeUsage
    {	VSUC_Usage_Filter	= 0,
	VSUC_Usage_Lookup	= 1,
	VSUC_Usage_LookupF1	= 2,
	VSUC_Usage_Lookup_CaseSensitive	= 3,
	VSUC_Usage_LookupF1_CaseSensitive	= 4
    } 	VSUSERCONTEXTATTRIBUTEUSAGE;



extern RPC_IF_HANDLE __MIDL_itf_context_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context_0000_0000_v0_0_s_ifspec;

#ifndef __IVsUserContext_INTERFACE_DEFINED__
#define __IVsUserContext_INTERFACE_DEFINED__

/* interface IVsUserContext */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsUserContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("761081DF-D45F-4683-9B9E-1B7241E56F5C")
    IVsUserContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddAttribute( 
            /* [in] */ VSUSERCONTEXTATTRIBUTEUSAGE usage,
            /* [in] */ __RPC__in LPCOLESTR szName,
            /* [in] */ __RPC__in LPCOLESTR szValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAttribute( 
            /* [in] */ __RPC__in LPCOLESTR szName,
            /* [in] */ __RPC__in LPCOLESTR szValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSubcontext( 
            /* [in] */ __RPC__in_opt IVsUserContext *pSubCtx,
            /* [in] */ int lPriority,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSubcontext( 
            /* [in] */ VSCOOKIE dwcookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CountAttributes( 
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ BOOL fIncludeChildren,
            /* [retval][out] */ __RPC__out int *pc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ int iAttribute,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ BOOL fIncludeChildren,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CountSubcontexts( 
            /* [retval][out] */ __RPC__out int *pc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubcontext( 
            /* [in] */ int i,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppSubCtx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( 
            /* [retval][out] */ __RPC__out BOOL *pfDirty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirty( 
            /* [in] */ BOOL fDirty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseUpdate( 
            /* [in] */ __RPC__in_opt IVsUserContextUpdate *pUpdate,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseUpdate( 
            /* [in] */ VSCOOKIE dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttrUsage( 
            /* [in] */ int index,
            /* [in] */ BOOL fIncludeChildren,
            /* [retval][out] */ __RPC__out VSUSERCONTEXTATTRIBUTEUSAGE *pUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllSubcontext( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [retval][out] */ __RPC__out int *lPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAttributeIncludeChildren( 
            /* [in] */ __RPC__in LPCOLESTR szName,
            /* [in] */ __RPC__in LPCOLESTR szValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributePri( 
            /* [in] */ int iAttribute,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ BOOL fIncludeChildren,
            /* [out] */ __RPC__out int *piPriority,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddAttribute )( 
            IVsUserContext * This,
            /* [in] */ VSUSERCONTEXTATTRIBUTEUSAGE usage,
            /* [in] */ __RPC__in LPCOLESTR szName,
            /* [in] */ __RPC__in LPCOLESTR szValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAttribute )( 
            IVsUserContext * This,
            /* [in] */ __RPC__in LPCOLESTR szName,
            /* [in] */ __RPC__in LPCOLESTR szValue);
        
        HRESULT ( STDMETHODCALLTYPE *AddSubcontext )( 
            IVsUserContext * This,
            /* [in] */ __RPC__in_opt IVsUserContext *pSubCtx,
            /* [in] */ int lPriority,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSubcontext )( 
            IVsUserContext * This,
            /* [in] */ VSCOOKIE dwcookie);
        
        HRESULT ( STDMETHODCALLTYPE *CountAttributes )( 
            IVsUserContext * This,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ BOOL fIncludeChildren,
            /* [retval][out] */ __RPC__out int *pc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IVsUserContext * This,
            /* [in] */ int iAttribute,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ BOOL fIncludeChildren,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *CountSubcontexts )( 
            IVsUserContext * This,
            /* [retval][out] */ __RPC__out int *pc);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubcontext )( 
            IVsUserContext * This,
            /* [in] */ int i,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppSubCtx);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IVsUserContext * This,
            /* [retval][out] */ __RPC__out BOOL *pfDirty);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirty )( 
            IVsUserContext * This,
            /* [in] */ BOOL fDirty);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IVsUserContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseUpdate )( 
            IVsUserContext * This,
            /* [in] */ __RPC__in_opt IVsUserContextUpdate *pUpdate,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseUpdate )( 
            IVsUserContext * This,
            /* [in] */ VSCOOKIE dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttrUsage )( 
            IVsUserContext * This,
            /* [in] */ int index,
            /* [in] */ BOOL fIncludeChildren,
            /* [retval][out] */ __RPC__out VSUSERCONTEXTATTRIBUTEUSAGE *pUsage);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllSubcontext )( 
            IVsUserContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IVsUserContext * This,
            /* [retval][out] */ __RPC__out int *lPriority);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAttributeIncludeChildren )( 
            IVsUserContext * This,
            /* [in] */ __RPC__in LPCOLESTR szName,
            /* [in] */ __RPC__in LPCOLESTR szValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributePri )( 
            IVsUserContext * This,
            /* [in] */ int iAttribute,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ BOOL fIncludeChildren,
            /* [out] */ __RPC__out int *piPriority,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        END_INTERFACE
    } IVsUserContextVtbl;

    interface IVsUserContext
    {
        CONST_VTBL struct IVsUserContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContext_AddAttribute(This,usage,szName,szValue)	\
    ( (This)->lpVtbl -> AddAttribute(This,usage,szName,szValue) ) 

#define IVsUserContext_RemoveAttribute(This,szName,szValue)	\
    ( (This)->lpVtbl -> RemoveAttribute(This,szName,szValue) ) 

#define IVsUserContext_AddSubcontext(This,pSubCtx,lPriority,pdwCookie)	\
    ( (This)->lpVtbl -> AddSubcontext(This,pSubCtx,lPriority,pdwCookie) ) 

#define IVsUserContext_RemoveSubcontext(This,dwcookie)	\
    ( (This)->lpVtbl -> RemoveSubcontext(This,dwcookie) ) 

#define IVsUserContext_CountAttributes(This,pszName,fIncludeChildren,pc)	\
    ( (This)->lpVtbl -> CountAttributes(This,pszName,fIncludeChildren,pc) ) 

#define IVsUserContext_GetAttribute(This,iAttribute,pszName,fIncludeChildren,pbstrName,pbstrValue)	\
    ( (This)->lpVtbl -> GetAttribute(This,iAttribute,pszName,fIncludeChildren,pbstrName,pbstrValue) ) 

#define IVsUserContext_CountSubcontexts(This,pc)	\
    ( (This)->lpVtbl -> CountSubcontexts(This,pc) ) 

#define IVsUserContext_GetSubcontext(This,i,ppSubCtx)	\
    ( (This)->lpVtbl -> GetSubcontext(This,i,ppSubCtx) ) 

#define IVsUserContext_IsDirty(This,pfDirty)	\
    ( (This)->lpVtbl -> IsDirty(This,pfDirty) ) 

#define IVsUserContext_SetDirty(This,fDirty)	\
    ( (This)->lpVtbl -> SetDirty(This,fDirty) ) 

#define IVsUserContext_Update(This)	\
    ( (This)->lpVtbl -> Update(This) ) 

#define IVsUserContext_AdviseUpdate(This,pUpdate,pdwCookie)	\
    ( (This)->lpVtbl -> AdviseUpdate(This,pUpdate,pdwCookie) ) 

#define IVsUserContext_UnadviseUpdate(This,dwCookie)	\
    ( (This)->lpVtbl -> UnadviseUpdate(This,dwCookie) ) 

#define IVsUserContext_GetAttrUsage(This,index,fIncludeChildren,pUsage)	\
    ( (This)->lpVtbl -> GetAttrUsage(This,index,fIncludeChildren,pUsage) ) 

#define IVsUserContext_RemoveAllSubcontext(This)	\
    ( (This)->lpVtbl -> RemoveAllSubcontext(This) ) 

#define IVsUserContext_GetPriority(This,lPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,lPriority) ) 

#define IVsUserContext_RemoveAttributeIncludeChildren(This,szName,szValue)	\
    ( (This)->lpVtbl -> RemoveAttributeIncludeChildren(This,szName,szValue) ) 

#define IVsUserContext_GetAttributePri(This,iAttribute,pszName,fIncludeChildren,piPriority,pbstrName,pbstrValue)	\
    ( (This)->lpVtbl -> GetAttributePri(This,iAttribute,pszName,fIncludeChildren,piPriority,pbstrName,pbstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContext_INTERFACE_DEFINED__ */


#ifndef __IVsUserContextUpdate_INTERFACE_DEFINED__
#define __IVsUserContextUpdate_INTERFACE_DEFINED__

/* interface IVsUserContextUpdate */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsUserContextUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5ED7D1C-61B6-428A-8129-E13B36D9E9A7")
    IVsUserContextUpdate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateUserContext( 
            /* [in] */ __RPC__in_opt IVsUserContext *pCtx,
            /* [in] */ VSCOOKIE dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextUpdate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextUpdate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateUserContext )( 
            IVsUserContextUpdate * This,
            /* [in] */ __RPC__in_opt IVsUserContext *pCtx,
            /* [in] */ VSCOOKIE dwCookie);
        
        END_INTERFACE
    } IVsUserContextUpdateVtbl;

    interface IVsUserContextUpdate
    {
        CONST_VTBL struct IVsUserContextUpdateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextUpdate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextUpdate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextUpdate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextUpdate_UpdateUserContext(This,pCtx,dwCookie)	\
    ( (This)->lpVtbl -> UpdateUserContext(This,pCtx,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextUpdate_INTERFACE_DEFINED__ */


#ifndef __IVsProvideUserContext_INTERFACE_DEFINED__
#define __IVsProvideUserContext_INTERFACE_DEFINED__

/* interface IVsProvideUserContext */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsProvideUserContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("997D7904-D948-4C8B-8BAB-0BDA1E212F6E")
    IVsProvideUserContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUserContext( 
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppctx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsProvideUserContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsProvideUserContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsProvideUserContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsProvideUserContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserContext )( 
            IVsProvideUserContext * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppctx);
        
        END_INTERFACE
    } IVsProvideUserContextVtbl;

    interface IVsProvideUserContext
    {
        CONST_VTBL struct IVsProvideUserContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsProvideUserContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsProvideUserContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsProvideUserContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsProvideUserContext_GetUserContext(This,ppctx)	\
    ( (This)->lpVtbl -> GetUserContext(This,ppctx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsProvideUserContext_INTERFACE_DEFINED__ */


#ifndef __IVsProvideUserContextForObject_INTERFACE_DEFINED__
#define __IVsProvideUserContextForObject_INTERFACE_DEFINED__

/* interface IVsProvideUserContextForObject */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsProvideUserContextForObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F98CCC8A-9C5F-41EB-8421-711C0F1880E6")
    IVsProvideUserContextForObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectContext( 
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppctx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsProvideUserContextForObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsProvideUserContextForObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsProvideUserContextForObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsProvideUserContextForObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectContext )( 
            IVsProvideUserContextForObject * This,
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppctx);
        
        END_INTERFACE
    } IVsProvideUserContextForObjectVtbl;

    interface IVsProvideUserContextForObject
    {
        CONST_VTBL struct IVsProvideUserContextForObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsProvideUserContextForObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsProvideUserContextForObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsProvideUserContextForObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsProvideUserContextForObject_GetObjectContext(This,punk,ppctx)	\
    ( (This)->lpVtbl -> GetObjectContext(This,punk,ppctx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsProvideUserContextForObject_INTERFACE_DEFINED__ */


#ifndef __IVsUserContextItemCollection_INTERFACE_DEFINED__
#define __IVsUserContextItemCollection_INTERFACE_DEFINED__

/* interface IVsUserContextItemCollection */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsUserContextItemCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A6DE4A2-5B3D-46EB-A65C-24C4EF4F396F")
    IVsUserContextItemCollection : public IUnknown
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContextItem **ppItem) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pEnum) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pCount) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ItemAt( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContextItem **ppItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextItemCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextItemCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextItemCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextItemCollection * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IVsUserContextItemCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContextItem **ppItem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IVsUserContextItemCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pEnum);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IVsUserContextItemCollection * This,
            /* [retval][out] */ __RPC__out long *pCount);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemAt )( 
            IVsUserContextItemCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContextItem **ppItem);
        
        END_INTERFACE
    } IVsUserContextItemCollectionVtbl;

    interface IVsUserContextItemCollection
    {
        CONST_VTBL struct IVsUserContextItemCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextItemCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextItemCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextItemCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextItemCollection_get_Item(This,index,ppItem)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppItem) ) 

#define IVsUserContextItemCollection_get__NewEnum(This,pEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pEnum) ) 

#define IVsUserContextItemCollection_get_Count(This,pCount)	\
    ( (This)->lpVtbl -> get_Count(This,pCount) ) 

#define IVsUserContextItemCollection_get_ItemAt(This,index,ppItem)	\
    ( (This)->lpVtbl -> get_ItemAt(This,index,ppItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextItemCollection_INTERFACE_DEFINED__ */


#ifndef __IVsUserContextItem_INTERFACE_DEFINED__
#define __IVsUserContextItem_INTERFACE_DEFINED__

/* interface IVsUserContextItem */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsUserContextItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("720B8500-17B3-4C89-AE84-2CFE7251B4B8")
    IVsUserContextItem : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Command( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCommand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CountAttributes( 
            /* [in] */ __RPC__in LPCOLESTR pszAttrName,
            /* [retval][out] */ __RPC__out int *pc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ __RPC__in LPCOLESTR pszAttrName,
            /* [in] */ int index,
            /* [optional][out] */ __RPC__deref_out_opt BSTR *pbstrName,
            /* [retval][optional][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextItem * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IVsUserContextItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Command )( 
            IVsUserContextItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCommand);
        
        HRESULT ( STDMETHODCALLTYPE *CountAttributes )( 
            IVsUserContextItem * This,
            /* [in] */ __RPC__in LPCOLESTR pszAttrName,
            /* [retval][out] */ __RPC__out int *pc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IVsUserContextItem * This,
            /* [in] */ __RPC__in LPCOLESTR pszAttrName,
            /* [in] */ int index,
            /* [optional][out] */ __RPC__deref_out_opt BSTR *pbstrName,
            /* [retval][optional][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        END_INTERFACE
    } IVsUserContextItemVtbl;

    interface IVsUserContextItem
    {
        CONST_VTBL struct IVsUserContextItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextItem_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IVsUserContextItem_get_Command(This,pbstrCommand)	\
    ( (This)->lpVtbl -> get_Command(This,pbstrCommand) ) 

#define IVsUserContextItem_CountAttributes(This,pszAttrName,pc)	\
    ( (This)->lpVtbl -> CountAttributes(This,pszAttrName,pc) ) 

#define IVsUserContextItem_GetAttribute(This,pszAttrName,index,pbstrName,pbstrValue)	\
    ( (This)->lpVtbl -> GetAttribute(This,pszAttrName,index,pbstrName,pbstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_context_0000_0006 */
/* [local] */ 

typedef 
enum tagAttrValueType
    {	VSHAL_Real	= 0,
	VSHAL_Display	= 1
    } 	ATTRVALUETYPE;



extern RPC_IF_HANDLE __MIDL_itf_context_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context_0000_0006_v0_0_s_ifspec;

#ifndef __IVsHelpAttributeList_INTERFACE_DEFINED__
#define __IVsHelpAttributeList_INTERFACE_DEFINED__

/* interface IVsHelpAttributeList */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsHelpAttributeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A56FB1E-1B2F-4699-8178-63B98E816F35")
    IVsHelpAttributeList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeName( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out int *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateAttributeStatus( 
            /* [in] */ __RPC__in BOOL *afActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeStatusVal( 
            /* [in] */ __RPC__in BSTR bstrValue,
            /* [in] */ ATTRVALUETYPE type,
            /* [out] */ __RPC__out BOOL *pfActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeStatusIndex( 
            /* [in] */ int index,
            /* [out] */ __RPC__out BOOL *pfActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeValue( 
            /* [in] */ int index,
            /* [in] */ ATTRVALUETYPE type,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpAttributeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsHelpAttributeList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsHelpAttributeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsHelpAttributeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeName )( 
            IVsHelpAttributeList * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IVsHelpAttributeList * This,
            /* [out] */ __RPC__out int *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAttributeStatus )( 
            IVsHelpAttributeList * This,
            /* [in] */ __RPC__in BOOL *afActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeStatusVal )( 
            IVsHelpAttributeList * This,
            /* [in] */ __RPC__in BSTR bstrValue,
            /* [in] */ ATTRVALUETYPE type,
            /* [out] */ __RPC__out BOOL *pfActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeStatusIndex )( 
            IVsHelpAttributeList * This,
            /* [in] */ int index,
            /* [out] */ __RPC__out BOOL *pfActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeValue )( 
            IVsHelpAttributeList * This,
            /* [in] */ int index,
            /* [in] */ ATTRVALUETYPE type,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        END_INTERFACE
    } IVsHelpAttributeListVtbl;

    interface IVsHelpAttributeList
    {
        CONST_VTBL struct IVsHelpAttributeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpAttributeList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsHelpAttributeList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsHelpAttributeList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsHelpAttributeList_GetAttributeName(This,bstrName)	\
    ( (This)->lpVtbl -> GetAttributeName(This,bstrName) ) 

#define IVsHelpAttributeList_GetCount(This,pCount)	\
    ( (This)->lpVtbl -> GetCount(This,pCount) ) 

#define IVsHelpAttributeList_UpdateAttributeStatus(This,afActive)	\
    ( (This)->lpVtbl -> UpdateAttributeStatus(This,afActive) ) 

#define IVsHelpAttributeList_GetAttributeStatusVal(This,bstrValue,type,pfActive)	\
    ( (This)->lpVtbl -> GetAttributeStatusVal(This,bstrValue,type,pfActive) ) 

#define IVsHelpAttributeList_GetAttributeStatusIndex(This,index,pfActive)	\
    ( (This)->lpVtbl -> GetAttributeStatusIndex(This,index,pfActive) ) 

#define IVsHelpAttributeList_GetAttributeValue(This,index,type,pbstrValue)	\
    ( (This)->lpVtbl -> GetAttributeValue(This,index,type,pbstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsHelpAttributeList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_context_0000_0007 */
/* [local] */ 

#define VSUC_CURRENT_F1 ((LPCOLESTR)1)


extern RPC_IF_HANDLE __MIDL_itf_context_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context_0000_0007_v0_0_s_ifspec;

#ifndef __IVsMonitorUserContext_INTERFACE_DEFINED__
#define __IVsMonitorUserContext_INTERFACE_DEFINED__

/* interface IVsMonitorUserContext */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsMonitorUserContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C074FDB-3D7D-4512-9604-72B3B0A5F609")
    IVsMonitorUserContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ __RPC__in_opt IServiceProvider *pSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ApplicationContext( 
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ApplicationContext( 
            /* [in] */ __RPC__in_opt IVsUserContext *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyContext( 
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextItems( 
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **pplist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindTargetItems( 
            /* [in] */ __RPC__in LPCOLESTR pszTargetAttr,
            /* [in] */ __RPC__in LPCOLESTR pszTargetAttrValue,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **ppList,
            /* [out] */ __RPC__out BOOL *pfF1Kwd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterItemProvider( 
            /* [in] */ __RPC__in_opt IVsUserContextItemProvider *pProvider,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterItemProvider( 
            /* [in] */ VSCOOKIE dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseContextItemEvents( 
            /* [in] */ __RPC__in_opt IVsUserContextItemEvents *pEvents,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseContextItemEvent( 
            /* [in] */ VSCOOKIE dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCtxBagAttr( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetNextCtxBagAttr( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrevAttrCache( 
            /* [out] */ __RPC__deref_out_opt BSTR **pbstrCacheArray,
            /* [out] */ __RPC__deref_out_opt int **pnCurrNumStored,
            /* [out] */ __RPC__out int *pnMaxNumStored) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCtxBag( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIdleAvailable( 
            /* [out] */ __RPC__out BOOL *pfIdleAvail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTopicTypeFilter( 
            /* [in] */ __RPC__in_opt IVsHelpAttributeList *pTopicTypeList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetF1Kwd( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrKwd,
            /* [out] */ __RPC__out BOOL *fF1Kwd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsF1Lookup( 
            /* [out] */ __RPC__out BOOL *fF1Lookup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsMonitorUserContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsMonitorUserContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsMonitorUserContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSite )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in_opt IServiceProvider *pSP);
        
        HRESULT ( STDMETHODCALLTYPE *get_ApplicationContext )( 
            IVsMonitorUserContext * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *put_ApplicationContext )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in_opt IVsUserContext *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEmptyContext )( 
            IVsMonitorUserContext * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsUserContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextItems )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **pplist);
        
        HRESULT ( STDMETHODCALLTYPE *FindTargetItems )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in LPCOLESTR pszTargetAttr,
            /* [in] */ __RPC__in LPCOLESTR pszTargetAttrValue,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **ppList,
            /* [out] */ __RPC__out BOOL *pfF1Kwd);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterItemProvider )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in_opt IVsUserContextItemProvider *pProvider,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterItemProvider )( 
            IVsMonitorUserContext * This,
            /* [in] */ VSCOOKIE dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseContextItemEvents )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in_opt IVsUserContextItemEvents *pEvents,
            /* [retval][out] */ __RPC__out VSCOOKIE *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseContextItemEvent )( 
            IVsMonitorUserContext * This,
            /* [in] */ VSCOOKIE dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCtxBagAttr )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrVal);
        
        HRESULT ( STDMETHODCALLTYPE *ResetNextCtxBagAttr )( 
            IVsMonitorUserContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevAttrCache )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__deref_out_opt BSTR **pbstrCacheArray,
            /* [out] */ __RPC__deref_out_opt int **pnCurrNumStored,
            /* [out] */ __RPC__out int *pnMaxNumStored);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCtxBag )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAttrVal);
        
        HRESULT ( STDMETHODCALLTYPE *IsIdleAvailable )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__out BOOL *pfIdleAvail);
        
        HRESULT ( STDMETHODCALLTYPE *SetTopicTypeFilter )( 
            IVsMonitorUserContext * This,
            /* [in] */ __RPC__in_opt IVsHelpAttributeList *pTopicTypeList);
        
        HRESULT ( STDMETHODCALLTYPE *GetF1Kwd )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrKwd,
            /* [out] */ __RPC__out BOOL *fF1Kwd);
        
        HRESULT ( STDMETHODCALLTYPE *IsF1Lookup )( 
            IVsMonitorUserContext * This,
            /* [out] */ __RPC__out BOOL *fF1Lookup);
        
        END_INTERFACE
    } IVsMonitorUserContextVtbl;

    interface IVsMonitorUserContext
    {
        CONST_VTBL struct IVsMonitorUserContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsMonitorUserContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsMonitorUserContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsMonitorUserContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsMonitorUserContext_SetSite(This,pSP)	\
    ( (This)->lpVtbl -> SetSite(This,pSP) ) 

#define IVsMonitorUserContext_get_ApplicationContext(This,ppContext)	\
    ( (This)->lpVtbl -> get_ApplicationContext(This,ppContext) ) 

#define IVsMonitorUserContext_put_ApplicationContext(This,pContext)	\
    ( (This)->lpVtbl -> put_ApplicationContext(This,pContext) ) 

#define IVsMonitorUserContext_CreateEmptyContext(This,ppContext)	\
    ( (This)->lpVtbl -> CreateEmptyContext(This,ppContext) ) 

#define IVsMonitorUserContext_GetContextItems(This,pplist)	\
    ( (This)->lpVtbl -> GetContextItems(This,pplist) ) 

#define IVsMonitorUserContext_FindTargetItems(This,pszTargetAttr,pszTargetAttrValue,ppList,pfF1Kwd)	\
    ( (This)->lpVtbl -> FindTargetItems(This,pszTargetAttr,pszTargetAttrValue,ppList,pfF1Kwd) ) 

#define IVsMonitorUserContext_RegisterItemProvider(This,pProvider,pdwCookie)	\
    ( (This)->lpVtbl -> RegisterItemProvider(This,pProvider,pdwCookie) ) 

#define IVsMonitorUserContext_UnregisterItemProvider(This,dwCookie)	\
    ( (This)->lpVtbl -> UnregisterItemProvider(This,dwCookie) ) 

#define IVsMonitorUserContext_AdviseContextItemEvents(This,pEvents,pdwCookie)	\
    ( (This)->lpVtbl -> AdviseContextItemEvents(This,pEvents,pdwCookie) ) 

#define IVsMonitorUserContext_UnadviseContextItemEvent(This,dwCookie)	\
    ( (This)->lpVtbl -> UnadviseContextItemEvent(This,dwCookie) ) 

#define IVsMonitorUserContext_GetNextCtxBagAttr(This,pbstrAttrName,pbstrAttrVal)	\
    ( (This)->lpVtbl -> GetNextCtxBagAttr(This,pbstrAttrName,pbstrAttrVal) ) 

#define IVsMonitorUserContext_ResetNextCtxBagAttr(This)	\
    ( (This)->lpVtbl -> ResetNextCtxBagAttr(This) ) 

#define IVsMonitorUserContext_GetPrevAttrCache(This,pbstrCacheArray,pnCurrNumStored,pnMaxNumStored)	\
    ( (This)->lpVtbl -> GetPrevAttrCache(This,pbstrCacheArray,pnCurrNumStored,pnMaxNumStored) ) 

#define IVsMonitorUserContext_GetNextCtxBag(This,pbstrAttrName,pbstrAttrVal)	\
    ( (This)->lpVtbl -> GetNextCtxBag(This,pbstrAttrName,pbstrAttrVal) ) 

#define IVsMonitorUserContext_IsIdleAvailable(This,pfIdleAvail)	\
    ( (This)->lpVtbl -> IsIdleAvailable(This,pfIdleAvail) ) 

#define IVsMonitorUserContext_SetTopicTypeFilter(This,pTopicTypeList)	\
    ( (This)->lpVtbl -> SetTopicTypeFilter(This,pTopicTypeList) ) 

#define IVsMonitorUserContext_GetF1Kwd(This,pbstrKwd,fF1Kwd)	\
    ( (This)->lpVtbl -> GetF1Kwd(This,pbstrKwd,fF1Kwd) ) 

#define IVsMonitorUserContext_IsF1Lookup(This,fF1Lookup)	\
    ( (This)->lpVtbl -> IsF1Lookup(This,fF1Lookup) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsMonitorUserContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_context_0000_0008 */
/* [local] */ 


enum _VSCIPPROPID
    {	VSCIPPROPID_NIL	= -1,
	VSCIPPROPID_LookupType	= 100,
	VSCIPPROPID_Customize	= 200
    } ;
typedef LONG VSCIPPROPID;



extern RPC_IF_HANDLE __MIDL_itf_context_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context_0000_0008_v0_0_s_ifspec;

#ifndef __IVsUserContextItemProvider_INTERFACE_DEFINED__
#define __IVsUserContextItemProvider_INTERFACE_DEFINED__

/* interface IVsUserContextItemProvider */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsUserContextItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("715C98B7-05FB-4A1A-86C8-FF00CE2E5D64")
    IVsUserContextItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ VSCIPPROPID property,
            /* [retval][out] */ __RPC__out VARIANT *pvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ VSCIPPROPID property,
            /* [in] */ VARIANT var) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeywordLookup( 
            /* [in] */ __RPC__in LPCOLESTR pwzTargetAttr,
            /* [in] */ __RPC__in LPCOLESTR pwzTargetAttrValue,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **ppList,
            /* [in] */ __RPC__in_opt IVsMonitorUserContext *pCMUC,
            /* [in] */ BOOL fCheckIdle,
            /* [in] */ BOOL fContinueInterrupt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PackedAttributeLookup( 
            /* [in] */ __RPC__in LPCOLESTR pwzRequired,
            /* [in] */ __RPC__in LPCOLESTR pwzScope,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **ppList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupEnabled( 
            /* [out] */ __RPC__out BOOL *pfLookupEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IVsUserContextItemProvider * This,
            /* [in] */ VSCIPPROPID property,
            /* [retval][out] */ __RPC__out VARIANT *pvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IVsUserContextItemProvider * This,
            /* [in] */ VSCIPPROPID property,
            /* [in] */ VARIANT var);
        
        HRESULT ( STDMETHODCALLTYPE *KeywordLookup )( 
            IVsUserContextItemProvider * This,
            /* [in] */ __RPC__in LPCOLESTR pwzTargetAttr,
            /* [in] */ __RPC__in LPCOLESTR pwzTargetAttrValue,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **ppList,
            /* [in] */ __RPC__in_opt IVsMonitorUserContext *pCMUC,
            /* [in] */ BOOL fCheckIdle,
            /* [in] */ BOOL fContinueInterrupt);
        
        HRESULT ( STDMETHODCALLTYPE *PackedAttributeLookup )( 
            IVsUserContextItemProvider * This,
            /* [in] */ __RPC__in LPCOLESTR pwzRequired,
            /* [in] */ __RPC__in LPCOLESTR pwzScope,
            /* [out] */ __RPC__deref_out_opt IVsUserContextItemCollection **ppList);
        
        HRESULT ( STDMETHODCALLTYPE *LookupEnabled )( 
            IVsUserContextItemProvider * This,
            /* [out] */ __RPC__out BOOL *pfLookupEnabled);
        
        END_INTERFACE
    } IVsUserContextItemProviderVtbl;

    interface IVsUserContextItemProvider
    {
        CONST_VTBL struct IVsUserContextItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextItemProvider_GetProperty(This,property,pvar)	\
    ( (This)->lpVtbl -> GetProperty(This,property,pvar) ) 

#define IVsUserContextItemProvider_SetProperty(This,property,var)	\
    ( (This)->lpVtbl -> SetProperty(This,property,var) ) 

#define IVsUserContextItemProvider_KeywordLookup(This,pwzTargetAttr,pwzTargetAttrValue,ppList,pCMUC,fCheckIdle,fContinueInterrupt)	\
    ( (This)->lpVtbl -> KeywordLookup(This,pwzTargetAttr,pwzTargetAttrValue,ppList,pCMUC,fCheckIdle,fContinueInterrupt) ) 

#define IVsUserContextItemProvider_PackedAttributeLookup(This,pwzRequired,pwzScope,ppList)	\
    ( (This)->lpVtbl -> PackedAttributeLookup(This,pwzRequired,pwzScope,ppList) ) 

#define IVsUserContextItemProvider_LookupEnabled(This,pfLookupEnabled)	\
    ( (This)->lpVtbl -> LookupEnabled(This,pfLookupEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextItemProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_context_0000_0009 */
/* [local] */ 


enum _LIMITTOPICSOURCE
    {	CCW_LimKwd_SelOnly	= 0,
	CCW_LimKwd_NoAmbient	= 1,
	CCW_LimKwd_All	= 2,
	CCW_LimKwd_Last	= 3
    } ;
typedef LONG LIMITTOPICSOURCE;



extern RPC_IF_HANDLE __MIDL_itf_context_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context_0000_0009_v0_0_s_ifspec;

#ifndef __IVsUserContextCustomize_INTERFACE_DEFINED__
#define __IVsUserContextCustomize_INTERFACE_DEFINED__

/* interface IVsUserContextCustomize */
/* [version][object][uuid] */ 


EXTERN_C const IID IID_IVsUserContextCustomize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F817159-761D-447e-9600-4C3387F4C0FD")
    IVsUserContextCustomize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLimitKeywordSource( 
            /* [retval][out] */ __RPC__out LONG *pLimKwdSrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextCustomizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextCustomize * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextCustomize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextCustomize * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLimitKeywordSource )( 
            IVsUserContextCustomize * This,
            /* [retval][out] */ __RPC__out LONG *pLimKwdSrc);
        
        END_INTERFACE
    } IVsUserContextCustomizeVtbl;

    interface IVsUserContextCustomize
    {
        CONST_VTBL struct IVsUserContextCustomizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextCustomize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextCustomize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextCustomize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextCustomize_GetLimitKeywordSource(This,pLimKwdSrc)	\
    ( (This)->lpVtbl -> GetLimitKeywordSource(This,pLimKwdSrc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextCustomize_INTERFACE_DEFINED__ */


#ifndef __IVsUserContextItemEvents_INTERFACE_DEFINED__
#define __IVsUserContextItemEvents_INTERFACE_DEFINED__

/* interface IVsUserContextItemEvents */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsUserContextItemEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2078F0E-A310-420A-BA27-16531905B88F")
    IVsUserContextItemEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUserContextItemsAvailable( 
            /* [in] */ __RPC__in_opt IVsUserContextItemCollection *pList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextItemEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextItemEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextItemEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextItemEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUserContextItemsAvailable )( 
            IVsUserContextItemEvents * This,
            /* [in] */ __RPC__in_opt IVsUserContextItemCollection *pList);
        
        END_INTERFACE
    } IVsUserContextItemEventsVtbl;

    interface IVsUserContextItemEvents
    {
        CONST_VTBL struct IVsUserContextItemEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextItemEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextItemEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextItemEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextItemEvents_OnUserContextItemsAvailable(This,pList)	\
    ( (This)->lpVtbl -> OnUserContextItemsAvailable(This,pList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextItemEvents_INTERFACE_DEFINED__ */



#ifndef __VsContext_LIBRARY_DEFINED__
#define __VsContext_LIBRARY_DEFINED__

/* library VsContext */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_VsContext;

EXTERN_C const CLSID CLSID_VsContextClass;

#ifdef __cplusplus

class DECLSPEC_UUID("3c1f59c6-69cf-11d2-aa7c-00c04f990343")
VsContextClass;
#endif
#endif /* __VsContext_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_context_0000_0011 */
/* [local] */ 

#define SID_SVsMonitorUserContext IID_IVsMonitorUserContext
#define HH_1x_ATTR L"HtmlHelp_1.X_LookupInfo"
#define KWD_GUID L"KWD_GUID"
#define KEYWORD_CS L"KEYWORD_CS"


extern RPC_IF_HANDLE __MIDL_itf_context_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context_0000_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\containedlanguage.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for containedlanguage.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __containedlanguage_h__
#define __containedlanguage_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsIntellisenseProjectManager_FWD_DEFINED__
#define __IVsIntellisenseProjectManager_FWD_DEFINED__
typedef interface IVsIntellisenseProjectManager IVsIntellisenseProjectManager;
#endif 	/* __IVsIntellisenseProjectManager_FWD_DEFINED__ */


#ifndef __SVsIntellisenseProjectManager_FWD_DEFINED__
#define __SVsIntellisenseProjectManager_FWD_DEFINED__
typedef interface SVsIntellisenseProjectManager SVsIntellisenseProjectManager;
#endif 	/* __SVsIntellisenseProjectManager_FWD_DEFINED__ */


#ifndef __IVsIntellisenseEngine_FWD_DEFINED__
#define __IVsIntellisenseEngine_FWD_DEFINED__
typedef interface IVsIntellisenseEngine IVsIntellisenseEngine;
#endif 	/* __IVsIntellisenseEngine_FWD_DEFINED__ */


#ifndef __SVsIntellisenseEngine_FWD_DEFINED__
#define __SVsIntellisenseEngine_FWD_DEFINED__
typedef interface SVsIntellisenseEngine SVsIntellisenseEngine;
#endif 	/* __SVsIntellisenseEngine_FWD_DEFINED__ */


#ifndef __IVsIntellisenseProjectEventSink_FWD_DEFINED__
#define __IVsIntellisenseProjectEventSink_FWD_DEFINED__
typedef interface IVsIntellisenseProjectEventSink IVsIntellisenseProjectEventSink;
#endif 	/* __IVsIntellisenseProjectEventSink_FWD_DEFINED__ */


#ifndef __IVsItemTypeResolutionService_FWD_DEFINED__
#define __IVsItemTypeResolutionService_FWD_DEFINED__
typedef interface IVsItemTypeResolutionService IVsItemTypeResolutionService;
#endif 	/* __IVsItemTypeResolutionService_FWD_DEFINED__ */


#ifndef __IVsItemTypeResolutionSite_FWD_DEFINED__
#define __IVsItemTypeResolutionSite_FWD_DEFINED__
typedef interface IVsItemTypeResolutionSite IVsItemTypeResolutionSite;
#endif 	/* __IVsItemTypeResolutionSite_FWD_DEFINED__ */


#ifndef __IVsIntellisenseProjectHost_FWD_DEFINED__
#define __IVsIntellisenseProjectHost_FWD_DEFINED__
typedef interface IVsIntellisenseProjectHost IVsIntellisenseProjectHost;
#endif 	/* __IVsIntellisenseProjectHost_FWD_DEFINED__ */


#ifndef __SVsIntellisenseProjectHost_FWD_DEFINED__
#define __SVsIntellisenseProjectHost_FWD_DEFINED__
typedef interface SVsIntellisenseProjectHost SVsIntellisenseProjectHost;
#endif 	/* __SVsIntellisenseProjectHost_FWD_DEFINED__ */


#ifndef __IVsIntellisenseProject_FWD_DEFINED__
#define __IVsIntellisenseProject_FWD_DEFINED__
typedef interface IVsIntellisenseProject IVsIntellisenseProject;
#endif 	/* __IVsIntellisenseProject_FWD_DEFINED__ */


#ifndef __IVsDataEnvironment_FWD_DEFINED__
#define __IVsDataEnvironment_FWD_DEFINED__
typedef interface IVsDataEnvironment IVsDataEnvironment;
#endif 	/* __IVsDataEnvironment_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "oleipc.h"
#include "vsshell.h"
#include "singlefileeditor.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_containedlanguage_0000_0000 */
/* [local] */ 

#pragma once







enum INTELLIPROJSTATUS
    {	INTELLIPROJSTATUS_LOADING	= 1,
	INTELLIPROJSTATUS_LOADCOMPLETE	= 2,
	INTELLIPROJSTATUS_CLOSE	= 3,
	INTELLIPROJSTATUS_REFRESH	= 4
    } ;

enum HOSTPROPID
    {	HOSTPROPID_PROJECTNAME	= 1,
	HOSTPROPID_HIERARCHY	= 2,
	HOSTPROPID_RELURL	= 3,
	HOSTPROPID_INTELLISENSECACHE_FILENAME	= 4
    } ;

enum REFERENCECHANGETYPE
    {	REFERENCE_Added	= 1,
	REFERENCE_Removed	= 2,
	REFERENCE_Changed	= 3
    } ;


extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0000_v0_0_s_ifspec;

#ifndef __IVsIntellisenseProjectManager_INTERFACE_DEFINED__
#define __IVsIntellisenseProjectManager_INTERFACE_DEFINED__

/* interface IVsIntellisenseProjectManager */
/* [uuid][object] */ 


EXTERN_C const IID IID_IVsIntellisenseProjectManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B299765F-1FC2-41a7-BEC1-64721D86E658")
    IVsIntellisenseProjectManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseIntellisenseProjectEvents( 
            /* [in] */ __RPC__in_opt IVsIntellisenseProjectEventSink *pSink,
            /* [out] */ __RPC__out VSCOOKIE *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseIntellisenseProjectEvents( 
            /* [in] */ VSCOOKIE dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainedLanguageFactory( 
            /* [in] */ __RPC__in BSTR bstrLanguage,
            /* [out] */ __RPC__deref_out_opt IVsContainedLanguageFactory **ppContainedLanguageFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseIntellisenseProject( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEditorReady( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteIntellisenseProjectLoad( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsIntellisenseProjectManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsIntellisenseProjectManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsIntellisenseProjectManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsIntellisenseProjectManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseIntellisenseProjectEvents )( 
            IVsIntellisenseProjectManager * This,
            /* [in] */ __RPC__in_opt IVsIntellisenseProjectEventSink *pSink,
            /* [out] */ __RPC__out VSCOOKIE *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseIntellisenseProjectEvents )( 
            IVsIntellisenseProjectManager * This,
            /* [in] */ VSCOOKIE dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainedLanguageFactory )( 
            IVsIntellisenseProjectManager * This,
            /* [in] */ __RPC__in BSTR bstrLanguage,
            /* [out] */ __RPC__deref_out_opt IVsContainedLanguageFactory **ppContainedLanguageFactory);
        
        HRESULT ( STDMETHODCALLTYPE *CloseIntellisenseProject )( 
            IVsIntellisenseProjectManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEditorReady )( 
            IVsIntellisenseProjectManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompleteIntellisenseProjectLoad )( 
            IVsIntellisenseProjectManager * This);
        
        END_INTERFACE
    } IVsIntellisenseProjectManagerVtbl;

    interface IVsIntellisenseProjectManager
    {
        CONST_VTBL struct IVsIntellisenseProjectManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsIntellisenseProjectManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsIntellisenseProjectManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsIntellisenseProjectManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsIntellisenseProjectManager_AdviseIntellisenseProjectEvents(This,pSink,pdwCookie)	\
    ( (This)->lpVtbl -> AdviseIntellisenseProjectEvents(This,pSink,pdwCookie) ) 

#define IVsIntellisenseProjectManager_UnadviseIntellisenseProjectEvents(This,dwCookie)	\
    ( (This)->lpVtbl -> UnadviseIntellisenseProjectEvents(This,dwCookie) ) 

#define IVsIntellisenseProjectManager_GetContainedLanguageFactory(This,bstrLanguage,ppContainedLanguageFactory)	\
    ( (This)->lpVtbl -> GetContainedLanguageFactory(This,bstrLanguage,ppContainedLanguageFactory) ) 

#define IVsIntellisenseProjectManager_CloseIntellisenseProject(This)	\
    ( (This)->lpVtbl -> CloseIntellisenseProject(This) ) 

#define IVsIntellisenseProjectManager_OnEditorReady(This)	\
    ( (This)->lpVtbl -> OnEditorReady(This) ) 

#define IVsIntellisenseProjectManager_CompleteIntellisenseProjectLoad(This)	\
    ( (This)->lpVtbl -> CompleteIntellisenseProjectLoad(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsIntellisenseProjectManager_INTERFACE_DEFINED__ */


#ifndef __SVsIntellisenseProjectManager_INTERFACE_DEFINED__
#define __SVsIntellisenseProjectManager_INTERFACE_DEFINED__

/* interface SVsIntellisenseProjectManager */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsIntellisenseProjectManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CB6B09C-64F5-4579-8593-7720DAB2EF8D")
    SVsIntellisenseProjectManager : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsIntellisenseProjectManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsIntellisenseProjectManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsIntellisenseProjectManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsIntellisenseProjectManager * This);
        
        END_INTERFACE
    } SVsIntellisenseProjectManagerVtbl;

    interface SVsIntellisenseProjectManager
    {
        CONST_VTBL struct SVsIntellisenseProjectManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsIntellisenseProjectManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsIntellisenseProjectManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsIntellisenseProjectManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsIntellisenseProjectManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_containedlanguage_0000_0002 */
/* [local] */ 

#define SID_SVsIntellisenseProjectManager IID_SVsIntellisenseProjectManager


extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0002_v0_0_s_ifspec;

#ifndef __IVsIntellisenseEngine_INTERFACE_DEFINED__
#define __IVsIntellisenseEngine_INTERFACE_DEFINED__

/* interface IVsIntellisenseEngine */
/* [uuid][object] */ 


EXTERN_C const IID IID_IVsIntellisenseEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4371079A-47C3-4b7a-93AE-BFB90FEDB8F0")
    IVsIntellisenseEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Load( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unload( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportsLoad( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsIntellisenseEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsIntellisenseEngine * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsIntellisenseEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsIntellisenseEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IVsIntellisenseEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unload )( 
            IVsIntellisenseEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsLoad )( 
            IVsIntellisenseEngine * This);
        
        END_INTERFACE
    } IVsIntellisenseEngineVtbl;

    interface IVsIntellisenseEngine
    {
        CONST_VTBL struct IVsIntellisenseEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsIntellisenseEngine_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsIntellisenseEngine_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsIntellisenseEngine_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsIntellisenseEngine_Load(This)	\
    ( (This)->lpVtbl -> Load(This) ) 

#define IVsIntellisenseEngine_Unload(This)	\
    ( (This)->lpVtbl -> Unload(This) ) 

#define IVsIntellisenseEngine_SupportsLoad(This)	\
    ( (This)->lpVtbl -> SupportsLoad(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsIntellisenseEngine_INTERFACE_DEFINED__ */


#ifndef __SVsIntellisenseEngine_INTERFACE_DEFINED__
#define __SVsIntellisenseEngine_INTERFACE_DEFINED__

/* interface SVsIntellisenseEngine */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsIntellisenseEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D380C630-E46F-40e1-B71D-F3D1682C5AA8")
    SVsIntellisenseEngine : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsIntellisenseEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsIntellisenseEngine * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsIntellisenseEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsIntellisenseEngine * This);
        
        END_INTERFACE
    } SVsIntellisenseEngineVtbl;

    interface SVsIntellisenseEngine
    {
        CONST_VTBL struct SVsIntellisenseEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsIntellisenseEngine_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsIntellisenseEngine_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsIntellisenseEngine_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsIntellisenseEngine_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_containedlanguage_0000_0004 */
/* [local] */ 

#define SID_SVsIntellisenseEngine IID_SVsIntellisenseEngine


extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0004_v0_0_s_ifspec;

#ifndef __IVsIntellisenseProjectEventSink_INTERFACE_DEFINED__
#define __IVsIntellisenseProjectEventSink_INTERFACE_DEFINED__

/* interface IVsIntellisenseProjectEventSink */
/* [object][version][uuid] */ 


EXTERN_C const IID IID_IVsIntellisenseProjectEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DFB5C0C2-817E-4a19-8C6D-E387FD68B50B")
    IVsIntellisenseProjectEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ DWORD dwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnReferenceChange( 
            /* [in] */ DWORD dwChangeType,
            __RPC__in LPCWSTR pszAssemblyPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnConfigChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCodeFileChange( 
            /* [in] */ __RPC__in LPCWSTR pszOldCodeFile,
            /* [in] */ __RPC__in LPCWSTR pszNewCodeFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsIntellisenseProjectEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsIntellisenseProjectEventSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsIntellisenseProjectEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsIntellisenseProjectEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            IVsIntellisenseProjectEventSink * This,
            /* [in] */ DWORD dwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *OnReferenceChange )( 
            IVsIntellisenseProjectEventSink * This,
            /* [in] */ DWORD dwChangeType,
            __RPC__in LPCWSTR pszAssemblyPath);
        
        HRESULT ( STDMETHODCALLTYPE *OnConfigChange )( 
            IVsIntellisenseProjectEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCodeFileChange )( 
            IVsIntellisenseProjectEventSink * This,
            /* [in] */ __RPC__in LPCWSTR pszOldCodeFile,
            /* [in] */ __RPC__in LPCWSTR pszNewCodeFile);
        
        END_INTERFACE
    } IVsIntellisenseProjectEventSinkVtbl;

    interface IVsIntellisenseProjectEventSink
    {
        CONST_VTBL struct IVsIntellisenseProjectEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsIntellisenseProjectEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsIntellisenseProjectEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsIntellisenseProjectEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsIntellisenseProjectEventSink_OnStatusChange(This,dwStatus)	\
    ( (This)->lpVtbl -> OnStatusChange(This,dwStatus) ) 

#define IVsIntellisenseProjectEventSink_OnReferenceChange(This,dwChangeType,pszAssemblyPath)	\
    ( (This)->lpVtbl -> OnReferenceChange(This,dwChangeType,pszAssemblyPath) ) 

#define IVsIntellisenseProjectEventSink_OnConfigChange(This)	\
    ( (This)->lpVtbl -> OnConfigChange(This) ) 

#define IVsIntellisenseProjectEventSink_OnCodeFileChange(This,pszOldCodeFile,pszNewCodeFile)	\
    ( (This)->lpVtbl -> OnCodeFileChange(This,pszOldCodeFile,pszNewCodeFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsIntellisenseProjectEventSink_INTERFACE_DEFINED__ */


#ifndef __IVsItemTypeResolutionService_INTERFACE_DEFINED__
#define __IVsItemTypeResolutionService_INTERFACE_DEFINED__

/* interface IVsItemTypeResolutionService */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVsItemTypeResolutionService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6CF64F7-8863-4e50-9DF1-892AA83D70D7")
    IVsItemTypeResolutionService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ __RPC__in_opt IUnknown *punkVsItemTypeResolutionSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeReferences( 
            /* [in] */ __RPC__in_opt IUnknown *punkCompilerParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceAdded( 
            /* [in] */ __RPC__in BSTR pszReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceRemoved( 
            /* [in] */ __RPC__in BSTR pszReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceChanged( 
            /* [in] */ __RPC__in BSTR pszReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsItemTypeResolutionServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsItemTypeResolutionService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsItemTypeResolutionService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsItemTypeResolutionService * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSite )( 
            IVsItemTypeResolutionService * This,
            /* [in] */ __RPC__in_opt IUnknown *punkVsItemTypeResolutionSite);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeReferences )( 
            IVsItemTypeResolutionService * This,
            /* [in] */ __RPC__in_opt IUnknown *punkCompilerParameters);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceAdded )( 
            IVsItemTypeResolutionService * This,
            /* [in] */ __RPC__in BSTR pszReference);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceRemoved )( 
            IVsItemTypeResolutionService * This,
            /* [in] */ __RPC__in BSTR pszReference);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceChanged )( 
            IVsItemTypeResolutionService * This,
            /* [in] */ __RPC__in BSTR pszReference);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IVsItemTypeResolutionService * This);
        
        END_INTERFACE
    } IVsItemTypeResolutionServiceVtbl;

    interface IVsItemTypeResolutionService
    {
        CONST_VTBL struct IVsItemTypeResolutionServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsItemTypeResolutionService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsItemTypeResolutionService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsItemTypeResolutionService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsItemTypeResolutionService_SetSite(This,punkVsItemTypeResolutionSite)	\
    ( (This)->lpVtbl -> SetSite(This,punkVsItemTypeResolutionSite) ) 

#define IVsItemTypeResolutionService_InitializeReferences(This,punkCompilerParameters)	\
    ( (This)->lpVtbl -> InitializeReferences(This,punkCompilerParameters) ) 

#define IVsItemTypeResolutionService_ReferenceAdded(This,pszReference)	\
    ( (This)->lpVtbl -> ReferenceAdded(This,pszReference) ) 

#define IVsItemTypeResolutionService_ReferenceRemoved(This,pszReference)	\
    ( (This)->lpVtbl -> ReferenceRemoved(This,pszReference) ) 

#define IVsItemTypeResolutionService_ReferenceChanged(This,pszReference)	\
    ( (This)->lpVtbl -> ReferenceChanged(This,pszReference) ) 

#define IVsItemTypeResolutionService_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsItemTypeResolutionService_INTERFACE_DEFINED__ */


#ifndef __IVsItemTypeResolutionSite_INTERFACE_DEFINED__
#define __IVsItemTypeResolutionSite_INTERFACE_DEFINED__

/* interface IVsItemTypeResolutionSite */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVsItemTypeResolutionSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45ABED49-8D6E-47b8-A0D6-C9F2405817C6")
    IVsItemTypeResolutionSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddReference( 
            /* [in] */ __RPC__in BSTR bstrReferencePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForReferencesReady( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCodeDirectoryAssembly( 
            /* [in] */ __RPC__in BSTR bstrAssembly,
            /* [out] */ __RPC__out BOOL *pfIsCodeAssembly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsItemTypeResolutionSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsItemTypeResolutionSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsItemTypeResolutionSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsItemTypeResolutionSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddReference )( 
            IVsItemTypeResolutionSite * This,
            /* [in] */ __RPC__in BSTR bstrReferencePath);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForReferencesReady )( 
            IVsItemTypeResolutionSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsCodeDirectoryAssembly )( 
            IVsItemTypeResolutionSite * This,
            /* [in] */ __RPC__in BSTR bstrAssembly,
            /* [out] */ __RPC__out BOOL *pfIsCodeAssembly);
        
        END_INTERFACE
    } IVsItemTypeResolutionSiteVtbl;

    interface IVsItemTypeResolutionSite
    {
        CONST_VTBL struct IVsItemTypeResolutionSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsItemTypeResolutionSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsItemTypeResolutionSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsItemTypeResolutionSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsItemTypeResolutionSite_AddReference(This,bstrReferencePath)	\
    ( (This)->lpVtbl -> AddReference(This,bstrReferencePath) ) 

#define IVsItemTypeResolutionSite_WaitForReferencesReady(This)	\
    ( (This)->lpVtbl -> WaitForReferencesReady(This) ) 

#define IVsItemTypeResolutionSite_IsCodeDirectoryAssembly(This,bstrAssembly,pfIsCodeAssembly)	\
    ( (This)->lpVtbl -> IsCodeDirectoryAssembly(This,bstrAssembly,pfIsCodeAssembly) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsItemTypeResolutionSite_INTERFACE_DEFINED__ */


#ifndef __IVsIntellisenseProjectHost_INTERFACE_DEFINED__
#define __IVsIntellisenseProjectHost_INTERFACE_DEFINED__

/* interface IVsIntellisenseProjectHost */
/* [uuid][object] */ 


EXTERN_C const IID IID_IVsIntellisenseProjectHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6C62F743-D2D3-46B3-BFBC-F04B54EE3f79")
    IVsIntellisenseProjectHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHostProperty( 
            /* [in] */ DWORD dwPropID,
            /* [retval][out] */ __RPC__out VARIANT *pvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompilerOptions( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputAssembly( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrOutputAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFileCodeModel( 
            /* [in] */ __RPC__in LPCWSTR pszFilename,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCodeModel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsIntellisenseProjectHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsIntellisenseProjectHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsIntellisenseProjectHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsIntellisenseProjectHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostProperty )( 
            IVsIntellisenseProjectHost * This,
            /* [in] */ DWORD dwPropID,
            /* [retval][out] */ __RPC__out VARIANT *pvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompilerOptions )( 
            IVsIntellisenseProjectHost * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputAssembly )( 
            IVsIntellisenseProjectHost * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrOutputAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFileCodeModel )( 
            IVsIntellisenseProjectHost * This,
            /* [in] */ __RPC__in LPCWSTR pszFilename,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCodeModel);
        
        END_INTERFACE
    } IVsIntellisenseProjectHostVtbl;

    interface IVsIntellisenseProjectHost
    {
        CONST_VTBL struct IVsIntellisenseProjectHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsIntellisenseProjectHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsIntellisenseProjectHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsIntellisenseProjectHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsIntellisenseProjectHost_GetHostProperty(This,dwPropID,pvar)	\
    ( (This)->lpVtbl -> GetHostProperty(This,dwPropID,pvar) ) 

#define IVsIntellisenseProjectHost_GetCompilerOptions(This,pbstrOptions)	\
    ( (This)->lpVtbl -> GetCompilerOptions(This,pbstrOptions) ) 

#define IVsIntellisenseProjectHost_GetOutputAssembly(This,pbstrOutputAssembly)	\
    ( (This)->lpVtbl -> GetOutputAssembly(This,pbstrOutputAssembly) ) 

#define IVsIntellisenseProjectHost_CreateFileCodeModel(This,pszFilename,ppCodeModel)	\
    ( (This)->lpVtbl -> CreateFileCodeModel(This,pszFilename,ppCodeModel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsIntellisenseProjectHost_INTERFACE_DEFINED__ */


#ifndef __SVsIntellisenseProjectHost_INTERFACE_DEFINED__
#define __SVsIntellisenseProjectHost_INTERFACE_DEFINED__

/* interface SVsIntellisenseProjectHost */
/* [object][uuid] */ 


EXTERN_C const IID IID_SVsIntellisenseProjectHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D13ECE7-AA1F-400f-B65D-FA2ABD4F1CD4")
    SVsIntellisenseProjectHost : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct SVsIntellisenseProjectHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SVsIntellisenseProjectHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SVsIntellisenseProjectHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SVsIntellisenseProjectHost * This);
        
        END_INTERFACE
    } SVsIntellisenseProjectHostVtbl;

    interface SVsIntellisenseProjectHost
    {
        CONST_VTBL struct SVsIntellisenseProjectHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SVsIntellisenseProjectHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SVsIntellisenseProjectHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SVsIntellisenseProjectHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SVsIntellisenseProjectHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_containedlanguage_0000_0009 */
/* [local] */ 

#define SID_SVsIntellisenseProjectHost IID_SVsIntellisenseProjectHost


extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_containedlanguage_0000_0009_v0_0_s_ifspec;

#ifndef __IVsIntellisenseProject_INTERFACE_DEFINED__
#define __IVsIntellisenseProject_INTERFACE_DEFINED__

/* interface IVsIntellisenseProject */
/* [uuid][object] */ 


EXTERN_C const IID IID_IVsIntellisenseProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B83B579-4969-4E12-A964-11EC19CC1503")
    IVsIntellisenseProject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ __RPC__in_opt IVsIntellisenseProjectHost *pHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFile( 
            /* [in] */ __RPC__in BSTR bstrAbsPath,
            /* [in] */ VSITEMID itemid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFile( 
            /* [in] */ __RPC__in BSTR bstrAbsPath,
            /* [in] */ VSITEMID itemid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameFile( 
            /* [in] */ __RPC__in BSTR bstrAbsPath,
            /* [in] */ __RPC__in BSTR bstrNewAbsPath,
            /* [in] */ VSITEMID itemid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCompilableFile( 
            /* [in] */ __RPC__in BSTR bstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainedLanguageFactory( 
            /* [retval][out] */ __RPC__deref_out_opt IVsContainedLanguageFactory **ppContainedLanguageFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompilerReference( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCompilerReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileCodeModel( 
            /* [in] */ __RPC__in_opt IUnknown *pProj,
            /* [in] */ __RPC__in_opt IUnknown *pProjectItem,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCodeModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProjectCodeModel( 
            /* [in] */ __RPC__in_opt IUnknown *pProj,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCodeModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshCompilerOptions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeDomProviderName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsWebFileRequiredByProject( 
            /* [retval][out] */ __RPC__out BOOL *pbReq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAssemblyReference( 
            /* [in] */ __RPC__in BSTR bstrAbsPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAssemblyReference( 
            /* [in] */ __RPC__in BSTR bstrAbsPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddP2PReference( 
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveP2PReference( 
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopIntellisenseEngine( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartIntellisenseEngine( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSupportedP2PReference( 
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForIntellisenseReady( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExternalErrorReporter( 
            /* [retval][out] */ __RPC__deref_out_opt IVsReportExternalErrors **ppErrorReporter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendPostedNotifications( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumePostedNotifications( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsIntellisenseProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsIntellisenseProject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in_opt IVsIntellisenseProjectHost *pHost);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFile )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in BSTR bstrAbsPath,
            /* [in] */ VSITEMID itemid);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFile )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in BSTR bstrAbsPath,
            /* [in] */ VSITEMID itemid);
        
        HRESULT ( STDMETHODCALLTYPE *RenameFile )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in BSTR bstrAbsPath,
            /* [in] */ __RPC__in BSTR bstrNewAbsPath,
            /* [in] */ VSITEMID itemid);
        
        HRESULT ( STDMETHODCALLTYPE *IsCompilableFile )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in BSTR bstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainedLanguageFactory )( 
            IVsIntellisenseProject * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsContainedLanguageFactory **ppContainedLanguageFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompilerReference )( 
            IVsIntellisenseProject * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCompilerReference);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileCodeModel )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in_opt IUnknown *pProj,
            /* [in] */ __RPC__in_opt IUnknown *pProjectItem,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCodeModel);
        
        HRESULT ( STDMETHODCALLTYPE *GetProjectCodeModel )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in_opt IUnknown *pProj,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppCodeModel);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshCompilerOptions )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeDomProviderName )( 
            IVsIntellisenseProject * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        HRESULT ( STDMETHODCALLTYPE *IsWebFileRequiredByProject )( 
            IVsIntellisenseProject * This,
            /* [retval][out] */ __RPC__out BOOL *pbReq);
        
        HRESULT ( STDMETHODCALLTYPE *AddAssemblyReference )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in BSTR bstrAbsPath);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAssemblyReference )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in BSTR bstrAbsPath);
        
        HRESULT ( STDMETHODCALLTYPE *AddP2PReference )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveP2PReference )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *StopIntellisenseEngine )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartIntellisenseEngine )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupportedP2PReference )( 
            IVsIntellisenseProject * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForIntellisenseReady )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetExternalErrorReporter )( 
            IVsIntellisenseProject * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsReportExternalErrors **ppErrorReporter);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendPostedNotifications )( 
            IVsIntellisenseProject * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumePostedNotifications )( 
            IVsIntellisenseProject * This);
        
        END_INTERFACE
    } IVsIntellisenseProjectVtbl;

    interface IVsIntellisenseProject
    {
        CONST_VTBL struct IVsIntellisenseProjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsIntellisenseProject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsIntellisenseProject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsIntellisenseProject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsIntellisenseProject_Init(This,pHost)	\
    ( (This)->lpVtbl -> Init(This,pHost) ) 

#define IVsIntellisenseProject_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IVsIntellisenseProject_AddFile(This,bstrAbsPath,itemid)	\
    ( (This)->lpVtbl -> AddFile(This,bstrAbsPath,itemid) ) 

#define IVsIntellisenseProject_RemoveFile(This,bstrAbsPath,itemid)	\
    ( (This)->lpVtbl -> RemoveFile(This,bstrAbsPath,itemid) ) 

#define IVsIntellisenseProject_RenameFile(This,bstrAbsPath,bstrNewAbsPath,itemid)	\
    ( (This)->lpVtbl -> RenameFile(This,bstrAbsPath,bstrNewAbsPath,itemid) ) 

#define IVsIntellisenseProject_IsCompilableFile(This,bstrFileName)	\
    ( (This)->lpVtbl -> IsCompilableFile(This,bstrFileName) ) 

#define IVsIntellisenseProject_GetContainedLanguageFactory(This,ppContainedLanguageFactory)	\
    ( (This)->lpVtbl -> GetContainedLanguageFactory(This,ppContainedLanguageFactory) ) 

#define IVsIntellisenseProject_GetCompilerReference(This,ppCompilerReference)	\
    ( (This)->lpVtbl -> GetCompilerReference(This,ppCompilerReference) ) 

#define IVsIntellisenseProject_GetFileCodeModel(This,pProj,pProjectItem,ppCodeModel)	\
    ( (This)->lpVtbl -> GetFileCodeModel(This,pProj,pProjectItem,ppCodeModel) ) 

#define IVsIntellisenseProject_GetProjectCodeModel(This,pProj,ppCodeModel)	\
    ( (This)->lpVtbl -> GetProjectCodeModel(This,pProj,ppCodeModel) ) 

#define IVsIntellisenseProject_RefreshCompilerOptions(This)	\
    ( (This)->lpVtbl -> RefreshCompilerOptions(This) ) 

#define IVsIntellisenseProject_GetCodeDomProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> GetCodeDomProviderName(This,pbstrProvider) ) 

#define IVsIntellisenseProject_IsWebFileRequiredByProject(This,pbReq)	\
    ( (This)->lpVtbl -> IsWebFileRequiredByProject(This,pbReq) ) 

#define IVsIntellisenseProject_AddAssemblyReference(This,bstrAbsPath)	\
    ( (This)->lpVtbl -> AddAssemblyReference(This,bstrAbsPath) ) 

#define IVsIntellisenseProject_RemoveAssemblyReference(This,bstrAbsPath)	\
    ( (This)->lpVtbl -> RemoveAssemblyReference(This,bstrAbsPath) ) 

#define IVsIntellisenseProject_AddP2PReference(This,pUnk)	\
    ( (This)->lpVtbl -> AddP2PReference(This,pUnk) ) 

#define IVsIntellisenseProject_RemoveP2PReference(This,pUnk)	\
    ( (This)->lpVtbl -> RemoveP2PReference(This,pUnk) ) 

#define IVsIntellisenseProject_StopIntellisenseEngine(This)	\
    ( (This)->lpVtbl -> StopIntellisenseEngine(This) ) 

#define IVsIntellisenseProject_StartIntellisenseEngine(This)	\
    ( (This)->lpVtbl -> StartIntellisenseEngine(This) ) 

#define IVsIntellisenseProject_IsSupportedP2PReference(This,pUnk)	\
    ( (This)->lpVtbl -> IsSupportedP2PReference(This,pUnk) ) 

#define IVsIntellisenseProject_WaitForIntellisenseReady(This)	\
    ( (This)->lpVtbl -> WaitForIntellisenseReady(This) ) 

#define IVsIntellisenseProject_GetExternalErrorReporter(This,ppErrorReporter)	\
    ( (This)->lpVtbl -> GetExternalErrorReporter(This,ppErrorReporter) ) 

#define IVsIntellisenseProject_SuspendPostedNotifications(This)	\
    ( (This)->lpVtbl -> SuspendPostedNotifications(This) ) 

#define IVsIntellisenseProject_ResumePostedNotifications(This)	\
    ( (This)->lpVtbl -> ResumePostedNotifications(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsIntellisenseProject_INTERFACE_DEFINED__ */


#ifndef __IVsDataEnvironment_INTERFACE_DEFINED__
#define __IVsDataEnvironment_INTERFACE_DEFINED__

/* interface IVsDataEnvironment */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVsDataEnvironment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD138AD4-A0BF-4681-8FA7-B6D57D55C4DB")
    IVsDataEnvironment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IServiceProvider *pServiceProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dispose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsDataEnvironmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsDataEnvironment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsDataEnvironment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsDataEnvironment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IVsDataEnvironment * This,
            /* [in] */ __RPC__in_opt IServiceProvider *pServiceProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Dispose )( 
            IVsDataEnvironment * This);
        
        END_INTERFACE
    } IVsDataEnvironmentVtbl;

    interface IVsDataEnvironment
    {
        CONST_VTBL struct IVsDataEnvironmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsDataEnvironment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsDataEnvironment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsDataEnvironment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsDataEnvironment_Initialize(This,pServiceProvider)	\
    ( (This)->lpVtbl -> Initialize(This,pServiceProvider) ) 

#define IVsDataEnvironment_Dispose(This)	\
    ( (This)->lpVtbl -> Dispose(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsDataEnvironment_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\context2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for context2.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __context2_h__
#define __context2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsUserContextExport_FWD_DEFINED__
#define __IVsUserContextExport_FWD_DEFINED__
typedef interface IVsUserContextExport IVsUserContextExport;
#endif 	/* __IVsUserContextExport_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "vsshell.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_context2_0000_0000 */
/* [local] */ 

#pragma once

enum __VSUSERCONTEXTEXPORTTEXTFLAGS
    {	VSUC_ETFlags_None	= 0,
	VSUC_ETFlags_StandardXML	= 0x1,
	VSUC_ETFlags_IncludeChildren	= 0x10
    } ;
typedef DWORD VSUSERCONTEXTEXPORTTEXTFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_context2_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_context2_0000_0000_v0_0_s_ifspec;

#ifndef __IVsUserContextExport_INTERFACE_DEFINED__
#define __IVsUserContextExport_INTERFACE_DEFINED__

/* interface IVsUserContextExport */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsUserContextExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B50F15A4-C42D-4dc1-AE09-7D2069EC58E9")
    IVsUserContextExport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUserContextAsText( 
            VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags,
            __RPC__in BSTR bstrOptions,
            __RPC__deref_in_opt BSTR *pbstrKeywords,
            __RPC__deref_in_opt BSTR *pbstrAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserContextAsSafeArray( 
            VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags,
            __RPC__in BSTR bstrF1Keyword,
            __RPC__deref_in_opt SAFEARRAY * *ppKeywords,
            __RPC__deref_in_opt SAFEARRAY * *ppAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSubcontextsFromSafeArrays( 
            __RPC__in_opt IVsMonitorUserContext *pMUC,
            __RPC__in SAFEARRAY * pKeywords,
            __RPC__in SAFEARRAY * pAttributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsUserContextExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsUserContextExport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsUserContextExport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsUserContextExport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserContextAsText )( 
            IVsUserContextExport * This,
            VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags,
            __RPC__in BSTR bstrOptions,
            __RPC__deref_in_opt BSTR *pbstrKeywords,
            __RPC__deref_in_opt BSTR *pbstrAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserContextAsSafeArray )( 
            IVsUserContextExport * This,
            VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags,
            __RPC__in BSTR bstrF1Keyword,
            __RPC__deref_in_opt SAFEARRAY * *ppKeywords,
            __RPC__deref_in_opt SAFEARRAY * *ppAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSubcontextsFromSafeArrays )( 
            IVsUserContextExport * This,
            __RPC__in_opt IVsMonitorUserContext *pMUC,
            __RPC__in SAFEARRAY * pKeywords,
            __RPC__in SAFEARRAY * pAttributes);
        
        END_INTERFACE
    } IVsUserContextExportVtbl;

    interface IVsUserContextExport
    {
        CONST_VTBL struct IVsUserContextExportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsUserContextExport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsUserContextExport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsUserContextExport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsUserContextExport_GetUserContextAsText(This,dwFlags,bstrOptions,pbstrKeywords,pbstrAttributes)	\
    ( (This)->lpVtbl -> GetUserContextAsText(This,dwFlags,bstrOptions,pbstrKeywords,pbstrAttributes) ) 

#define IVsUserContextExport_GetUserContextAsSafeArray(This,dwFlags,bstrF1Keyword,ppKeywords,ppAttributes)	\
    ( (This)->lpVtbl -> GetUserContextAsSafeArray(This,dwFlags,bstrF1Keyword,ppKeywords,ppAttributes) ) 

#define IVsUserContextExport_CreateSubcontextsFromSafeArrays(This,pMUC,pKeywords,pAttributes)	\
    ( (This)->lpVtbl -> CreateSubcontextsFromSafeArrays(This,pMUC,pKeywords,pAttributes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsUserContextExport_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\dbgmetric.h ===
#ifndef __METRIC_H__
#define __METRIC_H__

// ------------------------------------------------------------------
// Predefined metric names

// "CLSID"
extern LPCWSTR metricCLSID;
// "Name"
extern LPCWSTR metricName;
// "Language"
extern LPCWSTR metricLanguage;



#ifndef NO_DBGMETRIC // if NO_DBGMETIC is defined, don't include functions

// ------------------------------------------------------------------
// General purpose metric routines

//HRESULT GetMetric(LPCWSTR pszMachine, LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, VARIANT* pvarValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetMetric(LPCWSTR pszMachine, LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, _Out_ DWORD* pdwValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetMetric(LPCWSTR pszMachine, LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, BSTR* pbstrValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetMetric(LPCWSTR pszMachine, LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, _Out_ GUID* pguidValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetMetric(LPCWSTR pszMachine, LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) GUID* rgguidValues, _Out_ DWORD* pdwSize, LPCWSTR pszAltRoot);

//HRESULT SetMetric(LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, const VARIANT varValue);
HRESULT __stdcall SetMetric(LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, const DWORD dwValue, bool fUserSpecific, LPCWSTR pszAltRoot);
HRESULT __stdcall SetMetric(LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, LPCWSTR pszValue, bool fUserSpecific, LPCWSTR pszAltRoot);
HRESULT __stdcall SetMetric(LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, REFGUID guidValue, bool fUserSpecific, LPCWSTR pszAltRoot);
HRESULT __stdcall SetMetric(LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, _In_count_(dwSize) const GUID* rgguidValues, DWORD dwSize, bool fUserSpecific, LPCWSTR pszAltRoot);

HRESULT __stdcall EnumMetricSections(LPCWSTR pszMachine, LPCWSTR pszType, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) GUID* rgguidSections, _Out_ DWORD* pdwSize, LPCWSTR pszAltRoot);

HRESULT __stdcall RemoveMetric(LPCWSTR pszType, REFGUID guidSection, LPCWSTR pszMetric, LPCWSTR pszAltRoot);

HRESULT __stdcall SetMetricLocale(WORD wLangId);
WORD __stdcall GetMetricLocale();

HRESULT ReadTextFileAsBstr(LPCWSTR szFileName, BSTR *pbstrFileContent);
#endif // end ifndef NO_DBGMETRIC



// Predefined metric types
// "Engine"
extern LPCWSTR metrictypeEngine;
// "PortSupplier"
extern LPCWSTR metrictypePortSupplier;
// "Exception"
extern LPCWSTR metrictypeException;
// "EEExtensions"
extern LPCWSTR metricttypeEEExtension;

// Predefined engine metric names
// AddressBP
extern LPCWSTR metricAddressBP;
// AlwaysLoadLocal
extern LPCWSTR metricAlwaysLoadLocal;
// LoadInDebuggeeSession
extern LPCWSTR metricLoadInDebuggeeSession;
// LoadedByDebuggee
extern LPCWSTR metricLoadedByDebuggee;
// Attach
extern LPCWSTR metricAttach;
// CallStackBP
extern LPCWSTR metricCallStackBP;
// ConditionalBP
extern LPCWSTR metricConditionalBP;
// DataBP
extern LPCWSTR metricDataBP;
// Disassembly
extern LPCWSTR metricDisassembly;
// Dump writing
extern LPCWSTR metricDumpWriting;
// ENC
extern LPCWSTR metricENC;
// Exceptions
extern LPCWSTR metricExceptions;
// FunctionBP
extern LPCWSTR metricFunctionBP;
// HitCountBP
extern LPCWSTR metricHitCountBP;
// JITDebug
extern LPCWSTR metricJITDebug;
// Memory
extern LPCWSTR metricMemory;
// Port supplier
extern LPCWSTR metricPortSupplier;
// Registers
extern LPCWSTR metricRegisters;
// SetNextStatement
extern LPCWSTR metricSetNextStatement;
// SuspendThread
extern LPCWSTR metricSuspendThread;
// WarnIfNoSymbols
extern LPCWSTR metricWarnIfNoSymbols;
// Filtering non-user frames
extern LPCWSTR metricShowNonUserCode;
// What CLSID provides program nodes?
extern LPCWSTR metricProgramProvider;
// Always load the program provider locally?
extern LPCWSTR metricAlwaysLoadProgramProviderLocal;
// Use engine to watch for process events instead of program provider?
extern LPCWSTR metricEngineCanWatchProcess;
// Engines will be placed in the SDM's engine filter in descending order of priority. This determines the order in which WatchForProviderEvents/etc is called during multi-engine launch
extern LPCWSTR metricEnginePriority;
// Can we do remote debugging?
extern LPCWSTR metricRemoteDebugging;
// Should the encmgr use native's encbuild.dll to build for enc?
extern LPCWSTR metricEncUseNativeBuilder;
// When debugging a 64-bit process under WOW, should we load the engine 'remotely'
// or in the devenv process (which is running under WOW64)
extern LPCWSTR metricLoadUnderWOW64;
// When debugging a 64-bit process under WOW, should we load the program provider
// 'remotely' or in the devenv process (which is running under WOW64)
extern LPCWSTR metricLoadProgramProviderUnderWOW64;
// Stop on unhandled exceptions thrown across app domain boundaries
extern LPCWSTR metricStopOnExceptionCrossingManagedBoundary;
// Warn user if there is no "user" code on launch
extern LPCWSTR metricWarnIfNoUserCodeOnLaunch;
// Priority for engine automatic selection (preference given to higher)
extern LPCWSTR metricAutoSelectPriority;
// engines not compatible with this engine (only for automatic engine selection)
extern LPCWSTR metricAutoSelectIncompatibleList;
// engines not compatible with this engine
extern LPCWSTR metricIncompatibleList;
// Disable JIT optimizations while debugging
extern LPCWSTR metricDisableJITOptimization;
// Default memory organization 0=little endian (most typical), 1=big endian
extern LPCWSTR metricBigEndian;

// Filtering non-user frames
extern LPCWSTR metricShowNonUserCode;

// Stepping in "user" code only
extern LPCWSTR metricJustMyCodeStepping;
// Allow all threads to run when doing a funceval
extern LPCWSTR metricAllThreadsRunOnFuncEval;
// Use Shim API to get ICorDebug
extern LPCWSTR metricUseShimAPI;
// Attempt to map breakpoints in client-side script
extern LPCWSTR metricMapClientBreakpoints;
// Enable funceval quick abort
extern LPCWSTR metricEnableFuncEvalQuickAbort;
// Specify detour dll names for funceval quick abort
extern LPCWSTR metricFuncEvalQuickAbortDlls;
// Specify EXEs for which we shouldn't do FEQA
extern LPCWSTR metricFuncEvalQuickAbortExcludeList;
// Trace settings.
extern LPCWSTR metricTracing;
extern LPCWSTR metricEnableTracing;
// Enable/disable crossthread dependency notifications
extern LPCWSTR metricCrossThreadDependencyNotification;

// Managed engine activation
extern LPCWSTR metricEngineClass;
extern LPCWSTR metricEngineAssembly;
extern LPCWSTR metricProgramProviderClass;
extern LPCWSTR metricProgramProviderAssembly;

// Predefined EE metric names
// Engine
extern LPCWSTR metricEngine;
// Preload Modules
extern LPCWSTR metricPreloadModules;
// ThisObjectName
extern LPCWSTR metricThisObjectName;
// HideGoToSource
extern LPCWSTR metricHideGoToSource;
// HideGoToDisassembly
extern LPCWSTR metricHideGoToDisassembly;
// HideRunToCursor
extern LPCWSTR metricHideRunToCursor;
// HideBreakpointCommands
extern LPCWSTR metricHideCallStackBreakpoints;

// Predefined EE Extension metric names
// ExtensionDll
extern LPCWSTR metricExtensionDll;
// RegistersSupported
extern LPCWSTR metricExtensionRegistersSupported;
// RegistersEntryPoint
extern LPCWSTR metricExtensionRegistersEntryPoint;
// TypesSupported
extern LPCWSTR metricExtensionTypesSupported;
// TypesEntryPoint
extern LPCWSTR metricExtensionTypesEntryPoint;

// Predefined PortSupplier metric names
// PortPickerCLSID
extern LPCWSTR metricPortPickerCLSID;
// DisallowUserEnteredPorts
extern LPCWSTR metricDisallowUserEnteredPorts;
// PidBase
extern LPCWSTR metricPidBase;


#ifndef NO_DBGMETRIC // if NO_DBGMETIC is defined, don't include functions

// ------------------------------------------------------------------
// Engine-specific metric routines

HRESULT __stdcall EnumDebugEngines(LPCWSTR pszMachine, REFGUID guidPortSupplier, BOOL fRequireRemoteDebugging, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) GUID* rgguidEngines, _Out_ DWORD* pdwSize, LPCWSTR pszAltRoot);

#endif // end ifndef NO_DBGMETRIC



#ifndef NO_DBGMETRIC // if NO_DBGMETIC is defined, don't include functions

// ------------------------------------------------------------------
// EE-specific metric routines

HRESULT __stdcall GetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, _Out_ DWORD* pdwValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, BSTR* pbstrValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, _Out_ GUID* pguidValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) GUID* rgguidValues, _Out_ DWORD* pdwSize, LPCWSTR pszAltRoot);

HRESULT __stdcall SetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, DWORD dwValue, LPCWSTR pszAltRoot);
HRESULT __stdcall SetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, LPCWSTR pszValue, LPCWSTR pszAltRoot);
HRESULT __stdcall SetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, REFGUID guidValue, LPCWSTR pszAltRoot);
HRESULT __stdcall SetEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, _In_count_(dwSize) const GUID* rgguidValues, DWORD dwSize, LPCWSTR pszAltRoot);

HRESULT __stdcall EnumEEs(_Out_opt_cap_post_count_(*pdwSize, *pdwSize) GUID* rgguidLang, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) GUID* rgguidVendor, _Out_ DWORD* pdwSize, LPCWSTR pszAltRoot);

HRESULT __stdcall RemoveEEMetric(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, LPCWSTR pszAltRoot);

HRESULT __stdcall GetEEMetricFile(REFGUID guidLang, REFGUID guidVendor, LPCWSTR pszMetric, BSTR* pbstrValue, LPCWSTR pszAltRoot);

#endif // end ifndef NO_DBGMETRIC



#ifndef NO_DBGMETRIC // if NO_DBGMETIC is defined, don't include functions

// ------------------------------------------------------------------
// SP-specific metric routines

HRESULT __stdcall GetSPMetric(REFGUID guidSymbolType, LPCWSTR pszStoreType, LPCWSTR pszMetric, BSTR* pbstrValue, LPCWSTR pszAltRoot);
HRESULT __stdcall GetSPMetric(REFGUID guidSymbolType, LPCWSTR pszStoreType, LPCWSTR pszMetric, _Out_ GUID* pguidValue, LPCWSTR pszAltRoot);

HRESULT __stdcall SetSPMetric(REFGUID guidSymbolType, LPCWSTR pszStoreType, LPCWSTR pszMetric, LPCWSTR pszValue, LPCWSTR pszAltRoot);
HRESULT __stdcall SetSPMetric(REFGUID guidSymbolType, LPCWSTR pszStoreType, LPCWSTR pszMetric, REFGUID guidValue, LPCWSTR pszAltRoot);

HRESULT __stdcall RemoveSPMetric(REFGUID guidSymbolType, LPCWSTR pszStoreType, LPCWSTR pszMetric, LPCWSTR pszAltRoot);

#endif // end ifndef NO_DBGMETRIC



// Predefined SP store types
// "file"
extern LPCWSTR storetypeFile;
// "metadata"
extern LPCWSTR storetypeMetadata;


#ifndef NO_DBGMETRIC // if NO_DBGMETIC is defined, don't include functions

// ------------------------------------------------------------------
// Exception metric routines

HRESULT __stdcall GetExceptionMetric(REFGUID guidType, LPCWSTR pszException, _Out_opt_ DWORD* pdwState, _Out_opt_ DWORD* pdwCode, LPCWSTR pszAltRoot);

HRESULT __stdcall SetExceptionMetric(REFGUID guidType, LPCWSTR pszParent, LPCWSTR pszException, DWORD dwState, DWORD dwCode, LPCWSTR pszAltRoot);

HRESULT __stdcall EnumExceptionMetrics(REFGUID guidType, LPCWSTR pszParent, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) BSTR* rgbstrExceptions, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) DWORD* rgdwState, _Out_opt_cap_post_count_(*pdwSize, *pdwSize) DWORD* rgdwCode, _Out_ DWORD* pdwSize, LPCWSTR pszAltRoot);

HRESULT __stdcall RemoveExceptionMetric(REFGUID guidType, LPCWSTR pszParent, LPCWSTR pszException, LPCWSTR pszAltRoot);
HRESULT __stdcall RemoveAllExceptionMetrics(REFGUID guidType, LPCWSTR pszAltRoot);

#endif // end ifndef NO_DBGMETRIC


#endif // __METRIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\contextuuids.h ===
#pragma once

//                                                new                                     old
#define uuid_IVsUserContext                     761081DF-D45F-4683-9B9E-1B7241E56F5C //3c1f59c0-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsUserContextUpdate               F5ED7D1C-61B6-428A-8129-E13B36D9E9A7 //3c1f59c1-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsProvideUserContext              997D7904-D948-4C8B-8BAB-0BDA1E212F6E //3c1f59ca-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsProvideUserContextForObject     F98CCC8A-9C5F-41EB-8421-711C0F1880E6 //3c1f59cb-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsUserContextItemCollection       2A6DE4A2-5B3D-46EB-A65C-24C4EF4F396F //3c1f59c2-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsUserContextItem                 720B8500-17B3-4C89-AE84-2CFE7251B4B8 //3c1f59c3-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsHelpAttributeList               0A56FB1E-1B2F-4699-8178-63B98E816F35
#define uuid_IVsMonitorUserContext              9C074FDB-3D7D-4512-9604-72B3B0A5F609 //3c1f59c4-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsUserContextItemProvider         715C98B7-05FB-4A1A-86C8-FF00CE2E5D64 //3c1f59c7-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsUserContextItemEvents           A2078F0E-A310-420A-BA27-16531905B88F //3c1f59c8-69cf-11d2-aa7c-00c04f990343
#define uuid_IVsUserContextCustomize            0F817159-761D-447e-9600-4C3387F4C0FD
// library
#define uuid_lib_VsContext                      9E9C5B7E-02B2-41B5-8D81-DF773C10D0BE //3c1f59c5-69cf-11d2-aa7c-00c04f990343
#define uuid_coclass_VsContextClass           /*B531C14D-AFD7-4C68-8CD5-93F65EEB6A08*/ 3c1f59c6-69cf-11d2-aa7c-00c04f990343


//For context2.idl
#define uuid_IVsUserContextExport               B50F15A4-C42D-4dc1-AE09-7D2069EC58E9
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\designer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for designer.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __designer_h__
#define __designer_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveDesigner_FWD_DEFINED__
#define __IActiveDesigner_FWD_DEFINED__
typedef interface IActiveDesigner IActiveDesigner;
#endif 	/* __IActiveDesigner_FWD_DEFINED__ */


#ifndef __ICodeNavigate_FWD_DEFINED__
#define __ICodeNavigate_FWD_DEFINED__
typedef interface ICodeNavigate ICodeNavigate;
#endif 	/* __ICodeNavigate_FWD_DEFINED__ */


#ifndef __ICodeNavigate2_FWD_DEFINED__
#define __ICodeNavigate2_FWD_DEFINED__
typedef interface ICodeNavigate2 ICodeNavigate2;
#endif 	/* __ICodeNavigate2_FWD_DEFINED__ */


#ifndef __ISelectionContainer_FWD_DEFINED__
#define __ISelectionContainer_FWD_DEFINED__
typedef interface ISelectionContainer ISelectionContainer;
#endif 	/* __ISelectionContainer_FWD_DEFINED__ */


#ifndef __ITrackSelection_FWD_DEFINED__
#define __ITrackSelection_FWD_DEFINED__
typedef interface ITrackSelection ITrackSelection;
#endif 	/* __ITrackSelection_FWD_DEFINED__ */


#ifndef __IProfferTypeLib_FWD_DEFINED__
#define __IProfferTypeLib_FWD_DEFINED__
typedef interface IProfferTypeLib IProfferTypeLib;
#endif 	/* __IProfferTypeLib_FWD_DEFINED__ */


#ifndef __IProvideDynamicClassInfo_FWD_DEFINED__
#define __IProvideDynamicClassInfo_FWD_DEFINED__
typedef interface IProvideDynamicClassInfo IProvideDynamicClassInfo;
#endif 	/* __IProvideDynamicClassInfo_FWD_DEFINED__ */


#ifndef __IExtendedObject_FWD_DEFINED__
#define __IExtendedObject_FWD_DEFINED__
typedef interface IExtendedObject IExtendedObject;
#endif 	/* __IExtendedObject_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "servprov.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_designer_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1997 Microsoft Corporation. All Rights Reserved.
//
//  File: designer.h
//
//--------------------------------------------------------------------------
#ifndef _DESIGNER_H_
#define _DESIGNER_H_
extern const __declspec(selectany) GUID CATID_Designer = {0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x00, 0xaa, 0x00, 0x62, 0xbe, 0x57};


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0000_v0_0_s_ifspec;

#ifndef __IActiveDesigner_INTERFACE_DEFINED__
#define __IActiveDesigner_INTERFACE_DEFINED__

/* interface IActiveDesigner */
/* [unique][uuid][local][object] */ 

typedef /* [unique] */ IActiveDesigner *LPACTIVEDESIGNER;


EXTERN_C const IID IID_IActiveDesigner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51aae3e0-7486-11cf-a0C2-00aa0062be57")
    IActiveDesigner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeClassID( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeMiscStatusFlags( 
            /* [out] */ DWORD *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPersistenceInterface( 
            /* [in] */ REFIID riidPersist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveRuntimeState( 
            /* [in] */ REFIID riidPersist,
            /* [in] */ REFIID riidObjStgMed,
            /* [in] */ void *pObjStgMed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtensibilityObject( 
            /* [out] */ IDispatch **ppvObjOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveDesignerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveDesigner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveDesigner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveDesigner * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeClassID )( 
            IActiveDesigner * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeMiscStatusFlags )( 
            IActiveDesigner * This,
            /* [out] */ DWORD *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPersistenceInterface )( 
            IActiveDesigner * This,
            /* [in] */ REFIID riidPersist);
        
        HRESULT ( STDMETHODCALLTYPE *SaveRuntimeState )( 
            IActiveDesigner * This,
            /* [in] */ REFIID riidPersist,
            /* [in] */ REFIID riidObjStgMed,
            /* [in] */ void *pObjStgMed);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtensibilityObject )( 
            IActiveDesigner * This,
            /* [out] */ IDispatch **ppvObjOut);
        
        END_INTERFACE
    } IActiveDesignerVtbl;

    interface IActiveDesigner
    {
        CONST_VTBL struct IActiveDesignerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveDesigner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveDesigner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveDesigner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveDesigner_GetRuntimeClassID(This,pclsid)	\
    ( (This)->lpVtbl -> GetRuntimeClassID(This,pclsid) ) 

#define IActiveDesigner_GetRuntimeMiscStatusFlags(This,pdwMiscFlags)	\
    ( (This)->lpVtbl -> GetRuntimeMiscStatusFlags(This,pdwMiscFlags) ) 

#define IActiveDesigner_QueryPersistenceInterface(This,riidPersist)	\
    ( (This)->lpVtbl -> QueryPersistenceInterface(This,riidPersist) ) 

#define IActiveDesigner_SaveRuntimeState(This,riidPersist,riidObjStgMed,pObjStgMed)	\
    ( (This)->lpVtbl -> SaveRuntimeState(This,riidPersist,riidObjStgMed,pObjStgMed) ) 

#define IActiveDesigner_GetExtensibilityObject(This,ppvObjOut)	\
    ( (This)->lpVtbl -> GetExtensibilityObject(This,ppvObjOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveDesigner_INTERFACE_DEFINED__ */


#ifndef __ICodeNavigate_INTERFACE_DEFINED__
#define __ICodeNavigate_INTERFACE_DEFINED__

/* interface ICodeNavigate */
/* [unique][uuid][local][object] */ 

typedef /* [unique] */ ICodeNavigate *LPCODENAVIGATE;


EXTERN_C const IID IID_ICodeNavigate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d5140c4-7436-11ce-8034-00aa006009fa")
    ICodeNavigate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayDefaultEventHandler( 
            /* [in] */ LPCOLESTR lpstrObjectName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeNavigateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeNavigate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeNavigate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeNavigate * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayDefaultEventHandler )( 
            ICodeNavigate * This,
            /* [in] */ LPCOLESTR lpstrObjectName);
        
        END_INTERFACE
    } ICodeNavigateVtbl;

    interface ICodeNavigate
    {
        CONST_VTBL struct ICodeNavigateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeNavigate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICodeNavigate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICodeNavigate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICodeNavigate_DisplayDefaultEventHandler(This,lpstrObjectName)	\
    ( (This)->lpVtbl -> DisplayDefaultEventHandler(This,lpstrObjectName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICodeNavigate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_designer_0000_0002 */
/* [local] */ 

#define SID_SCodeNavigate IID_ICodeNavigate


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0002_v0_0_s_ifspec;

#ifndef __ICodeNavigate2_INTERFACE_DEFINED__
#define __ICodeNavigate2_INTERFACE_DEFINED__

/* interface ICodeNavigate2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICodeNavigate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2702ad60-3459-11d1-88fd-00a0c9110049")
    ICodeNavigate2 : public ICodeNavigate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayEventHandler( 
            /* [in] */ LPCOLESTR lpstrObjectName,
            /* [in] */ LPCOLESTR lpstrEventName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeNavigate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeNavigate2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeNavigate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeNavigate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayDefaultEventHandler )( 
            ICodeNavigate2 * This,
            /* [in] */ LPCOLESTR lpstrObjectName);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayEventHandler )( 
            ICodeNavigate2 * This,
            /* [in] */ LPCOLESTR lpstrObjectName,
            /* [in] */ LPCOLESTR lpstrEventName);
        
        END_INTERFACE
    } ICodeNavigate2Vtbl;

    interface ICodeNavigate2
    {
        CONST_VTBL struct ICodeNavigate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeNavigate2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICodeNavigate2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICodeNavigate2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICodeNavigate2_DisplayDefaultEventHandler(This,lpstrObjectName)	\
    ( (This)->lpVtbl -> DisplayDefaultEventHandler(This,lpstrObjectName) ) 


#define ICodeNavigate2_DisplayEventHandler(This,lpstrObjectName,lpstrEventName)	\
    ( (This)->lpVtbl -> DisplayEventHandler(This,lpstrObjectName,lpstrEventName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICodeNavigate2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_designer_0000_0003 */
/* [local] */ 

#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2
#define SELOBJS_ACTIVATE_WINDOW   1


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0003_v0_0_s_ifspec;

#ifndef __ISelectionContainer_INTERFACE_DEFINED__
#define __ISelectionContainer_INTERFACE_DEFINED__

/* interface ISelectionContainer */
/* [unique][uuid][local][object] */ 

typedef /* [unique] */ ISelectionContainer *LPSELECTIONCONTAINER;


EXTERN_C const IID IID_ISelectionContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d5140c6-7436-11ce-8034-00aa006009fa")
    ISelectionContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CountObjects( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cObjects,
            /* [size_is][out] */ IUnknown **apUnkObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectObjects( 
            /* [in] */ ULONG cSelect,
            /* [size_is][in] */ IUnknown **apUnkSelect,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *CountObjects )( 
            ISelectionContainer * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pc);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjects )( 
            ISelectionContainer * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cObjects,
            /* [size_is][out] */ IUnknown **apUnkObjects);
        
        HRESULT ( STDMETHODCALLTYPE *SelectObjects )( 
            ISelectionContainer * This,
            /* [in] */ ULONG cSelect,
            /* [size_is][in] */ IUnknown **apUnkSelect,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ISelectionContainerVtbl;

    interface ISelectionContainer
    {
        CONST_VTBL struct ISelectionContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectionContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectionContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectionContainer_CountObjects(This,dwFlags,pc)	\
    ( (This)->lpVtbl -> CountObjects(This,dwFlags,pc) ) 

#define ISelectionContainer_GetObjects(This,dwFlags,cObjects,apUnkObjects)	\
    ( (This)->lpVtbl -> GetObjects(This,dwFlags,cObjects,apUnkObjects) ) 

#define ISelectionContainer_SelectObjects(This,cSelect,apUnkSelect,dwFlags)	\
    ( (This)->lpVtbl -> SelectObjects(This,cSelect,apUnkSelect,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectionContainer_INTERFACE_DEFINED__ */


#ifndef __ITrackSelection_INTERFACE_DEFINED__
#define __ITrackSelection_INTERFACE_DEFINED__

/* interface ITrackSelection */
/* [unique][uuid][local][object] */ 

typedef /* [unique] */ ITrackSelection *LPTRACKSELECTION;


EXTERN_C const IID IID_ITrackSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d5140c5-7436-11ce-8034-00aa006009fa")
    ITrackSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSelectChange( 
            /* [in] */ ISelectionContainer *pSC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrackSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITrackSelection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITrackSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITrackSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectChange )( 
            ITrackSelection * This,
            /* [in] */ ISelectionContainer *pSC);
        
        END_INTERFACE
    } ITrackSelectionVtbl;

    interface ITrackSelection
    {
        CONST_VTBL struct ITrackSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrackSelection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITrackSelection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITrackSelection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITrackSelection_OnSelectChange(This,pSC)	\
    ( (This)->lpVtbl -> OnSelectChange(This,pSC) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITrackSelection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_designer_0000_0005 */
/* [local] */ 

#define SID_STrackSelection IID_ITrackSelection
#define CONTROLTYPELIB       (0x00000001)


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0005_v0_0_s_ifspec;

#ifndef __IProfferTypeLib_INTERFACE_DEFINED__
#define __IProfferTypeLib_INTERFACE_DEFINED__

/* interface IProfferTypeLib */
/* [unique][uuid][local][object] */ 

typedef /* [unique] */ IProfferTypeLib *LPPROFFERTYPELIB;


EXTERN_C const IID IID_IProfferTypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("718cc500-0a76-11cf-8045-00aa006009fa")
    IProfferTypeLib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProfferTypeLib( 
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ UINT uVerMaj,
            /* [in] */ UINT uVerMin,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProfferTypeLibVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProfferTypeLib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProfferTypeLib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProfferTypeLib * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProfferTypeLib )( 
            IProfferTypeLib * This,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ UINT uVerMaj,
            /* [in] */ UINT uVerMin,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IProfferTypeLibVtbl;

    interface IProfferTypeLib
    {
        CONST_VTBL struct IProfferTypeLibVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProfferTypeLib_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProfferTypeLib_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProfferTypeLib_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProfferTypeLib_ProfferTypeLib(This,guidTypeLib,uVerMaj,uVerMin,dwFlags)	\
    ( (This)->lpVtbl -> ProfferTypeLib(This,guidTypeLib,uVerMaj,uVerMin,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProfferTypeLib_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_designer_0000_0006 */
/* [local] */ 

#define SID_SProfferTypeLib IID_IProfferTypeLib


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0006_v0_0_s_ifspec;

#ifndef __IProvideDynamicClassInfo_INTERFACE_DEFINED__
#define __IProvideDynamicClassInfo_INTERFACE_DEFINED__

/* interface IProvideDynamicClassInfo */
/* [unique][uuid][local][object] */ 

typedef /* [unique] */ IProvideDynamicClassInfo *LPPROVIDEDYNAMICCLASSINFO;


EXTERN_C const IID IID_IProvideDynamicClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("468cfb80-b4f9-11cf-80dd-00aa00614895")
    IProvideDynamicClassInfo : public IProvideClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDynamicClassInfo( 
            /* [out] */ ITypeInfo **ppTI,
            /* [out] */ DWORD_PTR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreezeShape( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideDynamicClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvideDynamicClassInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvideDynamicClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvideDynamicClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IProvideDynamicClassInfo * This,
            /* [out] */ ITypeInfo **ppTI);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicClassInfo )( 
            IProvideDynamicClassInfo * This,
            /* [out] */ ITypeInfo **ppTI,
            /* [out] */ DWORD_PTR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *FreezeShape )( 
            IProvideDynamicClassInfo * This);
        
        END_INTERFACE
    } IProvideDynamicClassInfoVtbl;

    interface IProvideDynamicClassInfo
    {
        CONST_VTBL struct IProvideDynamicClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideDynamicClassInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideDynamicClassInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideDynamicClassInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideDynamicClassInfo_GetClassInfo(This,ppTI)	\
    ( (This)->lpVtbl -> GetClassInfo(This,ppTI) ) 


#define IProvideDynamicClassInfo_GetDynamicClassInfo(This,ppTI,pdwCookie)	\
    ( (This)->lpVtbl -> GetDynamicClassInfo(This,ppTI,pdwCookie) ) 

#define IProvideDynamicClassInfo_FreezeShape(This)	\
    ( (This)->lpVtbl -> FreezeShape(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideDynamicClassInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_designer_0000_0007 */
/* [local] */ 

extern const __declspec(selectany) GUID SID_SApplicationObject = {0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8};


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0007_v0_0_s_ifspec;

#ifndef __IExtendedObject_INTERFACE_DEFINED__
#define __IExtendedObject_INTERFACE_DEFINED__

/* interface IExtendedObject */
/* [object][uuid] */ 


EXTERN_C const IID IID_IExtendedObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A575C060-5B17-11d1-AB3E-00A0C9055A90")
    IExtendedObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInnerObject( 
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendedObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExtendedObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExtendedObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExtendedObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerObject )( 
            IExtendedObject * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        END_INTERFACE
    } IExtendedObjectVtbl;

    interface IExtendedObject
    {
        CONST_VTBL struct IExtendedObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendedObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExtendedObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExtendedObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExtendedObject_GetInnerObject(This,iid,ppvObject)	\
    ( (This)->lpVtbl -> GetInnerObject(This,iid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExtendedObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_designer_0000_0008 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_designer_0000_0008_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\CookieTable.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Visual Studio
 *  Copyright (C) Microsoft Corporation, 1995 - 2008
 *
 *  File:       CookieTable.h
 *
 *  Contents:   Interface file for CCookieTable
 *
 *  History:    20-Jan-2008 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include <map>
#include <algorithm>
#include <iterator>
#include <atlcomcli.h>              // for CComPtr, CAdapt
#include "vsshell.h"                // for VSCOOKIE, VSCOOKIE_NIL

#pragma push_macro("min")
#undef min

/*+-------------------------------------------------------------------------*
 * DefaultCookieTraits
 *
 * This class defines the default type, range, and issuance policy for
 * cookies handed out by CCookieTable.
 *-----------------------------------------------------------------(jeffro)-*/
template<class CookieType         = VSCOOKIE,
         CookieType Min           = 1,
         CookieType Max           = 0xffffffff,
         CookieType Invalid       = VSCOOKIE_NIL,
         bool       AllowRollover = true>
struct DefaultCookieTraits
{
    typedef CookieType cookie_type;

    static const cookie_type MinCookie     = Min;
    static const cookie_type MaxCookie     = Max;
    static const cookie_type InvalidCookie = Invalid;

    /*+-------------------------------------------------------------------------*
     * state_type
     *
     * This structure contains the state used by this type when generating a 
     * new cookie.
     *-----------------------------------------------------------------(jeffro)-*/
    struct state_type
    {
        state_type() 
            : lastCookieUsed (InvalidCookie)
            , fRolledOver    (false)
        {}
        
        cookie_type lastCookieUsed;
        bool        fRolledOver;
    };


    /*+-------------------------------------------------------------------------*
     * UniqueCookieCount
     *
     * Returns the maximum number of unique cookies that this traits class
     * can issue.
     *-----------------------------------------------------------------(jeffro)-*/
    static size_t UniqueCookieCount()
    {
        return (MaxCookie - MinCookie + 1);
    }


    /*+-------------------------------------------------------------------------*
     * NextCookie
     *
     * Generates a new cookie for the given table.
     *-----------------------------------------------------------------(jeffro)-*/
    template<class T>
    static cookie_type NextCookie (const T& table, state_type& state)
    {
        switch (state.lastCookieUsed)
        {
            case InvalidCookie:
                state.lastCookieUsed = MinCookie;
                break;

            case MaxCookie:
                state.lastCookieUsed = MinCookie;
                state.fRolledOver    = true;
                // fall through to default
                __fallthrough;
            default:
                /*
                 * if we haven't rolled over yet (common case), things are 
                 * easy -- just increment the cookie
                 */
                if (!state.fRolledOver)
                    state.lastCookieUsed++;

                /*
                 * if we have rolled over but the class doesn't support
                 * issuing cookies beyond that, throw an error
                 */
                else if (!AllowRollover)
                    throw (std::bad_alloc());

                /*
                 * otherwise iterate until we find one that's not in use
                 */
                else
                {
                    /*
                     * Do a quick test to see if the table is full.  This
                     * is highly unlikely unless cookie_type is a narrow
                     * data type or UniqueCookieCount is small.
                     */
                    if (table.pending_size() == table.max_size())
                        throw (std::bad_alloc());

                    /*
                     * Loop until we find a cookie that's not in use.  This is
                     * O(n), but it's highly unlikely we'll ever get this far.
                     */
                    while (table.pending_find (state.lastCookieUsed))
                    {
                        state.lastCookieUsed++;

                        /*
                         * we should never get to MaxCookie (pending_size() == max_size())
                         * protects us
                         */
                        if (state.lastCookieUsed == MaxCookie)
                        {
                            VSASSERT (false, "Should have found a cookie");
                            throw (std::bad_alloc());
                        }
                    }
                }
                break;
        }

        return (state.lastCookieUsed);
    }
};


/*+-------------------------------------------------------------------------*
 * DefaultValueTraits
 *
 * This class defines what an invalid value for a CCookieTable is, and the
 * method of invalidating values.
 *-----------------------------------------------------------------(jeffro)-*/
template<class T>
struct DefaultValueTraits
{
    /*
     * implement Invalidate if you need to detect an element
     * that has been erased during iteration
     */
    static void Invalidate (T&)
        {}

    /*
     * if you implement Invalidate, you should also implement
     * IsValid to identify an element that was invalidated
     */
    static bool IsValid (const T&)
        { return (true); }
};

// specialization for CComPtr<T>
template<class T>
struct DefaultValueTraits<CComPtr<T>>
{
    static void Invalidate (CComPtr<T>& spT)
    {
        spT.Release();
    }

    static bool IsValid (const CComPtr<T>& spT)
    {
        return (spT != NULL);
    }
};

// specialization for CAdapt<CComPtr<T>>
template<class T>
struct DefaultValueTraits<CAdapt<CComPtr<T>>>
{
    static void Invalidate (CAdapt<CComPtr<T>>& adapt)
    {
        CComPtr<T>& spT = adapt;
        spT.Release();
    }

    static bool IsValid (const CAdapt<CComPtr<T>>& adapt)
    {
        const CComPtr<T>& spT = adapt;
        return (spT != NULL);
    }
};


/*+-------------------------------------------------------------------------*
 * CCookieTable
 *
 * This class is intended to be used to support a registration model where
 * a client registers an object (commonly a COM interface) with a service
 * and receives a unique cookie for the registration in return.  The cookie
 * is subsequently used as a key when the object is unregistered.
 * 
 * This is an STL-style collection, exposing begin() and end() methods to
 * provide boundaries for iteration.  If there is a possiblity that the
 * table could be modified during the iteration, it is important to lock
 * the table before acquiring iterators.  The table can be locked with the
 * lock() method (and unlocked with unlock()), or by using the CCookieTable::Lock
 * RAII helper.
 * 
 * While the table is locked, the range of items covered by begin()/end()
 * is a snapshot representing the state of the table at the time it was
 * locked.  Additions or deletions from the table while it is locked are
 * held in a pending modifications list, which are applied to the table
 * when it is unlocked.  If an element is erased from the table while it
 * is locked, it is invalidated by ValueTraits::Invalidate; you can use
 * ValueTraits::IsValid during iteration to avoid using elements that were
 * erased during iteration.
 * 
 * NOTE:  This class provides the same thread-safety guarantees of standard 
 * STL collections:  it is thread-safe only in the sense that simultaneous 
 * accesses to distinct instances are safe, and simultaneous read accesses 
 * to to shared shared are safe. If multiple threads access a single 
 * instance and at least one thread may potentially write, then the user 
 * is responsible for ensuring mutual exclusion between the threads during
 * the accesses. 
 *-----------------------------------------------------------------(jeffro)-*/
template<class T, 
         class CookieTraits = DefaultCookieTraits<>,
         class ValueTraits  = DefaultValueTraits<T> >
class CCookieTable
{
public:
    typedef CCookieTable<T, CookieTraits, ValueTraits>  this_type;
    typedef CookieTraits                        CookieTraits;
    typedef ValueTraits                         ValueTraits;
    typedef typename CookieTraits::cookie_type  cookie_type;

private:
    typedef std::map<cookie_type, T>            map_type;

public:
    typedef typename map_type::mapped_type      mapped_type;
    typedef typename map_type::value_type       value_type;
    typedef typename map_type::size_type        size_type;
    typedef typename map_type::iterator         iterator;
    typedef typename map_type::const_iterator   const_iterator;

    static const cookie_type InvalidCookie = CookieTraits::InvalidCookie;

    class Lock
    {
    public:
        Lock (this_type& table)  : m_table (table)
            { m_table.lock(); }

        Lock (this_type* pTable) : m_table (*pTable)
            { m_table.lock(); }

        ~Lock()
            { m_table.unlock(); }

    private:
        this_type&  m_table;

        Lock            (const Lock& other);  // not copy-assignable
        Lock& operator= (const Lock& other);  // not assignable
    };

public:
    CCookieTable()
        : m_cLocks (0)
    {
        VSCASSERT (CookieTraits::MinCookie < CookieTraits::MaxCookie,
                  Min_max_cookies_in_CookeTraits_are_out_of_range);

        VSCASSERT ((CookieTraits::InvalidCookie < CookieTraits::MinCookie) ||
                   (CookieTraits::InvalidCookie > CookieTraits::MaxCookie),
                   CookieTraits_defines_the_invalid_cookie_between_min_max_cookies);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::begin
     *
     * Returns a bi-directional iterator addressing the first element in the 
     * table.  If the table is empty, the iterator addresses the location 
     * following the empty table.
     *-----------------------------------------------------------------(jeffro)-*/
    iterator begin()
        { return (m_map.begin()); }

    const_iterator begin() const
        { return (m_map.begin()); }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::end
     *
     * Returns a bi-directional iterator that addresses the location following 
     * the last element in the table.
     *-----------------------------------------------------------------(jeffro)-*/
    iterator end()
        { return (m_map.end()); }

    const_iterator end() const
        { return (m_map.end()); }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::insert
     *
     * Adds an element to the table.  If the table is locked when this function
     * is called, the element won't be physically added to the table until the
     * lock count goes to zero.
     *
     * Returns the cookie assigned to the new element.
     *-----------------------------------------------------------------(jeffro)-*/
    cookie_type insert (const mapped_type& element)
    { 
        /*
         * Lock the table before insertion.  Doing this now means we only have
         * a single code path for inserting items, regardless of whether the
         * table is externally locked or not.  The new element will actually
         * be added to the table once its lock count goes to zero.  If the
         * table isn't locked with this function is called, that time will be
         * when this function returns.
         */
        Lock lock(this);

        cookie_type cookie = CookieTraits::NextCookie (*this, m_CookieTraitsState);
        VSASSERT (!pending_find (cookie), "Reissuing a cookie that's in use");

        add_pending_insert (cookie, element);

        return (cookie);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::erase
     *
     * Removes the element matching the specified cookie.  If the table is 
     * locked when this function is called, the removal won't take effect 
     * until the table's lock count goes to zero.
     *
     * Returns a boolean indicating success.
     *-----------------------------------------------------------------(jeffro)-*/
    bool erase (const cookie_type& cookie)
    {
        bool fErased = false;

        /*
         * Lock the table before deletion.  Doing this now means we only have
         * a single code path for deleting items, regardless of whether the
         * table is externally locked or not.  The element will actually be
         * be removed from the table once its lock count goes to zero.  If the
         * table isn't locked with this function is called, that time will be
         * when this function returns.
         */
        Lock lock(this);
        VSASSERT (locked(), "Table should be locked");

        /*
         * look for an item in the table proper; if found and it hasn't already
         * been previously erased, invalidate it and add the cookie to the set of 
         * cookies to erase when unlocked
         */
        iterator it = find (cookie);
        if ((it != end()) && !find_pending_erasure (cookie))
        {
            ValueTraits::Invalidate (it->second);
            add_pending_erasure (cookie);
            fErased = true;
        }

        /*
         * if we didn't find the item in the table proper, see if it's in the
         * pending inserts
         */
        if (!fErased && find_pending_insert (cookie))
        {
            m_spPendingMods->m_inserts.erase (cookie);
            fErased = true;
        }

        return (fErased);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::clear
     *
     * Removes all elements from the table.  If the table is locked when this
     * function is called, the clear won't take effect until the table's lock
     * count goes to zero.
     *-----------------------------------------------------------------(jeffro)-*/
    void clear()
    { 
        /*
         * Lock the table before clearing.  Doing this now means we only have
         * a single code path for clearing items, regardless of whether the
         * table is externally locked or not.  The table will actually be 
         * cleared once its lock count goes to zero.  If the table isn't 
         * locked with this function is called, that time will be when this
         * function returns.
         */
        Lock lock(this);

        /*
         * invalidate all of the items in the table
         */
        std::for_each (begin(), end(), Invalidate());

        ensure_pending_mods();
        m_spPendingMods->m_clear = true;

        /*
         * now that the table has been cleared, we no longer have any pending
         * inserts/erasures
         */
        m_spPendingMods->m_inserts.clear();
        m_spPendingMods->m_erasures.clear();
    }

    struct Invalidate : public std::unary_function<value_type, void>
    {
        void operator()(value_type& pair) const
        {
            ValueTraits::Invalidate (pair.second);
        }
    };


    /*+-------------------------------------------------------------------------*
     * CCookieTable::find
     *
     * Returns an iterator addressing the location of an element with the 
     * specified cookie.  If no such element exists, the iterator addresses the 
     * location following the last element in the table.
     *
     * If this function is called when the table is locked, the find operation
     * will not take into account any changes made to the table while locked
     * (see pending_find()).
     *-----------------------------------------------------------------(jeffro)-*/
    iterator find (const cookie_type& cookie)
        { return (m_map.find (cookie)); }

    const_iterator find (const cookie_type& cookie) const
        { return (m_map.find (cookie)); }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::pending_find
     *
     * Returns a boolean indicating whether the given cookie is in use in the 
     * table, including all pending modifications to the table.  
     * 
     * If the table is unlocked with this function is called then the return 
     * value for this function is identical to (find(cookie) != end()).
     *
     * If the table is locked, the return value indicates the what the value
     * of (find(cookie) != end()) will be when all pending changes are applied.
     *-----------------------------------------------------------------(jeffro)-*/
    bool pending_find (const cookie_type& cookie) const
    { 
        bool found = (m_map.find (cookie) != end());       // assume unlocked

        /*
         * if we have pending modifications to the table, there's more work to do
         */
        if (have_pending_mods())
        {
            /*
             * if we found the cookie in the table proper, then its pending-
             * find state will only be true if there's not a pending clear
             * or a pending erasure
             */
            if (found)
                found = !m_spPendingMods->m_clear && !find_pending_erasure(cookie);

            /* 
             * otherwise, the cookie wasn't found in the table proper; its
             * pending-find state is only true if there's a pending insert
             * for the item
             */
            else
                found = find_pending_insert (cookie);
        }

        return (found);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::empty
     *
     * Returns a boolean indicating whether the table is empty.  If the table is 
     * locked when this function is called, the value returned represents the
     * table's state at the time it was locked.
     *-----------------------------------------------------------------(jeffro)-*/
    bool empty() const
        { return (m_map.empty()); }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::size
     *
     * Returns the number of elements in the table.  If the table is locked
     * when this function is called, the value returned is the size of the
     * table at the time it was locked.
     *-----------------------------------------------------------------(jeffro)-*/
    size_type size() const
        { return (m_map.size()); }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::pending_size
     *
     * Returns the number of elements that will be in the table when it is
     * unlocked, including all pending modifications to the table.  
     *
     * If the table is unlocked when this function is called, this is identical
     * to the value returned by size().
     *-----------------------------------------------------------------(jeffro)-*/
    size_type pending_size() const
    {
        size_type count = size();       // assume unlocked

        if (have_pending_mods())
        {
            /*
             * if the table was cleared while it was locked, the size when
             * unlocked will be the number of elements added to the table
             * since it was last cleared (to-erase collection should be empty)
             */
            if (m_spPendingMods->m_clear)
            {
                VSASSERT (m_spPendingMods->m_erasures.size() == 0, "Unexpected pending erasures");
                count =   m_spPendingMods->m_inserts.size();
            }
            else
            {
                /*
                 * decrement the count before incrementing to avoid overflow 
                 * (underflow isn't a concern)
                 */
                VSASSERT (m_spPendingMods->m_erasures.size() <= count, "Too many pending erasures");
                count -=  m_spPendingMods->m_erasures.size();
                count +=  m_spPendingMods->m_inserts.size();
            }
        }

        return (count); 
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::for_each
     *
     * Calls a function for each elements in the table, optionally skipping 
     * invalid elements.
     *-----------------------------------------------------------------(jeffro)-*/
    template<class Func>
    Func for_each (Func func, bool fIncludeInvalidElements = false)
    {
        /*
         * micro-optimization: short out without locking if the table is empty
         */
        if (empty())
            return (func);

        /*
         * lock the table so changes potentially made by the callback function 
         * don't invalidate our iterators
         */
        Lock lock(this);

        for (const_iterator it = begin(); it != end(); ++it)
        {
            const cookie_type& cookie = it->first;
            const mapped_type& value  = it->second;

            if (fIncludeInvalidElements || ValueTraits::IsValid(value))
            {
                func (cookie, value);
            }
        }

        return (func);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::max_size
     *
     * Returns the largest number of elements this table can hold.  This value
     * will be limited by the lesser of the maximum number of elements that 
     * the underlying map can hold and the cookie range specified by the 
     * CookieTraits class.
     *-----------------------------------------------------------------(jeffro)-*/
    size_type max_size() const
    { 
        size_type cookie_count = CookieTraits::UniqueCookieCount();
        return (std::min (m_map.max_size(), cookie_count));
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::lock
     *
     * Locks the table so subsequent insertions and deletions won't invalidate
     * iterators into the table.
     * 
     * NOTE: Locking the table DOES NOT provide exclusive access to the locking
     * thread.  There is NO thread safety implied by this function.  If exclusive
     * access to an instance of the table is required, it is the user's 
     * responsibility to provide it.
     *-----------------------------------------------------------------(jeffro)-*/
    size_type lock()
    {
        /*
         * bump the lock count
         */
        m_cLocks++;

        VSASSERT (locked(), "Table should be locked");
        return (m_cLocks);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::locked
     *
     * Returns a boolean indicating whether the table is locked or not.
     *-----------------------------------------------------------------(jeffro)-*/
    bool locked() const
    {
        /*
         * If we're not locked, we shouldn't have a modification tracking structure.
         * Note that the converse is not true:  If we're locked, we may or may not
         * have a modification tracking structure, depending on whether insert,
         * erase, or clear has been called while locked.
         */
        VSASSERT ((m_cLocks > 0) || !have_pending_mods(),
                  "Shouldn't have pending mods if we're not locked");

        return (m_cLocks > 0);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::unlock
     *
     * Decrements the lock count on the table.  If the lock count goes to zero,
     * any changes to the table made while the table was locked are applied.
     *-----------------------------------------------------------------(jeffro)-*/
    size_type unlock()
    {
        /*
         * Shouldn't be unlocking if not locked.  Consider using the Lock class
         * above to automate locking semantics.
         */
        VSASSERT (locked(), "Table should be locked");

        /*
         * if this is the final unlock, apply the pending changes
         */
        if (locked() && (--m_cLocks == 0) && have_pending_mods())
        {
            /*
             * apply pending clear/erasures
             */
            if (m_spPendingMods->m_clear)
            {
                m_map.clear();
            }
            else
            {
                std::for_each (m_spPendingMods->m_erasures.begin(), 
                               m_spPendingMods->m_erasures.end(),
                               Erase (m_map));
            }

            /*
             * apply pending inserts
             */
            std::copy (m_spPendingMods->m_inserts.begin(), 
                       m_spPendingMods->m_inserts.end(),
                       std::inserter (m_map, m_map.end()));

            /*
             * let go of the tracking structure
             */
            m_spPendingMods.reset();
            VSASSERT (!locked(), "Table should be unlocked");
        }

        return (m_cLocks);
    }

    struct Erase : public std::unary_function<cookie_type, void>
    {
        Erase (map_type& table) : m_pTable (&table) 
            {}

        void operator()(const cookie_type& cookie) const
            { m_pTable->erase (cookie); }

    private:
        map_type*  m_pTable;
    };


private:
    /*+-------------------------------------------------------------------------*
     * CCookieTable::find_pending_insert
     *
     * Returns a boolean indicating whether the given cookie is in the pending 
     * add collection.
     *-----------------------------------------------------------------(jeffro)-*/
    bool find_pending_insert (cookie_type cookie) const
    {
        if (!have_pending_mods())
            return (false);

        return (m_spPendingMods->m_inserts.find(cookie) != m_spPendingMods->m_inserts.end());
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::add_pending_insert
     *
     * Adds an entry to the pending inserts collection, creating the PendingMods
     * structure if necessary.
     *-----------------------------------------------------------------(jeffro)-*/
    void add_pending_insert (cookie_type cookie, const mapped_type& element)
    {
        ensure_pending_mods();
        m_spPendingMods->m_inserts[cookie] = element;
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::find_pending_erasure
     *
     * Returns a boolean indicating whether the given cookie is in the pending 
     * erasure collection.
     *-----------------------------------------------------------------(jeffro)-*/
    bool find_pending_erasure (cookie_type cookie) const
    {
        if (!have_pending_mods())
            return (false);

        return (std::find (m_spPendingMods->m_erasures.begin(),
                           m_spPendingMods->m_erasures.end(),
                           cookie) != m_spPendingMods->m_erasures.end());
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::add_pending_erasure
     *
     * Adds an entry to the pending erasures collection, creating the PendingMods
     * structure if necessary.
     *-----------------------------------------------------------------(jeffro)-*/
    void add_pending_erasure (cookie_type cookie)
    {
        ensure_pending_mods();
        m_spPendingMods->m_erasures.push_back (cookie);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::ensure_pending_mods
     *
     * Creates the PendingMods structure if we don't have one.
     *-----------------------------------------------------------------(jeffro)-*/
    void ensure_pending_mods()
    {
        VSASSERT (locked(), "Shouldn't need a PendingMods structure unless we're locked");

        if (!have_pending_mods())
            m_spPendingMods = std::auto_ptr<PendingMods>(new PendingMods);
    }


    /*+-------------------------------------------------------------------------*
     * CCookieTable::have_pending_mods
     *
     * Returns a boolean indicating whether we have pending modifications.
     *-----------------------------------------------------------------(jeffro)-*/
    bool have_pending_mods() const
    {
        return (m_spPendingMods.get() != NULL);
    }


private:
    /*+-------------------------------------------------------------------------*
     * PendingMods
     *
     * This data structure tracks changes made to the table while locked.
     *-----------------------------------------------------------------(jeffro)-*/
    struct PendingMods
    {
        PendingMods() : m_clear (false) {}

        typedef map_type                    Inserts;
        typedef std::vector<cookie_type>    Erasures;

        Inserts     m_inserts;
        Erasures    m_erasures;
        bool        m_clear;
    };

    map_type                            m_map;
    std::auto_ptr<PendingMods>          m_spPendingMods;    // used when locked and mods are pending
    size_type                           m_cLocks;
    typename CookieTraits::state_type   m_CookieTraitsState;

    CCookieTable         (const this_type& other);  // not copy-assignable
    this_type& operator= (const this_type& other);  // not assignable
};

#pragma pop_macro("min")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\customfind.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for customfind.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __customfind_h__
#define __customfind_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsRegisterCustomFindScope_FWD_DEFINED__
#define __IVsRegisterCustomFindScope_FWD_DEFINED__
typedef interface IVsRegisterCustomFindScope IVsRegisterCustomFindScope;
#endif 	/* __IVsRegisterCustomFindScope_FWD_DEFINED__ */


#ifndef __IVsCustomFindScope_FWD_DEFINED__
#define __IVsCustomFindScope_FWD_DEFINED__
typedef interface IVsCustomFindScope IVsCustomFindScope;
#endif 	/* __IVsCustomFindScope_FWD_DEFINED__ */


#ifndef __IVsCustomFindScopeLookIn_FWD_DEFINED__
#define __IVsCustomFindScopeLookIn_FWD_DEFINED__
typedef interface IVsCustomFindScopeLookIn IVsCustomFindScopeLookIn;
#endif 	/* __IVsCustomFindScopeLookIn_FWD_DEFINED__ */


#ifndef __IVsCustomFindScopeSearch_FWD_DEFINED__
#define __IVsCustomFindScopeSearch_FWD_DEFINED__
typedef interface IVsCustomFindScopeSearch IVsCustomFindScopeSearch;
#endif 	/* __IVsCustomFindScopeSearch_FWD_DEFINED__ */


#ifndef __IVsCustomFindScopeNotify_FWD_DEFINED__
#define __IVsCustomFindScopeNotify_FWD_DEFINED__
typedef interface IVsCustomFindScopeNotify IVsCustomFindScopeNotify;
#endif 	/* __IVsCustomFindScopeNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "textfind.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_customfind_0000_0000 */
/* [local] */ 







enum __VSCUSTOMFINDSTATUS
    {	CFR_IDLE	= 0,
	CFR_RUNNING	= ( CFR_IDLE + 1 ) ,
	CFR_COMPLETE	= ( CFR_RUNNING + 1 ) ,
	CFR_CANCEL	= ( CFR_COMPLETE + 1 ) ,
	CFR_ERROR	= ( CFR_CANCEL + 1 ) 
    } ;
typedef DWORD VSCUSTOMFINDSTATUS;

typedef struct _VSBROWSESCOPE
    {
    BSTR bstrDisplay;
    BSTR bstrTooltip;
    VARIANT varCanonicalScope;
    } 	VSBROWSESCOPEW;

typedef struct _VSBROWSESCOPE *PVSBROWSESCOPEW;



extern RPC_IF_HANDLE __MIDL_itf_customfind_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_customfind_0000_0000_v0_0_s_ifspec;

#ifndef __IVsRegisterCustomFindScope_INTERFACE_DEFINED__
#define __IVsRegisterCustomFindScope_INTERFACE_DEFINED__

/* interface IVsRegisterCustomFindScope */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsRegisterCustomFindScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72F08BD4-412B-4f54-8B7C-02997C483981")
    IVsRegisterCustomFindScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCustomFindScope( 
            /* [in] */ __RPC__in REFGUID guidSID,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ VSFINDOPTIONS grfEnabledOptions,
            /* [out] */ __RPC__out DWORD_PTR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCustomFindScope( 
            /* [in] */ DWORD_PTR dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsRegisterCustomFindScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsRegisterCustomFindScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsRegisterCustomFindScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsRegisterCustomFindScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCustomFindScope )( 
            IVsRegisterCustomFindScope * This,
            /* [in] */ __RPC__in REFGUID guidSID,
            /* [in] */ __RPC__in LPCOLESTR pszName,
            /* [in] */ VSFINDOPTIONS grfEnabledOptions,
            /* [out] */ __RPC__out DWORD_PTR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterCustomFindScope )( 
            IVsRegisterCustomFindScope * This,
            /* [in] */ DWORD_PTR dwCookie);
        
        END_INTERFACE
    } IVsRegisterCustomFindScopeVtbl;

    interface IVsRegisterCustomFindScope
    {
        CONST_VTBL struct IVsRegisterCustomFindScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsRegisterCustomFindScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsRegisterCustomFindScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsRegisterCustomFindScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsRegisterCustomFindScope_RegisterCustomFindScope(This,guidSID,pszName,grfEnabledOptions,pdwCookie)	\
    ( (This)->lpVtbl -> RegisterCustomFindScope(This,guidSID,pszName,grfEnabledOptions,pdwCookie) ) 

#define IVsRegisterCustomFindScope_UnRegisterCustomFindScope(This,dwCookie)	\
    ( (This)->lpVtbl -> UnRegisterCustomFindScope(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsRegisterCustomFindScope_INTERFACE_DEFINED__ */


#ifndef __IVsCustomFindScope_INTERFACE_DEFINED__
#define __IVsCustomFindScope_INTERFACE_DEFINED__

/* interface IVsCustomFindScope */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsCustomFindScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51066B51-499A-419b-A7B3-18C1DB46EB95")
    IVsCustomFindScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCustomFindScopeLookIn( 
            /* [retval][out] */ __RPC__deref_out_opt IVsCustomFindScopeLookIn **ppFindLookIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomFindScopeSearch( 
            /* [retval][out] */ __RPC__deref_out_opt IVsCustomFindScopeSearch **ppBatchFind) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsCustomFindScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsCustomFindScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsCustomFindScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsCustomFindScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomFindScopeLookIn )( 
            IVsCustomFindScope * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsCustomFindScopeLookIn **ppFindLookIn);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomFindScopeSearch )( 
            IVsCustomFindScope * This,
            /* [retval][out] */ __RPC__deref_out_opt IVsCustomFindScopeSearch **ppBatchFind);
        
        END_INTERFACE
    } IVsCustomFindScopeVtbl;

    interface IVsCustomFindScope
    {
        CONST_VTBL struct IVsCustomFindScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsCustomFindScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsCustomFindScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsCustomFindScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsCustomFindScope_GetCustomFindScopeLookIn(This,ppFindLookIn)	\
    ( (This)->lpVtbl -> GetCustomFindScopeLookIn(This,ppFindLookIn) ) 

#define IVsCustomFindScope_GetCustomFindScopeSearch(This,ppBatchFind)	\
    ( (This)->lpVtbl -> GetCustomFindScopeSearch(This,ppBatchFind) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsCustomFindScope_INTERFACE_DEFINED__ */


#ifndef __IVsCustomFindScopeLookIn_INTERFACE_DEFINED__
#define __IVsCustomFindScopeLookIn_INTERFACE_DEFINED__

/* interface IVsCustomFindScopeLookIn */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsCustomFindScopeLookIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B82E262A-A6A4-407f-B562-42785C2C61FC")
    IVsCustomFindScopeLookIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Browse( 
            /* [out][in] */ __RPC__inout PVSBROWSESCOPEW pBrowseScope) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsCustomFindScopeLookInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsCustomFindScopeLookIn * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsCustomFindScopeLookIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsCustomFindScopeLookIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *Browse )( 
            IVsCustomFindScopeLookIn * This,
            /* [out][in] */ __RPC__inout PVSBROWSESCOPEW pBrowseScope);
        
        END_INTERFACE
    } IVsCustomFindScopeLookInVtbl;

    interface IVsCustomFindScopeLookIn
    {
        CONST_VTBL struct IVsCustomFindScopeLookInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsCustomFindScopeLookIn_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsCustomFindScopeLookIn_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsCustomFindScopeLookIn_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsCustomFindScopeLookIn_Browse(This,pBrowseScope)	\
    ( (This)->lpVtbl -> Browse(This,pBrowseScope) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsCustomFindScopeLookIn_INTERFACE_DEFINED__ */


#ifndef __IVsCustomFindScopeSearch_INTERFACE_DEFINED__
#define __IVsCustomFindScopeSearch_INTERFACE_DEFINED__

/* interface IVsCustomFindScopeSearch */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsCustomFindScopeSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC70E6DE-4B40-438f-8F83-AFE1CC6AB101")
    IVsCustomFindScopeSearch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ VSBROWSESCOPEW VsBrowseScope,
            /* [in] */ __RPC__in LPCOLESTR pszFind,
            /* [in] */ __RPC__in LPCOLESTR pszFilter,
            /* [in] */ VSFINDOPTIONS grfOptions,
            /* [in] */ __RPC__in_opt IVsCustomFindScopeNotify *pBatchFindNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Replace( 
            /* [in] */ VSBROWSESCOPEW VsBrowseScope,
            /* [in] */ __RPC__in LPCOLESTR pszFind,
            /* [in] */ __RPC__in LPCOLESTR pszReplace,
            /* [in] */ __RPC__in LPCOLESTR pszFilter,
            /* [in] */ VSFINDOPTIONS grfOptions,
            /* [in] */ __RPC__in_opt IVsCustomFindScopeNotify *pBatchFindNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrStatus,
            /* [retval][out] */ __RPC__out VSCUSTOMFINDSTATUS *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsCustomFindScopeSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsCustomFindScopeSearch * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsCustomFindScopeSearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsCustomFindScopeSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Find )( 
            IVsCustomFindScopeSearch * This,
            /* [in] */ VSBROWSESCOPEW VsBrowseScope,
            /* [in] */ __RPC__in LPCOLESTR pszFind,
            /* [in] */ __RPC__in LPCOLESTR pszFilter,
            /* [in] */ VSFINDOPTIONS grfOptions,
            /* [in] */ __RPC__in_opt IVsCustomFindScopeNotify *pBatchFindNotify);
        
        HRESULT ( STDMETHODCALLTYPE *Replace )( 
            IVsCustomFindScopeSearch * This,
            /* [in] */ VSBROWSESCOPEW VsBrowseScope,
            /* [in] */ __RPC__in LPCOLESTR pszFind,
            /* [in] */ __RPC__in LPCOLESTR pszReplace,
            /* [in] */ __RPC__in LPCOLESTR pszFilter,
            /* [in] */ VSFINDOPTIONS grfOptions,
            /* [in] */ __RPC__in_opt IVsCustomFindScopeNotify *pBatchFindNotify);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IVsCustomFindScopeSearch * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrStatus,
            /* [retval][out] */ __RPC__out VSCUSTOMFINDSTATUS *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IVsCustomFindScopeSearch * This);
        
        END_INTERFACE
    } IVsCustomFindScopeSearchVtbl;

    interface IVsCustomFindScopeSearch
    {
        CONST_VTBL struct IVsCustomFindScopeSearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsCustomFindScopeSearch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsCustomFindScopeSearch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsCustomFindScopeSearch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsCustomFindScopeSearch_Find(This,VsBrowseScope,pszFind,pszFilter,grfOptions,pBatchFindNotify)	\
    ( (This)->lpVtbl -> Find(This,VsBrowseScope,pszFind,pszFilter,grfOptions,pBatchFindNotify) ) 

#define IVsCustomFindScopeSearch_Replace(This,VsBrowseScope,pszFind,pszReplace,pszFilter,grfOptions,pBatchFindNotify)	\
    ( (This)->lpVtbl -> Replace(This,VsBrowseScope,pszFind,pszReplace,pszFilter,grfOptions,pBatchFindNotify) ) 

#define IVsCustomFindScopeSearch_GetStatus(This,pbstrStatus,pdwStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,pbstrStatus,pdwStatus) ) 

#define IVsCustomFindScopeSearch_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsCustomFindScopeSearch_INTERFACE_DEFINED__ */


#ifndef __IVsCustomFindScopeNotify_INTERFACE_DEFINED__
#define __IVsCustomFindScopeNotify_INTERFACE_DEFINED__

/* interface IVsCustomFindScopeNotify */
/* [object][unique][version][uuid] */ 


EXTERN_C const IID IID_IVsCustomFindScopeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("169B2F24-BB17-40d8-AE2A-13B651B610CA")
    IVsCustomFindScopeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ VSCUSTOMFINDSTATUS grfStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsCustomFindScopeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsCustomFindScopeNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsCustomFindScopeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsCustomFindScopeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IVsCustomFindScopeNotify * This,
            /* [in] */ VSCUSTOMFINDSTATUS grfStatus);
        
        END_INTERFACE
    } IVsCustomFindScopeNotifyVtbl;

    interface IVsCustomFindScopeNotify
    {
        CONST_VTBL struct IVsCustomFindScopeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsCustomFindScopeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsCustomFindScopeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsCustomFindScopeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsCustomFindScopeNotify_Notify(This,grfStatus)	\
    ( (This)->lpVtbl -> Notify(This,grfStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsCustomFindScopeNotify_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\discoveryservice.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for discoveryservice.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __discoveryservice_h__
#define __discoveryservice_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsDiscoveryService_FWD_DEFINED__
#define __IVsDiscoveryService_FWD_DEFINED__
typedef interface IVsDiscoveryService IVsDiscoveryService;
#endif 	/* __IVsDiscoveryService_FWD_DEFINED__ */


#ifndef __IDiscoverUrlCallBack_FWD_DEFINED__
#define __IDiscoverUrlCallBack_FWD_DEFINED__
typedef interface IDiscoverUrlCallBack IDiscoverUrlCallBack;
#endif 	/* __IDiscoverUrlCallBack_FWD_DEFINED__ */


#ifndef __IDiscoveryResult_FWD_DEFINED__
#define __IDiscoveryResult_FWD_DEFINED__
typedef interface IDiscoveryResult IDiscoveryResult;
#endif 	/* __IDiscoveryResult_FWD_DEFINED__ */


#ifndef __IReferenceInfo_FWD_DEFINED__
#define __IReferenceInfo_FWD_DEFINED__
typedef interface IReferenceInfo IReferenceInfo;
#endif 	/* __IReferenceInfo_FWD_DEFINED__ */


#ifndef __ISchemaReferenceInfo_FWD_DEFINED__
#define __ISchemaReferenceInfo_FWD_DEFINED__
typedef interface ISchemaReferenceInfo ISchemaReferenceInfo;
#endif 	/* __ISchemaReferenceInfo_FWD_DEFINED__ */


#ifndef __IDiscoverySession_FWD_DEFINED__
#define __IDiscoverySession_FWD_DEFINED__
typedef interface IDiscoverySession IDiscoverySession;
#endif 	/* __IDiscoverySession_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_discoveryservice_0000_0000 */
/* [local] */ 












#define DISCOVERY_E_PROXYSETTINGINVALID MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x600)

enum tagDiscoveryNodeType
    {	DiscoveryReferenceInfo	= 1,
	ServiceReferenceInfo	= 2,
	SchemaReferenceInfo	= 3,
	UnrecognizedReference	= 4
    } ;
typedef enum tagDiscoveryNodeType DiscoveryNodeType;



extern RPC_IF_HANDLE __MIDL_itf_discoveryservice_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_discoveryservice_0000_0000_v0_0_s_ifspec;

#ifndef __IVsDiscoveryService_INTERFACE_DEFINED__
#define __IVsDiscoveryService_INTERFACE_DEFINED__

/* interface IVsDiscoveryService */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IVsDiscoveryService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9A32C80-B14D-4ae3-A955-5CBC3E7FAB10")
    IVsDiscoveryService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateDiscoverySession( 
            /* [retval][out] */ __RPC__deref_out_opt IDiscoverySession **pSessionObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsDiscoveryServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsDiscoveryService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsDiscoveryService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsDiscoveryService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDiscoverySession )( 
            IVsDiscoveryService * This,
            /* [retval][out] */ __RPC__deref_out_opt IDiscoverySession **pSessionObject);
        
        END_INTERFACE
    } IVsDiscoveryServiceVtbl;

    interface IVsDiscoveryService
    {
        CONST_VTBL struct IVsDiscoveryServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsDiscoveryService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVsDiscoveryService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVsDiscoveryService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVsDiscoveryService_CreateDiscoverySession(This,pSessionObject)	\
    ( (This)->lpVtbl -> CreateDiscoverySession(This,pSessionObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVsDiscoveryService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_discoveryservice_0000_0001 */
/* [local] */ 

#define SID_SVsDiscoveryService IID_IVsDiscoveryService


extern RPC_IF_HANDLE __MIDL_itf_discoveryservice_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_discoveryservice_0000_0001_v0_0_s_ifspec;

#ifndef __IDiscoverUrlCallBack_INTERFACE_DEFINED__
#define __IDiscoverUrlCallBack_INTERFACE_DEFINED__

/* interface IDiscoverUrlCallBack */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDiscoverUrlCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0EEA651C-B208-4ede-96CE-5194F4DC4E4A")
    IDiscoverUrlCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyDiscoverComplete( 
            /* [in] */ int cookie,
            /* [in] */ __RPC__in_opt IDiscoveryResult *pIDiscoveryResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscoverUrlCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiscoverUrlCallBack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiscoverUrlCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiscoverUrlCallBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDiscoverComplete )( 
            IDiscoverUrlCallBack * This,
            /* [in] */ int cookie,
            /* [in] */ __RPC__in_opt IDiscoveryResult *pIDiscoveryResult);
        
        END_INTERFACE
    } IDiscoverUrlCallBackVtbl;

    interface IDiscoverUrlCallBack
    {
        CONST_VTBL struct IDiscoverUrlCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscoverUrlCallBack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscoverUrlCallBack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscoverUrlCallBack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscoverUrlCallBack_NotifyDiscoverComplete(This,cookie,pIDiscoveryResult)	\
    ( (This)->lpVtbl -> NotifyDiscoverComplete(This,cookie,pIDiscoveryResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscoverUrlCallBack_INTERFACE_DEFINED__ */


#ifndef __IDiscoveryResult_INTERFACE_DEFINED__
#define __IDiscoveryResult_INTERFACE_DEFINED__

/* interface IDiscoveryResult */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDiscoveryResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9A32C91-B14D-4ae3-A955-5CBC3E75FCA5")
    IDiscoveryResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRawXml( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXml) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentXml( 
            /* [in] */ __RPC__in BSTR url,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXml) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceCount( 
            /* [retval][out] */ __RPC__out int *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceInfo( 
            /* [in] */ int pIndex,
            /* [retval][out] */ __RPC__deref_out_opt IReferenceInfo **ppIReferenceInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscoverySession( 
            /* [retval][out] */ __RPC__deref_out_opt IDiscoverySession **discoverySession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUrl( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddWebReference( 
            /* [in] *