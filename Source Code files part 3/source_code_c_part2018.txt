rPassportHistory(user.UserPuid, true);

                    // Just in case we decide to reuse users somehow, check how many times this user
                    // has already switched their passport in the limit interval
                    int recentSwitchCount = 0;
                    foreach (PassportHistoryDetails detail in userPassportHistory.Details)
                    {
                        int daysSince = (DateTime.UtcNow - detail.Timestamp).Duration().Days;

                        if (daysSince < HijackSettings.MachinePassportChangeIntervalDays)
                        {
                            if (detail.Reason == HistoryReason.SwitchUserPassport)
                            {
                                recentSwitchCount++;
                            }
                        }
                    }

                    Global.RO.Info("User has " + recentSwitchCount + " recent changes");

                    if (recentSwitchCount > HijackSettings.UserPassportChangeThreshold)
                    {
                        throw new UnexpectedTestResultException("User's recovery count is already above the threshold");
                    }

                    // Create new machine to add the initial switchings on, so that we have multiple unique machines
                    UacsCommon.PassportUser oldPassport = null;
                    UacsCommon.PassportUser newPassport = null;                    

                    // In order to bypass PASSPORT_NOT_LINKED errors, we're going to makeup a bunch of passports
                    // to use when we're pushing the passport data into the database
                    oldPassport = CreateNewPassport();

                    while (recentSwitchCount < HijackSettings.UserPassportChangeThreshold)
                    {
                        // Create a new passport
                        HijackUtilites.SwitchMachines(user);
                        newPassport = CreateNewPassport();

                        // All the switch times need to be different, so add a few seconds here
                        DateTime switchDate = DateTime.UtcNow.AddMonths(-2).AddSeconds(recentSwitchCount);

                        Global.RO.Info("Adding additional passport switch record");

                        // Throw some passport data into the database
                        UserPassportHistoryAddSproc addPassport = new UserPassportHistoryAddSproc(user.UserPuid, user.MachinePuid, null, switchDate, 0, oldPassport.PassportPuid, newPassport.PassportPuid, HistoryReason.SwitchUserPassport);

                        if (!addPassport.Execute())
                        {
                            throw new UnexpectedTestResultException("Unable to add recovery details for user.");
                        }

                        oldPassport = newPassport;
                        recentSwitchCount++;
                    }

                    Global.RO.Info("User is just below account recovery threshold");

                    String[] servers = Global.XEnv.GetServerListByInterface(Interface.xuacs);
                    eventMonitor = new ServerTestFramework.Utilities.Events(servers);
                    eventMonitor.Source = Interface.xuacs;
                }

                public override void Run()
                {
                    if (!eventMonitor.Init())
                    {
                        Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
                    }

                    Global.RO.Info("Attempting to switch passport...");

                    // move to another machines, and give ourselves some history so we can do the switch
                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.PassportChangeWaitIntervalHours, 0, 0));
                    SwitchPassport();

                    Global.RO.Info("Checking passport history...");
                    PassportHistoryGetResponse userHistory = HijackUtilites.GetUserPassportHistory(user.UserPuid, false);

                    // We're expecting it to be greater than the threshold now
                    if (userHistory.Total <= HijackSettings.UserPassportChangeThreshold)
                    {
                        Global.RO.Warn("User Passport History count didn't increase.  Ensure that passport switches are properly being logged.");
                    }

                    Global.RO.Info("Checking event logs...");
                    if (!eventMonitor.TestForChange((Int64)xonline.common.service.XEvent.Id.ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED))
                    {
                        throw new UnexpectedTestResultException("Unable to find machine passport threshold warning event.");
                    }

                    Global.RO.Success("Found User Passport Threshold warning event.");
                }
            }

            [TestCase, Description("Verify that if a user has changed their passport multiple times on one box, no event is logged"), TestCasePriority(3)]
            public class SwitchPassport_User_NonExcessiveUse : SwitchPassportTestBase
            {
                Events eventMonitor = null;

                public override void PreRun()
                {
                    base.PreRun();

                    // Check the user recovery history so far
                    PassportHistoryGetResponse userPassportHistory = HijackUtilites.GetUserPassportHistory(user.UserPuid, true);

                    // Just in case we decide to reuse users somehow, check how many times this user
                    // has already switched their passport in the limit interval
                    int recentSwitchCount = 0;
                    foreach (PassportHistoryDetails detail in userPassportHistory.Details)
                    {
                        int daysSince = (DateTime.UtcNow - detail.Timestamp).Duration().Days;
                        if (daysSince < HijackSettings.UserPassportChangeIntervalDays)
                        {
                            recentSwitchCount++;
                        }
                    }

                    if (recentSwitchCount > HijackSettings.UserPassportChangeThreshold)
                    {
                        throw new UnexpectedTestResultException("User's recovery count is already above the threshold");
                    }

                    // Create new machine to add the initial switchings on, so that we have multiple unique machines
                    MachineEditor altClient = HijackUtilites.CreateClient();
                    UacsCommon.PassportUser oldPassport = null;
                    UacsCommon.PassportUser newPassport = null;

                    // In order to bypass PASSPORT_NOT_LINKED errors, we're going to makeup a bunch of passports
                    // to use when we're pushing the passport data into the database
                    oldPassport = CreateNewPassport();

                    while (recentSwitchCount < HijackSettings.UserPassportChangeThreshold)
                    {
                        // Alternate between the original client and the alternate
                        UInt64 recoveryMachinePuid = recentSwitchCount % 2 == 0 ? user.MachinePuid : altClient.Id;

                        // Create a new passport
                        newPassport = CreateNewPassport();

                        // All the switch times need to be different, so add a few seconds here
                        DateTime switchDate = DateTime.UtcNow.AddMonths(-2).AddSeconds(recentSwitchCount);

                        // Throw some passport data into the database
                        UserPassportHistoryAddSproc addPassport = new UserPassportHistoryAddSproc(user.UserPuid, user.MachinePuid, null, switchDate, 0, oldPassport.PassportPuid, newPassport.PassportPuid, HistoryReason.SwitchUserPassport);

                        if (!addPassport.Execute())
                        {
                            throw new UnexpectedTestResultException("Unable to add recovery details for user.");
                        }

                        oldPassport = newPassport;
                        recentSwitchCount++;
                    }

                    Global.RO.Info("User is just below account recovery threshold");

                    String[] servers = Global.XEnv.GetServerListByInterface(Interface.xuacs);
                    eventMonitor = new Events(servers);
                    eventMonitor.Source = Interface.xuacs;
                }

                public override void Run()
                {
                    if (!eventMonitor.Init())
                    {
                        Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
                    }

                    Global.RO.Info("Attempting to switch passport...");

                    SwitchPassport();

                    Global.RO.Info("Checking passport history...");
                    PassportHistoryGetResponse userHistory = HijackUtilites.GetUserPassportHistory(user.UserPuid, false);

                    // We're expecting it to be greater than the threshold now
                    if (userHistory.Total <= HijackSettings.UserPassportChangeThreshold)
                    {
                        Global.RO.Warn("User Passport History count didn't increase.  Ensure that passport switches are properly being logged.");
                    }

                    Global.RO.Info("Checking event logs...");
                    if (eventMonitor.TestForChange((Int64)XEvent.Id.ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED))
                    {
                        throw new UnexpectedTestResultException("User passport threshold warning event thrown when not expected.");
                    }

                    Global.RO.Success("User Passport Threshold warning event not found as expected.");
                }
            }

            [TestCase, Description("Verify that if a machine is used to change a passport multiple times in a certain number of days, an event is logged"), TestCasePriority(1)]
            public class SwitchPassport_Machine_ExcessiveUse : SwitchPassportTestBase
            {
                ServerTestFramework.Utilities.Events eventMonitor = null;

                public override void PreRun()
                {
                    base.PreRun();

                    // Check the user recovery history so far
                    PassportHistoryGetResponse userPassportHistory = HijackUtilites.GetMachinePassportHistory(user.MachinePuid, true);

                    int recentSwitchCount = 0;
                    foreach (PassportHistoryDetails detail in userPassportHistory.Details)
                    {
                        int daysSince = (DateTime.UtcNow - detail.Timestamp).Duration().Days;
                        if (daysSince < HijackSettings.MachinePassportChangeIntervalDays)
                        {
                            recentSwitchCount++;
                        }
                    }

                    if (recentSwitchCount > HijackSettings.MachinePassportChangeThreshold)
                    {
                        throw new UnexpectedTestResultException("Machines recovery count is already above the threshold");
                    }

                    while (recentSwitchCount < HijackSettings.MachinePassportChangeThreshold)
                    {
                        //Create a random user and passport
                        UserEditor passportUser = UserEditor.CreateNew();
                        UacsCommon.PassportUser newPassport = CreateNewPassport();

                        // Change and change details for this user on this machine
                        MachinePassportHistoryAddSproc addPassport = new MachinePassportHistoryAddSproc(passportUser.Puid, user.MachinePuid, null, DateTime.UtcNow.AddDays(3), 0, (ulong)passportUser.UserPassportPuid, newPassport.PassportPuid, HistoryReason.SwitchUserPassport);

                        if (!addPassport.Execute())
                        {
                            throw new UnexpectedTestResultException("Unable to add recovery details for user.");
                        }

                        recentSwitchCount++;
                    }

                    Global.RO.Info("Machine is just below account recovery threshold");

                    String[] servers = Global.XEnv.GetServerListByInterface(Interface.xuacs);
                    eventMonitor = new ServerTestFramework.Utilities.Events(servers);
                    eventMonitor.Source = Interface.xuacs;
                }

                public override void Run()
                {
                    if (!eventMonitor.Init())
                    {
                        Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
                    }

                    Global.RO.Info("Attempting to switch passport...");
                    SwitchPassport();

                    Global.RO.Info("Checking passport history...");
                    PassportHistoryGetResponse machineHistory = HijackUtilites.GetMachinePassportHistory(user.MachinePuid, false);
                    // We're expecting it to be greater than the threshold now
                    if (machineHistory.Total <= HijackSettings.MachinePassportChangeThreshold)
                    {
                        Global.RO.Warn("Machine Passport count didn't increase.  Ensure that passport switches are properly being logged.");
                    }

                    Global.RO.Info("Checking event logs...");
                    if (!eventMonitor.TestForChange((Int64)xonline.common.service.XEvent.Id.ACCOUNTS_MACHINE_PASSPORT_THRESHOLD_EXCEEDED))
                    {
                        throw new UnexpectedTestResultException("Unable to find machine recovery threshold warning event.");
                    }

                    Global.RO.Success("Found Machine Threshold warning event.");
                }
            }
        }

        [TestCase, Owner("LukeL"), Description("Verifies that linking a web account creates the correct logs.  NOTE: This is apparently not used in production anymore, but still in use by tests for creating xbox1 accounts.  It is a web API so there is no machine associated with the requests."), TestCasePriority(3)]
        [AsyncGroup(14)]
        public void LinkWebAccount()
        {
            //create the user and machine
            UacsCommon uacs=new UacsCommon();
            Owner owner=uacs.GenerateOwner();
            ulong puid=owner.Create();
            if (puid==0)
            {
                throw new System.Exception("Uacs Owner.Create() failed.");
            }

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox1);

            //call the api
            XRLLinkWebAccount xrl=new XRLLinkWebAccount();
            xrl.cardHolder=owner.cardHolder;
            xrl.cardNumber=owner.cardNumber;
            xrl.postalCode=owner.postalCode;
            xrl.phoneExtension=owner.phoneExtension;
            xrl.phoneNumber=owner.phoneNumber;
            xrl.phonePrefix=owner.phonePrefix;
            xrl.gamertag=owner.gamertag;
            xrl.webId=uacs.GenerateWebId(puid);
            ulong passportPuid=BitConverter.ToUInt64(xrl.webId, 0);

            xrl.ManualPopulateSlot();
            xrl.Slot.machinePuid=machine.Id;
            xrl.Slot.userPuid0=puid;
            xrl.Slot.SetClientType(CSGInfo.ClientType.Xbox);

            Global.RO.Debug("Calling api...");
            XRLLinkWebAccountResponse resp;
            bool result=xrl.Execute(out resp);
            if (!result || xrl.XErr!=0)
            {
                throw new System.Exception("XRLLinkWebAccount call failed: "+xrl.ErrorStatusMessage);
            }

            //verify the user history was recorded
            for (int detailsPass=0; detailsPass<2; ++detailsPass)
            {
                bool details=(detailsPass==1);

                Global.RO.Debug("Checking user "+string.Format("0x{0:X}",puid)+" passport history "+(details?"with":"without")+" details...");
                PassportHistoryGetResponse reply=HijackUtilites.GetUserPassportHistory(puid, details);

                ValueCheck.Test("PassportHistoryGetResponse.Unique", 1, reply.Unique);
                ValueCheck.Test("PassportHistoryGetResponse.Total", 1, reply.Total);
                ValueCheck.Test("PassportHistoryGetResponse.First", System.DateTime.UtcNow, reply.First, new System.TimeSpan(0, 3, 0));
                ValueCheck.Test("PassportHistoryGetResponse.Last", System.DateTime.UtcNow, reply.Last, new System.TimeSpan(0, 3, 0));

                ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                if (details)
                {
                    ValueCheck.Test("Number of details", 1, reply.Details.Count);
                    ValueCheck.Test("Details[0].UserPuid", puid, reply.Details[0].UserPuid);
                    ValueCheck.TestNull("Details[0].MachinePuid", reply.Details[0].MachinePuid);
                    ValueCheck.TestNull("Details[0].IpAddress", reply.Details[0].IpAddress); //web calls don't have an IP in SGInfo
                    ValueCheck.Test("Details[0].Timestamp", reply.First, reply.Details[0].Timestamp, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                    ValueCheck.Test("Details[0].Reason", HistoryReason.LinkWebAccount, reply.Details[0].Reason);
                    ValueCheck.TestNull("Details[0].OldPassportPuid", reply.Details[0].OldPassportPuid);
                    ValueCheck.Test("Details[0].NewPassportPuid", passportPuid, reply.Details[0].NewPassportPuid);
                }
            }


            //verify no machine history was recorded
            {
                Global.RO.Debug("Checking machine "+string.Format("0x{0:X}",machine.Id)+" passport history to verify nothing exists...");
                PassportHistoryGetResponse reply=HijackUtilites.GetMachinePassportHistory(machine.Id, false);
                ValueCheck.Test("PassportHistoryGetResponse.Unique", 0, reply.Unique);
                ValueCheck.Test("PassportHistoryGetResponse.Total", 0, reply.Total);
                ValueCheck.TestNull("PassportHistoryGetResponse.First", reply.First);
                ValueCheck.TestNull("PassportHistoryGetResponse.Last", reply.Last);

            }
        }

        [TestCase, Owner("LukeL"), Description("Verifies that linking an xbox1 account creates the correct logs."), TestCasePriority(0), Ignore("Don't need Xbox1 tests anymore")]
        [AsyncGroup(14)]
        public void LinkXbox1Account()
        {
            //create the user and machine
            UacsCommon uacs=new UacsCommon();
            Owner owner=uacs.GenerateOwner();
            ulong puid=owner.Create();
            if (puid==0)
            {
                throw new System.Exception("Uacs Owner.Create() failed.");
            }

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);

            //call the api
            XRLXeLinkXbox1Account xrl=new XRLXeLinkXbox1Account();

            byte[] userPassport=PassportUtilities.GenerateSessionToken(xrl.Slot.Key);
            byte[] ownerPassport=userPassport;
            //ulong passport_user_puid=PassportUtilities.GetPuidFromSessionToken(userPassport);
            ulong passportPuid=PassportUtilities.GetPuidFromSessionToken(ownerPassport);

            xrl.MachinePuid=machine.Id;
            xrl.Gamertag=owner.gamertag;
            xrl.SignedUserPassportPuid=userPassport;
            xrl.SignedOwnerPassportPuid=ownerPassport;
            xrl.PhoneInfo.PhonePrefix=owner.phonePrefix;
            xrl.PhoneInfo.PhoneNumber=owner.phoneNumber;
            xrl.PhoneInfo.PhoneExtension=owner.phoneExtension;
            xrl.PostalCode=owner.postalCode;
            xrl.CardHolder=owner.cardHolder;
            xrl.CardNumber=owner.cardNumber;

            xrl.ManualPopulateSlot();
            xrl.Slot.machinePuid=machine.Id;
            xrl.Slot.userPuid0=puid;
            xrl.Slot.SetClientType(CSGInfo.ClientType.Xenon);

            Global.RO.Debug("Calling api...");
            bool result=xrl.Execute();
            if (!result || xrl.XErr!=0)
            {
                throw new System.Exception("XRLXeLinkXbox1Account call failed: "+xrl.ErrorStatusMessage);
            }

            //verify the user and machine history was recorded
            for (int lookupPass=0; lookupPass<2; ++lookupPass)
            {
                bool isUserPass=(lookupPass==1);

                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking "+(isUserPass?"user "+string.Format("0x{0:X}",puid):"machine "+string.Format("0x{0:X}",machine.Id))+" passport history "+(details?"with":"without")+" details...");

                    PassportHistoryGetResponse reply;
                    if (isUserPass)
                    {
                        reply=HijackUtilites.GetUserPassportHistory(puid, details);
                    }
                    else
                    {
                        reply=HijackUtilites.GetMachinePassportHistory(machine.Id, details);
                    }

                    ValueCheck.Test("PassportHistoryGetResponse.Unique", 1, reply.Unique);
                    ValueCheck.Test("PassportHistoryGetResponse.Total", 1, reply.Total);
                    ValueCheck.Test("PassportHistoryGetResponse.First", System.DateTime.UtcNow, reply.First.Value, new System.TimeSpan(0, 3, 0));
                    ValueCheck.Test("PassportHistoryGetResponse.Last", System.DateTime.UtcNow, reply.Last.Value, new System.TimeSpan(0, 3, 0));

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Number of details", 1, reply.Details.Count);
                        ValueCheck.Test("Details[0].UserPuid", puid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0].MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                        ValueCheck.Test("Details[0].Timestamp", reply.First.Value, reply.Details[0].Timestamp, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                        ValueCheck.Test("Details[0].Reason", HistoryReason.LinkXbox1Account, reply.Details[0].Reason);
                        ValueCheck.TestNull("Details[0].OldPassportPuid", reply.Details[0].OldPassportPuid);
                        ValueCheck.Test("Details[0].NewPassportPuid", passportPuid, reply.Details[0].NewPassportPuid);
                    }
                }
            }
        }

        [TestCase, Owner("LukeL"), Description("Verifies that replacing the passport generates the correct history entries"), TestCasePriority(0)]
        [AsyncGroup(14)]
        public void PassportChangePassword()
        {
            MachineEditor machine = MachineEditor.CreateNew(MachineType.Xbox360);

            //create user and machine
            XeUser user = new XeUser(true, machine.Id);
            user.PassportPassword = "AmaterasuIs<3";
            user.PassportMemberName = "xbltest-" + System.Guid.NewGuid().ToString() + Global.PassportMemberDomain;

            ulong userPuid = user.Create();

            if (userPuid == 0)
            {
                throw new System.Exception("Uacs XeUser.Create() failed.");
            }

            // switch to the same machine (to create a history record)
            HijackUtilites.SwitchMachines(user, machine.Id);

            {
                XRLXePassportChangePassword xrl = new XRLXePassportChangePassword();

                xrl.Slot.userPuid0 = user.UserPuid;
                xrl.Slot.machinePuid = machine.Id;
                xrl.PassportMemberName = user.PassportMemberName;
                xrl.SessionToken = user.PassportSessionToken;

                // and 3) the encrypted new password using the old password and the new password
                PassportTestClient pptc = new PassportTestClient();
                pptc.Init();
                pptc.GenerateEncryptedCredentials(user.PassportPassword, "Catatonic.1", "Kittysaurus Rex", out xrl.EncryptedPassword);

                Global.RO.Info("Changing password for member: {0}...", user.PassportMemberName);

                if (!xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int)))
                {
                    throw new UnexpectedTestResultException(xrl.GetDumpString());
                }
                if (xrl.XErr != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException(xrl.GetDumpString());
                }
            }


            //verify the user and machine history was recorded
            for (int lookupPass = 0; lookupPass < 2; ++lookupPass)
            {
                bool isUserPass = (lookupPass == 1);

                for (int detailsPass = 0; detailsPass < 2; ++detailsPass)
                {
                    bool details = (detailsPass == 1);

                    Global.RO.Debug("Checking " + (isUserPass ? "user " + string.Format("0x{0:X}", user.UserPuid) : "machine " + string.Format("0x{0:X}", machine.Id)) + " passport history " + (details ? "with" : "without") + " details...");

                    PassportHistoryGetResponse reply;
                    if (isUserPass)
                    {
                        reply = HijackUtilites.GetUserPassportHistory(user.UserPuid, details);
                    }
                    else
                    {
                        reply = HijackUtilites.GetMachinePassportHistory(machine.Id, details);
                    }

                    ValueCheck.Test("PassportHistoryGetResponse.Unique", 1, reply.Unique);
                    ValueCheck.Test("PassportHistoryGetResponse.Total", 2, reply.Total);
                    ValueCheck.Test("PassportHistoryGetResponse.First", System.DateTime.UtcNow, reply.First.Value, TimeSpan.FromMinutes(3));
                    ValueCheck.Test("PassportHistoryGetResponse.Last", System.DateTime.UtcNow, reply.Last.Value, TimeSpan.FromMinutes(3));

                    ValueCheck.Test("Details exist", details, reply.Details != null && reply.Details.Count > 0);
                    if (details)
                    {
                        // records come in reverse chronological order
                        ValueCheck.Test("Number of details", 2, reply.Details.Count);

                        ValueCheck.Test("Details[0].UserPuid", user.UserPuid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0].MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                        ValueCheck.Test("Details[0].Timestamp", reply.Last.Value, reply.Details[0].Timestamp, TimeSpan.FromSeconds(1));
                        ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                        ValueCheck.Test("Details[0].Reason", HistoryReason.PassportChangePassword, reply.Details[0].Reason);
                        // for password changes, puid remains the same
                        ValueCheck.Test("Details[0].OldPassportPuid", user.PassportUserPuid, reply.Details[0].OldPassportPuid);
                        ValueCheck.Test("Details[0].NewPassportPuid", user.PassportUserPuid, reply.Details[0].NewPassportPuid);

                        ValueCheck.Test("Details[1].UserPuid", user.UserPuid, reply.Details[1].UserPuid);
                        ValueCheck.Test("Details[1].MachinePuid", machine.Id, reply.Details[1].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[1].IpAddress);
                        ValueCheck.Test("Details[1].Timestamp", reply.First.Value, reply.Details[1].Timestamp, TimeSpan.FromSeconds(1));
                        ValueCheck.Test("Details[1].Hr", HResult.S_OK, reply.Details[1].Hr);
                        ValueCheck.Test("Details[1].Reason", HistoryReason.CreateLiveAccount, reply.Details[1].Reason);
                        // for account creation old passport is NULL
                        ValueCheck.TestNull("Details[1].OldPassportPuid", reply.Details[1].OldPassportPuid);
                        ValueCheck.Test("Details[1].NewPassportPuid", user.PassportUserPuid, reply.Details[1].NewPassportPuid);
                    }
                }
            }
        }

        [TestCase, Owner("LukeL"), Description("Verifies that setting passport password generates the correct history entries"), TestCasePriority(0)]
        [AsyncGroup(14)]
        public void ReplaceUserPassport()
        {
            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);

            //create user and machine
            XeUser user=new XeUser(true, machine.Id);

            ulong userPuid=user.Create();
            if (userPuid==0)
            {
                throw new System.Exception("Uacs XeUser.Create() failed.");
            }

            //create the passport
            string NewPassportMemberName="xbltest-"+System.Guid.NewGuid().ToString()+Global.PassportMemberDomain;
            string password="AmaterasuIs<3";
            string secretQuestion="Name of first pet";
            string secretAnswer="Kittysaurus Rex";

            // switch to the same machine (to create a history record)
            HijackUtilites.SwitchMachines(user, machine.Id);

            {
                XRLXePassportCreate xrl=new XRLXePassportCreate();
                XRLXePassportCreateResponse reply;

                xrl.Slot.userPuid0=userPuid;
                xrl.Slot.machinePuid=machine.Id;
                xrl.birthdate=System.DateTime.UtcNow.AddYears(-30);
                xrl.countryId=103; //US
                xrl.PassportMemberName=NewPassportMemberName;
                xrl.SecretQuestion=secretQuestion;

                PassportTestClient passport=new PassportTestClient();
                passport.Init();
                passport.GenerateEncryptedCredentials("", password, secretAnswer, out xrl.EncryptedPassword);

                Global.RO.Debug("Calling api...");
                bool result=xrl.Execute(out reply);
                if (!result || xrl.XErr!=0)
                {
                    throw new System.Exception("XRLXePassportCreate call failed: "+xrl.ErrorStatusMessage);
                }
            }

            //invalidate the user's passport
            ulong badPassportPuid=0xBaadD00d|(uint)ServerTestFramework.Utilities.RandomEx.GlobalRandGen.Next();
            UserEditor ue=UserEditor.FromPuid(user.UserPuid);
            ulong currentPassportPuid=(ulong)ue.UserPassportPuid;
            ue.UserWLIDInvalid=1;
            ue.UserPassportPuid=(long)badPassportPuid;
            UodbWS.ExecuteSQLNonQuery("update t_user_passport_puids set bi_user_passport_puid="+(long)badPassportPuid+" where bi_user_passport_puid="+(long)currentPassportPuid, currentPassportPuid);

            //now call replace
            ulong newPassportPuid=HijackUtilites.PassportGetPuidFromMemberName(NewPassportMemberName);
            {
                XRLXeReplaceUserPassport xrl=new XRLXeReplaceUserPassport();
                xrl.MachinePuid=machine.Id;
                xrl.TitleId=0xfffe07d1;
                xrl.UserPuid=userPuid;
                xrl.NewUserPassportMemberName=NewPassportMemberName;
                xrl.SignedNewUserPassportPuid=PassportUtilities.GenerateSessionToken(newPassportPuid, xrl.Slot.Key);

                bool result=xrl.Execute();
                if (!result || xrl.XErr!=0)
                {
                    if (xrl.XErr==HResult.XONLINE_E_ACCOUNTS_REPLACE_PASSPORT_QUEUED) //note that flakey billing box stuff doesn't matter since the logging stuff happens before that, so go ahead and accept errors about it being queued
                    {
                        Global.RO.Warn("XRLXeReplaceUserPassport returned acceptable error: "+xrl.ErrorStatusMessage);
                    }
                    else
                    {
                        throw new System.Exception("XRLXeReplaceUserPassport call failed: "+xrl.ErrorStatusMessage);
                    }
                }
            }

            //verify the user and machine history was recorded
            for (int lookupPass=0; lookupPass<2; ++lookupPass)
            {
                bool isUserPass=(lookupPass==1);

                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking "+(isUserPass?"user "+string.Format("0x{0:X}",user.UserPuid):"machine "+string.Format("0x{0:X}",machine.Id))+" passport history "+(details?"with":"without")+" details...");

                    PassportHistoryGetResponse reply;
                    if (isUserPass)
                    {
                        reply=HijackUtilites.GetUserPassportHistory(user.UserPuid, details);
                    }
                    else
                    {
                        reply=HijackUtilites.GetMachinePassportHistory(machine.Id, details);
                    }

                    ValueCheck.Test("PassportHistoryGetResponse.Unique", 1, reply.Unique);
                    ValueCheck.Test("PassportHistoryGetResponse.Total", 2, reply.Total);
                    ValueCheck.Test("PassportHistoryGetResponse.First", System.DateTime.UtcNow, reply.First.Value, new System.TimeSpan(0, 3, 0));
                    ValueCheck.Test("PassportHistoryGetResponse.Last", System.DateTime.UtcNow, reply.Last.Value, new System.TimeSpan(0, 3, 0));

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);

                    // records are reverse order, look at first record or
                    // the last thing we did - which was replace passport

                    if (details)
                    {
                        // records come in reverse chronological order
                        ValueCheck.Test("Number of details", 2, reply.Details.Count);

                        ValueCheck.Test("Details[0].UserPuid", user.UserPuid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0].MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                        ValueCheck.TestNull("Details[0].IpAddress", reply.Details[0].IpAddress); //the passport queue does not store this, so the api cannot log it so we get null for this
                        ValueCheck.Test("Details[0].Timestamp", reply.Last.Value, reply.Details[0].Timestamp, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                        ValueCheck.Test("Details[0].Reason", HistoryReason.ReplaceUserPassport, reply.Details[0].Reason);
                        // for replace user passport, different passports
                        ValueCheck.Test("Details[0].OldPassportPuid", badPassportPuid, reply.Details[0].OldPassportPuid);
                        ValueCheck.Test("Details[0].NewPassportPuid", newPassportPuid, reply.Details[0].NewPassportPuid);

                        ValueCheck.Test("Details[1].UserPuid", user.UserPuid, reply.Details[1].UserPuid);
                        ValueCheck.Test("Details[1].MachinePuid", machine.Id, reply.Details[1].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[1].IpAddress);
                        ValueCheck.Test("Details[1].Timestamp", reply.First.Value, reply.Details[1].Timestamp, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[1].Hr", HResult.S_OK, reply.Details[1].Hr);
                        ValueCheck.Test("Details[1].Reason", HistoryReason.CreateLiveAccount, reply.Details[1].Reason);
                        // for account creation old passport is NULL
                        ValueCheck.TestNull("Details[1].OldPassportPuid", reply.Details[1].OldPassportPuid);
                        ValueCheck.Test("Details[1].NewPassportPuid", currentPassportPuid, reply.Details[1].NewPassportPuid);
                    }
                }
            }
        }

        [TestGroup, Owner("BenRan"), Description("Tests that UserMachineHistory returns appropriate values")]
        [AsyncGroup(144, 14)]
        public class UserMachineHistoryTrust : TestNode
        {
            [TestCase, Description("Verifies that an Xbox.com MachinePuid is always trusted")]
            public class XboxDotCom_TrustedWithHistory : HijackTestBase
            {
                public override void Run()
                {
                    // 5 days ago, a user changed their passport on Xbox.com, so this user history
                    // has an Xbox.com MachinePuid which should be trusted
                    UInt64 xboxDotComMachinePuid = 0xffed000011223344;
                    UserRecoveryHistoryAddSproc userRecovery = new UserRecoveryHistoryAddSproc(
                        user.UserPuid,
                        xboxDotComMachinePuid,
                        null,
                        DateTime.Now.AddDays(-5),
                        0,
                        user.PassportUserPuid,
                        HistoryReason.SwitchUserPassport);

                    // Let's say we require one day of trust
                    if (!UserMachineHistory.IsTrusted(user.UserPuid, xboxDotComMachinePuid, 24))
                    {
                        throw new UnexpectedTestResultException("Machine untrusted for user when it should be.");
                    }

                    Global.RO.Success("Machine trusted as expected.");
                }
            }

            [TestCase, Description("Verifies that an Xbox.com MachinePuid is always trusted")]
            public class XboxDotCom_TrustedWithOutHistory : HijackTestBase
            {
                public override void Run()
                {
                    UInt64 xboxDotComMachinePuid = 0xffed000011223344;

                    // Let's say we require one day of trust
                    if (!UserMachineHistory.IsTrusted(user.UserPuid, xboxDotComMachinePuid, 24))
                    {
                        throw new UnexpectedTestResultException("Machine untrusted for user when it should be.");
                    }

                    Global.RO.Success("Machine trusted as expected.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IFLICTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IFLICTest\LogValidator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.LiveService;
using ServerTestFramework;

namespace IFLICTest
{
	static class LogValidator
	{
        public static List<string> logLines = new List<string>();
        public static bool Running = false;

        private static List<XmgmtEndpoint> xmgmtEndpoints = new List<XmgmtEndpoint>();
        private static string[] _filter;
        private static string _component;

        private class XmgmtEndpoint
        {
            public System.Net.IPEndPoint[] eps;
            public string _area = "";
            public string _component = "";
        }

        public static void Initialize(string serverInterfaceName, string componentName, string area)
        {
            XmgmtEndpoint xe = new XmgmtEndpoint();

            // find the enpoints...
            xe.eps = ManagementListener.GetXmgmtEndPoints(serverInterfaceName);
            if (xe.eps.Length == 0)
            {
                throw new System.Exception("No servers found for interface: " + serverInterfaceName);
            }

            xe._area = area;
            xe._component = componentName;

            // Start up the listener
            foreach (System.Net.IPEndPoint ep in xe.eps)
            {
                ManagementListener.Listen(ep, componentName, area, ListenerCallback);
            }

            xmgmtEndpoints.Add(xe);
            Running = true;
            
        }

        public static void CleanUp()
        {
            foreach (XmgmtEndpoint xe in xmgmtEndpoints)
            {
                foreach (System.Net.IPEndPoint ep in xe.eps)
                {
                    ManagementListener.Stop(ep, xe._component, xe._area, ListenerCallback);
                }
            }
            Running = false;
        }

        public static void Clear()
        {
            logLines.Clear();
        }

        //callback for when we receive data from the server
        private static void ListenerCallback(ManagementListener.Datagram datagram)
        {
            Global.RO.Debug("ListenerCallback[{0}]: {1}", datagram.Component, datagram.Text);
            logLines.Add(datagram.Component + "::" + datagram.Text);
        }

        public static bool FindNoLogLine()
        {
            // 10 tries, 5 seconds
            for (int attempt = 0; attempt < 10; attempt++)
            {
                System.Threading.Thread.Sleep(500);
                if (logLines.Count > 0)
                {
                    return false;
                }
            }
            return true;
        }

        public static string FindComponentLogLine(string component, params string[] filters)
        {
            // 10 tries, 5 seconds
            for (int attempt = 0; attempt < 10; attempt++)
            {
                System.Threading.Thread.Sleep(500);
                _filter = filters;
                _component = component;

                var foundLines = logLines.Find(ContainsFilters);
                if (!String.IsNullOrEmpty(foundLines))
                {
                    return foundLines;
                }
            }
            return null;
        }

        public static string FindLogLine(params string[] filters)
        {
            // 10 tries, 5 seconds
            for (int attempt = 0; attempt < 10; attempt++)
            {
                System.Threading.Thread.Sleep(500);
                _filter = filters;
                _component = null;
            
                var foundLines = logLines.Find(ContainsFilters);
                if (!String.IsNullOrEmpty(foundLines))
                {
                    return foundLines;
                }
            }
            return null;
        }

        private static bool ContainsFilters(string s)
        {
            if (!String.IsNullOrEmpty(_component))
            {
                if (!s.StartsWith(_component))
                {
                    return false;
                }
            }

            foreach (string filter in _filter)
            {
                if (!s.Contains(filter))
                {
                    return false;
                }
            }
            return true;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IFLICTest\IFLICStress.cs ===
﻿using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.server.stringsvr.module;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace IFLICTest
{
    class IFLICHelper
    {
        private static string _webAddress = "";

        public static string GetURL(string queryString)
        {
            if (_webAddress == "")
            {
                IPEndPoint authSG = new IPEndPoint(Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Address,
                                                    Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Port);
                _webAddress = String.Format("{0}:{1}", authSG.Address.ToString(), authSG.Port.ToString());
            }
            string url = String.Format("http://{0}/{1}?{2}",
                _webAddress,
                "msgserver/logstring2.ashx",
                queryString);

            Global.RO.Debug("GetURL: {0}", url);
            return url;
        }

        /// <summary>
        /// Sends a URL Encoded string to the IFLIC Module
        /// </summary>
        /// <param name="queryString">URL Encoded String</param>
        /// <returns>True on Success</returns>
        public static bool SendRequest(string queryString, string sig)
        {
            WebRequest request = null;
            WebResponse response = null;

            try
            {
                //HttpUtility.UrlEncode(
                System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
                string URL = GetURL(queryString);
                //Global.RO.Info(URL);

                request = WebRequest.Create(URL);
                request.CachePolicy = policy;

                request.Headers.Add("X-IFLCDIGEST", sig);

                response = request.GetResponse();
                //Global.RO.Info("Content type: {0}", response.re);
                Stream receiveStream = response.GetResponseStream();
                StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8);

                //Global.RO.Info("Response stream received:");
                //Global.RO.Info(readStream.ReadToEnd());
                response.Close();
                readStream.Close();
            }
            catch (System.Net.WebException e)
            {
                Global.RO.Info(e.Message);
                return false;
            }
            return true;
        }

    }

    [TestGroup, Owner("JKonkle"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("StringSvr", Component.vortexfd, "/Msgserver/LogString2.ashx")]
    [CompoundCase("VortexFD", Component.vortexfd, "/Vortex/logstring2.ashx")]
    class LogStringStress : TestNode
    {
        [StressTest, TestCase]
        class StaticSmall : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=MoreBlAh";
            string sig = "7AB66DBC6476115BB451D0F7E1FA0F3587BF3B35";

            public override void  Run(RUN_TYPE runType)
 	        {
                SendRequest(queryString, null, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "blah", "MoreBlAh");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }

        [StressTest, TestCase]
        class StaticMedium : IFLICTestBase
        {
            string queryString = "v1=FindCategories&vid=FA090000008C1F1F&v2=en-US&v3=-6%3a00&v4=en&v5=US&v6=Gold&v9=640x480i+S+TV&v10=2%2c2%2c3%2c1&v11=14195&v12=12699&v13=1.000&v14=1%2c1%2c1%2c0&v15=0%2c0%2c0%2c0%2c0%2c0%2c0&v16=0&v17=0%2c0%2c0%2c0%2c0%2c0%2c0%2c0&v18=0%2c0%2c0%2cdisabled&v27=100&v28=1&v22=250&v20=BrowseUI.xur&v25=0&v24=14547&v21=84&v29=3030&v30=1&v31=1&v23=0&events=event6&v8=D&en=UTF-8";
            string sig = "D2E73EA686C1E406C400D37E76A898351EEE2732";

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(queryString, null, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "FindCategories", "FA090000008C1F1F", "BrowseUI");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }

        [StressTest, TestCase]
        class StaticLarge : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&vid=0000000000000000&v2=unknown&v3=-8%3a00&v4=en&v5=US&v6=None&v9=1920x1080p+W+HDMI&v10=2%2c2%2c4%2c0&v11=14195&v12=10247&v13=100.000&v14=1%2c1%2c1%2c0&v15=0%2c0%2c0%2c0%2c0%2c0%2c0&v16=unknown&v17=0%2c0%2c0%2c0%2c0%2c0%2c0%2c0&v18=0%2c0%2c0%2cdisabled&v20=8483&v21=0B32129D40&v22=FFFE07D1&v23=00000080&v24=8015190E&v25=00000021&v26=0000F001&v27=30A84840&v28=00000000&v29=C0A8016800003A46&v34=00000000&v35=01C9F84D06015290&v36=20212300FFFFFFFF00000000&v39=PROD&v40=00000A23&v41=00EACECE&v42=nQCTJAA+rEE.&v43=yzi272v+e8.9&v44=X9.48.0&events=event6&v8=D&en=UTF-8";
            string sig = "205B668E4FF21BD467DBC196C87E23840472ED0C";

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(queryString, null, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "20212300FFFFFFFF00000000", "C0A8016800003A46");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }

        [StressTest, TestCase]
        class BadSigLarge : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&vid=0000000000000000&v2=unknown&v3=-8%3a00&v4=en&v5=US&v6=None&v9=1920x1080p+W+HDMI&v10=2%2c2%2c4%2c0&v11=14195&v12=10247&v13=100.000&v14=1%2c1%2c1%2c0&v15=0%2c0%2c0%2c0%2c0%2c0%2c0&v16=unknown&v17=0%2c0%2c0%2c0%2c0%2c0%2c0%2c0&v18=0%2c0%2c0%2cdisabled&v20=8483&v21=0B32129D40&v22=FFFE07D1&v23=00000080&v24=8015190E&v25=00000021&v26=0000F001&v27=30A84840&v28=00000000&v29=C0A8016800003A46&v34=00000000&v35=01C9F84D06015290&v36=20212300FFFFFFFF00000000&v39=PROD&v40=00000A23&v41=00EACECE&v42=nQCTJAA+rEE.&v43=yzi272v+e8.9&v44=X9.48.0&events=event6&v8=D&en=UTF-8";
            // changed 1 bit
            string sig = "205B668E4FF21BC467DBC196C87E23840472ED0C";

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(queryString, null, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    if (!LogValidator.FindNoLogLine())
                    {
                        throw new UnexpectedTestResultException("Found a log line");
                    }
                }
            }
        }
    }

    [TestGroup, Owner("JKonkle"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("StringSvr", Component.vortexfd, "/Msgserver/LogBinary.ashx")]
    [CompoundCase("VortexFD", Component.vortexfd, "/Vortex/LogBinary.ashx")]
    class LogBinaryStress : TestNode
    {
        [StressTest, TestCase]
        class StaticSmall : IFLICTestBase
        {
            byte[] postBody = null;
            string sig = null;

            public override void PreRun()
            {
                postBody = MakeVxMessage(1, "StaticSmall", null, (uint)17);

                MemoryStream sigContent = new MemoryStream(1000);
                sigContent.Write(postBody, 0, postBody.Length);
                sig = LogCollectorCrypto.CreateSignature(sigContent);
            }

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(null, postBody, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "|StaticSmall||11");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }

        [StressTest, TestCase]
        class StaticMedium : IFLICTestBase
        {
            byte[] postBody = null;
            string sig = null;

            public override void PreRun()
            {
                object[] log = new object[] { "StaticMedium", null, (uint)18, "Moredatas" };
                postBody = MakeVxMessage(1, new object[][]{
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log
                });

                MemoryStream sigContent = new MemoryStream(1000);
                sigContent.Write(postBody, 0, postBody.Length);
                sig = LogCollectorCrypto.CreateSignature(sigContent);
            }

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(null, postBody, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "|StaticMedium||12|Moredatas");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }

        [StressTest, TestCase]
        class StaticLarge : IFLICTestBase
        {
            byte[] postBody = null;
            string sig = null;

            public override void PreRun()
            {
                object[] log = new object[] { "StaticLarge", null, (uint)19, "Moredatas", "Moreproblems" };
                postBody = MakeVxMessage(1, new object[][]{
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log
                });

                MemoryStream sigContent = new MemoryStream(1000);
                sigContent.Write(postBody, 0, postBody.Length);
                sig = LogCollectorCrypto.CreateSignature(sigContent);
            }

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(null, postBody, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "|StaticLarge||13|Moredatas|Moreproblems");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }

        [StressTest, TestCase]
        class BadSig : IFLICTestBase
        {
            byte[] postBody = null;
            string sig = null;

            public override void PreRun()
            {
                object[] log = new object[] { "BadSig", null, (uint)20, "Moredatas", "Moreproblems" };
                postBody = MakeVxMessage(1, new object[][]{
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log
                });

                sig = "205B668E4FF21BC467DBC196C87E23840472ED0C";
            }

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(null, postBody, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    if (!LogValidator.FindNoLogLine())
                    {
                        throw new UnexpectedTestResultException("Found a log line");
                    }
                }
            }
        }

        [StressTest, TestCase]
        class BadSigLarge : IFLICTestBase
        {
            byte[] postBody = null;
            string sig = null;

            public override void PreRun()
            {
                object[] log = new object[] { "StaticLarge", null, (uint)19, "Moredatas", "Moreproblems" };
                postBody = MakeVxMessage(1, new object[][]{
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log,
                    log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log, log
                });

                sig = "205B668E4FF21BC467DBC196C87E23840472ED0C";
            }

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(null, postBody, sig);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    if (!LogValidator.FindNoLogLine())
                    {
                        throw new UnexpectedTestResultException("Found a log line");
                    }
                }
            }
        }
    }

    [TestGroup, Owner("JKonkle"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("StringSvr", Component.vortexfd, "/Msgserver/LogWeb_v1.ashx")]
    [CompoundCase("VortexFD", Component.vortexfd, "/Vortex/LogWeb_V1.ashx")]
    class LogWebV1Stress : TestNode
    {
        [StressTest, TestCase]
        class TestEvent : IFLICTestBase
        {
            string queryString = "evt=Test&evn=0&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            string cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";

            public override void Run(RUN_TYPE runType)
            {
                SendRequest(queryString, null, null, cookie);

                if (runType == RUN_TYPE.FUNCTIONAL)
                {
                    string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "XboxComTest-Test");
                    ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\ConnectionMgr.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using MemoryMappedFile;
using ServerTestFramework.LiveService.FakeSG;

namespace xonline.test.IGService
{
    public unsafe class ConnectionMgr
    {
        ///////////////////////////////////////////////////
        /// <summary>
        /// SPI Auth Data
        ///	Uses Memory Mapped file to allow direct maniplation of slots
        /// by both Client and Service
        /// Format:  Header then a table of 0xFFFF slot entries for each local IP (interface)
        /// </summary>
        static protected MMF mmf = new MMF();
        protected static byte* mmfPtr = null; // Points to shared data (mmf)
        protected static byte* slotPtrs = null; // Points to Slot tables for each interface
        protected static MmfHeader* header = null; // Points to metadata
        // local interface IP to mmf port tabke mapping
        private static Hashtable mmfPortTableOffset = null;

        protected static readonly int tableSize = 65536 * sizeof(CSGInfo);

        [StructLayout(LayoutKind.Sequential)]
        public struct MmfHeader
        {
            public int Version;
            public int Interfaces;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Sets up Shared Memory Mapped File
        /// </summary>
        public static void SetUpMMF(ArrayList IpList, int CurrentVersion)
        {
            int interfaces = (int)IpList.Count;
            uint size = (uint)(sizeof(MmfHeader) + (interfaces * tableSize));
            mmf.Create(size);

            mmfPtr = mmf.GetData();

            slotPtrs = mmfPtr + sizeof(MmfHeader);

            header = (MmfHeader*)mmfPtr;
            header->Interfaces = interfaces;
            header->Version = CurrentVersion;

            // Set up mapping of local interface IP to offset of port table in mmf
            mmfPortTableOffset = new Hashtable((int)IpList.Count);
            for (int i = 0; i < interfaces; ++i)
            {
                int offset = i * tableSize;
                mmfPortTableOffset[IpList[i]] = offset;
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Gets version in user when MMF was created
        /// </summary>
        /// <returns>Version number in MMF header</returns>
        public static int GetMMFVersion()
        {
            return header->Version;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Retries data from shared MMF
        /// </summary>
        /// <param name="port">Port for which data is requested</param>
        /// <param name="localIp">IP of interface requtest came in on</param>
        /// <returns>SPI Auth data</returns>
        public static unsafe CSGInfo FindSlotByPort(ushort port, IPAddress localIp)
        {
            CSGInfo* pMirror = (CSGInfo*)(slotPtrs + (int)mmfPortTableOffset[localIp]);
            return pMirror[port];
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Set a block of SPI Auth data to the Service to use
        /// </summary>
        /// <param name="slot">Loaded SPI Auth Data</param>
        /// <param name="srcIp">IP address of interface XRL request was sent out on</param>
        public static void PutSlot(ref CSGInfo Slot, IPAddress srcIp)
        {
            int interfaceIndex = 0;
            if (mmfPortTableOffset.ContainsKey(srcIp))
            {
                interfaceIndex = (int)mmfPortTableOffset[srcIp];
            }

            CSGInfo* pMirror = (CSGInfo*)(slotPtrs + interfaceIndex);
            pMirror[Slot.port] = Slot;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get number of serviced interfaces
        /// </summary>
        /// <returns>Number of interfaces service is listening on</returns>
        public static int GetInterfaceCount()
        {
            return mmfPortTableOffset.Count;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get the interface at a particular offset.  This makes sure the hash
        /// table the client uses to map local IP addresses to mmf slot data is the same as the 
        /// one used by the service.
        /// </summary>
        /// <param name="index">Interface index</param>
        /// <returns></returns>
        public static IPAddress GetInterfaceAddress(int offset)
        {
            foreach (IPAddress ip in mmfPortTableOffset.Keys)
            {
                if ((int)mmfPortTableOffset[ip] == offset)
                    return ip;
            }
            return IPAddress.None;
        }

        public static void Shutdown()
        {
            mmfPtr = null;
            slotPtrs = null;
            header = null;

            mmf.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HitWebCaches\WebCache.cs ===
using System;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Collections;

[assembly: RootNode(typeof(HitWebCaches.WebCacheSuite))]

namespace HitWebCaches
{
	public class WebCacheSuite : TestNode
	{

    [TestGroup]
	public class WebCacheGroup: TestNode
	{
		public WebCacheGroup()
		{
			Add(new HitWebCache_OneServer());
			Add(new HitWebCache_AllServers());
		}
	}

	public class HitWebCache_OneServer : TestBase
	{
		protected override void Execute()
		{
			try
			{
				bool result = Util.HitWebCaches(false);
				if (result)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
			catch(Exception e)
			{
				ConsoleX.WriteLine(e);
				ResultCode = TEST_RESULTS.FAILED;
			}			
		}		
	}

	public class HitWebCache_AllServers : TestBase
	{
		protected override void Execute()
		{
			try
			{
				bool result = Util.HitWebCaches(true);
				if (result)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
			catch(Exception e)
			{
				ConsoleX.WriteLine(e);
				ResultCode = TEST_RESULTS.FAILED;
			}			
		}		
	}

	public class Util
	{
		public static bool HitWebCaches(bool bAllServers)
		{				
			Hashtable table = new Hashtable();
			table.Add("wcalerts",		"/Alerts/health.ashx");
			table.Add("wcgeneral",		"/GeneralInfo/health.ashx");
			table.Add("wcmessaging",	"/Messaging/health.ashx");
			table.Add("wcpresence",		"/Presence/health.ashx");
			table.Add("wcquery",		"/Query/health.ashx");
			table.Add("wcsignature",	"/Signature/health.ashx");
			table.Add("wcstats",		"/Stats/health.ashx");
			table.Add("wcstorage",		"/Storage/health.ashx");
			table.Add("wcteams",		"/Teams/health.ashx");
			table.Add("wcusers",		"/UserAccount/health.ashx");
			bool bRetVal=true;
		
			try
			{
				foreach (string strServer in Global.Env.UtilityWebCacheServer.TextFront)
				{	
					ConsoleX.WriteLine("Server: " + strServer);					
					foreach (DictionaryEntry wc in table)
					{
						string strURL = "http://" + strServer + wc.Value;
						ConsoleX.Write("Getting Health Request for " + wc.Key + "...");
						HttpWebRequest HTTPRequest = (HttpWebRequest)HttpWebRequest.Create(strURL);
						HttpWebResponse HTTPResponse = (HttpWebResponse)HTTPRequest.GetResponse();
						if (HTTPResponse.StatusCode != System.Net.HttpStatusCode.OK)
						{
							ConsoleX.WriteLine("FAILURE: GET request for URL: " + strURL + " returned status code: " + 
								HTTPResponse.StatusCode);
							bRetVal=false;
						}
						else
						{
							ConsoleX.WriteLine("SUCCESS");
						}
					}
					if (bAllServers == false) break;
				}
			}
			catch (WebException e)
			{
				if (e.Status == WebExceptionStatus.ProtocolError)
				{
					HttpWebResponse response = (HttpWebResponse)e.Response;
					ConsoleX.WriteLine("A protocol error occurred. Response Status code: " +
						response.StatusCode);
				}
				else
				{
					ConsoleX.WriteLine(e);
				}
				bRetVal=false;
			}
			catch(Exception e)
			{
				ConsoleX.WriteLine(e);
				bRetVal=false;
			}
		
			return bRetVal;						
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IFLICTest\LogCollectorCrypto.cs ===
﻿using System.IO;
using System.Security.Cryptography;


namespace xonline.server.stringsvr.module
{
	internal class LogCollectorCrypto
	{
       
        private static readonly byte[] keyMask = new byte[] 
        {
            0xbb, 0xe9, 0x98, 0x69, 0xb9, 0x8d, 0xc8, 0xfd, 
            0x8a, 0x69, 0x19, 0xb9, 0x09, 0x88, 0xc8, 0xfd,
            0x2b, 0x09, 0xd9, 0x69, 0x39, 0xa9
        };
        private static readonly byte[] protectedKey = new byte[]
        {
            0xa7, 0x80, 0xa9, 0x04, 0x22, 0x4f, 0xd6, 0x1e, 0x03, 0x5f, 0x51, 0x02, 0xae, 0x34, 0xcb, 0x7a
        };

        private static byte [] GetKey()
        {
            byte[] signingKey = new byte[protectedKey.Length];

            for (int i = 0; i < protectedKey.Length; i++)
            {
                signingKey[i] = (byte)(keyMask[i] ^ protectedKey[i]);
            }

            return signingKey;
        }

        public static bool VerifySignature(byte[] signature, Stream content)
        {
            using (HMACSHA1 hasher = new HMACSHA1(GetKey()))
            {
                content.Seek(0, SeekOrigin.Begin);
                byte[] computedSignature = hasher.ComputeHash(content);

                if (computedSignature.Length != signature.Length)
                {
                    return false;
                }

                for (uint currentByte = 0; currentByte < computedSignature.Length; ++currentByte)
                {
                    if (signature[currentByte] != computedSignature[currentByte])
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static string CreateSignature(Stream content)
        {
            content.Seek(0, SeekOrigin.Begin);
            using (HMACSHA1 hasher = new HMACSHA1(GetKey()))
            {
                byte[] computedSignature = hasher.ComputeHash(content);

                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                foreach (byte chunk in computedSignature)
                {
                    sb.Append(chunk.ToString("X2"));
                }

                return sb.ToString();
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\IGNetwork.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

namespace xonline.test.IGService
{

    public class IGNetwork
    {
        private static IGNetwork[] _Network = null;
        private static ushort TCPPort = 3074;

        public static void Initialize(ArrayList IPList)
        {
            if (_Network != null)
            {
                throw new Exception("IGNetwork already initialized");
            }
            _Network = new IGNetwork[IPList.Count];
            int index = 0;
            foreach (IPAddress ipAddress in IPList)
            {
                IGNetwork network = new IGNetwork(new IPEndPoint(ipAddress, TCPPort));
                network.StartListening();
                _Network[index] = network;
                index++;
            }
        }
        public static void Shutdown()
        {
            foreach (IGNetwork network in _Network)
            {
                network.Stop();
            }
        }

        private Socket _Socket;
        private IPEndPoint _EndPoint;
        private Hashtable EstablishedConnections = new Hashtable();
        private ArrayList PendingConnections = new ArrayList();
        public IGNetwork(IPEndPoint Endpoint)
        {
            _EndPoint = Endpoint;
        }

        public IPEndPoint EndPoint
        {
            get
            {
                return _EndPoint;
            }
        }

        public void Stop()
        {
            _Socket.Close();
            _Socket = null;
        }

        public void StartListening()
        {
            _Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _Socket.Blocking = false;

            _Socket.Bind(_EndPoint);
            _Socket.Listen(5);

            _Socket.BeginAccept(new AsyncCallback(this.OnAcceptComplete), this);
        }

        private void OnAcceptComplete(IAsyncResult ar)
        {
            // Wrap the incoming socket in a connection object
            if (null != _Socket)
            {
                Socket s = _Socket.EndAccept(ar);

                OnClientAccepted(s);

                // Prepare the next accept
                _Socket.BeginAccept(new AsyncCallback(this.OnAcceptComplete), this);
            }
        }

        // Called from the accept socket to add new client connections
        private void OnClientAccepted(Socket socket)
        {
            lock (this)
            {
                Connection conn = new Connection(socket);
                PendingConnections.Add(conn);
                // this will register itself when the connection becomes established(after hello)
                new MessageHandler(this, conn);
            }
        }

        public void OnClientEstablished(MessageHandler msgHandler)
        {
            lock (this)
            {
                PendingConnections.Remove(msgHandler.Connection);
                string ClientKey = msgHandler.ClientKey;
                if (EstablishedConnections.ContainsKey(ClientKey))
                {
                    MessageHandler oldMsgHandler = EstablishedConnections[ClientKey] as MessageHandler;
                    oldMsgHandler.AttachConnection(msgHandler.Connection);
                    msgHandler.DetatchConnection();
                }
                else
                {
                    EstablishedConnections.Add(ClientKey, msgHandler);
                }
            }
        }


    }

    public class MessageHandler
    {
        private IGNetwork _Network = null;
        private Connection _Connection = null;
        private string _ClientKey = null;
        private const uint MaxDeferredQueueSize = 2048;
        private Queue _DeferredMessageQueue = Queue.Synchronized(new Queue());
        private int Sending = 0;

        public MessageHandler(IGNetwork Network, Connection Conn)
        {
            AttachConnection(Conn);
            _Network = Network;
        }

        public void AttachConnection(Connection Conn)
        {
            if (_Connection != null)
            {
                _Connection.Disconnect();
                DetatchConnection();
            }

            _Connection = Conn;
            _Connection.Received += new Connection.ReceivedEventHandler(OnReceivedEventHandler);
            _Connection.SentNotification += new Connection.Sent(OnSent);
            // start to send 
            OnSent(_Connection);
        }

        public void DetatchConnection()
        {
            if (_Connection != null)
            {
                _Connection.Received -= new Connection.ReceivedEventHandler(OnReceivedEventHandler);
                _Connection.SentNotification -= new Connection.Sent(OnSent);
                _Connection = null;
            }
        }

        private void OnReceivedEventHandler(object oSender, Connection.ReceivedEventArgs oArgs)
        {
            if (_Connection != oSender)
            {
                return;
            }

            switch (oArgs.MessageType)
            {
                case IG_MSG_TYPES.IGMSG_HELLO:
                    {
                        IGHelloMsgData msgData = oArgs.MessageData as IGHelloMsgData;
                        this._ClientKey = msgData.szDescription;
                        _Network.OnClientEstablished(this);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_ADD_XBOX_REQ:
                    {
                        IGAddXboxRequestData msgData = oArgs.MessageData as IGAddXboxRequestData;
                        SGADDR sgaddr = IGService.Instance.AddXbox(msgData._xboxId, msgData._titleId, msgData._titleVer, msgData._titleRegion, msgData._rgbKey, msgData._clientVersion, (ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType)msgData._clientType, msgData._languageId);
                        IGAddXboxResponse resp = new IGAddXboxResponse(sgaddr);
                        resp._Header.dwSeqNum = oArgs.SequenceNumber;
                        SendMessage(resp);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_REMOVE_XBOX_REQ:
                    {
                        IGRemoveXboxRequestData msgData = oArgs.MessageData as IGRemoveXboxRequestData;
                        IGService.Instance.RemoveXbox(msgData._xboxId);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_DEAD_XBOX_REQ:
                    {
                        IGDeadXboxRequestData msgData = oArgs.MessageData as IGDeadXboxRequestData;
                        IGService.Instance.DeadXbox(msgData._xboxId);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_CLEAR_XBOX_REQ:
                    {
                        // data doesn't matter since all xboxes will be cleared
                        IGService.Instance.ClearXboxes();
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_ADD_USER_REQ:
                    {
                        IGAddUserRequestData msgData = oArgs.MessageData as IGAddUserRequestData;
                        IGService.Instance.AddUser(msgData._xboxId, msgData._userId, msgData._userFlags, this);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_REMOVE_USER_REQ:
                    {
                        IGRemoveUserRequestData msgData = oArgs.MessageData as IGRemoveUserRequestData;
                        IGService.Instance.RemoveUser(msgData._xboxId, msgData._userId);
                    }
                    break;

                case IG_MSG_TYPES.IGMSG_SET_TITLE_REQ:
                    {
                        IGSetTitleRequestData msgData = oArgs.MessageData as IGSetTitleRequestData;
                        IGService.Instance.SetTitle(msgData._xboxId, msgData._titleId, msgData._titleVer, msgData._titleRegion);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_SET_ALT_TITLES_REQ:
                    {
                        IGSetAltTitlesRequestData msgData = oArgs.MessageData as IGSetAltTitlesRequestData;
                        IGService.Instance.SetAltTitles(msgData._xboxId, msgData._altTitleIds);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_SET_KEY_REQ:
                    {
                        IGSetKeyRequestData msgData = oArgs.MessageData as IGSetKeyRequestData;
                        IGService.Instance.SetKey(msgData._xboxId, msgData._rgbKey);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_SET_USER_STATE_REQ:
                    {
                        IGSetUserStateRequestData msgData = oArgs.MessageData as IGSetUserStateRequestData;
                        IGService.Instance.SetUserState(msgData._xboxId,msgData._userId, msgData._matchSessionId, msgData._state, msgData._titleData, msgData._titleDataLen);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_FD_REQ:
                    {
                        // marshall the request to a new thread so we can process more IO
                        ThreadPool.QueueUserWorkItem(new WaitCallback(ExecuteFDRequest), oArgs);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_LOAD_SLOT_REQ:
                    {
                        IGLoadSlotData msgData = oArgs.MessageData as IGLoadSlotData;
                        CSGInfo sgInfo = IGService.Instance.LoadSlot(msgData._xboxId);
                        IGLoadSlotResponse resp = new IGLoadSlotResponse(sgInfo);
                        resp._Header.dwSeqNum = oArgs.SequenceNumber;
                        SendMessage(resp);
                    }
                    break;
                case IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ:
                    {
                        IGPutSlotData msgData = oArgs.MessageData as IGPutSlotData;
                        IGService.Instance.PutSlot(msgData._sgInfo);
                    }
                    break;
            }

        }

        private void ExecuteFDRequest(object ck)
        {
            Connection.ReceivedEventArgs oArgs = ck as Connection.ReceivedEventArgs;
            IGFDRequestData msgData = oArgs.MessageData as IGFDRequestData;
            byte[] response = IGService.Instance.TransactFD(msgData._xboxId, msgData._serviceId, msgData._szUrl, msgData._szRequestType, msgData._rgbHttpHeader, msgData._rgbRequest);
            IGFDResponse resp = new IGFDResponse(response);
            resp._Header.dwSeqNum = oArgs.SequenceNumber;
            SendMessage(resp);
        }

        public void SendMessage(IGMessage Message)
        {
            int sending = Interlocked.Exchange(ref Sending, 1);
            // we are connected and we aren't waiting on a send
            if (_Connection.Connected && sending == 0)
            {
                _Connection.SendMessage(Message);
            }
            else
            {
                lock (_DeferredMessageQueue.SyncRoot)
                {
                    if (Sending == 0)
                    {
                        _Connection.SendMessage(Message);
                    }
                    else
                    {
                        _DeferredMessageQueue.Enqueue(Message);
                    }
                }
            }
        }

        private void OnSent(object oSender)
        {
            if (_Connection != oSender)
            {
                return;
            }
            lock(_DeferredMessageQueue.SyncRoot)
            {
                if (_Connection.Connected && _DeferredMessageQueue.Count > 0)
                {
                    IGMessage Message = _DeferredMessageQueue.Dequeue() as IGMessage;
                    if (Message != null)
                    {
                        _Connection.SendMessage(Message);
                    }
                }
                else
                {
                    Interlocked.Exchange(ref Sending, 0);
                }
            }
        }

        public string ClientKey
        {
            get
            {
                return _ClientKey;
            }
        }

        public Connection Connection
        {
            get
            {
                return _Connection;
            }
        }
    }

    public class Connection
    {
        private const int DefaultContextBufferSize = 512;
        private IGMessageHeader _Header = null;
        private IGMessageData _Data = null;
        
        // Context used to track async message completions
        // for send
        private class SendContext
        {
            public byte[] Payload;
            public int Pending;
        }

        public enum State
        {
            Disconnected,
            Disconnecting,
            Connecting,
            Connected
        }

        // Connection settings
        private Socket _Socket;

        // Local packet queue
        private State _State;
        private Exception _Exception;
        private byte[] _Scratch;
        private MemoryStream _ReadBuffer;

        public class ReceivedEventArgs : EventArgs
        {
            public ReceivedEventArgs(IG_MSG_TYPES messageType, IGMessageData Data, uint sequenceNumber)
            {
                this.messageType = messageType;
                this.Data = Data;
                this.sequenceNumber = sequenceNumber;
            }
            public IG_MSG_TYPES MessageType
            {
                get
                {
                    return messageType;
                }
            }

            public object MessageData
            {
                get
                {
                    return Data;
                }
            }

            public uint SequenceNumber
            {
                get
                {
                    return sequenceNumber;
                }
            }

            private readonly IG_MSG_TYPES messageType;
            private readonly IGMessageData Data;
            private readonly uint sequenceNumber;
        }
        
        public event ReceivedEventHandler Received;
        public delegate void ReceivedEventHandler(object oSender, ReceivedEventArgs oArgs);

        public Sent SentNotification;
        public delegate void Sent(object oSender);

        //
        // Property accessors
        //
        public bool Connected
        {
            get
            {
                return State.Disconnected != _State && State.Disconnecting != _State;
            }
        }

        public bool IsDisconnected
        {
            get
            {
                return State.Disconnected == _State;
            }
        }

        public State SocketState
        {
            get
            {
                return _State;
            }
        }

        public bool IsDiconnected
        {
            get
            {
                return State.Disconnected == _State;
            }
        }

        public Connection(Socket socket)        
        {
            _Scratch = new byte[DefaultContextBufferSize * 4];
            _ReadBuffer = new MemoryStream(DefaultContextBufferSize);
            AttachSocket(socket);
            StartReading((int)IGDefs.IG_MESSAGE_HEADER_SIZE);
        }

        public void AttachSocket(Socket socket)
        {
            _Exception = null;
            _Socket = socket;

            if (null != _Socket && _Socket.Connected)
            {
                _State = State.Connected;
                _Socket.Blocking = false;
                _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, 0);
                _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, 0);
            }
            else
            {
                _State = State.Disconnected;
            }
        }

        public void Disconnect()
        {
            if (null != _Socket && _Socket.Connected)
            {
                _State = State.Disconnecting;
                _Socket.Shutdown(SocketShutdown.Send);
                try
                {
                    _Socket.BeginReceive(_Scratch, 0, _Scratch.Length, 0, new AsyncCallback(this.OnReceiveComplete), this);
                }
                catch
                {
                    // Socket was either intentionally closed locally by a previous call to disconnect
                    // or closed by the remote party 
                    _State = State.Disconnected;
                    _Socket = null;
                }
            }
            else
            {
                try
                {
                    Socket s = _Socket;

                    // Clear members first in case the close throws
                    _Socket = null;
                    _State = State.Disconnected;

                    if (null != s)
                    {
                        s.Close();
                    }
                }
                catch (Exception)
                {
                    // Ignore errors here on final shutdown
                }
            }
        }

        public void SendMessage(IGMessage msg)
        {
            SendContext ctx = new SendContext();

            // Turn the stream into a payload and push it to the async socket
            ctx.Payload = (byte[])msg;
            ctx.Pending = ctx.Payload.Length;

            _Socket.BeginSend(
                    ctx.Payload,
                    0,
                    ctx.Pending,
                    0,
                    new AsyncCallback(this.OnSendComplete),
                    ctx);
        }
        
        private void OnSendComplete(IAsyncResult ar)
        {
            try
            {
                int written = _Socket.EndSend(ar);
                SendContext ctx = ar.AsyncState as SendContext;

                if (null == ctx)
                {
                    throw new ApplicationException("Invalid context async result state was null");
                }

                ctx.Pending -= written;

                if (ctx.Pending < 0)
                {
                    throw new ApplicationException("Invalid send, sent more bytes than were pending on context.");
                }
                else if (ctx.Pending > 0)
                {
                    // Continue sending payload
                    _Socket.BeginSend(
                        ctx.Payload,
                        ctx.Payload.Length - ctx.Pending,
                        ctx.Pending,
                        0,
                        new AsyncCallback(this.OnSendComplete),
                        ctx);
                }
                else
                {
                    // message complete
                    if (SentNotification != null)
                    {
                        SentNotification(this);
                    }
                }
         
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        public void StartReading(int Size)
        {
            if (State.Connected == _State || State.Disconnecting == _State)
            {
                _Socket.BeginReceive(_Scratch, 0, Size > _Scratch.Length ? _Scratch.Length : Size, 0, new AsyncCallback(this.OnReceiveComplete), this);
            }
            else
            {
                throw new ApplicationException(
                        String.Format("Invalid connection state: {0} for StartReading() (requires Connected or Disconnecting)",
                            _State.ToString()));
            }
        }

        private void OnReceiveComplete(IAsyncResult ar)
        {
            try
            {
                int received = 0;

                if (null != _Socket)
                {
                    received = _Socket.EndReceive(ar);
                }

                if (0 == received)
                {
                    // Socket was either intentionally closed locally by a previous call to disconnect
                    // or closed by the remote party 
                    _State = State.Disconnected;
                    Disconnect();
                    return;
                }

                if (_State != State.Connected)
                {
                    return;
                }

                if (received > _Scratch.Length)
                {
                    throw new Exception("Invalid receive, received bytes exceeds scratch buffer size");
                }

                // Buffer reads at the end of the read buffer
                _ReadBuffer.Seek(0, SeekOrigin.End);
                _ReadBuffer.Write(_Scratch, 0, received);
                // Parse header if we don't have it yet
                if (_Header == null)
                {
                    if (_ReadBuffer.Length == IGDefs.IG_MESSAGE_HEADER_SIZE)
                    {
                        _Header = new IGMessageHeader();
                        _ReadBuffer.Seek(0, SeekOrigin.Begin);
                        _Header.ReadStream(_ReadBuffer);
                        _ReadBuffer.SetLength(0);
                        StartReading((int)(_Header.dwMsgLen));
                    }
                    else if(_ReadBuffer.Length > IGDefs.IG_MESSAGE_HEADER_SIZE)
                    {
                        // this shouldn't happen.  
                        throw new Exception("This Shouldn't Happen");
                    }
                    else
                    {
                        // read the rest
                        StartReading((int)(IGDefs.IG_MESSAGE_HEADER_SIZE - _ReadBuffer.Length));
                    }
                }
                else
                {
                    if (_ReadBuffer.Length == _Header.dwMsgLen)
                    {
                        _Data = IGMessageData.GetInstance(_Header);
                        _ReadBuffer.Seek(0, SeekOrigin.Begin);
                        _Data.ReadStream(_ReadBuffer);
                        _ReadBuffer.SetLength(0);

                        // Do something with the Data
                        ReceivedEventArgs rea = new ReceivedEventArgs((IG_MSG_TYPES)_Header.dwMsgType, _Data, _Header.dwSeqNum);
                        if (Received != null)
                        {
                            Received(this, rea);
                        }

                        // Start all over again
                        _Header = null;
                        _Data = null;
                        StartReading((int)(IGDefs.IG_MESSAGE_HEADER_SIZE));
                    }
                    else if (_ReadBuffer.Length > _Header.dwMsgLen)
                    {
                        // this shouldn't happen.  
                        throw new Exception("This Shouldn't Happen");
                    }
                    else
                    {
                        // read the rest
                        StartReading((int)(_Header.dwMsgLen - _ReadBuffer.Length));
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // 
        // Internal interface
        //
        private void HandleException(Exception ex)
        {
            _Exception = ex;
            Disconnect();
        }

        private void AssertState(State state)
        {
            if (_State != state)
            {
                _Exception = new ApplicationException(
                        String.Format("Connection: {0} was in invalid state: {1} != expected state {2}",
                            null != _Socket ? _Socket.ToString() : "<not connected>",
                            _State.ToString(),
                            state.ToString()));
                _State = State.Disconnected;
                _Socket = null;

                throw _Exception;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\IGSocket.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace xonline.test.IGService
{
    public class IGSocket
    {
        // _socketTable is the table of socket - address pairs used by IG
        private static Hashtable  _socketTable = new Hashtable();

        /// <summary>
        /// Finds all ip addresses for IG
        /// </summary>
		/// <returns>List of IPAddress</returns>
        public static ArrayList FindIPAddresses() 
        {
			ArrayList ipAddressArray = new ArrayList();

            // sw is the StreamWriter object to write text to a file
            StreamWriter  sw = new StreamWriter("ig_findconnections.log");

            // Get the host entry for the local host
            IPHostEntry ipHostEntry = Dns.GetHostEntry(Dns.GetHostName());
            foreach(IPAddress ipAddress in ipHostEntry.AddressList) 
            {
                sw.WriteLine("IP Address: {0} ({1})", ipAddress.ToString(), ipAddress.AddressFamily);

                if (AddressFamily.InterNetwork == ipAddress.AddressFamily) 
                {
                    sw.WriteLine("  Valid");
                    ipAddressArray.Add(ipAddress);
                }
                else 
                {
                    sw.WriteLine("  Invalid");
                }

                sw.WriteLine();
            }

			if (0 == ipAddressArray.Count)
			{
				throw new ApplicationException("Cannot find any valid IP addresses.");
			}

            // Explicitly add the Loopback address for xblob configs
			sw.WriteLine( "Loopback Address" );
			ipAddressArray.Add( IPAddress.Loopback );
                    
            sw.Close();

			return ipAddressArray;
        }

        /// <summary>
        /// Initialize initializes the underyling resources needed by IG
        /// </summary>
        public static void Initialize( ArrayList ipAddressArray, ushort port ) 
        {
            foreach(IPAddress ipAddress in ipAddressArray) 
            {
                // Create the socket
                Socket  socket = new Socket( AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

                // http://support.microsoft.com/default.aspx?scid=kb;en-us;263823
                byte[]  optValue = { 0 };
                int	    ioCtl    = 0;
                unchecked
                {
                    ioCtl = (int) (0x80000000 | 0x18000000 | 12);
                }
                socket.IOControl( ioCtl , optValue, null );

                // Bind the socket
                IPEndPoint  ipEndPoint = new IPEndPoint( ipAddress, port );
                socket.Bind( ipEndPoint );

                // Add the socket to the socket table
                _socketTable.Add(ipAddress, socket);
            }
        }

        /// <summary>
        /// Terminate releases the underyling resources needed by IG
        /// </summary>
        public static void Terminate() 
        {
            foreach( Socket socket in _socketTable.Values ) 
            {
                // Close the socket
                socket.Close();
            }

            // Clear the socket table
            _socketTable.Clear();

            // Clear the ip address array
//            _ipAddressArray.Clear();
        }

        /// <summary>
        /// GetSocket returns the socket bound to a paticular ip address
        /// </summary>
        public static Socket GetSocket( 
            IPAddress  ipAddress ) 
        {
            return (Socket)_socketTable[ipAddress];
        }

        /// <summary>
        /// GetSocketArray builds and returns the array of sockets used by IG
        /// </summary>
        public static ArrayList GetSocketArray() 
        {
            // Build the array of sockets
            ArrayList  socketArray = new ArrayList();

            foreach(Socket socket in _socketTable.Values) 
            {
                socketArray.Add(socket);
            }

            return socketArray;
        }

        /// <summary>
        /// Send just redirects to Socket.BeginSendTo
        /// </summary>
        public static void Send(
            Socket    socket,
            byte[]    buffer,
            int       size,
            EndPoint  remoteEP ) 
        {
            socket.BeginSendTo( buffer, 0, size, SocketFlags.None, remoteEP, null, null );
        }

        /// <summary>
        /// CheckReceive checks all sockets for readability
        /// </summary>
        public static ArrayList CheckReceive(
            int  microSeconds ) 
        {
            // Check sockets for readability
            ArrayList  checkRead = GetSocketArray();
            Socket.Select(checkRead, null, null, microSeconds);

            return checkRead;
        }

        /// <summary>
        /// Receive just redirects to Socket.ReceiveFrom
        /// </summary>
        public static int Receive(
            Socket        socket,
            byte[]        buffer,
            ref EndPoint  remoteEP ) 
        {
            return socket.ReceiveFrom(buffer, ref remoteEP);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\IGProtocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using xonline.common.service;
using ServerTestFramework.LiveService.FakeSG;

namespace xonline.test.IGService
{
    public class IGDefs
    {
        public const uint IG_PROTOCOL_VERSION_CURRENT = 1;
        public const uint IG_MESSAGE_HEADER_SIZE = 16;
    }

    public enum IG_MSG_TYPES
    {
        // request types:
        IGMSG_MIN_REQ                    = 1000,
        IGMSG_HELLO                      = 1000,
        IGMSG_ADD_XBOX_REQ               = 1001,
        IGMSG_REMOVE_XBOX_REQ            = 1002,
        IGMSG_DEAD_XBOX_REQ              = 1003,
        IGMSG_CLEAR_XBOX_REQ             = 1004,
        IGMSG_ADD_USER_REQ               = 1005,
        IGMSG_REMOVE_USER_REQ            = 1006,
        IGMSG_SET_TITLE_REQ              = 1007,
        IGMSG_SET_ALT_TITLES_REQ         = 1008,
        IGMSG_SET_KEY_REQ                = 1009,
        IGMSG_SET_USER_STATE_REQ         = 1010,
        IGMSG_FD_REQ                     = 1011,
        IGMSG_LOAD_SLOT_REQ              = 1012,
        IGMSG_PUT_SLOT_REQ               = 1013,
        IGMSG_MAX_REQ                    = 1013,

        // response types:
        IGMSG_MIN_RESP                   = 1100,
        IGMSG_ADD_XBOX_RES               = 1100,
        IGMSG_FD_RES                     = 1101,
        IGMSG_NOTIFICATION               = 1102,
        IGMSG_LOAD_SLOT_RES              = 1103,
        IGMSG_MAX_RESP                   = 1103,
    };

    public class IGMessage : WireData
    {
        public IGMessageHeader _Header;
        public IGMessageData   _Data;

        public IGMessage()
        {
        }

        public IGMessage(IG_MSG_TYPES eType, IGMessageData Data)
        {
            _Header = new IGMessageHeader(eType);
            _Data = Data;
            _Header.dwMsgLen = (uint)(_Data.Size());
        }

        public override int Size()
        {
            return (_Header != null ? _Header.Size() : 0) + (_Data != null ? _Data.Size() : 0);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            _Header.WriteStream(binaryWriter);
            _Data.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _Header = new IGMessageHeader();
            _Header.ReadStream(binaryReader);

            _Data = IGMessageData.GetInstance(_Header);
            _Data.ReadStream(binaryReader);
            return this;
        }
    }

    public class IGMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public IGMessageHeader()
        {
        }

        public IGMessageHeader(IG_MSG_TYPES eType)
        {
            dwProtocolVersion = IGDefs.IG_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)IGDefs.IG_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - IGMessageHeader::WriteStream binaryWriter is null");
            }

            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream binaryReader is null");
            }

            dwProtocolVersion = binaryReader.ReadUInt32();
            dwMsgType = binaryReader.ReadUInt32();
            dwMsgLen = binaryReader.ReadUInt32();
            dwSeqNum = binaryReader.ReadUInt32();
           
            return this;
        }
    } 

    public class IGMessageData : WireData
    {
        public static IGMessageData GetInstance(IGMessageHeader Header)
        {
            IGMessageData data = null;
            switch (Header.dwMsgType)
            {
                case (uint)IG_MSG_TYPES.IGMSG_HELLO:
                    data = new IGHelloMsgData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_ADD_XBOX_REQ:
                    data = new IGAddXboxRequestData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_ADD_XBOX_RES:
                    data = new IGAddXboxResponseData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_REMOVE_XBOX_REQ:
                    data = new IGRemoveXboxRequestData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_DEAD_XBOX_REQ:
                    data = new IGDeadXboxRequestData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_CLEAR_XBOX_REQ:
                    data = new IGRemoveXboxRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_ADD_USER_REQ:
                    data = new IGAddUserRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_REMOVE_USER_REQ:
                    data = new IGRemoveUserRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_TITLE_REQ:
                    data = new IGSetTitleRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_ALT_TITLES_REQ:
                    data = new IGSetAltTitlesRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_KEY_REQ:
                    data = new IGSetKeyRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_USER_STATE_REQ:
                    data = new IGSetUserStateRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_FD_REQ:
                    data = new IGFDRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_FD_RES:
                    data = new IGFDResponseData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_NOTIFICATION:
                    data = new IGNotificationData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_LOAD_SLOT_REQ:
                    data = new IGLoadSlotData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_LOAD_SLOT_RES:
                    data = new IGLoadSlotResponseData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ:
                    data = new IGPutSlotData();
                    break;
            }

            return data;
        }
    }

    public class IGHelloMsg : IGMessage
    {
        public IGHelloMsg(string Description) : base(IG_MSG_TYPES.IGMSG_HELLO, new IGHelloMsgData(Description))
        {
        }
    }

    public class IGHelloMsgData : IGMessageData
    {
        [WireInfo(NullTerminate = true, ArraySize = 79)]
        public string szDescription;

        public IGHelloMsgData()
        {
        }

        public IGHelloMsgData(string Description)
        {
            szDescription = Description;
        }

        public override int Size()
        {
            return 80;
        }
    }

    public class IGAddXboxRequest : IGMessage
    {
        public IGAddXboxRequest(ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, uint clientType, uint languageId)
            : base(IG_MSG_TYPES.IGMSG_ADD_XBOX_REQ, new IGAddXboxRequestData(xboxId, titleId, titleVer, titleRegion, key, clientVersion, clientType, languageId))
        {}
    }

    public class IGAddXboxRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _titleId;
        public uint _titleVer;
        public uint _titleRegion;

        public uint _dwKeySize;
        [WireInfo(SizeParam = "_dwKeySize")]
        public byte[] _rgbKey;
        public ulong _clientVersion;
        public uint _clientType;
        public uint _languageId;

        public IGAddXboxRequestData()
        { }

        public IGAddXboxRequestData(ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, uint clientType, uint languageId)
        {
            _xboxId = xboxId;
            _titleId = titleId;
            _titleVer = titleVer;
            _titleRegion = titleRegion;
            _dwKeySize = (uint)key.Length;
            _rgbKey = key;
            _clientVersion = clientVersion;
            _clientType = clientType;
            _languageId = languageId;
        }

        public override int Size()
        {
            return sizeof(ulong) 
                + sizeof(uint)
                + sizeof(uint)
                + sizeof(uint)
                + sizeof(uint)
                + ((_rgbKey == null) ? 0 : _rgbKey.Length)
                + sizeof(ulong)
                + sizeof(uint)
                + sizeof(uint);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            _dwKeySize = (_rgbKey == null) ? 0 : (uint)_rgbKey.Length;
            
            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_titleId);
            binaryWriter.Write(_titleVer);
            binaryWriter.Write(_titleRegion);
            binaryWriter.Write(_dwKeySize);

            if (_rgbKey != null)
            {
                binaryWriter.Write(_rgbKey);
            }

            binaryWriter.Write(_clientVersion);
            binaryWriter.Write((uint)_clientType);
            binaryWriter.Write(_languageId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _titleId = binaryReader.ReadUInt32();
            _titleVer = binaryReader.ReadUInt32();
            _titleRegion = binaryReader.ReadUInt32();
            _dwKeySize = binaryReader.ReadUInt32();
            _rgbKey = new byte[_dwKeySize];
            if (_dwKeySize > 0)
            {
                _rgbKey = binaryReader.ReadBytes((int)_dwKeySize);
            }
            _clientVersion = binaryReader.ReadUInt64();
            _clientType = binaryReader.ReadUInt32();
            _languageId = binaryReader.ReadUInt32();

            return this;
        }


    }

    public class IGAddXboxResponse : IGMessage
    {
        public IGAddXboxResponse(SGADDR sgaddr)
            : base(IG_MSG_TYPES.IGMSG_ADD_XBOX_RES, new IGAddXboxResponseData(sgaddr))
        { }
    }

    public class IGAddXboxResponseData : IGMessageData
    {
        public SGADDR _sgaddr;

        public IGAddXboxResponseData()
        {
            _sgaddr = new SGADDR();
        }

        public IGAddXboxResponseData(SGADDR sgaddr)
        {
            _sgaddr = sgaddr;
        }

        public override int Size()
        {
            return _sgaddr.Size();
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            _sgaddr.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _sgaddr.ReadStream(binaryReader);
            return this;
        }
    }

    public class IGClearXboxRequest : IGMessage
    {
        public IGClearXboxRequest()
            : base(IG_MSG_TYPES.IGMSG_CLEAR_XBOX_REQ, new IGRemoveXboxRequestData(0))
        { }
    }

    public class IGRemoveXboxRequest : IGMessage
    {
        public IGRemoveXboxRequest(ulong xboxId)
            : base(IG_MSG_TYPES.IGMSG_REMOVE_XBOX_REQ, new IGRemoveXboxRequestData(xboxId))
        { }
    }

    public class IGRemoveXboxRequestData : IGMessageData
    {
        public ulong _xboxId;

        public IGRemoveXboxRequestData()
        { }

        public IGRemoveXboxRequestData(ulong xboxId)
        {
            _xboxId = xboxId;
        }

        public override int Size()
        {
            return sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            return this;
        }


    }

    public class IGDeadXboxRequest : IGMessage
    {
        public IGDeadXboxRequest(ulong xboxId)
            : base(IG_MSG_TYPES.IGMSG_DEAD_XBOX_REQ, new IGDeadXboxRequestData(xboxId))
        { }
    }

    public class IGDeadXboxRequestData : IGMessageData
    {
        public ulong _xboxId;

        public IGDeadXboxRequestData()
        { }

        public IGDeadXboxRequestData(ulong xboxId)
        {
            _xboxId = xboxId;
        }

        public override int Size()
        {
            return sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            return this;
        }
    }

    public class IGAddUserRequest : IGMessage
    {
        public IGAddUserRequest(ulong xboxId, ulong userId, uint userFlags)
            : base(IG_MSG_TYPES.IGMSG_ADD_USER_REQ, new IGAddUserRequestData(xboxId, userId, userFlags))
        { }
    }

    public class IGAddUserRequestData : IGMessageData
    {
        public ulong _xboxId;
        public ulong _userId;
        public uint _userFlags;

        public IGAddUserRequestData()
        { }

        public IGAddUserRequestData(ulong xboxId, ulong userId, uint userFlags)
        {
            _xboxId = xboxId;
            _userId = userId;
            _userFlags = userFlags;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(ulong)
                + sizeof(uint);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_userId);
            binaryWriter.Write(_userFlags);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            _userId = binaryReader.ReadUInt64();
            _userFlags = binaryReader.ReadUInt32();

            return this;
        }
    }

    public class IGRemoveUserRequest : IGMessage
    {
        public IGRemoveUserRequest(ulong xboxId, ulong userId)
            : base(IG_MSG_TYPES.IGMSG_REMOVE_USER_REQ, new IGRemoveUserRequestData(xboxId, userId))
        { }
    }

    public class IGRemoveUserRequestData : IGMessageData
    {
        public ulong _xboxId;
        public ulong _userId;

        public IGRemoveUserRequestData()
        { }

        public IGRemoveUserRequestData(ulong xboxId, ulong userId)
        {
            _xboxId = xboxId;
            _userId = userId;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_userId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            _userId = binaryReader.ReadUInt64();

            return this;
        }
    }

    public class IGSetTitleRequest : IGMessage
    {
        public IGSetTitleRequest(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
            : base(IG_MSG_TYPES.IGMSG_SET_TITLE_REQ, new IGSetTitleRequestData(xboxId, titleId, titleVer, titleRegion))
        { }
    }

    public class IGSetTitleRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _titleId;
        public uint _titleVer;
        public uint _titleRegion;

        public IGSetTitleRequestData()
        { }

        public IGSetTitleRequestData(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            _xboxId = xboxId;
            _titleId = titleId;
            _titleVer = titleVer;
            _titleRegion = titleRegion;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)
                + sizeof(uint)
                + sizeof(uint);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_titleId);
            binaryWriter.Write(_titleVer);
            binaryWriter.Write(_titleRegion);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _titleId = binaryReader.ReadUInt32();
            _titleVer = binaryReader.ReadUInt32();
            _titleRegion = binaryReader.ReadUInt32();

            return this;
        }
    }

    public class IGSetAltTitlesRequest : IGMessage
    {
        public IGSetAltTitlesRequest(ulong xboxId, uint[] altTitleIds)
            : base(IG_MSG_TYPES.IGMSG_SET_ALT_TITLES_REQ, new IGSetAltTitlesRequestData(xboxId, altTitleIds))
        { }
    }

    public class IGSetAltTitlesRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _dwAltTitles;
        [WireInfo(SizeParam = "_dwAltTitles")]
        public uint[] _altTitleIds;

        public IGSetAltTitlesRequestData()
        { }

        public IGSetAltTitlesRequestData(ulong xboxId, uint[] altTitleIds)
        {
            _xboxId = xboxId;
            _dwAltTitles = (uint)altTitleIds.Length;
            _altTitleIds = altTitleIds;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)
                + ((_altTitleIds == null) ? 0 : _altTitleIds.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_dwAltTitles);
            if (_altTitleIds != null)
            {
                for (int iTitle = 0; iTitle < _dwAltTitles; iTitle++)
                {
                    binaryWriter.Write(_altTitleIds[iTitle]);
                }
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _dwAltTitles = binaryReader.ReadUInt32();
            _altTitleIds = new uint[_dwAltTitles];
            for (int iTitle = 0; iTitle < _dwAltTitles; iTitle++)
            {
                _altTitleIds[iTitle] = binaryReader.ReadUInt32();
            }

            return this;
        }
    }

    public class IGSetKeyRequest : IGMessage
    {
        public IGSetKeyRequest(ulong xboxId, byte[] key)
            : base(IG_MSG_TYPES.IGMSG_SET_KEY_REQ, new IGSetKeyRequestData(xboxId, key))
        { }
    }

    public class IGSetKeyRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _dwKeySize;
        [WireInfo(SizeParam = "_dwKeySize")]
        public byte[] _rgbKey;

        public IGSetKeyRequestData()
        { }

        public IGSetKeyRequestData(ulong xboxId, byte[] key)
        {
            _xboxId = xboxId;
            _dwKeySize = (uint)key.Length;
            _rgbKey = key;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)
                + ((_rgbKey == null) ? 0 : _rgbKey.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_dwKeySize);

            if (_rgbKey != null)
            {
                binaryWriter.Write(_rgbKey);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _dwKeySize = binaryReader.ReadUInt32();
            _rgbKey = new byte[_dwKeySize];
            if (_dwKeySize > 0)
            {
                _rgbKey = binaryReader.ReadBytes((int)_dwKeySize);
            }

            return this;
        }
    }

    public class IGSetUserStateRequest : IGMessage
    {
        public IGSetUserStateRequest(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData)
            : base(IG_MSG_TYPES.IGMSG_SET_USER_STATE_REQ, new IGSetUserStateRequestData(xboxId, userId, matchSessionId, state, titleData))
        { }
    }

    public class IGSetUserStateRequestData : IGMessageData
    {
        public ulong _xboxId;
        public ulong _userId;
        public ulong _matchSessionId;
        public uint _state;
        public ushort _titleDataLen;
        public byte[] _titleData;

        public IGSetUserStateRequestData()
        { }

        public IGSetUserStateRequestData(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData)
        {
            _xboxId = xboxId;
            _userId = userId;
            _matchSessionId = matchSessionId;
            _state = state;
            _titleDataLen = (ushort)titleData.Length;
            _titleData = titleData;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(ulong)
                + sizeof(ulong)
                + sizeof(uint)
                + sizeof(ushort)
                + ((_titleData == null) ? 0 : _titleData.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_userId);
            binaryWriter.Write(_matchSessionId);
            binaryWriter.Write(_state);
            binaryWriter.Write(_titleDataLen);
            if (_titleData != null)
            {
                binaryWriter.Write(_titleData);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            _userId = binaryReader.ReadUInt64();
            _matchSessionId = binaryReader.ReadUInt64();
            _state = binaryReader.ReadUInt32();
            _titleDataLen = binaryReader.ReadUInt16();
            _titleData = new byte[_titleDataLen];
            if (_titleDataLen > 0)
            {
                _titleData = binaryReader.ReadBytes((int)_titleDataLen);
            }

            return this;
        }
    }

    public class IGFDRequest : IGMessage
    {
        public IGFDRequest(ulong xboxId, uint serviceId, string url, string RequestType, byte[] HttpHeader, byte[] Request)
            : base(IG_MSG_TYPES.IGMSG_FD_REQ, new IGFDRequestData(xboxId, serviceId, url, RequestType, HttpHeader,  Request))
        { }
    }

    public class IGFDRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _serviceId;

        public ushort _cbUrlLen; // Includes the '\0'
        [WireInfo(SizeParam = "_cbUrlLen", NullTerminate = true)]
        public string _szUrl; // ASCII Null terminated

        public ushort _cbRequestType; // Includes the '\0'
        [WireInfo(SizeParam = "_cbRequestType", NullTerminate = true)]
        public string _szRequestType; // ASCII Null terminated
        
        public uint _dwHttpHeaderSize;
        [WireInfo(SizeParam = "_dwHttpHeaderSize")]
        public byte[] _rgbHttpHeader;

        public uint _dwRequestSize;
        [WireInfo(SizeParam = "_dwRequestSize")]
        public byte[] _rgbRequest;


        public IGFDRequestData()
        { }

        public IGFDRequestData(ulong xboxId, uint serviceId, string url, string RequestType, byte[]HttpHeader,  byte[] Request)
        {
            _xboxId = xboxId;
            _serviceId = serviceId;

            _cbUrlLen = (ushort)url.Length;
            _szUrl = url;

            _cbRequestType = (ushort)RequestType.Length;
            _szRequestType = RequestType;

            _rgbHttpHeader = HttpHeader;
            _dwHttpHeaderSize = (uint)_rgbHttpHeader.Length;

            _rgbRequest = Request;
            _dwRequestSize = (uint)_rgbRequest.Length;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)

                + sizeof(ushort)
                + ((_szUrl == null) ? 0 : _szUrl.Length)

                + sizeof(ushort)
                + ((_szRequestType == null) ? 0 : _szRequestType.Length)

                +sizeof(uint)
                + ((_rgbHttpHeader == null) ? 0 : _rgbHttpHeader.Length)

                +sizeof(uint)
                + ((_rgbRequest == null) ? 0 : _rgbRequest.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_serviceId);


            binaryWriter.Write(_cbUrlLen);

            if (_szUrl != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_szUrl));
            }

            binaryWriter.Write(_cbRequestType);

            if (_szRequestType != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_szRequestType));
            }

            binaryWriter.Write(_dwHttpHeaderSize);

            if (_rgbHttpHeader != null)
            {
                binaryWriter.Write(_rgbHttpHeader);
            }
            binaryWriter.Write(_dwRequestSize);

            if (_rgbRequest != null)
            {
                binaryWriter.Write(_rgbRequest);
            }

            
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _serviceId = binaryReader.ReadUInt32();

            _cbUrlLen = binaryReader.ReadUInt16();
            if (_cbUrlLen > 0)
            {
                _szUrl = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_cbUrlLen));
            }

            _cbRequestType = binaryReader.ReadUInt16();
            if (_cbRequestType > 0)
            {
                _szRequestType = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_cbRequestType));
            }

            _dwHttpHeaderSize = binaryReader.ReadUInt32();
            _rgbHttpHeader = new byte[_dwHttpHeaderSize];
            if (_dwHttpHeaderSize > 0)
            {
                _rgbHttpHeader = binaryReader.ReadBytes((int)_dwHttpHeaderSize);
            }
            _dwRequestSize = binaryReader.ReadUInt32();
            _rgbRequest = new byte[_dwRequestSize];
            if (_dwRequestSize > 0)
            {
                _rgbRequest = binaryReader.ReadBytes((int)_dwRequestSize);
            }

            return this;
        }
    }

    public class IGFDResponse : IGMessage
    {
        public IGFDResponse(byte[] HttpResonse)
            : base(IG_MSG_TYPES.IGMSG_FD_RES, new IGFDResponseData(HttpResonse))
        { }
    }

    public class IGFDResponseData : IGMessageData
    {
        public uint _dwHttpResponseSize;
        [WireInfo(SizeParam = "_dwHttpResponseSize")]
        public byte[] _rgbResponse;

        public IGFDResponseData()
        { }

        public IGFDResponseData(byte[] HttpResponse)
        {
            _rgbResponse = HttpResponse;
            _dwHttpResponseSize = (uint)_rgbResponse.Length;
        }

        public override int Size()
        {
            return sizeof(uint)
                + ((_rgbResponse == null) ? 0 : _rgbResponse.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_dwHttpResponseSize);

            if (_rgbResponse != null)
            {
                binaryWriter.Write(_rgbResponse);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _dwHttpResponseSize = binaryReader.ReadUInt32();
            _rgbResponse = new byte[_dwHttpResponseSize];
            if (_dwHttpResponseSize > 0)
            {
                _rgbResponse = binaryReader.ReadBytes((int)_dwHttpResponseSize);
            }

            return this;
        }
    }

    public class IGNotification : IGMessage
    {
        public IGNotification(ulong userId, bool bIsPush, uint[] qvalData)
            : base(IG_MSG_TYPES.IGMSG_NOTIFICATION, new IGNotificationData(userId, bIsPush, qvalData))
        { }
    }

    public class IGNotificationData : IGMessageData
    {
        public ulong userId;
        public bool bIsPush;
        [WireInfo(ArraySize = 15)]
        public uint[] qvalData;

        public IGNotificationData(){}

        public IGNotificationData(ulong userId, bool bIsPush, uint[] qvalData)
        {
            this.userId = userId;
            this.bIsPush = bIsPush;
            this.qvalData = qvalData;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(bool)
                + 15 * sizeof(uint);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            if(qvalData.Length < 15)
            {
                throw new Exception("Invalid QVal Data");
            }

            binaryWriter.Write(userId);
            binaryWriter.Write(bIsPush);

            for (int i = 0; i < 15; i++)
            {
                binaryWriter.Write(qvalData[i]);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            userId = binaryReader.ReadUInt64();
            bIsPush = binaryReader.ReadBoolean();
            qvalData = new uint[15];
            for (int i = 0; i < 15; i++)
            {
                qvalData[i] = binaryReader.ReadUInt32();
            }

            return this;
        }
    }

    public class IGPutSlot : IGMessage
    {
        public IGPutSlot(CSGInfo sgInfo)
            : base(IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ, new IGPutSlotData(sgInfo))        { }
    }

    public class IGPutSlotData : IGMessageData
    {
        public CSGInfo _sgInfo;

        public IGPutSlotData() { }

        public IGPutSlotData(CSGInfo sgInfo)
        {
            this._sgInfo = sgInfo;
        }

        public override int Size()
        {
            unsafe
            {
                return sizeof(CSGInfo);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    for (int curByte = 0; curByte < sizeof(CSGInfo); curByte++)
                    {
                        binaryWriter.Write(*pbSGInfo);
                        pbSGInfo++;
                    }
                }
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    byte[] baSGInfo = binaryReader.ReadBytes(sizeof(CSGInfo));
                    if (baSGInfo.Length != sizeof(CSGInfo))
                    {
                        throw new Exception("Incorrect Length read");
                    }

                    foreach (byte curByte in baSGInfo)
                    {
                        *pbSGInfo = curByte;
                        pbSGInfo++;
                    }
                }
            }
            return this;
        }
    }

    public class IGLoadSlot : IGMessage
    {
        public IGLoadSlot(ulong xboxId)
            : base(IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ, new IGLoadSlotData(xboxId)) { }
    }

    public class IGLoadSlotData : IGMessageData
    {
        public ulong _xboxId;

        public IGLoadSlotData() { }

        public IGLoadSlotData(ulong xboxId)
        {
            this._xboxId = xboxId;
        }

        public override int Size()
        {
            return sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            binaryWriter.Write(_xboxId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            return this;
        }
    }

    public class IGLoadSlotResponse : IGMessage
    {
        public IGLoadSlotResponse(CSGInfo sgInfo)
            : base(IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ, new IGLoadSlotResponseData(sgInfo)) { }
    }

    public class IGLoadSlotResponseData : IGMessageData
    {
        public CSGInfo _sgInfo;

        public IGLoadSlotResponseData() { }

        public IGLoadSlotResponseData(CSGInfo sgInfo)
        {
            this._sgInfo = sgInfo;
        }

        public override int Size()
        {
            unsafe
            {
                return sizeof(CSGInfo);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    for (int curByte = 0; curByte < sizeof(CSGInfo); curByte++)
                    {
                        binaryWriter.Write(*pbSGInfo);
                        pbSGInfo++;
                    }
                }
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    byte[] baSGInfo = binaryReader.ReadBytes(sizeof(CSGInfo));
                    if (baSGInfo.Length != sizeof(CSGInfo))
                    {
                        throw new Exception("Incorrect Length read");
                    }

                    foreach (byte curByte in baSGInfo)
                    {
                        *pbSGInfo = curByte;
                        pbSGInfo++;
                    }
                }
            }
            return this;
        }
    }

    public class SGADDR : WireData
    {
        public uint                 inaSg;
        public uint                 SpiSg;
        public ulong                XboxID;
        public uint                 abReserved;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(inaSg);
            binaryWriter.Write(SpiSg);
            binaryWriter.Write(XboxID);
            binaryWriter.Write(abReserved);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            inaSg = (uint)binaryReader.ReadInt32();
            SpiSg = (uint)binaryReader.ReadInt32();
            XboxID = (ulong)binaryReader.ReadInt64();
            abReserved = (uint)binaryReader.ReadInt32();

            return this;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ServiceProcess;
using System.ComponentModel;
using System.Configuration.Install;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace IGService
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller serviceInstaller1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
            this.serviceInstaller1 = new System.ServiceProcess.ServiceInstaller();
            // 
            // serviceProcessInstaller1
            // 
            this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
            this.serviceProcessInstaller1.Password = null;
            this.serviceProcessInstaller1.Username = null;
            this.serviceProcessInstaller1.AfterUninstall += new System.Configuration.Install.InstallEventHandler(this.serviceProcessInstaller1_AfterUninstall);
            this.serviceProcessInstaller1.AfterInstall += new System.Configuration.Install.InstallEventHandler(this.serviceProcessInstaller1_AfterInstall);
            // 
            // serviceInstaller1
            // 
            this.serviceInstaller1.ServiceName = "IGService";
            // 
            // ProjectInstaller
            // 
            this.Installers.AddRange(new System.Configuration.Install.Installer[] {
                                                                                      this.serviceProcessInstaller1,
                                                                                      this.serviceInstaller1});

        }
		#endregion

		private string GetName()
		{
			return "Service (IG)";
		}

		private void serviceProcessInstaller1_AfterInstall(object sender, System.Configuration.Install.InstallEventArgs e)
		{
			ConsoleX.WriteLine(CC.GREEN, GetName()+" installed");
		}

		private void serviceProcessInstaller1_AfterUninstall(object sender, System.Configuration.Install.InstallEventArgs e)
		{
			ConsoleX.WriteLine(CC.GREEN, GetName()+" uninstalled");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IFLICTest\IFLICModuleTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.IO;
using xonline.server.stringsvr.module;
using System.Security.Cryptography;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.utilities2;
using System.Web;
using System.Xml;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;

[assembly: RootNode(typeof(IFLICTest.IFLICModuleTest))]

namespace IFLICTest
{
    public enum CertificateUsed
    {
        None,
        Invalid,
        Spoofed,
        Valid
    }

    public class IFLICModuleTest : TestNode
    {
        public override void PreRun (RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                try
                {
                    //LogValidator.Initialize(Interface.stringsvr, Component.stringsvr, XomAreaName.Reporting);
                    LogValidator.Initialize(Interface.vortexfd, Component.vortexfd, XomAreaName.VortexOutput);
                    LogValidator.Initialize(Interface.vortexfd, Component.vortexfd, XomAreaName.VortexOutputUnknown);
                }
                catch (Exception e)
                {
                    Global.RO.Error("{0}", e.ToString());
                }
            }

            // turn off spam for stress
            IFLICTestBase.RO.SetLevelFilter(runType == RUN_TYPE.FUNCTIONAL ? Report.FILTER_ALL : 0);
        }

        public override void PostRun (RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                LogValidator.CleanUp();
            }
        }
    }

    [TestGroup,Owner("JKonkle"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("StringSvr_LowerCase", Component.vortexfd, "/msgserver/logstring2.ashx")]
    [CompoundCase("StringSvr_MixedCase", Component.vortexfd, "/Msgserver/LogString2.ashx")]
    [CompoundCase("StringSvr_UpperCase", Component.vortexfd, "/MSGSERVER/LOGSTRING2.ASHX")]
    [CompoundCase("VortexFD_LowerCase", Component.vortexfd, "/Vortex/logstring2.ashx")]
    [CompoundCase("VortexFD_MixedCase", Component.vortexfd, "/Vortex/LogString2.ashx")]
    [CompoundCase("VortexFD_UpperCase", Component.vortexfd, "/VORTEX/LOGSTRING2.ASHX")]
    public class LogString2Tests : TestNode
    {
        [TestCase, Description("Basic send string with good signature")]
        public class PBasic : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=MoreBlAh";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "blah", "MoreBlAh");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Basic send string with good signature")]
        public class PEmptyValues : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=&v3=MoreBlAh";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "MoreBlAh");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }


        [TestCase, Description("Basic send string with good signature - special chars")]
        public class PSpecial : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=More BlAh&V4=More spaces needed!!-)";
            
            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "blah", "More BlAh", "More spaces needed!!-)");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send a query string with dupicate V1s and V3s"), TestCasePriority(2)]
        public class NDuplicateVs : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=MoreBlAh&v1=LogonFail_Sg&V4=blah&v3=OtherBleh&V5=Comma,Comma";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "blah", "MoreBlAh", "OtherBleh");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send a query string with no Vs"), TestCasePriority(2)]
        public class NNoVs : IFLICTestBase
        {
            string queryString = "Other1=LogonFail_Sg&Other2=blah&Other3=MoreBlAh&Other=LogonFail_Sg&Other4=blah&Other3=OtherBleh";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "blah", "MoreBlAh");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send a query string with only V1"), TestCasePriority(2)]
        public class NV1Only : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Other";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Other");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send a query string with reported IIS % vuln"), TestCasePriority(2)]
        public class NPercentVuln : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=WHAT%";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "WHAT");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send a query string with pre encoded %"), TestCasePriority(2)]
        public class NPercentPercent : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=WHAT%25";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "LogonFail_Sg", "WHAT");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send no Query string"), TestCasePriority(2)]
        public class NNoQueryString : IFLICTestBase
        {
            string queryString = "";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }
         
        [TestCase, Description("Send a Request with a bad signature"), TestCasePriority(2)]
        public class NBadSig : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=MoreBlAh&v4=BadSig";

            override protected void Execute()
            {
                SendRequest(queryString, null, "1122334455667788990011223344556677889900");
                if (!LogValidator.FindNoLogLine())
                {
                    throw new UnexpectedTestResultException("Found a log line");
                }
            }
        }

        [TestCase, Description("Send a Request with a good signature, but extra garbage encoded"), TestCasePriority(2)]
        public class NExtraString : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=MoreBlAh&v4=ExtraString";

            override protected void Execute()
            {
                // Get signature
                MemoryStream sigContent = new MemoryStream(1000);
                byte[] content = System.Text.Encoding.UTF8.GetBytes(queryString + "bunchogarbageextra");
                sigContent.Write(content, 0, content.Length);
                string sig = LogCollectorCrypto.CreateSignature(sigContent);
                SendRequest(queryString, null, sig);
                if (!LogValidator.FindNoLogLine())
                {
                    throw new UnexpectedTestResultException("Found a log line");
                }
            }
        }

        [TestCase, Description("Send a Request with no signature"), TestCasePriority(2)]
        public class NNoSig : IFLICTestBase
        {
            string queryString = "v1=LogonFail_Sg&v2=blah&v3=MoreBlAh&v4=NoSig";

            override protected void Execute()
            {
                SendRequest(queryString, null, null);
                if (!LogValidator.FindNoLogLine())
                {
                    throw new UnexpectedTestResultException("Found a log line");
                }
            }
        }
    }

    [TestGroup, Owner("JKonkle"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("StringSvr_LowerCase", Component.vortexfd, "/msgserver/logbinary.ashx")]
    [CompoundCase("StringSvr_MixedCase", Component.vortexfd, "/Msgserver/LogBinary.ashx")]
    [CompoundCase("StringSvr_UpperCase", Component.vortexfd, "/MSGSERVER/LOGBINARY.ASHX")]
    [CompoundCase("VortexFD_LowerCase", Component.vortexfd, "/Vortex/logbinary.ashx")]
    [CompoundCase("VortexFD_MixedCase", Component.vortexfd, "/Vortex/LogBinary.ashx")]
    [CompoundCase("VortexFD_UpperCase", Component.vortexfd, "/VORTEX/LOGBINARY.ASHX")]
    public class LogBinaryTests : TestNode
    {
        [TestCase, Description("Basic send binary with good signature")]
        public class PBasicBinary : IFLICTestBase
        {
            protected override void Execute()
            {
                byte[] postBody = MakeVxMessage(1, "PBasicBinaryField1", null, (uint)17);
                SendRequest(null, postBody);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "|PBasicBinaryField1||11");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send a Request with a bad signature"), TestCasePriority(2)]
        public class NBadSigBinary : IFLICTestBase
        {
            override protected void Execute()
            {
                byte[] postBody = MakeVxMessage(1, "PBasicBinaryField1", null, (uint)17);
                SendRequest(null, postBody, "1122334455667788990011223344556677889900");
                if (!LogValidator.FindNoLogLine())
                {
                    throw new UnexpectedTestResultException("Found a log line");
                }
            }
        }

        [TestCase, Description("Send a Request with no signature"), TestCasePriority(2)]
        public class NNoSigBinary : IFLICTestBase
        {
            override protected void Execute()
            {
                byte[] postBody = MakeVxMessage(1, "PBasicBinaryField1", null, (uint)17);
                SendRequest(null, postBody, null);
                if (!LogValidator.FindNoLogLine())
                {
                    throw new UnexpectedTestResultException("Found a log line");
                }
            }
        }
    }

    [TestGroup, Owner("JKonkle"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("StringSvr_LowerCase", Component.vortexfd, "/msgserver/logweb_v1.ashx")]
    [CompoundCase("StringSvr_MixedCase", Component.vortexfd, "/Msgserver/LogWeb_V1.ashx")]
    [CompoundCase("StringSvr_UpperCase", Component.vortexfd, "/MSGSERVER/LOGWEB_V1.ASHX")]
    [CompoundCase("VortexFD_LowerCase", Component.vortexfd, "/Vortex/logweb_v1.ashx")]
    [CompoundCase("VortexFD_MixedCase", Component.vortexfd, "/Vortex/LogWeb_V1.ashx")]
    [CompoundCase("VortexFD_UpperCase", Component.vortexfd, "/VORTEX/LOGWEB_V1.ASHX")]
    public class LogWebTests : TestNode
    {
        [TestCase, Description("Basic send web")]
        public class PBasicWeb : IFLICTestBase
        {
            string queryString = "evt=Test&evn=0&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            string cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";

            protected override void Execute()
            {
                SendRequest(queryString, null, null, cookie);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "XboxComTest-Test|Test|0|en-us");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send Web with invalid key header")]
        public class PIgnoreHeaderInvalid : IFLICTestBase
        {
            string queryString = "evt=Test&evn=0&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            string cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";

            protected override void Execute()
            {
                SendRequest(queryString, null, "1122334455667788990011223344556677889900", cookie);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "XboxComTest-Test|Test|0|en-us");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }

        [TestCase, Description("Send Web with valid key header")]
        public class PIgnoreHeaderValid : IFLICTestBase
        {
            string queryString = "evt=Test&evn=0&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            //string cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";

            protected override void Execute()
            {
                SendRequest(queryString, true);
                string temp = LogValidator.FindComponentLogLine((string)Parent.MyValues[0], "XboxComTest-Test|Test|0|en-us");
                ValueCheck.IsTrue(!String.IsNullOrEmpty(temp), "Line found?");
            }
        }
    }

    [TestGroup, Owner("Danalex"), TestFrequency("Daily"), TestCasePriority(1)]
    [CompoundCase("DiscoSvr", Component.vortexfd, "/event/data/v")]

    public class CertificateTests : TestNode
    {
        [TestCase, Description("Sending a valid certificate")]
        public class ValidCertCase : IFLICTestBase
        {
            protected override void Execute()
            {
                HttpWebResponse response = null;
                try
                {
                    SendRequest("", null, null, null, CertificateUsed.Valid, out response);
                }
                catch (WebException e)
                {
                    if (e.Status == WebExceptionStatus.ProtocolError)
                    {
                        //We test the protocol status code later on, so we can eat this.
                        response = e.Response as HttpWebResponse;
                    }
                    else
                    {
                        throw;
                    }
                }

                if (response.StatusCode == HttpStatusCode.NotFound)
                {
                    RO.Info("The access point was not found.  Aborting test.");
                }
                {
                    ValueCheck.IsTrue(response.StatusCode == HttpStatusCode.OK, "Status Code returned " + response.StatusCode.ToString() + ", should be 200 (OK)");
                }
            }
        }

        [TestCase, Description("Sending a certificate that claims to be from Microsoft.com")]
        public class SpoofCertCase : IFLICTestBase
        {
            protected override void Execute()
            {
                HttpWebResponse response = null;
                try
                {
                    SendRequest("", null, null, null, CertificateUsed.Spoofed, out response);
                }
                catch (WebException e)
                {
                    if (e.Status == WebExceptionStatus.ProtocolError)
                    {
                        //We test the protocol status code later on, so we can eat this.
                        response = e.Response as HttpWebResponse;
                    }
                    else
                    {
                        throw;
                    }
                }
                ValueCheck.IsTrue(response.StatusCode == HttpStatusCode.Unauthorized, "Status Code returned " + response.StatusCode.ToString() + ", should be 401 (Unauthorized)");
            }
        }

        [TestCase, Description("Sending a certificate from a completely unauthorized source")]
        public class InvalidCertCase : IFLICTestBase
        {
            protected override void Execute()
            {
                HttpWebResponse response = null;
                try
                {
                    SendRequest("", null, null, null, CertificateUsed.Invalid, out response);
                }
                catch (WebException e)
                {
                    if (e.Status == WebExceptionStatus.ProtocolError)
                    {
                        //We test the protocol status code later on, so we can eat this.
                        response = e.Response as HttpWebResponse;
                    }
                    else
                    {
                        throw;
                    }
                }
                ValueCheck.IsTrue(response.StatusCode == HttpStatusCode.Unauthorized, "Status Code returned " + response.StatusCode.ToString() + ", should be 401 (Unauthorized)");
            }
        }

        [TestCase, Description("Not sending a certificate at all")]
        public class MissingCertCase : IFLICTestBase
        {
            protected override void Execute()
            {
                HttpWebResponse response = null;
                try
                {
                    SendRequest("", null, null, null, CertificateUsed.None, out response);
                }
                catch (WebException e)
                {
                    if (e.Status == WebExceptionStatus.ProtocolError)
                    {
                        //We test the protocol status code later on, so we can eat this.
                        response = e.Response as HttpWebResponse;
                    }
                    else
                    {
                        throw;
                    }
                }
                if (response.StatusCode == HttpStatusCode.NotFound)
                {
                    RO.Info("The access point was not found.  This may be an error.");
                }
                else
                {
                    ValueCheck.IsTrue(response.StatusCode == HttpStatusCode.Unauthorized, "Status Code returned " + response.StatusCode.ToString() + ", should be 401 (Unauthorized)");
                }
            }
        }
    }

    public class IFLICTestBase : TestNode
    {
        public static Report RO = new Report("IFLIC");

        private static string _webAddress = "";

        private static X509Certificate2 validCert = null;
        private static X509Certificate2 spoofCert = null;
        private static X509Certificate2 garbageCert = null;

        public string GetURL(string queryString)
        {
            RO.Debug("Begin Getting URL");
            if (_webAddress == "")
            {
                Init();
            }
            string url = String.Format("http://{0}{1}{2}{3}",
                _webAddress,
                (string)Parent.MyValues[1],
                String.IsNullOrEmpty(queryString) ? "" : "?",
                queryString);

            RO.Debug("GetURL: {0}", url);
            return url;
        }

        public override void Run()
        {
            Execute();
        }

        protected virtual void Execute () { }

        /// <summary>
        /// Sends a URL Encoded string to the IFLIC Module
        /// </summary>
        /// <param name="queryString">URL Encoded String</param>
        /// <returns>True on Success</returns>
        public void SendRequest(string queryString, byte[] postBody)
        {
            // Get signature
            MemoryStream sigContent = new MemoryStream(1000);
            if (!String.IsNullOrEmpty(queryString))
            {
                byte[] content = System.Text.Encoding.ASCII.GetBytes(queryString);
                sigContent.Write(content, 0, content.Length);
            }
            if (postBody != null)
            {
                sigContent.Write(postBody, 0, postBody.Length);
            }
            string sig = LogCollectorCrypto.CreateSignature(sigContent);
            SendRequest(queryString, postBody, sig);
        }

        public void SendRequest(string queryString, byte[] postBody, string sig)
        {
            SendRequest(queryString, postBody, sig, null);
        }

        public void SendRequest(string queryString, byte[] postBody, string sig, string cookie)
        {
            HttpWebResponse response;
            SendRequest(queryString, postBody, sig, cookie, CertificateUsed.None, out response);
        }

        public void SendRequest(string queryString, byte[] postBody, string sig, string cookie, CertificateUsed certType, out HttpWebResponse response)
        {
            LogValidator.Clear();
            ServicePointManager.Expect100Continue = false;

            System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
            string URL = GetURL(queryString);
            RO.Info(URL);

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(URL);
            request.CachePolicy = policy;

            request.Headers["Cookie"] = cookie;
            
            if (sig != null)
            {
                RO.Info(sig);
                request.Headers.Add("X-IFLCDIGEST", sig);
            }

            if (!String.IsNullOrEmpty(queryString))
            {
                request.Method = "GET";
            }
            else if (postBody != null)
            {
                request.Method = "POST";
                if (URL.ToLower().Contains("msgserver"))
                {
                    request.ContentType = "xon/2"; // service id 2
                }
                else if (URL.ToLower().Contains("vortex"))
                {
                    request.ContentType = "xon/20"; // service id 32
                }

                request.ContentLength = postBody.Length;
                using (Stream requestStream = request.GetRequestStream())
                {
                    requestStream.Write(postBody, 0, postBody.Length);
                    requestStream.Flush();

                    RO.Debug("Wrote {0} bytes to stream",
                        postBody.Length);
                }
                System.Threading.Thread.Sleep(100);

            }

            switch(certType)
            {
                case CertificateUsed.Valid:
                    request.ClientCertificates.Add(validCert);
                    break;

                case CertificateUsed.Spoofed:
                    request.ClientCertificates.Add(spoofCert);
                    break;

                case CertificateUsed.Invalid:
                    request.ClientCertificates.Add(garbageCert);
                    break;

                case CertificateUsed.None:
                default:
                    break;
            }

            response = request.GetResponse() as HttpWebResponse;
            //RO.Info("Content type: {0}", response.re);
            Stream receiveStream = response.GetResponseStream();
            StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8);

            RO.Info("Response stream received:");
            RO.Info(readStream.ReadToEnd());
            response.Close();
            readStream.Close();
        }

        //public bool SendRequest(Dictionary<string, string> queryDict)
        //{
        //    StringBuilder sb = new StringBuilder();
        //    foreach (KeyValuePair<string, string> entry in queryDict)
        //    {
        //        sb.Append(String.Format("&{0}={1}", entry.Key, HttpUtility.UrlEncode(entry.Value)));
        //    }
        //    return SendRequest(sb.ToString().TrimStart('&'));
        //}

        public void SendRequest(string queryString, bool parse)
        {
            StringBuilder sb = new StringBuilder();
            if (parse)
            {                
                foreach (string pair in queryString.Split('&'))
                {
                    if (pair.Contains("="))
                    {
                        sb.Append(String.Format("&{0}={1}", pair.Split('=')[0], HttpUtility.UrlEncode(pair.Split('=')[1])));
                    }
                    else
                    {
                        sb.Append(String.Format("&{0}={1}", pair, ""));
                    }
                }

                queryString = sb.ToString().Substring(1);
            }
            
            
            SendRequest(queryString, null);
        }

        public byte[] MakeVxMessage(uint baseEventId, params object[] fields)
        {
            return MakeVxMessage(baseEventId, new object[][] { fields });
        }

        public byte[] MakeVxMessage(uint baseEventId, object[][] fields)
        {
            MemoryStream ms = new MemoryStream(1000);
            VortexBinaryWriter bw = new VortexBinaryWriter(ms);

            // Protocol
            bw.Write((byte)VxProtocol.VxProtocolType.Etx);  // 1=Etx
            // Etx headers
            bw.Write((long)0);

            // Each VxEvent
            foreach (object[] messages in fields)
            {
                Blob producerId = Blob.Parse("11223344556677889900AABBCCDDEEFF");
                VxEvent ve = new VxEvent(producerId, baseEventId, DateTime.UtcNow);
                uint fieldOrdinal = 1;
                // Each field
                foreach (object o in messages)
                {
                    if (o != null)
                    {
                        ve.EventFields.AddField(fieldOrdinal, o);
                    }
                    fieldOrdinal++;
                }
                ve.WriteStream(bw);
            }
            return ms.ToArray();
        }

        private static void Init()
        {
            Assembly curAssembly = Assembly.GetExecutingAssembly();
            string filePath = curAssembly.Location;
            filePath = filePath.Substring(0, filePath.LastIndexOf('\\') + 1);
            string xmlFile = filePath + "IFLICTest.xml";

            bool useExternal = false;
            string extAddr = "";
            int extPort = 13100;

            try
            {
                using (XmlTextReader reader = new XmlTextReader(xmlFile))
                {
                    while (reader.Read())
                    {
                        if (reader.NodeType == XmlNodeType.Element)
                        {
                            switch (reader.Name)
                            {
                                case "UseExternalDNS":
                                    useExternal = reader.ReadElementContentAsBoolean();
                                    break;

                                case "Address":
                                    extAddr = reader.ReadElementContentAsString();
                                    break;

                                case "Port":
                                    extPort = reader.ReadElementContentAsInt();
                                    break;

                                case "ValidCert":
                                    try
                                    {
                                        validCert = new X509Certificate2(filePath + reader.ReadElementContentAsString());
                                    }
                                    catch (CryptographicException)
                                    {
                                    }
                                    break;

                                case "SpoofCert":
                                    try
                                    {
                                        spoofCert = new X509Certificate2(filePath + reader.ReadElementContentAsString());
                                    }
                                    catch (CryptographicException)
                                    {
                                    }
                                    break;

                                case "InvalidCert":
                                    try
                                    {
                                        garbageCert = new X509Certificate2(filePath + reader.ReadElementContentAsString());
                                    }
                                    catch (CryptographicException)
                                    {
                                    }
                                    break;

                                default:
                                    break;
                            }
                        }
                    }
                }
            }
            catch (FileNotFoundException)
            {
                useExternal = false;
            }
            catch (Exception)
            {
                RO.Debug("Well, crap.  Unhandled Exception.");
                throw;
            }

            if (useExternal)
            {
                _webAddress = String.Format("{0}:{1}", extAddr, extPort.ToString());
                RO.Debug("Using External URL: " + _webAddress);
            }

            else
            {
                IPEndPoint authSG = new IPEndPoint(Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Address,
                                                    Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Port);
                _webAddress = String.Format("{0}:{1}", authSG.Address.ToString(), authSG.Port.ToString());
                RO.Debug("Using Internal URL: " + _webAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\ServiceMain.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using ServerTestFramework;

namespace xonline.test.IGService
{
	public class ServiceMain : System.ServiceProcess.ServiceBase
	{
		public ServiceMain()
		{
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;
			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new ServiceMain() };

			System.ServiceProcess.ServiceBase.Run( ServicesToRun );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart( string[] args )
		{
			try
			{
				IGService.Create();
			}
			catch( Exception e )
			{
				EventLog log = new EventLog();
				log.Source = "IG";
				log.WriteEntry( "Uncaught Exception when service starting:\n\n" + e.ToString(), EventLogEntryType.Error );
			}
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			try
			{
				IGService.Destroy();
			}
			catch( Exception e )
			{
				EventLog log = new EventLog();
				log.Source = "IG";
				log.WriteEntry( "Uncaught Exception when service stopping:\n\n" + e.ToString(), EventLogEntryType.Error );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\IGService.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime.Remoting.Services;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.protocol;

namespace xonline.test.IGService
{
    unsafe public class IGService
    {
        // IPs and Port to listen on
        private ArrayList IpList = null;
        private ushort Port = 0xffff;
        private uint _LocalIP = 0;
        private uint masterSpi = 1;

        // Table of Connected Xboxes for QVal processing
        private Hashtable SGXboxInfoSlots = Hashtable.Synchronized(new Hashtable()); 

        // Control Variables    
        private Thread SGThread  = null;  // Message handler thread
        private bool   terminate = false; // Signal for handler thread to terminate

        // Event logging object
        private EventLog Log; 

        // Batched state updates
        private ArrayList  StateUpdateQueue = new ArrayList();
        private IPEndPoint _StateEndpoint = null;
        private IPEndPoint StateEndpoint
        {
            get{
                if (null == _StateEndpoint)
                {
                    lock (Instance)
                    {
                        if (_StateEndpoint == null)
                        {
                            _StateEndpoint = live.protocol.TGFDWebClient.GetServiceIPEndPoint(live.common.XOService.PresNotification);
                        }
                    }
                }
                return _StateEndpoint;
            }
        }
        

		private bool       EnableStateBatching = false;
		private Timer      StateUpdateTimer;

        class StateUpdateItem
        {
            public ulong   XboxId;
            public ulong   UserId;
			public uint    State;
			public ulong   MatchSessionId;
			public byte[]  TitleData;
			public ushort  TitleDataCount;


            public StateUpdateItem(
					ulong   xboxId, 
					ulong   userId, 
					uint    state, 
					ulong   matchSessionId, 
					byte[]  titleData, 
					ushort  titleDataCount)
            {
				TitleData      = new byte[ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.MAX_TITLE_DATA_BYTES];
                XboxId         = xboxId;
                UserId         = userId;
				State          = state;
				MatchSessionId = matchSessionId;
				
				uint length = (uint)titleData.Length;
                if (length > ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.MAX_TITLE_DATA_BYTES)
				{
                    Instance.Log.WriteEntry("StateUpdateItem: title data truncated to " + ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.MAX_TITLE_DATA_BYTES, EventLogEntryType.Error);

                    length = ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.MAX_TITLE_DATA_BYTES;
				}

				// For testing purposes we allow the actual data passed in to exceed count. The packet
				// sent to presence uses a fixed length buffer of MAX_TITLE_DATA_BYTES + PacketMetaData
				Array.Copy(titleData, TitleData, length);
				TitleDataCount = titleDataCount;
            }
        }

        class AsyncHttpRequest
        {
			public String       Resource; 
            public IPEndPoint   Endpoint;
            public MemoryStream Request; // Hdr + Payload
            public MemoryStream Payload;
            public Socket       Socket;
            public int          TotalSent;
            public int          TotalRecv;
            public byte         []RecvBuffer;
            public MemoryStream Response;
            public EventLog     Log; 

            public AsyncHttpRequest()
            {
            }

            public void OnConnect(IAsyncResult result)
            {
                if(!Socket.Connected)
                {
                    Log.WriteEntry("AsyncHttpRequest: Could not connect to: " + Endpoint.ToString(), EventLogEntryType.Error);
                    return;
                }

                StringBuilder hdr = new StringBuilder(128);
                hdr.Append("POST ");
				hdr.Append(Resource);
				hdr.Append(" HTTP/1.0\r\n");

                hdr.Append("Host: ");
                hdr.Append(Endpoint.ToString());
                hdr.Append("\r\n");

                hdr.Append("Content-Length: ");
                hdr.Append(Payload.Length.ToString());
                hdr.Append("\r\n");

                hdr.Append("Connection: close\r\n");
                hdr.Append("Content-Type: xon/1\r\n");
                hdr.Append("User-Agent: 1/0.10.4715\r\n");
                hdr.Append("\r\n");

                byte[] hdrBytes = new ASCIIEncoding().GetBytes(hdr.ToString());

                Request = new MemoryStream();
                Request.Write(hdrBytes, 0, hdrBytes.Length);
                Payload.WriteTo(Request);

                TotalSent = 0;
                Socket.BeginSend(Request.ToArray(), 0, (int)Request.Length, SocketFlags.None, new AsyncCallback(OnSend), this);
            }

            public void OnSend(IAsyncResult result)
            {
                int nbytes = Socket.EndSend(result);
                if(nbytes < 0)
                {
                    Log.WriteEntry("Send Failed to: " + Endpoint.ToString() + ", Total sent: " + TotalSent, EventLogEntryType.Error);
                    return;
                } 

                TotalSent += nbytes;

                if(TotalSent < Request.Length)
                {
                    // Continue sending
                    Socket.BeginSend(Request.ToArray(), (int)TotalSent, (int)(Request.Length - TotalSent), SocketFlags.None,  new AsyncCallback(OnSend), this);
                }
                else
                {
                    // All data sent, recv response
                    Response = new MemoryStream();
                    RecvBuffer = new byte[512];
                    TotalRecv = 0;
                    Socket.BeginReceive(RecvBuffer, 0, (int)RecvBuffer.Length, SocketFlags.None, new AsyncCallback(OnRecv), this);
                }
            } 

            public void OnRecv(IAsyncResult result)
            {
                int nbytes = Socket.EndReceive(result);
                if(nbytes == 0)
                {
                    //Log.WriteEntry("Recv remote end closed connection: " + Endpoint.ToString() + "Response:\n" + 
                     //   new ASCIIEncoding().GetString(Response.ToArray()));

					// Close the socket and dicard any time_wait or close_wait data
					LingerOption linger = new LingerOption(false, 0);
					Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, linger);
					Socket.Close();
                }
                else if(nbytes < 0)
                {
                    Log.WriteEntry("Recv failed from " + Endpoint.ToString() + ", Total Bytes: " +  TotalRecv, EventLogEntryType.Error);
                }
                else
                {
                    TotalRecv += nbytes;
                    Response.Write(RecvBuffer, 0, nbytes);
                    Socket.BeginReceive(RecvBuffer, 0, (int)RecvBuffer.Length, SocketFlags.None, new AsyncCallback(OnRecv), this);
                }
            }
        }
        //////////////(uint)/////////////////////////////////////
        /// <summary>
        /// Message Handler Status
        /// </summary>
        public IGState State
        {
            get{ return state; }
        }
        public enum IGState
        {
            NotRunning,
            Starting,
            PortListening,
            ShuttingDown,
            ShutDown,
        }
        private IGState state = IGState.NotRunning;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Version shared by client and service to ensure compatability
        /// IMPORTANT: Increment this when making changes to client / service interaction
        /// </summary>
        /// <returns>IG version number</returns>
        public static int GetCompiledVersion()
        {
            return CurrentVersion;
        }
        protected const int CurrentVersion = 45;
        public static IGService Instance = null;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Wrap creation to manage singleton 
        /// </summary>
        public static void Create()
        {
            if( Instance != null )
            {
                Instance.Log.WriteEntry( "Attempted Start Abotred.\nService should already be started.", EventLogEntryType.Warning );
            }
            else
            {
                Instance = new IGService();
                Instance.Start();
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Wrap destruction to manage singleton 
        /// </summary>
        public static void Destroy()
        {
            if( Instance == null )
            {
                EventLog log = new EventLog();
                log.Source = "IG";
                log.WriteEntry( "Attempted Stop Abotred.\nService should already be stopped.", EventLogEntryType.Warning );
            }
            else
            {
                Instance.End();
                Instance = null;
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        private IGService()
        {
            // Setup for event logging
            Log = new EventLog();
            Log.Source = "IG";
            Log.WriteEntry( "Beginning Service Initialization..." );

            // Get local interface list
            IpList = IGSocket.FindIPAddresses();
            StringBuilder sb = new StringBuilder( "Local Interfaces detected.  Service will be monitoring:\n" );
            sb.AppendFormat( "Port:  {0:G} (0x{0:X})\nIP Addresses:\n", Port );
            foreach( IPAddress ip in IpList )
            {
                sb.AppendFormat( "   {0}\n", ip );
                byte[] ipBytes = ip.GetAddressBytes();
                if (ipBytes.Length == 4)
                {
                    uint IP =
                        ((uint)ipBytes[3] << 24) |
                        ((uint)ipBytes[2] << 16) |
                        ((uint)ipBytes[1] << 8) |
                        ((uint)ipBytes[0] << 0);

                    uint hoOld = (uint)IPAddress.NetworkToHostOrder((int)_LocalIP);
                    uint hoNew = (uint)IPAddress.NetworkToHostOrder((int)IP);

                    if (hoNew < hoOld || _LocalIP == 0)
                    {
                        _LocalIP = IP;
                    }
                }
            }
            Log.WriteEntry( sb.ToString() );
            
            // Create new MMF and store the version the service was built with
            ConnectionMgr.SetUpMMF( IpList, CurrentVersion );

            IGNetwork.Initialize(IpList);
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Begin message processing
        /// </summary>
        private void Start()
        {
            if( SGThread != null )
            {
                Log.WriteEntry( "Aborting. Message Handler Already started", EventLogEntryType.Error );
                return;
            }

            Log.WriteEntry( "Starting Message Handler" );
            terminate = false;
            state     = IGState.NotRunning;

            // Start the thread
            SGThread = new Thread( new ThreadStart( FastHandler ) );
            SGThread.Priority = ThreadPriority.Highest;
            SGThread.Start();
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// End message processing 
        /// </summary>
        private void End()
        {
            Log.WriteEntry( "Beginning Service Shutdown..." );
            
            if( SGThread == null )
            {
                Log.WriteEntry( "Aborting. Message Handler Already stopped", EventLogEntryType.Error );
                return;
            }

            Log.WriteEntry( "Stopping Message Handler" );
            state     = IGState.ShuttingDown;
            terminate = true;
                    
            // Wait for Thread to get the message and quit
            int SleepCount = 10;
            while( --SleepCount >= 0 )
            {
                if( SGThread.IsAlive )
                {
                    Thread.Sleep( 200 );
                }
                else
                {
                    break;
                }
            }
            if( SleepCount == -1 )
            {
                Log.WriteEntry( "Message Handler didn't stop when signalled.", EventLogEntryType.Warning );
            }

            SGThread.Abort();
            SGThread = null;

            // Clear out QVal proccesing table
            SGXboxInfoSlots.Clear();
                
            state = IGState.ShutDown;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Message handler thread
        /// </summary>
        void FastHandler()
        {
            Log.WriteEntry( "FastHandler: Starting" );
            try
            {
                state = IGState.Starting;

                IGSocket.Initialize( IpList, Port );

                state = IGState.PortListening;
                IPEndPoint RemoteIpEndPoint = new IPEndPoint( IPAddress.Any, 0 );
                EndPoint remote = RemoteIpEndPoint;

				uint[] qvals = new uint[15];
                byte[] receiveBytes = new byte[ 1000 ];
                while( !terminate )
                {
                    try
                    {
                        ArrayList sockList = IGSocket.CheckReceive( 500000 );

                        if( sockList.Count < 1 )
                            continue;
                        
                        foreach( Socket sock in sockList )
                        {
                            byte[] outArray = new byte[ 1492 ];
        
                            try
                            {
                                IGSocket.Receive( sock, receiveBytes, ref remote );
                            }
                            catch( Exception )
                            {
                                continue;
                            }

                            RemoteIpEndPoint = remote as IPEndPoint;
    
                            IPAddress localIp = ((IPEndPoint)sock.LocalEndPoint).Address;

                            fixed( Byte* b = receiveBytes )
                            {
                                SSgMsgHdr* regHdr = (SSgMsgHdr*) b;
#if THISISOBSOLETE
                                if( regHdr->_wType == (ushort) SGMSG.AUTHDATA_REQ )
                                {
                                    StringBuilder sb = new StringBuilder( "Obsolete AUTHDATA_REQ recieved on local Socket:" );
                                    sb.AppendFormat( " {0}\n", localIp );
                                    Log.WriteEntry( sb.ToString() );
                                }
                                else if( regHdr->_wType == (ushort) SGMSG.SPIDATA_REQ )
                                {
                                    StringBuilder sb = new StringBuilder( "Obsolete SPIDATA_REQ recieved on local Socket:" );
                                    sb.AppendFormat( " {0}\n", localIp );
                                    Log.WriteEntry( sb.ToString() );
                                } 
                                else if( regHdr->_wType == (ushort) SGMSG.SPIDATA_REQ2 )
                                {
                                #region Process Spi Data2 Request
                                    
                                    SgMsgSpiReq* req = (SgMsgSpiReq*) b;
                                    
                                    ushort RealPort = (ushort) ((req->_ipportZ>>8) | (req->_ipportZ<<8));
                                    CSGInfo SGInfo = FindSlotByPort( RealPort, localIp );

                                    fixed( byte* outBytes = outArray )
                                    {
                                        SgMsgSpiRep*    SpiRep   = (SgMsgSpiRep*)    outBytes;
                                        SSgMsgSpiData2* SpiData2 = (SSgMsgSpiData2*) (outBytes+sizeof(SgMsgSpiRep));
                                        SAuthData2*     AuthData = (SAuthData2*)     (outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2));
                                        
                                        // Fill Spi Rep data
                                        SpiRep->Header._wType = (ushort)SGMSG.SPIDATA_REP2;
                                        SpiRep->Header._cbEnt = (ushort) sizeof(SgMsgSpiRep);                   // must be real size
                                        SpiRep->_dwReqNum     = req->_dwReqNum;
                                        SpiRep->_ipaZ         = req->_ipaZ;
                                        SpiRep->_ipportZ      = req->_ipportZ;
                                        SpiRep->_fNotFound    = SGInfo.UserNotFound;

                                        // fill AuthDAta2
                                        AuthData->Header._wType    = (ushort)SGMSG.AUTHDATA2;
                                        AuthData->Header._cbEnt    = 184;
                                        AuthData->wAuthDataVersion = 2;
                                        AuthData->wAuthDataSize    = 180;
                                        AuthData->clientVersion    = SGInfo.clientVersion;
                                        AuthData->dwTitleID        = SGInfo.titleId;
                                        AuthData->dwTitleVersion   = SGInfo.titleVersion;
                                        AuthData->dwTitleRegion    = SGInfo.titleRegion;
                                        AuthData->qwXboxID         = SGInfo.machinePuid;

                                        AuthData->user0.flags=SGInfo.userFlag0;
                                        AuthData->user1.flags=SGInfo.userFlag1;
                                        AuthData->user2.flags=SGInfo.userFlag2;
                                        AuthData->user3.flags=SGInfo.userFlag3;

                                        AuthData->user0.puid = SGInfo.userPuid0;
                                        AuthData->user1.puid = SGInfo.userPuid1;
                                        AuthData->user2.puid = SGInfo.userPuid2;
                                        AuthData->user3.puid = SGInfo.userPuid3;
                                        AuthData->dwNumServices= 12;
                                        uint *Services = (uint*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2));
                                        Services[0] = (uint) SGInfo.service0;
                                        Services[1] = (uint) SGInfo.service1;
                                        Services[2] = (uint) SGInfo.service2;
                                        Services[3] = (uint) SGInfo.service3;
                                        Services[4] = (uint) SGInfo.service4;
                                        Services[5] = (uint) SGInfo.service5;
                                        Services[6] = (uint) SGInfo.service6;
                                        Services[7] = (uint) SGInfo.service7;
                                        Services[8] = (uint) SGInfo.service8;
                                        Services[9] = (uint) SGInfo.service9;
                                        Services[10] = (uint) SGInfo.service10;
                                        Services[11] = (uint) SGInfo.service11;
                                                                            
                                        // Trust factores  are set to Zero ;
                                        float *afltTrustFactor = (float*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2)+(12*sizeof(uint)));
                                        afltTrustFactor[0] = SGInfo.userTrust0;
                                        afltTrustFactor[1] = SGInfo.userTrust1;
                                        afltTrustFactor[2] = SGInfo.userTrust2;
                                        afltTrustFactor[3] = SGInfo.userTrust3;

                                        uint *altTitleID = (uint*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2)+(12*sizeof(uint))+(4*sizeof(float)));
                                        altTitleID[0] = SGInfo.altTitleId0;
                                        altTitleID[1] = SGInfo.altTitleId1;
                                        altTitleID[2] = SGInfo.altTitleId2;
                                        altTitleID[3] = SGInfo.altTitleId3;

                                        byte *key = (byte*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2)+(12*sizeof(uint))+(4*sizeof(float))+(4*sizeof(uint)));
                                        key[0] = SGInfo.key00;
                                        key[1] = SGInfo.key01;
                                        key[2] = SGInfo.key02;
                                        key[3] = SGInfo.key03;
                                        key[4] = SGInfo.key04;
                                        key[5] = SGInfo.key05;
                                        key[6] = SGInfo.key06;
                                        key[7] = SGInfo.key07;
                                        key[8] = SGInfo.key08;
                                        key[9] = SGInfo.key09;
                                        key[10] = SGInfo.key10;
                                        key[11] = SGInfo.key11;
                                        key[12] = SGInfo.key12;
                                        key[13] = SGInfo.key13;
                                        key[14] = SGInfo.key14;
                                        key[15] = SGInfo.key15;

                                        // The commented out SpiData lines below are AuthData elements that so far are not 
                                        // nescessary.  If they become nescessary we will fill them in.
                                        SpiData2->Header._wType=(ushort)SGMSG.SPIDATA2;
                                        SpiData2->Header._cbEnt=(ushort) sizeof(SSgMsgSpiData2);
                                        SpiData2->_fCs             = (byte)1;
                                        
                                        byte[] thisIp = ((IPEndPoint)sock.LocalEndPoint).Address.GetAddressBytes();
                                        uint listenIP = 
                                            ((uint) thisIp[3]<<24) |
                                            ((uint) thisIp[2]<<16) |
                                            ((uint) thisIp[1]<< 8) |
                                            ((uint) thisIp[0]<< 0);
                                        SpiData2->_ipaI            = listenIP;
                                        SpiData2->_ipportI         = Port;

                                        //SpiData2->_liNonce       =
                                        DateTime today             = DateTime.Now;
                                        SpiData2->_liTimeInit      = today.ToFileTime();
                                        //SpiData2->_wFlagsKeyEx   =
                                        //SpiData2->_wVersionKeyEx =
                                        SpiData2->sgaddr.abReserved = 0;
                                        SpiData2->sgaddr.dwSpiSg    = SGInfo.SpiSg;
                                        SpiData2->sgaddr.inaSg      = SGInfo.inaSg;
                                        SpiData2->sgaddr.qwXboxID   = SGInfo.machinePuid;
                                    }
                                    IGSocket.Send( sock, outArray, 262, RemoteIpEndPoint );
                                #endregion
                                }
#endif
                                if( regHdr->_wType == (ushort) SGMSG.SPIDATA_REQ )
                                {
                                    #region Process SpiData Request
                                    // The reply is actually of the form:
                                    // {
                                    //   CSgMsgSpiRep
                                    //   CSgMsgSpiData2
                                    //   CSgMsgHdr+CAuthData[2,3]
                                    // }
                                    SgMsgSpiReq* req = (SgMsgSpiReq*) b;
                                    
                                    ushort RealPort = (ushort) ((req->_ipportZ>>8) | (req->_ipportZ<<8));
                                    CSGInfo SGInfo = ConnectionMgr.FindSlotByPort( RealPort, localIp );

                                    int packetSize = 0;
                                    fixed( byte* outBytes = outArray )
                                    {
                                        SgMsgSpiRep*    SpiRep   = (SgMsgSpiRep*)       outBytes;
                                        SSgMsgSpiData2* SpiData2 = (SSgMsgSpiData2*)    (outBytes+sizeof(SgMsgSpiRep));
                                        SAuthData3*     AuthData = (SAuthData3*)        (outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2));
                                                                                
                                        // Fill Spi Rep data
                                        //
                                        SpiRep->Header._wType = (ushort)SGMSG.SPIDATA_REP;
                                        SpiRep->Header._cbEnt = (ushort) sizeof(SgMsgSpiRep);                   // must be real size
                                        SpiRep->_dwReqNum     = req->_dwReqNum;
                                        SpiRep->_ipaZ         = req->_ipaZ;
                                        SpiRep->_ipportZ      = req->_ipportZ;
                                        SpiRep->_fNotFound    = (byte)(SGInfo.UserExists == 0 ? 1 : 0);

                                        // If user doesn't exist, we only send the SgMsgSpiRep back.  I think.
                                        packetSize = sizeof(SgMsgSpiRep);

                                        if (SGInfo.UserExists > 0)
                                        {
                                            // Fill SpiData2 data
                                            //
                                            // The commented out SpiData lines below are AuthData elements that so far are not 
                                            // nescessary.  If they become nescessary we will fill them in.
                                            SpiData2->Header._wType=(ushort)SGMSG.SPIDATA;
                                            SpiData2->Header._cbEnt=(ushort) sizeof(SSgMsgSpiData2);
                                            SpiData2->_fCs             = (byte)1;

                                            if(0 == SGInfo.ipaI)
                                            {
                                                byte[] thisIp = ((IPEndPoint)sock.LocalEndPoint).Address.GetAddressBytes();
                                                uint listenIP = 
                                                    ((uint) thisIp[3]<<24) |
                                                    ((uint) thisIp[2]<<16) |
                                                    ((uint) thisIp[1]<< 8) |
                                                    ((uint) thisIp[0]<< 0);
                                                SpiData2->_ipaI             = listenIP;
                                                SpiData2->_ipportI          = Port;
                                            }
                                            else
                                            {
                                                SpiData2->_ipaI             = SGInfo.ipaI;
                                                SpiData2->_ipportI          = SGInfo.ipportI;
                                            }

                                            SpiData2->_liNonce          = SGInfo.liNonce;
                                            DateTime today              = DateTime.Now;
                                            SpiData2->_liTimeInit       = today.ToFileTime();
                                            //SpiData2->_wFlagsKeyEx    =
                                            //SpiData2->_wVersionKeyEx  =
                                            SpiData2->sgaddr.abReserved = 0;
                                            SpiData2->sgaddr.dwSpiSg    = SGInfo.SpiSg;
                                            SpiData2->sgaddr.inaSg      = SGInfo.inaSg;
                                            SpiData2->sgaddr.qwXboxID   = SGInfo.machinePuid;

                                            // Fill AuthDataHdr data
                                            //
                                            AuthData->Header._wType             = (ushort)SGMSG.AUTHDATA;
                                            AuthData->Header._cbEnt             = (ushort)sizeof(SAuthData3);  // was 184

                                            // Fill AuthData3 data
                                            //
                                            AuthData->wAuthDataVersion = (ushort)3;  // XONLINE_XENON_AUTHDATA_VERSION
                                            AuthData->wAuthDataSize    = (ushort)(sizeof(SAuthData3)-sizeof(SSgMsgHdr));  // was 180
                                            AuthData->clientVersion.wMajorVersion = SGInfo.wMajorVersion;
                                            AuthData->clientVersion.wMinorVersion = SGInfo.wMinorVersion;
                                            AuthData->clientVersion.wBuildNumber = SGInfo.wBuildNumber;
                                            AuthData->clientVersion.wQFENumber = SGInfo.wQFENumber;
                                            AuthData->dwTitleID         = SGInfo.titleId;
                                            AuthData->dwTitleVersion    = SGInfo.titleVersion;
                                            AuthData->dwTitleRegion     = SGInfo.titleRegion;
                                            AuthData->dwConsoleRegion   = SGInfo.consoleRegion;
                                            AuthData->dwMediaID         = SGInfo.mediaID;
                                            AuthData->wLanguageID       = SGInfo.languageID;
                                            AuthData->dwAuthDataFlags   = SGInfo.authDataFlags;

                                            AuthData->wNumPrivileges = SGInfo.wNumPrivileges;
                                            AuthData->dwPrivileges0 = SGInfo.dwPrivileges0;
                                            AuthData->dwPrivileges1 = SGInfo.dwPrivileges1;
                                            AuthData->dwPrivileges2 = SGInfo.dwPrivileges2;
                                            AuthData->dwPrivileges3 = SGInfo.dwPrivileges3;
                                            AuthData->dwPrivileges4 = SGInfo.dwPrivileges4;
                                            AuthData->dwPrivileges5 = SGInfo.dwPrivileges5;
                                            AuthData->dwPrivileges6 = SGInfo.dwPrivileges6;
                                            AuthData->dwPrivileges7 = SGInfo.dwPrivileges7;
                                            
                                            AuthData->qwXboxID          = SGInfo.machinePuid;
                                            AuthData->user0.flags= SGInfo.userFlag0;
                                            AuthData->user1.flags= SGInfo.userFlag1;
                                            AuthData->user2.flags= SGInfo.userFlag2;
                                            AuthData->user3.flags= SGInfo.userFlag3;
                                            AuthData->user0.puid = SGInfo.userPuid0;
                                            AuthData->user1.puid = SGInfo.userPuid1;
                                            AuthData->user2.puid = SGInfo.userPuid2;
                                            AuthData->user3.puid = SGInfo.userPuid3;
                                            
                                            AuthData->afltTrustFactor0 = SGInfo.userTrust0;
                                            AuthData->afltTrustFactor1 = SGInfo.userTrust1;
                                            AuthData->afltTrustFactor2 = SGInfo.userTrust2;
                                            AuthData->afltTrustFactor3 = SGInfo.userTrust3;

                                            AuthData->wNumDwordServices = SGInfo.wNumDwordServices;
                                            AuthData->dwServiceID0 = SGInfo.dwServiceID0;
                                            AuthData->dwServiceID1 = SGInfo.dwServiceID1;
                                            AuthData->dwServiceID2 = SGInfo.dwServiceID2;
                                            AuthData->dwServiceID3 = SGInfo.dwServiceID3;

                                            AuthData->dwAltTitleID0 = SGInfo.altTitleId0;
                                            AuthData->dwAltTitleID1 = SGInfo.altTitleId1;
                                            AuthData->dwAltTitleID2 = SGInfo.altTitleId2;
                                            AuthData->dwAltTitleID3 = SGInfo.altTitleId3;

                                            AuthData->abKey00 = SGInfo.key00;
                                            AuthData->abKey01 = SGInfo.key01;
                                            AuthData->abKey02 = SGInfo.key02;
                                            AuthData->abKey03 = SGInfo.key03;
                                            AuthData->abKey04 = SGInfo.key04;
                                            AuthData->abKey05 = SGInfo.key05;
                                            AuthData->abKey06 = SGInfo.key06;
                                            AuthData->abKey07 = SGInfo.key07;
                                            AuthData->abKey08 = SGInfo.key08;
                                            AuthData->abKey09 = SGInfo.key09;
                                            AuthData->abKey10 = SGInfo.key10;
                                            AuthData->abKey11 = SGInfo.key11;
                                            AuthData->abKey12 = SGInfo.key12;
                                            AuthData->abKey13 = SGInfo.key13;
                                            AuthData->abKey14 = SGInfo.key14;
                                            AuthData->abKey15 = SGInfo.key15;

                                            packetSize = sizeof(SgMsgSpiRep) + sizeof(SSgMsgSpiData2) + sizeof(SAuthData3);
                                        }

                                    }
                                    IGSocket.Send( sock, outArray, packetSize, RemoteIpEndPoint );
                                    #endregion
                                }
                                else if( (regHdr->_wType==(ushort)SGMSG.SET_QVALS_LAZY) || 
                                    (regHdr->_wType==(ushort)SGMSG.SET_QVALS_PUSH) )
                                {
                                    #region Process QVal Request

									bool bIsPushRequest = regHdr->_wType == (ushort)SGMSG.SET_QVALS_PUSH;

                                    SSgMsgSetQValsReq* pRequest = (SSgMsgSetQValsReq*) b;
        
                                    fixed( byte* outBytes = outArray )
                                    {
                                        SSgMsgSetQValsRep* pReply = (SSgMsgSetQValsRep*) outBytes;
                                        pReply->Hdr._wType = (ushort)SGMSG.SET_QVALS_REP;
                                        pReply->Hdr._cbEnt = (ushort)sizeof( SSgMsgSetQValsRep );

                                        pReply->sgaddr  = pRequest->sgaddr;
                                        pReply->UserId  = pRequest->UserId;
                                        pReply->Context = pRequest->Context;

                                        SGXboxInfo xboxInfo = (SGXboxInfo) SGXboxInfoSlots[ pRequest->sgaddr.qwXboxID ];
                                        if( xboxInfo == null )
                                        {
                                            pReply->NotFound = 1;
                                            pReply->NoSuchUser = 1;
                                        }
                                        else
                                        {
                                            pReply->NotFound = 0;
                                            SGUserInfo userInfo = (SGUserInfo) xboxInfo.users[ pRequest->UserId ];
                                            if( userInfo == null )
                                            {
                                                pReply->NoSuchUser = 1;
                                            }
                                            else
                                            {
                                                pReply->NoSuchUser = 0;

												// TODO-jacobr: this is not too desirable but 
												// it will do 
												qvals[0]  = pRequest->QVals.QFlagQVal; 
												qvals[1]  = pRequest->QVals.QFlags;
												qvals[2]  = pRequest->QVals.InviteQVal; 
												qvals[3]  = pRequest->QVals.NewMsgIdsQVal; 
												qvals[4]  = pRequest->QVals.NewMsgId_1;
												qvals[5]  = pRequest->QVals.NewMsgId_2;
												qvals[6]  = pRequest->QVals.NewMsgId_3;

												qvals[7]  = pRequest->QVals.NewMsgDataQVal;
												qvals[8]  = pRequest->QVals.NewMsgData_1;
												qvals[9]  = pRequest->QVals.NewMsgData_2;
												qvals[10] = pRequest->QVals.NewMsgData_3;

												qvals[11] = pRequest->QVals.DelMsgQVal; 
												qvals[12] = pRequest->QVals.DelMsg_1;
												qvals[13] = pRequest->QVals.DelMsg_2;
												qvals[14] = pRequest->QVals.DelMsg_3;
												if(!userInfo.EnqueueQVals(bIsPushRequest, qvals))
												{
                        							Log.WriteEntry("QVal packet queue exceeded for user: " + userInfo.UserId.ToString("x"), EventLogEntryType.Error);
												}

											}
										}
                                    }
                                    IGSocket.Send( sock, outArray, sizeof(SSgMsgSetQValsRep), RemoteIpEndPoint );
                                    #endregion                                                                              
                                }
                            }
                        }
                    }       
                    catch( SocketException ex)
                    {
                        Log.WriteEntry( "IG socket exception.\nNativeErrorCode: 0x"+ex.NativeErrorCode.ToString("X") + "\nMessage: " + ex.Message + "\nStackTrace: " + ex.StackTrace, EventLogEntryType.Error);
                    }
                    catch( Exception ex)
                    {
                        Log.WriteEntry("NONFATAL ERROR: IG should never throw an exception:\n" + ex.ToString(), EventLogEntryType.Error);
                    }
                }
            }
            finally
            {
                IGSocket.Terminate();
                Log.WriteEntry( "FastHandler: Finished" );
            }
        }

		private void StateUpdateTimerCallback(object state)
		{
			SendUpdateState(true);
		}

		// Called by either the timer drive batch state update 
		// or 
        private void SendUpdateState(bool batching)
        {
			// Provide a lock at the top level of this function to protect config
			// change race conditions and update queue modifications. This function
			// may be called from a system thread driven from the timer
			lock(StateUpdateQueue)
			{

				// This method was called from the wrong place, this isn't a bad thing but
				// indicates either:
				//
				//	- Stale timer which is should expire
				//	- Call from SetUserState() which can be ignored as the timer will kick off
				//		the appropriate call.
				if(EnableStateBatching != batching)
				{
					goto lbDone;
				}

				try
				{
					MemoryStream stream = new MemoryStream();
					CSgMsgNotifyCliUpdate msg = new CSgMsgNotifyCliUpdate();

					// Batch all of the updates into a single stream
					foreach(StateUpdateItem updateItem in StateUpdateQueue)
					{
						// Get the xbox slot information
						SGXboxInfo xbox = SGXboxInfoSlots[updateItem.XboxId] as SGXboxInfo;
						if(xbox == null) 
						{
							Log.WriteEntry("Attempted to write state update for xbox ID: " + 
									updateItem.XboxId.ToString("x") + 
									" which was not found in the slot hash", EventLogEntryType.Error);
							continue;
						}

						// Build the msg
						msg.wType       = (ushort)SGMSG.NOTIFY_CLI_UPD;
						msg.cbEnt       = 310;
						msg.inaSg       = xbox.SgIp;
						msg.dwSpiSg     = xbox.Spi;
						msg.qwXboxID    = xbox.XboxId;
						msg.abReserved  = 0;
						msg.qwUserId    = updateItem.UserId;
						msg.qwMatchSessionId = updateItem.MatchSessionId;
                        msg.dwAuthFlags = xbox.AuthDataFlags;
						msg.dwState 	= updateItem.State;
						msg.dwTitleId 	= xbox.TitleId;
						msg.cbTitleData = updateItem.TitleDataCount;

						// This will never be more than MAX_TITLE_DATA_BYTES
						Array.Copy(updateItem.TitleData, msg.rgbTitleData, updateItem.TitleData.Length);

						// Serialize the header and data 
						msg.WriteStream(stream);

					} // end build up batch state

					// All done with the items in the queue
					StateUpdateQueue.Clear();

					// Send the update to the presence FD state XRL
					AsyncHttpRequest request = new AsyncHttpRequest();
					request.Resource = "/xpnfront/state.ashx";
					request.Log = Log;
					request.Endpoint = StateEndpoint;
					request.Payload = stream;
					request.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
					request.Socket.Blocking = false;
					request.Socket.BeginConnect(request.Endpoint, new AsyncCallback(request.OnConnect), request);
				}
				catch(Exception ex)
				{
					Log.WriteEntry("Error in batch state update: " + ex.ToString(), EventLogEntryType.Error);
				}
			} // end lock(StateUpdateQueue)

lbDone:
			return;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get service version
        /// </summary>
        /// <returns>Version number compiled into service</returns>
        public int GetServiceVersion()
        {
            return GetCompiledVersion();
        }


        ///////////////////////////////////////////////////
        /// Client Interaction
        ///////////////////////////////////////////////////

        public SGADDR AddXbox(  ulong xboxId, 
								uint titleId, 
								uint titleVer, 
								uint titleRegion, 
								byte[] key, 
								ulong clientVersion,
                                CSGInfo.ClientType clientType, 
								uint languageId )
        {

			SGXboxInfo xbox = SGXboxInfoSlots[xboxId] as SGXboxInfo;
            uint SpiSg = masterSpi++;
			if(null == xbox)
			{
                xbox = new SGXboxInfo(_LocalIP, SpiSg, xboxId, languageId);
				SGXboxInfoSlots[xboxId] = xbox;
			}
			else
			{
				// Make sure we update spi
                xbox.SgIp = _LocalIP;
                xbox.Spi = SpiSg;
				xbox.LanguageId = (ushort)languageId;
			}

            xbox.TitleId = titleId;
            xbox.TitleVer = titleVer;
            xbox.TitleRegion = titleRegion;
            xbox.Key = key;
            xbox.ClientVersion = clientVersion;
            xbox.ClientType = clientType;
            
            SGADDR sgaddr = new SGADDR();
            sgaddr.abReserved = 0;
            sgaddr.SpiSg = SpiSg;
            sgaddr.XboxID = xboxId;
            sgaddr.inaSg = _LocalIP;

            return sgaddr;
        }

        public void RemoveXbox( ulong xboxId )
        {
            // TODO:  Release Slot
			SGXboxInfo xboxInfo = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null != xboxInfo)
            {
            	SGXboxInfoSlots.Remove(xboxId);
            }
        }

		public void DeadXbox( ulong xboxId )
		{
			SGXboxInfo xboxInfo = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null != xboxInfo)
            {
				SendNotifyDelete(xboxInfo);
				SGXboxInfoSlots.Remove(xboxId);
			}
		}

		public void ClearXboxes()
		{
			try 
			{
				foreach(SGXboxInfo xboxInfo in SGXboxInfoSlots.Values)
				{
					if(xboxInfo == null)
						continue;
					
                    // TODO:  Release Slot

					SendNotifyDelete(xboxInfo);
					
				}
			}
            catch(Exception ex)
            {
                Log.WriteEntry("Error in ClearXboxes() update: " + ex.ToString(), EventLogEntryType.Error);
            }

			// Clear all slots
			SGXboxInfoSlots.Clear();
		}

		public void SendNotifyDelete(SGXboxInfo xboxInfo)
		{
			MemoryStream stream = new MemoryStream();
			CSgMsgNotifyCliDelete msg = new CSgMsgNotifyCliDelete();

			// Build the msg
			msg.wType           = (ushort)SGMSG.NOTIFY_CLI_DEL;
			msg.cbEnt           = 28; 
			msg.inaSg           = xboxInfo.SgIp;
			msg.dwSpiSg         = xboxInfo.Spi;
			msg.qwXboxId        = xboxInfo.XboxId;
			msg.abReserved      = 0;
			msg.dwTitleId       = xboxInfo.TitleId;

			// Serialize the header and data 
			msg.WriteStream(stream);

			// Send the dead xbox info to the presence FD state XRL
			AsyncHttpRequest request = new AsyncHttpRequest();
			request.Resource = "/xpnfront/deadxbox.ashx";
			request.Log = Log;
			request.Endpoint = StateEndpoint;
			request.Payload = stream;
			request.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			request.Socket.Blocking = false;
			request.Socket.BeginConnect(request.Endpoint, new AsyncCallback(request.OnConnect), request);
		}

        public void SetTitle( ulong xboxId, uint titleId, uint titleVer, uint titleRegion )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox not found in IG" );
            }
            xbox.TitleId     = titleId;
            xbox.TitleVer    = titleVer;
            xbox.TitleRegion = titleRegion;
        }

        public void SetAltTitles( ulong xboxId, uint[] altTitleIds )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox not found in IG" );
            }
            
            xbox.ClearAltTitles();
            foreach( uint id in altTitleIds )
            {
                xbox.AddAltTitle( id );
            }
        }

        public void SetKey( ulong xboxId, byte[] key )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.Key = key;
        }

        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData, ushort titleDataLen)
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.SetUserState(userId, matchSessionId, state, titleData, titleDataLen);
            lock (StateUpdateQueue)
            {
                StateUpdateQueue.Add(new StateUpdateItem(xboxId, userId, state, matchSessionId, titleData, titleDataLen));
            }
			SendUpdateState(false);
        }

		public void SetEnableStateBatching(bool enable, uint intervalSeconds)
		{
			if(intervalSeconds > 3600)
			{
				Log.WriteEntry("SetEnableStateBatching: interval times of over an hour not supported");
				goto lbDone;
			}
			
			lock(StateUpdateQueue)
			{
				EnableStateBatching = enable;
			
				if(null != StateUpdateTimer)
				{
					StateUpdateTimer.Dispose();
				}

				if(EnableStateBatching)
				{
					// State updates will now be driven off of a timer which will drain
					// the StateUpdateQueue
					StateUpdateTimer = new Timer(
							new TimerCallback(this.StateUpdateTimerCallback),
							this,
							0,                // start right away
							(int)(intervalSeconds * 1000)); // repeat interval in millis
				}
			}

lbDone:
			return;
		}

        public void AddUser( ulong xboxId, ulong userId, uint userFlags, MessageHandler msgHandler )
        {
			// This will only add a new user if their UserId does not yet exist on this Xbox
			// else it will just update their flags
            SGXboxInfo xbox = LookupXbox(xboxId);
            if (xbox != null)
            {
                xbox.AddUser(userId, userFlags, msgHandler);
            }
        }

        public void RemoveUser( ulong xboxId, ulong userId )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.RemoveUser( userId );
        }

        private SGXboxInfo LookupXbox( ulong xboxId)
		{ 
			SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
			if( xbox == null)
			{
				throw new Exception( "Xbox: " + xboxId.ToString("x") + " not found in IG" );
			}

			return xbox;
		}

        public void PutSlot(CSGInfo sgInfo)
        {
            SGXboxInfo xbox = LookupXbox(sgInfo.machinePuid);
            xbox.SetSGInfo(sgInfo);
        }

        public CSGInfo LoadSlot(ulong xboxId)
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            CSGInfo sgInfo = new CSGInfo();
            sgInfo.Initialize();
            xbox.LoadSGInfo(ref sgInfo);
            return sgInfo;
        }

        public byte[] TransactFD(ulong xboxId,
            uint serviceId,
            string relativeUrl, 
            string method, 
            byte[] headers,
            byte[] requestData)
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[xboxId];
            CSGInfo slot = new CSGInfo();
            if (xbox != null)
            {
                slot.Initialize();
                xbox.LoadSGInfo(ref slot);
            }
            return TransactFD(serviceId, relativeUrl, method, headers, requestData, ref slot);
        }

        public byte[] TransactFD(
            uint serviceId,
            string relativeUrl, 
            string method, 
            byte[] headers,
            byte[] requestData,
            ref CSGInfo Slot)
        {
            live.protocol.TGFDWebClient fd = new live.protocol.TGFDWebClient();
            return fd.UploadData(serviceId,relativeUrl,method,headers,requestData,ref Slot);
        }

        #region SG Message Protocol constants and structures
        private enum SGMSG : ushort
        {
            AUTHDATA_REQ   = 0x4700, // CSgMsgAuthReq
            AUTHDATA_REP   = 0x4701, // CSgMsgAuthRep
            KICK_REQ       = 0x4705, // CSgMsgKickReq
            KICK_REP       = 0x4706, // CSgMsgKickRep
            CLIENT_ADD     = 0x4707, // CSgMsgClient
            CLIENT_DEL     = 0x4708, // CSgMsgClient
            CLIENT_UPD     = 0x4709, // CSgMsgClient
            XBTOXB_FORWARD = 0x470A, // CSgMsgXbToXbForward
            SET_QVALS_LAZY = 0x470B, // CSgMsgSetQValsReq
            SET_QVALS_PUSH = 0x470C, // CSgMsgSetQValsReq
            SET_QVALS_REP  = 0x470D, // CSgMsgSetQValsRep
            //SPIDATA_REQ    = 0x470E, // CSgMsgSpiReq
            //SPIDATA_REP    = 0x470F, // CSgMsgSpiRep
            //AUTHDATA       = 0x4780, // CAuthData in the payload
            //SPIDATA        = 0x4781, // CSgMsgSpiData in the payload
            SPIDATA_REQ    = 0x4710, // CSgMsgSpiReq
            SPIDATA_REP    = 0x4711, // CSgMsgSpiRep2
            NOTIFY_CLI_DEL = 0x4712,  // CSgMsgNotifyCliDelete
            NOTIFY_CLI_UPD = 0x4713,  // CSgMsgNotifyCliUpdate
            NOTIFY_CLI_TCHG= 0x4714,  // CSgMsgNotifyCliTitleChange
            SPIDATA        = 0x4782, // CSgMsgSpiData2 in the payload
            AUTHDATA       = 0x4783  // CAuthData3 in the payload
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgHdr 
        {
            public ushort _wType; // One of SGMSG enumeration
            public ushort _cbEnt; // Size of this entry (including header)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSGAddr
        {
            public uint  inaSg;      // IP address of the SG for the client
            public uint  dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong qwXboxID;   // Unique identifier of client machine account
            public uint  abReserved; // Reserved (must be zero)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgAuthReq
        {
            public SSgMsgHdr Header;
            public uint      _dwReqNum; // Request number from requester
            public uint      _ipaZ;     // IP address of the client on the DMZ
            public ushort    _ipportZ;  // IP port of the client on the DMZ
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiReq
        {
            public SSgMsgHdr Header;    
            public uint      _dwReqNum; // Request number from requester
            public uint      _ipaZ;     // IP address of the client on the DMZ
            public ushort    _ipportZ;  // IP port of the client on the DMZ
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiRep
        {
            public SSgMsgHdr Header;
            // Data ------------------------------------------------------------------------------
            public uint   _dwReqNum;  // Copy of _dwReqNum from request
            public uint   _ipaZ;      // IP address of the client on the DMZ
            public ushort _ipportZ;   // IP port of the client on the DMZ
            public byte   _fNotFound; // TRUE if client not found (no auth-data enclosed)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiData
        {
            public ushort  _ipportI;      // IP port of the client on the Internet
            public uint    _ipaI;         // IP address of the client on the Internet
            public SSGAddr sgaddr;
            public ushort _wVersionKeyEx; // KeyEx version of the client
            public ushort _wFlagsKeyEx;   // Flags sent in KeyEx initiator
            public long   _liNonce;       // A random nonce associated with this session
            public long   _liTimeInit;    // FILETIME marking session initiation
            public int    _fCs;           // TRUE if SG is providing connection service
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSpiData2 
        {
            public SSgMsgHdr Header;
            public ushort    _ipportI;       // IP port of the client on the Internet
            public uint      _ipaI;          // IP address of the client on the Internet
            public SSGAddr   sgaddr;
            public ushort    _wVersionKeyEx; // KeyEx version of the client
            public ushort    _wFlagsKeyEx;   // Flags sent in KeyEx initiator
            public long      _liNonce;       // A random nonce associated with this session
            public long      _liTimeInit;    // FILETIME marking session initiation
            public int       _fCs;           // TRUE if SG is providing connection services
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData1
        {
            public SSgMsgHdr      Header;
            public ushort         wAuthDataVersion; 
            public ushort         wAuthDataSize; 
            public ulong          clientVersion;
            public uint           dwTitleID;
            public uint           dwTitleVersion;
            public uint           dwTitleRegion;
            public ulong          qwXboxID;
            public SAuthData2User user0;
            public SAuthData2User user1;
            public SAuthData2User user2;
            public SAuthData2User user3;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData2
        {
            public SSgMsgHdr        Header;
            public ushort           wAuthDataVersion; 
            public ushort           wAuthDataSize; 
            public ulong            clientVersion;
            public uint             dwTitleID;
            public uint             dwTitleVersion;
            public uint             dwTitleRegion;
            public ulong            qwXboxID;
            public SAuthData2User   user0;
            public SAuthData2User   user1;
            public SAuthData2User   user2;
            public SAuthData2User   user3;
            public uint             dwNumServices;

            // Arrays are difficult to specify in C#, easier to do this in the fixed{} block above
            //public ushort         dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];  // 12
            //public float          afltTrustFactor[4];
            //public uint           dwAltTitleID[4];
            //public byte           abKey[16];
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData2User
        {
            // The high 16 bits of dwUserFlags should come from the UODB User Table.
            public ulong puid; 
            public uint  flags; 
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SXboxLibraryVersion
        {
            public ushort           wMajorVersion;
            public ushort           wMinorVersion;
            public ushort           wBuildNumber;
            public ushort           wQFENumber;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData3
        {
            public SSgMsgHdr        Header;
            public ushort           wAuthDataVersion; 
            public ushort           wAuthDataSize; 
            public SXboxLibraryVersion  clientVersion;
            public uint             dwTitleID;
            public uint             dwTitleVersion;
            public uint             dwTitleRegion;
            public uint             dwConsoleRegion;
            public uint             dwMediaID;
            public ushort           wLanguageID;
            public uint             dwAuthDataFlags;
            public ushort           wNumPrivileges;
            //public uint           dwPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];  // 8
            public uint             dwPrivileges0;
            public uint             dwPrivileges1;
            public uint             dwPrivileges2;
            public uint             dwPrivileges3;
            public uint             dwPrivileges4;
            public uint             dwPrivileges5;
            public uint             dwPrivileges6;
            public uint             dwPrivileges7;
            public ulong            qwXboxID;
            //public XUID           users[XONLINE_MAX_LOGON_USERS];  // 4
            public SAuthData2User   user0;
            public SAuthData2User   user1;
            public SAuthData2User   user2;
            public SAuthData2User   user3;
            //public float          afltTrustFactor[XONLINE_MAX_LOGON_USERS];  // 4
            public float            afltTrustFactor0;
            public float            afltTrustFactor1;
            public float            afltTrustFactor2;
            public float            afltTrustFactor3;
            public ushort           wNumDwordServices;
            //public uint           dwServiceID[XONLINE_MAX_DWORD_SERVICEIDS];  // 4
            public uint             dwServiceID0;
            public uint             dwServiceID1;
            public uint             dwServiceID2;
            public uint             dwServiceID3;
            //public uint           dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];  // 4
            public uint             dwAltTitleID0;
            public uint             dwAltTitleID1;
            public uint             dwAltTitleID2;
            public uint             dwAltTitleID3;
            //public byte           abKey[XONLINE_KEY_LENGTH];  // 16
            public byte             abKey00;
            public byte             abKey01;
            public byte             abKey02;
            public byte             abKey03;
            public byte             abKey04;
            public byte             abKey05;
            public byte             abKey06;
            public byte             abKey07;
            public byte             abKey08;
            public byte             abKey09;
            public byte             abKey10;
            public byte             abKey11;
            public byte             abKey12;
            public byte             abKey13;
            public byte             abKey14;
            public byte             abKey15;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgAuthRep
        {
            public SSgMsgHdr Header;
            public uint      _dwReqNum;  // Copy of _dwReqNum from request
            public uint      _ipaZ;      // IP address of the client on the DMZ
            public ushort    _ipportZ;   // IP port of the client on the DMZ
            public ushort    _ipportI;   // IP port of the client on the Internet
            public uint      _ipaI;      // IP address of the client on the Internet
            public SSGAddr   sgaddr;
            public byte      _fNotFound; // TRUE if client not found (no auth-data enclosed)
        };

        // QVals - Xonline.x over engineers the crap out of these.
        //         In practice they always look like this
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SQVals
        {
            public uint QFlagQVal; // Notification Queue Flags
            public uint QFlags;
            
            public uint InviteQVal; // Boolean (no extra data)

            public uint NewMsgIdsQVal; // The last 3 message IDs that arrived
            public uint NewMsgId_1;
            public uint NewMsgId_2;
            public uint NewMsgId_3;

            public uint NewMsgDataQVal; // Data for the last 3 messages that arrived
            public uint NewMsgData_1;
            public uint NewMsgData_2;
            public uint NewMsgData_3;

            public uint DelMsgQVal; // the last 3 messages deleted
            public uint DelMsg_1;
            public uint DelMsg_2;
            public uint DelMsg_3;
        };

        // QVal Request (From NotiInh)
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSetQValsReq
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;  // SGADDR of the client
            public ulong     UserId;  // User id of the user
            public uint      Context; // Sender's context to be returned in reply
            public SQVals    QVals;   // Turns out this blob at the end always looks the same
        };

        // QVal Reply
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSetQValsRep
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;     // SGADDR of the client
            public ulong     UserId;     // User id of the user
            public uint      Context;    // Sender's context from corresponding request
            public byte      NotFound;   // TRUE if client not found
            public byte      NoSuchUser; // TRUE if SG doesn't know about qwUserId
        };

        // Kick Request
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct CSgMsgKickReq
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr; // SGADDR of the client to kick
        };
        
        // Kick Reply
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct CSgMsgKickRep
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;    // SGADDR of the client that was kicked
            public byte      fNotFound; // TRUE if client not found
        };

        // State update
        private class CSgMsgNotifyCliUpdate  : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxID;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public ulong     qwUserId;
            public ulong     qwMatchSessionId;
            public uint      dwAuthFlags;  // <- New member
            public uint      dwState;
            public uint      dwTitleId;
            public ushort    cbTitleData;
            [WireInfo(ArraySize=256)]
            public byte      []rgbTitleData = new byte[256];
        }; 

	 	private class CSgMsgNotifyCliDelete : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxId;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public uint      dwTitleId;
        };
	
		/*TODO-jacobr: stubbed in here in anticipation of m4 integration
		private class CSgMsgNotifyCliTitleChange : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxID;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public uint      dwOldTitleId;
            public uint      dwNewTitleId;
        }
		*/
        #endregion 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\SGXBoxInfo.cs ===
using System;
using System.Collections;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.service;

namespace xonline.test.IGService
{
    public class SGXboxInfo
    {
        private CSGInfo _sgInfo;

        public uint  SgIp
        {
            get
            {
               return _sgInfo.inaSg;
            }
            set
            {
               _sgInfo.inaSg = value;
            }
        }

        public uint Spi
        {
            get
            {
               return _sgInfo.SpiSg;
            }
            set
            {
               _sgInfo.SpiSg = value;
            }
        }

        public ulong XboxId
        {
            get
            {
               return _sgInfo.machinePuid;
            }
            set
            {
               _sgInfo.machinePuid = value;
            }
        }

        public ulong ClientVersion
        {
            get
            {
               return _sgInfo.clientVersion;
            }
            set
            {
               _sgInfo.clientVersion = value;
            }
        }

        public uint AuthDataFlags
        {
            get
            {
                return _sgInfo.authDataFlags;
            }
        }

        public CSGInfo.ClientType ClientType
        {
            set
            {
               _sgInfo.SetClientType(value);
            }
        }

        public uint TitleId
        {
            get
            {
                return _sgInfo.titleId;
            }
            set
            {
                _sgInfo.titleId = value;
            }
        }
        public uint TitleVer
        {
            get
            {
                return _sgInfo.titleVersion;
            }
            set
            {
                _sgInfo.titleVersion = value;
            }
        }

        public uint TitleRegion
        {
            get
            {
                return _sgInfo.titleRegion;
            }
            set
            {
                _sgInfo.titleRegion = value;
            }
        }


        public ushort LanguageId
        {
            get
            {
                return _sgInfo.languageID;
            }
            set
            {
                _sgInfo.languageID = value;
            }
        }

        public byte[] Key
        {
            get
            {
                return _sgInfo.Key;
            }
            set
            {
                _sgInfo.SetKey(value);
            }
        }

        public SGXboxInfo( uint sgIp, uint spi, ulong xboxId, uint languageId )
        {
            _sgInfo = new CSGInfo();
            _sgInfo.Initialize();

            _sgInfo.inaSg = sgIp;
            _sgInfo.SpiSg = spi;
            _sgInfo.machinePuid = xboxId;
            _sgInfo.languageID = (ushort)languageId;
            _sgInfo.SetKey(DefaultKey);
        }

        public static byte[] DefaultKey = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        public static byte[] AnotherKey = {1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4};
        public byte   NumAltTitles = 0;
        public Hashtable users = new Hashtable( 4 );

        public void AddAltTitle( uint id )
        {
            if( NumAltTitles == 4 )
            {
                throw new Exception( "No more alt titles allowed in SGXboxInfo" );
            }
            switch (NumAltTitles)
            {
                case 0:
                    _sgInfo.altTitleId0 = id;
                    break;
                case 1:
                    _sgInfo.altTitleId1 = id;
                    break;
                case 2:
                    _sgInfo.altTitleId2 = id;
                    break;
                case 3:
                    _sgInfo.altTitleId3 = id;
                    break;
            }
        }

        public void ClearAltTitles()
        {
            _sgInfo.altTitleId0 = 0;
            _sgInfo.altTitleId1 = 0;
            _sgInfo.altTitleId2 = 0;
            _sgInfo.altTitleId3 = 0;
            NumAltTitles = 0;
        }

		public SGUserInfo GetUser(ulong userId)
		{
			return GetUser(userId, false);
		}

        public SGUserInfo GetUser(ulong userId, bool mustExist)
        {
            SGUserInfo userInfo = users[userId] as SGUserInfo;
			if(null == userInfo && mustExist)
			{
				throw new Exception("UserId: " + userId.ToString("x") + " was not found for XboxId: " + XboxId.ToString("x"));
			}

			return userInfo;
        }

        public void AddUser( ulong userId, uint userFlags, MessageHandler msgHandler )
        {
			SGUserInfo userInfo = users[userId] as SGUserInfo;
			if(null == userInfo)
			{
            	if( users.Count >= 4 ) 
            	{
                	throw new Exception( "Too many Users in SGXboxInfo" );
            	}
 				userInfo = new SGUserInfo(userId, userFlags, msgHandler);
            	users[ userId ] = userInfo;
			}
			else
			{
				userInfo.UserFlags = userFlags;
			}

            if (_sgInfo.userPuid0 == 0 || _sgInfo.userPuid0 == userId)
            {
                _sgInfo.userPuid0 = userId;
                _sgInfo.userFlag0 = userFlags;
            }
            else if (_sgInfo.userPuid1 == 0 || _sgInfo.userPuid1 == userId)
            {
                _sgInfo.userPuid1 = userId;
                _sgInfo.userFlag1 = userFlags;
            }
            else if (_sgInfo.userPuid2 == 0 || _sgInfo.userPuid2 == userId)
            {
                _sgInfo.userPuid2 = userId;
                _sgInfo.userFlag2 = userFlags;
            }
            else if (_sgInfo.userPuid3 == 0 || _sgInfo.userPuid3 == userId)
            {
                _sgInfo.userPuid3 = userId;
                _sgInfo.userFlag3 = userFlags;
            }

            _sgInfo.UserExists = 1;

        }

        // Title data can represent XBOX 1 title data or Xenon GI data, it is opaque to the SG
        // titleData is a static size array (xenon specifies 256 bytes)
        public void SetUserState(ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen)
        {
            SGUserInfo user = GetUser(userId, true);
            
            // update user state
            user.MatchSessionId   = matchSessionId;
            user.State            = state;
            user.TitleDataLen     = titleDataLen;
            user.TitleData        = titleData;
        }

        public void RemoveUser( ulong userId )
        {
            if(users.Contains(userId))
            {
            	users.Remove( userId );
            }

            if (_sgInfo.userPuid0 == userId)
            {
                _sgInfo.userPuid0 = 0;
                _sgInfo.userFlag0 = 0;
            }
            else if (_sgInfo.userPuid1 == userId)
            {
                _sgInfo.userPuid1 = 0;
                _sgInfo.userFlag1 = 0;
            }
            else if (_sgInfo.userPuid2 == userId)
            {
                _sgInfo.userPuid2 = 0;
                _sgInfo.userFlag2 = 0;
            }
            else if (_sgInfo.userPuid3 == userId)
            {
                _sgInfo.userPuid3 = 0;
                _sgInfo.userFlag3 = 0;
            }
        }

        public void ResetUser( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);
            
            user.QFlags       = 0; 
            user.QFlagSeqNum  = 0;
            user.Invites      = 0;
            user.InviteSeqNum = 0;
        }

        public void SetSGInfo(CSGInfo sgInfo)
        {
            _sgInfo = sgInfo;
        }

        public void LoadSGInfo( ref CSGInfo sgInfo )
        {
            sgInfo = _sgInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\XOnWebClient.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using xonline.common.config;
using xonline.common.service;
using ServerTestFramework.LiveService.FakeSG;
using xonline.test.IGService;

using XOService = live.common.XOService;

namespace live.protocol
{
    public class TGFDWebClient
    {
        private const int c_recvBufferSize = 4096;
        private const string c_headerSeperator = "\r\n";

        private static byte[] _emptyByteArray = new byte[0];
        private static byte[] _trash = new byte[128];
        private byte[] _recvBuffer = new byte[c_recvBufferSize];

        public int ReceiveTimeout = 35000;
        public int SendTimeout = 35000;

        public static System.Net.IPEndPoint GetServiceIPEndPoint(XOService service)
        {
            string viface;

            switch (service)
            {

                case XOService.PresNotification: viface = VirtualInterface.xpnfd_presence; break;
                case XOService.StringService: viface = VirtualInterface.stringsvr; break;
                case XOService.Auto_Update:       viface = VirtualInterface.xbos_autoupdate; break;
                case XOService.Base_Subscription:  viface = VirtualInterface.xbos_base_subscription; break;
                case XOService.User_Account: viface = VirtualInterface.xuacs; break;
                case XOService.Matchmaking: viface = VirtualInterface.xmatchfd; break;
                case XOService.Stats: viface = VirtualInterface.xstatsfd; break;
                case XOService.Feedback: viface = VirtualInterface.fbserver; break;
                case XOService.Billing_Offering: viface = VirtualInterface.xbos_billing_offering; break;
                case XOService.DRM: viface = VirtualInterface.xbos_drm; break;

                case XOService.LiveInfo: viface = VirtualInterface.LiveInfo; break;
                case XOService.Lists: viface = VirtualInterface.Lists; break;
                case XOService.Signature_Server: viface = VirtualInterface.xsig; break;
                case XOService.Query: viface = VirtualInterface.xqry; break;
                case XOService.Name_Resolution: viface = VirtualInterface.stfd_name_resolution; break;
                case XOService.Storage: viface = VirtualInterface.stfd_storage; break;
                case XOService.Arbitration: viface = VirtualInterface.xarb; break;
                case XOService.Cron: viface = VirtualInterface.cron_int; break;
                case XOService.MessagingService: viface = VirtualInterface.xpnfd_messaging; break;
                case XOService.Teams: viface = VirtualInterface.xpnfd_teams; break;
                case XOService.Catalog: viface = VirtualInterface.xbos_billing_offering; break;
                case XOService.Massive: viface = VirtualInterface.catalog; break;  // for now we will steal massive
                case (XOService)178 : viface = "xsuppapi"; break; //Really need a data driven method here


                default:
                    throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, 0, "Internal virtual interface for service " + service + " not found!   Add it to XRLUtil::GetServiceAddress.");
            }
            if (ServerTestFramework.Global.XEnv == null)
            {
                // Setup ServerTestFramework
                ServerTestFramework.Global.Initialize(AppDomain.CurrentDomain.BaseDirectory + "\\stf.xml");
            }
            System.Net.IPEndPoint ipEndPoint = ServerTestFramework.Global.XEnv.GetVirtualInterface(viface);
            if (ipEndPoint == null)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, 0, "Virtual interface for service " + viface.ToString() + " not found!  Check the config file.");
            }

            //if (service == XOService.Catalog)
            //{
            //    ipEndPoint.Port = 12020;
           // }

            return ipEndPoint;
        }

        //-----------------------------------------------------
        // GetServiceAddress
        //
        //      Returns an address from the service configuration
        //      that can be used to contact the given service id.
        //
        public static string GetServiceAddress(XOService service)
        {
            System.Net.IPEndPoint ipEndPoint = GetServiceIPEndPoint(service);
            return ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString();
        }

        public static void GetServiceInfo(XOService service, out string serviceAddress)
        {
            serviceAddress = GetServiceAddress(service);
        }

        private void SendWebRequest(TcpClient tcpClient, Uri destUri, string method, byte[] headers, byte[] requestData)
        {
            NetworkStream netstream = tcpClient.GetStream();

            string reqHeader = method + " " + destUri.PathAndQuery + " HTTP/1.1\r\n";
            reqHeader += "Host: " + destUri.Host + "\r\n";
            reqHeader += "Content-Length: " + requestData.Length + "\r\n";
            byte[] reqHeaderBytes = Encoding.ASCII.GetBytes(reqHeader);


            byte[] message = new byte[reqHeaderBytes.Length + headers.Length + requestData.Length];
            reqHeaderBytes.CopyTo(message, 0);
            headers.CopyTo(message, reqHeaderBytes.Length);
            requestData.CopyTo(message, reqHeaderBytes.Length + headers.Length);

            netstream.Write(message, 0, message.Length);
        }

        private byte[] ReceiveWebResponse(TcpClient tcpClient)
        {
            NetworkStream netstream = tcpClient.GetStream();
            byte[] responseData = null;

            int totalBytesRead = 0;
            int offset = 0;
            int eohIndex = -1;
            int contentLength = -1;
            bool done = false;
            do
            {
                // Get the data
                int bytesRead = netstream.Read(_recvBuffer, 0, c_recvBufferSize);
                totalBytesRead += bytesRead;

                // Prepare the response buffer
                if (responseData == null)
                {
                    responseData = new byte[totalBytesRead];
                }

                // Grow the response buffer
                if (bytesRead > responseData.Length - offset)
                {
                    byte[] newResponseData = new byte[responseData.Length + bytesRead];
                    responseData.CopyTo(newResponseData, 0);
                    responseData = newResponseData;
                }

                // Copy the data in from the response buffer
                Array.Copy(_recvBuffer, 0, responseData, offset, bytesRead);
                offset += bytesRead;

                // Check if we've got a full header yet
                if (eohIndex == -1)
                {
                    eohIndex = GetEndOfHeaderIndex(responseData);
                }
                // If we've got a full header...
                if (eohIndex != -1)
                {
                    // Check if we've got all the data
                    if (contentLength == -1)
                    {
                        Dictionary<string, string> headers = GetHeaders(responseData);
                        if (headers != null)
                        {
                            string xerr;
                            if (!headers.TryGetValue("X-Err", out xerr))
                            {
                                string contentLengthValue = headers["Content-Length"];
                                {
                                    contentLength = Int32.Parse(contentLengthValue);
                                }
                            }
                            else
                            {
                                // X-Err found, bailing
                                done = true;
                            }
                        }
                    }
                }
                if (totalBytesRead == eohIndex + 1 + contentLength)
                {
                    done = true;
                }
            } while (!done);

            return responseData;
        }

        private static int GetEndOfHeaderIndex(byte[] bytes)
        {
            // There may or may not be a complete header at this point
            int endOfHeader = -1;
            for (int i = 3; i < bytes.Length; i++)
            {
                if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
                {
                    endOfHeader = i;
                    break;
                }
            }
            return (endOfHeader);
        }

        private string GetHeaderString(byte[] bytes)
        {
            string header = null;
            int eohIdx = GetEndOfHeaderIndex(bytes);
            if (-1 != eohIdx)
            {
                // We have header
                header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
            }
            return (header);
        }

        public Dictionary<string, string> GetHeaders(byte[] responseData)
        {
            if (responseData == null)
            {
                return null;
            }

            string headerString = GetHeaderString(responseData);
            if (headerString == null)
            {
                return null;
            }
            Dictionary<string, string> headerDict = new Dictionary<string, string>();
            string[] fields = headerString.Split('\n');
            foreach (string field in fields)
            {
                string[] parts = field.Split(new char[] { ':' }, 2);
                if (parts.Length == 2)
                {
                    headerDict.Add(parts[0].Trim(), parts[1].Trim());
                }
            }
            return headerDict;
        }

        private static void ShutdownAndClose(TcpClient tcpClient)
        {
            Socket socket = null;
            NetworkStream netstream = null;
            try
            {
                netstream = tcpClient.GetStream();
                socket = tcpClient.Client;

                // Send and receive should be shutdown independently of each other
                if (socket.Connected)
                {
                    // Do a half-close on the underlying socket
                    socket.Shutdown(SocketShutdown.Send);

                    while (socket.Receive(_trash) > 0)
                    {
                    }
                }
            }
            catch { }
            finally
            {
                if (socket != null)
                {
                    // KB821625
                    socket.Close();
                }
                if (netstream != null)
                {
                    netstream.Close();
                }

                tcpClient.Close();
            }
        }

        public byte[] UploadData(
            uint serviceId,
            string relativeUrl, 
            string method, 
            byte[] headers,
            byte[] requestData,
            ref CSGInfo Slot)
        {
            byte[] responseData = new byte[0];
            TcpClient tcpClient = null;
            try
            {
                string serviceAddress;
                GetServiceInfo((XOService)serviceId, out serviceAddress);
                string finalUrl = "http://" + serviceAddress + relativeUrl;

                // Connect to the remote host
                Uri uri = new Uri(finalUrl);
                tcpClient = new TcpClient(uri.Host, uri.Port);
                tcpClient.ReceiveTimeout = ReceiveTimeout;
                tcpClient.SendTimeout = SendTimeout;
                tcpClient.Client.LingerState.Enabled = false;

                Slot.port = (ushort)((IPEndPoint)tcpClient.Client.LocalEndPoint).Port;
                ConnectionMgr.PutSlot(ref Slot, ((IPEndPoint)tcpClient.Client.LocalEndPoint).Address);

                // Send the HTTP request
                SendWebRequest(tcpClient, uri, method, headers, requestData);

                // Receive and parse the response, if any
                responseData = ReceiveWebResponse(tcpClient);
            }
            catch(Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
            }

            if (tcpClient != null)
            {
                // Clean-up after ourselves
                ShutdownAndClose(tcpClient);
            }

            return responseData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\IGService\SGUserInfo.cs ===
using System;
using System.IO;
using System.Collections;
using System.Diagnostics;
using ServerTestFramework.LiveService.FakeSG;

namespace xonline.test.IGService
{
	public class SGUserInfo
	{
        private readonly MessageHandler msgHandler;
		public ulong  UserId         = 0;
		public uint   UserFlags      = 0;
		public uint   QFlags         = 0;
		public uint   QFlagSeqNum    = 0;
		public ushort Invites        = 0;  
		public uint   InviteSeqNum   = 0;
		public ulong  MatchSessionId = 0;
		public uint   State          = 0;
		public ushort TitleDataLen   = 0; 
		public byte   []TitleData    = new byte[256];

		public SGUserInfo(ulong userId, uint userFlags, MessageHandler msgHandler)
		{
			UserId = userId;
			UserFlags = userFlags;
            this.msgHandler = msgHandler;
		}

		/// <summary>
		/// This method is called by the UDP handler to accumulate 
		/// SG qval data on the user object. This will be 'delivered'
		/// via a pull from a STF hosted PNUser object. 
		///
		/// Technically the real SG would accumulate these changes for the
		/// user this method will packetize it so that this process is not lossy.
		/// </summary>
		public bool EnqueueQVals(bool bIsPush, uint [] qvalData)
		{
            IGNotification msg = new IGNotification(UserId, bIsPush, qvalData);
            msgHandler.SendMessage(msg);
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\LBServer.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;

using LBServer.Features;

[assembly: RootNode(typeof(LBServer.LBServer))]

namespace LBServer
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class LBServer : TestSuite
	{
        public LBServer()
        {
            AddChild(new GCreateLB());
            AddChild(new GSetGetStats());
            AddChild(new GEnumStats());
            AddChild(new GDeleteLB());
        }

        public override void PreRun()
		{
			LBSHelper.Init();
		}

        public override void PostRun()
		{
			LBSHelper.UnInit();
		}

		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\Features\GCreateLB.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.LBServer;



namespace LBServer.Features
{
	/// <summary>
	/// Summary description for GCreateLB.
	/// </summary>
	public class GCreateLB:TestNode
	{
		
		public GCreateLB()
		{
			Add(new tc_Createlb());
			

		}
	}

	public class tc_Createlb : LBSTestBase
	{
		
		public tc_Createlb()
		{
			CreateLB mess= new CreateLB(1234,123456,"");
			req.AddProc(mess);
				
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\LBSManager.cs ===
using System;
using System.Net;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.LBServer;

namespace LBServer
{
	/// <summary>
	/// this cass will manage all the request to LBserver.
	/// </summary>
	public class LBSManager
	{
		LBSClient client = null;
		public static int seed=1;

		public LBSManager()
		{

		}
		public void Init()
		{
			

			if(client ==null)
			{
				client = new LBSClient("Pankajn");
			}

		
			IPHostEntry hostInfo = Dns.GetHostByName("dcaiafa1");
			IPEndPoint epoint = new IPEndPoint(hostInfo.AddressList[0],15000);
			client.Connect(epoint);
		}


		public ArrayList Execute( LBSRequest  req)
		{
			 ArrayList resps= null;
			int ReqID= Interlocked.Increment(ref LBSManager.seed);
			try
			{
				resps = client.Execute(req,ReqID);
			}
			catch( Exception e)
			{
				throw new Exception("connid ="+client.ClientID+"Request ID :"+ReqID,e);
			}

			return resps;
		}

		public ArrayList ExecuteVerify( StatsWrite[] procs)
		{

			LBSRequest req = new LBSRequest();

			for(int i=0;i<procs.Length;i++)
			{
				req.AddProc(procs[i]);
				LBSHelper.inmemLbs.StatsWrite(procs[i]);
			}
			ArrayList resps= null;
			int ReqID= Interlocked.Increment(ref LBSManager.seed);
			try
			{
				resps = client.Execute(req,ReqID);
			}
			catch( Exception e)
			{
				throw new Exception("connid ="+client.ClientID+"Request ID :"+ReqID,e);
			}

			return resps;
		}


		public void UnInit()
		{
			client.DisConnect();
			client=null;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\LBSHelper.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.LBServer;
using LBServer.IMDB;

namespace LBServer
{
	/// <summary>
	/// Summary description for LBSHelper.
	/// </summary>
	public class LBSHelper
	{
		public static LBSManager lbsm= new LBSManager();
		public static LBSIMDB   inmemLbs= new LBSIMDB();

		public LBSHelper()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		public static void UnInit()
		{
			lbsm.UnInit();
		}

		public static void Init()
		{
			lbsm.Init();
		}

		public static void CreateLB(int title , int lbid, string Params)
		{
			CreateLB mess= new CreateLB(title,lbid,Params);
			
			LBSRequest req= new LBSRequest();
			req.AddProc(mess);

			lbsm.Execute(req);

			inmemLbs.CreateLB(mess);

			
		}
	}

	
	///
	public class LBSTestBase:TestBase
	{

		protected LBSRequest req= new LBSRequest();

		override protected void Execute()
		{
			Initialize();
			LBSHelper.lbsm.Execute(req);
			Verify();
		}

		protected virtual void Initialize ()
		{
		}

		protected virtual void Verify()
		{
			ResultCode = TEST_RESULTS.PASSED;
		}

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\Features\GDeleteLB.cs ===
using System;
using ServerTestFramework;

namespace LBServer.Features
{
	/// <summary>
	/// Summary description for GDeleteLB.
	/// </summary>
	public class GDeleteLB:TestNode
	{
		public GDeleteLB()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\Features\GSetGetStats.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.LBServer;

namespace LBServer.Features
{
	/// <summary>
	/// Summary description for GSetGetStats.
	/// </summary>
	public class GSetGetStats:TestNode
	{
		public GSetGetStats()
		{
			Add(new tc_SetGet1User(25,1));
		}
	}

	public class tc_SetGet1User : LBSTestBase
	{
		int title=0;
		int lbid=0;

		public tc_SetGet1User(int title , int lbid)
		{
			this.title=title;
			this.lbid=lbid;
			
		}

		protected override void Initialize ()
		{
			LBSHelper.CreateLB(title,lbid,"");

			StatsWrite sreq= new StatsWrite(title,lbid,987654321,1);
			sreq.AddStats(1,(int)75);

			req.AddProc(sreq);

		}

		protected override void Verify()
		{

			StatsRead sread= new StatsRead(title,lbid,987654321);
			LBSRequest vreq= new LBSRequest();
			vreq.AddProc(sread);

			ArrayList respList= LBSHelper.lbsm.Execute(vreq);

			if(respList.Count==1)
			{
				ResultCode = TEST_RESULTS.PASSED;
			}


			//make sure that it has one entry with one stats.


		}


		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\Features\GEnumStats.cs ===
using System;
using ServerTestFramework;

namespace LBServer.Features
{
	/// <summary>
	/// Summary description for GEnumStats.
	/// </summary>
	public class GEnumStats:TestNode
	{
		public GEnumStats()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\CPerformanceMonitor.cs ===
using System;
using System.Diagnostics;

namespace ServerTestFramework
{
	public class CPerformanceMonitor
	{
		System.Diagnostics.PerformanceCounter		perfCounter;
		public System.Collections.Queue				dataQueue;
		int											ErrorCounter=1;

		public string		server
		{
			get	{return perfCounter.MachineName;		}
			set	{perfCounter.MachineName=value;			}
		}
	
		public string		category
		{
			get	{return perfCounter.CategoryName;		}
			set	{perfCounter.CategoryName=value;		}
		}
	
		public string		counter
		{
			get	{return perfCounter.CounterName;		}
			set	{perfCounter.CounterName=value;			}
		}
	
		public string		instance
		{
			get	{return perfCounter.InstanceName;		}
			set	{perfCounter.InstanceName=value;		}
		}
	
		public class	DataPoint
		{
			public float				time;
			public float				data;
		}

		public CPerformanceMonitor(string server, string category, string counter, string instance)
		{
			try
			{
				perfCounter=new System.Diagnostics.PerformanceCounter();
			
				perfCounter.MachineName=server;
				perfCounter.CategoryName=category;
				perfCounter.CounterName=counter;
				perfCounter.InstanceName=instance;

				dataQueue=new System.Collections.Queue(3600);
			}
			catch(Exception e)
			{
				Console.WriteLine("NON-FATAL Exception:");
				Console.WriteLine(server+"\\"+category+"("+instance+")\\"+counter);
				Console.WriteLine(e.ToString());
			}
		}

		/// <summary>
		/// Records one tick of the encapuslate counter.
		/// </summary>
		/// <param name="timeStamp">timeStamp is used to label a sample. This can be used later on when charting performance over time.
		/// The suggested way to implement Ticks is by having the callee calculate the current timeStamp, and then call all counters
		/// with that value. This will ensure that all counters have the same value</param>
		public void Tick(float timeStamp)
		{
			bool	bPassed=false;
			DataPoint pt=new DataPoint();
			try
			{
				pt.data=perfCounter.NextValue();
				bPassed=true;
			}
			catch(InvalidOperationException)
			{
				// This is just an unavailable counter (so let's not spam)
				// Console.WriteLine(server+"\\"+category+"("+instance+")\\"+counter+" is not available");
			}
			catch(Exception e)
			{
				if (ErrorCounter>0)
				{
					Console.WriteLine("NON-FATAL Exception:");
					Console.WriteLine(server+"\\"+category+"("+instance+")\\"+counter);
					Console.WriteLine(e.ToString());
					ErrorCounter--;
				}
				pt.data=0;
			}
			if (bPassed)
				ErrorCounter=1;

			pt.time=timeStamp;
			dataQueue.Enqueue(pt);
//			Console.WriteLine("Perf: {0} - {1}",pt.time.ToString(),pt.data.ToString());
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LBServer\IMDB\LBSIMDB.cs ===
using System;
using System.Collections;
using ServerTestFramework.LiveService.Stats.Util;
using ServerTestFramework.LiveService.Stats.StatsDBSim;
using ServerTestFramework.LiveService.LBServer;
namespace LBServer.IMDB
{
	/// <summary>
	/// Summary description for LBSIMDB.
	/// </summary>
	public class LBSIMDB
	{
		public uint         _guiUntier = 0;
		public  Hashtable _Lbs  = new Hashtable();

		public LBSIMDB()
		{
		}

		public void StatsWrite(StatsWrite mess)
		{
			bool HasRating= false;

			ProcParam[] tmp = mess.GetProc().Params;
			int idx=0;
			uint title = (uint)((ParamINT32)tmp[idx++].pvalue).val;
			uint lbid = (uint)((ParamINT32)tmp[idx++].pvalue).val;
			uint puid = (uint)((ParamINT64)tmp[idx++].pvalue).val;
			// increment by one we will ignore logontime.
				idx++;
			//

			LBSLeaderboard lb = (LBSLeaderboard) _Lbs[new TitleLbKey(title, lbid)];
			if(lb==null)
				throw new StatsException(1,"Invalid Title : "+title);

			BaseLBEntry  PalyerEntry=(BaseLBEntry)lb._lbEntries[puid];
			if(PalyerEntry==null)
				PalyerEntry= new BaseLBEntry(puid);


			int statscount = ((ParamINT32)tmp[idx++].pvalue).val;

			for( int i=0;i<statscount;i++)
			{

				short StatId=0;
				if(tmp[idx+1].bParamType== (byte)TypeID.Int16)
					StatId = ((ParamINT16)tmp[idx++].pvalue).val;
				else
					throw (new StatsException(1,"stats id must be Int16"));

				if((ushort)StatId ==SpecialAttrib.Rating)
				{
					if(tmp[idx+1].bParamType== (byte)TypeID.Int64)
					{
						PalyerEntry._lRating = (long) ((ParamINT64)tmp[idx++].pvalue).val;;
						PalyerEntry._uiUntier=_guiUntier; 
						HasRating=true;
					}
					else
						throw (new StatsException(1,"Rating must be long"));
			
				}
				else
				{
					PalyerEntry._stats[StatId]= tmp[idx++] ;

				}
				
				if(HasRating && lb._lbEntries[puid]==null)
					lb._rankedEntries.Add(PalyerEntry);
			
				if(lb._lbEntries[puid]==null)
					lb._lbEntries[puid]=PalyerEntry;

				// add support for attachments later.
	//			if(CheckIFUserQulifiesAtt(PalyerEntry._ulUserId,PalyerEntry._lRating,lb))
	//				throw (new StatsException(HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT,"User Qulafies for attachment"));
	

			}
		}

		public void StatsRead(StatsRead mess)
		{
			ProcParam[] tmp = mess.GetProc().Params;



		}

		public void CreateLB(CreateLB mess)
		{
			ProcCall tmp = mess.GetProc();
		
			uint uiTitleId=(uint)((ParamINT32)tmp.Params[0].pvalue).val;
			uint uiLbId= (uint)((ParamINT32)tmp.Params[1].pvalue).val;
			TitleLbKey titleLbKey = new TitleLbKey(uiTitleId, uiLbId);

			LBSLeaderboard lb = new LBSLeaderboard(uiTitleId,uiLbId);

			_Lbs[titleLbKey]=lb;

		}

		public void StatsEnum(StatsEnum mess)
		{
		}
		public void DeleteLB()
		{
			//TitleLbKey titleLbKey = new TitleLbKey(uiTitleId, uiLbId);
			//_Lbs.Remove(titleLbKey);
		}

	}

	public class LBSLeaderboard :BaseLB
	{
		public LBSLeaderboard(uint uiTitleId,uint uiLbId) :base(uiTitleId,uiLbId)
		{
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\CPerformanceMonitorPump.cs ===
using System;
using System.Text;
using System.IO;
using System.Threading;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
	public class C2PerformanceMonitorPump
	{
		const int			SizeBeforeDeque=10;
		Thread				PumpThread;
		bool				KeepRunning;
		DateTime			StartTime;
		public ArrayList	PerfCounters;
		string				fileName;

		void	WriteHeader()
		{
			TextWriter	TW=File.CreateText(fileName);

			TW.Write("Time,");
			foreach (CPerformanceMonitor monitor in PerfCounters)
			{
				string s=monitor.server+"\\"+monitor.category+"\\"+monitor.counter;
				TW.Write(s+",");
			}
			TW.WriteLine("");
			TW.Flush();
			TW.Close();
		}

		void DumpResults(int TotalCount)
		{
			TextWriter	TW=File.AppendText(fileName);

//			Console.Write("Dumping "+TotalCount+" results ");
			for (int i=0; i<TotalCount; i++)
			{
				bool	bWriteTime=true;
				foreach (CPerformanceMonitor monitor in PerfCounters)
				{
					CPerformanceMonitor.DataPoint dp=monitor.dataQueue.Dequeue() as CPerformanceMonitor.DataPoint;
					if (bWriteTime)
					{
						TW.Write(dp.time+",");
						bWriteTime=false;
					}
					TW.Write(dp.data+",");					
				}
				TW.WriteLine("");
			}
			TW.Close();
		}

		void Pump()
		{
			try
			{
				int TotalCount=0;
				int	SecondsBetweenTicks=15;
				DateTime	NextTick=DateTime.Now.AddSeconds(SecondsBetweenTicks);
				while (KeepRunning)
				{
					float timestamp=(float) (DateTime.Now-StartTime).TotalSeconds;
					foreach (CPerformanceMonitor monitor in PerfCounters)
					{
						monitor.Tick(timestamp);
					}
					TotalCount=(PerfCounters[0] as CPerformanceMonitor).dataQueue.Count;
					if (TotalCount>SizeBeforeDeque)
					{
						DumpResults(SizeBeforeDeque);
					}

					TimeSpan TimeToGo=NextTick.Subtract(DateTime.Now);
					double	SleepTime=TimeToGo.TotalMilliseconds;
					if (SleepTime>0)
						System.Threading.Thread.Sleep((int) SleepTime);
					NextTick=NextTick.AddSeconds(SecondsBetweenTicks);
				}

				TotalCount=(PerfCounters[0] as CPerformanceMonitor).dataQueue.Count;
				DumpResults(TotalCount);

				Console.WriteLine("PerfMon pump terminating");
			}
			catch(Exception e)
			{
				ConsoleX.WriteLine(CC.YELLOW,"Monitor pump (heartbeat) has thrown an exception. WTF?");
				ConsoleX.WriteLine(CC.YELLOW,"The time is "+DateTime.Now);
				ConsoleX.WriteLine(CC.YELLOW,e.ToString());
			}
		}
		public void Stop()
		{
			KeepRunning=false;
			while (PumpThread.IsAlive)
			{
				Thread.Sleep(200);
			}
		}

		public C2PerformanceMonitorPump(string[] ServerList)
		{
			PerfCounters=new ArrayList();
			Console.WriteLine(Global.GenerateSeparatorString("Performance monitor pump:"));
			Console.Write("Server: ");
			foreach (string Server in ServerList)
			{
				Console.Write(Server+"; ");
				AddServer(Server);
			}
			Console.WriteLine("");
		}
		void AddServer(string Server)
		{
			PerfCounters.Add(new CPerformanceMonitor(Server,"Processor","% Processor Time","_Total"));
			PerfCounters.Add(new CPerformanceMonitor(Server,".NET CLR Memory","# Bytes in all Heaps","_Global_"));
			PerfCounters.Add(new CPerformanceMonitor(Server,"PhysicalDisk","Disk Bytes/sec","_Total"));
			PerfCounters.Add(new CPerformanceMonitor(Server,"Process","Private Bytes","aspnet_wp"));
			PerfCounters.Add(new CPerformanceMonitor(Server,"Process","Handle Count","aspnet_wp"));
			PerfCounters.Add(new CPerformanceMonitor(Server,"Web Service","Current Connections","_Total"));
			PerfCounters.Add(new CPerformanceMonitor(Server,".NET CLR Memory","# GC Handles","aspnet_wp"));
		}
		public void Go(string FileNameBase)
		{
			KeepRunning=true;
			StartTime=DateTime.Now;
			fileName=FileNameBase+DateTime.Now.Ticks+".csv";
			WriteHeader();
			PumpThread=new Thread(new ThreadStart(Pump));
			PumpThread.Start();
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFController\Listner.cs ===
using System;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace STFController
{

	public class RegisterKey
	{
		public string IP;
		public string component;
		public RegisterKey(string ip, string comp)
		{
			IP=ip;
			component=comp;
		}
		public override bool Equals(object obj)
		{
			return (IP == ((RegisterKey)obj).IP)
				&& (component == ((RegisterKey)obj).component);
		}
        
		public override int GetHashCode()
		{
			return (int)(IP.GetHashCode()<<15 + component.GetHashCode());
		}
	}

	public class ComponentState
	{
		public int		Type;
		public int		currentState;
		public string	IP;
		public int		ListiningPort;
		public string	Component;
		public DateTime lastupdated;
		public int	changestate;


		public ComponentState()
		{
		}

		public ComponentState(Register reg, string ip)
		{
			Type= reg.Type;
			currentState=reg.State;
			ListiningPort=reg.ListeningPort;
			Component =reg.Component;
			lastupdated= DateTime.UtcNow;
			IP =ip;
			changestate=(int)TestState.running;

		}

		public override string ToString()
		{
            string type = 
                Type == (int)TestType.Functional ? "Functional" :
                Type == (int)TestType.DVTFunctional ? "DVTFunctional" :
                Type == (int)TestType.Stress ? "Stress" : 
                "unknown";
            string state = 
                currentState == (int)TestState.start ? "start" :
                currentState == (int)TestState.init ? "init" :
                currentState == (int)TestState.running ? "running" :
                currentState == (int)TestState.terminating ? "terminating" :
                currentState == (int)TestState.stop ? "stop" :
                "unknown";
            string result = "STF|" + Component + "|" + type + "|" + state + "|" + ListiningPort;
			return result; 
		}

	}


	
	
	/// <summary>
	/// Summary description for Listner.
	/// </summary>
	public class ControlListner
	{
		public static Hashtable  clients = new Hashtable();
		public bool run = true;
		public ControlListner()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public void start()
		{
			run=true;
			Thread td = new Thread(new ThreadStart(listnerthread));
			td.Start();

		}

		public void stop()
		{
			run = false;

		}

		public void listnerthread()
		{
			FDTransaction.MyUdpClient sock = new FDTransaction.MyUdpClient();
					
			sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReceiveTimeout,600000);
			sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,35000);
			sock.Client.Bind(new IPEndPoint(IPAddress.Any, 65450));
				

			while(run)
			{
				try
				{
					IPEndPoint endpoint= null;
					byte[] recdata= sock.Receive(ref endpoint);

					if(recdata.Length>0)
					{
						MemoryStream reqStream = new MemoryStream(recdata);
						MessageHeader msgHdr=(MessageHeader) new MessageHeader().ReadStream(reqStream);
						

						if(msgHdr.msgType ==(int)MsgTypes.Register)
						{
							Register req= (Register)new Register().ReadStream(reqStream);
							RegisterKey  key = new RegisterKey(endpoint.Address.ToString(),req.Component);
							if(!clients.ContainsKey(key))
							{
								ComponentState tmp = new ComponentState(req,key.IP);
								STfControlDB.AddComponent(tmp);
								clients.Add(key,tmp);
							}
							else
							{
								if(req.State==(int)TestState.start)
								{
									ComponentState tmp = new ComponentState(req,key.IP);
									STfControlDB.AddComponent(tmp);
									clients.Add(key,tmp);
								}
								else
								{
									ComponentState tmp = (ComponentState)clients[key];
									tmp.currentState= req.State;
									tmp.ListiningPort= req.ListeningPort;
									tmp.lastupdated=DateTime.UtcNow;
									STfControlDB.AddComponent(tmp);
								}
							}
						}
						

					
					}
				}
				catch(System.Exception e)
				{
					Service1.log.WriteEntry(e.ToString());
				}
			}
		
		}
	}

	public class CommondListner
	{
		public const int Headersize= 8;
		public bool run = true;
		protected AutoResetEvent ShutDownEvent = new System.Threading.AutoResetEvent(false);
		public CommondListner()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public void start()
		{
			run=true;
			Thread td = new Thread(new ThreadStart(listnerthread));
			td.Start();
			ShutDownEvent.Reset();

		}

		public void stop()
		{
			run = false;
			ShutDownEvent.Set();

		}
		const int InitialBufSize = 4096;

		private void IncomingReqHandler(Object stateInfo) 
		{

			Socket request = (Socket)stateInfo;
			/////////////////////////////////////
			int CurrentBufferSize=InitialBufSize;
			Byte[] receiveBytes=null;
			int got=0;
			int cum=0;
			
			

			try
			{
				while(true)
				{
					CurrentBufferSize=InitialBufSize;
					receiveBytes=new Byte[InitialBufSize+1];
					got=0;
					cum=0;
					
					
					int SpinCount=0;
					while ((request.Available==0) && (SpinCount<10))
					{
						SpinCount++;
						if(ShutDownEvent.WaitOne(1,false))
						{
							ShutDownEvent.Set();
							return ;
						}
					}

					if(request.Available>0)
					{
						got=request.Receive(receiveBytes,cum,CurrentBufferSize-cum,SocketFlags.None);

						if(got==0)
						{
							// the remote host have shout down the socket. close the socket and exit from the thread.
							request.Close();
							request= null;
							return;
						}
						else if (got >Headersize)
						{
							cum+=got;

							MessageHeader header =(MessageHeader) new MessageHeader().ReadBytes(receiveBytes);
							while(cum<(header.size))
							{
								got=request.Receive(receiveBytes,cum,CurrentBufferSize-cum,SocketFlags.None);
								cum+=got;
								if(ShutDownEvent.WaitOne(1,false))
								{
									ShutDownEvent.Set();
									return ;
								}
							}

						}
					}

					if(cum >0)
					{

						MemoryStream stream = new MemoryStream(receiveBytes);
						MessageHeader reqhead =(MessageHeader) new MessageHeader().ReadStream(stream);
						CommandMsg Req = (CommandMsg)new CommandMsg().ReadStream(stream);
						string comm= Req.Text.Trim();
						string[] commandparams = comm.Split(new char[]{' '});

						STfControlDB.logCommand(commandparams[0],commandparams[1]);
						if(commandparams[0].ToLower()=="list")
						{
							string data="";
							lock(ControlListner.clients)
							{
								foreach (RegisterKey key in ControlListner.clients.Keys)
								{
									ComponentState client = (ComponentState)ControlListner.clients[key];
									data += client.ToString()+"|"+key.IP+"\n";
								}
							}

							SendResponse(request,data);
                            						
							


						}
						else if(commandparams[0].ToLower()=="stop")
						{
							SendResponse(request,"All components  will be stoped in next 10 minutes");
							if(commandparams[2]=="xbox360")
							{
								lock(ControlListner.clients)
								{
									foreach (RegisterKey key in ControlListner.clients.Keys)
									{
										ComponentState client = (ComponentState)ControlListner.clients[key];
										if(client.currentState ==(int)TestState.running)
										{
											client.currentState=(int)TestState.terminating;
											client.changestate=(int)TestState.stop;
											SendTextCommand(client,"stop");
										}

										
									}
								}
							}
						}
						else
						{
							string resp=  "Supported commands  list -> displays all registured components \n" ;
							resp+= "Supported commands  stop -> sends stop command to all registured components" ;
					
							SendResponse(request,"Unknown Command \n"+resp);
						}

						receiveBytes= null;
					}
					
				}
			}
			catch(System.Threading.ThreadAbortException)
			{
				//thread told to shutdown; goto finally block
			}
			catch (SocketException)
			{
				//Console.WriteLine("socket exception 0x"+e.NativeErrorCode.ToString("X")+" Handler count ="+Handlers);
			}
			catch (ObjectDisposedException) 
			{
				// Ignore the Exception sinc the Opposite party may have  closed the connection.
				request= null;
			}
			catch (Exception e )
			{
				Console.WriteLine("unexpected exception:");
				Console.WriteLine(e.ToString()); 
			}
			finally
			{
				
				if(request != null)
				{
					request.Shutdown(SocketShutdown.Both);
					request.Close();
					
					
				}
			}
	
	
		}

		public static void SendTextCommand(ComponentState client , string command)
		{
			MessageHeader header = new MessageHeader((int)MsgTypes.Command);
			CommandMsg resp = new CommandMsg();
			resp.Text=command;
			header.size= header.Size()+resp.Size();
			byte[] buff  =new byte[header.size];
			MemoryStream Respstream = new MemoryStream(buff);
			header.WriteStream(Respstream);
			resp.WriteStream(Respstream);
			

			try
			{
				
				byte[] recdata= new byte[0];
				IPEndPoint endpoint = new IPEndPoint(IPAddress.Parse(client.IP),client.ListiningPort);

				FDTransaction.MyUdpClient sock = new FDTransaction.MyUdpClient();
				sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,1000);
				sock.Send(buff,buff.Length,endpoint);

				STfControlDB.logCommand("Sent "+command+"to "+client.IP,"Service");
			}
			catch(System.Exception e)
			{
				System.Console.WriteLine(e);
			}
		}

		public static void  SendResponse(Socket request,string data )
		{
			MessageHeader header = new MessageHeader((int)MsgTypes.Command);
			CommandMsg resp = new CommandMsg();
			resp.Text=data;
			header.size= header.Size()+resp.Size();
			byte[] buff  =new byte[header.size];
			MemoryStream Respstream = new MemoryStream(buff);
			header.WriteStream(Respstream);
			resp.WriteStream(Respstream);
									
			request.Send(buff);
		}

		public void listnerthread()
		{
			FDTransaction.MyTcpClient sock = new FDTransaction.MyTcpClient();
					
			sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReceiveTimeout,600000);
			sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,35000);
			sock.Client.Bind(new IPEndPoint(IPAddress.Any, 65451));

			while(run)
			{
				try
				{
					Socket request = null;
					sock.Client.Listen(100);

					request = sock.Client.Accept();

					ThreadPool.QueueUserWorkItem(new WaitCallback(IncomingReqHandler),request);

					
					
				}
				catch(System.Exception e)
				{
					Service1.log.WriteEntry(e.ToString());
				}
			}
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFController\Monitor.cs ===
using System;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace STFController
{
	/// <summary>
	/// Summary description for Monitor.
	/// </summary>
	public class Monitor
	{
		protected AutoResetEvent ShutDownEvent = new System.Threading.AutoResetEvent(false);
		

		public Monitor()
		{
		}
		public void Stop()
		{
			ShutDownEvent.Set();

		}

		public void  Start()
		{
			Thread WorkerTd = new Thread(new  ThreadStart(Workerthread));
			WorkerTd.Start();
		}
		public void Workerthread()
		{

			while(!ShutDownEvent.WaitOne(300000,false))
			{
			
				lock(ControlListner.clients)
				{
					DateTime lasttime = DateTime.UtcNow;
					lasttime= lasttime.AddMinutes(-20);
					foreach (RegisterKey key in ControlListner.clients.Keys)
					{
						ComponentState client = (ComponentState)ControlListner.clients[key];
						if(client.changestate ==(int)TestState.stop && client.currentState!=(int)TestState.stop)
						{
							client.currentState=(int)TestState.terminating;
							client.changestate=(int)TestState.stop;
							
							CommondListner.SendTextCommand(client,"stop");
						}
						
						if(  client.lastupdated.CompareTo(lasttime)<0)
						{
							client.currentState=(int)TestState.stop;
							STfControlDB.AddComponent(client);
						}
						
					}
				}
	
			
			}
			ShutDownEvent.Set();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFController\Service1.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading;

namespace STFController
{
	public class Service1 : System.ServiceProcess.ServiceBase
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		ControlListner controltd= new ControlListner();
		CommondListner commandtd = new CommondListner();
		Monitor monitor = new Monitor();
		public static EventLog log = new EventLog("Application",".","STFCOntroller");

		public Service1()
		{
			// This call is required by the Windows.Forms Component Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitComponent call
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;
	
			// More than one user Service may run within the same process. To add
			// another service to this process, change the following line to
			// create a second service object. For example,
			//
			//   ServicesToRun = new System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
			//
			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new Service1() };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
			this.ServiceName = "StfController";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			// TODO: Add code here to start your service.

			//  create a UDP listner with a standered port . and lisin for regestor  commands.
			//user the main thread to lisin to  commands to sent o others.
			try
			{
				controltd.start();
				commandtd.start();
				monitor.Start();


			}
			catch(System.Exception e)
			{

			log.WriteEntry(e.ToString());
			
			}
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			// TODO: Add code here to perform any tear-down necessary to stop your service.
			controltd.stop();
			commandtd.stop();
			monitor.Stop();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFController\StfSVC.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;

namespace STFController
{
	/// <summary>
	/// Summary description for StfSVC.
	/// </summary>
	[RunInstaller(true)]
	public class StfSVC : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller STfService;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public StfSVC()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
			this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
			this.STfService = new System.ServiceProcess.ServiceInstaller();
			// 
			// serviceProcessInstaller1
			// 
			this.serviceProcessInstaller1.Password = null;
			this.serviceProcessInstaller1.Username = null;
			// 
			// XBLPerfLogService
			// 
			this.STfService.ServiceName = "StfController";
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.serviceProcessInstaller1,
																					  this.STfService});

		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Report.cs ===
using System;
using System.Text;
using System.IO;
using System.Collections;

using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    public class Report : InfiniteLifetimeMarshalByRefObject
    {
        /// <summary>
        /// Bit flags used for specifying the logging level of a report.
        /// </summary>
        public const uint DEBUG     = 0x1;
        public const uint INFO      = 0x2;
        public const uint WARN      = 0x4;
        public const uint ERROR     = 0x8;
        public const uint FATAL     = 0x10;
        public const uint SUCCESS   = 0x20;

        public const uint FILTER_ALL = DEBUG | INFO | WARN | ERROR | FATAL | SUCCESS;

        private const /*u*/int LOCK_TIMEOUT_IN_MS=8192;

        /// <summary>
        /// Interfaced needed to a log message sink.
        /// </summary>
        public interface Destination
        {
            void Log(uint level, string path, string message, string suiteName, string groupName, string caseName, System.DateTime date);
        }
        
        // create the root report
        static Report   _Root = new Report();

        Report          _Parent;
        string          _Name;
        string          _Category;
        ArrayList       _Destinations;
        uint            _Filter;
        
        System.Threading.ReaderWriterLock  _DestCollLock=new System.Threading.ReaderWriterLock();

        public string Name
        {
            get {return _Name;}
        }
        public string Category
        {
            get {return _Category;}
        }
        public uint Filter
        {
            get {return _Filter;}
        }
    
        /// <summary>
        /// Get the global root reporting destination.
        /// </summary>
        public static Report GetRoot()
        {
            return _Root;
        }

        public static void SetRoot(Report r)
        {
            _Root = r;
        }

        // Default constructor only to be called by the static initializer
        protected Report()
        {
            _Parent = null;
            _Category = "Global";
            _Name = "";
            _Filter = FILTER_ALL;
            _Destinations = null;
        }

        /// <summary>
        /// Create a new report object it will be placed under the root report.
        /// </summary>
        /// <param name="Category">Category of logging</param>
        /// <param name="Name">Name of specific log</param>
        public Report(string Category, string Name)
        {
            _Parent = Report.GetRoot();
            _Category = Category;
            _Name = Name;
            _Filter = FILTER_ALL;
            _Destinations = null;
        }

        /// <summary>
        /// Create a new report that inherits it's properties (minus filter) from
        /// a parent report. Name must be specified for every report seperately.
        /// </summary>
        /// <param name="parent">Report to inherit properties from</param>
        public Report(Report parent, string Name)
        {
            _Parent = parent;
            _Category = _Parent._Category;
            _Filter = FILTER_ALL;
            _Name = Name;
            _Destinations = null;
        }

        /// <summary>
        /// Create a new default style report with a given name and unspecified
        /// category. This report will automatically be attached to the root 
        /// reporting object.
        /// </summary>
        /// <param name="Name">Name of this report.</param>
        public Report(string Name)
        {
            _Parent = Report.GetRoot();
            _Category = _Parent.Category;
            _Filter = FILTER_ALL;
            _Name = Name;
            _Destinations = null;
        }

        /// <summary>
        /// Add a new reporting destination to the internal list of reporters.
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol Destination</param>
        public void AddReportDestination(Destination dest)
        {
            try
            {
                _DestCollLock.AcquireWriterLock(LOCK_TIMEOUT_IN_MS);
            }
            catch
            {
                CoreGlobal.RO.Warn("AcquireWriterLock timed out in AddReportDestination.");
                return;
            }

            try
            {
                if(_Destinations == null)
                {
                    _Destinations = new ArrayList();
                }
                _Destinations.Add(dest);
            }
            finally
            {
                _DestCollLock.ReleaseWriterLock();
            }
        }

        /// <summary>
        /// Removeo a new reporting destination by reference.
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol Destination</param>
        public void RemoveReportDestination(Destination dest)
        {
            try
            {
                _DestCollLock.AcquireWriterLock(LOCK_TIMEOUT_IN_MS);
            }
            catch
            {
                CoreGlobal.RO.Warn("AcquireWriterLock timed out in RemoveReportDestination.");
                return;
            }

            try
            {
                if(_Destinations != null)
                {
                    _Destinations.Remove(dest);
                }
            }
            finally
            {
                _DestCollLock.ReleaseWriterLock();
            }
        }

        /// <summary>
        /// Return a list of all destinations for this report.
        /// </summary>
        /// <returns>ArrayList of Destinations.</returns>
        public ArrayList GetReportDestinations()
        {
            return _Destinations;
        }
        
        /// <summary>
        /// Remove all reporting destinations.
        /// </summary>
        public void ResetDestinations()
        {
            try
            {
                _DestCollLock.AcquireWriterLock(LOCK_TIMEOUT_IN_MS);
            }
            catch
            {
                CoreGlobal.RO.Warn("AcquireWriterLock timed out in ResetDestinations.");
                return;
            }

            try
            {
                if(_Destinations != null)
                {
                    _Destinations.Clear();
                }
            }
            finally
            {
                _DestCollLock.ReleaseWriterLock();
            }
        }

        /// <summary>
        /// Change the level of reporting that will be written.
        /// </summary>
        /// <param name="filter">Log level bitflags</param>
        public void SetLevelFilter(uint filter)
        {
            _Filter = filter;
        }

        /// <summary>
        /// Shortcut to enable only a specific set of filters
        /// </summary>
        /// <param name="filter">Log level bitflags</param>
        public void EnableFilter(uint filter)
        {
            _Filter |= filter;
        }

        /// <summary>
        /// Shortcut to disable only a specific set of filters
        /// </summary>
        /// <param name="filter">Log level bitflags</param>
        public void DisableFilter(uint filter)
        {
            _Filter &= ~filter;
        }

        void Log(uint level, string name, string message, System.DateTime date)
        {
            if(((uint)level & _Filter) == 0)
            {
                return;
            }

            if (date==System.DateTime.MinValue)
            {
                date=System.DateTime.Now;
            }

            bool doLog = true;
            if(_Destinations != null && _Destinations.Count > 0)
            {
                string suiteName,groupName,caseName;
                ThreadTracker.GetTest(out suiteName, out groupName, out caseName);

                try
                {
                    _DestCollLock.AcquireReaderLock(LOCK_TIMEOUT_IN_MS);
                }
                catch
                {
                    //We can't use RO to warn about this, else we'll just loop back into ourself, so directly output to debug
                    System.Diagnostics.Debugger.Log(0,"Report.Log","AcquireReaderLock timed out in Log.");
                    doLog = false;
                }

                if (doLog)
                {
                    try
                    {
                        foreach(Destination dest in _Destinations)
                        {
                            dest.Log(level, name, message, suiteName, groupName, caseName, date);
                        }
                    }
                    finally
                    {
                        _DestCollLock.ReleaseReaderLock();
                    }
                }
            }

            if(_Parent != null)
            {
                _Parent.Log(level, name, message, date);
            }
        }

        /// <summary>
        /// Log a message at debug priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Debug(string message)
        {
            Log(DEBUG, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at debug priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Debug(string format, params object[] args)
        {
            Log(DEBUG, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at info priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Info(string message)
        {
            Log(INFO, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at info priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Info(string format, params object[] args)
        {
            Log(INFO, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at warning priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Warn(string message)
        {
            Log(WARN, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at warning priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Warn(string format, params object[] args)
        {
            Log(WARN, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at error priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Error(string message)
        {
            Log(ERROR, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at error priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Error(string format, params object[] args)
        {
            Log(ERROR, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at fatal priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Fatal(string message)
        {
            Log(FATAL, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at fatal priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Fatal(string format, params object[] args)
        {
            Log(FATAL, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// Log a message at success priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Success(string message)
        {
            Log(SUCCESS, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at success priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Success(string format, params object[] args)
        {
            Log(SUCCESS, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Formats and timestamps a log line nicely.
        /// </summary>
        public static string FormatLogLine(uint level, string path, string message)
        {
            return FormatLogLine(DateTime.MinValue, level, path, message);
        }
        public static string FormatLogLine(System.DateTime date, uint level, string path, string message)
        {
            string logLine = "";
            if (date!=System.DateTime.MinValue) logLine += "[" + date.ToString() + "] ";
            if (path!=null && path.Length>0) logLine += "[" + path + "] ";
            logLine += message;
            switch(level)
            {
                case Report.DEBUG:
                    logLine="[DBG] " + logLine;
                    break;
                case Report.INFO:
                    logLine="[INF] " + logLine;
                    break;
                case Report.WARN:
                    logLine="[WRN] " + logLine;
                    break;
                case Report.ERROR:
                    logLine="[ERR] " + logLine;
                    break;
                case Report.FATAL:
                    logLine="[FTL] " + logLine;
                    break;
                case Report.SUCCESS:
                    logLine="[SUC] " + logLine;
                    break;
                default:
                    logLine="[???] " + logLine;
                    break;
            }

            return logLine;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\CoreGlobals.cs ===
namespace ServerTestFramework
{
    public static class CoreGlobal
    {
        // -- public globals

        
        /// <summary>
        /// The default config file to load.
        /// </summary>
        public static string DefaultConfigFile = "stf.xml";

        /// <summary>
        /// The current config set.
        /// </summary>
        public static ServerTestFramework.Runner.StfXmlDoc Config;

        /// <summary>
        /// Check the versions of other assemblies linked against us, to make sure there's not a mismatch between the version they linked with and our version.
        /// </summary>
        public static void CheckAssemblyVersion(System.Reflection.Assembly asm)
        {
            //get our stfcore version
            System.Reflection.Assembly myAsm=System.Reflection.Assembly.GetExecutingAssembly();
            System.Reflection.AssemblyName myAsmName=myAsm.GetName();
            string ourName="STFCore";

            //check for stf referances
            System.Reflection.AssemblyName []refAsmNames=asm.GetReferencedAssemblies();
            foreach (System.Reflection.AssemblyName rAsmName in refAsmNames)
            {
                if (rAsmName.Name==ourName)
                {
                    if (myAsmName.Version != rAsmName.Version)
                    {
                        CoreGlobal.RO.Warn("Assembly \"" + asm.GetName().Name + "\" was linked against a different version of "+ourName+".dll than the currently loaded version.");
                        CoreGlobal.RO.Warn("This is usually harmless, but it can sometimes result in unusual problems (such as referances to fields or methods that don't exist).");
                        CoreGlobal.RO.Warn(asm.GetName().Name + " linked against "+ourName+".dll version: " + rAsmName.Version);
                        CoreGlobal.RO.Warn(ourName+".dll version currently loaded: " + myAsmName.Version);
                    }
                }

                //try to recurse into that to check it's referances too
                try
                {
                    if (!(rAsmName.Name.StartsWith("System.") || rAsmName.Name=="System" || rAsmName.Name=="WstClient")) //exclude these from recursion
                    {
                        System.Reflection.Assembly recAsm=System.Reflection.Assembly.ReflectionOnlyLoad(rAsmName.Name);
                        CheckAssemblyVersion(recAsm);
                    }
                }
                catch
                { }
            }
        }

        /// <summary>
        /// Initialize the framework using a pre-created XML config document.
        /// </summary>
        public static void Initialize(System.Xml.XmlDocument config)
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config = new ServerTestFramework.Runner.StfXmlDoc();
            Config.Merge(config, "/");
            DoInitialize();
        }
        /// <summary>
        /// Initialize the framework using a pre-created XML config document.
        /// </summary>
        public static void Initialize(ServerTestFramework.Runner.StfXmlDoc config)
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config = config;
            DoInitialize();
        }
        /// <summary>
        /// Initialize the framework using the default config file.
        /// </summary>
        public static void Initialize()
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config = new ServerTestFramework.Runner.StfXmlDoc(DefaultConfigFile);
            DoInitialize();
        }


        // -- core-only globals

        //reporting object for the core
        internal static Report RO = new Report("Core");

        // Internal initialize after we have a valid xml document (CoreGlobal.Config)
        private static void DoInitialize()
        {
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFControllerClient\main.cs ===
using System;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Collections;
using System.Threading;
using System.Security.Principal;
using ServerTestFramework.LiveService;

namespace STFControllerClient
{
	/// <summary>
	/// Client used to connect to stf controller service and
	/// execute commands.
	/// </summary>
	class Client
	{
		public int Headersize = 8;
		Controller tmp1 = new Controller();
		Controller tmp2 = new Controller();
		string ip = "127.0.0.1";

		enum Commands
		{
			List,
			Stop,
			Test
		};
		

		/// <summary>
		/// Console entry point
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
			Client client = new Client();
			bool result = false;


			string  currentUser = WindowsIdentity.GetCurrent().Name;
			System.Console.WriteLine("Executing Commands AS " + currentUser);

	
			if(args.Length >1)
			{
				// Parse arguments
				client.ip = args[0].Trim();

				// Get command
				foreach(string command in Enum.GetNames(typeof(Commands)))
				{
					if(0 == String.Compare(args[1], command, true))
					{
						result = client.ExecCommand(args[1].ToLower() + " " + currentUser);
					}
				}
			}

			if(!result)
			{
				Usage();
			}

			// Allow automation 
			return result ? 0 : -1;
		}

		private static void Usage()
		{
			Console.WriteLine( "Supported commands:" );
			Console.WriteLine("    list:  Displays all registured components" );
			Console.WriteLine( "   stop:  Sends stop command to all registured components" );
			Console.WriteLine( "   test:  Run client/controller unit test" );

			Console.WriteLine( "Usage  STFControllerClient <IP|HOSTNAME> command " );
			Console.WriteLine( "example :-  STFControllerClient 65.52.241.139 list " );
		}

		public void Test()
		{
			Component1();
			component2();
			for ( int i=0;i<10;i++)
			{
				ExecCommand("list");
				//if(i==0)
					//tmp2.Stop();
				System.Threading.Thread.Sleep(300000);
			}
			
			tmp1.Stop();
		}

		public void Component1()
		{
			tmp1.SetCurrentState(TestType.Stress,TestState.running,"tfeedback");
			tmp1.Start(TestType.Stress,TestState.running,"tfeedback",ip,new CmdListener_Stop(donothing));
		}

		public static  void donothing()
		{
		}

		public void component2()
		{
			tmp1.Start(TestType.Stress,TestState.running,"tstorage",ip,new CmdListener_Stop(donothing));
		}

		public IPAddress LookupAddress(string hostname)
		{
			if(null == hostname || hostname.Length == 0)
			{
				throw new ArgumentException("LookupAddress: Invalid hostname passed");
			}

			IPHostEntry hent = Dns.Resolve(hostname);

			if(hent.AddressList.Length == 0)
			{
				throw new Exception("Address list was not populated for call to Dns.Resolve(" + hostname + ")");
			}

			return hent.AddressList[0];
		}

		public bool ExecCommand(string command)
		{
			bool retValue = true;

			try
			{
				// Do fall back DNS lookup if we are not passed a valid IP address
				IPEndPoint endpoint = null;
				try
				{
					endpoint = new IPEndPoint(IPAddress.Parse(ip),65451);
				}
				catch(FormatException)
				{
					endpoint = new IPEndPoint(LookupAddress(ip),65451);
				}

				System.Net.Sockets.NetworkStream outStream=null;

				FDTransaction.MyTcpClient sock = new FDTransaction.MyTcpClient();
					


				sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReceiveTimeout,600000);
				sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,35000);

				sock.Client.Connect(endpoint);
				outStream=sock.GetStream();

				Console.WriteLine("Executing command: {0} on for control server: {1}", command, endpoint.ToString());

				// build data packet here 
				MessageHeader header = new MessageHeader((int)MsgTypes.Command);
				CommandMsg resp = new CommandMsg();
				resp.Text=command;
				header.size= header.Size()+resp.Size();
				byte[] buff  =new byte[header.size];
				MemoryStream Respstream = new MemoryStream(buff);
				header.WriteStream(Respstream);
				resp.WriteStream(Respstream);
				
				outStream.Write(buff,0,(int) buff.Length);
				
				byte []responseData=new byte[1024*5];

				int totalbytesread = outStream.Read(responseData,0,responseData.Length);
				if(totalbytesread >= Headersize)
				{
					MessageHeader respheader =(MessageHeader) new MessageHeader().ReadBytes(responseData);
				

					while(totalbytesread<(respheader.size))
					{
						int bytesRead = outStream.Read(responseData,totalbytesread,responseData.Length);
						totalbytesread+=bytesRead;
					}

					// all data is recived 
					MemoryStream stream = new MemoryStream(responseData);
					MessageHeader reqhead =(MessageHeader) new MessageHeader().ReadStream(stream);
					CommandMsg Req = (CommandMsg)new CommandMsg().ReadStream(stream);
					
			
					Console.WriteLine(Req.Text);

				
				}
				
			}
			catch(System.Exception e)
			{
				Console.WriteLine(e);
				retValue = false;
			}

			return retValue;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\TestBase.cs ===
using System;
using System.Net;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    // The class hierarchy here needs to be cleaned up, but it will likely require
    // breaking changes. At this point (middle of of M5), that is unacceptable, so 
    // this is what we have to live with for now.  
    //
    // For now, it looks like:
    //
    //                       MinimumTestBase
    //                       /             \
    //                TestBase             MinimumStressTestBase
    //                /      \
    // TestBaseFunction      StressTestBase
    //                       /
    //   DynamicStressTestBase
    //
    // The "Minimum*" classes are the new ones; if you implement them, your class
    // MUST BE MULTI-THREAD SAFE. 
    //

    public enum TEST_RESULTS 
    {
        NOT_EXECUTED, 
        PASSED, 
        FAILED, 
        IN_PROGRESS,
        COMPOSITE
    };

    /// <summary>
    /// This must be multi-thread safe.
    /// </summary>
    public abstract class MinimumTestBase : InfiniteLifetimeMarshalByRefObject, ICloneable
    {
        // All of these may potentially be accessed by multiple threads. They should be considered read-only after initializing them.
        // IMPORTANT:  When you add something here, look also to see if it needs added the Clone() function!
        public string           Name;
        public string           Desc                = "";
        public TestBaseGroup    Parent;
        public bool             Enabled             = true;
        public bool             CatchExceptions     = true;
        public bool             Ignore              = false;    
        public bool             IsDvt               = false;
        public int              BugId               = 0;
        public uint             AsyncGroup          = 0;
        public bool             IsExcludedFromDailyRun = false; //if this case is excluded from the daily functional run
        public bool             IsRetryable         = true; //if this case can be retried automatically after a failure
        public System.Type      ExpectedException   = null;
        public object           []MyValues           = null; //this is the value assigned to an instance of a test that was generated by a compound test

        // This will be used if TestResult = PASSED | FAILED for stress tests. It has to go
        // here because StressTestBase and MinimumStressTestBase need it.
        // You may set it once per derived class type. Then consider it read-only.
        public int CasesExecuted = 1;

        public object Clone()
        {
            //all values and referances are copied by default
            MinimumTestBase copy=(MinimumTestBase)MemberwiseClone();            

            //Things explicitely duplicated go here
            copy.Name = (string)Name.Clone(); //needed for CompoundCase

            //
            return copy;
        }

        public string FullName
        {
            get
            {
                if (Parent == null)
                    return Name;
                return Parent.Name+"."+Name;
            }
        }

        public object MyValue
        {
            get
            {
                if (MyValues==null || MyValues.Length==0) return null;
                else return MyValues[0];
            }
        }
        
        public MinimumTestBase()
        {
            Name = GetType().Name;
        }

        public MinimumTestBase(string name)
        {
            Name = name;
        }

        abstract public TEST_RESULTS Run();

    }

    public class TestBaseFunction : TestBase
    {
        public delegate void TestCaseDelegate();

        public static void NoOp()
        {
        }

        public TestBaseFunction(TestCaseDelegate testCase, string name)
        {
            m_testCase = testCase;
            Name = name;
        }
                                                         
        protected override void Execute()
        {
            m_testCase();

            ResultCode = TEST_RESULTS.PASSED;
        }

        protected TestCaseDelegate m_testCase;
    }

    
    /// <summary>
    /// This is not multi-thread safe.
    /// </summary>
    abstract public class TestBase : MinimumTestBase
    {
        public long             Started;
        public TEST_RESULTS     ResultCode          = TEST_RESULTS.NOT_EXECUTED;
        public float            TotalExecutionTime  = 0;

        public TestBase()
        {
            Name = GetType().Name;
        }
        public TestBase(string name)
        {
            Name = name;
        }

        abstract protected void Execute();    
        
        public float Elapsed
        {
            get
            {
                long ElapsedTicks=DateTime.Now.Ticks-Started;
                return ElapsedTicks*0.0000001f;
            }
        }

        public override TEST_RESULTS Run()
        {
            Started = DateTime.Now.Ticks;
            ResultCode = TEST_RESULTS.FAILED;

            try
            {
                Execute();
            }
            finally 
            {
                TotalExecutionTime = Elapsed;
            }

            return ResultCode;
        }

        static protected void Check(bool f)
        {
            if (!f)
                throw new UnexpectedTestResultException();
        }

        static protected void Check(bool f, string msg)
        {
            if (!f)
                throw new UnexpectedTestResultException(msg);
        }

        public void Info(string Msg)
        {
            ConsoleX.ClearLine();
            ConsoleX.WriteLine("Info :"+ Msg);
        }

        static public  void LogWarning(string Msg)
        {
            ConsoleX.WriteLine("Warn :"+ Msg);
            
        }
    }

    /// <summary>
    /// This is a test case that will generate multiple TestBase instances to represent it.
    /// </summary>
    // We inherit from TestBase so that we have an "instance" from which we can generate others.
    public abstract class CompoundTestBase: TestBase
    {
        private const string INSTANCE_DELIMINATOR = " ";

        public CompoundTestBase()
            : base()
        {
        }

        public CompoundTestBase(string name)
            : base(name)
        {
        }

        //This can optionally be implemented to manually tweak how instances are generated.
        //It is passed the list of instances that were specified from attributes.  You can then add or remove from this list.
        protected virtual void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
        {
        }

        //Generate a TestBase for every instance the test represents.
        public TestBase[] GenerateTestInstances()
        {
            //ask them to update the list if we haven't yet
            lock (testCaseInstances)
            {
                if (!hasUpdatedInstances)
                {
                    hasUpdatedInstances=true;
                    EditInstances(ref testCaseInstances);

                    //resolve duplicate names
                    foreach (CompoundCaseAttribute cc1 in testCaseInstances)
                    {
                        int dupeNum=0;
                        foreach (CompoundCaseAttribute cc2 in testCaseInstances)
                        {
                            if (cc1==cc2) continue;

                            if (cc1.Name==cc2.Name)
                            {
                                CoreGlobal.RO.Warn("Compound Test " + Name + " has a duplicate instance name: " + cc1.Name + ".  The duplicate has been renamed.");
                                cc2.Name+=INSTANCE_DELIMINATOR + ++dupeNum;
                            }
                        }
                    }
                }
            }

            //generate
            if (testCaseInstances.Count==0)
            {
                TestBase newTB=(TestBase)this.Clone();
                newTB=(TestBase)this.Clone();
                return new TestBase[]{ newTB };
            }

            TestBase []tbList=new TestBase[testCaseInstances.Count];
            int tbNum=0;
            foreach (CompoundCaseAttribute cc in testCaseInstances)
            {
                tbList[tbNum]=(TestBase)this.Clone();
                tbList[tbNum].Name=Name + INSTANCE_DELIMINATOR + cc.Name;
                tbList[tbNum].MyValues=cc.Values;
                ++tbNum;
            }

            return tbList;
        }

        //
        bool hasUpdatedInstances=false;
        private System.Collections.Generic.List<CompoundCaseAttribute> testCaseInstances=new System.Collections.Generic.List<CompoundCaseAttribute>();
        
        //should only be called by TestBaseGroup - adds an instance to the instance list during contruction
        internal void TestBaseGroup_AddInstance(CompoundCaseAttribute instance)
        {
            testCaseInstances.Add(instance);

            if (hasUpdatedInstances) //should never happen, just here for sanity
            {
                CoreGlobal.RO.Warn("Instance added to a CompoundTest '" + Name + "' after the instances were already instantiated.  The new instance won't be used.");
            }
        }
    };
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\StressTestBase.cs ===
using System.Data.SqlClient;
using System.Data.Common;
using System.Text;
using System;
using System.IO;
using System.Threading;
using System.Net;
using System.Reflection;
using System.Collections.Generic;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{

    // The class hierarchy here needs to be cleaned up, but it will likely require
    // breaking changes. At this point (middle of of M5), that is unacceptable, so 
    // this is what we have to live with for now.  


    /// <summary>
    /// This is multi-thread safe.  Classes that implement this will only be
    /// instantiated once during a stress run.
    /// </summary>
    public abstract class MinimumStressTestBase : MinimumTestBase
    {
        // Your test should implement:
        // abstract public TEST_RESULTS Run();	
    }
    
    /// <summary>
    /// This is not multi-thread safe.  Due to legacy code, StressTestBase needs to derive
    /// from TestBase.
    /// </summary>
    public abstract class StressTestBase : TestBase
    {
        // This will be used if TestResult = COMPOSITE
        public int CasesPassedComposite=0;
        public int CasesFailedComposite=0;

        public int Successes {get {return CasesExecuted;}}


    }

    public abstract class DynamicStressTestBase : StressTestBase
    {
        public string testName=null;

        public abstract void Initialize (string testName);
		
    }

    /// <summary>
    /// This adapts a functional test to a stress test.
    /// </summary>
    public abstract class FuncToStressAdapter: StressTestBase
    {
        protected TestBase TestCase;

        public FuncToStressAdapter(TestBase testCase)
        {
            TestCase=testCase;
        }

        public virtual void PreRun()
        {
        }

        public virtual void PostRun()
        {
        }

        protected override sealed void Execute()
        {
            try
            {
                PreRun();
            }
            finally
            {
                try
                {
                    TestCase.Run();
                }
                finally
                {
                    ResultCode=TestCase.ResultCode;
                    PostRun();
                }
            }
        }
    }

    /// <summary>
    /// A stress base for doing asynchronous tests.  Derived classes must implement their Begin function
    /// in a thread safe manner, as only one actual object will ever be created.
    /// The Run function allows the async tests to run synchronously if the scheduler does not
    /// have support for async tests.
    /// </summary>
    public abstract class AsyncStressTestBase : MinimumStressTestBase
    {
        /// <summary>
        /// An object that may be useful for debugging and will be used for running synchronously.
        /// </summary>
        public class AsyncStressTracking
        {
            public long ID = 0;
            public ManualResetEvent WaitEvent = null;
            public TEST_RESULTS Result = TEST_RESULTS.NOT_EXECUTED;
            public object ExternalState = null;

            /// <summary>
            /// The ID value position, each tracker gets its own number until we wrap.
            /// </summary>
            protected static long IDVal = 0;

            public AsyncStressTracking ()
            {
                ID = Interlocked.Increment(ref IDVal);
            }

            public AsyncStressTracking (object state)
            {
                ID = Interlocked.Increment(ref IDVal);
                ExternalState = state;
            }
        }

        #region Sync Functions

        /// <summary>
        /// The maximum time to wait when running synchronously.
        /// </summary>
        public static int MaximumWaitTimeMilliseconds = 110000;

        /// <summary>
        /// The Run function allows the async tests to run synchronously if the scheduler does not
        /// have support for async tests.
        /// </summary>
        /// <returns>The result of running the test.</returns>
        public sealed override TEST_RESULTS Run ()
        {
            AsyncStressTracking tracker = new AsyncStressTracking();
            tracker.WaitEvent = GetWaitEvent();

            Begin(tracker);

            tracker.WaitEvent.WaitOne(MaximumWaitTimeMilliseconds, false);
            ReleaseWaitEvent(tracker.WaitEvent);

            return tracker.Result;
        }

        /// <summary>
        /// The queue of ManualResetEvents to be used when running synchronously.
        /// </summary>
        private Queue<ManualResetEvent> WaitEventQ = new Queue<ManualResetEvent>();

        /// <summary>
        /// Gets a ManualResetEvent from the queue, or creates one if it is empty.
        /// </summary>
        /// <returns>A ManualResetEvent.</returns>
        private ManualResetEvent GetWaitEvent ()
        {
            lock (WaitEventQ)
            {
                if (WaitEventQ.Count == 0)
                {
                    return new ManualResetEvent(false);
                }
                else
                {
                    ManualResetEvent mre = WaitEventQ.Dequeue();
                    mre.Reset();
                    return mre;
                }
            }
        }

        /// <summary>
        /// Returns a ManualResetEvent to the queue.
        /// </summary>
        /// <param name="mre">The ManualResetEvent to return.</param>
        private void ReleaseWaitEvent (ManualResetEvent mre)
        {
            if (mre == null)
            {
                return;
            }

            lock (WaitEventQ)
            {
                WaitEventQ.Enqueue(mre);
            }
        }

        #endregion

        #region Async Functions

        /// <summary>
        /// The main entry point for external callers that are aware of AsyncStressTestBase.
        /// </summary>
        /// <param name="state">A state object that will be passed back to the external caller.</param>
        public void Begin (object state)
        {
            Begin(new AsyncStressTracking(state));
        }

        /// <summary>
        /// This is the entry point for the test case.  Remember that it must be thread safe.
        /// All tests should call End to report the result of running the test.
        /// </summary>
        /// <param name="tracker">The state object used to track this test run.</param>
        public abstract void Begin (AsyncStressTracking tracker);

        /// <summary>
        /// The delegate type that is used to notify the scheduler of the async test completing.
        /// </summary>
        /// <param name="state">A state object that will be passed back to the external caller.</param>
        /// <param name="result">The result of running the test.</param>
        /// <param name="exc">The exception, if any, that occured.</param>
        public delegate void AsyncCompletion (object state, TEST_RESULTS result, Exception exc);

        /// <summary>
        /// The function that will be called by the test to report its result.
        /// The scheduler should set this value on startup to receive callbacks.
        /// </summary>
        public static AsyncCompletion AsyncFinish = null;

        /// <summary>
        /// Reports the test result given to it.
        /// </summary>
        /// <param name="result">The result of running the test.</param>
        /// <param name="tracker">The state object used to track this test run.</param>
        protected void End (TEST_RESULTS result, AsyncStressTracking tracker)
        {
            End(result, null, tracker);
        }

        /// <summary>
        /// Reports the test as failed with the given exception.
        /// </summary>
        /// <param name="exc">The exception that occured.</param>
        /// <param name="tracker">The state object used to track this test run.</param>
        protected void End (Exception exc, AsyncStressTracking tracker)
        {
            End(TEST_RESULTS.FAILED, exc, tracker);
        }

        /// <summary>
        /// Reports the test result and updates the tracker.
        /// </summary>
        /// <param name="result">The result of running the test.</param>
        /// <param name="exc">The exception that occured.</param>
        /// <param name="tracker">The state object used to track this test run.</param>
        private void End (TEST_RESULTS result, Exception exc, AsyncStressTracking tracker)
        {
            tracker.Result = result;

            if (tracker.WaitEvent != null)
            {
                if (!(tracker.WaitEvent.Set()))
                {
                    CoreGlobal.RO.Error("Could not set the event wait handle for run {0}, that thread will probably be permanently locked.");
                }

                // this means we are in sync mode, so no need to call back to AsyncFinish
                return;
            }

            if (AsyncFinish == null)
            {
                CoreGlobal.RO.Error("No AsyncFinish function is defined, AsynStressTests will not be correctly " +
                    "reporting results.");
            }
            else
            {
                AsyncFinish(tracker.ExternalState, result, exc);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\AttrExcepts.cs ===
using System;
using System.Net;

namespace ServerTestFramework
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple=false, Inherited=false)]
    public class DescriptionAttribute : Attribute
    {
        protected string desc;
        public string Desc
        {
            get {return desc;}
        }

        public DescriptionAttribute(string desc)
        {
            this.desc = desc;
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true)]
    public class TestCaseAttribute : Attribute
    {
        public TestCaseAttribute()
        {
        }
        public TestCaseAttribute(bool catchExceptions)
        {
            CatchExceptions = catchExceptions;
        }
        public TestCaseAttribute(int bugID)
        {
            BugID = bugID;
        }
        public TestCaseAttribute(bool catchExceptions, int bugID)
        {
            CatchExceptions = catchExceptions;
            BugID = bugID;
        }
        public TestCaseAttribute(System.Type expectedException)
        {
            if(!expectedException.IsSubclassOf(typeof(System.Exception)))
            {
                CoreGlobal.RO.Error(expectedException.ToString() + " is not a subclass of System.Exception.");
                ExpectedException = null;
            }
            else
                ExpectedException = expectedException;

            CatchExceptions = true;
        }
        public TestCaseAttribute(System.Type expectedException, int bugID)
        {
            if(!expectedException.IsSubclassOf(typeof(System.Exception)))
            {
                CoreGlobal.RO.Error(expectedException.ToString() + " is not a subclass of System.Exception.");
                ExpectedException = null;
            }
            else
                ExpectedException = expectedException;

            CatchExceptions = true;
            BugID = bugID;
        }
        public bool CatchExceptions = true;
        public int BugID = 0;
        public System.Type ExpectedException = null;
    }

    /// <summary>
    /// allow an alias for Attribute "[TestCase]" to be "[Test]", like NUnit
    /// </summary> 
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true)]
    public class TestAttribute : TestCaseAttribute
    {
    }

    /// <summary>
    /// marks a function as a setup method.  These methods are executed
    /// just before a set of tests are run.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Method)]
    public class TestGroupSetupAttribute : Attribute
    {
    }

    /// <summary>
    /// marks a function as an tear-down method.  These methods are executed
    /// just after a set of tests are run.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Method)]
    public class TestGroupTearDownAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class TestGroupAttribute : Attribute
    {
        public string ComponentArea = "";
    }

    /// <summary>
    /// allow an alias for Attribute "[TestGroup]" to be "[TestFixture]", like NUnit
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class TestFixtureAttribute : TestGroupAttribute
    {
    }

    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class StressTestAttribute : Attribute
    {
        public float TargetTPS = 0;
        public float Priority = 0;
        public bool CatchExceptions = true;
        public bool Counters = false;

        public StressTestAttribute()
        {
        }

        public StressTestAttribute(float priority)
        {
            this.Priority = priority;
        }

        public StressTestAttribute(float priority, bool usePerfCounters)
        {
            this.Priority = priority;
            this.Counters = usePerfCounters;
        }

        public StressTestAttribute(bool usePerfCounters)
        {
            this.Counters = usePerfCounters;
        }
    }

    /// <summary>
    /// This feature should be used to temporarily not run a TestCase or TestGroup. 
    /// This is a better mechanism than commenting out the testCase/testGroup,
    /// since the tests will be compiled with the rest of the code and there is an 
    /// indication at run time that a test is not being run. This insures that tests will not be forgotten.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=true)]
    public class IgnoreAttribute : Attribute
    {
        public IgnoreAttribute()
        {
        }

        public IgnoreAttribute(string desc)
        {
        }
    }
    /// <summary>
    /// This attribute can be applied to TestGroup or TestCase
    /// it stands for "Developer Verfication Test"
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class DVTAttribute : Attribute
    {
        public DVTAttribute()
        {
        }
    }

    /// <summary>
    /// On a test case, tests with the same AsyncGroup value can run at the same time.  On a group this sets the default AsyncGroup value for all tests in that group.
    /// Test groups with the same AsyncSet value can be run at the same time. (AsyncSet has no meaning for a test case)
    /// A value of 0 means don't run async.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true, AllowMultiple=false)]
    public class AsyncGroupAttribute: Attribute
    {
        //parallel groups        
        protected uint asyncSet;
        public uint AsyncSet { get {return asyncSet;} }

        //parallel test cases within a group
        protected uint asyncGroup;
        public uint AsyncGroup { get {return asyncGroup;} }

        //
        public AsyncGroupAttribute(uint group)
        {
            asyncGroup=group;
        }
        public AsyncGroupAttribute(uint group, uint set)
        {
            asyncGroup=group;
            asyncSet=set;
        }
    };

    /// <summary>
    /// Attribute for a test group for how many threads within the group are allowed to run at the same time.
    /// Default is 8.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public class AsyncThreadCountAttribute: Attribute
    {
        protected uint threadCount;
        public uint ThreadCount { get {return threadCount;} }

        public AsyncThreadCountAttribute(uint tcount)
        {
            threadCount=tcount;
        }
    };

    /// <summary>
    /// Attribute for a test group.  Controls the delay (in ms) between thread creations for tests within the group.
    /// This can be useful for preventing a ton of tests from slamming the network system at the exact same moment.
    /// Default is 25ms.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public class AsyncThreadDelayAttribute: Attribute
    {
        protected uint threadDelay;
        public uint ThreadDelay { get {return threadDelay;} }

        public AsyncThreadDelayAttribute(uint tdelay)
        {
            threadDelay=tdelay;
        }
    };

    /// <summary>
    /// Attribute for groups and cases.  This specifies that the test case or group should be excluded from the automatic daily functional run.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=true, AllowMultiple=false)]
    public class DoNotRunDailyAttribute: Attribute
    {
    };

    /// <summary>
    /// Attribute for groups and cases.  This specifies that the test case should never be automatically retried if it fails.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=true, AllowMultiple=false)]
    public class DoNotRetryAttribute: Attribute
    {
    };

    /// <summary>
    /// Attribute for groups and cases.  Each instance of CompoundTestBase class that use this will cause multiple instances of TestBase's to be created.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=true)]
    public class CompoundCaseAttribute: Attribute
    {
        public string Name;
        public object []Values;

        public CompoundCaseAttribute(string name, params object []values)
        {
            Name=name;
            Values=values;
        }
    };

    //
    public class UnexpectedTestResultException : Exception
    {
        public UnexpectedTestResultException() : base() {}
        public UnexpectedTestResultException(string message) : base(message) {}
        public UnexpectedTestResultException(string message, Exception inner) : base(message, inner) {}
    }

    public class HarnessException : Exception
    {
        public HarnessException() : base() {}
        public HarnessException(string message) : base(message) {}
        public HarnessException(string message, Exception inner) : base(message, inner) {}
    }

    /// <summary>
    /// Custom Excption class to convey excpetions at the test suite load and run states.
    /// </summary>
    public class TestSuiteException : Exception
    {
        public TestSuiteException( string message) : base(message) {}
        public TestSuiteException( string message, Exception inner) : base(message, inner) {}
    }

    /// <summary>
    /// Custom Exception class to carry and identify failures with an Http Status code
    /// </summary>
    public class HttpStatusCodeException : Exception
    {
        public HttpStatusCode StatusCode; 
        public HttpStatusCodeException( HttpStatusCode code ) : base() { StatusCode = code; }
        public HttpStatusCodeException( HttpStatusCode code, string message) : base(message) { StatusCode = code; }
        public HttpStatusCodeException( HttpStatusCode code, string message, Exception inner) : base(message, inner) { StatusCode = code; }
    }

    /// <summary>
    /// Custom Exception class to identify time out failures
    /// </summary>
    public class TimeOutException : Exception
    {
        public ushort WaitSec; 
        public TimeOutException( ushort waitSec ) : base() { WaitSec = waitSec; }
        public TimeOutException( ushort waitSec, string message) : base(message) { WaitSec = waitSec; }
        public TimeOutException( ushort waitSec, string message, Exception inner) : base(message, inner) { WaitSec = waitSec; }
    }

    /// <summary>
    /// Custom Excption class to carry and identify failures matching a named value.
    /// </summary>
    public class ExpectedValueCheckException : Exception
    {
        public string Name;
        public ExpectedValueCheckException( string name ) : base( "Value Mismatch! "+name ) { Name = name; }
        public ExpectedValueCheckException( string name, string message) : base("Value Mismatch! "+name+": "+message) { Name = name; }
        public ExpectedValueCheckException( string name, string message, Exception inner) : base("Value Mismatch! "+name+": "+message, inner) { Name = name; }
    }

    /// <summary>
    /// Generic exception wrapper, allows parameters in the message string. Think of it as
    /// an Exception++.
    /// </summary>
    public class StfException : Exception
    {
        public StfException(string message) : base(message) 
        { 
            if (CoreGlobal.RO != null)
                CoreGlobal.RO.Error(message); 
        }
        public StfException(string format, params object[] args) : base(String.Format(format, args)) 
        { 
            if (CoreGlobal.RO != null)
                CoreGlobal.RO.Error(format, args); 
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\StressTestBaseList.cs ===
using System;
using System.Collections;

namespace ServerTestFramework
{
    public class StressTestBaseList : CollectionBase, IEnumerable
    {
        public class StressTestBaseItem
        {
            public Type Type;
            public float Priority;
            public float TargetTPS;
            public bool UseCounters;
            public string TestName=null;

            public StressTestBaseItem(Type type)
            {
                this.Type = type;
            }

            public StressTestBaseItem(Type type, float priority) : this(type)
            {
                this.Priority = priority;
            }

            public StressTestBaseItem(Type type, float priority, string testname) : this(type)
            {
                this.Priority = priority;
                TestName = testname;
            }

            public StressTestBaseItem(Type type, float priority, string testname, bool useCounters) : this(type)
            {
                this.Priority = priority;
                this.UseCounters = useCounters;
                TestName = testname;
            }

            public StressTestBaseItem(Type type, float priority, float targetTPS, string testname, bool useCounters) : this(type)
            {
                this.Priority = priority;
                this.TargetTPS = targetTPS;
                this.UseCounters = useCounters;
                TestName = testname;
            }
        }

        public void Add(Type type, string testname) { Add(type, 0, testname); }
        public void Add(Type type) { Add(type, 0); }
        public void Add(Type type, float defaultPriority) { this.AddItem(type, defaultPriority, 0, null, false); }
        public void Add(Type type, float defaultPriority, bool useCounters) { this.AddItem(type, defaultPriority, 0, null, useCounters); }
        public void Add(Type type, float defaultPriority, string testname) { this.AddItem(type, defaultPriority, 0, testname, false); }
        public void Add(Type type, float defaultPriority, float defaultTPS, bool useCounters) { this.AddItem(type, defaultPriority, defaultTPS, null, useCounters); }
        public void Add(Type type, float defaultPriority, float defaultTPS, string testname) { this.AddItem(type, defaultPriority, defaultTPS, testname, false); }

        private void AddItem(Type type, float defaultPriority, float defaultTPS, string testname, bool useCounters)
        {
            if (!type.IsSubclassOf(typeof(MinimumTestBase)))
                throw new ArgumentException("Stress tests must derive from MinimumTestBase");

            List.Add(new StressTestBaseItem(type, defaultPriority, defaultTPS, testname, useCounters));
        }


        // These methods allow identical syntax to be used for stress and functional tests
        public void Add(TestBase tb) {Add(tb.GetType());}
        public void Add(TestBase tb, int defaultPriority) {Add(tb.GetType(), defaultPriority);}

        public Type this[int index]
        {
            get {return (Type) List[index];}
            set {List[index] = value;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\TestSequenceBase.cs ===
using System;
using System.Collections;
using System.Net;
using System.Threading;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    /// <summary>
    /// Common Action State keeps track of the number of tests requesting this action
    /// </summary>
    public class TestSequenceCommonActionState
    {
        private static bool _sRunning = true;
        private int _count;
        private ArrayList _waiters = new ArrayList();

        public TestSequenceCommonActionState()
        {
            _count = 1;
        }

        public void AddRef()
        {
            lock (_waiters.SyncRoot)
            {
                Interlocked.Increment(ref _count);
            }
        }

        private void InjectException(TestSequenceAsyncResult tasyr, Exception ex)
        {
            // inject the exception into each case expecting this action
            TestSequenceBase test = tasyr.AsyncState as TestSequenceBase;
            test.FailureException = ex;
            test.ResultCode = TEST_RESULTS.FAILED;
        }

        public void Release(TestSequenceAsyncResult asy, TestSequenceCommonAction action, bool ExecuteAction)
        {
            lock (_waiters.SyncRoot)
            {
                int remainingRequests = Interlocked.Decrement(ref _count);
                if (remainingRequests == 0)
                {
                    Exception _ex = null;
                    try
                    {
                        if ((_waiters.Count > 0 || ExecuteAction) && _sRunning)
                        {
                            action.Action();
                        }
                    }
                    catch (Exception ex)
                    {
                        // Dispose wont have an async result
                        if (asy != null)
                        {
                            InjectException(asy, ex);
                        }
                        _ex = ex;
                    }
                    foreach (TestSequenceAsyncResult tasyr in _waiters)
                    {
                        if (_ex != null)
                        {
                            InjectException(tasyr, _ex);
                        }
                        tasyr.Complete();
                    }
                    _waiters.Clear();
                }
                else if(asy != null)
                {
                    asy.IsCompleted = false;
                    _waiters.Add(asy);
                }
            }
        }

        public static bool Running
        {
            get
            {
                return _sRunning;
            }
            set
            {
                _sRunning = value;
            }
        }
    }

    /// <summary>
    /// Common Action requestable by a test sequence.
    /// </summary>
    public abstract class TestSequenceCommonAction : IDisposable
    {
        private TestSequenceCommonActionState _state;
        private int _fCompleted;
        
        public TestSequenceCommonAction()
        {
            _fCompleted = 0;
            _state = TestSequenceCommonActionsTable.RequestCommonActionState(this.GetType());
        }

        public void WaitForAction(TestSequenceAsyncResult asy)
        {
            int fCompleted = Interlocked.Exchange(ref _fCompleted, 1);
            if(fCompleted == 0)
            {
                _state.Release(asy, this, true);
            }
        }

        public void Dispose()
        {
            int fCompleted = Interlocked.Exchange(ref _fCompleted, 1);
            if (fCompleted == 0)
            {
                _state.Release(null, this, false);
            }
        }

        public abstract void Action();
    }

    /// <summary>
    /// Table of the states of requested common actions.
    /// </summary>
    public static class TestSequenceCommonActionsTable
    {
        private static Hashtable _sCommonActionsTable = new Hashtable();
        public static TestSequenceCommonActionState RequestCommonActionState(Type t)
        {
            TestSequenceCommonActionState state = null;

            lock (_sCommonActionsTable.SyncRoot)
            {
                if (_sCommonActionsTable.Contains(t))
                {
                    state = _sCommonActionsTable[t] as TestSequenceCommonActionState;
                    state.AddRef();
                }
                else
                {
                    state = new TestSequenceCommonActionState();
                    _sCommonActionsTable.Add(t, state);
                }
            }
            return state;
        }

        public static void Init()
        {
            lock (_sCommonActionsTable)
            {
                _sCommonActionsTable.Clear();
            }
        }
    }


    /// <summary>
    /// This class of test is executed by a TestSequenceBaseGroup.
    /// </summary>
    public class TestSequenceBase : TestBase, IDisposable
    {
        TestSequenceBaseGroup ParentGroup;
        private Exception _FailureException = null;

        public TestSequenceBase() : base() { }

        ~TestSequenceBase()
        {
            Dispose(false);
        }

        public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

        public sealed override TEST_RESULTS Run()
        {
            Started = DateTime.Now.Ticks;
            ResultCode = TEST_RESULTS.IN_PROGRESS;
            _FailureException = null;
            // the Parent class manages the running of this test
            ParentGroup = (TestSequenceBaseGroup)Parent;
            ParentGroup.RunTest(this);
            return TEST_RESULTS.IN_PROGRESS;
        }

        public Exception FailureException
        {
            get
            {
                return _FailureException;
            }
            set
            {
                if (_FailureException == null)
                {
                    _FailureException = value;
                }
            }
        }

        protected sealed override void Execute() 
        {
        }

        public void Complete()
        {
            TotalExecutionTime = Elapsed;
            Dispose(true);
        }

        // User Defined Methods
        public virtual void Initialize() {}

        public virtual void DoNextStep(TestSequenceAsyncResult asy)
        {
            ResultCode = TEST_RESULTS.NOT_EXECUTED;
        }

        protected virtual void Dispose(bool fDisposing)
        {
        }
    }
    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\TestSequenceBaseGroup.cs ===
using System;
using System.Collections;
using System.Reflection;
using System.Threading;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    /// <summary>
    /// Group of TestSequenceBases.  This class handles their async execution flow.
    /// </summary>
    public class TestSequenceBaseGroup : TestBaseGroup
    {
        private ArrayList Running = new ArrayList();
        private AutoResetEvent are = new AutoResetEvent(false);
        private bool _CancelRun = false;

        public TestSequenceBaseGroup() : base() {}
        public TestSequenceBaseGroup(string groupName) : base(groupName){}

        public sealed override void Initialize()
        {
            _CancelRun = false;
            are.Reset();
            base.Initialize();
            foreach (TestSequenceBase tsb in List)
            {
                if (tsb.Enabled)
                {
                    tsb.Initialize();
                }
            }
        }

        public void TerminteTests()
        {
            _CancelRun = true;
        }

        public void WaitForTests()
        {
            if (Running.Count > 0)
            {
                are.WaitOne();
            }
        }

        public void RunTest(TestSequenceBase test)
        {
            Running.Add(test);
            ExecuteTestStep(test);
        }

        private void ExecuteTestStep(object state)
        {
            TestSequenceBase test = state as TestSequenceBase;
            IAsyncResult asy = BeginExecuteTestStep(test);
            if (asy.CompletedSynchronously)
            {
                EndExecuteTestStep(asy);
            }
        }

        private IAsyncResult BeginExecuteTestStep(TestSequenceBase test)
        {
            TestSequenceAsyncResult asy = null;
            try
            {
                asy = new TestSequenceAsyncResult(test, new AsyncCallback(EndExecuteTestStep));
                test.DoNextStep(asy);
            }
            catch(Exception ex)
            {
                test.FailureException = ex;
                test.ResultCode = TEST_RESULTS.FAILED;
            }
            return asy;
        }

        private void EndExecuteTestStep(IAsyncResult asy)
        {
            TestSequenceBase tsb = asy.AsyncState as TestSequenceBase;
            if (_CancelRun)
            {
                tsb.ResultCode = TEST_RESULTS.NOT_EXECUTED;
            }

            if (tsb.ResultCode == TEST_RESULTS.IN_PROGRESS)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(ExecuteTestStep), tsb);
            }
            else
            {
                tsb.Complete();
                Running.Remove(tsb);
                if (Running.Count == 0)
                {
                    are.Set();
                }
            }
        }
    }

    /// <summary>
    /// Async Result of a step executed on a Test Sequence.
    /// </summary>
    public class TestSequenceAsyncResult :
        IAsyncResult
    {
        public TestSequenceAsyncResult(object ck, AsyncCallback asyncCallback)
        {
            this._ck = ck;
            // assume it will complete synchronously unless otherwise stated
            this._fComplete = true;
            this._asyncCallback = asyncCallback;
        }

        public object AsyncState
        {
            get
            {
                return _ck;
            }
        }

        // not used
        public WaitHandle AsyncWaitHandle
        {
            get
            {
                return null;
            }
        }

        public bool CompletedSynchronously
        {
            get
            {
                return _fComplete;
            }
        }

        public bool IsCompleted
        {
            get
            {
                return _fComplete;
            }
            set
            {
                _fComplete = value;
            }
        }

        public void Complete()
        {
            if (_asyncCallback != null)
            {
                _asyncCallback(this);
            }
            _fComplete = true;
        }

        private readonly object _ck;
        private bool _fComplete;
        private readonly AsyncCallback _asyncCallback;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\TestBaseGroupList.cs ===
using System;
using System.Collections;
using System.Xml;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
	public class TestBaseGroupList : CollectionBase, IEnumerable
	{
		public void Add(TestBaseGroup t)
		{
			List.Add(t);
		}

		public void Remove(TestBaseGroup t)
		{
			List.Remove(t);
		}

		public TestBaseGroup this[int index]
		{
			get
			{
				return (TestBaseGroup)List[index];
			}
			set
			{
				List[index] = value;
			}
		}

		public void Prune(string suiteName, XmlDocument doc)
		{
			// If there is a suite element in the functional section then all of the suite's tests are enabled
			bool suiteEnabled = doc.SelectSingleNode("/stf/tests/suite[@name='" + suiteName + "']/functional/suite") != null;

			foreach (TestBaseGroup tbg in List)
				foreach (TestBase tb in tbg)
					tb.Enabled = suiteEnabled;

			if (suiteEnabled)
				return;

			XmlNode functionalSection = doc.SelectSingleNode("/stf/tests/suite[@name='" + suiteName + "']/functional");
			if (functionalSection == null)
				return;

			XmlNodeList groups = doc.SelectNodes("/stf/tests/suite[@name='" + suiteName + "']/functional/group");
			foreach (XmlNode groupNode in groups)
			{
				string groupName = groupNode.Attributes["name"].Value;
				string component = groupNode.Attributes["component"] != null ? groupNode.Attributes["component"].Value : null;

				TestBaseGroup group = null;
				foreach (TestBaseGroup tbg in List)
					if (groupName == tbg.Name)
						group = tbg;

				if (group != null)
				{
					foreach (TestBase tb in group)
						tb.Enabled = true;
				}
				else
				{
					// Usually, this exception gets quelched by the runner
					// But I think it's still a good idea to let the user know,
					// hence the WriteLine
					string errorStr="Group "+groupName+", listed in the xml file, cannot be found in the DLL.";
					throw new Exception(errorStr);
				}
			}

			XmlNodeList tests = doc.SelectNodes("/stf/tests/suite[@name='" + suiteName + "']/functional/test");
			foreach (XmlNode testNode in tests)
			{
				string groupName = testNode.Attributes["group"].Value;
				string testName = testNode.Attributes["name"].Value;
				string component = testNode.Attributes["component"] != null ? testNode.Attributes["component"].Value : null;

				TestBaseGroup group = null;
				foreach (TestBaseGroup tbg in List)
					if (tbg.Name == groupName)
						group = tbg;

				TestBase test = null;
				if (group != null)
				{
					foreach (TestBase tb in group)
						if (tb.Name == testName)
							test = tb;
					
					if (test != null)
						test.Enabled = true;
					else
						throw new Exception("Test " + groupName + "." + testName + " not found in xml file.");
				}
				else
				{
					throw new Exception("Group " + groupName + " not found in xml file.");
				}
			}
		}

        // Copies special attributes (async settings, etc) from another group list to this one
        public void CopyAttributesFrom(TestBaseGroupList other)
        {
            foreach (TestBaseGroup me in this)
            {
                foreach (TestBaseGroup you in other)
                {
                    if (me.Name == you.Name)
                    {
                        me.CopyAttributesFrom(you);
                        break;
                    }
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\UnitTest.cs ===
using System;
using System.Diagnostics;

namespace ServerTestFramework
{
	/// <summary>
	/// Base class for simple UnitTests.
    /// This is old, please use TestBase.
	/// </summary>
	public abstract class UnitTest
	{
		/// <summary>
		/// Implement this to be a unit test.
		/// </summary>
		abstract public void RunTest();

		/// <summary>
		/// Returns the name of the unit test.
		/// </summary>
		public string Name
		{
			get
			{
                CoreGlobal.RO.Warn("UnitTest is deprecated.  Please switch to using TestBase.");
				return GetType().Name;
			}
		}

		/// <summary>
		/// Utility function to break nicely in either Debug or Free builds.
		/// </summary>
		/// <param name="b"></param>
		protected void Verify(bool b)
		{
			Debug.Assert(b, "Unit test verify failed.");
			if (!b)
				throw new Exception("Verify failed.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\ThreadBase.cs ===
using System;
using System.Threading;

namespace ServerTestFramework
{
    /// <summary>
    /// Utility function to just create a System.Thread (this internally updates the thread tracker automatically).
    /// (You must still call .Start() on it like normal)
    /// </summary>
    public class ThreadMaker
    {
        // -- Public

        public delegate void EmptyThreadProcDelegate();
        public delegate void ObjectThreadProcDelegate(object obj);

        //creates a thread with a proc that takes no parameters
        public static System.Threading.Thread CreateThread(EmptyThreadProcDelegate threadProc)
        {
            ThreadProc info=new ThreadProc();
            ThreadTracker.GetTest(out info.suiteName, out info.groupName, out info.caseName);
            info.isObject=false;
            info.proc=threadProc;
            return new Thread(new ThreadStart(info.Proc));
        }

        //creates a thread with a proc that takes an object as a parameter
        public static System.Threading.Thread CreateThread(ObjectThreadProcDelegate threadProc, object obj)
        {
            ThreadProc info=new ThreadProc();
            ThreadTracker.GetTest(out info.suiteName, out info.groupName, out info.caseName);
            info.isObject=true;
            info.param=obj;
            info.proc=threadProc;
            return new Thread(new ThreadStart(info.Proc));
        }
        
        // -- Internal

        //local info for the thread, and it's real proc
        private class ThreadProc
        {
            public bool isObject;
            public object proc;
            public object param;

            public string suiteName,groupName,caseName;

            public void Proc()
            {
                ThreadTracker.SetTest(suiteName, groupName, caseName);

                try
                {
                    if (isObject)
                    {
                        (proc as ObjectThreadProcDelegate)(param);
                    }
                    else
                    {
                        (proc as EmptyThreadProcDelegate)();
                    }
                }
                catch (System.Threading.ThreadAbortException) //from user calling Abort, this is ok
                {
                }
                catch (Exception e) //any other exception is not expected
                {
                    CoreGlobal.RO.Error("ThreadMaker thread crash:\n"+e.Message+"\n"+e.StackTrace);
                }
            }
        };
    };


    /// <summary>
    /// Represents a class with a worker thread (this internally updates the thread tracker automatically).
    /// </summary>
    public abstract class ThreadBase
    {
        //implement this:
        protected abstract void ThreadBody();

        //
        public Thread TaskThread=null;

        //Starts the worker thread.  If it was already running, this request is ignored.
        public virtual void Go()
        {
            if (TaskThread==null || TaskThread.IsAlive==false)
            {
                TaskThread=new Thread(new ThreadStart(TaskThreadStarter));
                ThreadTracker.GetTest(out myTestSuite,out myTestGroup,out myTestCase);
                TaskThread.Start();
            }
        }

        //Stops the worker thread (raises an abort exception in it)
        public virtual void Stop()
        {
            if (TaskThread != null)
                TaskThread.Abort();
            TaskThread=null;
        }

        //Blocks and waits for the thread to finish running.
        public virtual void Join()
        {
            if (TaskThread != null)
            {
                TaskThread.Join();
            }
            TaskThread=null;
        }

        //return whether the thread is still running.
        public bool IsAlive
        {
            get
            {
                if (TaskThread==null)
                    return false;
                return TaskThread.IsAlive;
            }
        }

        //which test report I belong to
        private string myTestSuite, myTestGroup, myTestCase;

        //used internally to call the user thread procedure
        private void TaskThreadStarter()
        {
            //set this thread's output to the correct test case name
            ThreadTracker.SetTest(myTestSuite,myTestGroup,myTestCase);

            //run it
            try
            {
                ThreadBody();
            }
            catch (System.Threading.ThreadAbortException) //from user calling Abort, this is ok
            {
            }
            catch (Exception e) //any other exception is not expected
            {
                CoreGlobal.RO.Error("ThreadBase worker thread crash:\n"+e.Message+"\n"+e.StackTrace);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\TestBaseGroup.cs ===
using System;
using System.Collections;
using System.Reflection;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    public abstract class TestBaseGroup : CollectionBase, IEnumerable
    {
        protected string name;
        protected uint asyncThreadCount=16; //max number of threads that can run within this group
        protected uint asyncThreadDelay=25; //delay between thread creations in this group
        protected uint defaultAsyncGroup=0; //default asyncGroup value for tests within this group
        protected uint asyncSet=0; //which asyncSet this group belongs to (for running different groups in parallel)
        protected bool isExcludedFromDailyRun=false; //is this group excluded from the daily functional run
        protected bool isRetryable=true; //whether this groups group setup as well as test cases with it, can be retried on a failure.

        public int RunGroupIndex=-1; //index of the group used when running the test
        public Exception SetupException=null;

        public delegate void TestGroupSetupDelegate();
        public ArrayList TestGroupSetupMethods = new ArrayList();
        
        public delegate void TestGroupTearDownDelegate();
        public ArrayList TestGroupTearDownMethods = new ArrayList();

        // The name of this test group
        public string Name 
        {
            get {return name;}
            set {name = value;}
        }

        public uint AsyncThreadCount
        {
            get {return asyncThreadCount;} 
            set {asyncThreadCount=value;}
        }

        public uint AsyncThreadDelay
        {
            get {return asyncThreadDelay;} 
            set {asyncThreadDelay=value;}
        }

        public uint DefaultAsyncGroup
        {
            get {return defaultAsyncGroup;} 
            set {defaultAsyncGroup=value;}
        }

        public uint AsyncSet
        {
            get {return asyncSet;} 
            set {asyncSet=value;}
        }

        public bool IsExcludedFromDailyRun
        {
            get {return isExcludedFromDailyRun;}
            set {isExcludedFromDailyRun=value;}
        }

        public bool IsRetryable
        {
            get {return isRetryable;}
            set {isRetryable=value;}
        }

        public bool Ignore = false;
        public bool IsDvt = false;

        /// <summary>
        /// Construct a new TestBaseGroup using the type's name and an Xbox client
        /// </summary>
        public TestBaseGroup() : this(null)
        {
        }

        /// <summary>
        /// Construct a new TestBaseGroup with a custom name and an Xbox client
        /// </summary>
        /// <param name="groupName"></param>
        public TestBaseGroup(string groupName)
        {
            try
            {
                if (groupName == null)
                {
                    groupName = GetType().Name;
                }
                Name = groupName;

                System.Collections.Generic.List<CompoundCaseAttribute> groupCompoundCases = new System.Collections.Generic.List<CompoundCaseAttribute>();

                {
                    //check for [Dvt] and [Ignore] attributes (on group)
                    IsDvt = null != (DVTAttribute)Attribute.GetCustomAttribute(GetType(), typeof(DVTAttribute));
                    Ignore = null != (IgnoreAttribute)Attribute.GetCustomAttribute(GetType(), typeof(IgnoreAttribute));

                    //check for [AsyncThreadCount] (on group class)
                    AsyncThreadCountAttribute tcA=(AsyncThreadCountAttribute)Attribute.GetCustomAttribute(GetType(), typeof(AsyncThreadCountAttribute));
                    if (tcA!=null)
                    {
                        uint atc=tcA.ThreadCount;
                        if (atc<1)
                        {
                            CoreGlobal.RO.Warn("A group's AsyncThreadCount cannot be less than 1. (class name: "+GetType().Name+")");
                            atc=1;
                        }
                        AsyncThreadCount=atc;
                    }

                    //check for [AsyncThreadDelay] (on group class)
                    AsyncThreadDelayAttribute tdA=(AsyncThreadDelayAttribute)Attribute.GetCustomAttribute(GetType(), typeof(AsyncThreadDelayAttribute));
                    if (tdA!=null)
                    {
                        AsyncThreadDelay=tdA.ThreadDelay;
                    }

                    //check for [AsyncGroup] (on group class)
                    AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(GetType(), typeof(AsyncGroupAttribute));
                    if (asyncGroupA!=null)
                    {
                        DefaultAsyncGroup=asyncGroupA.AsyncGroup;
                        AsyncSet=asyncGroupA.AsyncSet;
                    }

                    //check for [DoNotRunDaily] (on group class)
                    IsExcludedFromDailyRun = null != (DoNotRunDailyAttribute)Attribute.GetCustomAttribute(GetType(), typeof(DoNotRunDailyAttribute));

                    //check for [DoNotRetry] (on group class)
                    if (null != (DoNotRetryAttribute)Attribute.GetCustomAttribute(GetType(), typeof(DoNotRetryAttribute)))
                    {
                        IsRetryable = false;
                    }

                    //check for [CompoundCase] on group
                    Attribute[] attList=Attribute.GetCustomAttributes(GetType(), typeof(CompoundCaseAttribute));
                    if (attList!=null && attList.Length!=0)
                    {
                        foreach (Attribute att in attList)
                        {
                            groupCompoundCases.Add((CompoundCaseAttribute)att);
                        }
                    }
                }

                // look for inner classes declared within the TestBaseGroup, turning them into test cases as appropriate
                foreach (Type inner in GetType().GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public))
                {
                    TestCaseAttribute testCaseAttr = (TestCaseAttribute)Attribute.GetCustomAttribute(inner, typeof(TestCaseAttribute));

                    if (testCaseAttr != null)
                    {
                        ConstructorInfo testDefaultConstructor = inner.GetConstructor(Type.EmptyTypes);
                        if (testDefaultConstructor == null)
                        {
                            CoreGlobal.RO.Warn("Test case does not have a default constructor, so it will be ignored: " + inner.FullName);
                            continue;
                        }

                        TestBase instance = testDefaultConstructor.Invoke(null) as TestBase;
                        if (instance==null)
                        {
                            CoreGlobal.RO.Warn("Test case is not derived from TestBase, so it will be ignored: "+inner.FullName);
                            continue;
                        }

                        instance.BugId = testCaseAttr.BugID;

                        //[Description] (on test case)
                        DescriptionAttribute da = (DescriptionAttribute)Attribute.GetCustomAttribute(inner, typeof(DescriptionAttribute));
                        instance.Desc = da == null ? null : da.Desc;

                        //[Ignore] (on test case)
                        IgnoreAttribute ia = (IgnoreAttribute)Attribute.GetCustomAttribute(inner, typeof(IgnoreAttribute));
                        instance.Ignore = (ia != null);
                        if (Ignore) instance.Ignore=true;
                        
                        //[Dvt] (on test case)
                        DVTAttribute dvt = (DVTAttribute)Attribute.GetCustomAttribute(inner, typeof(DVTAttribute));
                        instance.IsDvt = IsDvt || (dvt != null);

                        //[AsyncGroup] (on test case)
                        AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(inner, typeof(AsyncGroupAttribute));
                        if (asyncGroupA!=null)
                        {
                            instance.AsyncGroup=asyncGroupA.AsyncGroup;
                        }
                        else //default to group value
                        {
                            instance.AsyncGroup=DefaultAsyncGroup;
                        }

                        //[DoNotRunDaily] (on test case)
                        instance.IsExcludedFromDailyRun = null!=(DoNotRunDailyAttribute)Attribute.GetCustomAttribute(inner, typeof(DoNotRunDailyAttribute));
                        instance.IsExcludedFromDailyRun = instance.IsExcludedFromDailyRun || IsExcludedFromDailyRun; //inherit from group

                        //[DoNotRetry] (on test case)
                        if (!IsRetryable || //inherit from group
                            null!=(DoNotRetryAttribute)Attribute.GetCustomAttribute(inner, typeof(DoNotRetryAttribute)))
                        {
                            instance.IsRetryable = false;
                        }

                        //[CompoundCase] on test case
                        Attribute[] attList=Attribute.GetCustomAttributes(inner, typeof(CompoundCaseAttribute));
                        if (instance is CompoundTestBase)
                        {
                            CompoundTestBase ctb=(CompoundTestBase)instance;
                            if (groupCompoundCases.Count!=0)
                            {
                                foreach (CompoundCaseAttribute instAttr in groupCompoundCases)
                                {
                                    ctb.TestBaseGroup_AddInstance(instAttr);
                                }
                            }
                            if (attList!=null && attList.Length!=0)
                            {
                                foreach (Attribute att in attList)
                                {
                                    ctb.TestBaseGroup_AddInstance((CompoundCaseAttribute)att);
                                }
                            }
                        }
                        else //warn if they tried to specify compound stuff on a non-compound test base
                        {
                            if (attList!=null && attList.Length!=0)
                            {
                                CoreGlobal.RO.Warn("TestBase " + instance.Name + " has the CompoundCase attribute specified, but this attribute requires a CompoundTestBase.");
                            }
                            if (groupCompoundCases.Count!=0)
                            {
                                CoreGlobal.RO.Debug("The group " + Name + " has the CompoundCase attribute and contains the test " + instance.Name + " which is not derived from CompoundTestBase.  That case will not have instances made for it.");
                            }
                        }

                        //
                        instance.CatchExceptions = testCaseAttr.CatchExceptions;
                        instance.ExpectedException = testCaseAttr.ExpectedException;

                        //add it
                        if (instance is CompoundTestBase)
                        {
                            Add((CompoundTestBase)instance,instance.AsyncGroup);
                        }
                        else
                        {
                            Add(instance,instance.AsyncGroup);
                        }
                    }
                }

                // look for public functions within the TestBaseGroup, 
                Type testCaseDelegateType = Type.GetType("ServerTestFramework.TestBaseFunction+TestCaseDelegate");
                Type testGroupSetupDelegateType = typeof(TestGroupSetupDelegate);
                Type testGroupTearDownDelegateType = typeof(TestGroupTearDownDelegate);

                foreach (MethodInfo methodInfo in GetType().GetMethods())
                {
                    Attribute attr;

                    // check for [TestCase]
                    attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestCaseAttribute));
                    if (attr != null)
                    {
                        TestBaseFunction.TestCaseDelegate testCaseDelegate = null;

                        if (methodInfo.IsStatic)
                        {
                            testCaseDelegate = (TestBaseFunction.TestCaseDelegate)
                                Delegate.CreateDelegate(testCaseDelegateType, methodInfo);
                        }
                        else
                        {
                            testCaseDelegate = (TestBaseFunction.TestCaseDelegate)
                                Delegate.CreateDelegate(testCaseDelegateType, this, methodInfo);
                        }

                        TestBase instance = new TestBaseFunction(testCaseDelegate, methodInfo.Name);

                        instance.BugId = ((TestCaseAttribute)attr).BugID;

                        //[Description] (on test case)
                        DescriptionAttribute da = (DescriptionAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DescriptionAttribute));
                        instance.Desc = da == null ? null : da.Desc;

                        //[Ignore] (on test case)
                        IgnoreAttribute ia = (IgnoreAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(IgnoreAttribute));
                        instance.Ignore = (ia != null);
                        if (Ignore) instance.Ignore=true;

                        //[Dvt] (on test case)
                        DVTAttribute dvt = (DVTAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DVTAttribute));
                        instance.IsDvt = IsDvt || (dvt != null);

                        //[AsyncGroup] (on test case)
                        AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(AsyncGroupAttribute));
                        if (asyncGroupA!=null)
                        {
                            instance.AsyncGroup=asyncGroupA.AsyncGroup;
                        }
                        else //default to group value
                        {
                            instance.AsyncGroup=DefaultAsyncGroup;
                        }

                        //[DoNotRunDaily] (on test case)
                        instance.IsExcludedFromDailyRun = null!=(DoNotRunDailyAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DoNotRunDailyAttribute));
                        instance.IsExcludedFromDailyRun = instance.IsExcludedFromDailyRun || IsExcludedFromDailyRun; //inherit from group

                        //[DoNotRetry] (on test case)
                        if (!IsRetryable || //inherit from group
                            null!=(DoNotRetryAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DoNotRetryAttribute)))
                        {
                            instance.IsRetryable = false;
                        }

                        //[CompoundCase] on test case
                        Attribute[] attList=Attribute.GetCustomAttributes(methodInfo, typeof(CompoundCaseAttribute));
                        if (attList!=null && attList.Length!=0)
                        {
                            CoreGlobal.RO.Warn("CompoundCase attribute is not valid on " + instance.Name + ", which is a function-declared case.");
                        }

                        //
                        instance.CatchExceptions = ((TestCaseAttribute)attr).CatchExceptions;
                        instance.ExpectedException = ((TestCaseAttribute)attr).ExpectedException;

                        Add(instance,instance.AsyncGroup);
                    }

                    // check for [TestGroupSetup]
                    attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestGroupSetupAttribute));
                    if (attr != null)
                    {
                        if (methodInfo.IsStatic)
                        {
                            TestGroupSetupMethods.Add(Delegate.CreateDelegate(testGroupSetupDelegateType, 
                                methodInfo));
                        }
                        else
                        {
                            TestGroupSetupMethods.Add(Delegate.CreateDelegate(testGroupSetupDelegateType, 
                                this, methodInfo));
                        }
                    }

                    // check for [TestGroupTearDown]
                    attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestGroupTearDownAttribute));
                    if (attr != null)
                    {
                        if (methodInfo.IsStatic)
                        {
                            TestGroupTearDownMethods.Add(Delegate.CreateDelegate(testGroupTearDownDelegateType, 
                                methodInfo));
                        }
                        else
                        {
                            TestGroupTearDownMethods.Add(Delegate.CreateDelegate(testGroupTearDownDelegateType, 
                                this, methodInfo));
                        }
                    }                
                }
            }
            catch(Exception e)
            {
                CoreGlobal.RO.Error("An exception was thrown attempting to create TestBaseGroup!");
                CoreGlobal.RO.Error(e.ToString());
                throw;
            }
            
        }

        public virtual void Initialize()
        {
            foreach (TestGroupSetupDelegate SetupDelegate in TestGroupSetupMethods)
            {
                CoreGlobal.RO.Debug("   Setup ({0}.{1})", Name, SetupDelegate.Method.Name);
                try
                {
                    SetupDelegate();
                }
                catch(Exception ex)
                {
                    CoreGlobal.RO.Error("   Setup ({0}.{1}) Failed: {2}", Name, SetupDelegate.Method.Name, ex.ToString());
                    SetupException = ex;
                }
            }

        }

        public virtual void Cleanup()
        {
            foreach (TestGroupTearDownDelegate TearDownDelegate in TestGroupTearDownMethods)
            {
                CoreGlobal.RO.Debug("   TearDown ({0}.{1})", Name, TearDownDelegate.Method.Name);
                try
                {
                    TearDownDelegate();
                }
                catch(Exception ex)
                {
                    CoreGlobal.RO.Error("   TearDown ({0}.{1}) Failed: {2}", Name, TearDownDelegate.Method.Name, ex.ToString());
                }
            }

        }

        /// <summary>
        /// Adds a test to the group.  The group's default AsyncGroup value will be used.
        /// </summary>
        virtual public void Add(TestBase t)
        {
            Add(t, DefaultAsyncGroup);
        }
        /// <summary>
        /// Adds a test to the group, with a specific AsyncGroup value.
        /// </summary>
        virtual public void Add(TestBase t, uint asyncGroup)
        {
            t.Parent = this;
            t.AsyncGroup = asyncGroup;
            List.Add(t);
        }
        /// <summary>
        /// Generates the tosts of a compound test and adds them to the group.  The group's default AsyncGroup value will be used.
        /// </summary>
        virtual public void Add(CompoundTestBase t)
        {
            Add(t, DefaultAsyncGroup);
        }
        /// <summary>
        /// Generates the tosts of a compound test and adds them to the group, with a specific AsyncGroup value.
        /// </summary>
        virtual public void Add(CompoundTestBase t, uint asyncGroup)
        {
            TestBase []testInstances=t.GenerateTestInstances();
            foreach (TestBase inst in testInstances)
            {
                Add(inst, asyncGroup);
            }
        }

        public TestBase this[int index]
        {
            get
            {
                return (TestBase)List[index];
            }
            set
            {
                List[index] = value;
            }
        }

        public bool AnyEnabledTests()
        {
            foreach (TestBase test in List)
            {
                if (test.Enabled)
                {
                    return true;
                }
            }
            return false;
        }

        // Copies special attributes (async settings, etc) from another group to this one
        public void CopyAttributesFrom(TestBaseGroup other)
        {
            //copy group settings
            asyncThreadCount = other.asyncThreadCount;
            asyncThreadDelay = other.asyncThreadDelay;
            defaultAsyncGroup = other.defaultAsyncGroup;
            asyncSet = other.asyncSet;
            Ignore = other.Ignore;
            isExcludedFromDailyRun = other.isExcludedFromDailyRun;
            isRetryable = other.isRetryable;

            //copy test settings
            foreach (TestBase me in this)
            {
                foreach (TestBase you in other)
                {
                    if (me.Name == you.Name)
                    {
                        me.Ignore = you.Ignore;
                        me.AsyncGroup = you.AsyncGroup;
                        me.IsExcludedFromDailyRun = you.IsExcludedFromDailyRun;
                        me.IsRetryable = you.IsRetryable;
                        me.MyValues = you.MyValues;
                        
                        break;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\LocalTestSuiteLoader.cs ===
using System;
using System.IO;
using System.Collections;
using System.Xml;
using System.Reflection;
using ServerTestFramework;

namespace ServerTestFramework.Runner
{
	/// <summary>
	/// Loader for a local test suite in the current app domain
	/// </summary>
	public class LocalTestSuiteLoader
	{
		public TestSuite LoadTestSuite(string fullPath, out string errorMessage)
		{
			// load the test suite from the dll
			TestSuite suite = null;
			errorMessage = "";

			try
			{
				// load the test suite from the dll
				suite = TestSuite.CreateFromAssemblyPath(fullPath);

                // TODO: is it okay to just let .net handle versioning?
				// validate the suite version
				//if (suite != null && !suite.ValidateStfRunnerVersion(RunnerGlobal.Version))
				//{
					//throw new TestSuiteException("Suite: " + suite.Name + " is compiled for a different version STFRunner. You may need to upgrade StfRunner. Please sync & build. Current version: " + RunnerGlobal.Version);
				//}
			}
			catch(Exception ex)
			{
				errorMessage = ex.GetType().Name + ": " + ex.Message;
			}

			return suite;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\FunctionalScheduler.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Xml;
using System.IO;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;

namespace ServerTestFramework.Runner
{
    public class FunctionalScheduler : InfiniteLifetimeMarshalByRefObject, TestEventListener, TestScheduler
    {
        //event handler for when a functional run is about to start
        public delegate void FunctionalStartDelegate();
        public delegate void FunctionalStopDelegate();
        public static event FunctionalStartDelegate FunctionalStartEvent;
        public static event FunctionalStopDelegate FunctionalStopEvent;

        //
        private TestSuiteContainer           _Suites;
        private StfXmlDoc                    _Config;
        private System.Collections.Generic.List<RemoteSchedulerAgent>    _RemoteAgents = new System.Collections.Generic.List<RemoteSchedulerAgent>();
        private bool                         _CancelAllSuites = false;
        private TestEventListener            _Listener;

        public bool EnableFileLogging = true;

        public void Initialize(StfXmlDoc config, TestSuiteContainer suites)
        { 
            _Config = config;
            _Suites = suites;
        }

        // from TestScheduler
        public void Start(TestEventListener listener)
        {
            //signal that we're about to start
            if (FunctionalStartEvent!=null)
            {
                FunctionalStartEvent();
            }
            
            //
            _Listener=listener;

            // Make sure we start, not stop
            _CancelAllSuites = false;

            ThreadTracker.ResetTest();

            try
            {
                //
                bool disableAsync=CoreGlobal.Config.GetBoolParameter("noasyncmode");
                bool loopForever=CoreGlobal.Config.GetBoolParameter("loopforever");

                do
                {
                    //list of which suites have already been started/run.
                    System.Collections.Generic.Dictionary<string,bool> startedList=new System.Collections.Generic.Dictionary<string,bool>();

                    foreach (TestSuite suite in _Suites.GetLoadedSuites())
                    {
                        startedList.Add(suite.Name,false);
                    }

                    // initialize possible Common Actions
                    TestSequenceCommonActionState.Running = true;
                    TestSequenceCommonActionsTable.Init();

                    //run them
                    foreach (TestSuite suite in _Suites.GetLoadedSuites())
                    {
                        if (_CancelAllSuites) //stop if cancelling
                            break;

                        if (startedList[suite.Name]) //don't run if already run
                            continue;

                        //if the current suite is not in an AsyncSuite then run it by itself, else run all in that AsyncSuite
                        if (suite.AsyncSuite==0 || disableAsync)
                        {
                            startedList[suite.Name]=true;
                            RunSuite(suite);
                        }
                        else
                        {
                            //find all suites with the same AsyncSuite value as me
                            ArrayList sameArray=new ArrayList();
                            foreach (TestSuite s in _Suites.GetLoadedSuites())
                            {
                                if (s.AsyncSuite==suite.AsyncSuite)
                                {
                                    sameArray.Add(s);
                                    startedList[s.Name]=true;
                                }
                            }

                            //if only one then just run it, else run all in parallel
                            if (sameArray.Count==1) //self
                            {
                                RunSuite(suite);
                            }
                            else
                            {
                                ParallelRunner.Run(RunSuite_AsyncHelper, (uint)sameArray.Count, 64, sameArray);
                            }
                        }
                    }
                } while (loopForever && !_CancelAllSuites);
            }
            catch(Exception ex)
            {
                CoreGlobal.RO.Error("Unhandled exception occured in functional test scheduler.\nReason: {0}\nStackTrace: {1}", ex.Message, ex.StackTrace);
            }
            finally
            {
                ThreadTracker.ResetTest();
            }

            //free the remote agents
            lock (_RemoteAgents)
            {
                _RemoteAgents.Clear();
            }

            //signal that we're done
            if (FunctionalStopEvent!=null)
            {
                FunctionalStopEvent();
            }
        }

        public void Stop()
        {
            _CancelAllSuites = true;

            lock (_RemoteAgents)
            {
                if (_RemoteAgents.Count>0)
                {
                    CoreGlobal.RO.Info("Stopping " + _RemoteAgents.Count + " suites...");
                
                    foreach (RemoteSchedulerAgent rsa in _RemoteAgents)
                    {
                        rsa.Stop();
                    }
                }
            }
        }

        public void OnTestEvent(TestEventArgs args)
        {
            CoreGlobal.RO.Debug("Got test event: Suite: {0}, Group: {1}, Test: {2}, Action: {3}",
                args.SuiteName, args.GroupName, args.TestName, args.Action);
        }

        //helper to call RunSuite for different suites in parallel
        void RunSuite_AsyncHelper(uint num, object arrayList)
        {
            ArrayList sameList=arrayList as ArrayList;

            RunSuite(sameList[(int)num] as TestSuite);
        }

        //runs a single test suite
        private void RunSuite(TestSuite suite)
        {
            if (_CancelAllSuites)
                return;

            ThreadTracker.ResetTest();
            ThreadTracker.SetTestSuite(suite.Name);

            //
            FileReportDestination funcResults = null;
            RemoteSchedulerAgent remoteAgent = null;
            try
            {
                // Lookup the remote app domain
                AppDomain domain = _Suites.LookupAppDomainForTestSuite(suite.Name);
                
                if(EnableFileLogging)
                {
                    // Setup a file to log the results of the functional test run
                    DateTime now = DateTime.Now;
                    string funcResultsFileName = String.Format("FuncResults\\{0}-{1}-{2}-{3}-{4}-{5}.txt",
                            new object[]{
                            suite.Name,
                            now.Year,
                            now.Month,
                            now.Day,
                            now.Hour,
                            now.Minute
                            });
                    if (_Suites.AspxHostedTestSuites)
                    {
                        funcResultsFileName = "..\\" + funcResultsFileName;
                    }

                    try
                    {
                        funcResults = new FileReportDestination(funcResultsFileName);
                        ServerTestFramework.Report.GetRoot().AddReportDestination(funcResults);
                    }
                    catch (Exception e)
                    {
                        CoreGlobal.RO.Warn("Failed to create file report destination.  Output will not be logged: "+e.Message);
                        funcResults=null;
                    }
                }

                // Make sure that the remote agent has logging when we are in an isolated environment 
                if(null != domain && AppDomain.CurrentDomain != domain)
                {
                    // Get an instance of the cross domain test suite runner agent
                    remoteAgent = (RemoteSchedulerAgent)domain.CreateInstanceFromAndUnwrap("ServerTestFramework.dll", "ServerTestFramework.Runner.RemoteSchedulerAgent");
                    remoteAgent.ConfigureReporting(ServerTestFramework.Report.GetRoot().GetReportDestinations());
                }
                else
                {
                    // We can use a local version here
                    remoteAgent = new RemoteSchedulerAgent();
                }

                lock (_RemoteAgents)
                {
                    _RemoteAgents.Add(remoteAgent);
                }
                remoteAgent.Start(_Listener, suite, _Config.OuterXml);
            }
            catch(Exception ex)
            {
                CoreGlobal.RO.Error("Unexpected exception in functional test scheduler: RunSuite on suite name: {2}\nReason: {0}\nStackTrace: {1}", ex.Message, ex.StackTrace, suite.Name);
            }
            finally
            {
                ThreadTracker.ResetTest();

                // Release the file log
                if(EnableFileLogging && null != funcResults)
                {
                    ServerTestFramework.Report.GetRoot().RemoveReportDestination(funcResults);
                    funcResults.Close();
                }

                //
                if (remoteAgent!=null)
                {
                    lock (_RemoteAgents)
                    {
                        _RemoteAgents.Remove(remoteAgent);
                    }
                }
            }
        }

        private string StripException(Exception e)
        {
            string []strings=e.ToString().Split('\n');
            StringBuilder SB=new StringBuilder(1024);
            foreach (string s in strings)
            {
                int indexOfIn=s.IndexOf(" in ");
                if (indexOfIn==-1)
                    indexOfIn=s.Length-1;               
                string t=s.Substring(0,indexOfIn);
                SB.Append(t+"\n");
            }
            return SB.ToString().Replace("\n", "\n   ");
        }


        public bool ValidateParameters()
        {
            if (_Suites.Count==0)
            {
                CoreGlobal.RO.Error("ValidateSettings: No suites have been specified");
                return false;
            }

            if (_Config == null)
            {
                CoreGlobal.RO.Error("ValidateSettings: Config XML file was not found or specified.");
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\RunningAverage.cs ===
using System;
using System.Collections;

namespace ServerTestFramework.Runner
{
	public class RunningAverage
	{
		int length;
		int validData;
		int nextWritePosition;
		double[] data;

		public RunningAverage(int length)
		{
			this.length=length;
			data=new double[length];
			validData=0;
			nextWritePosition=0;
		}

		public void Add(double val)
		{
			data[nextWritePosition++]=val;
			if (nextWritePosition>=length)
				nextWritePosition=0;
			if (validData<length)
				validData++;
		}

        public void Add(float val)
        {
            Add((double)val);
        }

		public double Get()
		{
			int i;
			double avg=0;

			if (validData==0)
				return 0;

			for (i=0; i<validData; i++)
				avg+=data[i];
			return avg/validData;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\TestSuite.cs ===
using System;
using System.Diagnostics;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    //You should try not to use this... we need to find a better alternative sometime, so this will eventually be removed.
    public class CustomMenu
    {
        public string name = "";
        public EventHandler handler= null;
        public CustomMenu(string Name ,EventHandler Handler)
        {
            name=Name;
            handler=Handler;

        }
    }

    //
    public class TestSuite : InfiniteLifetimeMarshalByRefObject
    {
        //event handler for when a suite is loaded
        public delegate void SuiteLoadedDelegate(System.Reflection.Assembly assembly);
        public static event SuiteLoadedDelegate SuiteLoadedEvent;

        //
        public TestSuite()
        {
            _assembly = GetType().Assembly;
            CoreGlobal.CheckAssemblyVersion(_assembly);
            SuiteLoadedEvent(_assembly);
        }

        public TestSuite(Assembly asm)
        {
            _assembly = asm;
            CoreGlobal.CheckAssemblyVersion(_assembly);
            SuiteLoadedEvent(_assembly);
        }
        
        public Assembly HostAssembly
        {
            get { return (_assembly == null ? GetType().Assembly : _assembly); }
            set { _assembly = value; }
        }

        public string Name 
        {
            get { return HostAssembly.GetName().Name; }
        }

        public uint AsyncSuite
        {
            get { return asyncSuite; }
            set { asyncSuite=value; }
        }

        /// <summary>
        /// Returns full path to the suite DLL
        /// </summary>
        public string FullPath
        {
            get { return HostAssembly.Location; }
        }

        public ArrayList CustomMenu = new  ArrayList();
        
        static public TestSuite CreateFromAssemblyPath(string path)
        {
            Assembly asm = null;
            try
            {
                asm = Assembly.LoadFile(path);
            }
            catch(BadImageFormatException)
            {
                return null;
            }

            return CreateFromAssembly(asm);
        }

        static public TestSuite CreateFromAssembly(string asmName)
        {
            string testName = System.IO.Path.GetFileNameWithoutExtension(asmName);
            Assembly asm = null;
            try 
            {
                asm = Assembly.LoadFrom(asmName);
            }
            catch( BadImageFormatException ) 
            {
                return null;
            }
            return CreateFromAssembly(asm);
        }

        static public TestSuite CreateFromAssembly(Assembly asm)
        {
            if(asm == null)
            {
                throw new ArgumentException("Assembly object was nil");
            }

            TestSuite ts = null;
            Type[] eTypes = asm.GetExportedTypes();
            foreach( Type t in eTypes )
            {
                if( t.IsSubclassOf( typeof( ServerTestFramework.TestSuite ) ) )
                {
                    try
                    {
                        ts = asm.CreateInstance( t.FullName, true) as TestSuite;
                    }
                    catch (Exception e)
                    {
                        CoreGlobal.RO.Error("Failed to instantiate TestSuite from assembly: " + t.FullName + "\nA generic wrapper suite will probably be created now instead, but your Suite class may not be usable.");
                        CoreGlobal.RO.Error("Exception: " + e.Message + "\n" + e.StackTrace);
                        if (e.InnerException!=null)
                        {
                            CoreGlobal.RO.Error("Inner Exception: " + e.InnerException.Message + "\n" + e.InnerException.StackTrace);
                        }
                    }
                    break;
                }
            }

            if (ts == null)
            {
                // try searching for types marked with [TestGroup]
                // if they exist, just create a wrapper suite class
                foreach (Type t in eTypes)
                {
                    object[] attrs = t.GetCustomAttributes(typeof(TestGroupAttribute), true);

                    if (attrs.Length != 0)
                    {
                        ts = new TestSuite(asm);
                        break;
                    }
                }

            }

            //somehing went wrong... check some stuff.
            if (ts==null)
            {
                CoreGlobal.RO.Warn("Failed to create suite from assembly.");

                //get our stf version (similar to the check in FrameworkGlobals that happens "after" a load)
                System.Reflection.Assembly myAsm=System.Reflection.Assembly.GetExecutingAssembly();
                System.Reflection.AssemblyName myAsmName=myAsm.GetName();
                string myName=myAsmName.Name;

                System.Reflection.AssemblyName []refAsmNames=asm.GetReferencedAssemblies();
                foreach (System.Reflection.AssemblyName rAsmName in refAsmNames)
                {
                    //check for dangerous mixing of monolithic and split dlls
                    if ((myName=="ServerTestFramework" && (rAsmName.Name=="STFLive" || rAsmName.Name=="STFCore")) || (rAsmName.Name=="ServerTestFramework" && (myName=="STFLive" || myName=="STFCore")))
                    {
                        CoreGlobal.RO.Fatal("Detected mixed use of the monolithic ServerTestFramework.dll with STFCore.dll/STFLive.dll");
                        CoreGlobal.RO.Fatal("You CANNOT use both at the same time, because that creates seperate un-shared instances of all globals in xonline.");
                        CoreGlobal.RO.Fatal("Currently executing code is using: " + myName);
                        CoreGlobal.RO.Fatal("Suite is using: " + rAsmName.Name);
                    }
                }
            }

            return ts;
        }

        override public bool Equals(object ts)
        {
            return ts is TestSuite && (ts as TestSuite).Name == Name;
        }

        override public int GetHashCode()
        {
            return Name.GetHashCode();
        }

        // Cached copy of the last instance that was called.  This is so we can remember attributes that were changed by the gui.
        protected TestBaseGroupList _TestListForAttributes = null;

        // This gets the tests list, preserving any special attributes from the previous instance.
        // It internally calls GetTests normally still.
        public TestBaseGroupList GetTestsWithPreservation()
        {
            //Get the suites list
            TestBaseGroupList slist = GetTests();

            // If we have a saved instance, copy the attributes from that instance to the new one.
            if (_TestListForAttributes != null)
            {
                slist.CopyAttributesFrom(_TestListForAttributes);
            }

            // Cache the list for later use of the attributes
            _TestListForAttributes = slist;
            return slist;
        }

        // Cached list of tests, to avoid calling the constructor multiple times for each test by default.
        protected TestBaseGroupList _TestList = null;

        // This gets the tests list.  This is the default implementation that suites can replace.
        // It caches it.. but not all suites cache them.  Since the gui relies on the same instance staying around the
        //    whole time, all runners/gui need to use the GetTestsWithPreservation funtions instead, which saves the attributes.
        // The has only been kept the same for backwards compatability with older existing tests.
        // !!! You will normally want to call GetTestsWithPreservation, not this !!!
        virtual public TestBaseGroupList GetTests()
        {
            if (_TestList != null)
            {
                return _TestList;
            }

            TestBaseGroupList tests = new TestBaseGroupList();

            foreach (Type t in HostAssembly.GetTypes())
            {
                object[] attrs = t.GetCustomAttributes(typeof(TestGroupAttribute), true);
                Debug.Assert(attrs.Length == 0 || attrs.Length == 1);

                if (attrs.Length == 1 && attrs[0] is TestGroupAttribute)
                {
                    // Get the default constructor
                    ConstructorInfo constructor = t.GetConstructor(Type.EmptyTypes);
                    if(constructor == null)
                    {
                        CoreGlobal.RO.Error("Could not create test group: {0}, no default constructor found", t.FullName);
                    }
                    else
                    {
                        // Add the newly created test group
                        object tbg = null;
    
                        try
                        {
                            tbg = constructor.Invoke(Type.EmptyTypes);
                        }
                        catch(Exception ex)
                        {
                            CoreGlobal.RO.Warn("The constructor for TestGroup " + t.FullName + " failed and could not be added to the TestSuite");
                            CoreGlobal.RO.Error(ex.ToString()); 
                        }

                        if(null != tbg)
                        {
                            try
                            {
                                tests.Add((TestBaseGroup)tbg);
                            }
                            catch(Exception ex)
                            {
                                CoreGlobal.RO.Error("The test group: {0} does not appear to subclass from TestBaseGroup: {1}", 
                                        tbg.GetType().FullName, ex.Message); 
                            }
                        }
                    }

                    
                }
            }

            _TestList = tests;
            return tests;
        }

        virtual public StressTestBaseList GetStressTests()
        {
            StressTestBaseList tests = new StressTestBaseList();

            foreach (Type t in HostAssembly.GetTypes())
            {
                if (!t.IsAbstract)
                {
                    object[] attrs = t.GetCustomAttributes(typeof(StressTestAttribute), true);
                    Debug.Assert(attrs.Length == 0 || attrs.Length == 1);

                    if (attrs.Length == 1 && attrs[0] is StressTestAttribute)
                    {
                        tests.Add(t, ((StressTestAttribute)attrs[0]).Priority, ((StressTestAttribute)attrs[0]).TargetTPS, ((StressTestAttribute)attrs[0]).Counters);
                    }
                }
            }

            return tests;
        }

        /// <summary>
        /// Load the description of the enabled test tree into a XmlDocument
        /// </summary>
        /// <param name="testDesc">Document to build description into</param>
        public string DescribeTestTree()
        {
            XmlDocument testDesc = new XmlDocument();
            testDesc.AppendChild(testDesc.CreateElement("suite"));
            XmlElement docEl = testDesc.DocumentElement;
            docEl.SetAttribute("name", Name);

            // Note: this used to just call GetTests() and iterate through the items in the list.
            // However, GetTests() actually instantiates all of the tests, which is kind of slow.
            // The code below is a copy of the codepath GetTests() follows, but doesn't instantiate
            // anything, since we only need the test names and the Ignore attribute.

            // There's a problem with the "fast" implementation below -- many tests have a suite
            // defined that overrides GetTests().  I assume this is for custom behavior, although
            // glancing at a few, this may not be the case.  If it IS for custom behavior, these 
            // code changes won't work -- the tests won't show up properly in the test tree GUI.
            // So, if we find a GetTests() in this assembly, we should behave the old way and call
            // GetTests().  The "faster way" also does not work for compound cases.

            //Decide whether to use the instantiation method or the "faster" method
            bool useFastMethod=true;

            foreach (MethodInfo m in this.GetType().GetMethods()) //for each function
            {
                if ((m.Name == "GetTests" && m.DeclaringType.FullName != "ServerTestFramework.TestSuite"))
                {
                    useFastMethod=false;
                    break;
                }
            }

            foreach (Type groupType in HostAssembly.GetTypes()) //for each group class
            {
                object[] attrs = groupType.GetCustomAttributes(typeof(TestGroupAttribute), true);
                if (!(attrs.Length == 1 && attrs[0] is TestGroupAttribute))
                {
                    continue;
                }                 

                //on the group itself
                Attribute[] attList=Attribute.GetCustomAttributes(groupType, typeof(CompoundCaseAttribute));
                if (attList!=null && attList.Length!=0)
                {
                    useFastMethod=false;
                    break;
                }

                //on any class(case) within the group
                foreach (Type inner in groupType.GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public))
                {
                    //if it has the attribute
                    attList=Attribute.GetCustomAttributes(inner, typeof(CompoundCaseAttribute));
                    if (attList!=null && attList.Length!=0)
                    {
                        useFastMethod=false;
                        break;
                    }

                    //or it implements CompoundTestBase.GenerateTestInstances
                    foreach (MethodInfo m in inner.GetMethods()) //for each function
                    {
                        if (m.Name == "GenerateTestInstances")
                        {
                            useFastMethod=false;
                            break;
                        }
                    }
                }

                //on any method within the group
                foreach (MethodInfo methodInfo in groupType.GetMethods())
                {
                    attList=Attribute.GetCustomAttributes(methodInfo, typeof(CompoundCaseAttribute));
                    if (attList!=null && attList.Length!=0)
                    {
                        useFastMethod=false;
                        break;
                    }
                }
            }

            //
            if (!useFastMethod)
            {
                TestBaseGroupList tl = GetTestsWithPreservation();
                foreach(TestBaseGroup tbg in tl)
                {
                    XmlElement groupEl = (XmlElement)docEl.AppendChild(testDesc.CreateElement("group"));
                    groupEl.SetAttribute("name", tbg.Name);
                    if (tbg.Ignore || null!=(IgnoreAttribute)Attribute.GetCustomAttribute(tbg.GetType(), typeof(IgnoreAttribute), true))
                    {
                        groupEl.SetAttribute("ignore", "true");
                    }
                    if (tbg.IsDvt)
                    {
                        groupEl.SetAttribute("isdvt", "true");
                    }

                    if (tbg.AsyncSet!=0)
                    {
                        groupEl.SetAttribute("asyncset",String.Format("{0}", tbg.AsyncSet));
                    }

                    if (tbg.IsExcludedFromDailyRun)
                    {
                        groupEl.SetAttribute("isexcludedfromdailyrun", "true");
                    }

                    groupEl.SetAttribute("isretryable", tbg.IsRetryable?"true":"false");

                    foreach(TestBase test in tbg)
                    {
                        XmlElement testEl = (XmlElement)groupEl.AppendChild(testDesc.CreateElement("test"));
                        testEl.SetAttribute("name", test.Name);
                        if (test.BugId != 0)
                        {
                            testEl.SetAttribute("bugid", String.Format("{0}", test.BugId));
                        }
                        if (test.Ignore || null!=(IgnoreAttribute)Attribute.GetCustomAttribute(test.GetType(), typeof(IgnoreAttribute),true))
                        {
                            testEl.SetAttribute("ignore", "true");
                        }
                        if (test.Desc != null)
                        {
                            testEl.SetAttribute("desc", test.Desc);
                        }

                        if (test.AsyncGroup!=0)
                        {
                            testEl.SetAttribute("asyncgroup",String.Format("{0}", test.AsyncGroup));
                        }
                        
                        if (test.IsDvt)
                        {
                            testEl.SetAttribute("isdvt", "true");
                        }

                        if (test.IsExcludedFromDailyRun)
                        {
                            testEl.SetAttribute("isexcludedfromdailyrun", "true");
                        }

                        testEl.SetAttribute("isretryable", test.IsRetryable?"true":"false");
                    }
                }
                // Return at this point, we're done.  
                return testDesc.OuterXml;
            }

            // This is the new, faster, better way of using reflection to get ONLY the test names, instead
            // of instantiating each test just to describe the tree.

            // Iterate through each TestBaseGroup
            foreach (Type t in HostAssembly.GetTypes())
            {
                object[] attrs = t.GetCustomAttributes(typeof(TestGroupAttribute), true);
                Debug.Assert(attrs.Length == 0 || attrs.Length == 1);

                if (attrs.Length == 1 && attrs[0] is TestGroupAttribute)
                {
                    // OK, we have a TestBaseGroup at this point as 't'
                    XmlElement groupEl = (XmlElement)docEl.AppendChild(testDesc.CreateElement("group"));
                    groupEl.SetAttribute("name", t.Name);

                    //
                    if(null != (IgnoreAttribute)Attribute.GetCustomAttribute(t, typeof(IgnoreAttribute)))
                    {
                        groupEl.SetAttribute("ignore", "true");
                    }

                    if(null != (DVTAttribute)Attribute.GetCustomAttribute(t, typeof(DVTAttribute)))
                    {
                        groupEl.SetAttribute("isdvt", "true");
                    }

                    if(null != (DoNotRunDailyAttribute)Attribute.GetCustomAttribute(t, typeof(DoNotRunDailyAttribute)))
                    {
                        groupEl.SetAttribute("isexcludedfromdailyrun", "true");
                    }

                    if(null != (DoNotRetryAttribute)Attribute.GetCustomAttribute(t, typeof(DoNotRetryAttribute)))
                    {
                        groupEl.SetAttribute("isretryable", "false");
                    }
                    else
                    {
                        groupEl.SetAttribute("isretryable", "true");
                    }

                    // Check default AsyncGroup attribute for group
                    uint groupAsyncGroup=0;
                    {
                        AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(t, typeof(AsyncGroupAttribute));
                        if (asyncGroupA!=null)
                        {
                            groupAsyncGroup=asyncGroupA.AsyncGroup;
                            groupEl.SetAttribute("asyncset",asyncGroupA.AsyncSet.ToString());
                        }
                    }

                    // Iterate through each TestBase now (inner classes)
                    // Look for inner classes marked with TestCase attribute that are public, protected, or private
                    foreach (Type inner in t.GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public))
                    {
                        TestCaseAttribute testCaseAttr = (TestCaseAttribute)Attribute.GetCustomAttribute(inner, typeof(TestCaseAttribute));                    
                        if (testCaseAttr != null)
                        {
                            // OK, we have the TestBase here as 'inner'
                            XmlElement testEl = (XmlElement)groupEl.AppendChild(testDesc.CreateElement("test"));
                            testEl.SetAttribute("name", inner.Name);
                            if (testCaseAttr.BugID != 0)
                            {
                                testEl.SetAttribute("bugid", testCaseAttr.BugID.ToString());
                            }
                            if(null != (IgnoreAttribute)Attribute.GetCustomAttribute(inner, typeof(IgnoreAttribute)))
                            {
                                testEl.SetAttribute("ignore", "true");
                            }
                            if (null != (DescriptionAttribute)Attribute.GetCustomAttribute(inner, typeof(DescriptionAttribute)))
                            {
                                testEl.SetAttribute("desc", ((DescriptionAttribute)Attribute.GetCustomAttribute(inner, typeof(DescriptionAttribute))).Desc);
                            }

                            if (null != (AsyncGroupAttribute)Attribute.GetCustomAttribute(inner, typeof(AsyncGroupAttribute))) //use ours
                            {
                                testEl.SetAttribute("asyncgroup", ((AsyncGroupAttribute)Attribute.GetCustomAttribute(inner, typeof(AsyncGroupAttribute))).AsyncGroup.ToString());
                            }
                            else //default to group value
                            {
                                testEl.SetAttribute("asyncgroup",groupAsyncGroup.ToString());
                            }

                            if(null != (DVTAttribute)Attribute.GetCustomAttribute(inner, typeof(DVTAttribute)))
                            {
                                testEl.SetAttribute("isdvt", "true");
                            }

                            if(null != (DoNotRunDailyAttribute)Attribute.GetCustomAttribute(inner, typeof(DoNotRunDailyAttribute)))
                            {
                                testEl.SetAttribute("isexcludedfromdailyrun", "true");
                            }

                            if(null != (DoNotRetryAttribute)Attribute.GetCustomAttribute(inner, typeof(DoNotRetryAttribute)))
                            {
                                testEl.SetAttribute("isretryable", "false");
                            }
                            else
                            {
                                testEl.SetAttribute("isretryable", "true");
                            }
                        }
                    }

                    // Iterate through each TestBase now (public functions)
                    // Look for methods marked with TestCase attribute that are public
                    foreach (MethodInfo methodInfo in t.GetMethods())
                    {
                        Attribute attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestCaseAttribute));
                        if (attr != null)
                        {
                            // OK, we have the TestBase here as 'methodInfo'
                            XmlElement testEl = (XmlElement)groupEl.AppendChild(testDesc.CreateElement("test"));
                            testEl.SetAttribute("name", methodInfo.Name);
                            if (((TestCaseAttribute)attr).BugID != 0)
                            {
                                testEl.SetAttribute("bugid", ((TestCaseAttribute)attr).BugID.ToString());
                            }
                            if (null != (IgnoreAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(IgnoreAttribute)))
                            {
                                testEl.SetAttribute("ignore", "true");
                            }

                            if (null != (AsyncGroupAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(AsyncGroupAttribute)))
                            {
                                testEl.SetAttribute("asyncgroup", ((AsyncGroupAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(AsyncGroupAttribute))).AsyncGroup.ToString());
                            }
                            else if (null != (AsyncGroupAttribute)Attribute.GetCustomAttribute(t, typeof(AsyncGroupAttribute))) //group may still have the attribute
                            {
                                testEl.SetAttribute("asyncgroup", ((AsyncGroupAttribute)Attribute.GetCustomAttribute(t, typeof(AsyncGroupAttribute))).AsyncGroup.ToString());
                            }

                            if (null != (DVTAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DVTAttribute)))
                            {
                                testEl.SetAttribute("isdvt", "true");
                            }

                            if (null != (DoNotRunDailyAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DoNotRunDailyAttribute)))
                            {
                                testEl.SetAttribute("isexcludedfromdailyrun", "true");
                            }

                            if (null != (DoNotRetryAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DoNotRetryAttribute)))
                            {
                                testEl.SetAttribute("isretryable", "false");
                            }
                            else
                            {
                                testEl.SetAttribute("isretryable", "true");
                            }
                        }
                    }
                }
            }
            
            return testDesc.OuterXml;
        }

        /// <summary>
        /// Functional:
        /// This is called when a functional run for a suite is started.
        /// </summary>
        virtual public void Initialize(XmlDocument config) 
        {
        }

        /// <summary>
        /// Functional:
        /// This is called when a functional run for a suite is complete.
        /// </summary>
        virtual public void DeinitializeSuite()
        {
        }

        /// <summary>
        /// Stress:
        /// This is called just before a stress run starts.
        /// </summary>
        virtual public void InitializeStress(XmlDocument config) 
        {
        }

        /// <summary>
        /// Stress:
        /// This is called when a stress run ends.
        /// </summary>
        virtual public void DeinitializeStress() 
        {
        }

        /// <summary>
        /// Stress:
        /// This is called after your suite is loaded but still before the gui shows up.
        /// Override it to do stuff like show your own form, etc.
        /// </summary>
        virtual public void OneTimeInitializeStress(XmlDocument config) 
        {
        }

        /// <summary>
        /// Stress:
        /// This is called when the stress GUI is being closed. Use it to do stuff like
        /// close your own custom form, etc.
        /// </summary>
        virtual public void OneTimeDeinitializeStress() 
        {
        }

        /// <summary>
        /// This doesn't make any sense as part of a suite base which may be run without any gui existing.
        /// We will remove this eventually, but need to come up with an alternative first.
        /// 
        /// Override this to add custom menus to the GUI. (stress only)
        /// </summary>
        virtual public void AddCustomMenus()
        {
        }

        protected Assembly _assembly;
        private uint asyncSuite=0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\TestEventListener.cs ===
using System;
using System.Collections;
using ServerTestFramework;

namespace ServerTestFramework.Runner
{
	/// <summary>
	/// Specific types of events that occur inside of the test scheduler.
	/// </summary>
	public enum TestAction
	{
		Pass,       /// Test returned a passed result.
		Fail,       /// Test case returned a failed result.
        Retry,      /// A test case that previously failed is now being re-run.
		Start,      /// Test case started running.
		Ignore,     ///	Test case was ignored.
		StartAll,   /// Tests begin running. Details will contain a count of running tests.
		StopAll     /// Tests all fininished. Details will contain a count of all ran tests.
	};

	/// <summary>
	/// Event arguments notifying listeners of a test result.
	/// </summary>
	[Serializable]
	public class TestEventArgs
	{
		public string SuiteName;
		public string GroupName;
		public string TestName;
		public string Details;
		public int BugId;
		public TestAction Action;

		public TestEventArgs(string suiteName, string groupName, string testName, string details, int bugId, TestAction action)
		{
			SuiteName = suiteName;
			GroupName = groupName;
			TestName = testName;
			Details = details;
			BugId = bugId;
			Action = action;
		}
	}

	/// <summary>
	/// This interface should be implemented by any class that would be notified by a functional test scheduler of events
	/// as it is running tests.
	/// </summary>
	public interface TestEventListener
	{
		void OnTestEvent(TestEventArgs eventArgs);
	}

    public class MultiTestEventListener : TestEventListener
    {
        private ArrayList _listeners = new ArrayList();

        public virtual void OnTestEvent(TestEventArgs eventArgs)
        {
            foreach (TestEventListener listener in _listeners)
            {
                listener.OnTestEvent(eventArgs);
            }
        }

        public void Add(TestEventListener listener)
        {
            _listeners.Add(listener);
        }

        public void Remove(TestEventListener listener)
        {
            _listeners.Remove(listener);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\AboutForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for AboutForm.
	/// </summary>
	public class AboutForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.PictureBox pictureBox1;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.PictureBox pictureBox2;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public AboutForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(AboutForm));
			this.pictureBox1 = new System.Windows.Forms.PictureBox();
			this.button1 = new System.Windows.Forms.Button();
			this.panel1 = new System.Windows.Forms.Panel();
			this.pictureBox2 = new System.Windows.Forms.PictureBox();
			this.panel2 = new System.Windows.Forms.Panel();
			this.label3 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.panel1.SuspendLayout();
			this.panel2.SuspendLayout();
			this.SuspendLayout();
			// 
			// pictureBox1
			// 
			this.pictureBox1.BackColor = System.Drawing.SystemColors.Highlight;
			this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
			this.pictureBox1.Location = new System.Drawing.Point(5, 19);
			this.pictureBox1.Name = "pictureBox1";
			this.pictureBox1.Size = new System.Drawing.Size(64, 64);
			this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.pictureBox1.TabIndex = 3;
			this.pictureBox1.TabStop = false;
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.button1.Location = new System.Drawing.Point(248, 344);
			this.button1.Name = "button1";
			this.button1.TabIndex = 4;
			this.button1.Text = "OK";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// panel1
			// 
			this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.panel1.BackColor = System.Drawing.SystemColors.Highlight;
			this.panel1.Controls.Add(this.pictureBox1);
			this.panel1.Location = new System.Drawing.Point(8, 8);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(72, 368);
			this.panel1.TabIndex = 5;
			// 
			// pictureBox2
			// 
			this.pictureBox2.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
			this.pictureBox2.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox2.Image")));
			this.pictureBox2.Location = new System.Drawing.Point(104, 136);
			this.pictureBox2.Name = "pictureBox2";
			this.pictureBox2.Size = new System.Drawing.Size(87, 125);
			this.pictureBox2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.pictureBox2.TabIndex = 7;
			this.pictureBox2.TabStop = false;
			// 
			// panel2
			// 
			this.panel2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.panel2.Controls.Add(this.label3);
			this.panel2.Controls.Add(this.label1);
			this.panel2.Controls.Add(this.label2);
			this.panel2.Location = new System.Drawing.Point(80, 16);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(256, 88);
			this.panel2.TabIndex = 6;
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(8, 64);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(192, 16);
			this.label3.TabIndex = 2;
			this.label3.Text = "Copyright (c) MS XOSTT";
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(8, 8);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(208, 16);
			this.label1.TabIndex = 0;
			this.label1.Text = "Xbox Live Server Test Team";
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(8, 24);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(216, 24);
			this.label2.TabIndex = 1;
			this.label2.Text = "Functional Test DB Viewer";
			// 
			// AboutForm
			// 
			this.AcceptButton = this.button1;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(346, 384);
			this.Controls.Add(this.pictureBox2);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel1);
			this.Controls.Add(this.button1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AboutForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "About RegDBViewer";
			this.panel1.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void button1_Click(object sender, System.EventArgs e)
		{
			Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\StressJobList.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    public class StressJob
    {
        // Member vars
        private string          suiteName;
        private string          name;
        private bool            IsDynamicTest = false;
        private ConstructorInfo ci;
        private float           priority;
        private TestResult      results = null;
        private float           targetTPS = 0;

        public float            TriggerTimeLeft; //used by the TPS scheduler (measured in seconds)
        
        private MinimumStressTestBase  testbase = null;
        private bool            alwaysInstantiate = true;
        private bool            useCounters = false;
        
        // Properties
        public string       SuiteName       {get {return suiteName;}}
        public string       Name            {get {return name;}}
        public string       FullName        {get {return suiteName + "." + name;}}
        public TestResult   Results         {get {return results;}}
        public bool         UseCounters     {get {return useCounters;}}

        // Setting this to true will create a new test object (StressTestBase) for
        // every transaction.  Setting to false will cause us to cache the object
        // and re-use it, saving lots and lots of instantiations.  I personally
        // went from 6,800 TPS to 10,500 TPS clientside with this one change.
        public bool AlwaysInstantiate
        {
            get { return alwaysInstantiate; }
            set { alwaysInstantiate = value; }
        }

        public float TargetTPS  
        {
            get 
            {
                return targetTPS;
            } 
            set 
            {
                targetTPS = value; 
                if (results != null) 
                    results.TargetTps = value; 
            }
        }

        public float Priority
        {
            get
            {
                return priority;
            }
            set
            {
                float delta = value - priority;
                priority = value;
                if (PriorityChanged != null)
                    PriorityChanged(this, delta);
            }
        }

        /// <summary>
        /// Constructor for dynamic test cases
        /// </summary>
        /// <param name="suiteName"></param>
        /// <param name="type"></param>
        /// <param name="priority"></param>
        /// <param name="testname"></param>
        /// <param name="allResults"></param>
        public StressJob(string suiteName, Type type, float priority, string testname, TestResultCollection allResults, bool bUseCounters)
        {
            this.suiteName = suiteName;
            //name = type.Name;
            ci = type.GetConstructor(Type.EmptyTypes);
            Priority = priority;
            name =testname;
            IsDynamicTest=true;
            results = allResults.CreateTestResult(FullName);
            useCounters = bUseCounters;

            if (type == typeof(MinimumStressTestBase))
            {
                AlwaysInstantiate = false;
            }
        }

        /// <summary>
        /// Regular constructor
        /// </summary>
        /// <param name="suiteName"></param>
        /// <param name="type"></param>
        /// <param name="priority"></param>
        /// <param name="allResults"></param>
        public StressJob(string suiteName, Type type, float priority, TestResultCollection allResults, bool bUseCounters)
        {
            this.suiteName = suiteName;
            name = type.Name;
            ci = type.GetConstructor(Type.EmptyTypes);
            Priority = priority;
            results = allResults.CreateTestResult(FullName);
            useCounters = bUseCounters;
            
            if (type.IsSubclassOf(typeof(MinimumStressTestBase)))
            {
                AlwaysInstantiate = false;
            }
        }

        /// <summary>
        /// Regular constructor
        /// </summary>
        /// <param name="suiteName"></param>
        /// <param name="type"></param>
        /// <param name="allResults"></param>
        public StressJob(string suiteName, Type type, TestResultCollection allResults)
        {
            this.suiteName = suiteName;
            name = type.Name;
            ci = type.GetConstructor(Type.EmptyTypes);
            Priority = 0;
            results = allResults.CreateTestResult(FullName);
            useCounters = false;;
            
            if (type.IsSubclassOf(typeof(MinimumStressTestBase)))
            {
                AlwaysInstantiate = false;
            }
        }

        public MinimumTestBase CreateInstance()
        {
            // We are not supposed to cache the object, we should create it every
            // single time.
            if (AlwaysInstantiate)
            {
                if (IsDynamicTest)
                {
                    DynamicStressTestBase tbDynamic =(DynamicStressTestBase)ci.Invoke(null);
                    tbDynamic.Initialize(name);
                    return tbDynamic;
                }
                else 
                {
                    StressTestBase tb = (StressTestBase)ci.Invoke(null);
                    return tb;
                }
            }

                // If we haven't stored the testbase yet, let's call the constructor and
                // store the object. Once. Be careful of multithreading. The base type is
                // required to be MinimumStressTestBase.
            else if (testbase == null)
            {
                // I don't want to lock the obect every time this function gets called --
                // it gets called a lot. We only need the lock for the constructor call.
                // So we're moving the lock to after the check, then we'll have to check 
                // again after acquiring the lock. 
                lock (this)
                {
                    if (testbase != null)
                        return testbase;
                       
                    testbase = (MinimumStressTestBase)ci.Invoke(null);
                }
            }
            // Else return cached object.
            return testbase;
        }

        public event PriorityChangedHandler PriorityChanged;
    }

    public delegate void PriorityChangedHandler(StressJob sj, float oldPrioity);

    public class StressJobList : CollectionBase, IEnumerable
    {
        //used by the priority scheduler only
        private float totalPriority = 0;
        public float TotalPriority {get {return totalPriority;}}
        
        //construct an empty one
        public StressJobList()
        {
        }

        //construct and load tests and settings
        public StressJobList(TestSuite[] suites, XmlDocument config, TestResultCollection allResults)
        {
            
            foreach (TestSuite suite in suites)
            {
                ArrayList CounterNames = new ArrayList();
                StressTestBaseList stbl = suite.GetStressTests();
                foreach (StressTestBaseList.StressTestBaseItem item in stbl)
                {
                    float priority = item.Priority;
                    float targetTPS = item.TargetTPS;
                    string testname =item.Type.Name;
                    StressJob sj;

                    XmlNode testNode = config.SelectSingleNode(string.Format("/stf/tests/suite[@name='{0}']/stress/test[@name='{1}']", suite.Name,testname));
                    if (testNode != null && testNode.Attributes["priority"] != null)
                        priority = Convert.ToSingle(testNode.Attributes["priority"].Value);

                    Debug.Assert(item.Type.IsSubclassOf(typeof(MinimumStressTestBase)) || item.Type.IsSubclassOf(typeof(StressTestBase)));
                    
                    totalPriority += priority;
                    if(item.Type.IsSubclassOf(typeof(DynamicStressTestBase)) && item.TestName!=null)
                    {
                        // this is a dynamic test case.
                        testname= item.TestName;
                        sj = new StressJob(suite.Name, item.Type, priority, testname, allResults, item.UseCounters);
                    }
                    else    // this is not dynamic test case
                    {
                        sj = new StressJob(suite.Name, item.Type, priority, allResults, item.UseCounters);
                    }
                    
                    if (item.UseCounters)
                    {
                        CounterNames.Add(testname);
                        CounterNames.Add(testname+"Failed");
                    }
                    
                    // Older config files may not contain a target TPS rate
                    sj.TargetTPS = targetTPS;

                    if (testNode != null)
                    {
                        XmlAttribute targetTPSNode=testNode.Attributes["targetTPS"];
                        if (targetTPSNode!=null)
                            sj.TargetTPS = Convert.ToSingle(targetTPSNode.Value);
                    }
                    
                    sj.PriorityChanged += new PriorityChangedHandler(sj_PriorityChanged);
                    List.Add(sj);
                }

                XmlNodeList tests = config.SelectNodes("/stf/tests/suite[@name='" + suite.Name + "']/stress/test");
                foreach (XmlNode testNode in tests)
                {
                    bool foundTest = false;
                    foreach (StressTestBaseList.StressTestBaseItem item in stbl)
                    {
                        if (item.Type.Name == testNode.Attributes["name"].Value)
                            foundTest = true;
                        if(item.TestName!=null && item.TestName==testNode.Attributes["name"].Value)
                            foundTest = true;
                    }

                    if (!foundTest)
                    {
                        string sibMessage="";
                        if (testNode.PreviousSibling!=null) sibMessage += "\r\nprev node: " + testNode.PreviousSibling.Attributes["name"].Value;
                        if (testNode.NextSibling!=null) sibMessage += "\r\nnext node: " + testNode.NextSibling.Attributes["name"].Value;
                        throw new Exception("Test " + testNode.Attributes["name"].Value + " found in xml file is not part of " + suite.Name + "." + sibMessage);
                    }
                }

                // Creating perfcounters.
                string [] tmp= new string[CounterNames.Count];
                for(int i=0;i<CounterNames.Count;i++)
                    tmp[i]=(string)CounterNames[i];

                try
                {
                    Counters.CreateCategory("STFTests." + suite.Name, tmp);
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Warn("Failed to create performance counters:\n" + e.ToString());
                }
            }
        }

        public void AddJob(StressJob sj)
        {
            List.Add(sj);
        }

        private void sj_PriorityChanged(StressJob sj, float delta)
        {
            totalPriority += delta;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\StressSchedulerTPS.cs ===
using System.Collections.Generic;
using ServerTestFramework;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Settings and Status for the TPS based scheduler.
    /// </summary>
    public class StressSettingsTPS
    {
        //Settings - all times are in seconds
        public int MaxThreads=100;
        public float ScaleTPS=1.0f;
        public int HangTime=120; //time until a thread is considered "hung"
        public float ReserveHighTPSThreadRatio=0.05f; //portion of the threads that are reserved for running non-slow tests
        
        //Settings for sin wave scaling
        //Period requirements: sin and cos of ((1/settings.SinWavePeriod)*System.Math.PI*2*24hours) == 0 and 1
        public float SinWavePeriod=60*60*24; //24 hour by default
        public float SinWavePhase=(float)System.Math.PI/2; //peek at midnight GMT by default
        public float SinWaveMagnitude=0.5f;
        public bool SinWaveEnabled=false;

        //Current Status
        public int Status_CurrentThreads=0;
        public float Status_CurrentSinScalar=1.0f;
    }

    /// <summary>
    /// The TPS based stress scheduler.
    /// </summary>
    public class StressSchedulerTPS: StressTestScheduler
    {
        // -- interface implementation

        //Called to set up the scheduler.
        public void Initialize(StfXmlDoc config, TestSuiteContainer suites, StressJobList jobListReference, object schedulerSettings)
        {
            if (schedulerSettings!=null) settings=(StressSettingsTPS)schedulerSettings;
            else settings=new StressSettingsTPS();

            jobList=jobListReference;
        }
        
        //Shuts down the scheduler.
        public void Shutdown()
        {
            Stop();
        }

        //This call should block and run tests and block until someone calls Stop.
        public void Run()
        {
            running=true;

            // - prepare to run

            // set async callback function
            AsyncStressTestBase.AsyncFinish = TestCallback;

            //setup the initial trigger time on each job
            System.Random rand=new System.Random();
            foreach (StressJob job in jobList)
            {
                if (job.TargetTPS<0.0000001f) job.TargetTPS=0.0f;
                else job.TriggerTimeLeft=settings.ScaleTPS/job.TargetTPS * (float)rand.NextDouble();
            }

            // - main loop
            System.DateTime lastTime=System.DateTime.Now; //time of last pass

            while (running)
            {
                float sleepTime=MaxLagTime/2; //time in seconds the time we'll end up sleeping after this pass
                
                //calc the number of threads reserved for non-slow cases and the average threads-per-case assuming even distribution
                int reservedFastThreads=(int)(settings.ReserveHighTPSThreadRatio*settings.MaxThreads);
                if (reservedFastThreads<1) reservedFastThreads=1;
                if (settings.ReserveHighTPSThreadRatio==0.0f || settings.MaxThreads<=1) reservedFastThreads=0;

                int totalActiveJobs=0;
                foreach (StressJob job in jobList)
                {
                    if (job.TargetTPS>0.0f) ++totalActiveJobs;
                }
                if (totalActiveJobs<=1)
                {
                    totalActiveJobs=1;
                    reservedFastThreads=0;
                }
                float evenThreadsPerJob=(float)settings.MaxThreads/totalActiveJobs;

                //calc the sin wave tps scalar
                float sinTPSScalar=1.0f;
                if (settings.SinWaveEnabled)
                {
                    //calc seconds since midnight
                    System.DateTime now=System.DateTime.Now;
                    System.DateTime dayStart=now-new System.TimeSpan(0,now.Hour,now.Minute,now.Second,now.Millisecond);
                    float seconds=(float)((now-dayStart).TotalSeconds);

                    //
                    sinTPSScalar=1.0f + (float)System.Math.Sin(settings.SinWavePhase+(1/settings.SinWavePeriod)*seconds*System.Math.PI*2)*settings.SinWaveMagnitude;
                }

                settings.Status_CurrentSinScalar=sinTPSScalar;

                //check for hung threads
                lock (activeThreads)
                {
                    try
                    {
                        foreach (TPSWorker worker in activeThreads)
                        {
                            if ((System.DateTime.Now-worker.startTime).TotalSeconds > settings.HangTime)
                            {
                                if (worker.job!=null)
                                {
                                    CoreGlobal.RO.Warn("Aborting stuck thread: "+worker.job.Name);
                                    worker.job.Results.Deadlock();
                                }
                                if (worker.node!=null) activeThreads.Remove(worker.node);
                                DestroyWorker(worker);
                                sleepTime=0;
                                break;
                            }
                        }
                    }
                    catch (System.Exception e)
                    {
                        CoreGlobal.RO.Warn("Scheduler error while checking for hung threads: "+e.Message);
                    }
                }

                //sort the jobs so that the most-starved jobs are first in the list
                System.Collections.Generic.List<StressJob> sortedJobs=new List<StressJob>();
                foreach (StressJob job in jobList)
                {
                    sortedJobs.Add(job);
                }
                sortedJobs.Sort(SortStressJobsByTriggerTime);

                //figure out how much time has really passed since the last pass
                System.DateTime dtNow=System.DateTime.Now;
                System.TimeSpan timePassed=dtNow-lastTime;
                lastTime=dtNow;
                float time=(float)(timePassed.TotalMilliseconds/1000);

                //go through each job
                string passErrors="";

                foreach (StressJob job in sortedJobs)
                {
                    if (!running) break;

                    //if it's disabled, don't process it
                    float jobTPS=job.TargetTPS*settings.ScaleTPS*sinTPSScalar;

                    if (jobTPS<=0.0f)
                    {
                        job.TriggerTimeLeft=0;
                        continue;
                    }

                    if (jobTPS>5000000) //5 million sanity cap
                    {
                        jobTPS=5000000;
                    }

                    float iterTime=1/jobTPS; //time required for a single case run

                    //pass time
                    job.TriggerTimeLeft-=time;

                    //if there are fewer threads available than the number reserved for non-slow jobs
                    int availableThreads=settings.MaxThreads-activeThreads.Count;
                    if (availableThreads<0) availableThreads=0;
                    if (availableThreads<reservedFastThreads)
                    {
                        //if this job is hogging more than its share of threads, it is not allowed to run
                        float consumedThreads=job.Results.Threads;
                        if (consumedThreads>evenThreadsPerJob*2)
                        {
                            job.TriggerTimeLeft=0;

                            //warn about it, but no more than once per second
                            if (System.DateTime.Now-lastOutOfFastThreadsWarnTime >= new System.TimeSpan(0,0,1))
                            {
                                lastOutOfFastThreadsWarnTime=System.DateTime.Now;
                                passErrors+="A job is being skipped because all normal threads are in-use. "+availableThreads+" are available but reserved for faster jobs.\n";
                            }

                            continue;
                        }
                    }

                    //don't lag behind if we can't keep up
                    if (job.TriggerTimeLeft<-MaxLagTime)
                    {
                        job.TriggerTimeLeft=-MaxLagTime;

                        //warn about it
                        if (System.DateTime.Now-lastOutOfCPUWarnTime >= new System.TimeSpan(0,0,1))
                        {
                            lastOutOfCPUWarnTime=System.DateTime.Now;
                            passErrors+="Not enough CPU time to run jobs at the desired speed.\n";
                        }

                        //wiggle the exact wait time to help mix up the list so 1 case doesn't steal it all
                        job.TriggerTimeLeft+=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(MaxLagTime/5);
                    }

                    //spawn instances of this job until we've made as many as we need since the last iteration
                    System.DateTime jobSpawnStartTime=System.DateTime.Now;
                    while (job.TriggerTimeLeft<0 && running)
                    {
                        //if we have too many of it made for the reserve limit, don't make anymore; next cycle will catch and warn about it if needed
                        if (job.Results.Threads>=settings.MaxThreads-reservedFastThreads)
                        {
                            //If reserved is set to 0%, don't ever block
                            if (reservedFastThreads!=0)
                            {
                                job.TriggerTimeLeft+=MaxLagTime/4;
                                break;
                            }
                        }

                        //don't ever spend more than .5 seconds in one pass on spawning a single job
                        if (System.DateTime.Now-jobSpawnStartTime > new System.TimeSpan(0,0,0,0,500))
                        {
                            break;
                        }

                        //for very fast jobs, it's more effecient to have a thread do several tasks, so calculate how many we should do each
                        uint jobCount=(uint)(jobTPS/333.333f)+1;
                        uint maxJobsForTime=(uint)(-job.TriggerTimeLeft/iterTime);
                        if (jobCount>maxJobsForTime) jobCount=maxJobsForTime;
                        if (jobCount<1) jobCount=1;
                        if (jobCount>100) jobCount=100;

                        job.TriggerTimeLeft+=iterTime*jobCount;

                        if (!SpawnJob(job,jobCount)) //out of threads
                        {
                            System.Threading.Thread.Sleep(0); //yield in case we just tried to do too much at once on a uniprocessor system, then try again
                            if (!SpawnJob(job,jobCount)) //out of threads
                            {
                                //back it off just a little, but try again soon
                                job.TriggerTimeLeft+=MaxLagTime/4;
                                if (job.TriggerTimeLeft<-MaxLagTime/2) job.TriggerTimeLeft=-MaxLagTime/2;
                                sleepTime/=2;

                                //warn about it, but no more than once per second
                                if (System.DateTime.Now-lastOutOfThreadsWarnTime >= new System.TimeSpan(0,0,1))
                                {
                                    lastOutOfThreadsWarnTime=System.DateTime.Now;
                                    passErrors+="Not enough threads available to spawn another instance of a test.\n";
                                }

                                break;
                            }
                        }
                    }

                    if (job.TriggerTimeLeft<sleepTime) sleepTime=job.TriggerTimeLeft;

                    //if the user updated any jobs, their next trigger time will be too high, so fix that up if it's unreasonable
                    if (job.TriggerTimeLeft>iterTime*2) job.TriggerTimeLeft=iterTime*2;
                }

                //update status, and nap
                if (passErrors.Length!=0)
                {
                    CoreGlobal.RO.Warn("Scheduler error:\n"+passErrors);
                }

                settings.Status_CurrentThreads=activeThreads.Count;

                int msSleep=(int)(sleepTime*1000) - 1;
                if (msSleep<0) msSleep=0;
                System.Threading.Thread.Sleep(msSleep);
            }

            //wait for all threads to end
            int tries=50; // 5 seconds before we just abort them
            while ((activeThreads.Count > 0 || IsInProgress) && tries > 0)
            {
                System.Threading.Thread.Sleep(100);
                settings.Status_CurrentThreads=activeThreads.Count;
                --tries;
            }

            //kill any remaining threads and clean up
            WipeThreadLists();

            //we should have 0 threads now
            settings.Status_CurrentThreads=activeThreads.Count;
            if (settings.Status_CurrentThreads!=0)
            {
                CoreGlobal.RO.Warn("Exiting scheduler, but we have threads still alive.  This should never happen.");
            }
        }

        //Stop running tests.
        public void Stop()
        {
            running=false;
        }

        /// <summary>
        /// Checks the job list for in progress tests, if there are any, return true.
        /// </summary>
        public bool IsInProgress
        {
            get
            {
                foreach (StressJob job in jobList)
                {
                    if (job.Results.InProgress > 0)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        //Validates that the current scheduler settings are valid.
        public bool ValidateParameters()
        {
            return (settings.MaxThreads>0 && settings.ScaleTPS>0);
        }

        // -- private helpers

        //spawns a new thread to run a job
        private bool SpawnJob(StressJob job, uint count)
        {
            //if over max, bad
            if (activeThreads.Count>=settings.MaxThreads) return false;

            //find a worker, or make one if needed
            TPSWorker worker=null;
            if (idleThreads.Count>0)
            {
                lock (idleThreads)
                {
                    //pull from idle pool
                    if (idleThreads.Count>0)
                    {
                        worker=idleThreads.First.Value;
                        idleThreads.RemoveFirst();

                        lock (activeThreads)
                        {
                            worker.node=activeThreads.AddFirst(worker);
                        }
                    }
                }
            }

            if (worker==null)
            {
                worker=new TPSWorker();
                lock (idleThreads)
                {
                    lock (activeThreads)
                    {
                        if (activeThreads.Count>=settings.MaxThreads) return false;

                        worker.node=activeThreads.AddFirst(worker);
                    }
                }
            }

            //set up the worker
            worker.job=job;
            worker.startTime=System.DateTime.Now;
            worker.count=count;

            if (worker.thread!=null)
            {
                worker.are.Set();
            }
            else //we need to setup the thread
            {
                worker.thread=ThreadMaker.CreateThread(SpawnThreadProc, worker);
                worker.thread.Start();
            }
            return true;
        }

        //procedure to run a test
        private void SpawnThreadProc(object o)
        {
            TPSWorker worker=(TPSWorker)o;
            try
            {
                while (true)
                {
                    //see if we have a job
                    if (!running) break;

                    if (worker.job==null)
                    {
                        worker.are.WaitOne();
                        continue;
                    }

                    StressJob job=worker.job;
                    job.Results.AddThread();

                    try
                    {
                        //get the test, and run it (CreateInstance will return a shared instance if it should)
                        for (uint number=0; number<worker.count; ++number)
                        {
                            if (!running) break;

                            MinimumTestBase tb=job.CreateInstance();

                            TEST_RESULTS result=TEST_RESULTS.FAILED;
                            string reason=null;

                            if (tb is AsyncStressTestBase)
                            {
                                AsyncStressTestBase astb = (AsyncStressTestBase) tb;

                                try
                                {
                                    job.Results.BeginInProgress();
                                    astb.Begin(job);
                                }
                                catch (System.Exception e)
                                {
                                    job.Results.EndInProgress();
                                    job.Results.Fail();
                                    CoreGlobal.RO.Error(job.Name + " failed: " + e.Message);
                                }
                            }
                            else
                            {
                                try
                                {
                                    job.Results.BeginInProgress();
                                    result = tb.Run();
                                }
                                catch (System.Exception e)
                                {
                                    reason = e.Message;
                                }
                                finally
                                {
                                    job.Results.EndInProgress();
                                }

                                //handle the results of the run
                                if (result == TEST_RESULTS.PASSED)
                                {
                                    job.Results.Pass();
                                }
                                else if (result == TEST_RESULTS.FAILED)
                                {
                                    job.Results.Fail();
                                    CoreGlobal.RO.Error(job.Name + " failed" + (reason == null ? "." : ": " + reason));
                                }
                                else if (result == TEST_RESULTS.NOT_EXECUTED)
                                {
                                    job.Results.Skip();
                                }
                                else
                                {
                                    CoreGlobal.RO.Warn("Unhandled test result in scheduler code [SpawnThreadProc]: " + result);
                                }
                            }
                        }
                    }
                    finally
                    {
                        job.Results.SubtractThread();
                    }

                    //move us from the active to the idle list
                    lock (activeThreads)
                    {
                        activeThreads.Remove(worker.node);
                    }

                    worker.job=null;

                    lock (idleThreads)
                    {
                        worker.node=idleThreads.AddFirst(worker);
                    }

                    //time to nap
                    if (!running) break;
                    worker.are.WaitOne();
                }
            }
            finally
            {
                //remove us from any list we belong to
                if (worker!=null && worker.node!=null && worker.node.List!=null)
                {
                    lock (worker.node.List)
                    {
                        worker.node.List.Remove(worker.node);
                    }
                }
            }
        }

        /// <summary>
        /// The callback used by async tests to report success or failure.
        /// </summary>
        /// <param name="state">The state object that was passed to Begin.</param>
        /// <param name="result">The result of running the test.</param>
        /// <param name="exc">The exception, if any, that occured during the asynchronous portions of the test.</param>
        private void TestCallback (object state, TEST_RESULTS result, System.Exception exc)
        {
            StressJob job = (StressJob) state;

            job.Results.EndInProgress();

            // handle the results of the run
            if (result == TEST_RESULTS.PASSED)
            {
                job.Results.Pass();
            }
            else if (result == TEST_RESULTS.FAILED)
            {
                job.Results.Fail();
                CoreGlobal.RO.Error(job.Name + " failed" + (exc == null ? "." : ": " + exc.Message));
            }
            else if (result == TEST_RESULTS.NOT_EXECUTED)
            {
                job.Results.Skip();
            }
            else
            {
                CoreGlobal.RO.Warn("Unhandled test result in scheduler code [TestCallback]: " + result);
            }
        }

        //clears out thread lists
        void WipeThreadLists()
        {
            lock (activeThreads)
            {
                lock (idleThreads)
                {
                    while (activeThreads.Count>0)
                    {
                        if (activeThreads.First!=null)
                        {
                            activeThreads.First.Value.node=null;
                            DestroyWorker(activeThreads.First.Value);
                        }
                        else
                        {
                            CoreGlobal.RO.Warn("Scheduler anomaly: activeThreads list has a null entry.");
                        }
                        activeThreads.RemoveFirst();
                    }

                    while (idleThreads.Count>0)
                    {
                        if (idleThreads.First!=null)
                        {
                            idleThreads.First.Value.node=null;
                            DestroyWorker(idleThreads.First.Value);
                        }
                        else
                        {
                            CoreGlobal.RO.Warn("Scheduler anomaly: idleThreads list has a null entry.");
                        }
                        idleThreads.RemoveFirst();
                    }
                }
            }
        }

        //Destroys a worker thread
        void DestroyWorker(TPSWorker w)
        {
            if (w.are!=null)
            {
                w.are.Set();
                if (w.thread!=null && !running) System.Threading.Thread.Sleep(1); //that might have been enough to end them.. give them a little chance.
            }

            if (w.thread!=null)
            {
                w.thread.Abort();
            }

            //clear contents to help out the evil garbage collector
            w.thread=null;
            w.are=null;
            w.node=null;
            w.job=null;
        }

        //Used to sort stress jobs
        public static int SortStressJobsByTriggerTime(StressJob x, StressJob y)
        {
            if (x.TriggerTimeLeft<y.TriggerTimeLeft) return -1;
            else if (x.TriggerTimeLeft>y.TriggerTimeLeft) return 1;
            else
            {
                //if they are the same, randomly choose a direction, to help mix them up more
                //if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<50) return -1;
                //else return 1;
                return 0; //this breaks C#'s sorter... grr
            }
        }

        // -- private members

        //
        StressSettingsTPS settings;
        StressJobList jobList;

        System.DateTime lastOutOfThreadsWarnTime=System.DateTime.Now;
        System.DateTime lastOutOfFastThreadsWarnTime=System.DateTime.Now;
        System.DateTime lastOutOfCPUWarnTime=System.DateTime.Now;

        //switch to cause us to stop running
        volatile bool running;

        //list of threads
        class TPSWorker
        {
            public System.DateTime startTime;
            public System.Threading.Thread thread;
            public volatile StressJob job;
            public uint count; //number of times the worker should execute this job

            public LinkedListNode<TPSWorker> node; //node in the list that I'm currently in

            public System.Threading.AutoResetEvent are=new System.Threading.AutoResetEvent(true);
        }

        LinkedList<TPSWorker> activeThreads=new LinkedList<TPSWorker>(); //running threads
        LinkedList<TPSWorker> idleThreads=new LinkedList<TPSWorker>(); //idle threads

        //maximum lag time for test case spawning
        public const float MaxLagTime=0.5f;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\RemoteSchedulerAgent.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Xml;
using System.IO;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// An object that can run a set of tests inside a remote app domain and report the results to a local 
    /// scheduler
    /// </summary>
    public class RemoteSchedulerAgent : InfiniteLifetimeMarshalByRefObject
    {
        private TestEventListener               _Listener;
        private TestSuite                       _Suite;
        private bool                            _CancelRun;
        private StfXmlDoc                       _Config;
        private TestResult[]                    _Results;       // array of Results, one per TestBaseGroup
        private bool                            _RunDVTOnly;
        private bool                            _IgnoreNonDailyTests = false;
        private uint                            _TryRunCount = 1; // times to try group init and cases that fail
        private uint                            _TestCount;
        private System.TimeSpan                 _SuiteRunTime; //time it took to run the suite

        private System.Collections.Generic.List<Thread>  _TestCaseThreads=new System.Collections.Generic.List<Thread>(); //list of all test case threads currently running in this agent
        private System.Collections.Generic.List<Thread>  _GroupInitThreads=new System.Collections.Generic.List<Thread>(); //list of all group init threads currently running in this agent

        private ArrayList _RunningSequences = new ArrayList();
        public bool IsCancelled { get {return _CancelRun;} }

        enum RunQueueItemType 
        {
            TestCase,
            TestGroupInit,
            TestGroupShutdown,
            AsyncGroupStart,
            AsyncGroupEnd,
            AsyncSetStart,
            AsyncSetEnd
        }
        class RunQueueItem
        {
            public RunQueueItemType     Type;
            public object               Data;

            public RunQueueItem(RunQueueItemType type, object data)
            {
                Type = type;
                Data = data;
            }
        }

        public void ConfigureReporting(ArrayList destinations)
        {
            /* Report is MarshalByRefObject that only has one copy in the process.
            foreach(ServerTestFramework.Report.Destination d in destinations)
            {
                ServerTestFramework.Report.GetRoot().AddReportDestination(d);
            }
            */
        }


        public void Start(TestEventListener listener, TestSuite suite, string configXml)
        {
            // Reset flag
            _CancelRun = false;
            _Listener = listener;
            _Suite = suite;
            _GroupInitThreads.Clear();
            _TestCaseThreads.Clear();
            _RunningSequences.Clear();

            // Create the config XML from the passed in XML string. Also attempt to
            // load [DLL name].xml from the same directory as [DLL name].dll that
            // we are executing from. Very handy for test-specifc settings. It should 
            // be noted that the DLL name does not necessarily match the suite name. 
            // The other beauty of doing it here is this gets called every time
            // we click start, allowing you to change the XML file without restarting
            // STFRunner.
            _Config = new StfXmlDoc();
            _Config.LoadXml(configXml);
            string suitexmlfile = Path.ChangeExtension(suite.FullPath, "xml");
            if (File.Exists(suitexmlfile))
            {
                CoreGlobal.RO.Debug("Found {0}, merging config", suitexmlfile);
                StfXmlDoc xmldoc = new StfXmlDoc(suitexmlfile);

                // Merge with local copy and with global copy. 
                // TODO: future work
                // We really should get rid of one of these two, as the local copy isn't 
                // accessible from tests, AFAIK. I'm scared to overwrite CoreGlobal.Config
                // so we're just going to merge twice.
                _Config.Merge(xmldoc, "/stf");
                lock (CoreGlobal.Config)
                {
                    CoreGlobal.Config.Merge(xmldoc, "/stf");
                }
            }

            // Parse parameters that are stored in the XML config document
            _RunDVTOnly=_Config.GetBoolParameter("dvtmode");
            _IgnoreNonDailyTests=_Config.GetBoolParameter("dailyrunmode");

            string tryRunCountString=_Config.GetParameter("tryruncount");
            if (tryRunCountString!=null)
            {
                try
                {
                    _TryRunCount=uint.Parse(tryRunCountString);
                }
                catch
                {
                    _TryRunCount=1;
                    CoreGlobal.RO.Warn("stf config parameter has a bad format (must be uint): tryruncount:" + tryRunCountString);
                }
            }
            if (_TryRunCount<1)
            {
                CoreGlobal.RO.Warn("stf config parameter: tryruncount: must be at least 1");
                _TryRunCount=1;
            }
            if (_TryRunCount>20)
            {
                CoreGlobal.RO.Warn("stf config parameter: tryruncount more than 20 isn't very sane, capping at 20");
                _TryRunCount=20;
            }

            ArrayList runQueue = new ArrayList();
            
            try
            {
                BuildSuiteTests(suite, runQueue);

                if(_TestCount > 0)
                {
                    System.DateTime suiteStartTime=System.DateTime.Now;
                    RunSuiteTests(suite, runQueue);
                    _SuiteRunTime=System.DateTime.Now-suiteStartTime;
                    ReportResults();
                }
            }
            catch(Exception ex)
            {
                CoreGlobal.RO.Error("Failed to run test suite: {0}, Reason: {1}", suite.Name, ex.ToString());
                throw;
            }
        }

        private void AbortSequences()
        {
            lock (_RunningSequences.SyncRoot)
            {
                TestSequenceCommonActionState.Running = false;
                foreach (TestSequenceBaseGroup tsbg in _RunningSequences)
                {
                    tsbg.TerminteTests();
                }
                _RunningSequences.Clear();
            }
        }

        //Calls Abort on all threads in a thread list, without holding a lock on the list during the Abort
        private void AbortThreadList(System.Collections.Generic.List<Thread> tlist, string listName)
        {
            uint numSuspended=0;

            if (tlist.Count>0)
            {
                CoreGlobal.RO.Info("Aborting "+tlist.Count+" "+listName+"s.");
            }
            while (true)
            {
                //pick the next target thread
                Thread target = null;
                lock (tlist)
                {
                    foreach (Thread t in tlist)
                    {
                        if (!(t.ThreadState==System.Threading.ThreadState.Aborted || t.ThreadState==System.Threading.ThreadState.AbortRequested || t.ThreadState==System.Threading.ThreadState.Stopped))
                        {
                            target=t;
                            break;
                        }
                    }
                }

                if (target==null)
                {
                    break;
                }

                //attempt to abort it
                try
                {
                    target.Abort();
                }
                catch (ThreadStateException)
                {
                    ++numSuspended;
                }
            }
            if (numSuspended>0)
            {
                CoreGlobal.RO.Warn("" + numSuspended + " " + listName + " threads were suspended and may not abort.");
            }
        }

        //waits on each thread in a thread list to completely stop, without holding the list lock during the Join
        private void JoinThreadList(System.Collections.Generic.List<Thread> tlist, string listName)
        {
            uint waitTime=0;
            while (tlist.Count>0)
            {
                //find a target thread
                Thread target=null;

                lock (tlist)
                {
                    if (tlist.Count>0)
                    {
                        target=tlist[0];
                    }
                }

                if (target==null)
                {
                    break;
                }

                //wait on it to stop
                bool succ=target.Join(10000);
                if (!succ)
                {
                    waitTime+=10;
                    CoreGlobal.RO.Warn("A "+listName+" thread(mid=" + target.ManagedThreadId + ") still has not finished responding to the Abort after " + waitTime + " seconds...");
                }
                else
                {
                    waitTime=0;
                }
            }
        }

        //Stops all our running tests
        public void Stop()
        {
            //Set our state as stopping, so no more tests are started
            _CancelRun = true;

            //Abort all running sequences
            AbortSequences();

            //Abort all group init and test case threads
            AbortThreadList(_GroupInitThreads,"GroupInit");
            AbortThreadList(_TestCaseThreads,"TestCase");
            
            //Wait on all threads to completely stop
            JoinThreadList(_GroupInitThreads,"GroupInit");
            JoinThreadList(_TestCaseThreads,"TestCase");
        }

        private void BuildSuiteTests(TestSuite suite, ArrayList runQueue)
        {   
            _TestCount = 0;
            Hashtable tempGroups = new Hashtable();
            int i=0;

            bool disableAsync=CoreGlobal.Config.GetBoolParameter("noasyncmode");
            
            // validate that the suite has test groups
            TestBaseGroupList origTests = suite.GetTestsWithPreservation();
            if (origTests == null)
            {
                CoreGlobal.RO.Error("No tests found in test suite: " + suite.Name);
                return;
            }

            //rearrange the groups so all same AsyncSet values are adjacent, with minimal changes to the order
            ArrayList testListList=new ArrayList();

            foreach (TestBaseGroup tbg in origTests)
            {
                if (tbg.AsyncSet==0 || disableAsync) //non-async one
                {
                    ArrayList newSingle=new ArrayList();
                    newSingle.Add(tbg);
                    testListList.Add(newSingle);
                }
                else //needs sorted by AsyncSet
                {
                    //see if we have a list already for that AsyncSet
                    bool wasAdded=false;
                    foreach (ArrayList lg in testListList)
                    {
                        if ((lg[0] as TestBaseGroup).AsyncSet==tbg.AsyncSet)
                        {
                            lg.Add(tbg);
                            wasAdded=true;
                            break;
                        }
                    }

                    //nope, make a new list for it
                    if (!wasAdded)
                    {
                        ArrayList newList=new ArrayList();
                        newList.Add(tbg);
                        testListList.Add(newList);
                    }
                }
            }

            //put the sorted groups back into a TestBaseGroupList
            TestBaseGroupList tests=new TestBaseGroupList();

            foreach (ArrayList lg in testListList)
            {
                foreach (TestBaseGroup tbg in lg)
                {
                    tests.Add(tbg);
                }
            }

            // probe the suite for any enabled tests
            uint lastAsyncSet=0;
            foreach (TestBaseGroup tbg in tests)
            {
                // remove any disabled tests -- this has to happen before here, not inside the test-case loop

                if (_Config != null) //normal disabled tests
                {
                    tests.Prune(suite.Name, _Config);
                }

                if (_RunDVTOnly) //non-dvt tests if it's a dvt run
                {
                    foreach (TestBase tb in tbg)
                    {
                        if(!(tb.IsDvt || tbg.IsDvt))
                        {
                            tb.Enabled=false;
                        }
                    }
                }

                if (_IgnoreNonDailyTests) //tests excluded from the daily functional run
                {
                    foreach (TestBase tb in tbg)
                    {
                        if(tb.IsExcludedFromDailyRun || tbg.IsExcludedFromDailyRun)
                        {
                            tb.Enabled=false;
                        }
                    }
                }

                //
                if (!tbg.Ignore && tbg.AnyEnabledTests())
                {
                    //async set start/end
                    if (!disableAsync && tbg.AsyncSet!=lastAsyncSet)
                    {
                        if (lastAsyncSet!=0)
                        {
                            runQueue.Add(new RunQueueItem(RunQueueItemType.AsyncSetEnd,lastAsyncSet));
                        }

                        if (tbg.AsyncSet!=0)
                        {
                            runQueue.Add(new RunQueueItem(RunQueueItemType.AsyncSetStart,tbg.AsyncSet));
                        }
                        lastAsyncSet=tbg.AsyncSet;
                    }

                    //group init
                    runQueue.Add(new RunQueueItem(RunQueueItemType.TestGroupInit, tbg));
                    tempGroups.Add(i++,tbg.Name);

                    //sort the cases by AsyncGroup
                    System.Collections.ArrayList asGroups=new System.Collections.ArrayList();
                    foreach (TestBase tb in tbg)
                    {
                        if (tb.Enabled && !tb.Ignore)
                        {
                            //see if we already have a list for that group, make one if not
                            System.Collections.ArrayList asg=null;
                            if (tb.AsyncGroup!=0 && !disableAsync)
                            {
                                foreach (System.Collections.ArrayList g in asGroups)
                                {
                                    if ((g[0] as TestBase).AsyncGroup==tb.AsyncGroup)
                                    {
                                        asg=g;
                                        break;
                                    }
                                }
                            }
                            if  (asg==null) //need a new group
                            {
                                asg=new System.Collections.ArrayList();
                                asGroups.Add(asg);
                            }

                            asg.Add(tb);
                            
                            _TestCount++;
                        }
                    }

                    //add the tests to the queue
                    foreach (System.Collections.ArrayList group in asGroups)
                    {
                        if (group.Count==1) //single seperate item
                        {
                            TestBase tb=group[0] as TestBase;
                            runQueue.Add(new RunQueueItem(RunQueueItemType.TestCase, tb));
                        }
                        else //async group of items
                        {
                            runQueue.Add(new RunQueueItem(RunQueueItemType.AsyncGroupStart, 0));

                            foreach (TestBase tb in group)
                            {
                                runQueue.Add(new RunQueueItem(RunQueueItemType.TestCase, tb));
                            }

                            runQueue.Add(new RunQueueItem(RunQueueItemType.AsyncGroupEnd, tbg));
                        }
                    }

                    //group shutdown
                    runQueue.Add(new RunQueueItem(RunQueueItemType.TestGroupShutdown, tbg));
                }
            }

            //asyncSet End
            if (!disableAsync && lastAsyncSet!=0)
            {
                runQueue.Add(new RunQueueItem(RunQueueItemType.AsyncSetEnd,lastAsyncSet));
            }

            //give each group it's group index (for _Results) based on it's position within the list
            int RunGroupIndex=0;
            foreach (RunQueueItem rqi in runQueue)
            {
                if (rqi.Type==RunQueueItemType.TestGroupInit)
                {
                    (rqi.Data as TestBaseGroup).RunGroupIndex=RunGroupIndex++;
                }
            }

            // Now we have all TestBaseGroups, create the _Results array
            _Results = new TestResult[tempGroups.Count];
            for(int j=0;j<tempGroups.Count;j++)
            {
                _Results[j] = new TestResult();
                _Results[j].GroupName = (string)tempGroups[j];
            }
        }

        //helper for RunSuiteTests for running a single test asynchronously
        private class RunSuiteTests_AsyncInstance
        {
            //info we'll need for the run
            private RemoteSchedulerAgent myAgent;
            private ArrayList testList=null;
            string suiteName;
            TestBaseGroup tbg;

            public RunSuiteTests_AsyncInstance(RemoteSchedulerAgent agent, ArrayList testCaseList, string nameOfSuite, TestBaseGroup testGroup)
            {
                myAgent=agent;
                testList=testCaseList;
                suiteName=nameOfSuite;
                tbg=testGroup;
            }

            //instance of a thread
            public void ThreadProc(uint rqiIndex, object obj)
            {
                if (myAgent.IsCancelled)
                {
                    return;
                }

                try
                {
                    myAgent.RunTest(suiteName, tbg, testList[(int)rqiIndex] as TestBase);
                }
                catch (System.Threading.ThreadAbortException) //can result from us stopping the tast case early
                {
                    System.Threading.Thread.ResetAbort();
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Warn("Expected exception running a test: "+e.Message);
                }
            }
        };

        //helper for RunSuiteTests - struct of information about a list of groups to run from a run queue
        class RunGroupInfo
        {
            public TestSuite suite;
            public ArrayList runQueue;
            public ArrayList groupStartIndices;
        };

        //helper for RunSuiteTests to run a set of groups in parallel
        void RunSuiteGroup_AsyncInstance(uint num, object runGroupInfo)
        {
            RunGroupInfo gi=runGroupInfo as RunGroupInfo;

            int startInd=(int)gi.groupStartIndices[(int)num];
            RunSuiteGroup(gi.suite, gi.runQueue, startInd);
        }

        //helper for RunSuiteTests to find a list of of the first index(TestGroupInit) of each group in the same AsyncSet
        private void FindRQIAsyscSet(ArrayList runQueue, int asyncSetStartIndex, out int asyncSetEndIndex, out ArrayList groupStartIndices)
        {
            groupStartIndices=new ArrayList();

            if ((runQueue[asyncSetStartIndex] as RunQueueItem).Type==RunQueueItemType.TestGroupInit) //this is a stand-alone group
            {
                groupStartIndices.Add(asyncSetStartIndex);

                //find the last index
                int rqIndex;
                for (rqIndex=asyncSetStartIndex; rqIndex<runQueue.Count; ++rqIndex)
                {
                    if ((runQueue[rqIndex] as RunQueueItem).Type==RunQueueItemType.TestGroupShutdown)
                        break;
                }

                asyncSetEndIndex=rqIndex;
                return;
            }

            //go until we hit the end of our AsyncSet
            { //workaround C# retartedness
                int rqIndex;
                for (rqIndex=asyncSetStartIndex; rqIndex<runQueue.Count; ++rqIndex)
                {
                    RunQueueItem rqi = runQueue[rqIndex] as RunQueueItem;

                    if (rqi.Type==RunQueueItemType.TestGroupInit) //hit a group start
                    {
                        groupStartIndices.Add(rqIndex);
                    }
                    
                    if (rqi.Type==RunQueueItemType.AsyncSetEnd) //hit the end of this set
                    {
                        break;
                    }
                }

                asyncSetEndIndex=rqIndex;
            }
        }

        //helper for RunSuiteTests to run a single group
        private void RunSuiteGroup(TestSuite suite, ArrayList runQueue, int rqIndexStart)
        {
            try
            {
                System.Collections.ArrayList asyncList=null;
                int groupIndex=-1;
                TestBaseGroup tbg=null;
                for (int rqIndex=rqIndexStart; rqIndex<runQueue.Count; ++rqIndex)
                {
                    RunQueueItem rqi = runQueue[rqIndex] as RunQueueItem;

                    switch(rqi.Type)
                    {
                        case RunQueueItemType.TestCase:
                            if(_CancelRun)  
                            {
                                if (groupIndex!=-1)
                                    _Results[groupIndex].Skip();
                            }
                            else
                            {
                                if (asyncList==null) //normal run
                                {
                                    RunTest(suite.Name, tbg, rqi.Data as TestBase);
                                }
                                else //queue for async run
                                {
                                    asyncList.Add(rqi.Data as TestBase);
                                }
                            }
                            break;
                        case RunQueueItemType.TestGroupInit:
                            if(_CancelRun)
                                break;

                            if (rqi.Data is TestSequenceBaseGroup)
                            {
                                lock (_RunningSequences.SyncRoot)
                                {
                                    _RunningSequences.Add(rqi.Data as TestSequenceBaseGroup);
                                }
                            }

                            tbg=(rqi.Data as TestBaseGroup);
                            groupIndex=tbg.RunGroupIndex;
                            _Results[groupIndex].Start();

                            ThreadTracker.SetTestGroup(tbg.Name);
                            ThreadTracker.ResetTestCase();

                            //do group init
                            try
                            {
                                lock (_GroupInitThreads)
                                {
                                    _GroupInitThreads.Add(System.Threading.Thread.CurrentThread);
                                }

                                try
                                {
                                    uint myTryRunCount=(tbg.IsRetryable?_TryRunCount:1);
                                    for (uint tryCount=0; tryCount<myTryRunCount; ++tryCount)
                                    {
                                        if(_CancelRun)
                                            break;

                                        try
                                        {
                                            tbg.SetupException=null;
                                            tbg.Initialize();
                                            if (tbg.SetupException!=null)
                                            {
                                                throw new System.Exception("Group Setup threw",tbg.SetupException);
                                            }
                                            break;
                                        }
                                        catch (Exception e)
                                        {
                                            CoreGlobal.RO.Error("Group init threw on try "+(tryCount+1)+" of "+myTryRunCount+": "+tbg.Name);
                                            CoreGlobal.RO.Error("Exception: "+e.Message+"\n"+e.StackTrace);

                                            //if we died on our last try, skip any test cases in this group with "fail"
                                            if (tryCount+1 == myTryRunCount)
                                            {
                                                while ((runQueue[rqIndex+1] as RunQueueItem).Type!=RunQueueItemType.TestGroupShutdown)
                                                {
                                                    if ((runQueue[rqIndex+1] as RunQueueItem).Type==RunQueueItemType.TestCase)
                                                    {
                                                        TestBase tb = (TestBase)(((RunQueueItem)runQueue[rqIndex+1]).Data);
                                                        _Listener.OnTestEvent(new TestEventArgs(suite.Name, tb.Parent.Name, tb.Name, "Group Init failed", 0, TestAction.Fail));
                                                    }

                                                    ++rqIndex;
                                                }
                                            }
                                        }
                                    }
                                }
                                catch (System.Threading.ThreadAbortException) //if we stop the test early
                                {
                                    System.Threading.Thread.ResetAbort(); //we don't want our agent thread to die due to cancelling the run
                                }
                            }
                            finally
                            {
                                lock (_GroupInitThreads)
                                {
                                    _GroupInitThreads.Remove(System.Threading.Thread.CurrentThread);
                                }
                            }

                            break;
                        case RunQueueItemType.TestGroupShutdown:
                            if (tbg==null)
                            {
                                return;
                            }

                            ThreadTracker.ResetTestCase();
                            string suiteName = suite.Name;

                            if (rqi.Data is TestSequenceBaseGroup)
                            {
                                (rqi.Data as TestSequenceBaseGroup).WaitForTests(); 
                                foreach (TestSequenceBase tsb in (TestSequenceBaseGroup)rqi.Data)
                                {
                                    if (tsb.Enabled)
                                    {
                                        TEST_RESULTS result = TEST_RESULTS.FAILED;
                                        result = tsb.ResultCode;

                                        if (result == TEST_RESULTS.NOT_EXECUTED)
                                        {
                                            CoreGlobal.RO.Warn(tsb.Name + " not executed");
                                            _Listener.OnTestEvent(new TestEventArgs(suiteName, tsb.Parent.Name, tsb.Name, null, tsb.BugId, TestAction.Ignore));
                                        }
                                        else if (result == TEST_RESULTS.PASSED)
                                        {
                                            Pass(suiteName, tsb, tbg.RunGroupIndex);
                                            _Listener.OnTestEvent(new TestEventArgs(suiteName, tsb.Parent.Name, tsb.Name, null, tsb.BugId, TestAction.Pass));
                                        }
                                        else if (result == TEST_RESULTS.FAILED)
                                        {
                                            Fail(suiteName, tsb, tsb.FailureException, tbg.RunGroupIndex);
                                            _Listener.OnTestEvent(new TestEventArgs(suiteName, tsb.Parent.Name, tsb.Name, tsb.FailureException == null ? null : tsb.FailureException.ToString(), tsb.BugId, TestAction.Fail));
                                        }
                                    }
                                }
                                (rqi.Data as TestSequenceBaseGroup).Cleanup();
                            }
                            else
                            {
                                uint myTryRunCount=(tbg.IsRetryable?_TryRunCount:1);
                                for (uint tryCount=0; tryCount<myTryRunCount; ++tryCount)
                                {
                                    try
                                    {                            
                                        tbg.Cleanup();
                                        break;
                                    }
                                    catch (Exception e)
                                    {
                                        CoreGlobal.RO.Error("Group teardown threw on try "+(tryCount+1)+" of "+myTryRunCount+": "+tbg.Name);
                                        CoreGlobal.RO.Error("Exception: "+e.Message+"\n"+e.StackTrace);

                                        if(_CancelRun && myTryRunCount>1)
                                        {
                                            CoreGlobal.RO.Error("Run is being cancelled though, so not trying teardown again.");
                                            break;
                                        }
                                    }
                                }
                            }

                            _Results[groupIndex].End();
                            tbg=null;
                            return; //end of group, stop
                        case RunQueueItemType.AsyncGroupStart:
                            asyncList=new System.Collections.ArrayList();
                            break;
                        case RunQueueItemType.AsyncGroupEnd:
                            //extract thread count
                            TestBaseGroup atbg=rqi.Data as TestBaseGroup;
                            uint numThreads=atbg.AsyncThreadCount;
                            uint threadDelay=atbg.AsyncThreadDelay;
                            if (numThreads<1) numThreads=1;
                            //run tests in parallel
                            if (asyncList.Count>0)
                            {
                                RunSuiteTests_AsyncInstance ai=new RunSuiteTests_AsyncInstance(this, asyncList, suite.Name, atbg);
                                ParallelRunner.Run(ai.ThreadProc, (uint)asyncList.Count, numThreads, 0, threadDelay);
                            }
                            asyncList=null;
                            break;
                    }
                }
            }
            finally
            {
                ThreadTracker.ResetTestGroup();
                ThreadTracker.ResetTestCase();
            }
        }
    
        //run all groups/cases for a suite
        private void RunSuiteTests(TestSuite suite, ArrayList runQueue)
        {
            CoreGlobal.RO.Info("Running TestSuite: {0}, Enabled: {1}", suite.Name, _TestCount);

            for(int i=0;i<_Results.Length;i++)
                _Results[i].Reset();
            
            _Listener.OnTestEvent(new TestEventArgs(suite.Name, "", "", _TestCount.ToString(), 0, TestAction.StartAll));
            
            // Initialize the suite
            suite.Initialize(_Config);

            try
            {
                //run them
                for (int rqIndex=0; rqIndex<runQueue.Count; ++rqIndex)
                {
                    //find groups starting from the current index
                    int asyncSetEndIndex;
                    ArrayList asGroupStartIndices;
                    FindRQIAsyscSet(runQueue, rqIndex, out asyncSetEndIndex, out asGroupStartIndices);

                    //run them
                    if (asGroupStartIndices.Count==0) //should never happen..
                    {
                        CoreGlobal.RO.Error("RunSuiteTests: FindRQIGroupIndexRange gave back 0 groups");
                    }
                    else if (asGroupStartIndices.Count==1) //single group only
                    {
                        RunSuiteGroup(suite,runQueue,rqIndex);
                    }
                    else //groups to run in parallel
                    {
                        RunGroupInfo gi=new RunGroupInfo();
                        gi.suite=suite;
                        gi.runQueue=runQueue;
                        gi.groupStartIndices=asGroupStartIndices;

                        ParallelRunner.Run(RunSuiteGroup_AsyncInstance, (uint)asGroupStartIndices.Count, 64, gi);
                    }

                    //update index to the last element of that group
                    rqIndex=asyncSetEndIndex;
                }

                _Listener.OnTestEvent(new TestEventArgs(suite.Name, "", "", _TestCount.ToString(), 0, TestAction.StopAll));
            }
            finally
            {
                // Deinitialize test suite
                suite.DeinitializeSuite();
            }
        }

        private void ReportResults()
        {
            int passed, total, skipped;
            double passRate;
            TimeSpan elapsed;

            GetResultsAllGroups(out passed, out total, out skipped, out passRate, out elapsed);
            CoreGlobal.RO.Info(""); 
            CoreGlobal.RO.Info("TEST RESULTS SUMMARY:");
            // if all tests passed, then display a success message
            if (passed == total && skipped == 0)
            {
                CoreGlobal.RO.Success("All tests in " + _Suite.Name + " passed in " + (elapsed.TotalMilliseconds / 1000).ToString("F") + " seconds.");
            }
            else
            {            
                // else, display informational message
                CoreGlobal.RO.Info("Passed: " + passed.ToString() + "/" + 
                    total.ToString() + ", PassRate: " + (passRate*100).ToString("F")
                    + "%, Time: " + (elapsed.TotalMilliseconds / 1000).ToString("F") + " seconds.");
            }

            CoreGlobal.RO.Info("");    
            // Broken up by test group
            CoreGlobal.RO.Info("BY TEST GROUP:");
            for(int i=0;i<_Results.Length;i++)
            {
                CoreGlobal.RO.Info(_Results[i].GroupName);
                CoreGlobal.RO.Info("Passed: " + _Results[i].Passed.ToString() + "/" + 
                    _Results[i].Total.ToString() + ", PassRate: " + (_Results[i].PassRate*100).ToString("F")
                    + "%, Time: " + (_Results[i].Elapsed.TotalMilliseconds / 1000).ToString("F") + " seconds.");
            }
        }

        private void GetResultsAllGroups(out int passed, out int total, out int skipped, 
            out double passRate, out TimeSpan elapsed)
        {
            // Initialize variables
            passed=0; total=0; skipped=0; passRate=0;
            for(int i=0;i<_Results.Length;i++)
            {
                passed += _Results[i].Passed;
                total += _Results[i].Total;
                skipped += _Results[i].Skipped;                
            }
            passRate = (double)passed/total;
            elapsed=_SuiteRunTime;
        }

        private void RunTest(string suiteName, TestBaseGroup tbg, TestBase tb)
        {
            try
            {
                //store name of the test being run by this thread
                ThreadTracker.SetTestCase(tb.Name);

                //add us to the currently running tests
                lock (_TestCaseThreads)
                {
                    _TestCaseThreads.Add(Thread.CurrentThread);
                }

                TEST_RESULTS result=TEST_RESULTS.FAILED;

                //run it
                uint myTryRunCount=(tb.IsRetryable?_TryRunCount:1);
                for (uint tryCount=0; tryCount<myTryRunCount; ++tryCount)
                {
                    if(_CancelRun)
                        break;

                    try
                    {
                        //do the run
                        TestEventArgs resultArgs = new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, null, tb.BugId, TestAction.Start);
                        _Listener.OnTestEvent(resultArgs);

                        result = tb.Run();

                        //check return of the run
                        if(tb.ExpectedException != null) //did not get an exception, but expected one
                        {
                            result=TEST_RESULTS.FAILED;
                            UnexpectedTestResultException e = new UnexpectedTestResultException("An exception of type " + tb.ExpectedException.ToString() + " was expected, but no exception was thrown.");
                            Fail(suiteName, tb, e, tbg.RunGroupIndex);
                            _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, e.ToString(), tb.BugId, TestAction.Fail));
                        }
                        else //no exception, good
                        {
                            if(result == TEST_RESULTS.NOT_EXECUTED)
                            {
                                CoreGlobal.RO.Warn(tb.Name + " not executed");
                                _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, null, tb.BugId, TestAction.Ignore));
                            }
                            else if (result==TEST_RESULTS.PASSED)
                            {
                                Pass(suiteName, tb, tbg.RunGroupIndex);
                                _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, null, tb.BugId, TestAction.Pass));
                            }
                            else if (result==TEST_RESULTS.FAILED)
                            {
                                Fail(suiteName, tb, null, tbg.RunGroupIndex);
                                _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, null, tb.BugId, TestAction.Fail));
                            }
                        }
                    }
                    catch (System.Threading.ThreadAbortException) //outter handler should handle this
                    {
                        result=TEST_RESULTS.NOT_EXECUTED;
                        throw;
                    }
                    catch (Exception e)
                    {
                        if(tb.ExpectedException != null) //we expected an exception, and got one
                        {
                            if(e.GetType() != tb.ExpectedException) //didn't expect this type though
                            {
                                UnexpectedTestResultException eTestResult = new UnexpectedTestResultException("An exception of type " + tb.ExpectedException.ToString() + " was expected, but the exception thrown was of type " + e.GetType().ToString() + ".");
                                result=TEST_RESULTS.FAILED;
                                Fail(suiteName, tb, eTestResult, tbg.RunGroupIndex);
                                _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, eTestResult.ToString(), tb.BugId, TestAction.Fail));
                            }
                            else //we did expect this type, good
                            {
                                result=TEST_RESULTS.PASSED;
                                Pass(suiteName, tb, tbg.RunGroupIndex);
                                _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, e.ToString(), tb.BugId, TestAction.Pass));
                            }
                        }
                        else //did not expect an exception, but got one
                        {
                            result=TEST_RESULTS.FAILED;
                            Fail(suiteName, tb, e, tbg.RunGroupIndex);
                            _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, e.ToString(), tb.BugId, TestAction.Fail));
                        }

                        if (!tb.CatchExceptions) //if false, will propegate this up to halt execution of the suite
                        {
                            throw;
                        }
                    }

                    //
                    if (result!=TEST_RESULTS.FAILED) //if we didn't fail, we're done
                    {
                        break;
                    }
                    else if (tryCount+1<myTryRunCount) //if it failed, give it another chance to not fail, if we're running it again
                    {
                        UnFail(suiteName, tb, tbg.RunGroupIndex);
                        _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, "Retrying a failed test", tb.BugId, TestAction.Retry));
                    }

                    if (myTryRunCount!=1)
                    {
                        CoreGlobal.RO.Error("Test case failed on try "+(tryCount+1)+" of "+myTryRunCount+": "+tb.Name);
                    }
                }
            }
            catch (System.Threading.ThreadAbortException) //results from us stopping the tast case early
            {
                try
                {
                    _Listener.OnTestEvent(new TestEventArgs(suiteName, tb.Parent.Name, tb.Name, "Abort! Abort!", tb.BugId, TestAction.Ignore));
                    System.Threading.Thread.ResetAbort(); //scheduler thread itself should not be aborted
                }
                catch (System.Threading.ThreadAbortException)
                {
                    System.Threading.Thread.ResetAbort(); //scheduler thread itself should not be aborted
                }
            }
            finally
            {
                //reset name of current test case for this thread
                ThreadTracker.ResetTestCase();

                //remove us to the currently running tests
                lock (_TestCaseThreads)
                {
                    _TestCaseThreads.Remove(Thread.CurrentThread);
                }
            }
        }

        private void Pass(string suiteName, TestBase tb, int groupIndex)
        {
            _Results[groupIndex].Pass();
            
            string status = string.Format("{0}\\{1} passed in {2}", tb.Parent.Name, tb.Name, tb.Elapsed.ToString("F3"));
            if (tb.BugId != 0) status += String.Format(" (bugid={0})", tb.BugId);
            CoreGlobal.RO.Success(status);
        }

        private void Fail(string suiteName, TestBase tb, Exception reason, int groupIndex)
        {
            _Results[groupIndex].Fail();

            string status = string.Format("{0}\\{1} FAILED in {2}", tb.Parent.Name, tb.Name, tb.Elapsed.ToString("F3"));            
            if (tb.BugId != 0) status += String.Format(" (bugid={0})", tb.BugId);
            CoreGlobal.RO.Error(status);

            if (reason != null)
            {
                CoreGlobal.RO.Error("Exception:\r\n" + reason.ToString());
            }
        }

        private void UnFail(string suiteName, TestBase tb, int groupIndex)
        {
            _Results[groupIndex].UnFail();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\TestScheduler.cs ===
using System;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Interface for stress test schedulers.  You should be able to implement this, then with only a little gui effort, integrate the new scheduler into STFRunner.
    /// </summary>
    public interface StressTestScheduler
    {
        /// <summary>
        /// Called to set up the scheduler.
        /// </summary>
        /// <param name="schedulerSettings">This can be anything.  Most likely it will be used to pass a custom settings class so you can communicate settings to/from the scheduler.</param>
        void Initialize(StfXmlDoc config, TestSuiteContainer suites, StressJobList jobListReference, object schedulerSettings);
        
        /// <summary>
        /// Shuts down the scheduler.
        /// </summary>
        void Shutdown();

        /// <summary>
        /// This call should block and run tests and block until someone calls Stop.
        /// </summary>
        void Run();

        /// <summary>
        /// Stop running tests.
        /// </summary>
        void Stop();

        /// <summary>
        /// Validates that the current scheduler settings are valid.
        /// </summary>
        /// <returns>true if they are valid</returns>
        bool ValidateParameters();
    }

    /// <summary>
    /// Functional test schedular interface.
    /// </summary>
    public interface TestScheduler
    {
        void Initialize(StfXmlDoc config, TestSuiteContainer suites);
        void Start(TestEventListener listener);
        void Stop();
        bool ValidateParameters();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\ThreadCaseTracker.cs ===
//Tracks which test case every thread belongs to.  Anything that creates a thread should immediately call SetActiveTestCase before doing other work.
//(Note: ThreadBase.cs does this automatically; it is recommended that most test cases make use of that)

namespace ServerTestFramework
{
    public class ThreadTracker
    {
        // -- Public

        //sets which suite/group/case the caller thread belongs to
        public static void SetTest(string suiteName, string groupName, string caseName)
        {
            activeTestSuite=suiteName;
            activeTestGroup=groupName;
            activeTestCase=caseName;

            VerboseOutput();
        }

        //sets the caller thread's suite/group/case to the default
        public static void ResetTest()
        {
            activeTestSuite=DefaultSuiteName;
            activeTestGroup=DefaultGroupName;
            activeTestCase=DefaultCaseName;

            VerboseOutput();
        }

        //sets which suite the caller thread belongs to
        public static void SetTestSuite(string suiteName)
        {
            activeTestSuite=suiteName;

            VerboseOutput();
        }

        //sets the caller thread's suite to the default
        public static void ResetTestSuite()
        {
            activeTestSuite=DefaultSuiteName;

            VerboseOutput();
        }

        //sets which group the caller thread belongs to
        public static void SetTestGroup(string groupName)
        {
            activeTestGroup=groupName;

            VerboseOutput();
        }

        //sets the caller thread's group to the default
        public static void ResetTestGroup()
        {
            activeTestGroup=DefaultGroupName;

            VerboseOutput();
        }

        //sets which case the caller thread belongs to
        public static void SetTestCase(string caseName)
        {
            activeTestCase=caseName;

            VerboseOutput();
        }

        //sets the caller thread's case to the default
        public static void ResetTestCase()
        {
            activeTestCase=DefaultCaseName;

            VerboseOutput();
        }

        //gets the current test this thread belongs to
        public static void GetTest(out string suiteName, out string groupName, out string caseName)
        {
            //if not initialized yet, set to default
            if (activeTestSuite==null || activeTestSuite=="")
            {
                ResetTestSuite();
            }

            if (activeTestGroup==null || activeTestGroup=="")
            {
                ResetTestGroup();
            }
            
            if (activeTestCase==null || activeTestCase=="")
            {
                ResetTestCase();
            }

            //
            suiteName=activeTestSuite;
            groupName=activeTestGroup;
            caseName=activeTestCase;
        }

        //default suite to place unknown threads in
        public static string DefaultSuiteName="_";
        readonly public static string DefaultGroupName="_";
        readonly public static string DefaultCaseName="_";


        // -- Internal

        //which test case the thread belongs to
        [System.ThreadStatic]
        private static string activeTestSuite;
        [System.ThreadStatic]
        private static string activeTestGroup;
        [System.ThreadStatic]
        private static string activeTestCase;

        //Output any changes to debug
        private static void VerboseOutput()
        {
#if false
            Global.RO.Debug("Active test case set to: " + activeTestSuite + "." + activeTestGroup + "." + activeTestCase);
#endif
        }
    };

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\AdminForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for Admin.
	/// </summary>
	public class AdminForm : System.Windows.Forms.Form
	{
		
		private int BldDescriptionChanged = 0;
		private bool BldRenameChanged = false;
		private bool BldDeletChecked = false;
		
		private RegDBQueryManager queryManager;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage DelBuild;
		private System.Windows.Forms.TabPage BuildDis;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.ComboBox BuildcomboBox;
		private System.Windows.Forms.CheckedListBox BuildcheckedList;
		private System.Windows.Forms.Button button6;
		private System.Windows.Forms.Button button7;
		private System.Windows.Forms.TextBox BuildDes;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label9;
		private System.Windows.Forms.Label label10;
		private System.Windows.Forms.TabPage BldRename;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Label label8;
		private System.Windows.Forms.TextBox BLDDescription;
		private System.Windows.Forms.ComboBox RenameBldlist;
		private System.Windows.Forms.TextBox NewbldNo;
		private System.Windows.Forms.TextBox NewItnNo;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public AdminForm(RegDBQueryManager qManager)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
			queryManager=qManager;

			//
			// TODO: Add any constructor code after InitializeComponent call
						
			ReloadBldLists();
			
			BuildcomboBox.SelectedIndex=0;

					

			
		}

		public void ReloadBldLists()
		{
			BuildList bl =  queryManager.GetBuildList();
			BuildcomboBox.Items.Clear();
			BuildcheckedList.Items.Clear();
			RenameBldlist.Items.Clear();
			foreach (Build b in bl)
				if (b.BuildName.Trim() != "")
				{
					BuildcomboBox.Items.Add(b);
					BuildcheckedList.Items.Add(b);
					RenameBldlist.Items.Add(b);
				}
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.BuildDis = new System.Windows.Forms.TabPage();
			this.BuildDes = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.BuildcomboBox = new System.Windows.Forms.ComboBox();
			this.label4 = new System.Windows.Forms.Label();
			this.BldRename = new System.Windows.Forms.TabPage();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.BLDDescription = new System.Windows.Forms.TextBox();
			this.label8 = new System.Windows.Forms.Label();
			this.label9 = new System.Windows.Forms.Label();
			this.NewbldNo = new System.Windows.Forms.TextBox();
			this.NewItnNo = new System.Windows.Forms.TextBox();
			this.label10 = new System.Windows.Forms.Label();
			this.RenameBldlist = new System.Windows.Forms.ComboBox();
			this.label7 = new System.Windows.Forms.Label();
			this.DelBuild = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.BuildcheckedList = new System.Windows.Forms.CheckedListBox();
			this.button6 = new System.Windows.Forms.Button();
			this.button7 = new System.Windows.Forms.Button();
			this.button1 = new System.Windows.Forms.Button();
			this.panel1 = new System.Windows.Forms.Panel();
			this.panel2 = new System.Windows.Forms.Panel();
			this.tabControl1.SuspendLayout();
			this.BuildDis.SuspendLayout();
			this.BldRename.SuspendLayout();
			this.groupBox1.SuspendLayout();
			this.DelBuild.SuspendLayout();
			this.panel1.SuspendLayout();
			this.panel2.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.Add(this.BuildDis);
			this.tabControl1.Controls.Add(this.BldRename);
			this.tabControl1.Controls.Add(this.DelBuild);
			this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.tabControl1.Location = new System.Drawing.Point(0, 0);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(360, 254);
			this.tabControl1.TabIndex = 0;
			this.tabControl1.SelectedIndexChanged += new System.EventHandler(this.tabControl1_SelectedIndexChanged);
			// 
			// BuildDis
			// 
			this.BuildDis.Controls.Add(this.BuildDes);
			this.BuildDis.Controls.Add(this.label3);
			this.BuildDis.Controls.Add(this.BuildcomboBox);
			this.BuildDis.Controls.Add(this.label4);
			this.BuildDis.Location = new System.Drawing.Point(4, 22);
			this.BuildDis.Name = "BuildDis";
			this.BuildDis.Size = new System.Drawing.Size(352, 228);
			this.BuildDis.TabIndex = 1;
			this.BuildDis.Text = "Build Description";
			// 
			// BuildDes
			// 
			this.BuildDes.Location = new System.Drawing.Point(40, 104);
			this.BuildDes.MaxLength = 50;
			this.BuildDes.Multiline = true;
			this.BuildDes.Name = "BuildDes";
			this.BuildDes.Size = new System.Drawing.Size(296, 72);
			this.BuildDes.TabIndex = 7;
			this.BuildDes.Text = "";
			this.BuildDes.TextChanged += new System.EventHandler(this.BuildDes_TextChanged);
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(16, 80);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(80, 16);
			this.label3.TabIndex = 6;
			this.label3.Text = "Description:";
			// 
			// BuildcomboBox
			// 
			this.BuildcomboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.BuildcomboBox.Items.AddRange(new object[] {
															   "00.00.0000",
															   "01.00.0000",
															   "02.00.0000",
															   "02.00.0458"});
			this.BuildcomboBox.Location = new System.Drawing.Point(40, 40);
			this.BuildcomboBox.Name = "BuildcomboBox";
			this.BuildcomboBox.Size = new System.Drawing.Size(120, 21);
			this.BuildcomboBox.TabIndex = 5;
			this.BuildcomboBox.SelectedIndexChanged += new System.EventHandler(this.BuildcomboBox_SelectedIndexChanged);
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(16, 16);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(40, 16);
			this.label4.TabIndex = 4;
			this.label4.Text = "Build:";
			// 
			// BldRename
			// 
			this.BldRename.Controls.Add(this.groupBox1);
			this.BldRename.Controls.Add(this.RenameBldlist);
			this.BldRename.Controls.Add(this.label7);
			this.BldRename.Location = new System.Drawing.Point(4, 22);
			this.BldRename.Name = "BldRename";
			this.BldRename.Size = new System.Drawing.Size(352, 196);
			this.BldRename.TabIndex = 3;
			this.BldRename.Text = "Rename Build";
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.Add(this.BLDDescription);
			this.groupBox1.Controls.Add(this.label8);
			this.groupBox1.Controls.Add(this.label9);
			this.groupBox1.Controls.Add(this.NewbldNo);
			this.groupBox1.Controls.Add(this.NewItnNo);
			this.groupBox1.Controls.Add(this.label10);
			this.groupBox1.Location = new System.Drawing.Point(16, 48);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(312, 136);
			this.groupBox1.TabIndex = 13;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Rename To:-";
			// 
			// BLDDescription
			// 
			this.BLDDescription.Location = new System.Drawing.Point(80, 88);
			this.BLDDescription.MaxLength = 50;
			this.BLDDescription.Multiline = true;
			this.BLDDescription.Name = "BLDDescription";
			this.BLDDescription.Size = new System.Drawing.Size(208, 40);
			this.BLDDescription.TabIndex = 14;
			this.BLDDescription.Text = "";
			this.BLDDescription.TextChanged += new System.EventHandler(this.BLDDescription_TextChanged);
			// 
			// label8
			// 
			this.label8.Location = new System.Drawing.Point(16, 88);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(64, 16);
			this.label8.TabIndex = 13;
			this.label8.Text = "Description";
			// 
			// label9
			// 
			this.label9.Location = new System.Drawing.Point(16, 24);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(64, 16);
			this.label9.TabIndex = 9;
			this.label9.Text = "Build #";
			// 
			// NewbldNo
			// 
			this.NewbldNo.Location = new System.Drawing.Point(80, 24);
			this.NewbldNo.MaxLength = 10;
			this.NewbldNo.Name = "NewbldNo";
			this.NewbldNo.Size = new System.Drawing.Size(208, 20);
			this.NewbldNo.TabIndex = 11;
			this.NewbldNo.Text = "";
			this.NewbldNo.TextChanged += new System.EventHandler(this.NewbldNo_TextChanged);
			// 
			// NewItnNo
			// 
			this.NewItnNo.Location = new System.Drawing.Point(80, 56);
			this.NewItnNo.MaxLength = 5;
			this.NewItnNo.Name = "NewItnNo";
			this.NewItnNo.Size = new System.Drawing.Size(208, 20);
			this.NewItnNo.TabIndex = 12;
			this.NewItnNo.Text = "";
			this.NewItnNo.TextChanged += new System.EventHandler(this.NewItnNo_TextChanged);
			// 
			// label10
			// 
			this.label10.Location = new System.Drawing.Point(16, 56);
			this.label10.Name = "label10";
			this.label10.Size = new System.Drawing.Size(64, 16);
			this.label10.TabIndex = 10;
			this.label10.Text = "Iteration #";
			// 
			// RenameBldlist
			// 
			this.RenameBldlist.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.RenameBldlist.Location = new System.Drawing.Point(72, 16);
			this.RenameBldlist.Name = "RenameBldlist";
			this.RenameBldlist.Size = new System.Drawing.Size(120, 21);
			this.RenameBldlist.TabIndex = 7;
			this.RenameBldlist.SelectedIndexChanged += new System.EventHandler(this.RenameBldlist_SelectedIndexChanged);
			// 
			// label7
			// 
			this.label7.Location = new System.Drawing.Point(16, 16);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(40, 16);
			this.label7.TabIndex = 6;
			this.label7.Text = "Build:";
			// 
			// DelBuild
			// 
			this.DelBuild.Controls.Add(this.label5);
			this.DelBuild.Controls.Add(this.BuildcheckedList);
			this.DelBuild.Location = new System.Drawing.Point(4, 22);
			this.DelBuild.Name = "DelBuild";
			this.DelBuild.Size = new System.Drawing.Size(352, 196);
			this.DelBuild.TabIndex = 0;
			this.DelBuild.Text = "Delete Build";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(16, 16);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(144, 16);
			this.label5.TabIndex = 1;
			this.label5.Text = "Select builds to delete:";
			// 
			// BuildcheckedList
			// 
			this.BuildcheckedList.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.BuildcheckedList.Location = new System.Drawing.Point(40, 40);
			this.BuildcheckedList.Name = "BuildcheckedList";
			this.BuildcheckedList.Size = new System.Drawing.Size(168, 139);
			this.BuildcheckedList.TabIndex = 0;
			this.BuildcheckedList.SelectedIndexChanged += new System.EventHandler(this.BuildcheckedList_SelectedIndexChanged);
			this.BuildcheckedList.ItemCheck += new System.Windows.Forms.ItemCheckEventHandler(this.BuildcheckedList_ItemCheck);
			// 
			// button6
			// 
			this.button6.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button6.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.button6.Location = new System.Drawing.Point(208, 8);
			this.button6.Name = "button6";
			this.button6.Size = new System.Drawing.Size(72, 24);
			this.button6.TabIndex = 13;
			this.button6.Text = "Cancel";
			this.button6.Click += new System.EventHandler(this.button6_Click);
			// 
			// button7
			// 
			this.button7.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button7.Enabled = false;
			this.button7.Location = new System.Drawing.Point(288, 8);
			this.button7.Name = "button7";
			this.button7.Size = new System.Drawing.Size(72, 24);
			this.button7.TabIndex = 12;
			this.button7.Text = "Apply";
			this.button7.Click += new System.EventHandler(this.button7_Click);
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button1.Location = new System.Drawing.Point(128, 8);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(72, 24);
			this.button1.TabIndex = 14;
			this.button1.Text = "OK";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.button7);
			this.panel1.Controls.Add(this.button6);
			this.panel1.Controls.Add(this.button1);
			this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.panel1.Location = new System.Drawing.Point(8, 262);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(360, 32);
			this.panel1.TabIndex = 15;
			this.panel1.Paint += new System.Windows.Forms.PaintEventHandler(this.panel1_Paint);
			// 
			// panel2
			// 
			this.panel2.Controls.Add(this.tabControl1);
			this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel2.Location = new System.Drawing.Point(8, 8);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(360, 254);
			this.panel2.TabIndex = 17;
			// 
			// AdminForm
			// 
			this.AcceptButton = this.button1;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.button6;
			this.ClientSize = new System.Drawing.Size(376, 302);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel1);
			this.DockPadding.All = 8;
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AdminForm";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Admin";
			this.Load += new System.EventHandler(this.AdminForm_Load);
			this.tabControl1.ResumeLayout(false);
			this.BuildDis.ResumeLayout(false);
			this.BldRename.ResumeLayout(false);
			this.groupBox1.ResumeLayout(false);
			this.DelBuild.ResumeLayout(false);
			this.panel1.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void AdminForm_Load(object sender, System.EventArgs e)
		{
		
		}

		private void BuildcheckedList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
		
		}

		private void BuildcomboBox_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			//MessageBox.Show(BuildcomboBox.SelectedIndex.ToString());
			if(((Build)BuildcomboBox.SelectedItem).BuildDescription !=null)
				BuildDes.Text=((Build)BuildcomboBox.SelectedItem).BuildDescription.Trim();
			else 
				BuildDes.Text="";
		}

		private void tabControl1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			//MessageBox.Show("Tab changed ","Warning",MessageBoxButtons.OKCancel);
		}
		

		private void Apply()
		{
			// find out what has changed and update
			BuildList listtoDel = new BuildList();

			if(BldRenameChanged)
			{
				((Build)RenameBldlist.SelectedItem).BuildName=NewbldNo.Text.Trim()+"("+NewItnNo.Text.Trim()+")";;
				((Build)RenameBldlist.SelectedItem).BuildDescription= BLDDescription.Text.Trim();
				int itnnO =System.Convert.ToInt32(NewItnNo.Text);
				queryManager.ReNameBuild(((Build)RenameBldlist.SelectedItem).ID,NewbldNo.Text.Trim(),itnnO,BLDDescription.Text.Trim());
				
				BldRenameChanged= false;
				int preselectedIndex= RenameBldlist.SelectedIndex;
				ReloadBldLists();
				RenameBldlist.SelectedIndex=preselectedIndex;
			}
			if(BldDescriptionChanged >1)
			{
				((Build)BuildcomboBox.SelectedItem).BuildDescription = BuildDes.Text.Trim(); 
				queryManager.UpdateIterationDescription(((Build)BuildcomboBox.SelectedItem).ID,BuildDes.Text.Trim());
				
				BldDescriptionChanged= 1;
			}

			if(BldDeletChecked)
			{
				foreach(Build itemChecked in BuildcheckedList.CheckedItems) 
				{
					DialogResult result;
					string  temp =" Do you want to Delete  Build :-"+ itemChecked.ToString()+" Description :- "+itemChecked.BuildDescription;

					result = MessageBox.Show(temp,"Warning",MessageBoxButtons.YesNo);
					if(result == DialogResult.Yes)
					{
						queryManager.DeleteBuild(itemChecked.ID);
						listtoDel.Add(itemChecked);
					}
				}

				foreach(Build itemChecked in listtoDel)
				{
					BuildcheckedList.Items.Remove(itemChecked);
				}
				foreach(int itemChecked in BuildcheckedList.CheckedIndices)
				{
					BuildcheckedList.SetItemChecked(itemChecked,false);
				}
				
				BldDeletChecked = false;
				ReloadBldLists();
			}

			RefreshChanged();
		}

		private void button7_Click(object sender, System.EventArgs e)
		{
			Apply();
		}

		private void button6_Click(object sender, System.EventArgs e)
		{
			Close();
		}

		private void RefreshChanged()
		{
				button7.Enabled = BldDescriptionChanged>1 ||  BldDeletChecked||BldRenameChanged;
		}

		private void BuildDes_TextChanged(object sender, System.EventArgs e)
		{
			BldDescriptionChanged ++;
			if(BldDescriptionChanged ==2)
				RefreshChanged();
		}

	

		private void button1_Click(object sender, System.EventArgs e)
		{
			Apply();
			Close();
		}

		private void BuildcheckedList_ItemCheck(object sender, System.Windows.Forms.ItemCheckEventArgs e)
		{
			BldDeletChecked= true;
			RefreshChanged();
		}

		private void RenameBldlist_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			NewbldNo.Text=((Build)RenameBldlist.SelectedItem).BuildName.Substring(0,10);
			NewItnNo.Text=((Build)RenameBldlist.SelectedItem).BuildName.Split(new char[]{'(',')'})[1].Trim();
			//MessageBox.Show(BuildcomboBox.SelectedIndex.ToString());
			if(((Build)RenameBldlist.SelectedItem).BuildDescription !=null)
				{
				BLDDescription.Text=((Build)RenameBldlist.SelectedItem).BuildDescription.Trim();
				}
			else 
				BLDDescription.Text="";
		
		}

		private void NewbldNo_TextChanged(object sender, System.EventArgs e)
		{
			BldRenameChanged= true;;
			RefreshChanged();
		}

		private void NewItnNo_TextChanged(object sender, System.EventArgs e)
		{
			BldRenameChanged= true;;
			RefreshChanged();

		}

		private void BLDDescription_TextChanged(object sender, System.EventArgs e)
		{
			BldRenameChanged= true;;
			RefreshChanged();

		}

		private void label6_Click(object sender, System.EventArgs e)
		{
		
		}

		private void panel1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\TestResult.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// All stats-related variables and calculations for stress testing should go in this class.
    /// </summary>
    public class TestResult
    {
        // Member vars
        private int             passed;
        private int             failed;
        private int             deadlocked;
        private int             skipped;
        private int             in_progress;
        private int             threads;
        private TimeSpan        elapsed;
        private DateTime        startTime;
        private DateTime        endTime;
        private bool            isInStartEndBlock=false; //has Start() been called, but not End() yet?
        private object          threadLock = new object();
        private string          name = "";
        private string          groupname = "";

        private float           tps;
        private RunningAverage  avgShortTps;
        private RunningAverage  avgTps;
        private RunningAverage  avgTps120;
        private RunningAverage  avgPrivateTps;
        private int             lastTotal = 0;
        private int             lastSkipped = 0;
        private float           lastTime = 0;
        private float           targetTps = 0;

        // Accessors
        public int              Passed              {get {return passed;}}
        public int              Failed              {get {return failed;}}
        public int              Deadlocked          {get {return deadlocked;}}
        public int              Skipped             {get {return skipped;}}
        public int              InProgress          {get {return in_progress;}}
        public int              Threads             {get {return threads;}}
        public int              Total               {get {return passed + failed + deadlocked;}}
        public double           PassRate            {get {return (double)passed / Total;}}
        public DateTime         StartTime           {get {return startTime;}}
        public DateTime         EndTime             {get {return endTime;}}
        public TimeSpan         Elapsed             {get {return elapsed;}}
        public TimeSpan         ElapsedTime         {get {return DateTime.Now - startTime;}}
        public float            TotalTime           {get {return (float)(DateTime.Now - startTime).TotalSeconds;}}
        public string           Name                {get {return name;} set {name = value;}}
        public float            TargetTps           {get {return targetTps;} set {targetTps = value;}}
        public string           GroupName           {get {return groupname;} set {groupname = value;}}

        public TestResult() : this("<NoName>")
        {
        }

        public TestResult(string testName)
        {
            name = testName;
            Reset();
        }

        /// <summary>
        /// Start counting elapsed time.  The counter is stopped when End is called.  The Elapsed time is cumulative through Start/End pairs.
        /// </summary>
        public void Start()
        {
            startTime = DateTime.Now;
            isInStartEndBlock=true;
        }

        public void End()
        {
            endTime = DateTime.Now;

            //check that Start was actually called
            if (!isInStartEndBlock)
            {
                CoreGlobal.RO.Warn("TestResult.End() was called without a matching TestResult.Start(), time of run will be wrong");
                startTime = DateTime.Now;
            }

            //
            elapsed += endTime - startTime;
            isInStartEndBlock=false;
        }

        public void Reset()
        {
            passed = 0;
            failed = 0;
            deadlocked = 0;
            skipped = 0;
            in_progress = 0;
            threads = 0;
            elapsed = TimeSpan.Zero;
            startTime = DateTime.Now;
            endTime = startTime;
            isInStartEndBlock=false;
            tps = 0;
            avgShortTps = new RunningAverage(5);
            avgTps = new RunningAverage(20);
            avgTps120 = new RunningAverage(120);
            avgPrivateTps = new RunningAverage(20);
            targetTps = 0;
        }

        public void Pass()
        {
            Interlocked.Increment(ref passed);
        }

        public void Fail()
        {
            Interlocked.Increment(ref failed);
        }

        public void UnFail() //for a test that failed on the first try, but succeeded later
        {
            Interlocked.Decrement(ref failed);
        }
        
        public void Deadlock()
        {
            Interlocked.Increment(ref deadlocked);
        }

        public void Skip()
        {
            Interlocked.Increment(ref skipped);
        }

        /// <summary>
        /// Increases the count of in progress test runs.
        /// </summary>
        public void BeginInProgress ()
        {
            Interlocked.Increment(ref in_progress);
        }

        /// <summary>
        /// Decreases the count of in progress test runs.
        /// </summary>
        public void EndInProgress ()
        {
            int init, calc;

            do
            {
                init = in_progress;

                if (init == 0)
                {
                    break;
                }
                else if (init < 0)
                {
                    calc = 0;
                }
                else
                {
                    calc = init - 1;
                }
            } while (init != Interlocked.CompareExchange(ref in_progress, calc, init));
        }

        public void AddThread()
        {
            Interlocked.Increment(ref threads);
        }

        public void SubtractThread()
        {
            Interlocked.Decrement(ref threads);
        }

        public void TakeSample()
        {
            lock (threadLock)
            {
                int transactions = Total - lastTotal;
                int totaltransactions = (Skipped - lastSkipped) + transactions;
                float secondsTotal = TotalTime - lastTime;

                if (secondsTotal > 0)
                {
                    tps = (float)transactions / secondsTotal;
                    float tpsTotal = (float)totaltransactions / secondsTotal;

                    avgShortTps.Add(tps);
                    avgTps.Add(tps);
                    avgTps120.Add(tps);
                    avgPrivateTps.Add(tpsTotal);
                }

                lastTotal = Total;
                lastSkipped = Skipped;
                lastTime = TotalTime;
            }
        }

        public float TotalTPS()
        {
            return ((float)Total / TotalTime);
        }

        public float TotalPrivateTPS()
        {
            return ((float)(Total + Skipped) / TotalTime);
        }

        public float TPS()
        {
            return (tps);
        }

        public float RunningShortTPS()
        {
            return ((float)avgShortTps.Get());
        }

        public float RunningTPS()
        {
            return ((float)avgTps.Get());
        }

        public float RunningTPS120()
        {
            return ((float)avgTps120.Get());
        }

        public float RunningPrivateTPS()
        {
            return ((float)avgPrivateTps.Get());
        }

        public string GetStatusLine()
        {
            TimeSpan elapsedSpan = ElapsedTime;
            string elapsedTime=
                elapsedSpan.Days.ToString()+"d"+
                elapsedSpan.Hours.ToString("D2")+":"+
                elapsedSpan.Minutes.ToString("D2")+":"+
                elapsedSpan.Seconds.ToString("D2");
            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("[" + Name + "]");
            sb.Append(" | Pass: " + Passed.ToString().PadLeft(7));
            sb.Append(" | Fail: " + Failed.ToString().PadLeft(4));
            sb.Append(" | Dead: " + Deadlocked.ToString().PadLeft(2));
            sb.Append(" | Skip: " + Skipped.ToString().PadLeft(3));
            sb.Append(" | Time: " + elapsedTime);
            sb.Append(" | Tps10: " + RunningTPS().ToString("F2").PadLeft(6));
            sb.Append(" | Rate: " + (PassRate*100).ToString("F1"));
            sb.Append(" | TpsPriv: " + RunningPrivateTPS().ToString("F2").PadLeft(6));
            return sb.ToString();
        }

        public string GetStatusHtmlRow()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("<tr>\r\n");
            sb.Append("  <td>" + Name + "</td>\r\n");
            sb.Append("  <td>" + Total + "</td>\r\n");
            sb.Append("  <td>" + (PassRate*100).ToString("F1") + "</td>\r\n");
            sb.Append("  <td><font color=");
            if (this.RunningTPS() >= TargetTps)
                sb.Append("green>");
            else
                sb.Append("red>");
            sb.Append(this.RunningTPS().ToString("f2")+"</font></td>\r\n");
            sb.Append("  <td>" + TargetTps.ToString("f2") + "</td>\r\n");
            sb.Append("  <td>" + this.RunningPrivateTPS().ToString("f2")+"</td>\r\n");
            sb.Append("</tr>\r\n");
            return sb.ToString();
        }

    }

    /// <summary>
    /// Represents a collection of TestResult objects and provides methods for calculating summary values
    /// </summary>
    public class TestResultCollection : CollectionBase, IEnumerable
    {
        private DateTime    startTime;
        private bool        bStarted = false;

        public TimeSpan     ElapsedTime { get { return DateTime.Now - startTime;}}

        /// <summary>
        /// Creates a new TestResult and adds it to the collection
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public TestResult CreateTestResult(string name)
        {
            if (!bStarted)
            {
                Start();
            }
                
            TestResult r = new TestResult(name);
            List.Add(r);
            return r;
        }

        /// <summary>
        /// Add existing TestResult to collection
        /// </summary>
        /// <param name="r"></param>
        public void AddTestResult(TestResult r)
        {
            if (!bStarted)
            {
                Start();
            }
            List.Add(r);
        }

        public void Start()
        {
            startTime = DateTime.Now;
            bStarted = true;
        }

        public int TotalPassed 
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Passed;
                }
                return v;
            }
        }
                
        public int TotalFailed
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Failed;
                }
                return v;
            }
        }
                
        public int TotalDeadlocked
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Deadlocked;
                }
                return v;
            }
        }
                        
        public int TotalSkipped
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Skipped;
                }
                return v;
            }
        }
                
        public int Total
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Total;
                }
                return v;
            }
        }
                
        public float TotalPassRate
        { 
            get 
            {
                return (float)TotalPassed / Total;
            }
        }

        public float TotalTPS()
        {
            float v = 0;
            foreach (TestResult r in List)
            {
                v += r.TotalTPS();
            }
            return v;
        }

        public float TotalRunningTPS()
        {
            float v = 0;
            foreach (TestResult r in List)
            {
                v += r.RunningTPS();
            }
            return v;
        }

        // Does this make sense?
        public float TotalRunningPrivateTPS()
        {
            float v = 0;
            foreach (TestResult r in List)
            {
                v += r.RunningPrivateTPS();
            }
            return v;
        }

        public string GetStatusLine()
        {
            TimeSpan elapsedSpan = ElapsedTime;
            string elapsedTime=
                elapsedSpan.Days.ToString()+"d"+
                elapsedSpan.Hours.ToString("D2")+":"+
                elapsedSpan.Minutes.ToString("D2")+":"+
                elapsedSpan.Seconds.ToString("D2");
            string status = "Pass: " + TotalPassed.ToString().PadLeft(7)+
                " | Fail: " + TotalFailed.ToString().PadLeft(4)+
                " | Dead: " + TotalDeadlocked.ToString().PadLeft(2)+
                " | Skip: " + TotalSkipped.ToString().PadLeft(3)+
                " | Time: " + elapsedTime +
                " | Tps10: " + TotalRunningTPS().ToString("F2").PadLeft(6)+
                " | Rate: " + TotalPassRate.ToString("F1") +
                " | TpsPriv: " + TotalRunningPrivateTPS().ToString("F2").PadLeft(6);
            return status;
        }

        public string GetStatusHtmlTable_Summary()
        {
            TimeSpan elapsed = ElapsedTime;
            string shortElapsed=elapsed.Days+"."+elapsed.Hours+":"+elapsed.Minutes+":"+elapsed.Seconds;

            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("<p>Total Summary<br>\r\n");
            sb.Append("<table border=1 cellspacing=0 cellpadding=2>\r\n");
            sb.Append("<tr><td>Passed</td><td>"+TotalPassed+"</td></tr>\r\n");
            sb.Append("<tr><td>Failed</td><td>"+TotalFailed+"</td></tr>\r\n");
            sb.Append("<tr><td>Total transactions</td><td>"+Total+"</td></tr>\r\n");
            sb.Append("<tr><td>Time</td><td>"+shortElapsed+"</td></tr>\r\n");
            sb.Append("<tr><td>TPS</td><td>"+TotalRunningTPS().ToString("F2")+"</td></tr>\r\n");
            sb.Append("<tr><td>Pass rate</td><td>"+(TotalPassRate*100).ToString("F2")+"%</td></tr>\r\n");
            sb.Append("<tr><td>Private TPS</td><td>"+TotalRunningPrivateTPS().ToString("F2")+"</td></tr>\r\n");
            sb.Append("</table></p>\r\n");

            return sb.ToString();
        }

        public string GetStatusHtmlTable_Detail()
        {            
            double totalTargetTPS = 0;
            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("<p>Details<br>\r\n");
            sb.Append("<table border=1 cellspacing=0 cellpadding=2>\r\n");
            sb.Append("<tr><td>API name</td><td>Transactions</td><td>Pass rate</td><td>TPS</td><td>Target TPS</td><td>Private TPS</td></tr>\r\n");
            foreach (TestResult result in List)
            {
                totalTargetTPS += result.TargetTps;

                if (result.Total == 0)
                    continue; // If this API test has not been executed, I don't want it cluttering the result file
					
                sb.Append(result.GetStatusHtmlRow());
            }
            sb.Append("</table>\r\n");
            
            return sb.ToString();
        }
        
        public string GetStatusHtmlTable()
        {
            return GetStatusHtmlTable_Summary() + "\r\n" + GetStatusHtmlTable_Detail();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFCoreOld\Runner\TestSuiteContainer.cs ===
using System;
using System.IO;
using System.Collections;
using System.Xml;
using System.Web;
using System.Web.Hosting;
using System.Reflection;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    public class TestSuiteContainer
    {
        // Event arguments when a new suite is added
        public class AddSuiteEventArgs
        {
            public TestSuite Suite;
            public string Path;

            public AddSuiteEventArgs(TestSuite suite, string path) 
            {
                Suite = suite;
                Path = path;
            }
        }

        public class RemoveSuiteEventArgs
        {
            public string Name;
            public RemoveSuiteEventArgs(String name)
            {
                Name = name;
            }
        }

        // the delegate signature
        public delegate void AddSuiteEventHandler(object sender, AddSuiteEventArgs e);
        public delegate void RemoveSuiteEventHandler(object sender, RemoveSuiteEventArgs e);

        // the event to wire
        public event AddSuiteEventHandler SuiteAdded;
        public event RemoveSuiteEventHandler SuiteRemoved;

        
        protected virtual void OnSuiteAdded(AddSuiteEventArgs args)
        {
            if (SuiteAdded != null) 
            {
                //Invokes the delegates.
                SuiteAdded(this, args); 
            }
        }

        protected virtual void OnSuiteRemoved(RemoveSuiteEventArgs args)
        {
            if (SuiteRemoved != null) 
            {
                //Invokes the delegates.
                SuiteRemoved(this, args); 
            }
        }

        private class Context
        {
            public bool Enabled;
            public string fullPath;
            public TestSuite Suite;
            public AppDomain Domain;
        }

        private Hashtable _SuiteContexts;
        private string _BaseDir;
        private FileSystemWatcher _Watcher;

        public bool IsolateTestSuites;
        public bool AspxHostedTestSuites = false;

        public int Count
        {
            get
            {
                return _SuiteContexts.Count;
            }
        }

        public string BaseDirectory
        {
            get
            {
                return _BaseDir;
            }
        }
        
        public TestSuiteContainer()
        {
            _SuiteContexts = new Hashtable();
            _BaseDir = Directory.GetCurrentDirectory() + "\\Suites";

            // Install a file watcher that will auto load newly deployed test
            // suite DLLs.
            if(Directory.Exists(_BaseDir))
            {
                _Watcher = new FileSystemWatcher(_BaseDir);
                _Watcher.Filter = "*.DLL";
                _Watcher.Created += new FileSystemEventHandler(DllDeployEvent);
                _Watcher.EnableRaisingEvents = true;
            }
        }

        public TestSuite[] GetLoadedSuites()
        {
            ArrayList suites = new ArrayList(_SuiteContexts.Count);
            foreach(Context context in _SuiteContexts.Values)
            {
                suites.Add(context.Suite);
            }
            TestSuite[] ret = (TestSuite[])suites.ToArray(typeof(TestSuite));
            return ret;
        }

        public TestSuite[] GetEnabledSuites()
        {
            ArrayList suites = new ArrayList(_SuiteContexts.Count);
            foreach(Context context in _SuiteContexts.Values)
            {
                if(context.Enabled)
                    suites.Add(context.Suite);
            }
            TestSuite[] ret = (TestSuite[])suites.ToArray(typeof(TestSuite));
            return ret;
        }

        public void LoadAllSuitesInPath(string path)
        {
            if (Directory.Exists(path))
            {
                CoreGlobal.RO.Info("Searching: {0} for test suites", path);

                foreach (string file in Directory.GetFiles(path, "*.dll"))
                {
                    LoadFile(Path.GetFullPath(file));
                }
            }
        } 

        public void LoadFiles(string[] files)
        {
            foreach (string file in files)
            {
                if (file.EndsWith(".dll"))
                {
                    LoadFile(Path.GetFullPath(file));
                }
            }
        }

        public void SearchForSuites(XmlDocument config)
        {
            ArrayList al = new ArrayList();

            foreach (XmlNode node in config.SelectNodes("/stf/tests/suite"))
            {
                XmlAttribute searchAttr = node.Attributes["search"];
                XmlAttribute nameAttr = node.Attributes["name"];
                if (searchAttr != null && nameAttr != null)
                    al.Add(searchAttr.Value + "\\" + nameAttr.Value + ".dll");
            }

            LoadFiles((string[])al.ToArray(typeof(string)));
        }

        public void LoadAllDeployedSuites()
        {
            LoadAllSuitesInPath(_BaseDir);
        }

        public void UnloadSuite(string suiteName)
        {
            if(IsolateTestSuites)
            {
                Context context = _SuiteContexts[suiteName] as Context;
                if(context != null)
                {
                    try
                    {
                        AppDomain.Unload(context.Domain);
                        _SuiteContexts.Remove(suiteName);
                        OnSuiteRemoved(new RemoveSuiteEventArgs(suiteName));
                    }
                    catch(CannotUnloadAppDomainException ex)
                    {
                        CoreGlobal.RO.Error("Could not unload the app domain: " + suiteName + ", reason: " + ex.GetType().FullName + ": " + ex.Message);
                    }
                }
            }
        }

        public void LoadFile(string fullPath)
        {
            string errorMessage;
            string asmSimpleName = Path.GetFileNameWithoutExtension(fullPath);
            string dllPath = Path.GetFullPath(fullPath);
            Context context = new Context();

            {
                context.Domain = AppDomain.CurrentDomain;

                LocalTestSuiteLoader localLoader = new LocalTestSuiteLoader();
                context.Suite = localLoader.LoadTestSuite(fullPath, out errorMessage);
                context.fullPath = fullPath;
            }

            // if we have successfully loaded the suite the Suite member will be set.
            // this is a bit hacky but since we need to be able to probe directories
            // errors returned from a remote app domain can be trick to handle so I let
            // the loaders handle exception handling and give an error string on failure
            if(context.Suite == null)
            {
                // some DLLs are just not test suite assemblies (servertestframework.dll)
                // they will not have a reason for failing load
                if(errorMessage != "")
                {
                    CoreGlobal.RO.Error("A test suite could not be loaded. Path: " + fullPath + ", Reason: " + errorMessage);
                }
            }
            else
            {
                // index by name
                _SuiteContexts[context.Suite.Name] = context;

                // fire the event to notify listeners that a new suite was added
                AddSuiteEventArgs args = new AddSuiteEventArgs(context.Suite, fullPath);
                OnSuiteAdded(args);
            }
        }

        public void DisableAll()
        {
            foreach(Context ctx in _SuiteContexts.Values)
                ctx.Enabled = false;
        }

        public void EnableAll()
        {
            foreach(Context ctx in _SuiteContexts.Values)
                ctx.Enabled = true;
        }

        public void Enable(string name)
        {
            Context ctx = _SuiteContexts[name] as Context;
            if(ctx != null)
                ctx.Enabled = true;
        }

        public bool Contains(string name)
        {
            return (_SuiteContexts[name] != null);
        }

        public AppDomain LookupAppDomainForTestSuite(string suiteName)
        {
            Context ctx = _SuiteContexts[suiteName] as Context;
            if(ctx != null)
            {
                return ctx.Domain;
            }
            else
            {
                return null;
            }
            
        }

        private void SetAppDomainPolicy(AppDomain domain)
        {
            // create the policy level
            PolicyLevel polLevel = PolicyLevel.CreateAppDomainLevel();
            UnionCodeGroup rootCodeGroup;
            PermissionSet permSet = new PermissionSet(PermissionState.None);
            permSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.Execution));
            rootCodeGroup = new UnionCodeGroup(new AllMembershipCondition(),
                new PolicyStatement(permSet, PolicyStatementAttribute.Nothing));
            
            // limit all code on this machine to local intranet permissions in this app domain
            NamedPermissionSet localInternet = FindNamedPermissionSet("LocalInternet");
            UnionCodeGroup virtualInternet = new UnionCodeGroup(
                new ZoneMembershipCondition(SecurityZone.MyComputer),
                new PolicyStatement(localInternet, PolicyStatementAttribute.Nothing));
            virtualInternet.Name = "Virtual Internet";

            // add the code groups to the policy level
            rootCodeGroup.AddChild(virtualInternet);
            polLevel.RootCodeGroup = rootCodeGroup;
            domain.SetAppDomainPolicy(polLevel);
        }

        private NamedPermissionSet FindNamedPermissionSet(string name)
        {
            IEnumerator policyEnumerator = SecurityManager.PolicyHierarchy();
            while(policyEnumerator.MoveNext())
            {
                PolicyLevel currentLevel = (PolicyLevel)policyEnumerator.Current;

                if(currentLevel.Label == "Machine")
                {
                    IList namedPermissions = currentLevel.NamedPermissionSets;
                    IEnumerator namedPermission = namedPermissions.GetEnumerator();
                    
                    while(namedPermission.MoveNext())
                    {
                        if(((NamedPermissionSet)namedPermission.Current).Name == name)
                        {
                            return ((NamedPermissionSet)namedPermission.Current);
                        }
                    }
                }
            }
            return null;
        }

        private void DllDeployEvent(object sender, FileSystemEventArgs e)
        {
            try
            {
                if(e.ChangeType == WatcherChangeTypes.Created || e.ChangeType == WatcherChangeTypes.Changed)
                {
                    CoreGlobal.RO.Info("Loading new assembly: " + e.FullPath);                  
                    // load it
                    LoadFile(e.FullPath);
                }
            }
            catch(Exception ex)
            {
                CoreGlobal.RO.Error("Could not auto-deploy DLL: " + ex.GetType().FullName + ": " + ex.Message);
            }
        }

        //finds a suite from the loaded suites (returns null if not found)
        public TestSuite FindTestSuite(string suiteName)
        {
            foreach(Context context in _SuiteContexts.Values)
            {
                TestSuite suite=context.Suite;
                if (suite.Name==suiteName)
                {
                    return suite;
                }
            }

            return null;
        }

        //finds a test group within a specific suite (returns null if not found)
        public TestBaseGroup FindTestGroup(string suiteName, string groupName)
        {
            TestSuite suite=FindTestSuite(suiteName);
            if (suite!=null)
            {
                TestBaseGroupList glist=suite.GetTestsWithPreservation();
                foreach (TestBaseGroup tbg in glist)
                {
                    if (tbg.Name==groupName)
                    {
                        return tbg;
                    }
                }
            }

            return null;
        }

        //finds a test case within a specific suite and group (returns null if not found)
        public TestBase FindTestCase(string suiteName, string groupName, string caseName)
        {
            TestBaseGroup tbg=FindTestGroup(suiteName,groupName);
            if (tbg!=null)
            {
                foreach (TestBase test in tbg)
                {
                    if (test.Name==caseName)
                    {
                        return test;
                    }
                }
            }

            return null;
        }

    } //TestSuiteContainer

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\AsyncButtonClickAction.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Windows.Forms;

namespace STFRunner
{
    public delegate void Action();
    public delegate bool CancelableAction();

    public class AsyncButtonClickAction
    {
        private Action action;
        private Action endAction;
        private CancelableAction funcStart;
        private Action funcStopped;
        private Action funcStatus;
        private ButtonCollection btns;

        private Button curButton;
        private string curButtonText;
        private AsyncState state = AsyncState.Stopped;
        private Thread thread;
        private System.Windows.Forms.Timer statusTimer = null;

        public int TimerInterval
        {
            get {return statusTimer.Interval;}
            set {statusTimer.Interval=value;}
        }

        public AsyncState State {get {return state;}}

        public AsyncButtonClickAction(Action action, Action endAction, ButtonCollection btns, CancelableAction funcStart, Action funcStopped, Action funcStatus)
        {
            statusTimer = new System.Windows.Forms.Timer();
            statusTimer.Interval = 1000;
            statusTimer.Tick += new EventHandler(Status);

            this.action = action;
            this.endAction = endAction;
            this.btns = btns;
            this.funcStart = funcStart;
            this.funcStatus = funcStatus;
            this.funcStopped = funcStopped;
            
            
            if( btns != null )
            {
                foreach (Button b in btns)
                    b.Click += new EventHandler(Click);
            }
        }

        public AsyncButtonClickAction(Action action, Action endAction, Button btn, CancelableAction funcStart, Action funcStopped, Action funcStatus) : this(action, endAction, (ButtonCollection)null, funcStart, funcStopped, funcStatus)
        {
            btns = new ButtonCollection();
            btns.Add(btn);
            btn.Click += new EventHandler(Click);
        }

        private void Click(object sender, EventArgs args)
        {
            Debug.Assert(state == AsyncState.Started || state == AsyncState.Stopped, "Click should not be hit when not in stopped or started state");

            if (state == AsyncState.Started)
                Stop(sender, args);
            else
                Start(sender, args);
        }

        private void ThreadStartMarshaller()
        {
            action();
        }

        public void Start(object sender, EventArgs e)
        {
            lock (this)
            {
                if (!(sender is Button))
                    throw new Exception("Event must be sent from a button.");

                if (funcStart != null)
                {
                    if (!funcStart())
                        return;
                }

                Debug.Assert(curButton == null);
                curButton = (Button)sender;
                curButtonText = curButton.Text;

                foreach (Button b in btns)
                    b.Enabled = false;
                if (curButton != null)
                {
                    curButton.Text = "Stop";
                    curButton.Enabled = true;
                }

                state = AsyncState.Started;

                thread = new Thread(new ThreadStart(ThreadStartMarshaller));
                thread.Start();

                if (statusTimer != null)
                    statusTimer.Start();
            }
        }

        public void Stop(object sender, EventArgs e)
        {
            lock (this)
            {
                if (curButton != null)
                {
                    curButton.Enabled = false;
                    curButton.Text = "Stopping...";
                }

                state = AsyncState.Stopping;

                if (endAction != null)
                {
                    //do this from another thread so we don't lockup the gui handle
                    Thread t=new Thread(new ThreadStart(endAction));
                    t.Start();
                }
            }
        }

        private void Status(object sender, EventArgs args)
        {
            lock (this)
            {
                if (funcStatus != null)
                    funcStatus();

                if (thread.ThreadState == System.Threading.ThreadState.Stopped)
                {
                    statusTimer.Stop();

                    if (curButton != null)
                    {
                        curButton.Text = curButtonText;
                    }
                    curButton = null;
                    foreach (Button b in btns)
                        b.Enabled = true;

                    if (funcStopped != null)
                        funcStopped();

                    state = AsyncState.Stopped;
                }
            }
        }
    }

    public class ButtonCollection : CollectionBase, IEnumerable
    {
        public void Add(Button b)
        {
            List.Add(b);
        }
        
        public Button this[int index]
        {
            get
            {
                return (Button)List[index];
            }
            set
            {
                List[index] = value;
            }
        }    
    }

    public enum AsyncState
    {
        Stopped,
        Started,
        Stopping
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\ControlTree.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows.Forms;
using ServerTestFramework.Reporting;

namespace RegDBViewer
{
	public class ControlTree : System.Windows.Forms.ListBox
	{
		static Brush passBrush = new SolidBrush(Color.Green);
		static Brush failBrush = new SolidBrush(Color.Red);
		static Brush linkBrush = new SolidBrush(Color.Blue);
		private ToolTip toolTip = new ToolTip();

		private System.ComponentModel.Container components = null;

		public ControlTree()
		{
			InitializeComponent();
		}

		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if( components != null )
					components.Dispose();
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// ControlTree
			// 
			this.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;

		}
		#endregion

		protected override void OnDrawItem(DrawItemEventArgs e)
		{
			if (e.Index == -1 || e.Index >= Items.Count)
				return;
			DrawAnItem(e, (ItemRow)Items[e.Index]);
		}

		static private int Clamp(float c) {return Math.Min(Math.Max(0, (int)c), 255);}

		static private Color GetItemBackColor(DrawItemEventArgs e, ItemRow item)
		{
			float rColScale = ((float)Math.Pow(0.93, item.Depth));
			float gColScale = ((float)Math.Pow(0.93, item.Depth));
			float bColScale = ((float)Math.Pow(0.93, item.Depth));

			Color col = e.BackColor;
			int cMod = e.Index % 2 == 0 ? 6 : 0;

			return Color.FromArgb(
				Clamp((rColScale*col.R)-cMod), 
				Clamp((gColScale*col.G)-cMod), 
				Clamp(bColScale*col.B));
		}

		static public void DrawAnItem(DrawItemEventArgs e, ItemRow item)
		{
			Font font = e.Font;
			if (item != null && item.Depth == 0)
				font = new Font(e.Font, e.Font.Style | FontStyle.Bold);

			string pass, fail, total, rate;
			if (item == null)
			{
				item = new ItemRow();
				pass = "Passed:";
				fail = "Failed:";
				total = "Total:";
				rate = "Rate:";
				font = new Font(e.Font, FontStyle.Bold);
			}
			else
			{
				pass = item.Pass.ToString();
				fail = item.Fail.ToString();
				total = item.Total.ToString();
				rate = item.Rate;
			}

			Graphics g = e.Graphics;

			using (Brush backBrush = new SolidBrush(GetItemBackColor(e, item)))
                g.FillRectangle(backBrush, e.Bounds);

			using (Brush foreBrush = new SolidBrush(e.ForeColor))
			{
				Brush b;
				if (item.Fail > 0)
					b = failBrush;
				else if (item.Pass > 0)
					b = passBrush;
				else if (item.Fail + item.Pass > 1)
					b = linkBrush;
				else
					b = foreBrush;

				int rColW = 48;

				Rectangle r = e.Bounds;
				r.Location = new Point(r.Left + 8 * item.Depth, r.Top);
				r.Width -= 8 * item.Depth - rColW * 4;

				Font f = item.Total > 1 || item.Depth < 3 ? new Font(font, font.Style | FontStyle.Underline) : font;
				g.DrawString(item.Name, f, b, r);

				StringFormat rAlign = StringFormat.GenericDefault;
				rAlign.Alignment = StringAlignment.Far;

				r.Width = rColW;
				r.Location = new Point(e.Bounds.Width - rColW * 4, r.Top);
				g.DrawString(pass, font, b, r, rAlign);
				
				r.Location = new Point(e.Bounds.Width - rColW * 3, r.Top);
				g.DrawString(fail, font, b, r, rAlign);
				
				r.Location = new Point(e.Bounds.Width - rColW * 2, r.Top);
				g.DrawString(total, font, b, r, rAlign);
				
				r.Location = new Point(e.Bounds.Width - rColW * 1, r.Top);
				g.DrawString(rate, font, b, r, rAlign);
			}
		}

		protected override void OnSizeChanged(EventArgs e)
		{
			base.OnSizeChanged (e);
			Refresh();
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			base.OnMouseMove(e);

			int index = e.Y / ItemHeight + this.TopIndex;
			if (index >= 0 && index < Items.Count)
			{
				ItemRow item = (ItemRow)Items[index];
				string desc = null;
				if (item is IterationRow)
					desc = ((IterationRow)item).Description;
				else if (item is TestCaseRow)
					desc = ((TestCaseRow)item).ResultDetails;

				if (desc != null && desc.Trim().Length != 0)
				{
					toolTip.SetToolTip(this, Items[index].ToString().Trim() + "\n" + desc.Trim());
					return;
				}
			}

			toolTip.SetToolTip(this, null);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\AdminTestCase.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for AdminTestCase.
	/// </summary>
	public class AdminTestCase : System.Windows.Forms.Form
	{
		private int SrvDescriptionChanged = 0;
		private RegDBQueryManager queryManager;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TextBox ServerDes;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.ComboBox SrvList;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Button button7;
		private System.Windows.Forms.Button button6;
		private System.Windows.Forms.Button button1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public AdminTestCase(RegDBQueryManager qManager)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			queryManager=qManager;
			ServerList sl = queryManager.GetServerList();

			SrvList.Items.Clear();
			foreach (Server s in sl)
				if (s.Servername.Trim() != "")
					SrvList.Items.Add(s);
			SrvList.SelectedIndex=0;

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.ServerDes = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.SrvList = new System.Windows.Forms.ComboBox();
			this.label1 = new System.Windows.Forms.Label();
			this.panel1 = new System.Windows.Forms.Panel();
			this.button7 = new System.Windows.Forms.Button();
			this.button6 = new System.Windows.Forms.Button();
			this.button1 = new System.Windows.Forms.Button();
			this.tabControl1.SuspendLayout();
			this.panel1.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.Add(this.tabPage1);
			this.tabControl1.Controls.Add(this.tabPage2);
			this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.tabControl1.Location = new System.Drawing.Point(8, 8);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(360, 254);
			this.tabControl1.TabIndex = 0;
			// 
			// tabPage1
			// 
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(352, 228);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Add Server Description";
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(352, 228);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Add TestCase Description";
			// 
			// ServerDes
			// 
			this.ServerDes.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.ServerDes.Location = new System.Drawing.Point(56, 176);
			this.ServerDes.MaxLength = 50;
			this.ServerDes.Multiline = true;
			this.ServerDes.Name = "ServerDes";
			this.ServerDes.Size = new System.Drawing.Size(264, 48);
			this.ServerDes.TabIndex = 7;
			this.ServerDes.Text = "";
			this.ServerDes.TextChanged += new System.EventHandler(this.ServerDes_TextChanged);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(24, 144);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(72, 16);
			this.label2.TabIndex = 6;
			this.label2.Text = "Description:";
			// 
			// SrvList
			// 
			this.SrvList.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.SrvList.Items.AddRange(new object[] {
														 "FBCK",
														 "Stats",
														 "MESSIIS",
														 "MONINH",
														 "SIGTEST"});
			this.SrvList.Location = new System.Drawing.Point(48, 104);
			this.SrvList.Name = "SrvList";
			this.SrvList.Size = new System.Drawing.Size(120, 21);
			this.SrvList.TabIndex = 5;
			this.SrvList.SelectedIndexChanged += new System.EventHandler(this.SrvList_SelectedIndexChanged);
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(24, 80);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(48, 16);
			this.label1.TabIndex = 4;
			this.label1.Text = "Server:";
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.button7);
			this.panel1.Controls.Add(this.button6);
			this.panel1.Controls.Add(this.button1);
			this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.panel1.Location = new System.Drawing.Point(8, 262);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(360, 32);
			this.panel1.TabIndex = 16;
			// 
			// button7
			// 
			this.button7.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button7.Enabled = false;
			this.button7.Location = new System.Drawing.Point(288, 8);
			this.button7.Name = "button7";
			this.button7.Size = new System.Drawing.Size(72, 24);
			this.button7.TabIndex = 12;
			this.button7.Text = "Apply";
			this.button7.Click += new System.EventHandler(this.button7_Click);
			// 
			// button6
			// 
			this.button6.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button6.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.button6.Location = new System.Drawing.Point(208, 8);
			this.button6.Name = "button6";
			this.button6.Size = new System.Drawing.Size(72, 24);
			this.button6.TabIndex = 13;
			this.button6.Text = "Cancel";
			this.button6.Click += new System.EventHandler(this.button6_Click);
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button1.Location = new System.Drawing.Point(128, 8);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(72, 24);
			this.button1.TabIndex = 14;
			this.button1.Text = "OK";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// AdminTestCase
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(376, 302);
			this.Controls.Add(this.ServerDes);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.SrvList);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.tabControl1);
			this.Controls.Add(this.panel1);
			this.DockPadding.All = 8;
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AdminTestCase";
			this.Text = "TestCase Manager";
			this.Load += new System.EventHandler(this.AdminTestCase_Load);
			this.tabControl1.ResumeLayout(false);
			this.panel1.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void AdminTestCase_Load(object sender, System.EventArgs e)
		{
		
		}

		private void SrvList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			if(((Server)SrvList.SelectedItem).ServerDescription != null)
				ServerDes.Text=((Server)SrvList.SelectedItem).ServerDescription.Trim();
			else 
				ServerDes.Text="";
		}

		private void Apply()
		{
			// find out what has changed and update
			if(SrvDescriptionChanged>1)
			{
				((Server)SrvList.SelectedItem).ServerDescription = ServerDes.Text.Trim(); 
				queryManager.UpdateSrvDescription(((Server)SrvList.SelectedItem).ID,ServerDes.Text.Trim());
				SrvDescriptionChanged= 1;
			}
		}
		private void RefreshChanged()
		{
			button7.Enabled = SrvDescriptionChanged >1;
		}

		private void ServerDes_TextChanged(object sender, System.EventArgs e)
		{
			SrvDescriptionChanged ++;
			if(SrvDescriptionChanged==2)
				RefreshChanged();
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			Apply();
			Close();
		}

		private void button6_Click(object sender, System.EventArgs e)
		{
			Close();
		}

		private void button7_Click(object sender, System.EventArgs e)
		{
			Apply();
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\CoolGraph.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows.Forms;

namespace STFRunner
{
	/// <summary>
	/// Summary description for CoolGraph.
	/// </summary>
	public class CoolGraph : System.Windows.Forms.UserControl
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public CoolGraph()
		{
			// This call is required by the Windows.Forms Form Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call

		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		Bitmap bmp;

		#region Component Designer generated code
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// CoolGraph
			// 
			this.Name = "CoolGraph";
			this.Resize += new System.EventHandler(this.CoolGraph_Resize);
			this.Paint += new System.Windows.Forms.PaintEventHandler(this.CoolGraph_Paint);

		}
		#endregion

		private void CoolGraph_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
            Graphics gr=e.Graphics;
			gr.DrawImage(bmp,0,0);
		}

		private void DrawGrid()
		{
			Graphics gr=Graphics.FromImage(bmp);
			gr.FillRectangle(new SolidBrush(Color.Black),0,0,Width,Height);

//			SolidBrush green

		}

		private void CoolGraph_Resize(object sender, System.EventArgs e)
		{
			bmp=new Bitmap(this.Width,this.Height);
			Invalidate();
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\GradientControl.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Data;
using System.Windows.Forms;

namespace STFRunner
{
	/// <summary>
	/// Summary description for GradientControl.
	/// </summary>
	public class GradientControl : System.Windows.Forms.UserControl
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public GradientControl()
		{
			// This call is required by the Windows.Forms Form Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitForm call
			SetStyle(ControlStyles.AllPaintingInWmPaint,true);
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// GradientControl
			// 
			this.Name = "GradientControl";
			this.Size = new System.Drawing.Size(152, 56);
			this.Resize += new System.EventHandler(this.GradientControl_Resize);
			this.Paint += new System.Windows.Forms.PaintEventHandler(this.GradientControl_Paint);

		}
		#endregion

		private void GradientControl_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			Graphics gr=e.Graphics;
			System.Drawing.Rectangle rct=new Rectangle(0,0,Width,Height);
			LinearGradientBrush	grb=new LinearGradientBrush(rct,this.ForeColor,this.BackColor,45,false);
			gr.FillRectangle(grb,rct);

			gr.DrawString(this.Text, this.Font, new SolidBrush(Color.White),5,5);

			gr.DrawLine(new Pen(new SolidBrush(Color.Black),4),0,Height,Width,Height);
		}

		private void GradientControl_Resize(object sender, System.EventArgs e)
		{
			Invalidate();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\gui.cs ===
using System;
using System.Diagnostics;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using System.Xml;
using System.Threading;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using ServerTestFramework;
using ServerTestFramework.Reporting;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;
using RegDBViewer;

namespace STFRunner
{
    /// <summary>
    /// Summary description for GUI.
    /// </summary>
    public class GUI : System.Windows.Forms.Form
    {
        public const string k_StfRunnerStateFile = "stfrunner_state.xml";

        // this delegate is provided to allow inter-thread updates
        public delegate void UpdateGUI();

#region Private Data
        // this delegate is used to provide post-stop actions
        private delegate void FuncStopActionDelegate(object data);
        
        private GUIReportDestination guiReporter;
        private bool viewResultsFromDB = false;
        private RegressionReport report = null;
        private RegDBQueryManager queryManager;
        private TestScheduler scheduler;
        private StfXmlDoc config;
        private TestSuiteContainer suites;
        private AsyncButtonClickAction asyncButton;
        private System.Windows.Forms.ContextMenu treeContextMenu;

        private WireDataFuzzForm wdFuzzForm = null;
        
        // Set these methods before or during test execution; when the tests
        // finish or are stopped, this function will be called with this data 
        // object.
        private FuncStopActionDelegate FuncStopActionMethod = null;
        private object FuncStopActionMethodData;

        private System.Windows.Forms.Panel panelRunControl;
        private System.Windows.Forms.Button bStart;
        private System.Windows.Forms.Button bLoadDLLs;
        private System.Windows.Forms.SaveFileDialog SFD;
        private System.Windows.Forms.OpenFileDialog OFD;
        private System.Windows.Forms.MainMenu mainMenu1;
        private System.Windows.Forms.MenuItem menuItem1; // top level "File"
        private System.Windows.Forms.MenuItem menuItemSearchDLL;
        private System.Windows.Forms.MenuItem menuItem2;
        private System.Windows.Forms.MenuItem menuItem3;
        private System.Windows.Forms.MenuItem menuItem4;
        private System.Windows.Forms.MenuItem menuItem5;
        private System.Windows.Forms.CheckBox chkRegDB;
        private System.Windows.Forms.CheckBox chkDvt;
        private System.Windows.Forms.CheckBox chkDisableAsync;
        private System.Windows.Forms.CheckBox chkRetryFailures;
        private System.Windows.Forms.CheckBox chkForceNpdb;
        private System.Windows.Forms.CheckBox chkRunLoop;
        private System.Windows.Forms.MenuItem menuItem6; // top level "View"
        private System.Windows.Forms.MenuItem menuViewFilters;
        private System.Windows.Forms.MenuItem menuShowOnlyFailedTests;
        private System.Windows.Forms.MenuItem menuRefresh;
        private System.Windows.Forms.MenuItem menuItem7;
        private System.Windows.Forms.Panel panelMaster;
        private System.Windows.Forms.TabControl tabMasterControl;
        private System.Windows.Forms.TabPage tabFunctional;
        private System.Windows.Forms.TabPage tabRegDB;
        private STFRunner.TestTree tvTests;
        private STFRunner.TestTree tvReg;
        private System.Windows.Forms.Panel panelRegBuild;
        private System.Windows.Forms.ListBox lstRegBuild;
        private System.Windows.Forms.Panel panelBuildRegBuild;
        private System.Windows.Forms.TabPage tabCerts;
        private System.Windows.Forms.Button btnCertView;
        private System.Windows.Forms.ListBox lstCerts;
        private System.Windows.Forms.Button btnCertClipboard;
        private System.Windows.Forms.Button btnLoadCert;
        private System.Windows.Forms.TabPage tabResults;
        private System.Windows.Forms.Panel panelResultList;
        private RegDBViewer.TestResultTree testResultTree1;
        private System.Windows.Forms.Panel panelResultServerFilter;
        private System.Windows.Forms.CheckBox chkFilterServers;
        private System.Windows.Forms.CheckedListBox clbServerList;
        private STFSplitContainer splitFunc;
        private STFSplitContainer splitRegH;
        private System.Windows.Forms.SplitContainer splitInsideReg;
        private STFRunner.LogViewRichText logView;
        private STFRunner.LogViewRichText logRegView;
        private STFRunner.STFProgressBar progressBar1;
        private System.Windows.Forms.MenuItem menuItem8; // top level "Reports"
        private System.Windows.Forms.MenuItem menuItem9; // Reports - Debug
        private System.Windows.Forms.MenuItem menuItem15; // Reports - Info
        private System.Windows.Forms.MenuItem menuItem16; // Reports - Warn
        private System.Windows.Forms.MenuItem menuItem17; // Reports - Error
        private System.Windows.Forms.MenuItem menuItem18; // Reports - Fatal
        private System.Windows.Forms.MenuItem menuItemReportEnable;
        private System.Windows.Forms.MenuItem menuItemReportDisable;
        private System.Windows.Forms.MenuItem menuItemReportBreak;
        private System.Windows.Forms.MenuItem menuItem19;
        private System.Windows.Forms.MenuItem menuItem20;
        private System.Windows.Forms.MenuItem menuItem21;
        private System.Windows.Forms.MenuItem menuItemColorSchemeBlack;
        private System.Windows.Forms.MenuItem menuItemColorSchemeWhite;
        private System.Windows.Forms.MenuItem menuItem24;
        private System.Windows.Forms.MenuItem menuItemChangeFont;
        private System.Windows.Forms.MenuItem menuItem22; // Reports - Success
        private System.Windows.Forms.MenuItem menuSaveFailedTests;
        private System.Windows.Forms.MenuItem menuWebstoreInstall;
        private System.Windows.Forms.MenuItem menuEventViewer;
        private System.Windows.Forms.MenuItem menuExpandCheckedNodes;
        private System.Windows.Forms.MenuItem menuItem10;
        private System.Windows.Forms.MenuItem FuzzMainMenuItem;
        private System.Windows.Forms.MenuItem FuzzWireDataFormMenuItem;
        private System.Windows.Forms.ComboBox cboNpdbSetting;
        private System.Windows.Forms.Label labelNpdb;
        private System.Windows.Forms.Label labelRegBuild;
        private IContainer components;
        private System.Windows.Forms.ToolTip ttip;

        private volatile RegDBInquirer regInq;

        private object lockPendingRegDBSuiteLoads=new object();
        private System.Collections.Generic.List<string> pendingRegDBSuiteLoads=new System.Collections.Generic.List<string>();

        //used in a workaround for double-change resize bug in .NET for sync'd SplitContainers
        private class STFSplitContainer: System.Windows.Forms.SplitContainer
        {
            public delegate void SplitterDistanceDel(int size);
            public void SetSplitterDistance(int size)
            {
                SplitterDistance=size;
            }
        };

#endregion  //Private Data

#region Setup and Cleanup

        public GUI(StfXmlDoc config, TestSuiteContainer suites)
        {
            int i;

            InitializeComponent();
            NondesignerInitializeComponent();

            this.config = config;
            this.suites = suites;
            this.suites.SuiteAdded += new TestSuiteContainer.AddSuiteEventHandler(SuiteAddedHandler);
            this.suites.SuiteRemoved += new TestSuiteContainer.RemoveSuiteEventHandler(SuiteRemovedHandler);
            this.HandleCreated += new EventHandler(GUI_HandleCreated);
            this.AllowDrop = true;
            this.DragDrop += new System.Windows.Forms.DragEventHandler(this.DragDropHandler);
            this.DragEnter += new System.Windows.Forms.DragEventHandler(this.DragEnterHandler);
            this.Closing += new CancelEventHandler(GUI_Closing);
            this.Resize += new EventHandler(GUI_Resize);
            
            asyncButton = new AsyncButtonClickAction(
                new Action(RunAllFunctionalTests), 
                new Action(StopFunctionalRun), 
                bStart, 
                new CancelableAction(Start), 
                new Action(FunctionalTestsComplete), 
                null);
            
            // Route all reports from the root to the GUI
            guiReporter = new GUIReportDestination(logView);
            ServerTestFramework.Report.GetRoot().AddReportDestination(guiReporter);

            // Route all reports form the root to the debug output window in VS
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());

            // Rewire STDOUT/STDERR to the gui reporter
            Console.SetError(new TextWriterReportBridge("STDERR"));
            Console.SetOut(new TextWriterReportBridge("STDOUT"));

            // Capture per-test-case reports
            ServerTestFramework.Report.GetRoot().AddReportDestination(new TestCaseReports());

            // Ensure that Globals is initialized since it may not always be 
            // loaded directly in the local runner app domain.
            Global.Initialize(config);
            
            // Set the default editor in the logview here after initializing the globals.
            this.logView.Initialize(Global.EditorPath, Global.EditorArgs, Global.SourceMappingFrom, Global.SourceMappingTo);
            this.logRegView.Initialize(Global.EditorPath, Global.EditorArgs, Global.SourceMappingFrom, Global.SourceMappingTo);

            // Populate the NPDB drop down box
            if (Global.NpdbSettings != null)
            {
                for (i = 0; i < Global.NpdbSettings.Count; i++)
                {
                    this.cboNpdbSetting.Items.Add(Global.NpdbSettings[i].ToString());
                }
            }

            // Load the certs into the certificates pane
            foreach (string key in Global.Certificates.Keys)
                lstCerts.Items.Add(new CertificateEntry(key, Global.Certificates[key].Cert));

            if (lstCerts.Items.Count > 0)
            {
                btnCertClipboard.Enabled = true;
                btnCertView.Enabled = true;
            }

            // look up the report log filters and reflect on gui report and menu
            uint currentFilters = Global.RO.Filter;
            try
            {
                // Setup log filters
                string strSetting = currentFilters.ToString();
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.ReportLogFilterKeyName, strSetting);
                currentFilters = UInt32.Parse(strSetting);
                
                // Setup window position
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.FunctionalWindowTopKeyName, this.Top.ToString());
                this.Top = Int32.Parse(strSetting);
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.FunctionalWindowLeftKeyName, this.Left.ToString());
                this.Left = Int32.Parse(strSetting);

                // Setup window size
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.FunctionalWindowWidthKeyName, this.Width.ToString());
                this.Width = Int32.Parse(strSetting);
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.FunctionalWindowHeightKeyName, this.Height.ToString());
                this.Height = Int32.Parse(strSetting);

                // Set the log splitter
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.FunctionalWindowSplitterRatioKeyName, "0.5");
                float sbarPositionRatio = float.Parse(strSetting);
                float sbarPosY = sbarPositionRatio * splitFunc.Height;
                this.splitFunc.SplitterDistance = (int)sbarPosY;

                //set the check boxes we care to preserve
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.FunctionalForceNpdbKeyName, "0");
                int fnpdbVal=int.Parse(strSetting);
                this.chkForceNpdb.Checked=(fnpdbVal==0?false:true);

                // Set the color scheme
                ColorScheme cs;
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.GUIReportColorSchemeName, "menuItemColorSchemeBlack");
                if (strSetting == "menuItemColorSchemeWhite")
                {
                    menuItemColorSchemeBlack.Checked = false;
                    menuItemColorSchemeWhite.Checked = true;
                    cs = new ColorScheme(ColorScheme.Default_WhiteBackground);
                }
                else
                {
                    // Default is black
                    menuItemColorSchemeBlack.Checked = true;
                    menuItemColorSchemeWhite.Checked = false;
                    cs = new ColorScheme(ColorScheme.Default_BlackBackground);
                }
                // Set the font
                string fontname = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.GUIReportColorSchemeFontName, "Lucida Console");
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.GUIReportColorSchemeFontSize, "8");
                cs.TextFont = new Font(fontname, float.Parse(strSetting));
                guiReporter.SetColorScheme(cs);
                logRegView.Font=cs.TextFont;
                logRegView.BackColor=cs.BackgroundColor;

                // Set the default NPDB setting
                string npdbsetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.DefaultNpdbSetting, "");
                if (npdbsetting == null || npdbsetting == "")
                {
                    // No setting saved, use first item as default
                    if (cboNpdbSetting.Items.Count > 0)
                    {
                        cboNpdbSetting.SelectedIndex = 0;
                        Global.DefaultNpdbSetting = new NpdbSetting((string)cboNpdbSetting.Items[0]);
                    }
                }
                else
                {
                    // Find item in combo box
                    int idx = cboNpdbSetting.FindStringExact(npdbsetting);
                    if (idx >= 0)
                    {
                        cboNpdbSetting.SelectedIndex = idx;
                        Global.DefaultNpdbSetting = new NpdbSetting(npdbsetting);
                    }
                    else
                    {
                        // Saved item not found in combobox, toss it away and use first item as default
                        if (cboNpdbSetting.Items.Count > 0)
                        {
                            cboNpdbSetting.SelectedIndex = 0;
                            Global.DefaultNpdbSetting = new NpdbSetting((string)cboNpdbSetting.Items[0]);
                        }
                    }
                }
            }
            catch(Exception ex)
            {
                Global.RO.Error(ex.GetType().FullName + " trying to open the registry key: " + Global.CommonAppDataRegistry.Name + ", message: " + ex.Message);
            }

            Report.GetRoot().SetLevelFilter(currentFilters);

            // restore the checked menus according to filter settings
            i = 1;
            foreach(MenuItem mi in menuItem8.MenuItems)
            {
                if((i & currentFilters) != 0)
                    mi.Checked = true;
                else
                    mi.Checked = false;

                i = i << 1;
            }

            // create the context menu and install event handlers
            treeContextMenu = new ContextMenu();
            treeContextMenu.Popup += new EventHandler(this.TestMenuPopupHandler);
            tvTests.ContextMenu = treeContextMenu;
            tvTests.DoubleClick += TestMenuDoubleClickHandler;
            tvReg.Click += RegTreeClickHandler;
            lstRegBuild.Click += RegBuildClickHandler;

            // Instantiate the GUI feedback factory so that tests can provide some GUI feedback
            FeedbackManager.Instance.SetFactory(new GUIFeedbackFactory(progressBar1));
        }

        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            try
            {
                base.Dispose( disposing );
            }
            catch(InvalidOperationException)
            {
                // Ignore, this can happen in shutdown due to multiple threads
                // not shutting down before dispose.
            }

            //Stop any running fucntionals
            //This has to be done here rather than from a gui event handler which seems to hold an internal lock of some sort in the internal .NET stuff.
            StopFunctionalRun();
        }

#endregion //region Setup and Cleanup

#region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        // NOTE: Form designer no longer... there have been numerous manual changes here.
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(GUI));
            this.panelRunControl = new System.Windows.Forms.Panel();
            this.labelNpdb = new System.Windows.Forms.Label();
            this.cboNpdbSetting = new System.Windows.Forms.ComboBox();
            this.progressBar1 = new STFRunner.STFProgressBar();
            this.chkRegDB = new System.Windows.Forms.CheckBox();
            this.chkDvt = new System.Windows.Forms.CheckBox();
            this.chkDisableAsync = new System.Windows.Forms.CheckBox();
            this.chkRetryFailures = new System.Windows.Forms.CheckBox();
            this.chkForceNpdb = new System.Windows.Forms.CheckBox();
            this.chkRunLoop = new System.Windows.Forms.CheckBox();
            this.bStart = new System.Windows.Forms.Button();
            this.bLoadDLLs = new System.Windows.Forms.Button();
            this.SFD = new System.Windows.Forms.SaveFileDialog();
            this.OFD = new System.Windows.Forms.OpenFileDialog();
            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);
            this.menuItem1 = new System.Windows.Forms.MenuItem();
            this.menuItem2 = new System.Windows.Forms.MenuItem();
            this.menuItem3 = new System.Windows.Forms.MenuItem();
            this.menuSaveFailedTests = new System.Windows.Forms.MenuItem();
            this.menuItemSearchDLL = new System.Windows.Forms.MenuItem();
            this.menuWebstoreInstall = new System.Windows.Forms.MenuItem();
            this.menuItem5 = new System.Windows.Forms.MenuItem();
            this.menuItem4 = new System.Windows.Forms.MenuItem();
            this.menuItem6 = new System.Windows.Forms.MenuItem();
            this.menuShowOnlyFailedTests = new System.Windows.Forms.MenuItem();
            this.menuExpandCheckedNodes = new System.Windows.Forms.MenuItem();
            this.menuItem10 = new System.Windows.Forms.MenuItem();
            this.menuEventViewer = new System.Windows.Forms.MenuItem();
            this.menuItem19 = new System.Windows.Forms.MenuItem();
            this.menuViewFilters = new System.Windows.Forms.MenuItem();
            this.menuItem7 = new System.Windows.Forms.MenuItem();
            this.menuRefresh = new System.Windows.Forms.MenuItem();
            this.menuItem21 = new System.Windows.Forms.MenuItem();
            this.menuItem20 = new System.Windows.Forms.MenuItem();
            this.menuItemColorSchemeBlack = new System.Windows.Forms.MenuItem();
            this.menuItemColorSchemeWhite = new System.Windows.Forms.MenuItem();
            this.menuItem24 = new System.Windows.Forms.MenuItem();
            this.menuItemChangeFont = new System.Windows.Forms.MenuItem();
            this.menuItem8 = new System.Windows.Forms.MenuItem();
            this.menuItem9 = new System.Windows.Forms.MenuItem();
            this.menuItem15 = new System.Windows.Forms.MenuItem();
            this.menuItem16 = new System.Windows.Forms.MenuItem();
            this.menuItem17 = new System.Windows.Forms.MenuItem();
            this.menuItem18 = new System.Windows.Forms.MenuItem();
            this.menuItem22 = new System.Windows.Forms.MenuItem();
            this.menuItemReportBreak = new System.Windows.Forms.MenuItem();
            this.menuItemReportEnable = new System.Windows.Forms.MenuItem();
            this.menuItemReportDisable = new System.Windows.Forms.MenuItem();
            this.FuzzMainMenuItem = new System.Windows.Forms.MenuItem();
            this.FuzzWireDataFormMenuItem = new System.Windows.Forms.MenuItem();
            this.panelMaster = new System.Windows.Forms.Panel();
            this.tabMasterControl = new System.Windows.Forms.TabControl();
            this.tabFunctional = new System.Windows.Forms.TabPage();
            this.splitFunc = new STFRunner.GUI.STFSplitContainer();
            this.tvTests = new STFRunner.TestTree();
            this.logView = new STFRunner.LogViewRichText();
            this.tabRegDB = new System.Windows.Forms.TabPage();
            this.splitRegH = new STFRunner.GUI.STFSplitContainer();
            this.splitInsideReg = new System.Windows.Forms.SplitContainer();
            this.tvReg = new STFRunner.TestTree();
            this.panelRegBuild = new System.Windows.Forms.Panel();
            this.labelRegBuild = new System.Windows.Forms.Label();
            this.panelBuildRegBuild = new System.Windows.Forms.Panel();
            this.lstRegBuild = new System.Windows.Forms.ListBox();
            this.logRegView = new STFRunner.LogViewRichText();
            this.tabCerts = new System.Windows.Forms.TabPage();
            this.btnCertView = new System.Windows.Forms.Button();
            this.lstCerts = new System.Windows.Forms.ListBox();
            this.btnCertClipboard = new System.Windows.Forms.Button();
            this.btnLoadCert = new System.Windows.Forms.Button();
            this.tabResults = new System.Windows.Forms.TabPage();
            this.panelResultList = new System.Windows.Forms.Panel();
            this.testResultTree1 = new RegDBViewer.TestResultTree();
            this.panelResultServerFilter = new System.Windows.Forms.Panel();
            this.chkFilterServers = new System.Windows.Forms.CheckBox();
            this.clbServerList = new System.Windows.Forms.CheckedListBox();
            this.ttip = new System.Windows.Forms.ToolTip(this.components);
            this.panelRunControl.SuspendLayout();
            this.panelMaster.SuspendLayout();
            this.tabMasterControl.SuspendLayout();
            this.tabFunctional.SuspendLayout();
            this.splitFunc.Panel1.SuspendLayout();
            this.splitFunc.Panel2.SuspendLayout();
            this.splitFunc.SuspendLayout();
            this.tabRegDB.SuspendLayout();
            this.splitRegH.Panel1.SuspendLayout();
            this.splitRegH.Panel2.SuspendLayout();
            this.splitRegH.SuspendLayout();
            this.splitInsideReg.Panel1.SuspendLayout();
            this.splitInsideReg.Panel2.SuspendLayout();
            this.splitInsideReg.SuspendLayout();
            this.panelRegBuild.SuspendLayout();
            this.panelBuildRegBuild.SuspendLayout();
            this.tabCerts.SuspendLayout();
            this.tabResults.SuspendLayout();
            this.panelResultList.SuspendLayout();
            this.panelResultServerFilter.SuspendLayout();
            this.SuspendLayout();
            // 
            // panelRunControl
            // 
            this.panelRunControl.Anchor = ((System.Windows.Forms.AnchorStyles) (((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.panelRunControl.Controls.Add(this.labelNpdb);
            this.panelRunControl.Controls.Add(this.cboNpdbSetting);
            this.panelRunControl.Controls.Add(this.progressBar1);
            this.panelRunControl.Controls.Add(this.chkRegDB);
            this.panelRunControl.Controls.Add(this.chkDvt);
            this.panelRunControl.Controls.Add(this.chkDisableAsync);
            this.panelRunControl.Controls.Add(this.chkRetryFailures);
            this.panelRunControl.Controls.Add(this.chkForceNpdb);
            this.panelRunControl.Controls.Add(this.chkRunLoop);
            this.panelRunControl.Controls.Add(this.bStart);
            this.panelRunControl.Controls.Add(this.bLoadDLLs);
            this.panelRunControl.Location = new System.Drawing.Point(0, 488);
            this.panelRunControl.Name = "panelRunControl";
            this.panelRunControl.Size = new System.Drawing.Size(800, 32);
            this.panelRunControl.TabIndex = 0;
            // 
            // labelNpdb
            // 
            this.labelNpdb.Location = new System.Drawing.Point(407, 9);
            this.labelNpdb.Name = "labelNpdb";
            this.labelNpdb.Size = new System.Drawing.Size(34, 15);
            this.labelNpdb.TabIndex = 10;
            this.labelNpdb.Text = "Npdb:";
            // 
            // cboNpdbSetting
            // 
            this.cboNpdbSetting.Location = new System.Drawing.Point(441, 5);
            this.cboNpdbSetting.Name = "cboNpdbSetting";
            this.cboNpdbSetting.Size = new System.Drawing.Size(140, 21);
            this.cboNpdbSetting.TabIndex = 9;
            this.ttip.SetToolTip(this.cboNpdbSetting, "Allows you to select the environment(npdb) to run against.");
            this.cboNpdbSetting.SelectedIndexChanged += new System.EventHandler(this.cboNpdbSetting_SelectedIndexChanged);
            // 
            // progressBar1
            // 
            this.progressBar1.Anchor = ((System.Windows.Forms.AnchorStyles) (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.progressBar1.BackColor = System.Drawing.Color.DarkGray;
            this.progressBar1.Description = "";
            this.progressBar1.ForeColor = System.Drawing.SystemColors.HotTrack;
            this.progressBar1.Location = new System.Drawing.Point(587, 4);
            this.progressBar1.Maximum = 0;
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(208, 21);
            this.progressBar1.Step = 1;
            this.progressBar1.TabIndex = 9;
            this.ttip.SetToolTip(this.progressBar1, "Progress.  This bar should probably go away sometime, since it\'s not multithread " +
                    "safe.");
            this.progressBar1.Value = 0;
            // 
            // chkRegDB
            // 
            this.chkRegDB.Location = new System.Drawing.Point(135, 0);
            this.chkRegDB.Name = "chkRegDB";
            this.chkRegDB.Size = new System.Drawing.Size(96, 16);
            this.chkRegDB.TabIndex = 6;
            this.chkRegDB.Text = "Log to RegDB";
            this.ttip.SetToolTip(this.chkRegDB, "All test case pass/fails and all output will be logged to RegDB, where it can be " +
                    "viewed at a later time.");
            // 
            // chkDvt
            // 
            this.chkDvt.Location = new System.Drawing.Point(135, 16);
            this.chkDvt.Name = "chkDvt";
            this.chkDvt.Size = new System.Drawing.Size(96, 16);
            this.chkDvt.TabIndex = 7;
            this.chkDvt.Text = "Run DVT Only";
            this.ttip.SetToolTip(this.chkDvt, "Run only test cases that have the DVT attribute on them.");
            // 
            // chkDisableAsync
            // 
            this.chkDisableAsync.Location = new System.Drawing.Point(231, 0);
            this.chkDisableAsync.Name = "chkDisableAsync";
            this.chkDisableAsync.Size = new System.Drawing.Size(95, 16);
            this.chkDisableAsync.TabIndex = 8;
            this.chkDisableAsync.Text = "Disable Async";
            this.ttip.SetToolTip(this.chkDisableAsync, "Prevent any test cases/groups/suites from running in parallel.");
            // 
            // chkRetryFailures
            // 
            this.chkRetryFailures.Location = new System.Drawing.Point(231, 16);
            this.chkRetryFailures.Name = "chkRetryFailures";
            this.chkRetryFailures.Size = new System.Drawing.Size(95, 16);
            this.chkRetryFailures.TabIndex = 9;
            this.chkRetryFailures.Text = "Retry Failures";
            this.ttip.SetToolTip(this.chkRetryFailures, "If a test case or a group setup fails, it will be retried up to 3 times.");
            // 
            // chkForceNpdb
            // 
            this.chkForceNpdb.Location = new System.Drawing.Point(326, 0);
            this.chkForceNpdb.Name = "chkForceNpdb";
            this.chkForceNpdb.Size = new System.Drawing.Size(90, 16);
            this.chkForceNpdb.TabIndex = 9;
            this.chkForceNpdb.Text = "Force NPDB";
            this.ttip.SetToolTip(this.chkForceNpdb, resources.GetString("chkForceNpdb.ToolTip"));
            // 
            // chkRunLoop
            // 
            this.chkRunLoop.Location = new System.Drawing.Point(326, 16);
            this.chkRunLoop.Name = "chkRunLoop";
            this.chkRunLoop.Size = new System.Drawing.Size(90, 16);
            this.chkRunLoop.TabIndex = 9;
            this.chkRunLoop.Text = "Run Looped";
            this.ttip.SetToolTip(this.chkRunLoop, "When checked, the functional run will start over again from the beginning after it finishes, looping forever.");
            // 
            // bStart
            // 
            this.bStart.Location = new System.Drawing.Point(60, 0);
            this.bStart.Name = "bStart";
            this.bStart.Size = new System.Drawing.Size(70, 32);
            this.bStart.TabIndex = 0;
            this.bStart.Text = "&Start";
            this.ttip.SetToolTip(this.bStart, "Starts or Stops a test run.");
            // 
            // bLoadDLLs
            // 
            this.bLoadDLLs.Location = new System.Drawing.Point(2, 0);
            this.bLoadDLLs.Name = "bLoadDLLs";
            this.bLoadDLLs.Size = new System.Drawing.Size(55, 32);
            this.bLoadDLLs.TabIndex = 1;
            this.bLoadDLLs.Text = "Search for &DLLs";
            this.ttip.SetToolTip(this.bLoadDLLs, "Searches the Suites directory for .dll files and attempts to load every one of th" +
                    "em as a test suite.  This is generally overkill.");
            this.bLoadDLLs.Click += new System.EventHandler(this.button1_Click);
            // 
            // SFD
            // 
            this.SFD.FileName = "TestConfig";
            // 
            // OFD
            // 
            this.OFD.ShowReadOnly = true;
            // 
            // mainMenu1
            // 
            this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItem1,
            this.menuItem6,
            this.menuItem8,
            this.FuzzMainMenuItem});
            // 
            // menuItem1
            // 
            this.menuItem1.Index = 0;
            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItem2,
            this.menuItem3,
            this.menuSaveFailedTests,
            this.menuItemSearchDLL,
            this.menuWebstoreInstall,
            this.menuItem5,
            this.menuItem4});
            this.menuItem1.Text = "File";
            // 
            // menuItem2
            // 
            this.menuItem2.Index = 0;
            this.menuItem2.Shortcut = System.Windows.Forms.Shortcut.F9;
            this.menuItem2.Text = "Open...";
            this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);
            // 
            // menuItem3
            // 
            this.menuItem3.Index = 1;
            this.menuItem3.Shortcut = System.Windows.Forms.Shortcut.F6;
            this.menuItem3.Text = "Save Selected Tests...";
            this.menuItem3.Click += new System.EventHandler(this.menuItem3_Click);
            // 
            // menuSaveFailedTests
            // 
            this.menuSaveFailedTests.Index = 2;
            this.menuSaveFailedTests.Text = "Save Failed Tests...";
            this.menuSaveFailedTests.Click += new System.EventHandler(this.menuSaveFailedTests_Click);
            // 
            // menuItemSearchDLL
            // 
            this.menuItemSearchDLL.Index = 3;
            this.menuItemSearchDLL.Text = "Search for DLLs";
            this.menuItemSearchDLL.Click += new System.EventHandler(this.menuItemSearchDLL_Click);
            // 
            // menuWebstoreInstall
            // 
            this.menuWebstoreInstall.Index = 4;
            this.menuWebstoreInstall.Text = "Xblob Webstore Install...";
            this.menuWebstoreInstall.Click += new System.EventHandler(this.menuWebstoreInstall_Click);
            // 
            // menuItem5
            // 
            this.menuItem5.Index = 5;
            this.menuItem5.Text = "-";
            // 
            // menuItem4
            // 
            this.menuItem4.Index = 6;
            this.menuItem4.Text = "Exit";
            this.menuItem4.Click += new System.EventHandler(this.menuItem4_Click);
            // 
            // menuItem6
            // 
            this.menuItem6.Index = 1;
            this.menuItem6.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuShowOnlyFailedTests,
            this.menuExpandCheckedNodes,
            this.menuItem10,
            this.menuEventViewer,
            this.menuItem19,
            this.menuViewFilters,
            this.menuItem7,
            this.menuRefresh,
            this.menuItem21,
            this.menuItem20});
            this.menuItem6.Text = "View";
            // 
            // menuShowOnlyFailedTests
            // 
            this.menuShowOnlyFailedTests.Index = 0;
            this.menuShowOnlyFailedTests.Shortcut = System.Windows.Forms.Shortcut.CtrlF8;
            this.menuShowOnlyFailedTests.Text = "Select Only Failed Tests";
            this.menuShowOnlyFailedTests.Click += new System.EventHandler(this.menuShowOnlyFailedTests_Click);
            // 
            // menuExpandCheckedNodes
            // 
            this.menuExpandCheckedNodes.Index = 1;
            this.menuExpandCheckedNodes.Shortcut = System.Windows.Forms.Shortcut.CtrlF9;
            this.menuExpandCheckedNodes.Text = "Expand Checked Groups";
            this.menuExpandCheckedNodes.Click += new System.EventHandler(this.menuExpandCheckedNodes_Click);
            // 
            // menuItem10
            // 
            this.menuItem10.Index = 2;
            this.menuItem10.Text = "-";
            // 
            // menuEventViewer
            // 
            this.menuEventViewer.Index = 3;
            this.menuEventViewer.Text = "Events";
            this.menuEventViewer.Click += new System.EventHandler(this.menuEvents_Click);
            // 
            // menuItem19
            // 
            this.menuItem19.Index = 4;
            this.menuItem19.Shortcut = System.Windows.Forms.Shortcut.ShiftDel;
            this.menuItem19.Text = "Clear Report";
            this.menuItem19.Click += new System.EventHandler(this.menuItem19_Click);
            // 
            // menuViewFilters
            // 
            this.menuViewFilters.Index = 5;
            this.menuViewFilters.Text = "Filters";
            this.menuViewFilters.Visible = false;
            this.menuViewFilters.Click += new System.EventHandler(this.menuViewFilters_Click);
            // 
            // menuItem7
            // 
            this.menuItem7.Index = 6;
            this.menuItem7.Text = "View Results From DB";
            this.menuItem7.Visible = false;
            this.menuItem7.Click += new System.EventHandler(this.menuItem7_Click);
            // 
            // menuRefresh
            // 
            this.menuRefresh.Index = 7;
            this.menuRefresh.Text = "Refresh";
            this.menuRefresh.Visible = false;
            this.menuRefresh.Click += new System.EventHandler(this.menuRefresh_Click);
            // 
            // menuItem21
            // 
            this.menuItem21.Index = 8;
            this.menuItem21.Text = "-";
            // 
            // menuItem20
            // 
            this.menuItem20.Index = 9;
            this.menuItem20.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItemColorSchemeBlack,
            this.menuItemColorSchemeWhite,
            this.menuItem24,
            this.menuItemChangeFont});
            this.menuItem20.Text = "Color Scheme";
            // 
            // menuItemColorSchemeBlack
            // 
            this.menuItemColorSchemeBlack.Checked = true;
            this.menuItemColorSchemeBlack.Index = 0;
            this.menuItemColorSchemeBlack.Text = "Black background";
            this.menuItemColorSchemeBlack.Click += new System.EventHandler(this.menuItemColorSchemeBlack_Click);
            // 
            // menuItemColorSchemeWhite
            // 
            this.menuItemColorSchemeWhite.Index = 1;
            this.menuItemColorSchemeWhite.Text = "White background";
            this.menuItemColorSchemeWhite.Click += new System.EventHandler(this.menuItemColorSchemeWhite_Click);
            // 
            // menuItem24
            // 
            this.menuItem24.Index = 2;
            this.menuItem24.Text = "-";
            // 
            // menuItemChangeFont
            // 
            this.menuItemChangeFont.Index = 3;
            this.menuItemChangeFont.Text = "Change font...";
            this.menuItemChangeFont.Click += new System.EventHandler(this.menuItemChangeFont_Click);
            // 
            // menuItem8
            // 
            this.menuItem8.Index = 2;
            this.menuItem8.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItem9,
            this.menuItem15,
            this.menuItem16,
            this.menuItem17,
            this.menuItem18,
            this.menuItem22,
            this.menuItemReportBreak,
            this.menuItemReportEnable,
            this.menuItemReportDisable});
            this.menuItem8.Text = "Reports";
            // 
            // menuItem9
            // 
            this.menuItem9.Index = 0;
            this.menuItem9.Text = "Debug";
            this.menuItem9.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItem15
            // 
            this.menuItem15.Index = 1;
            this.menuItem15.Text = "Info";
            this.menuItem15.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItem16
            // 
            this.menuItem16.Index = 2;
            this.menuItem16.Text = "Warn";
            this.menuItem16.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItem17
            // 
            this.menuItem17.Index = 3;
            this.menuItem17.Text = "Error";
            this.menuItem17.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItem18
            // 
            this.menuItem18.Index = 4;
            this.menuItem18.Text = "Fatal";
            this.menuItem18.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItem22
            // 
            this.menuItem22.Index = 5;
            this.menuItem22.Text = "Success";
            this.menuItem22.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItemReportBreak
            // 
            this.menuItemReportBreak.Index = 6;
            this.menuItemReportBreak.Text = "-";
            // 
            // menuItemReportEnable
            // 
            this.menuItemReportEnable.Index = 7;
            this.menuItemReportEnable.Text = "Enable All";
            this.menuItemReportEnable.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // menuItemReportDisable
            // 
            this.menuItemReportDisable.Index = 8;
            this.menuItemReportDisable.Text = "Disable All";
            this.menuItemReportDisable.Click += new System.EventHandler(this.ReportMenu_Select);
            // 
            // FuzzMainMenuItem
            // 
            this.FuzzMainMenuItem.Index = 3;
            this.FuzzMainMenuItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.FuzzWireDataFormMenuItem});
            this.FuzzMainMenuItem.Text = "Fuzzing";
            // 
            // FuzzWireDataFormMenuItem
            // 
            this.FuzzWireDataFormMenuItem.Index = 0;
            this.FuzzWireDataFormMenuItem.Text = "WireData Fuzzing...";
            this.FuzzWireDataFormMenuItem.Click += new System.EventHandler(this.OpenWireDataFuzzForm);
            // 
            // panelMaster
            // 
            this.panelMaster.Anchor = ((System.Windows.Forms.AnchorStyles) ((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.panelMaster.Controls.Add(this.tabMasterControl);
            this.panelMaster.Location = new System.Drawing.Point(0, 0);
            this.panelMaster.Name = "panelMaster";
            this.panelMaster.Size = new System.Drawing.Size(800, 485);
            this.panelMaster.TabIndex = 1;
            // 
            // tabMasterControl
            // 
            this.tabMasterControl.Controls.Add(this.tabFunctional);
            this.tabMasterControl.Controls.Add(this.tabRegDB);
            this.tabMasterControl.Controls.Add(this.tabCerts);
            this.tabMasterControl.Controls.Add(this.tabResults);
            this.tabMasterControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabMasterControl.Location = new System.Drawing.Point(0, 0);
            this.tabMasterControl.Name = "tabMasterControl";
            this.tabMasterControl.SelectedIndex = 0;
            this.tabMasterControl.Size = new System.Drawing.Size(800, 485);
            this.tabMasterControl.TabIndex = 3;
            // 
            // tabFunctional
            // 
            this.tabFunctional.Controls.Add(this.splitFunc);
            this.tabFunctional.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabFunctional.Location = new System.Drawing.Point(4, 22);
            this.tabFunctional.Name = "tabFunctional";
            this.tabFunctional.Size = new System.Drawing.Size(792, 459);
            this.tabFunctional.TabIndex = 0;
            this.tabFunctional.Text = "Functional";
            this.tabFunctional.Leave += new System.EventHandler(this.SplitterDistance_BugFix_OnResize);
            // 
            // splitFunc
            // 
            this.splitFunc.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitFunc.Location = new System.Drawing.Point(0, 0);
            this.splitFunc.Name = "splitFunc";
            this.splitFunc.Orientation = System.Windows.Forms.Orientation.Horizontal;
            // 
            // splitFunc.Panel1
            // 
            this.splitFunc.Panel1.Controls.Add(this.tvTests);
            // 
            // splitFunc.Panel2
            // 
            this.splitFunc.Panel2.Controls.Add(this.logView);
            this.splitFunc.Size = new System.Drawing.Size(792, 459);
            this.splitFunc.SplitterDistance = 229;
            this.splitFunc.TabIndex = 0;
            this.splitFunc.TabStop = false;
            // 
            // tvTests
            // 
            this.tvTests.CheckBoxes = true;
            this.tvTests.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tvTests.Location = new System.Drawing.Point(0, 0);
            this.tvTests.Name = "tvTests";
            this.tvTests.NodeUnderMouse = null;
            this.tvTests.Size = new System.Drawing.Size(792, 229);
            this.tvTests.TabIndex = 4;
            // 
            // logView
            // 
            this.logView.BackColor = System.Drawing.Color.White;
            this.logView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logView.Font = new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.logView.ForeColor = System.Drawing.Color.Black;
            this.logView.Location = new System.Drawing.Point(0, 0);
            this.logView.Name = "logView";
            this.logView.ReadOnly = true;
            this.logView.Size = new System.Drawing.Size(792, 226);
            this.logView.TabIndex = 0;
            this.logView.Text = "";
            this.logView.WordWrap = false;
            // 
            // tabRegDB
            // 
            this.tabRegDB.Controls.Add(this.splitRegH);
            this.tabRegDB.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabRegDB.Location = new System.Drawing.Point(4, 22);
            this.tabRegDB.Name = "tabRegDB";
            this.tabRegDB.Size = new System.Drawing.Size(792, 459);
            this.tabRegDB.TabIndex = 1;
            this.tabRegDB.Text = "RegDB";
            this.tabRegDB.Enter += new System.EventHandler(this.tabRegDB_Enter_Delegate);
            this.tabRegDB.Leave += new System.EventHandler(this.SplitterDistance_BugFix_OnResize_RegDB);
            // 
            // splitRegH
            // 
            this.splitRegH.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitRegH.Location = new System.Drawing.Point(0, 0);
            this.splitRegH.Name = "splitRegH";
            this.splitRegH.Orientation = System.Windows.Forms.Orientation.Horizontal;
            // 
            // splitRegH.Panel1
            // 
            this.splitRegH.Panel1.Controls.Add(this.splitInsideReg);
            // 
            // splitRegH.Panel2
            // 
            this.splitRegH.Panel2.Controls.Add(this.logRegView);
            this.splitRegH.Size = new System.Drawing.Size(792, 459);
            this.splitRegH.SplitterDistance = 45;
            this.splitRegH.TabIndex = 0;
            this.splitRegH.TabStop = false;
            // 
            // splitInsideReg
            // 
            this.splitInsideReg.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitInsideReg.FixedPanel = System.Windows.Forms.FixedPanel.Panel2;
            this.splitInsideReg.IsSplitterFixed = true;
            this.splitInsideReg.Location = new System.Drawing.Point(0, 0);
            this.splitInsideReg.Name = "splitInsideReg";
            // 
            // splitInsideReg.Panel1
            // 
            this.splitInsideReg.Panel1.Controls.Add(this.tvReg);
            // 
            // splitInsideReg.Panel2
            // 
            this.splitInsideReg.Panel2.Controls.Add(this.panelRegBuild);
            this.splitInsideReg.Size = new System.Drawing.Size(792, 45);
            this.splitInsideReg.SplitterDistance = 692;
            this.splitInsideReg.TabIndex = 0;
            this.splitInsideReg.TabStop = false;
            // 
            // tvReg
            // 
            this.tvReg.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tvReg.HideSelection = false;
            this.tvReg.Location = new System.Drawing.Point(0, 0);
            this.tvReg.Name = "tvReg";
            this.tvReg.NodeUnderMouse = null;
            this.tvReg.Size = new System.Drawing.Size(692, 45);
            this.tvReg.TabIndex = 4;
            // 
            // panelRegBuild
            // 
            this.panelRegBuild.Controls.Add(this.labelRegBuild);
            this.panelRegBuild.Controls.Add(this.panelBuildRegBuild);
            this.panelRegBuild.Dock = System.Windows.Forms.DockStyle.Fill;
            this.panelRegBuild.Location = new System.Drawing.Point(0, 0);
            this.panelRegBuild.Name = "panelRegBuild";
            this.panelRegBuild.Size = new System.Drawing.Size(96, 45);
            this.panelRegBuild.TabIndex = 1;
            // 
            // labelRegBuild
            // 
            this.labelRegBuild.Location = new System.Drawing.Point(90, 2);
            this.labelRegBuild.Name = "labelRegBuild";
            this.labelRegBuild.Size = new System.Drawing.Size(100, 18);
            this.labelRegBuild.TabIndex = 10;
            this.labelRegBuild.Text = "Build:";
            // 
            // panelBuildRegBuild
            // 
            this.panelBuildRegBuild.Controls.Add(this.lstRegBuild);
            this.panelBuildRegBuild.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.panelBuildRegBuild.Location = new System.Drawing.Point(0, 20);
            this.panelBuildRegBuild.Height = 31;
            this.panelBuildRegBuild.Width = 228;
            this.panelBuildRegBuild.Name = "panelBuildRegBuild";

            this.panelBuildRegBuild.TabIndex = 1;

            // 
            // lstRegBuild
            // 
            this.lstRegBuild.Dock = System.Windows.Forms.DockStyle.Fill;
            this.lstRegBuild.Location = new System.Drawing.Point(0, 0);
            this.lstRegBuild.Name = "lstRegBuild";
            this.lstRegBuild.Size = new System.Drawing.Size(96, 43);
            this.lstRegBuild.TabIndex = 4;
            // 
            // logRegView
            // 
            this.logRegView.BackColor = System.Drawing.Color.White;
            this.logRegView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logRegView.Font = new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.logRegView.ForeColor = System.Drawing.Color.Black;
            this.logRegView.Location = new System.Drawing.Point(0, 0);
            this.logRegView.Name = "logRegView";
            this.logRegView.ReadOnly = true;
            this.logRegView.Size = new System.Drawing.Size(792, 410);
            this.logRegView.TabIndex = 0;
            this.logRegView.Text = "";
            this.logRegView.WordWrap = false;
            // 
            // tabCerts
            // 
            this.tabCerts.Controls.Add(this.btnCertView);
            this.tabCerts.Controls.Add(this.lstCerts);
            this.tabCerts.Controls.Add(this.btnCertClipboard);
            this.tabCerts.Controls.Add(this.btnLoadCert);
            this.tabCerts.Location = new System.Drawing.Point(4, 22);
            this.tabCerts.Name = "tabCerts";
            this.tabCerts.Size = new System.Drawing.Size(792, 474);
            this.tabCerts.TabIndex = 2;
            this.tabCerts.Text = "Certs";
            this.tabCerts.Visible = false;
            // 
            // btnCertView
            // 
            this.btnCertView.Enabled = false;
            this.btnCertView.Location = new System.Drawing.Point(136, 296);
            this.btnCertView.Name = "btnCertView";
            this.btnCertView.Size = new System.Drawing.Size(75, 23);
            this.btnCertView.TabIndex = 5;
            this.btnCertView.Text = "View";
            // 
            // lstCerts
            // 
            this.lstCerts.Location = new System.Drawing.Point(8, 56);
            this.lstCerts.Name = "lstCerts";
            this.lstCerts.Size = new System.Drawing.Size(216, 225);
            this.lstCerts.TabIndex = 4;
            // 
            // btnCertClipboard
            // 
            this.btnCertClipboard.Enabled = false;
            this.btnCertClipboard.Location = new System.Drawing.Point(16, 296);
            this.btnCertClipboard.Name = "btnCertClipboard";
            this.btnCertClipboard.Size = new System.Drawing.Size(104, 23);
            this.btnCertClipboard.TabIndex = 3;
            this.btnCertClipboard.Text = "Copy to clipboard";
            // 
            // btnLoadCert
            // 
            this.btnLoadCert.Location = new System.Drawing.Point(16, 16);
            this.btnLoadCert.Name = "btnLoadCert";
            this.btnLoadCert.Size = new System.Drawing.Size(104, 23);
            this.btnLoadCert.TabIndex = 0;
            this.btnLoadCert.Text = "Load Certificate";
            // 
            // tabResults
            // 
            this.tabResults.Controls.Add(this.panelResultList);
            this.tabResults.Controls.Add(this.panelResultServerFilter);
            this.tabResults.Location = new System.Drawing.Point(4, 22);
            this.tabResults.Name = "tabResults";
            this.tabResults.Size = new System.Drawing.Size(792, 474);
            this.tabResults.TabIndex = 3;
            this.tabResults.Text = "Results";
            this.tabResults.Visible = false;
            // 
            // panelResultList
            // 
            this.panelResultList.Controls.Add(this.testResultTree1);
            this.panelResultList.Dock = System.Windows.Forms.DockStyle.Fill;
            this.panelResultList.Location = new System.Drawing.Point(128, 0);
            this.panelResultList.Name = "panelResultList";
            this.panelResultList.Size = new System.Drawing.Size(664, 474);
            this.panelResultList.TabIndex = 1;
            // 
            // testResultTree1
            // 
            this.testResultTree1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.testResultTree1.LastSelected = null;
            this.testResultTree1.Location = new System.Drawing.Point(0, 0);
            this.testResultTree1.Name = "testResultTree1";
            this.testResultTree1.Size = new System.Drawing.Size(664, 474);
            this.testResultTree1.TabIndex = 0;
            this.testResultTree1.SelectedIndexChanged += new RegDBViewer.SelectedRowChangedHandler(this.testResultTree1_SelectedIndexChanged);
            // 
            // panelResultServerFilter
            // 
            this.panelResultServerFilter.Controls.Add(this.chkFilterServers);
            this.panelResultServerFilter.Controls.Add(this.clbServerList);
            this.panelResultServerFilter.Dock = System.Windows.Forms.DockStyle.Left;
            this.panelResultServerFilter.Location = new System.Drawing.Point(0, 0);
            this.panelResultServerFilter.Name = "panelResultServerFilter";
            this.panelResultServerFilter.Size = new System.Drawing.Size(128, 474);
            this.panelResultServerFilter.TabIndex = 0;
            // 
            // chkFilterServers
            // 
            this.chkFilterServers.Dock = System.Windows.Forms.DockStyle.Top;
            this.chkFilterServers.Location = new System.Drawing.Point(0, 0);
            this.chkFilterServers.Name = "chkFilterServers";
            this.chkFilterServers.Size = new System.Drawing.Size(128, 24);
            this.chkFilterServers.TabIndex = 1;
            this.chkFilterServers.Text = "Filter Server List";
            // 
            // clbServerList
            // 
            this.clbServerList.Dock = System.Windows.Forms.DockStyle.Fill;
            this.clbServerList.Location = new System.Drawing.Point(0, 0);
            this.clbServerList.Name = "clbServerList";
            this.clbServerList.Size = new System.Drawing.Size(128, 469);
            this.clbServerList.TabIndex = 0;
            // 
            // ttip
            // 
            this.ttip.AutoPopDelay = 30000;
            this.ttip.InitialDelay = 333;
            this.ttip.ReshowDelay = 500;
            this.ttip.ShowAlways = true;
            // 
            // GUI
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(800, 521);
            this.Controls.Add(this.panelMaster);
            this.Controls.Add(this.panelRunControl);
            this.Menu = this.mainMenu1;
            this.Name = "GUI";
            this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
            this.Text = "STFRunner";
            this.panelRunControl.ResumeLayout(false);
            this.panelMaster.ResumeLayout(false);
            this.tabMasterControl.ResumeLayout(false);
            this.tabFunctional.ResumeLayout(false);
            this.splitFunc.Panel1.ResumeLayout(false);
            this.splitFunc.Panel2.ResumeLayout(false);
            this.splitFunc.ResumeLayout(false);
            this.tabRegDB.ResumeLayout(false);
            this.splitRegH.Panel1.ResumeLayout(false);
            this.splitRegH.Panel2.ResumeLayout(false);
            this.splitRegH.ResumeLayout(false);
            this.splitInsideReg.Panel1.ResumeLayout(false);
            this.splitInsideReg.Panel2.ResumeLayout(false);
            this.splitInsideReg.ResumeLayout(false);
            this.panelRegBuild.ResumeLayout(false);
            this.panelBuildRegBuild.ResumeLayout(false);
            this.tabCerts.ResumeLayout(false);
            this.tabResults.ResumeLayout(false);
            this.panelResultList.ResumeLayout(false);
            this.panelResultServerFilter.ResumeLayout(false);
            this.ResumeLayout(false);

        }
#endregion

#region NondesignerInitializeComponent

        /// <summary>
        /// The place to put any code that would upset the Designer.
        /// </summary>
        private void NondesignerInitializeComponent ()
        {
            this.splitInsideReg.SplitterDistance = this.splitInsideReg.Width - 235;
            this.tvReg.AllowFancyTags=false;
            this.tvReg.HideSelection=false;

        }

#endregion

#region Run and Status control
        /// <summary>
        /// Called asynchronously when the "Start" button is clicked
        /// </summary>
        private void RunAllFunctionalTests()
        {
            GUITestEventListener listener = new GUITestEventListener(tvTests, report);
            scheduler = new FunctionalScheduler();
            scheduler.Initialize(config, suites);
            scheduler.Start(listener);
            scheduler = null;
        }

        /// <summary>
        /// Called asynchronously when the "Stop" button is clicked but the tests are still running
        /// </summary>
        private void StopFunctionalRun()
        {
            if(scheduler != null)
            {
                scheduler.Stop();
            }
        }

        /// <summary>
        /// Called asynchronously when the tests have completed
        /// </summary>
        private void FunctionalTestsComplete()
        {
            Global.RO.Info("Functional test run complete.");

            //kill regdb logging if it's going
            report.Dispose();
            report=null;
            
            // changes to the results pane (disabled for now)
            //tabMasterControl.SelectedIndex=2;
            LoadServerList();
            LoadData(null);
            panelResultServerFilter.Visible = menuViewFilters.Checked;

            // Call the callback method, if set
            if (FuncStopActionMethod != null)
                FuncStopActionMethod(FuncStopActionMethodData);

            // Clear it
            FuncStopActionMethod = null;
            FuncStopActionMethodData = null;

        }

        private bool Start()
        {
            viewResultsFromDB= false;
            menuItem7.Checked = false;
            if (report != null)
            {
                report.Dispose();
                report = null;
            }

            suites.DisableAll();
            string[] suiteNames = tvTests.GetEnabledSuiteNames();
            foreach(string name in suiteNames)
            {
                suites.Enable(name);
            }

            // Remove all suite sections from xml doc
            foreach (XmlNode node in config.SelectNodes("/stf/tests/suite"))
                node.ParentNode.RemoveChild(node);
            RemoveEmptyNodes(config, "/stf/tests");

            config.Merge(tvTests.GenerateConfigFile(), "/stf");

            // If regression data is to be logged we collect the information from the user
            // and store it in the internal config document. This is then passed to the agent
            // which will use the information to connect to the regression database.
            if (chkRegDB.Checked)
            {
                RegDBSettings settings = new RegDBSettings();
                settings.LoadFromConfig(config);

                // Create a form for the user to enter information about this regression run
                // capture the result of the form button in 'result'
                RegDBForm rdbf = new RegDBForm(settings.IpAddresses);
                DialogResult result = rdbf.ShowDialog(this);

                // If the user does not cancel we will save off their settings 
                // in the in-memory XML config for the next run.
                if (result != DialogResult.Cancel)
                {
                    settings.DefaultIpAddress   = rdbf.comboBox1.Text;
                    settings.BuildNumber        = rdbf.BuildNo;
                    settings.Iteration          = rdbf.IterationNo.ToString();

                    settings.SaveToConfig(config);

                    // Create a class instance to handle queries against the 
                    // regression database
                    queryManager = new RegDBQueryManager(settings.DefaultIpAddress);

                    // try to reporting to the regression database
                    try 
                    {
                        report = new RegDB(settings.BuildNumber, Int32.Parse(settings.Iteration));
                    }
                    catch(Exception ex)
                    {
                        Global.RO.Error("Could not create the regression database reporting object: " + ex.Message);
                    }
                }
                else //they hit cancel
                {
                    Global.RO.Debug("Run cancelled.");
                    return false;
                }
                    
                // All done with the dialog
                rdbf.Dispose();
            }

            //should we run only DVT tests?
            config.SetBoolParameter("dvtmode", chkDvt.Checked);
            //should we disable async?
            config.SetBoolParameter("noasyncmode", chkDisableAsync.Checked);
            //number of times to try each one?
            config.SetParameter("tryruncount",chkRetryFailures.Checked?"3":"1");
            //force environment reset?
            config.SetBoolParameter("forceenvreset",chkForceNpdb.Checked);
            //run in a loop forever?
            config.SetBoolParameter("loopforever",chkRunLoop.Checked);

            //
            if(report == null)
            {
                report = new RegressionReport("Test Results");
            }

            // Put the cursor at the end of the logging textbox
            int len = logView.TextLength;
            logView.Focus();
            logView.Select(len, len);

            // Reset the progress bar
            progressBar1.Value = 0;
            progressBar1.Step = 1;
            progressBar1.Maximum = 100;

            // Reset the tree coloring status
            tvTests.ResetTreeStatus();

            return true;
        }
#endregion //Run and Status control

#region Misc Util
        private void RemoveEmptyNodes(XmlDocument doc, string xpath)
        {
            foreach (XmlNode node in doc.SelectNodes(xpath))
                if (node.ChildNodes.Count == 0)
                    node.ParentNode.RemoveChild(node);
        }

        private void LoadFile(string filename)
        {
            XmlTextReader tr=new XmlTextReader(filename);
            XmlDocument doc=new XmlDocument();
            doc.Load(tr);
            
            tvTests.ClearAllChecks();
            tvTests.LoadState(doc);
            tr.Close();     
        }

        private void SaveFile(string filename)
        {
            XmlDocument doc=tvTests.GenerateConfigFile();
            XmlTextWriter tw=new XmlTextWriter(filename, System.Text.Encoding.ASCII);
            tw.IndentChar = '\t';
            tw.Indentation = 1;
            tw.Formatting = Formatting.Indented;
            doc.WriteTo(tw);
            tw.Close();
        }
        
        private void LoadServerList()
        {
            if(queryManager!=null && (chkRegDB.Checked || viewResultsFromDB))
            {
                ServerList sl = queryManager.GetServerList();
                clbServerList.Items.Clear();
                foreach (Server s in sl)
                    if (s.Servername.Trim() != "")
                        clbServerList.Items.Add(s);
            }
        }

        public void LoadData(ItemRow selected) {LoadData(selected, GenerateQuery(null));}
        private void LoadData(ItemRow selected, RegDBViewer.RegDBQuery query)
        {
            bool Display=false;
            ItemRowList root = null;
            if (queryManager!=null && (chkRegDB.Checked || viewResultsFromDB))
            {
                root = queryManager.GetItems(query, selected);
                Display= true;
            }
            else
            {
                if(report!=null)
                {
                    root = report.GetItems();
                    Display= true;
                }
            }
                

            if(Display)
            {
                testResultTree1.SuspendLayout();
                testResultTree1.Items.Clear();
                InsertBranch(root, 0);
                testResultTree1.ResumeLayout();
            }
        }

        private RegDBViewer.RegDBQuery GenerateQuery(ItemCheckEventArgs e)
        {
            if (clbServerList.CheckedItems.Count + (e == null ? 0 : (e.NewValue == CheckState.Checked ? 1 : -1)) == 0)
                return null;

            RegDBViewer.RegDBQuery query = new RegDBViewer.RegDBQuery();

            if (chkFilterServers.Checked)
            {
                foreach (Server s in clbServerList.CheckedItems)
                    query.AddServer(s.ID);
            }

            if (e != null)
            {
                if (e.NewValue == CheckState.Checked)
                    query.AddServer(((Server)clbServerList.Items[e.Index]).ID);
                else
                    query.RemoveServer(((Server)clbServerList.Items[e.Index]).ID);
            }

            return query;
        }

        private int InsertBranch(ItemRowList items, int index)
        {
            foreach (ItemRow item in items)
            {
                if (item==null)
                    continue;

                if (menuShowOnlyFailedTests.Checked && item.Fail == 0)
                    continue;

                testResultTree1.Items.Insert(index, item);
                index++;

                if (item.Children != null && item.Children.Count > 0 && item.SubTreeOpen)
                    index = InsertBranch(item.Children, index);
            }

            return index;
        }
#endregion  //Misc Util

#region Event Handlers

        private void button1_Click(object sender, System.EventArgs e)
        {
            menuItemSearchDLL_Click(sender,e);
        }

        private void btnLoadCert_Click(object sender, System.EventArgs e)
        {
            OFD.Filter = "Certificate files (*.cer;*.pfx)|*.cer;*.pfx|All files|*.*";
            if (OFD.ShowDialog()!=DialogResult.OK)
                return;

            FileStream fs = File.OpenRead(OFD.FileName);
            byte[] cert = new byte[fs.Length];
            fs.Read(cert, 0, (int)fs.Length);

            Match match = new Regex(@"(?:^|\\)([^\\]+)\.([^\\\.]+)$").Match(OFD.FileName);
            string certName = Path.GetFileNameWithoutExtension(OFD.FileName);
            CertificateEntry.CertType ct = CertificateEntry.CertType.X509;
            if (Path.GetExtension(OFD.FileName) == "pfx")
                ct = CertificateEntry.CertType.PKCS12;

            CertificateEntry ce = new CertificateEntry(certName, cert, ct, false);
            lstCerts.Items.Add(ce);
            lstCerts.SelectedItem = ce;

            btnCertClipboard.Enabled = true;
            btnCertView.Enabled = true;
        }

        private void btnCertClipboard_Click(object sender, System.EventArgs e)
        {
            if (lstCerts.SelectedIndex != -1)
            {
                CertificateEntry ce = (CertificateEntry)lstCerts.SelectedItem;
                string typeName = ce.Type == CertificateEntry.CertType.PKCS12 ? "pkcs12" : "x509";
                Clipboard.SetDataObject("<" + typeName + " name='" + ce.Name + "'>" + Convert.ToBase64String(ce.Cert) + "</" + typeName + ">");
            }
        }

        private void btnCertView_Click(object sender, System.EventArgs e)
        {
            CertificateEntry ce = (CertificateEntry)lstCerts.SelectedItem;

            string tempFileName = ce.Type == CertificateEntry.CertType.PKCS12 ? "temp.pfx" : "temp.cer";
            FileStream fs = File.OpenWrite(tempFileName);
            fs.Write(ce.Cert, 0, ce.Cert.Length);
            fs.Close();

            ProcessStartInfo psi = new ProcessStartInfo(tempFileName);
            psi.FileName = tempFileName;
            psi.UseShellExecute = true;
            Process p = Process.Start(psi);
            p.WaitForExit();
        }

        private void menuItem4_Click(object sender, System.EventArgs e)
        {
            Close();
        }

        private void menuViewFilters_Click(object sender, System.EventArgs e)
        {
            menuViewFilters.Checked = !menuViewFilters.Checked;
            panelResultServerFilter.Visible = menuViewFilters.Checked;
        }

        private void menuShowOnlyFailedTests_Click(object sender, System.EventArgs e)
        {
            /* Was:
            menuShowOnlyFailedTests.Checked = !menuShowOnlyFailedTests.Checked;
            LoadData(testResultTree1.LastSelected);
            */

            tvTests.PruneChecksToFailedTests();
        }

        private void menuRefresh_Click(object sender, System.EventArgs e)
        {
            testResultTree1.LastSelected = null;
            LoadServerList();
            LoadData(null);
        }

        private void testResultTree1_SelectedIndexChanged(object sender, RegDBViewer.SelectedRowChangedEventArgs e)
        {
            LoadData(e.Row);
        }

        private void tabMasterControl_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            /*if(tabMasterControl.SelectedIndex==2)
            {
                LoadServerList();
                LoadData(null);
                panelResultServerFilter.Visible = menuViewFilters.Checked;
            }
            */
        }

        private void clbServerList_ItemCheck(object sender, System.Windows.Forms.ItemCheckEventArgs e)
        {
            LoadData(null, GenerateQuery(e));
        }

        private void menuItem7_Click(object sender, System.EventArgs e)
        {
            menuItem7.Checked = true;

            if(menuItem7.Checked)
            {
                viewResultsFromDB = true;
                queryManager= new RegDBQueryManager();
                LoadServerList();
                LoadData(null);
                panelResultServerFilter.Visible = menuViewFilters.Checked;
                tabMasterControl.SelectedIndex=2;
            }
                
        }

        private void ReportMenu_Select(object sender, System.EventArgs e)
        {
            MenuItem mitem = (MenuItem)sender;

            //handle selecting that option
            if (sender == menuItemReportEnable) //all on
            {
                menuItem9.Checked = menuItem15.Checked = menuItem16.Checked = 
                menuItem17.Checked = menuItem18.Checked = menuItem22.Checked = true;
            }
            else if (sender == menuItemReportDisable) //all off
            {
                menuItem9.Checked = menuItem15.Checked = menuItem16.Checked = 
                menuItem17.Checked = menuItem18.Checked = menuItem22.Checked = false;
            }
            else //normal single togggle
            {
                mitem.Checked = !mitem.Checked;
            }

            //calc new filter
            uint currentFilter=0;

            currentFilter |= (menuItem9.Checked ?Report.DEBUG : 0); //DEBUG
            currentFilter |= (menuItem15.Checked?Report.INFO  : 0); //INFO
            currentFilter |= (menuItem16.Checked?Report.WARN  : 0); //WARN
            currentFilter |= (menuItem17.Checked?Report.ERROR : 0); //ERROR
            currentFilter |= (menuItem18.Checked?Report.FATAL : 0); //FATAL
            currentFilter |= (menuItem22.Checked?Report.SUCCESS:0); //SUCCESS

            //update filter
            Report.GetRoot().SetLevelFilter(currentFilter);

            try
            {
                string currentFilterSetting = currentFilter.ToString();
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.ReportLogFilterKeyName, currentFilterSetting);
            }
            catch(Exception ex)
            {
                Global.RO.Error(ex.GetType().FullName + " trying to open the registry key: " + Global.CommonAppDataRegistry.Name + ", message: " + ex.Message);
            }
        }

        private void menuItem19_Click(object sender, System.EventArgs e)
        {
            logView.Clear();
        }

        // this method has to go through Control.Invoke so that the GUI is modified through the UI thread
        private delegate void AddSuiteDelegate(TestSuite suite);
        private delegate void RemoveSuiteDelegate(string suiteName);
        private void SuiteAddedHandler(object sender, TestSuiteContainer.AddSuiteEventArgs e)
        {
            if(tvTests.IsHandleCreated)
            {
                Invoke(new AddSuiteDelegate(tvTests.AddSuite), new object[]{e.Suite});
                Invoke(new AddSuiteDelegate(tvReg.AddSuite), new object[]{e.Suite});
            }

            lock (lockPendingRegDBSuiteLoads)
            {
                pendingRegDBSuiteLoads.Add(e.Suite.Name);
            }
        }
        private void SuiteRemovedHandler(object sender, TestSuiteContainer.RemoveSuiteEventArgs e)
        {
            if(tvTests.IsHandleCreated)
            {
                Invoke(new RemoveSuiteDelegate(tvTests.RemoveSuite), new object[]{e.Name});
                Invoke(new RemoveSuiteDelegate(tvReg.RemoveSuite), new object[]{e.Name});
            }
        }

        public delegate void InvokeRegDBSuiteNode();

        private void UpdateRegDBTabSuiteList()
        {
            lock (lockPendingRegDBSuiteLoads)
            {
                foreach (string suiteName in pendingRegDBSuiteLoads)
                {
                    try
                    {
                        //get RegDB's view of the tree
                        RegDBTreeReader.Node suiteNode=RegDBTreeReader.GetSuiteTree((string)suiteName);
                        if (suiteNode==null) continue;

                        //merge them
                        tvReg.Invoke(new InvokeRegDBSuiteNode(delegate {MergeRegDBSuiteWithTVReg(suiteNode);}));
                    }
                    catch (Exception e)
                    {
                        Global.RO.Debug("Error getting RegDB's view of the suite " +suiteName + ": " + e.Message);
                    }
                }

                pendingRegDBSuiteLoads.Clear();
            }
        }

        private void MergeRegDBSuiteWithTVReg(RegDBTreeReader.Node suiteNode)
        {
            //for each suite that RegDB sees
            foreach (RegDBTreeReader.Node groupRegNode in suiteNode.Children)
            {
                if (groupRegNode.Name == ThreadTracker.DefaultGroupName) continue;

                //see if the tvReg tree view has that group and add it if not
                TestTreeNode ttGroupNode=tvReg.GetTreeNode(suiteNode.Name, groupRegNode.Name, null);
                
                if (ttGroupNode==null)
                {
                    ttGroupNode=new TestTreeNode(groupRegNode.Name);
                    ttGroupNode.NodeLevel=1;
                    ttGroupNode.ForeColor=Color.Gray;
                    ttGroupNode.TestName=groupRegNode.Name;

                    tvReg.GetTreeNode(suiteNode.Name,null,null).Nodes.Add(ttGroupNode);
                }

                //look through the tvReg group node's children to see if RegDB has any cases not listed there and add them if so
                foreach (RegDBTreeReader.Node caseRegNode in groupRegNode.Children)
                {
                    if (caseRegNode.Name == ThreadTracker.DefaultCaseName) continue;

                    TestTreeNode ttCaseNode=tvReg.GetTreeNode(suiteNode.Name, groupRegNode.Name, caseRegNode.Name);
                    
                    if (ttCaseNode==null)
                    {
                        ttCaseNode=new TestTreeNode(caseRegNode.Name);
                        ttCaseNode.NodeLevel=2;
                        ttCaseNode.ForeColor=Color.Gray;
                        ttCaseNode.TestName=caseRegNode.Name;

                        ttGroupNode.Nodes.Add(ttCaseNode);
                    }                    
                }
            }
        }

        // this is required because the handler is not installed before the window is instantiated
        // and some testsuites will be loaded by the user on startup
        private void GUI_HandleCreated(object sender, EventArgs e)
        {
            TestSuite[] suitesArray = suites.GetLoadedSuites();
            for(int i = 0; i < suitesArray.Length; ++i)
            {
                tvTests.AddSuite(suitesArray[i]);
                tvReg.AddSuite(suitesArray[i]);
            }

            tvTests.LoadState();

            // Load the selected items here
            try
            {
                LoadFile(k_StfRunnerStateFile);
            }
            catch
            {
                // Don't really care about any events here, this is only a value-added feature
            }
        }

        // Serialize implicit window settings to the registry so that the window can be
        // restored on create
        private void GUI_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            // Remove gui report destination so we don't wait on ourself to handle output to it
            ServerTestFramework.Report.GetRoot().RemoveReportDestination(guiReporter);
            guiReporter=null;

            // Save the selected items here
            try
            {
                SaveFile(k_StfRunnerStateFile);
            }
            catch
            {
                // Don't really care about any events here, this is only a value-added feature
            }

            try
            {
                if (this.WindowState == FormWindowState.Normal) // don't save the form size if the form is max'd or min'd
                {
                    Global.CommonAppDataRegistry.SetValue(RunnerGlobal.FunctionalWindowTopKeyName, this.Top.ToString());
                    Global.CommonAppDataRegistry.SetValue(RunnerGlobal.FunctionalWindowLeftKeyName, this.Left.ToString());
                    Global.CommonAppDataRegistry.SetValue(RunnerGlobal.FunctionalWindowWidthKeyName, this.Width.ToString());
                    // Rein: there's a bug somewhere that makes the window grow by 19 pixels each time it's closed.
                    // I can't spend more time trying to find this bug but it's annoying as hell.
                    Global.CommonAppDataRegistry.SetValue(RunnerGlobal.FunctionalWindowHeightKeyName, (this.Height - 19).ToString());  
                }
                float sbarPositionRatio = 0.5f;
                if (splitFunc.Height > 0)
                    sbarPositionRatio = (float)splitFunc.SplitterDistance/splitFunc.Height;
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.FunctionalWindowSplitterRatioKeyName, sbarPositionRatio.ToString());
                string csName;
                if (menuItemColorSchemeWhite.Checked)
                    csName = "menuItemColorSchemeWhite";
                else
                    csName = "menuItemColorSchemeBlack";  // default
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.GUIReportColorSchemeName, csName);
                if (this.guiReporter!=null)
                {
                    Global.CommonAppDataRegistry.SetValue(RunnerGlobal.GUIReportColorSchemeFontName, this.guiReporter.GetColorScheme().TextFont.Name.ToString());
                    Global.CommonAppDataRegistry.SetValue(RunnerGlobal.GUIReportColorSchemeFontSize, this.guiReporter.GetColorScheme().TextFont.Size.ToString());
                }
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.DefaultNpdbSetting, Global.DefaultNpdbSetting.ToString());

                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.FunctionalForceNpdbKeyName, (this.chkForceNpdb.Checked?"1":"0"));                
            }
            catch(Exception ex)
            {
                Global.RO.Error(ex.GetType().FullName + " trying to open the registry key: " + Global.CommonAppDataRegistry.Name + ", message: " + ex.Message);
            }
        }

        //Gui resized
        private void GUI_Resize(object sender, EventArgs e)
        {

        }

        private void TestMenuPopupHandler(object sender, EventArgs e)
        {
            ContextMenu menu = (sender as ContextMenu);
            TestTree tree = (menu.SourceControl as TestTree);
            TestTreeNode node = tree.NodeUnderMouse;
            Menu.MenuItemCollection mi = menu.MenuItems;

            mi.Clear();
            if (node == null)
            {
                mi.Add("Load new suite...", new System.EventHandler(this.LoadSuiteMenuHandler));
                return;
            }

            switch (node.NodeLevel)
            {
                case 0:     // TestSuite
                    mi.Add("Unload " + node.TestName, new System.EventHandler(this.UnloadSuiteMenuHandler));
                    mi.Add("Load new suite...", new System.EventHandler(this.LoadSuiteMenuHandler));
                    mi.Add(new MenuItem("-"));
                    mi.Add("Set Suite's AsyncSuite value", new System.EventHandler(this.SetSuiteAsyncSuiteMenuHandler));
                    mi.Add("Set AsyncSet value for every group in suite", new System.EventHandler(this.SetSuiteAsyncSetMenuHandler));
                    mi.Add(new MenuItem("-"));
                    mi.Add("Regression log for this suite", new System.EventHandler(this.RegressionLogSuiteHandler));
                    break;
                case 1:     // TestGroup
                    mi.Add("Set Group's AsyncSet value", new System.EventHandler(this.SetGroupAsyncSetMenuHandler));
                    mi.Add("Set AsyncGroup value for every test in group", new System.EventHandler(this.SetGroupAsyncGroupMenuHandler));
                    mi.Add(new MenuItem("-"));
                    mi.Add("Regression log for this group", new System.EventHandler(this.RegressionLogGroupHandler));
                    break;
                case 2:     // TestCase
                    mi.Add("View output from this case", new System.EventHandler(this.ViewSingleCaseOutput));
                    mi.Add("Set Test's AsyncGroup value", new System.EventHandler(this.SetTestAsyncGroupMenuHandler));
                    mi.Add("Toggle Ignore on this case", new System.EventHandler(this.ToggleIgnoreMenuHandler));
                    mi.Add(new MenuItem("-"));
                    if (node.BugID != null)
                    {
                        mi.Add("Lookup bug " + node.BugID + " in \"Xenon\" db", new System.EventHandler(this.BugViewMenuHandler));
                    }
                    mi.Add("Regression log for this case", new System.EventHandler(this.RegressionLogCaseHandler));
                    break;
            }

            // Common items
            MenuItem miRegression = new MenuItem(
                "Regression history for " + node.TestTypeString + " " + node.TestName,
                new System.EventHandler(this.RegressionHistoryMenuHandler));
            mi.Add(miRegression);

            bool isRunningNow=!(bStart.Text.Contains("Start"));
            if (!isRunningNow)
            {
                MenuItem miExecute = new MenuItem(
                    "Execute " + node.TestTypeString + " " + node.TestName,
                    new System.EventHandler(this.ExecuteTestMenuHandler));

                mi.Add(miExecute);
            }
        }

        private void TestMenuDoubleClickHandler(object sender, EventArgs e)
        {
            TestTree tree = sender as TestTree;
            TestTreeNode node = tree.NodeUnderMouse;

            switch (node.NodeLevel)
            {
                case 0:     // TestSuite
                    break;
                case 1:     // TestGroup
                    break;
                case 2:     // TestCase
                    ViewSingleCaseOutput(sender,e);
                    break;
            }
        }

        private object regDBAsyncTVLock=new object();

        public delegate void InvokeDamnit(); //*shakefist*

        private void RegTreeClickHandler(object sender, EventArgs e)
        {
            TestTree tree = sender as TestTree;
            TestTreeNode node = tree.NodeUnderMouse;
            if (node==null) return;

            ThreadMaker.CreateThread(RegTreeRetrieveBuildsThread,node).Start();
        }

        private void RegTreeRetrieveBuildsThread(object chosenNode)
        {
            TestTreeNode node=(TestTreeNode)chosenNode;

            string suiteName, groupName, caseName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out caseName);

            //make an inquirer for us to use
            RegDBInquirer q=null;
            switch (node.NodeLevel)
            {
                case 0:     // TestSuite
                    q=new RegDBInquirer(suiteName);
                    break;
                case 1:     // TestGroup
                    q=new RegDBInquirer(suiteName,groupName);
                    break;
                case 2:     // TestCase
                    q=new RegDBInquirer(suiteName,groupName,caseName);
                    break;
            }

            lock (regDBAsyncTVLock)
            {
                //cancel and log retrievals and old requests
                if (regInq!=null)
                {
                    regInq.CancelGetLog();
                }

                //request is now for us
                regInq=q;

                //wipe old build list and output display
                logRegView.Invoke(new InvokeDamnit(delegate {lstRegBuild.Items.Clear();}));
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Clear();}));

                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"Looking up build list for: "+suiteName+" "+groupName+" "+caseName+"...");}));
            }

            //retrieve build history
            RegDBInquirer.RegDBHistory []rhist;
            try
            {
                rhist=q.GetHistory();
            }
            catch (Exception ex)
            {
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"Error getting build history: " + ex.Message);}));
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"Stack: " + ex.StackTrace);}));
                return;
            }

            //if the inquirer changed, we've been superceded by another request
            lock (regDBAsyncTVLock)
            {
                if (q!=regInq)
                {
                    return;
                }

                //put build in the box
                foreach (RegDBInquirer.RegDBHistory h in rhist)
                {
                    string bStr=h.Environment+": "+h.Build+"."+h.Iteration;
                    int pad=(4+1+2+1+2+1+3)-bStr.Length + 1;
                    for (uint i=0; i<pad; ++i)
                        bStr+=" ";
                    logRegView.Invoke(new InvokeDamnit(delegate {lstRegBuild.Items.Add(bStr+"["+h.Passed+" / "+(h.Passed+h.Failed)+ "]");}));
                }

                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"Retrieved history for: "+suiteName+" "+groupName+" "+caseName+"\n");}));
                if (rhist==null || rhist.Length==0)
                {
                    logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"No builds found.");}));
                }
                else
                {
                    logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"Please select a build.");}));
                }
            }
        }

        private void RegBuildClickHandler(object sender, EventArgs e)
        {
            if (regInq==null) return;

            //locate the build they want
            int indList=lstRegBuild.SelectedIndex;
            if (indList==-1) return;

            ThreadMaker.CreateThread(RegBuildRetrieveHistoryThread,indList).Start();
        }

        private void RegBuildRetrieveHistoryThread(object indList)
        {
            RegDBInquirer myInq=regInq;
            if (myInq==null) return;

            //stop any old history retrieval and wipe the output
            myInq.CancelGetLog();
            if (myInq!=regInq) return;

            lock (regDBAsyncTVLock)
            {
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Clear();}));

                //get the build history that they want
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"RegDB: Retrieving logs...");}));
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"");}));
            }
             
            RegDBInquirer.RegDBHistory []rhist=myInq.GetHistory();
            RegDBInquirer.RegDBHistory hist = rhist[(int)indList];

            //output it to the display, piped through GUIReportDestination
            GUIReportDestination rd=new GUIReportDestination(logRegView);

            myInq.GetLog(hist, rd);

            //
            lock (regDBAsyncTVLock)
            {
                if (myInq!=regInq) return;

                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"");}));
                logRegView.Invoke(new InvokeDamnit(delegate {logRegView.Append(Color.White,"RegDB: Query complete.");}));
            }
        }

        // handle clicks on the unload context menu
        private void UnloadSuiteMenuHandler(object sender, EventArgs e)
        {
            TreeNode node = tvTests.SelectedNode;
            if(!suites.IsolateTestSuites)
            {
                MessageBox.Show("STFRunner is not running in isolated AppDomain mode.", "Unload Suite Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
            else
            {
                if(suites.Contains(node.Text))
                {
                    suites.UnloadSuite(node.Text);
                }
            }
        }

        private void LoadSuiteMenuHandler(object sender, EventArgs e)
        {
            //store current directory: win32 common controls evilly alter the current directory, which can screw a lot of things up
            string curDir = System.Environment.CurrentDirectory;

            // Popup handler opens file dialog so user can manually load a test suite DLL.
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.CheckFileExists = true;
            ofd.CheckPathExists = true;
            ofd.Filter = "Test Suite Assemblies (*.dll)|*.dll";
            DialogResult res = ofd.ShowDialog();

            //fix back current directory then load those suites
            System.Environment.CurrentDirectory = curDir;

            if (res == DialogResult.OK)
            {
                suites.LoadFile(ofd.FileName);
            }
        }

        private void ExecuteTestMenuHandler(object sender, EventArgs e)
        {
            // Sender is the MenuItem.  .NET1.1 doesn't allow the node to be attached in the
            // .Tag member (it exists only in .NET2.0), so we'll have to rely on the
            // tree's currently selected node for the "true" sender.
            
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            XmlDocument previousState = tvTests.GenerateConfigFile();
            
            // Clear everything and check only our test(s)
            tvTests.ClearAllChecks();
            tvTests.CheckNode(node, true, true);

            // Restore the state of the tree asynchronously once the test(s) are done executing
            FuncStopActionMethod = new FuncStopActionDelegate(RestoreTreeState);
            FuncStopActionMethodData = (object)previousState;

            // Fake a button click. Executes asynchronously
            asyncButton.Start(this.bStart, null);
        }

        private void RestoreTreeState(object data)
        {
            XmlDocument previousState = (XmlDocument)data;

            // Restore 
            tvTests.ClearAllChecks();
            tvTests.LoadState(previousState);
        }

        private void BugViewMenuHandler(object sender, EventArgs e)
        {
            // Sample bug link:
            // bug://Xenon:13828/

            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            if (node.BugID == null)
                return;
            string url = String.Format("bug://{0}:{1}", "Xenon", node.BugID);
            Process.Start(url);
        }

        private void RegressionHistoryMenuHandler(object sender, EventArgs e)
        {
            // Sender is the MenuItem.  .NET1.1 doesn't allow the node to be attached in the
            // .Tag member (it exists only in .NET2.0), so we'll have to rely on the
            // tree's currently selected node for the "true" sender.

            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;

            // Create the form, it will load data asynchronously
            RegressionHistory reghist = new RegressionHistory(config);
            reghist.ShowHistory(node);
        }

        private void RegressionLogSharedDisplay(RegDBInquirer regInq, string friendlyName)
        {
            //change to RegDB tab
            tabMasterControl.SelectedTab=tabRegDB;

            //expand suite/group
            TestTreeNode chosenNode=tvReg.GetTreeNode(regInq.SuiteName, regInq.GroupName, regInq.CaseName);
            
            TestTreeNode nextNode=chosenNode;
            while (nextNode!=null)
            {
                nextNode.Expand();
                nextNode=(TestTreeNode)nextNode.Parent;
            }

            //select the node and invoke the "click" handler (don't tell me you don't hear that?)
            chosenNode.EnsureVisible();
            tvReg.SelectedNode=chosenNode;
            tvReg.NodeUnderMouse=chosenNode;
            RegTreeClickHandler(tvReg,null);
        }

        private void RegressionLogSuiteHandler(object sender, EventArgs args)
        {
            //get suite name
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);

            //make an inquirer for it and show it
            RegDBInquirer q=new RegDBInquirer(suiteName);
            RegressionLogSharedDisplay(q, suiteName);
        }

        private void RegressionLogGroupHandler(object sender, EventArgs args)
        {
            //get group name and history
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            
            //make an inquirer for it and show it
            RegDBInquirer q=new RegDBInquirer(suiteName, groupName);
            RegressionLogSharedDisplay(q, suiteName+"."+groupName);
        }

        private void RegressionLogCaseHandler(object sender, EventArgs args)
        {
            //get case name and history
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);

            //make an inquirer for it and show it
            RegDBInquirer q=new RegDBInquirer(suiteName, groupName, testName);
            RegressionLogSharedDisplay(q, suiteName+"."+groupName+"."+testName);
        }

        private void SetSuiteAsyncSuiteMenuHandler(object sender, EventArgs args)
        {
            //get new value to set from user
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            uint newValue=(uint)UIGetNumberFromUser("AsyncSuite value",(int)node.AsyncSuite);

            //set into suite
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            TestSuite ts=suites.FindTestSuite(suiteName);
            if (suiteName=="" || ts==null)
            {
                Global.RO.Error("SetSuiteAsyncSuiteMenuHandler: could not find test suite: suite="+suiteName);
                return;
            }
            ts.AsyncSuite=newValue;

            //set ui
            node.AsyncSuite=newValue;
        }
        
        private void SetGroupAsyncSetMenuHandler(object sender, EventArgs args)
        {
            //get new value to set from user
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            uint newValue=(uint)UIGetNumberFromUser("AsyncSet value",(int)node.AsyncSet);

            //set into group
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            TestBaseGroup tbg=suites.FindTestGroup(suiteName,groupName);
            if (groupName=="" || tbg==null)
            {
                Global.RO.Error("SetGroupAsyncSetMenuHandler: could not find test group: suite="+suiteName+" group="+groupName);
                return;
            }
            tbg.AsyncSet=newValue;

            //set ui
            node.AsyncSet=newValue;
        }

        private void SetTestAsyncGroupMenuHandler(object sender, EventArgs args)
        {
            //get new value to set from user
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            uint newValue=(uint)UIGetNumberFromUser("AsyncGroup value",(int)node.AsyncGroup);

            //set into test
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            TestBase test=suites.FindTestCase(suiteName,groupName,testName);
            if (testName=="" || test==null)
            {
                Global.RO.Error("SetTestAsyncGroupMenuHandler: could not find test case: suite="+suiteName+" group="+groupName+" test="+testName);
                return;
            }
            test.AsyncGroup=newValue;

            //set ui
            node.AsyncGroup=newValue;
        }

        private void ToggleIgnoreMenuHandler(object sender, EventArgs args)
        {
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;

            //
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            TestBase test=suites.FindTestCase(suiteName,groupName,testName);
            if (testName=="" || test==null)
            {
                Global.RO.Error("ToggleIgnoreMenuHandler: could not find test case: suite="+suiteName+" group="+groupName+" test="+testName);
                return;
            }

            //set test
            test.Ignore=!test.Ignore;
            if (!test.Ignore) test.Parent.Ignore=false;
            //set ui
            node.Ignored=test.Ignore;
        }

        private void SetGroupAsyncGroupMenuHandler(object sender, EventArgs args)
        {
            //get new value to set from user
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            uint newValue=(uint)UIGetNumberFromUser("AsyncGroup value",(int)node.AsyncGroup);

            //get the group and go through every test in it, so set the value into the test cases
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            TestBaseGroup tbg=suites.FindTestGroup(suiteName,groupName);
            if (groupName=="" || tbg==null)
            {
                Global.RO.Error("SetGroupAsyncGroupMenuHandler: could not find test group: suite="+suiteName+" group="+groupName);
                return;
            }

            foreach (TestBase test in tbg)
            {
                test.AsyncGroup=newValue;
            }

            //go through the ui nodes now and set those
            foreach (TestTreeNode testNode in node.Nodes) //MSDN doc error: ChildNodes doesn't exist, using Nodes
            {
                testNode.AsyncGroup=newValue;
            }
        }

        private void SetSuiteAsyncSetMenuHandler(object sender, EventArgs args)
        {
            //get new value to set from user
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            uint newValue=(uint)UIGetNumberFromUser("AsyncSet value",(int)node.AsyncSet);

            //get the suite and go through every group in it, so set the value into the test group
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);
            TestSuite ts=suites.FindTestSuite(suiteName);
            if (suiteName=="" || ts==null)
            {
                Global.RO.Error("SetSuiteAsyncSetMenuHandler: could not find test suite: "+suiteName);
                return;
            }

            foreach (TestBaseGroup group in ts.GetTestsWithPreservation())
            {
                group.AsyncSet=newValue;
            }

            //go through the ui nodes now and set those
            foreach (TestTreeNode testNode in node.Nodes) //MSDN doc error: ChildNodes doesn't exist, using Nodes
            {
                testNode.AsyncSet=newValue;
            }
        }

        private void ViewSingleCaseOutput(object sender, EventArgs args)
        {
            //get output for the case
            TestTreeNode node = tvTests.SelectedNode as TestTreeNode;
            string suiteName, groupName, testName;
            node.GetNodeHierarchyNames(out suiteName,out groupName,out testName);

            string caseOutput=TestCaseReports.GetCaseOutput(suiteName,groupName,testName);

            //put it into a nice form for the user
            ShowUserNonBlockingTextWindow(testName+" - "+groupName+" - "+suiteName,caseOutput);
        }

        private void DragEnterHandler(object sender, System.Windows.Forms.DragEventArgs e)
        {
            object o = e.Data.GetData(DataFormats.FileDrop);
            if(o != null)
            {
                e.Effect = DragDropEffects.Copy;
            }

            string[] formats = e.Data.GetFormats();
            string s = e.Data.GetType().ToString();
        }

        private void DragDropHandler(object sender, System.Windows.Forms.DragEventArgs e)
        {
            string[] filenames = (string[])e.Data.GetData(DataFormats.FileDrop);
            suites.LoadFiles(filenames);
        }

        private void menuItemColorSchemeBlack_Click(object sender, System.EventArgs e)
        {
            menuItemColorSchemeWhite.Checked = false;
            menuItemColorSchemeBlack.Checked = true;
            this.guiReporter.SetColorScheme(ColorScheme.Default_BlackBackground);
            logRegView.Font=ColorScheme.Default_BlackBackground.TextFont;
            logRegView.BackColor=ColorScheme.Default_BlackBackground.BackgroundColor;
        }

        private void menuItemColorSchemeWhite_Click(object sender, System.EventArgs e)
        {
            menuItemColorSchemeWhite.Checked = true;
            menuItemColorSchemeBlack.Checked = false;
            this.guiReporter.SetColorScheme(ColorScheme.Default_WhiteBackground);
            logRegView.Font=ColorScheme.Default_WhiteBackground.TextFont;
            logRegView.BackColor=ColorScheme.Default_WhiteBackground.BackgroundColor;
        }

        private void menuItemChangeFont_Click(object sender, System.EventArgs e)
        {
            FontDialog fd = new FontDialog();
            ColorScheme cs = this.guiReporter.GetColorScheme();
            fd.Font = cs.TextFont;
            fd.ShowColor = false;
            fd.ShowEffects = false;
            fd.ShowApply = false;
            fd.AllowVerticalFonts = false;
            fd.AllowVectorFonts = false;
            if (fd.ShowDialog() != DialogResult.Cancel)
            {
                cs.TextFont = fd.Font;
                this.guiReporter.SetColorScheme(cs);
                logRegView.Font=cs.TextFont;
                logRegView.BackColor=cs.BackgroundColor;
            }
        }

        // File -> Open...
        private void menuItem2_Click(object sender, System.EventArgs e)
        {
            //store current directory - win32 api's cc will clobber this, and we'll need to restore it
            string curDir = System.Environment.CurrentDirectory;
            
            //
            if (OFD.FileName == "")
            {
                OFD.FileName = SFD.FileName;
            }
            OFD.Filter = "Test configuration file (*.xml)|*.xml|All files (*.*)|*.*";
            DialogResult res = OFD.ShowDialog();
            System.Environment.CurrentDirectory = curDir;
            if (res!=DialogResult.OK)
            {
                return;
            }

            LoadFile(OFD.FileName);
        }

        // File -> Search for DLLs
        private void menuItemSearchDLL_Click(object sender, System.EventArgs e)
        {
            try
            {
                int numSuites = tvTests.Nodes.Count;
                suites.LoadAllSuitesInPath(@".");
                suites.LoadAllSuitesInPath(@".\\Suites");

                // If we didn't find any new suites
                if (numSuites == tvTests.Nodes.Count)
                {
                    OpenFileDialog ofd = new OpenFileDialog();
                    ofd.Filter = "Test Suites (*.dll)|*.dll";
                    if (ofd.ShowDialog() == DialogResult.OK)
                    {
                        suites.LoadAllSuitesInPath(Path.GetDirectoryName(ofd.FileName));
                    }
                }
            }
            catch(Exception ex)
            {
                Global.RO.Error(ex.GetType().FullName + " trying to search for test suites: " + ex.Message + "\n" + ex.ToString());
            }
        }        

        // File -> Save Selected Tests...
        private void menuItem3_Click(object sender, System.EventArgs e)
        {
            //store current directory - win32 api's cc will clobber this, and we'll need to restore it
            string curDir = System.Environment.CurrentDirectory;

            //
            SFD.Filter = "Test configuration file (*.xml)|*.xml";
            DialogResult res = SFD.ShowDialog();
            System.Environment.CurrentDirectory = curDir;
            if (res!=DialogResult.OK)
            {
                return;
            }

            SaveFile(SFD.FileName);
        }

        // File -> Save Failed Tests...
        private void menuSaveFailedTests_Click(object sender, System.EventArgs e)
        {
            //store current directory - win32 api's cc will clobber this, and we'll need to restore it
            string curDir = System.Environment.CurrentDirectory;

            //
            SFD.Filter = "Test configuration file (*.xml)|*.xml";
            DialogResult res = SFD.ShowDialog();
            System.Environment.CurrentDirectory = curDir;
            if (res!=DialogResult.OK)
            {
                return;
            }

            tvTests.PruneChecksToFailedTests();
            SaveFile(SFD.FileName);
        }

        // File -> Xblob Webstore Install...
        private void menuWebstoreInstall_Click(object sender, System.EventArgs e)
        {
            WebstoreInstall webstore = new WebstoreInstall();
            webstore.Show();
        }

        // View -> Events
        private void menuEvents_Click(object sender, System.EventArgs e)
        {
            EventViewer eventViewer = new EventViewer();
            eventViewer.Show();
        }

        private void menuExpandCheckedNodes_Click(object sender, System.EventArgs e)
        {
            tvTests.ExpandCheckedNodes();
        }

        private void cboNpdbSetting_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            Global.DefaultNpdbSetting = new NpdbSetting((string)cboNpdbSetting.SelectedItem);
            Global.CommonAppDataRegistry.SetValue(RunnerGlobal.DefaultNpdbSetting, Global.DefaultNpdbSetting.ToString());
        }

        private void OpenWireDataFuzzForm (object sender, System.EventArgs e)
        {
            // thread safety through invoke, not that we care too much if we make two of these
            if (wdFuzzForm == null)
            {
                wdFuzzForm = new ServerTestFramework.Utilities.WireDataFuzzForm();
            }

            wdFuzzForm.Show();
            wdFuzzForm.BringToFront();
            wdFuzzForm.WindowState = FormWindowState.Normal;
        }

        private void SplitterDistance_BugFix_OnResize (object sender, System.EventArgs e)
        {
            //workaround for a .NET bug where the underlying framework applies the change from a resize to SplitterDistance, even after explicitely setting it
            ThreadMaker.CreateThread(
                delegate()
                {
                    System.Threading.Thread.Sleep(50);
                    splitRegH.Invoke(new STFSplitContainer.SplitterDistanceDel(splitRegH.SetSplitterDistance), new object[] { splitFunc.SplitterDistance });
                }
                ).Start();
        }

        private void SplitterDistance_BugFix_OnResize_RegDB (object sender, System.EventArgs e)
        {
            //workaround for a .NET bug where the underlying framework applies the change from a resize to SplitterDistance, even after explicitely setting it
            ThreadMaker.CreateThread(
                delegate()
                {
                    System.Threading.Thread.Sleep(50);
                    splitFunc.Invoke(new STFSplitContainer.SplitterDistanceDel(splitFunc.SetSplitterDistance), new object[] { splitRegH.SplitterDistance });
                }
                ).Start();
        }

        private void tabRegDB_Enter_Delegate (object sender, System.EventArgs e)
        {
            ThreadMaker.CreateThread(UpdateRegDBTabSuiteList).Start();
        }

#endregion //Event Handlers

#region UI Helper Functions
        //hrelper to get input from user - cancel will return the default value
        private int UIGetNumberFromUser(string nameOfValue, int defaultValue)
        {
            while (true)
            {
                //make a box for this
                Form form=new Form();
                form.SetBounds(0,0,200,85,BoundsSpecified.Size);
                form.Text=nameOfValue;
                form.FormBorderStyle=FormBorderStyle.FixedDialog;
                form.MaximizeBox=false;

                Size expectedFormSize=new Size(192,58); //for funky windows ui styles, we need to adjust form size
                Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
                form.Size+=diffFormSize;

                //make controls
                TextBox input=new TextBox();
                input.Text=defaultValue.ToString();
                input.SetBounds(25,5,150,25);

                Button butOk=new Button();
                butOk.Text="Ok";
                butOk.SetBounds(15,30,75,25);
                butOk.DialogResult=DialogResult.OK;

                Button butCan=new Button();
                butCan.Text="Cancel";
                butCan.SetBounds(200-15-75,30,75,25);
                butCan.DialogResult=DialogResult.Cancel;

                //put it together and show it
                form.Controls.Add(input);
                form.Controls.Add(butOk);
                form.Controls.Add(butCan);

                form.AcceptButton=butOk;
                form.CancelButton=butCan;
                form.ShowDialog(this);

                //handle result
                //Global.RO.Info("dbg form:  result="+form.DialogResult+"  input="+input.Text + "  parsed="+int.Parse(input.Text));
                if (form.DialogResult==DialogResult.OK)
                {
                    try
                    {
                        return int.Parse(input.Text);
                    }
                    catch
                    {
                        Global.RO.Warn("value entered by user isn't a valid int.. asking for another");
                        MessageBox.Show(form, "Entered value is not a valid integer.");
                    }
                }
                else
                    return defaultValue;
            }
        }

        //helper to show a chunk of text to the user in a window (non-blocking)
        void ShowUserNonBlockingTextWindow(string title, string text)
        {
            //convert \n to windows' goofy \r\n line breaks
            string fixedText=text.Replace("\r","");
            fixedText=fixedText.Replace("\n","\r\n");

            //make form
            Form form=new Form();
            form.SetBounds(0,0,600,350,BoundsSpecified.Size);
            form.Text=title;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            Size expectedFormSize=new Size(592,323); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;
            
            //make text box
            TextBox tbox=new TextBox();
            tbox.Text=fixedText;
            tbox.ReadOnly=true;
            tbox.WordWrap=false;
            tbox.ScrollBars=ScrollBars.Both;
            tbox.Multiline=true;
            tbox.SetBounds(4,4,588,318);
            tbox.SelectionStart=0;
            tbox.SelectionLength=0;
            tbox.SelectedText="";

            tbox.KeyPress+=delegate(object sender, KeyPressEventArgs e) //close on escape key
            {
                if (e.KeyChar == 27)
                {
                    form.Close();
                }
            };

            form.Resize+=delegate(object sender, EventArgs e)
            {
                tbox.Height=form.Height - 32 - diffFormSize.Height;
                tbox.Width=form.Width - 12 - diffFormSize.Width;
            };

            //put together and show to user
            form.Controls.Add(tbox);

            form.Show(this);
        }

        //helper to block and ask the user for an option from a list (ret -1 on cancel)
        int AskUserForListOption(string []opts, string title, int defaultInd)
        {
            //make form
            Form form=new Form();
            form.SetBounds(0,0,300,130,BoundsSpecified.Size);
            form.Text=title;
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(292,103); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            ComboBox input=new ComboBox();
            input.SetBounds(25,20,300-50,25);
            input.Items.AddRange(opts);
            input.SelectedIndex=defaultInd;
            
            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(50,65,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(300-50-75,65,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(input);
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(this);
            
            //extract result
            if (form.DialogResult==DialogResult.OK)
            {
                return input.SelectedIndex;
            }
            else
            {
                return -1;
            }
        }

#endregion

    } //class GUI
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\Global.cs ===
using System;

namespace STFRunner
{
    /// <summary>
    /// Summary description for Global.
    /// </summary>
    public class RunnerGlobal
    {
        

        public const int Version=6;            // StfRunner version. Passed in to TestSuites
        public static int DefaultPort = 11042;
        
        // Registry key names
        public const string ReportLogFilterKeyName              = "ReportLogFilter";
        public const string FunctionalWindowWidthKeyName        = "FunctionalWinWidth";
        public const string FunctionalWindowHeightKeyName       = "FunctionalWinHeight";
        public const string FunctionalWindowTopKeyName          = "FunctionalWinTop";
        public const string FunctionalWindowLeftKeyName         = "FunctionalWinLeft";
        public const string FunctionalWindowSplitterRatioKeyName  = "FunctionalWinSplitterRatio";

        public const string FunctionalForceNpdbKeyName  = "FunctionalForceNpdbBox";

        public const string StressWindowTopKeyName              = "StressWinTop";
        public const string StressWindowLeftKeyName             = "StressWinLeft";
        public const string StressWindowWidthKeyName            = "StressWinWidth";
        public const string StressWindowHeightKeyName           = "StressWinHeight";
        public const string StressWindowSplitterRatioKeyName      = "StressWinSplitterRatio";

        public const string GUIReportColorSchemeName            = "GUIReportColorScheme";
        public const string GUIReportColorSchemeFontName        = "GUIReportColorSchemeFont";
        public const string GUIReportColorSchemeFontSize        = "GUIReportColorSchemeFontSize";
        
        public const string DefaultNpdbSetting                  = "DefaultNpdbSetting";

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\GUIFeedbackFactory.cs ===
using System;
using System.Collections;
using System.Windows.Forms;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFRunner
{
	class GUIFeedbackFactory : FeedbackHandleFactory
	{
		// 
		// Only one progress handle will be active at a time other handles
		// will have their elements released
		//
		class GUIProgressFeedback : ProgressFeedbackHandle
		{
			private STFProgressBar _ProgressBar;
			private string _Message;
			private uint _Value;
			private uint _Maximum;

			public GUIProgressFeedback()
			{
				_ProgressBar = null;
				_Value = 0;
				_Maximum = 0;
			}

			public void AquireElements(STFProgressBar progressBar)
			{
				_ProgressBar = progressBar;
				_ProgressBar.Maximum = (int)_Maximum;
				_ProgressBar.Value = (int)_Value;
				_ProgressBar.Description = _Message;
			}

			public void ReleaseElements()
			{
				_ProgressBar = null;
			}

			public override void SetProgress(uint currentValue, uint totalValue)
			{
				_Maximum = totalValue;
				_Value = currentValue;

				if(_ProgressBar != null)
				{
					_ProgressBar.Maximum = (int)totalValue;
					_ProgressBar.Value = (int)currentValue;
				}
			}

			public override void SetMessage(string message)
			{
				_Message = message;
				if(_ProgressBar != null)
				{
					_ProgressBar.Description = message;
				}
			}
		}


		private STFProgressBar _ProgressBar;
		private ArrayList _ProgressHandles;


		public GUIFeedbackFactory(STFProgressBar progressBar)
		{
			if(progressBar == null)
			{
				throw new ArgumentException("STFProgressBar cannot be null");
			}

			_ProgressBar = progressBar;
			_ProgressHandles = new ArrayList();
		}

		public override ProgressFeedbackHandle CreateProgressFeedback(string title)
		{
			GUIProgressFeedback progress = new GUIProgressFeedback();
			progress.SetMessage(title);

			_ProgressHandles.Insert(0, progress);
			UpdateProgressHandles();

			return progress;
		}

		public override void ReleaseProgressFeedback(ProgressFeedbackHandle handle)
		{
			_ProgressHandles.Remove(handle);
			UpdateProgressHandles();
		}

		// Only the top of the progress handle stack should be active
		private void UpdateProgressHandles()
		{
			if(_ProgressHandles.Count >  0)
			{
				GUIProgressFeedback top = _ProgressHandles[0] as GUIProgressFeedback;
				foreach(GUIProgressFeedback compare in _ProgressHandles)
				{
					if(compare == top)
					{
						compare.AquireElements(_ProgressBar);
					}
					else
					{
						compare.ReleaseElements();
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\RegDBQuery.cs ===
using System;
using System.Collections;

namespace RegDBViewer
{
	public class RegDBQuery
	{
		ArrayList builds = new ArrayList();
		ArrayList servers = new ArrayList();

		public  void AddBuild(int IterationID)
		{
			if(builds.Count < 6)
				builds.Add(IterationID);
		}

		public void AddServer(int SubCompID)
		{
			if(servers.Count<6)
				servers.Add(SubCompID);
		}

		public void RemoveServer(int SubCompID)
		{
			servers.Remove(SubCompID);
		}

		public int GetServerCount()
		{
			return servers.Count;
		}

		public int GetServerAT(int index)
		{
			return (int)servers[index];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\GUIReportDestination.cs ===
using System;
using System.Windows.Forms;
using System.Drawing;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFRunner
{
    // For the output window
    public class ColorScheme
    {
        // Text colors
        public Color DEBUG;
        public Color INFO;
        public Color WARN;
        public Color ERROR;
        public Color FATAL;
        public Color SUCCESS;

        // Output font
        public Font TextFont;

        // RichText background color
        public Color BackgroundColor;

        // Constructor
        public ColorScheme(Color debug, Color info, Color warn, Color error, Color fatal, Color success, Font text, Color background)
        {
            DEBUG = debug;
            INFO = info;
            WARN = warn;
            ERROR = error;
            FATAL = fatal;
            SUCCESS = success;
            TextFont = text;
            BackgroundColor = background;
        }

        // Copy constructor
        public ColorScheme(ColorScheme cs) : this(cs.DEBUG, cs.INFO, cs.WARN, cs.ERROR, cs.FATAL, cs.SUCCESS, cs.TextFont, cs.BackgroundColor)
        {}

        // Presets
        static public ColorScheme Default_BlackBackground = new ColorScheme(
            Color.DarkGray,
            Color.Gainsboro,
            Color.Orange,
            Color.Red,
            Color.Violet,
            Color.LightGreen,
            new Font("Lucida Console", 8),
            Color.Black);

        static public ColorScheme Default_WhiteBackground = new ColorScheme(
            Color.DarkGray,
            Color.Black,
            Color.DarkOrange,
            Color.DarkRed,
            Color.DarkViolet,
            Color.DarkGreen,
            new Font("Lucida Console", 8),
            Color.White);
    }

    /// <summary>
    /// Summary description for ListViewReportDestination.
    /// </summary>
    public class GUIReportDestination : InfiniteLifetimeMarshalByRefObject, ServerTestFramework.Report.Destination
    {
        object _Lock = new object();
        ILogView _LogView;
        ColorScheme currentColorScheme;
		
        public GUIReportDestination(ILogView logView)
        {
            if(logView == null)
                throw new ArgumentNullException("listView");

            _LogView = logView;

            // add a handler to ensure we don't write to a disposed text view
            _LogView.Disposed += new EventHandler(_LogView_Disposed);

            // Set font and background now based on our color scheme
            SetColorScheme(ColorScheme.Default_BlackBackground);
        }

        public void SetColorScheme(ColorScheme cs)
        {
            currentColorScheme = new ColorScheme(cs);
            _LogView.Font = currentColorScheme.TextFont;
            _LogView.BackColor = currentColorScheme.BackgroundColor;
        }

        public ColorScheme GetColorScheme()
        {
            return currentColorScheme;
        }

        // impl from IReportDestination
        public void Log(uint level, string path, string message, string suiteName, string groupName, string caseName, System.DateTime date)
        {
            if(_LogView == null)
                return;

            Color lineColor = Color.White;

            switch(level)
            {
                case ServerTestFramework.Report.DEBUG:
                    lineColor = currentColorScheme.DEBUG;
                    break;
                case ServerTestFramework.Report.INFO:
                    lineColor = currentColorScheme.INFO;
                    break;
                case ServerTestFramework.Report.WARN:
                    lineColor = currentColorScheme.WARN;
                    break;
                case ServerTestFramework.Report.ERROR:
                    lineColor = currentColorScheme.ERROR;
                    break;
                case ServerTestFramework.Report.FATAL:
                    lineColor = currentColorScheme.FATAL;
                    break;
                case ServerTestFramework.Report.SUCCESS:
                    lineColor = currentColorScheme.SUCCESS;
                    break;
            }

			// Underlying LogView is thread-safe
            string logLine=Report.FormatLogLine(date, level, path, message);
			_LogView.Append(lineColor, logLine); 
        }

        private void _LogView_Disposed(object sender, EventArgs e)
        {
            _LogView = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\fSetTime.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace STFRunner
{
	/// <summary>
	/// Summary description for fSetTime.
	/// </summary>
	public class fSetTime : System.Windows.Forms.Form
	{
		private System.Windows.Forms.DateTimePicker day;
		private System.Windows.Forms.NumericUpDown hour;
		private System.Windows.Forms.NumericUpDown minute;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Button bCancel;
		private System.Windows.Forms.Button bOk;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public fSetTime()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		public DateTime Time
		{
			set
			{
				day.Value=value;
				hour.Value=value.Hour;
				minute.Value=value.Minute;
			}
			get
			{
				DateTime dt=new DateTime( day.Value.Year, day.Value.Month, day.Value.Day, (int) hour.Value, (int) minute.Value, 0);
				return dt;
			}
		}
		
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.day = new System.Windows.Forms.DateTimePicker();
			this.hour = new System.Windows.Forms.NumericUpDown();
			this.minute = new System.Windows.Forms.NumericUpDown();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.panel1 = new System.Windows.Forms.Panel();
			this.bOk = new System.Windows.Forms.Button();
			this.bCancel = new System.Windows.Forms.Button();
			((System.ComponentModel.ISupportInitialize)(this.hour)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.minute)).BeginInit();
			this.panel1.SuspendLayout();
			this.SuspendLayout();
			// 
			// day
			// 
			this.day.AllowDrop = true;
			this.day.Location = new System.Drawing.Point(8, 32);
			this.day.Name = "day";
			this.day.Size = new System.Drawing.Size(192, 20);
			this.day.TabIndex = 0;
			// 
			// hour
			// 
			this.hour.Location = new System.Drawing.Point(8, 88);
			this.hour.Maximum = new System.Decimal(new int[] {
																 23,
																 0,
																 0,
																 0});
			this.hour.Name = "hour";
			this.hour.Size = new System.Drawing.Size(48, 20);
			this.hour.TabIndex = 1;
			// 
			// minute
			// 
			this.minute.Increment = new System.Decimal(new int[] {
																	 15,
																	 0,
																	 0,
																	 0});
			this.minute.Location = new System.Drawing.Point(64, 88);
			this.minute.Maximum = new System.Decimal(new int[] {
																   59,
																   0,
																   0,
																   0});
			this.minute.Name = "minute";
			this.minute.Size = new System.Drawing.Size(48, 20);
			this.minute.TabIndex = 2;
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(8, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(100, 16);
			this.label1.TabIndex = 3;
			this.label1.Text = "Stress end date:";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(8, 72);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(100, 16);
			this.label2.TabIndex = 4;
			this.label2.Text = "Stress end time:";
			// 
			// label3
			// 
			this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(56, 88);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(8, 23);
			this.label3.TabIndex = 5;
			this.label3.Text = ":";
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.bOk);
			this.panel1.Controls.Add(this.bCancel);
			this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.panel1.Location = new System.Drawing.Point(0, 126);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(208, 32);
			this.panel1.TabIndex = 6;
			// 
			// bOk
			// 
			this.bOk.Location = new System.Drawing.Point(83, 3);
			this.bOk.Name = "bOk";
			this.bOk.TabIndex = 1;
			this.bOk.Text = "OK";
			this.bOk.Click += new System.EventHandler(this.bOk_Click);
			// 
			// bCancel
			// 
			this.bCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.bCancel.Location = new System.Drawing.Point(3, 3);
			this.bCancel.Name = "bCancel";
			this.bCancel.TabIndex = 0;
			this.bCancel.Text = "Cancel";
			this.bCancel.Click += new System.EventHandler(this.bCancel_Click);
			// 
			// fSetTime
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.bCancel;
			this.ClientSize = new System.Drawing.Size(208, 158);
			this.Controls.Add(this.panel1);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.minute);
			this.Controls.Add(this.hour);
			this.Controls.Add(this.day);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "fSetTime";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Set execution time";
			((System.ComponentModel.ISupportInitialize)(this.hour)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.minute)).EndInit();
			this.panel1.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void bOk_Click(object sender, System.EventArgs e)
		{
			this.DialogResult=DialogResult.OK;
			Close();
		}

		private void bCancel_Click(object sender, System.EventArgs e)
		{
			this.DialogResult=DialogResult.Cancel;
			Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\GUITestEventListener.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Reporting;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;
using System.Windows.Forms;

namespace STFRunner
{
    class GUITestEventListener : InfiniteLifetimeMarshalByRefObject, TestEventListener
    {
        TestTree testTree;
        System.Collections.Generic.Dictionary<string,ProgressInfo> progressInfoList=new System.Collections.Generic.Dictionary<string,ProgressInfo>();
        RegressionReport report;
        uint totalTests;

        public GUITestEventListener(TestTree testTree, RegressionReport report)
        {
            this.testTree = testTree;
            this.report = report;
        }

        public void SetTotalTests(uint count)
        {
            totalTests = count;
        }

        private delegate void TestTreeMarkTreeStatusDelegate(
                        TestAction action, 
                        string suiteName,
                        string groupName,
                        string testName,
                        string details);

        public void OnTestEvent(TestEventArgs e)
        {
            if (testTree.Created && !testTree.Disposing)
            {
                // mark the check box item corresponding to test and it's parents
                if(testTree.IsHandleCreated)
                {
                    // Ensure proper cross-thread serialization
                    testTree.Invoke(new TestTreeMarkTreeStatusDelegate(testTree.MarkTreeStatus),
                            new object[] {
                                e.Action,
                                e.SuiteName,
                                e.GroupName,
                                e.TestName,
                                e.Details});
                }
                else
                {
                    testTree.MarkTreeStatus(e.Action, e.SuiteName, e.GroupName, e.TestName, e.Details);
                }
            }
            
            try 
            {
                switch(e.Action)
                {
                    case TestAction.StartAll:
                        progressInfoList.Add(e.SuiteName,new ProgressInfo("Test run", UInt32.Parse(e.Details), 1));
                        break;
                    case TestAction.StopAll:
                        progressInfoList.Remove(e.SuiteName);
                        break;
                    case TestAction.Start:
                        if(report != null)
                            report.Start(e.SuiteName, e.GroupName, e.TestName, e.Details, e.BugId);
                        break;
                    case TestAction.Pass:
                        progressInfoList[e.SuiteName].Step();
                        if(report != null)
                            report.Pass(e.SuiteName, e.GroupName, e.TestName, e.Details, e.BugId);
                        break;
                    case TestAction.Fail:
                        progressInfoList[e.SuiteName].Step();
                        if(report != null)
                            report.Fail(e.SuiteName, e.GroupName, e.TestName, e.Details, e.BugId);
                        break;
                    case TestAction.Retry:
                        progressInfoList[e.SuiteName].UnStep();
                        break;
                }
            }
            catch (System.Threading.ThreadAbortException)
            {
                //will be propegated out from here automatically
            }
            catch (Exception ex)
            {
                Global.RO.Warn(e.TestName + " failed to log event: " + ex.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\EventViewer.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;

using ServerTestFramework.Database;

namespace STFRunner
{
    /// <summary>
    /// Summary description for EventViewer.
    /// </summary>
    public class EventViewer : System.Windows.Forms.Form
    {
        private object                  lockObject;
        private Events                  DBEvents;
        private Hashtable               columnOrder;
        private int                     columnIndex;

        private string                  searchString;
        private string                  filterServerString;
        private string                  filterServiceString;
        private bool                    filterTimeStartChecked;
        private bool                    filterTimeEndChecked;
        private uint                    filterCount;
        private int                     refreshInterval;

        private System.Threading.Timer  refreshTimer;

        private System.Windows.Forms.ListView        eventListView;
        private System.Windows.Forms.RichTextBox     eventTextBox;

        private System.Windows.Forms.GroupBox        searchGroupBox;
        private System.Windows.Forms.TextBox         searchTextBox;
        private System.Windows.Forms.Button          searchButton;

        private System.Windows.Forms.GroupBox        filterServerGroupBox;
        private System.Windows.Forms.TextBox         filterServerTextBox;
        private System.Windows.Forms.Button          filterServerButton;

        private System.Windows.Forms.GroupBox        filterServiceGroupBox;
        private System.Windows.Forms.TextBox         filterServiceTextBox;
        private System.Windows.Forms.Button          filterServiceButton;

        private System.Windows.Forms.GroupBox        filterTimeStartGroupBox;
        private System.Windows.Forms.DateTimePicker  filterTimeStartPicker;
        private System.Windows.Forms.Button          filterTimeStartButton;

        private System.Windows.Forms.GroupBox        filterTimeEndGroupBox;
        private System.Windows.Forms.DateTimePicker  filterTimeEndPicker;
        private System.Windows.Forms.Button          filterTimeEndButton;

        private System.Windows.Forms.GroupBox        filterCountGroupBox;
        private System.Windows.Forms.NumericUpDown   filterCountUpDown;
        private System.Windows.Forms.Button          filterCountButton;

        private System.Windows.Forms.GroupBox        refreshGroupBox;
        private System.Windows.Forms.NumericUpDown   refreshIntervalUpDown;
        private System.Windows.Forms.Button          refreshIntervalButton;
        private System.Windows.Forms.Button          refreshButton;

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container      components = null;

        public EventViewer()
        {
            lockObject = new object();
            DBEvents = new ServerTestFramework.Database.Events();
            columnOrder = new Hashtable();
            columnIndex = 0;

            searchString = "";
            filterServerString = "";
            filterServiceString = "";
            filterTimeStartChecked = false;
            filterTimeEndChecked = false;
            filterCount = 100;
            refreshInterval = 10;

            refreshTimer = null;

            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();
            InitializeEventsList();
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if (disposing)
            {
                if(null != components)
                {
                    components.Dispose();
                }
            }

            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.eventListView = new System.Windows.Forms.ListView();
            this.eventTextBox = new System.Windows.Forms.RichTextBox();

            this.searchGroupBox = new System.Windows.Forms.GroupBox();
            this.searchTextBox = new System.Windows.Forms.TextBox();
            this.searchButton = new System.Windows.Forms.Button();

            this.filterServerGroupBox = new System.Windows.Forms.GroupBox();
            this.filterServerTextBox = new System.Windows.Forms.TextBox();
            this.filterServerButton = new System.Windows.Forms.Button();

            this.filterServiceGroupBox = new System.Windows.Forms.GroupBox();
            this.filterServiceTextBox = new System.Windows.Forms.TextBox();
            this.filterServiceButton = new System.Windows.Forms.Button();

            this.filterTimeStartGroupBox = new System.Windows.Forms.GroupBox();
            this.filterTimeStartPicker = new System.Windows.Forms.DateTimePicker();
            this.filterTimeStartButton = new System.Windows.Forms.Button();
            
            this.filterTimeEndGroupBox = new System.Windows.Forms.GroupBox();
            this.filterTimeEndPicker = new System.Windows.Forms.DateTimePicker();
            this.filterTimeEndButton = new System.Windows.Forms.Button();
            
            this.filterCountGroupBox = new System.Windows.Forms.GroupBox();
            this.filterCountUpDown = new System.Windows.Forms.NumericUpDown();
            this.filterCountButton = new System.Windows.Forms.Button();

            this.refreshGroupBox = new System.Windows.Forms.GroupBox();
            this.refreshIntervalUpDown = new System.Windows.Forms.NumericUpDown();
            this.refreshIntervalButton = new System.Windows.Forms.Button();
            this.refreshButton = new System.Windows.Forms.Button();

            this.SuspendLayout();
            this.searchGroupBox.SuspendLayout();
            this.filterServerGroupBox.SuspendLayout();
            this.filterServiceGroupBox.SuspendLayout();
            this.filterTimeStartGroupBox.SuspendLayout();
            this.filterTimeEndGroupBox.SuspendLayout();
            this.filterCountGroupBox.SuspendLayout();
            this.refreshGroupBox.SuspendLayout();
            this.eventListView.SuspendLayout();
            this.eventTextBox.SuspendLayout();

            // 
            // searchGroupBox
            // 
            this.searchGroupBox.Controls.Add(this.searchTextBox);
            this.searchGroupBox.Controls.Add(this.searchButton);
            this.searchGroupBox.Name = "searchGroupBox";
            this.searchGroupBox.Text = "Search";
            this.searchGroupBox.Location = new Point(8, 8);
            this.searchGroupBox.Size = new Size(228, 46);
            this.searchGroupBox.TabIndex = 0;
            this.searchGroupBox.TabStop = false;

            // 
            // searchTextBox
            // 
            this.searchTextBox.Name = "searchTextBox";
            this.searchTextBox.Text = "";
            this.searchTextBox.Location = new Point(8, 16);
            this.searchTextBox.Size = new Size(144, 20);
            this.searchTextBox.TabIndex = 0;
            this.searchTextBox.TextChanged += new System.EventHandler(this.searchTextBox_TextChanged);

            // 
            // searchButton
            // 
            this.searchButton.Name = "searchButton";
            this.searchButton.Text = "Search";
            this.searchButton.Location = new Point(160, 14);
            this.searchButton.Size = new Size(60, 24);
            this.searchButton.TabIndex = 1;
            this.searchButton.Enabled = false;
            this.searchButton.Click += new System.EventHandler(this.searchButton_Click);

            // 
            // filterServerGroupBox
            // 
            this.filterServerGroupBox.Controls.Add(this.filterServerTextBox);
            this.filterServerGroupBox.Controls.Add(this.filterServerButton);
            this.filterServerGroupBox.Name = "filterServerGroupBox";
            this.filterServerGroupBox.Text = "Server Filter";
            this.filterServerGroupBox.Location = new Point(8, 64);
            this.filterServerGroupBox.Size = new Size(228, 46);
            this.filterServerGroupBox.TabIndex = 1;
            this.filterServerGroupBox.TabStop = false;

            // 
            // filterServerTextBox
            // 
            this.filterServerTextBox.Name = "filterServerTextBox";
            this.filterServerTextBox.Text = "";
            this.filterServerTextBox.Location = new Point(8, 16);
            this.filterServerTextBox.Size = new Size(144, 20);
            this.filterServerTextBox.TabIndex = 0;
            this.filterServerTextBox.TextChanged += new System.EventHandler(this.filterServerTextBox_TextChanged);

            // 
            // filterServerButton
            // 
            this.filterServerButton.Name = "filterServerButton";
            this.filterServerButton.Text = "Set";
            this.filterServerButton.Location = new Point(160, 14);
            this.filterServerButton.Size = new Size(60, 24);
            this.filterServerButton.TabIndex = 1;
            this.filterServerButton.Enabled = false;
            this.filterServerButton.Click += new System.EventHandler(this.filterServerButton_Click);

            // 
            // filterServiceGroupBox
            // 
            this.filterServiceGroupBox.Controls.Add(this.filterServiceTextBox);
            this.filterServiceGroupBox.Controls.Add(this.filterServiceButton);
            this.filterServiceGroupBox.Name = "filterServiceGroupBox";
            this.filterServiceGroupBox.Text = "Service Filter";
            this.filterServiceGroupBox.Location = new Point(8, 118);
            this.filterServiceGroupBox.Size = new Size(228, 46);
            this.filterServiceGroupBox.TabIndex = 2;
            this.filterServiceGroupBox.TabStop = false;

            // 
            // filterServiceTextBox
            // 
            this.filterServiceTextBox.Name = "filterServiceTextBox";
            this.filterServiceTextBox.Text = "";
            this.filterServiceTextBox.Location = new Point(8, 16);
            this.filterServiceTextBox.Size = new Size(144, 20);
            this.filterServiceTextBox.TabIndex = 0;
            this.filterServiceTextBox.TextChanged += new System.EventHandler(this.filterServiceTextBox_TextChanged);

            // 
            // filterServiceButton
            // 
            this.filterServiceButton.Name = "filterServiceButton";
            this.filterServiceButton.Text = "Set";
            this.filterServiceButton.Location = new Point(160, 14);
            this.filterServiceButton.Size = new Size(60, 24);
            this.filterServiceButton.TabIndex = 1;
            this.filterServiceButton.Enabled = false;
            this.filterServiceButton.Click += new System.EventHandler(this.filterServiceButton_Click);

            // 
            // filterTimeStartGroupBox
            // 
            this.filterTimeStartGroupBox.Controls.Add(this.filterTimeStartPicker);
            this.filterTimeStartGroupBox.Controls.Add(this.filterTimeStartButton);
            this.filterTimeStartGroupBox.Name = "filterTimeStartGroupBox";
            this.filterTimeStartGroupBox.Text = "Time Start";
            this.filterTimeStartGroupBox.Location = new Point(8, 172);
            this.filterTimeStartGroupBox.Size = new Size(228, 46);
            this.filterTimeStartGroupBox.TabIndex = 3;
            this.filterTimeStartGroupBox.TabStop = false;

            // 
            // filterTimeStartPicker
            // 
            this.filterTimeStartPicker.Name = "filterTimeStartPicker";
            this.filterTimeStartPicker.Format = DateTimePickerFormat.Custom;
            this.filterTimeStartPicker.CustomFormat = "MM/dd/yyyy HH:mm";
            this.filterTimeStartPicker.Value = MungeDateTime(DateTime.Now);
            this.filterTimeStartPicker.ShowCheckBox = true;
            this.filterTimeStartPicker.Checked = false;
            this.filterTimeStartPicker.ShowUpDown = true;
            this.filterTimeStartPicker.Location = new Point(8, 16);
            this.filterTimeStartPicker.Size = new Size(144, 20);
            this.filterTimeStartPicker.TabIndex = 0;
            this.filterTimeStartPicker.ValueChanged += new System.EventHandler(this.filterTimeStartPicker_ValueChanged);

            // 
            // filterTimeStartButton
            // 
            this.filterTimeStartButton.Name = "filterTimeStartButton";
            this.filterTimeStartButton.Text = "Set";
            this.filterTimeStartButton.Location = new Point(160, 14);
            this.filterTimeStartButton.Size = new Size(60, 24);
            this.filterTimeStartButton.TabIndex = 1;
            this.filterTimeStartButton.Enabled = false;
            this.filterTimeStartButton.Click += new System.EventHandler(this.filterTimeStartButton_Click);

            // 
            // filterTimeEndGroupBox
            // 
            this.filterTimeEndGroupBox.Controls.Add(this.filterTimeEndPicker);
            this.filterTimeEndGroupBox.Controls.Add(this.filterTimeEndButton);
            this.filterTimeEndGroupBox.Name = "filterTimeEndGroupBox";
            this.filterTimeEndGroupBox.Text = "Time End";
            this.filterTimeEndGroupBox.Location = new Point(8, 226);
            this.filterTimeEndGroupBox.Size = new Size(228, 46);
            this.filterTimeEndGroupBox.TabIndex = 4;
            this.filterTimeEndGroupBox.TabStop = false;

            // 
            // filterTimeEndPicker
            // 
            this.filterTimeEndPicker.Name = "filterTimeEndPicker";
            this.filterTimeEndPicker.Format = DateTimePickerFormat.Custom;
            this.filterTimeEndPicker.CustomFormat = "MM/dd/yyyy HH:mm";
            this.filterTimeEndPicker.Value = MungeDateTime(DateTime.Now);
            this.filterTimeEndPicker.ShowCheckBox = true;
            this.filterTimeEndPicker.Checked = false;
            this.filterTimeEndPicker.ShowUpDown = true;
            this.filterTimeEndPicker.Location = new Point(8, 16);
            this.filterTimeEndPicker.Size = new Size(144, 20);
            this.filterTimeEndPicker.TabIndex = 0;
            this.filterTimeEndPicker.ValueChanged += new System.EventHandler(this.filterTimeEndPicker_ValueChanged);

            // 
            // filterTimeEndButton
            // 
            this.filterTimeEndButton.Name = "filterTimeEndButton";
            this.filterTimeEndButton.Text = "Set";
            this.filterTimeEndButton.Location = new Point(160, 14);
            this.filterTimeEndButton.Size = new Size(60, 24);
            this.filterTimeEndButton.TabIndex = 1;
            this.filterTimeEndButton.Enabled = false;
            this.filterTimeEndButton.Click += new System.EventHandler(this.filterTimeEndButton_Click);

            // 
            // filterCountGroupBox
            // 
            this.filterCountGroupBox.Controls.Add(this.filterCountUpDown);
            this.filterCountGroupBox.Controls.Add(this.filterCountButton);
            this.filterCountGroupBox.Name = "groupFilter";
            this.filterCountGroupBox.Text = "Count";
            this.filterCountGroupBox.Location = new Point(8, 280);
            this.filterCountGroupBox.Size = new Size(228, 46);
            this.filterCountGroupBox.TabIndex = 5;
            this.filterCountGroupBox.TabStop = false;

            // 
            // filterCountUpDown
            // 
            this.filterCountUpDown.Name = "filterCountUpDown";
            this.filterCountUpDown.Value = filterCount;
            this.filterCountUpDown.Minimum = 0;
            this.filterCountUpDown.Maximum = 1000;
            this.filterCountUpDown.Increment = 10;
            this.filterCountUpDown.Location = new Point(8, 16);
            this.filterCountUpDown.Size = new Size(76, 20);
            this.filterCountUpDown.TabIndex = 0;
            this.filterCountUpDown.TextChanged += new System.EventHandler(this.filterCountUpDown_ValueChanged);

            // 
            // filterCountButton
            // 
            this.filterCountButton.Name = "filterCountButton";
            this.filterCountButton.Text = "Set";
            this.filterCountButton.Location = new Point(92, 14);
            this.filterCountButton.Size = new Size(60, 24);
            this.filterCountButton.TabIndex = 1;
            this.filterCountButton.Enabled = false;
            this.filterCountButton.Click += new System.EventHandler(this.filterCountButton_Click);

            // 
            // refreshGroupBox
            // 
            this.refreshGroupBox.Controls.Add(this.refreshIntervalUpDown);
            this.refreshGroupBox.Controls.Add(this.refreshIntervalButton);
            this.refreshGroupBox.Controls.Add(this.refreshButton);
            this.refreshGroupBox.Name = "refreshGroupBox";
            this.refreshGroupBox.Text = "Refresh";
            this.refreshGroupBox.Location = new Point(8, 334);
            this.refreshGroupBox.Size = new Size(228, 46);
            this.refreshGroupBox.TabIndex = 6;
            this.refreshGroupBox.TabStop = false;

            // 
            // refreshIntervalUpDown
            // 
            this.refreshIntervalUpDown.Name = "refreshIntervalUpDown";
            this.refreshIntervalUpDown.Value = refreshInterval;
            this.refreshIntervalUpDown.Minimum = 0;
            this.refreshIntervalUpDown.Maximum = 300;
            this.refreshIntervalUpDown.Increment = 5;
            this.refreshIntervalUpDown.Location = new Point(8, 16);
            this.refreshIntervalUpDown.Size = new Size(76, 20);
            this.refreshIntervalUpDown.TabIndex = 0;
            this.refreshIntervalUpDown.TextChanged += new System.EventHandler(this.refreshIntervalUpDown_ValueChanged);

            // 
            // refreshIntervalButton
            // 
            this.refreshIntervalButton.Name = "filterCountButton";
            this.refreshIntervalButton.Text = "Set";
            this.refreshIntervalButton.Location = new Point(92, 14);
            this.refreshIntervalButton.Size = new Size(60, 24);
            this.refreshIntervalButton.TabIndex = 1;
            this.refreshIntervalButton.Enabled = false;
            this.refreshIntervalButton.Click += new System.EventHandler(this.refreshIntervalButton_Click);

            // 
            // refreshButton
            // 
            this.refreshButton.Name = "refreshButton";
            this.refreshButton.Text = "Refresh";
            this.refreshButton.Location = new Point(160, 14);
            this.refreshButton.Size = new Size(60, 24);
            this.refreshButton.TabIndex = 2;
            this.refreshButton.Click += new System.EventHandler(this.refreshButton_Click);

			// 
			// eventListView
			// 
            this.eventListView.Name = "eventListView";
            this.eventListView.Location = new Point(244, 8);
            this.eventListView.Size = new Size(599, 318);
            this.eventListView.TabIndex = 4;
            this.eventListView.FullRowSelect = true;
			this.eventListView.HideSelection = false;
			this.eventListView.MultiSelect = false;
			this.eventListView.View = System.Windows.Forms.View.Details;
			this.eventListView.SelectedIndexChanged += new System.EventHandler(this.eventList_SelectedIndexChanged);

			// 
			// eventTextBox
			// 
            this.eventTextBox.Name = "eventTextBox";
            this.eventTextBox.Text = "";
			this.eventTextBox.Location = new Point(244, 332);
			this.eventTextBox.Size = new Size(599, 159);
			this.eventTextBox.TabIndex = 5;

			// 
			// EventViewer
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.Name = "EventViewer";
            this.Text = "Event Viewer";
            this.ClientSize = new System.Drawing.Size(851, 499);
            this.Controls.Add(this.searchGroupBox);
            this.Controls.Add(this.filterServiceGroupBox);
            this.Controls.Add(this.filterServerGroupBox);
            this.Controls.Add(this.filterTimeStartGroupBox);
            this.Controls.Add(this.filterTimeEndGroupBox);
            this.Controls.Add(this.filterCountGroupBox);
            this.Controls.Add(this.refreshGroupBox);
            this.Controls.Add(this.eventListView);
            this.Controls.Add(this.eventTextBox);
			this.searchGroupBox.ResumeLayout(false);
			this.filterServiceGroupBox.ResumeLayout(false);
            this.filterServerGroupBox.ResumeLayout(false);
            this.filterTimeStartGroupBox.ResumeLayout(false);
            this.filterTimeEndGroupBox.ResumeLayout(false);
            this.filterCountGroupBox.ResumeLayout(false);
            this.refreshGroupBox.ResumeLayout(false);
            this.eventListView.ResumeLayout(false);
			this.eventTextBox.ResumeLayout(false);
			this.ResumeLayout(false);
		}
		#endregion

        private void InitializeEventsList()
        {
            eventListView.Columns.Add("ID", 50, HorizontalAlignment.Right);
            columnOrder.Add(0, -1);
            eventListView.Columns.Add("Type", 25, HorizontalAlignment.Center);
            columnOrder.Add(1, -1);
            eventListView.Columns.Add("Server", 100, HorizontalAlignment.Left);
            columnOrder.Add(2, -1);
            eventListView.Columns.Add("Service", 100, HorizontalAlignment.Left);
            columnOrder.Add(3, -1);
            eventListView.Columns.Add("Time", 125, HorizontalAlignment.Left);
            columnOrder.Add(4, -1);
            eventListView.Columns.Add("Description", 175, HorizontalAlignment.Left);
            columnOrder.Add(5, -1);

            eventListView.ColumnClick += new ColumnClickEventHandler(EventListColumnClick);
        }

        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            if (null == refreshTimer) 
            {
                CreateTimer(refreshInterval);
            }
        }

        protected override void OnClosed(EventArgs e)
        {
            if (null != refreshTimer) 
            {
                refreshTimer.Dispose();
                refreshTimer = null;
            }

            base.OnClosed(e);
        }

        private void CreateTimer(int seconds)
        {
            if (0 < seconds) 
            {
                if (null != refreshTimer) 
                {
                    refreshTimer.Dispose();
                }

                refreshTimer = new System.Threading.Timer(new TimerCallback(UpdateRefresh), this, 0, 1000 * seconds);
            }
            else 
            {
                refreshTimer.Dispose();
                refreshTimer = null;
            }
        }

        private void UpdateRefresh(object ev) 
        {
            RefreshData();
        }

        private void RefreshData()
        {
            DateTime   dtStart = DateTime.MinValue;
            DateTime   dtEnd = DateTime.MaxValue;
            ArrayList  recordList = null;

            lock(lockObject) 
            {
                if ((false == filterTimeStartButton.Enabled) && (true == filterTimeStartPicker.Checked) ) 
                {
                    dtStart = MungeDateTime(filterTimeStartPicker.Value);
                }

                if ((false == filterTimeEndButton.Enabled) && (true == filterTimeEndPicker.Checked) ) 
                {
                    dtEnd = MungeDateTime(filterTimeEndPicker.Value);
                }

                // get the lastest events
                recordList = DBEvents.GetLatestEventsMatching(filterCount, filterServiceString, filterServerString, dtStart, dtEnd);
                DBEvents.Close();
            }

            // look for expired events in the eventListView
            ListView.ListViewItemCollection  lviList = eventListView.Items;
            foreach (ListViewItem lvi in lviList) 
            {
                if (false == recordList.Contains((EventRecord)lvi.Tag)) 
                {
                    // this event in not in the lastest events so remove it
                    eventListView.Items.Remove(lvi);
                }
                else 
                {
                    // this event is current so do not add it
                    recordList.Remove(lvi.Tag);
                }
            }

            // add new events
            foreach (EventRecord record in recordList)
            {
                ListViewItem lvi = new ListViewItem(record.Index.ToString());
                lvi.Tag = record;
                lvi.SubItems.Add(record.Type.ToString());
                lvi.SubItems.Add(record.Server);
                lvi.SubItems.Add(record.Service);
                lvi.SubItems.Add(record.Time.ToString());
                lvi.SubItems.Add(record.Description);

                // highlight if matches the search query
                SearchHighlight(lvi);

                eventListView.Items.Add(lvi);
            }

            // sort the events
            ColumnSort(columnIndex);
        }

        private void UpdateSelection()
        {
            if (0 < eventListView.SelectedItems.Count)
            {
                ListViewItem  item = eventListView.SelectedItems[0];
                EventRecord   record = (EventRecord)item.Tag;
                eventTextBox.Text = item.SubItems[5].Text;
            }
            else 
            {
                eventTextBox.Text = "";
            }
        }

        private void SearchHighlight(ListViewItem lvi) 
        {
            lvi.BackColor = Color.White;

            if (0 < searchString.Length)
            {
                if (-1 < lvi.SubItems[5].Text.ToUpper().IndexOf(searchString))
                {
                    lvi.BackColor = Color.LightGreen;
                }
            }
        }

        private void SearchHighlight() 
        {
            foreach (ListViewItem lvi in eventListView.Items)
            {
                SearchHighlight(lvi);
            }
        }

        private void ColumnSort(int columnIndex) 
        {
            // Set the ListViewItemSorter property to a new ListViewItemComparer object.
            eventListView.ListViewItemSorter = new ListViewItemComparer(columnIndex, (int)columnOrder[columnIndex]);
            // Call the sort method to manually sort the column based on the ListViewItemComparer implementation.
            eventListView.Sort();
        }

        private void searchTextBox_TextChanged(object sender, EventArgs e)
        {
            if (searchTextBox.Text.ToUpper() != searchString) 
            {
                searchButton.Enabled = true;
            }
            else 
            {
                searchButton.Enabled = false;
            }
        }

        private void searchButton_Click(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                searchString = searchTextBox.Text.ToUpper();
                searchButton.Enabled = false;
            }

            SearchHighlight();
        }

        private void filterServerTextBox_TextChanged(object sender, EventArgs e)
        {
            if (filterServerTextBox.Text.ToUpper() != filterServerString) 
            {
                filterServerButton.Enabled = true;
            }
            else 
            {
                filterServerButton.Enabled = false;
            }
        }

        private void filterServerButton_Click(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                filterServerString = filterServerTextBox.Text.ToUpper();
                filterServerButton.Enabled = false;
            }
        }

        private void filterServiceTextBox_TextChanged(object sender, EventArgs e)
        {
            if (filterServiceTextBox.Text.ToUpper() != filterServiceString) 
            {
                filterServiceButton.Enabled = true;
            }
            else 
            {
                filterServiceButton.Enabled = false;
            }
        }

        private void filterServiceButton_Click(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                filterServiceString = filterServiceTextBox.Text.ToUpper();
                filterServiceButton.Enabled = false;
            }
        }

        private DateTime MungeDateTime(DateTime dt) 
        {
            dt = dt.AddSeconds(-dt.Second);

            return dt;
        }

        private void filterTimeStartPicker_ValueChanged(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                if (filterTimeStartPicker.Checked != filterTimeStartChecked) 
                {
                    filterTimeStartButton.Enabled = true;
                }
                else 
                {
                    filterTimeStartButton.Enabled = false;
                }
            }
        }

        private void filterTimeStartButton_Click(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                filterTimeStartChecked = filterTimeStartPicker.Checked;
                filterTimeStartButton.Enabled = false;
            }
        }

        private void filterTimeEndPicker_ValueChanged(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                if (filterTimeEndPicker.Checked != filterTimeEndChecked) 
                {
                    filterTimeEndButton.Enabled = true;
                }
                else 
                {
                    filterTimeEndButton.Enabled = false;
                }
            }
        }

        private void filterTimeEndButton_Click(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                filterTimeEndChecked = filterTimeEndPicker.Checked;
                filterTimeEndButton.Enabled = false;
            }
        }

        private void filterCountUpDown_ValueChanged(object sender, EventArgs e)
        {
            if (filterCountUpDown.Value != filterCount) 
            {
                filterCountButton.Enabled = true;
            }
            else 
            {
                filterCountButton.Enabled = false;
            }
        }

        private void filterCountButton_Click(object sender, EventArgs e)
        {
            lock(lockObject) 
            {
                filterCount = (uint)filterCountUpDown.Value;
                filterCountButton.Enabled = false;
            }
        }

        private void refreshIntervalUpDown_ValueChanged(object sender, EventArgs e)
        {
            if (refreshIntervalUpDown.Value != refreshInterval) 
            {
                refreshIntervalButton.Enabled = true;
            }
            else 
            {
                refreshIntervalButton.Enabled = false;
            }
        }

        private void refreshIntervalButton_Click(object sender, EventArgs e)
        {
            refreshInterval = (int)refreshIntervalUpDown.Value;
            refreshIntervalButton.Enabled = false;
            CreateTimer(refreshInterval);
        }

        private void refreshButton_Click(object sender, EventArgs e)
        {
            RefreshData();
        }

        private void eventList_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateSelection();
        }

        // EventListColumnClick event handler.
        private void EventListColumnClick(object o, ColumnClickEventArgs e)
        {
            columnIndex = e.Column;
            columnOrder[e.Column] = -((int)columnOrder[e.Column]);

            ColumnSort(e.Column);
        }

        // Implements the manual sorting of items by columns.
        class ListViewItemComparer : IComparer 
        {
            private int  _columnIndex;
            private int  _columnOrder;

            public ListViewItemComparer() 
            {
                _columnIndex = 0;
                _columnOrder = 0;
            }
            public ListViewItemComparer(int columnIndex, int columnOrder) 
            {
                _columnIndex = columnIndex;
                _columnOrder = columnOrder;
            }
            public int Compare(object x, object y) 
            {
                int retVal = 0;

                if (0 == _columnIndex) 
                {
                    int xVal = Int32.Parse(((ListViewItem)x).SubItems[_columnIndex].Text);
                    int yVal = Int32.Parse(((ListViewItem)y).SubItems[_columnIndex].Text);

                    retVal = xVal.CompareTo(yVal);
                }
                else 
                {
                    retVal = String.Compare(((ListViewItem)x).SubItems[_columnIndex].Text, ((ListViewItem)y).SubItems[_columnIndex].Text);
                }

                if (-1 == _columnOrder) retVal = -retVal;

                return retVal;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\LogView.cs ===
using System;
using System.IO;
using System.Threading;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Drawing;
using System.Windows.Forms;
using System.Diagnostics;

namespace STFRunner
{
    /// <summary>
    /// Interface for LogView objects, to allow easy interchange of custom LogView control and 
    /// old-school RichTextBox control. 
    /// </summary>
    public interface ILogView
    {
        void Append(Color color, string text);

        event EventHandler Disposed;
        
        Font Font 
        { 
            get; 
            set; 
        }

        Color BackColor 
        { 
            get; 
            set; 
        }
    }


    /// <summary>
    /// Wrapper for RichTextBox control to make it conform to our ILogView interface.  The RichTextBox
    /// base class implements most of our interface for us (actually, I think Control class does). All
    /// we have to do is implement the Append method.
    /// </summary>
    public class LogViewRichText : System.Windows.Forms.RichTextBox, ILogView
    {
        // One instance of the editor process
        private string EditorPath;
        private string EditorArgs;
        private string SourceMappingFrom;
        private string SourceMappingTo;
        private Process EditorProc = null;

        private object lockAppend = new object();

        public LogViewRichText()
        {
            this.MouseDown += new MouseEventHandler(LogViewRichText_MouseDown);
        }

        public void Initialize(string editorPath, string editorArgs, string sourceMappingFrom, string sourceMappingTo)
        {
            this.EditorPath = editorPath;
            this.EditorArgs = editorArgs;
            this.SourceMappingFrom = sourceMappingFrom;
            this.SourceMappingTo = sourceMappingTo;
            this.EditorProc = new Process();
        }

        private delegate void AppendTextDelegate(Color color, string text);

        private void AppendText(Color color, string text)
        {
            lock (lockAppend)
            {
                SuspendLayout();
                SelectionColor = color;
                AppendText(text + "\n");
                ScrollToCaret();
                ResumeLayout();
            }
        }

        public void Append(Color color, string text)
        {
            if(IsHandleCreated)
            {
                Invoke(new AppendTextDelegate(this.AppendText), new object[]{color, text});
            }
            else
            {
                AppendText(color, text);
            }
        }

        private string GetLineFromPosition(int x, int y)
        {
            int idx = this.GetCharIndexFromPosition(new System.Drawing.Point(x, y));
            int line = this.GetLineFromCharIndex(idx);
            return this.Lines[line];
        }

        private bool ParseFilenameFromLine(string line, out string filename, out string linenum)
        {
            // Typical exception line looks like:
            //    at XSGTest.XSGTestBase.Execute() in c:\sd\main\private\test\StfTests\XSGTest\XSGTestBase.cs:line 115
            // Regular expressions:
            //    To match the exception line above: "at (.+) in (.+):line ([0-9]+)"
            // First quickly check if we have a match. If so, parse out info.

            filename = null;
            linenum = null;

            string regexpr = "at (.+) in (.+):line ([0-9]+)";
            if (!Regex.IsMatch(line, regexpr))
            {
                return false;
            }
            string[] chunks = Regex.Split(line, regexpr);
            // 0: leading spaces or ""
            // 1: full function name
            // 2: filename
            // 3: line number
            // 4: ""

            // Something went wrong
            if (chunks.Length != 5)
            {
                return false;
            }
            filename = chunks[2];
            linenum = chunks[3];

            // Perform a prefix search & replace for the source mapping conversions
            if (this.SourceMappingFrom != null && this.SourceMappingTo != null)
            {
                // Only replace the left-most characters, so the FROM must begin at index 0
                if (filename.StartsWith(this.SourceMappingFrom))
                {
                    if (this.SourceMappingFrom == "")
                    {
                        filename = this.SourceMappingTo + filename;
                    }
                    else
                    {
                        filename = filename.Replace(this.SourceMappingFrom, this.SourceMappingTo);
                    }
                }
            }

            return true;
        }

        private void LogViewRichText_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            // Handle double clicks
            if (e.Clicks == 2)
            {
                // See if we can parse a filename & line number out of the line the
                // user clicked on. If so, launch it in Visual Studio.
                // TODO: is the filepath local or on the build machine?

                string line = GetLineFromPosition(e.X, e.Y);
                string filename = null;
                string linenum = null;
                if (ParseFilenameFromLine(line, out filename, out linenum))
                {
                    string actualArgs = "";
                    if (EditorPath == null || EditorPath == "")
                    {
                        //Global.RO.Warn("No editor configured, see <editor> tag in XML config file");
                        return;
                    }
                    if (!File.Exists(EditorPath))
                    {
                        //Global.RO.Warn("Path to configured editor doesn't exist ({0})", Global.EditorPath);
                        return;
                    }
                    if (EditorArgs != null && 
                        EditorArgs != "" && 
                        EditorArgs.IndexOf("{0}") >= 0 &&
                        EditorArgs.IndexOf("{1}") >= 0)
                    {
                        actualArgs = String.Format(EditorArgs, filename, linenum);
                    }
                    EditorProc.StartInfo.FileName = EditorPath;
                    EditorProc.StartInfo.Arguments = actualArgs;
                    EditorProc.Start();
                }
            }
        }

    }
    
    /// <summary>
    /// High performance thread-safe log view. This control uses an internal circular buffer to avoid
    /// having to trim lines of input during append. It attempts to function in some respect like
    /// the DOS console. Selection will pause any threads attempting to append to the log view. If you
    /// select or scroll the log view will not follow the output for 5 seconds. Each time you touch the 
    /// scrollbar this timer is reset allowing the user to view past input without being flooded by the current
    /// input.
    /// </summary>
    public class LogView : Control, ILogView
    {
        // Internal selection state representation
        class Selection
        {
            // Marks when the first portion of bounds and line/col information
            // have been captured
            public bool Valid;

            // These buffer positions are actual positions in the
            // circular buffer
            public int BeginLine;
            public int BeginIndex;
            public int EndLine;
            public int EndIndex;

            // Sorted selection indexes
            public int TopLine;
            public int TopIndex;
            public int BottomLine;
            public int BottomIndex;
			
            public Selection()
            {
                Clear();
            }

            public void Clear()
            {
                Valid = false;
                BeginLine = -1;
                BeginIndex= -1;
                EndLine = -1;
                EndIndex = -1;
                TopLine = -1;
                TopIndex = -1;
                BottomLine = -1;
                BottomIndex = -1;
            }

            // Given the circular buffer array copy out the data
            // corresponding to the selection criteria
            public string GetData(string [] lines)
            {
                StringBuilder buffer = new StringBuilder(256);
                for(int i = TopLine; i > 0 && i <= BottomLine; ++i)
                { 
                    string line = lines[i];
                    int startIndex = 0;
                    int length = line.Length;

                    if(i == TopLine && i == BottomLine)
                    {
                        startIndex = TopIndex;
                        length = BottomIndex - TopIndex;
                    }
                    else if(i == TopLine)
                    {
                        startIndex = TopIndex;
                        length = line.Length - startIndex;
                    }
                    else if(i == BottomLine)
                    {
                        length = BottomIndex;
                    }

                    if((startIndex + length) <= line.Length)
                    {
                        buffer.Append(line.Substring(startIndex, length));
                    }
                }

                return buffer.ToString();
            }

            public override string ToString()
            {
                return	"BeginLine: " + BeginLine +
                    ", BeginIndex: " + BeginIndex +
                    ", EndLine: " + EndLine +
                    ", EndIndex: " + EndIndex +
                    ", TopLine: " + TopLine +
                    ", TopIndex: " + TopIndex +
                    ", BottomLine: " + BottomLine +
                    ", BottomIndex: " + BottomIndex;
            }
        }

	
        // Drawing prims
        private Graphics _BG;
        private Bitmap _Backbuffer;
        private Brush  _BgBrush;
        private Brush  _TextBrush;
        private Brush  _SelectBrush;
        private Pen	   _SelectPen;
        private float  _YOffset;
		
        // Data buffers
        private string[]_Lines;
        private float[] _Heights;
        private Color[] _Colors;
        private uint   _MaxLines;
        private uint   _NumLines;
        private uint   _Top;
        private uint   _WritePos;
		
        // Control state
        private VScrollBar _VScroll;
        private uint _ViewLine;
        private int _LastRefresh; 
        private int _LastScroll;
        private Selection _Selection;
        private bool _SelectionAdd;
        private bool _FollowTail;
		
        /// <summary>
        /// Create a new log view with 1000 lines of buffer.
        /// </summary>
        public LogView() : this(1000)
        {
        }

        /// <summary>
        /// Create a new log view with a specified number of buffer lines.
        /// </summary>
        /// <param name="nBufferLines">Buffer lines for circular buffer queue</param>
        public LogView(uint nBufferLines) : base()
        {
            // Paint background and foreground in one pass from WM_PAINT
            SetStyle(ControlStyles.AllPaintingInWmPaint
                |ControlStyles.UserPaint
                |ControlStyles.ResizeRedraw
                |ControlStyles.Selectable
                |ControlStyles.UserMouse, true);

            // Set these true to enable Focus()
            Visible = true;
            Enabled = true;

            UpdateStyles();
			
            SetupDrawing(); 
            CreateBuffers(1000);

            _FollowTail = true;

            // Add a vertical scrollbar
            _VScroll = new VScrollBar();
            _VScroll.Dock = DockStyle.Right;
            _VScroll.Minimum = 0;
            _VScroll.Maximum = 0;
            _VScroll.LargeChange = 10;
            _VScroll.Scroll += new ScrollEventHandler(this.ScrollEvent);
            Controls.Add(_VScroll);

            _Selection.Clear();
        }

        public delegate void InvokeAppendCode();
        public void Append(Color color, string strData)
        {
            bool changeMax = false;
            lock (_Selection)
            {
                // Wrap write we have to move the top 
                if(_NumLines == _MaxLines)
                {
                    _Top++;
                    if(_Top == _MaxLines)
                    {
                        _Top = 0;
                    }
                }
                else
                {
                    ++_NumLines;
                    changeMax = true;
                }
            }

            if (changeMax)
            {
                if (_VScroll.InvokeRequired) _VScroll.Invoke(new InvokeAppendCode(delegate {_VScroll.Maximum = (int)_NumLines;}));
                else _VScroll.Maximum = (int)_NumLines;
            }

            lock (_Selection)
            {
                _Lines[_WritePos] = strData; // Store data
                _Heights[_WritePos] = 0;
                _Colors[_WritePos] = color;
                _WritePos++;

                // Wrap the write position
                if(_WritePos == _MaxLines)
                {
                    _WritePos = 0;
                }
    		
    			
                // Cause redraw
                Invalidate();
            }
        }

        public void Clear()
        {
            lock (_Selection)
            {
                for(uint i = 0; i < _NumLines; ++i)
                {
                    _Lines[i] = null;
                    _Heights[i] = 0;
                }

                _NumLines = 0;
                _WritePos = 0;
                _Top = 0;
                _ViewLine = 0;

                // Cause redraw
                Invalidate();
            }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize (e);

            // Make sure that this is not a minimize resize, we don't care about re-creating
            // the backbuffer in that case
            if(ClientRectangle.Width != 0 && ClientRectangle.Height != 0)
            {
                CreateBackbuffer();	
            }
        }

        protected override void OnPaintBackground(PaintEventArgs pevent)
        {
            // All painting should be done in OnPaint
        }


        protected override void OnPaint(PaintEventArgs e)
        {
            // Limit the refresh interval of expensive paints
            if(Math.Abs(Environment.TickCount - _LastRefresh) > 250)
            {
                RefreshBackbuffer();
            }

            FlushBackbuffer(e.Graphics);
        }
		
        private void RefreshBackbuffer()
        {
            // Update refresh time
            _LastRefresh = Environment.TickCount;

            _BG.FillRectangle(new SolidBrush(this.BackColor), ClientRectangle);
			
            if(this.Focused)
            {
                _BG.DrawRectangle(_SelectPen, 0, 0, ClientRectangle.Width-1, ClientRectangle.Height-1);
            }
			
            SizeF size = new SizeF(ClientRectangle.Width, 0);
            PointF p = new PointF(0, _YOffset);
            uint i = _Top + _ViewLine;
            uint count = 0;
            uint maxcount = _NumLines - _ViewLine;
            bool selectMode = false;

            if(i >= _MaxLines)
            {
                i -= _MaxLines;
            }

            // Selection is off the displayed text
            if(_Selection.TopLine > -1 && _Selection.TopLine < i && _Selection.BottomLine >= i)
            {
                selectMode = true;
            }
			
            // Run a cursor down the buffer, exit paint routine when the cursor 
            // leaves the valid client rectangle.
            while(p.Y < ClientRectangle.Height)
            {
                string line = _Lines[i];
				
                if(line == null)
                {
                    break;
                }

                // Build bounding rects
                Region selRegion = new Region();
                selRegion.MakeEmpty();

                // This is done here to avoid contention with the Append() method
                if(_Heights[i] == 0)
                {
                    _Heights[i] = _BG.MeasureString(line, Font, ClientRectangle.Width).Height;
                }

                size.Height = _Heights[i];
                RectangleF boundingRect = new RectangleF(p, size);

                // Handle case where single line is selected
                if(i == _Selection.TopLine && i == _Selection.BottomLine)
                {
                    selRegion.Union(GetSelectionRegion(line, _Selection.TopIndex, _Selection.BottomIndex, boundingRect, _BG));
                    selectMode = false;
                }
                else if(i == _Selection.TopLine)
                {
                    selRegion.Union(GetSelectionRegion(line, _Selection.TopIndex, line.Length, boundingRect, _BG));
                    selectMode = true;
                }
                else if(i == _Selection.BottomLine)
                {
                    selRegion.Union(GetSelectionRegion(line, 0, _Selection.BottomIndex, boundingRect, _BG));
                    selectMode = false;
                }
                else if(selectMode == true)
                {
                    selRegion.Union(GetSelectionRegion(line, 0, line.Length, boundingRect, _BG));
                }
				
                if(!selRegion.IsEmpty(_BG))
                {
                    //_BG.DrawRectangle(_SelectPen, selRect.X, selRect.Y, selRect.Width, selRect.Height);
                    _BG.FillRegion(_SelectBrush, selRegion);
                }

                _BG.DrawString(line, Font, new SolidBrush(_Colors[i]), boundingRect);
                p += new Size(0, (int)size.Height);
				
                i++;
                count++;

                if(i == _MaxLines)
                {
                    i = 0;
                }

                // View line is positioned at the end of the virtual buffer and
                // we reached the end before we ran out of lines to render
                if(count == maxcount)
                {
                    break;
                }
            }

            // Calculate the aproximate number of lines in a page, move viewline
            // to that much before the end of the virtual buffer
            if(_FollowTail)
            {
                int viewLine = (int)(_NumLines - _VScroll.LargeChange);
                if(viewLine < 0)
                {
                    viewLine = 0;
                }

                try
                {
                    int line=(int)_NumLines - _VScroll.LargeChange;
                    if (line<0) line=0;
                    if (line>_VScroll.Maximum) line=_VScroll.Maximum;

                    _VScroll.Value = line;
                }
                catch
                {
                    System.Diagnostics.Debugger.Log(0,"logview error","\"_VScroll.Value = line\" threw.");
                }
                _ViewLine = (uint)viewLine;
            }
            else
            {
                // Scroll timeout has expired, convert back to follow mode
                if(Math.Abs(Environment.TickCount - _LastScroll) > 5000)
                {
                    _FollowTail = true;
                }
            }
        }

        private void FlushBackbuffer(Graphics g)
        {
            g.DrawImage(_Backbuffer, ClientRectangle);
        }

        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown (e);

            if(e.KeyCode == Keys.ShiftKey)
            {
                _SelectionAdd = true;
            }
        }
        protected override void OnKeyUp(KeyEventArgs e)
        {
            base.OnKeyUp(e);

            if(_SelectionAdd && (e.KeyCode == Keys.ShiftKey))
            {
                _SelectionAdd = false;
            }

            if(e.KeyCode == Keys.Return)
            {
                Clipboard.SetDataObject(_Selection.GetData(_Lines));
                _Selection.Clear();
                RefreshBackbuffer();
                Invalidate();
                Parent.Focus();
            }
            else if(e.KeyCode == Keys.Escape)
            {
                _Selection.Clear();
                RefreshBackbuffer();
                Invalidate();
                Parent.Focus();
            }
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            base.OnMouseDown (e);
            if(e.Button == MouseButtons.Left)
            {
                // Take focus
                base.Focus();

                if(_Selection.Valid && _SelectionAdd)
                {
                    // Add to existing selection
                    UpdateSelection(new Point(e.X, e.Y), false);
                }
                else
                {
                    // Start a new selection
                    _Selection.Clear();
                    UpdateSelection(new Point(e.X, e.Y), true);
                }
				
                RefreshBackbuffer();
                Invalidate();
            }
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            base.OnMouseUp (e);
            if(e.Button == MouseButtons.Left)
            {
                UpdateSelection(new Point(e.X, e.Y), false);
                RefreshBackbuffer();
                Invalidate();
            }
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            base.OnMouseMove (e);
            if(e.Button == MouseButtons.Left)
            {
                if(_Selection.Valid)
                {
                    UpdateSelection(new Point(e.X, e.Y), false);
                }

                RefreshBackbuffer();
                Invalidate();
            }
        }

        // Lock the selection monitor
        protected override void OnGotFocus(EventArgs e)
        {
            base.OnGotFocus(e);

            Monitor.Enter(_Selection);
        }

        // Unlock the selection monitor
        protected override void OnLostFocus(EventArgs e)
        {
            _Selection.Clear();
            RefreshBackbuffer();
            Invalidate();
            Monitor.Exit(_Selection);

            base.OnLostFocus(e);
        }

        private void CreateBackbuffer()
        {
            if(_BG != null)
                _BG.Dispose();
            if(_Backbuffer != null)
                _Backbuffer.Dispose();

            _Backbuffer = new Bitmap(ClientRectangle.Width, ClientRectangle.Height);
            _BG = Graphics.FromImage(_Backbuffer);

            // Re-measure valid strings since the size of the buffer has changed
            for(int i = 0; i < _NumLines; ++i)
            {
                _Heights[i] = 0;
            }
        }

        private void CreateBuffers(uint nMaxLines)
        {
            _WritePos = 0;
            _Top      = 0;
            _MaxLines = nMaxLines;
            _Lines    = new string[_MaxLines];
            _Heights  = new float[_MaxLines];
            _Colors = new Color[_MaxLines];
        }

        private void SetupDrawing()
        {
            // Create the colors and drawing prims
            _SelectPen = new Pen(Color.Red, 1);
            _BgBrush = new SolidBrush(Color.Black);
            _TextBrush = new SolidBrush(Color.White);
            _SelectBrush = new SolidBrush(Color.Blue);
            _Selection = new Selection();
            _YOffset = 2.0f;
        }

        private void UpdateSelection(Point p, bool begin)
        {
            // Test the point against the client rect, if it misses
            // we should just stop right away
            if(!ClientRectangle.Contains(p))
            {
                return;
            }

            // Conver the behavior for a period of time to allow user
            // to view previous log results
            SuspendFollow();
			
            // Test each line of text in the view
            SizeF size = new SizeF(ClientRectangle.Width, 0);
            PointF search = new PointF(0, _YOffset);
            int i = (int)(_Top + _ViewLine);
            int count = 0;

            if(i >= _MaxLines)
            {
                i -= (int)(_MaxLines);
            }

            while(search.Y < ClientRectangle.Height)
            {
                string line = _Lines[i];

                // Ran out of lines to test
                if(line == null)
                {
                    // Exit the search
                    break;
                }

                if(_Heights[i] == 0)
                {
                    _Heights[i] = _BG.MeasureString(line, Font, ClientRectangle.Width).Height;
                }

                size.Height = _Heights[i]; 
				
                // Matched a line rect, now we will pull out the actual character selection regions
                if(p.Y >= search.Y && p.Y <= search.Y + size.Height)
                {
                    Region[] regions = BuildRegions(line, new RectangleF(search, size), _BG);

                    int charIndex = -1;

                    // Find the character index under the cursor
                    for(int j = 0; j < regions.Length; ++j)
                    {
                        Region region = regions[j];
						
                        RectangleF rect = region.GetBounds(_BG);
                        // Diagnostic for debugging...
                        //_BG.DrawRectangle(new Pen(Color.Yellow), rect.X, rect.Y, rect.Width, rect.Height);
                        if(rect.Contains(p))
                        {
                            charIndex = j;
                            break;
                        }
                    }

                    // Update the selection bounds
                    if(charIndex > -1)
                    {
                        if(begin)
                        {
                            _Selection.Valid = true;
                            _Selection.BeginLine = i;
                            _Selection.BeginIndex = charIndex;
                        }
                        else
                        {
                            _Selection.EndLine = i;
                            _Selection.EndIndex = charIndex+1;
                        }

                        // Sort the selection indexes
                        if(_Selection.BeginLine == _Selection.EndLine)
                        {
                            _Selection.TopLine = _Selection.BeginLine;
                            _Selection.BottomLine = _Selection.EndLine;

                            if(_Selection.BeginIndex < _Selection.EndIndex)
                            {
                                _Selection.TopIndex = _Selection.BeginIndex;
                                _Selection.BottomIndex = _Selection.EndIndex;
                            }
                            else
                            {
                                _Selection.TopIndex = _Selection.EndIndex;
                                _Selection.BottomIndex = _Selection.BeginIndex;
                            }
                        }
                        else if(_Selection.BeginLine < _Selection.EndLine)
                        {
                            _Selection.TopLine = _Selection.BeginLine;
                            _Selection.TopIndex = _Selection.BeginIndex;
                            _Selection.BottomLine = _Selection.EndLine;
                            _Selection.BottomIndex = _Selection.EndIndex;
                        }
                        else
                        {
                            _Selection.TopLine = _Selection.EndLine;
                            _Selection.TopIndex = _Selection.EndIndex;
                            _Selection.BottomLine = _Selection.BeginLine;
                            _Selection.BottomIndex = _Selection.BeginIndex;
                        }

                        // Diagnostic for debugging...
                        //Debug.WriteLine("Selection: " + _Selection.ToString());
                    }
					
                    // Exit the line search
                    break;
                }

                // Move the search cursor to the next line
                search += new Size(0, (int)size.Height);
                i++;
                count++;

                // Wrap search
                if(i == _MaxLines)
                {
                    i = 0;
                }
            }
        }

        // Build an array of regions, one for each character in the string 'line'
        private Region[] BuildRegions(string line, RectangleF rect, Graphics g)
        {
            Region[] regions = new Region[line.Length];
            uint nregions = 0;

            // CharacterRange arrays can only be requested in blocks of 32 because
            // of a limitation in GDI+
            for(int i = 0; i < line.Length; i += 32)
            {
                int rangelen = 32;

                if(i + rangelen > line.Length)
                {
                    rangelen = line.Length - i;
                }

                // Setup the line character ranges
                // Create one range vaule for each character
                CharacterRange[] ranges = new CharacterRange[rangelen];
                for(int j = 0; j < rangelen; ++j)
                {
                    ranges[j] = new CharacterRange(i+j, 1);
                }
					
						
                // Setup string format
                StringFormat stringFormat = new StringFormat();
                stringFormat.FormatFlags = StringFormatFlags.FitBlackBox;
                stringFormat.SetMeasurableCharacterRanges(ranges);

                // Get the measured regions in the string and append them to
                // the region buffer.
                Region[] tmpRegions = g.MeasureCharacterRanges(line, Font, rect, stringFormat);
                foreach(Region region in tmpRegions)
                {
                    regions[nregions++] = region;
                }
            }
		
            return regions;
        }

        // Get a region representing the local selection on the line. This will be used to union the
        // entire selection.
        private Region GetSelectionRegion(string line, int startIndex, int endIndex, RectangleF rect, Graphics g)
        {
            CharacterRange[] ranges = new CharacterRange[1];
            ranges[0] = new CharacterRange(startIndex, endIndex - startIndex);
			
            // Set string format.
            StringFormat stringFormat = new StringFormat();
            stringFormat.FormatFlags = StringFormatFlags.FitBlackBox;
            stringFormat.SetMeasurableCharacterRanges(ranges);

            // Get the measured regions in the string
            Region[] regions = g.MeasureCharacterRanges(line, Font, rect, stringFormat);
            return regions[0];
        }

        private void ScrollEvent(Object sender, ScrollEventArgs e)
        {
            SuspendFollow();

            _LastRefresh = 0; // disable the graphics flush throttle
            _ViewLine = (uint)_VScroll.Value;
            Invalidate();
        }

        // Convert the behavior for a period of time to allow user
        // to view previous log results
        private void SuspendFollow()
        {
            _FollowTail = false;
            _LastScroll = Environment.TickCount;
        }		
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\STFProgressBar.cs ===
using System;
using System.Drawing;
using System.Windows.Forms;

namespace STFRunner
{
	/// <summary>
	/// Custom progress indicator that shows text and provides better indication
	/// of how far along tasks actually are.
	/// </summary>
	public class STFProgressBar : Control
	{
		private Bitmap _Backbuffer;
		private Graphics _BG;
		private string _Description;
		private float _Value;
		private float _Step;
		private float _Maximum;
		private float _Offset;

		/// <summary>
		/// Set a description to float on top of the progress indication.
		/// </summary>
		public string Description
		{
			set {
				if(value == null)
				{
					_Description = "";
				}
				else
				{
					_Description = value;
				}
				Invalidate();
			}
			get {
				return _Description;
			}
		}

		/// <summary>
		/// Set the current value of progress.
		/// </summary>
		public int Value
		{
			set {
				if(value > _Maximum)
				{
					throw new ArgumentException("Value was greater than maximum");
				}
				_Value = (float)value;
				Invalidate();
			}
			get {
				return (int)_Value;
			}
		}

		/// <summary>
		/// Set the ammount of change that occurs when PerformStep() is called.
		/// </summary>
		public int Step
		{
			set {
				_Step = (float)value;
				Invalidate();
			}
			get {
				return (int)_Step;
			}
		}

		/// <summary>
		/// Set the maximum value of the progress indicator.
		/// </summary>
		public int Maximum
		{
			set {
				_Maximum = (float)value;
				Invalidate();
			}
			get {
				return (int)_Maximum;
			}
		}
			
		/// <summary>
		/// Create a new progress bar
		/// </summary>
		public STFProgressBar() 
		{
			// Paint background and foreground in one pass from WM_PAINT
			SetStyle(ControlStyles.AllPaintingInWmPaint
					|ControlStyles.UserPaint
					|ControlStyles.ResizeRedraw
					|ControlStyles.Selectable
					|ControlStyles.UserMouse, true);

			// Set these true to enable Focus()
			Visible = true;
			Enabled = true;

			_Value   = 0.0f;
			_Maximum = 0.0f;
			_Step    = 1.0f;

			UpdateStyles();
		}

		/// <summary>
		/// Perform a single step on Value. Clips to Maximum.
		/// </summary>
		public void PerformStep()
		{
			if(_Value < _Maximum)
			{
				_Value += _Step;
				if(_Value > _Maximum)
				{
					_Value = _Maximum;
				}
			}
		}

		protected override void OnResize(EventArgs e)
		{
			base.OnResize (e);

			// Make sure that this is not a minimize resize, we don't care about re-creating
			// the backbuffer in that case
			if(ClientRectangle.Width != 0 && ClientRectangle.Height != 0)
			{
				CreateBackbuffer();	
				SizeF stringBounds = _BG.MeasureString("TEST", Font);
				_Offset = (ClientRectangle.Height/2.0f) - (stringBounds.Height/2.0f);
			}
		}

		protected override void OnPaintBackground(PaintEventArgs pevent)
		{
			// All painting should be done in OnPaint
		}


		protected override void OnPaint(PaintEventArgs e)
		{
			RefreshBackbuffer();
			FlushBackbuffer(e.Graphics);
		}
		
		private void RefreshBackbuffer()
		{
			_BG.FillRectangle(new SolidBrush(this.BackColor), ClientRectangle);
			_BG.DrawRectangle(new Pen(Color.Black), ClientRectangle.X, ClientRectangle.Y, ClientRectangle.Width-1, ClientRectangle.Height-1);


			float width = 0;

			if(_Maximum > 0)
			{
				width = (float)Math.Floor((_Value/_Maximum) * (float)ClientRectangle.Width);
			}

			Rectangle progressRect = new Rectangle(
					0, 
					0, 
					(int)width, 
					ClientRectangle.Height);

			_BG.FillRectangle(new SolidBrush(this.ForeColor), progressRect);

			string message = "";
			if(_Description != null && _Description.Length > 0)
			{
				message += _Description; 
			}
			if(_Maximum > 0)
			{
				if(message.Length > 0)
				{
					message += ": ";
				}

				message += _Value + "/" + _Maximum + " (" + (_Value/_Maximum).ToString("p") + ")";
			}

			_BG.DrawString(message, Font, new SolidBrush(Color.White), 4, _Offset);
		}

		private void FlushBackbuffer(Graphics g)
		{
			g.DrawImage(_Backbuffer, ClientRectangle);
		}

		private void CreateBackbuffer()
		{
			if(_BG != null)
				_BG.Dispose();
			if(_Backbuffer != null)
				_Backbuffer.Dispose();

			_Backbuffer = new Bitmap(ClientRectangle.Width, ClientRectangle.Height);
			_BG = Graphics.FromImage(_Backbuffer);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\MainClass.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Windows.Forms;
using System.Xml;
using System.Text;
using System.Web;
using System.Web.Hosting;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;

namespace STFRunner
{
    public class MainClass : BaseApp
    {
        [STAThread]
        static void Main(string[] args)
        {
            new MainClass().Run(args);
        }

        protected override void ConfigureCommandLine()
        {
            _CommandLineParser.Usage = "STFRunner.exe <options> <test suites (.dll)> <test config files (.xml)>"; 
            _CommandLineParser.Notes = "Either -functional or -stress must be specified to run tests from command line.\nIf neither is specified then stfrunner will bring up the GUI.";
            _CommandLineParser.AddSwitch("functional", "Run functional tests according to the config files (or all tests if no configuration info is found.)", true);
            _CommandLineParser.AddSwitch("stress", "Run stress tests according to the config files.", true);
            _CommandLineParser.AddSwitch("regdb", "Log functional results to the regression DB.");
            _CommandLineParser.AddSwitch("auto", "Automatically load suites from the Suites directory, watches test suites for changes.");
            _CommandLineParser.AddSwitch("stressenv", "Specify the environment to run against (stress only).  (-stressenv:bvtnet) Stressnet is default.");
        }

        protected override void ShowError(string title, string message)
        {
            // Show a message box
            MessageBox.Show(message, title);
        }

        protected override void ShowMessage(string title, string message)
        {
            MessageBox.Show(message, title);
        }


        protected override void BeginApplication(StfXmlDoc config)
        {
            TestSuiteContainer suites = new TestSuiteContainer();
            
            if (_CommandLine.HasSwitch("stress"))
            {
                //set environment
                Global.Config = config;
                ServerTestFramework.Global.Initialize("stf.xml");

                string envName="stressnet"; //default
                if (_CommandLine.HasSwitch("stressenv"))
                {
                    envName=((CommandLine.Switch)_CommandLine.Switches["stressenv"]).GetSubParams(0)[0];
                }

                bool found = false;
                if (Global.NpdbSettings!=null)
                {
                    foreach (NpdbSetting npdbSetting in Global.NpdbSettings)
                    {
                        if (npdbSetting.environment.ToLower() == envName.ToLower())
                        {
                            Global.DefaultNpdbSetting = npdbSetting;
                            found = true;
                        }
                    }
                }
                if (!found)
                {
                    ShowError("Error - invalid environment specified.", "Environment '"+envName+"' not found in config.");
                    return;
                }

                //
                suites.LoadFiles(GetFilesFromCommandLine("dll"));
                suites.SearchForSuites(config);
                Application.Run(new StressGUI(config, suites));
            }
            else
            {
                GUI gui = new GUI(config, suites);

                // enable auto load of deployed suites
                // uses the isolation mode of the test suite container
                if(_CommandLine.HasSwitch("auto"))
                {
                    suites.IsolateTestSuites = true;
                    suites.LoadAllDeployedSuites();
                }

                suites.LoadFiles(GetFilesFromCommandLine("dll"));
                suites.SearchForSuites(config);
    
                // default type is functional
                Application.Run(gui);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\ServerScheduler.cs ===
using System;
using ServerTestFramework.Runner;

namespace STFRunner
{
    public class ServerScheduler : ServerTestFramework.Runner.StressTestScheduler
    {
        //private Service.Server.Client _Client;
        private StfXmlDoc _Config;
        private TestSuiteContainer _Suites;

        public void Initialize(StfXmlDoc config, TestSuiteContainer suites, StressJobList jobListReference, object param)
        {
            _Config = config;
            _Suites = suites;
            //_Client = null;
        }

        public void Shutdown()
        {
        }

        public void Run()
        {
        }

        public void Stop()
        {
        }

        public void SetParameter(string name, object param)
        {
        }

        public bool ValidateParameters()
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\RegressionHistory.cs ===
using System;
using System.ComponentModel;
using System.Collections;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Data.SqlClient;
using System.Threading;
using System.Net;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Reporting;

namespace STFRunner
{
    public class RegressionHistory : Form
    {
        public class FormClosedException : Exception
        {
        }

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;


        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.txtBox = new System.Windows.Forms.RichTextBox();
            this.statusBox = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            // 
            // txtBox
            // 
            this.txtBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.txtBox.Font = new System.Drawing.Font("Lucida Console", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.txtBox.Location = new System.Drawing.Point(0, 0);
            this.txtBox.Name = "txtBox";
            this.txtBox.ReadOnly = true;
            this.txtBox.Size = new System.Drawing.Size(472, 454);
            this.txtBox.TabIndex = 0;
            this.txtBox.Text = "";
            this.txtBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.RegressionHistory_KeyPress);
            // 
            // statusBox
            // 
            this.statusBox.BackColor = System.Drawing.SystemColors.Control;
            this.statusBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.statusBox.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.statusBox.Location = new System.Drawing.Point(12, 202);
            this.statusBox.Multiline = true;
            this.statusBox.Name = "statusBox";
            this.statusBox.Size = new System.Drawing.Size(448, 46);
            this.statusBox.TabIndex = 1;
            this.statusBox.Text = "Retrieving regression history...\r\nPress ESC to cancel";
            this.statusBox.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
            this.statusBox.Visible = false;
            this.statusBox.WordWrap = false;
            // 
            // RegressionHistory
            // 
            this.ClientSize = new System.Drawing.Size(472, 454);
            this.Controls.Add(this.statusBox);
            this.Controls.Add(this.txtBox);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
            this.Name = "RegressionHistory";
            this.Text = "RegressionHistory";
            this.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.RegressionHistory_KeyPress);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.RichTextBox txtBox;
        private RegDBSettings settings;
        private bool bFormActive = true;
        private BackgroundWorker worker;
        private TextBox statusBox;
        private TestTreeNode nodeForHistory;

        public RichTextBox Output
        {
            get
            {
                if (!bFormActive || txtBox.Disposing)
                    throw new FormClosedException();
                else
                    return txtBox;
            }
        }

        public RegressionHistory(StfXmlDoc config)
        {
            InitializeComponent();
            Initialize(config);
        }

        public void Initialize(StfXmlDoc config)
        {
            // Create the background worker and set up the event handlers
            worker = new BackgroundWorker();
            worker.WorkerSupportsCancellation = true;
            worker.DoWork += new DoWorkEventHandler(worker_DoWork);
            worker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(worker_RunWorkerCompleted);

            settings = new RegDBSettings();
            settings.LoadFromConfig(config);
        }

        void worker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            try
            {
                statusBox.Visible = false;

                // First check for any exceptions
                if (e.Error != null)
                {
                    Output.AppendText(e.Error.Message);
                }
                else if (e.Cancelled)
                {
                    // At this point, the dialog box is gone, so do nothing.
                    return;
                }
                else
                {
                    SqlDataReader reader = e.Result as SqlDataReader;
                    if (reader == null)
                    {
                        Output.AppendText("Invalid result data. Regression history cannot be displayed.");
                        return;
                    }

                    Output.AppendText("RegDb history for " + nodeForHistory.TestTypeString + ":\n");
                    Output.AppendText(nodeForHistory.FullPath + "\n");

                    // Display the results
                    if (nodeForHistory.NodeLevel == 0)
                        DisplayForSuite(reader);
                    else if (nodeForHistory.NodeLevel == 1)
                        DisplayForGroup(reader);
                    else if (nodeForHistory.NodeLevel == 2)
                        DisplayForTest(reader);

                    reader.Close();
                }
            }
            catch (FormClosedException)
            {
                // eat it
            }
        }

        void worker_DoWork(object sender, DoWorkEventArgs e)
        {
            string SqlStatement;
            SqlConnection sqlConn = null;
            SqlCommand sqlCmd = null;
            SqlDataReader sqlReader = null;
            TestTreeNode node = e.Argument as TestTreeNode;

            if (node == null)
                throw new ArgumentNullException("e.Argument", "Invalid tree node passed to the worker thread.");

            e.Result = null;

            if (node.NodeLevel == 0)
                SqlStatement = SelectForSuite(node);
            else if (node.NodeLevel == 1)
                SqlStatement = SelectForGroup(node);
            else if (node.NodeLevel == 2)
                SqlStatement = SelectForTest(node);
            else
                throw new ArgumentOutOfRangeException("node.NodeLevel", node.NodeLevel, "Unknown node level");

            // Retrieve and open connection
            sqlConn = RegDB.OpenSQLConnection();
            if (sqlConn == null)
            {
                throw new Exception("Unable to connect to any regdb ips, please check your /stf/config/regressiondb/ settings");
            }

            // Bail if we've been cancelled
            if (worker.CancellationPending)
            {
                Global.RO.Debug("Cancelling operation");
                e.Cancel = true;
                sqlConn.Close();
                return;
            }

            // Do SQL command
            sqlCmd = new SqlCommand(SqlStatement, sqlConn);
            sqlReader = sqlCmd.ExecuteReader();

            // Check to see if we've been cancelled during the ExecuteReader call
            if (worker.CancellationPending)
            {
                Global.RO.Debug("Cancelling operation");
                e.Cancel = true;
                sqlReader.Close();
                sqlConn.Close();
            }
            else
            {
                e.Result = sqlReader;
            }
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }
        
        private void RegressionHistory_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == 27)
            {
                bFormActive = false;
                worker.CancelAsync();
                this.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="name"></param>
        /// <param name="nodelevel">0=suite, 1=testgroup, 2=testcase</param>
        public void ShowHistory(TestTreeNode node)
        {
            this.Text = "Regression history for " + node.TestName;
            this.Show();
            this.Update();
            this.bFormActive = true;
            this.nodeForHistory = node;

            // Start the background worker to perform the query on the database
            statusBox.Visible = true;
            worker.RunWorkerAsync(node);
        }

        #region Sql selection query builders

        public string SelectForSuite(TestTreeNode node)
        {
            // Essential query:
            //
            /*
                SELECT      Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result, COUNT(*) AS ResultCount
                FROM        TestCase INNER JOIN
                            TestRun ON TestCase.TestCaseID = TestRun.TestCaseID INNER JOIN
                            TestGroup INNER JOIN
                            SubComponent ON TestGroup.SubCompID = SubComponent.SubCompID ON TestCase.TestGroupID = TestGroup.TestGroupID INNER JOIN
                            Iteration ON TestRun.IterationID = Iteration.IterationID
                GROUP BY    SubComponent.SubComponent, Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result
                HAVING      (SubComponent.SubComponent = 'XkdcTest')
                ORDER BY    Iteration.BuildNo, Iteration.IterationNO, TestRun.Result
             */

            TestTreeNode parent = (TestTreeNode)node.Parent;
            string SELECT = "SELECT Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result, COUNT(*), env.[Name] AS ResultCount ";
            string FROM = "FROM TestCase INNER JOIN TestRun ON TestCase.TestCaseID = TestRun.TestCaseID INNER JOIN TestGroup INNER JOIN SubComponent ON TestGroup.SubCompID = SubComponent.SubCompID ON TestCase.TestGroupID = TestGroup.TestGroupID INNER JOIN Iteration ON TestRun.IterationID = Iteration.IterationID ";
            string JOIN_ENV = "join Environments as env on Iteration.EnvironmentID = env.EnvironmentId ";
            string GROUPBY = "GROUP BY SubComponent.SubComponent, Iteration.BuildNo, Iteration.IterationNO, env.[Name], Iteration.[Date], TestRun.Result ";
            string HAVING = "HAVING (SubComponent.SubComponent = '" + node.TestName + "') ";
            string ORDERBY = "ORDER BY Iteration.BuildNo, Iteration.IterationNO, TestRun.Result ";
            return SELECT + FROM + JOIN_ENV + GROUPBY + HAVING + ORDERBY;
        }

        public string SelectForGroup(TestTreeNode node)
        {
            // Essential query:
            //
            /*
                SELECT      Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result, COUNT(*) AS ResultCount
                FROM        TestCase INNER JOIN
                            TestRun ON TestCase.TestCaseID = TestRun.TestCaseID INNER JOIN
                            TestGroup INNER JOIN
                            SubComponent ON TestGroup.SubCompID = SubComponent.SubCompID ON TestCase.TestGroupID = TestGroup.TestGroupID INNER JOIN
                            Iteration ON TestRun.IterationID = Iteration.IterationID
                GROUP BY    TestGroup.TestGroup, SubComponent.SubComponent, Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result
                HAVING      (SubComponent.SubComponent = 'XkdcTest') AND (TestGroup.TestGroup = 'XenonServices')
                ORDER BY    Iteration.BuildNo, Iteration.IterationNO, TestRun.Result
             */

            TestTreeNode parent = (TestTreeNode)node.Parent;
            string SELECT = "SELECT Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result, COUNT(*), env.[Name] AS ResultCount ";
            string FROM = "FROM TestCase INNER JOIN TestRun ON TestCase.TestCaseID = TestRun.TestCaseID INNER JOIN TestGroup INNER JOIN SubComponent ON TestGroup.SubCompID = SubComponent.SubCompID ON TestCase.TestGroupID = TestGroup.TestGroupID INNER JOIN Iteration ON TestRun.IterationID = Iteration.IterationID ";
            string JOIN_ENV = "join Environments as env on Iteration.EnvironmentID = env.EnvironmentId ";
            string GROUPBY = "GROUP BY TestGroup.TestGroup, SubComponent.SubComponent, Iteration.BuildNo, Iteration.IterationNO, env.[Name], Iteration.[Date], TestRun.Result ";
            string HAVING = "HAVING (SubComponent.SubComponent = '" + parent.TestName + "') AND (TestGroup.TestGroup = '" + node.TestName + "') ";
            string ORDERBY = "ORDER BY Iteration.BuildNo, Iteration.IterationNO, TestRun.Result ";
            return SELECT + FROM + JOIN_ENV + GROUPBY + HAVING + ORDERBY;
        }

        public string SelectForTest(TestTreeNode node)
        {
            // Essential query:
            //
            /*
                SELECT      Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result
                FROM        TestRun INNER JOIN
                            TestCase ON TestRun.TestCaseID = TestCase.TestCaseID INNER JOIN
                            TestGroup ON TestCase.TestGroupID = TestGroup.TestGroupID INNER JOIN
                            SubComponent ON TestGroup.SubCompID = SubComponent.SubCompID INNER JOIN
                            Iteration ON TestRun.IterationID = Iteration.IterationID
                WHERE       (SubComponent.SubComponent LIKE 'XkdcTest') and (TestGroup.TestGroup LIKE 'XenonAuthdata') and (TestCase.TestCaseName LIKE 'AuthdataXenonFields')
                ORDER BY    Iteration.BuildNo, Iteration.IterationNO
            */

            TestTreeNode parent = (TestTreeNode)node.Parent;
            TestTreeNode grandparent = (TestTreeNode)parent.Parent;
            string SELECT = "SELECT Iteration.BuildNo, Iteration.IterationNO, Iteration.[Date], TestRun.Result, env.[Name] ";
            string FROM = "FROM TestRun INNER JOIN TestCase ON TestRun.TestCaseID = TestCase.TestCaseID INNER JOIN TestGroup ON TestCase.TestGroupID = TestGroup.TestGroupID INNER JOIN SubComponent ON TestGroup.SubCompID = SubComponent.SubCompID INNER JOIN Iteration ON TestRun.IterationID = Iteration.IterationID ";
            string JOIN_ENV = "join Environments as env on Iteration.EnvironmentID = env.EnvironmentId ";
            string WHERE = "WHERE (SubComponent.SubComponent='" + grandparent.TestName + "') AND (TestGroup.TestGroup='" + parent.TestName + "') AND (TestCase.TestCaseName='" + node.TestName + "') ";
            string ORDERBY = "ORDER BY Iteration.BuildNo, Iteration.IterationNO ";
            return SELECT + FROM + JOIN_ENV + WHERE + ORDERBY;
        }

        #endregion

        #region Sql data reader displayers

        private void DisplayForSuite(SqlDataReader sr)
        {
            DisplayForGroup(sr);
        }

        private void DisplayForGroup(SqlDataReader sr)
        {
            int rowcount = 0;
            int countpass = 0;
            int countfail = 0;
            int percentpass = 0;
            string lastbuild = "";
            string build = "";
            string date = "";

            if (sr.HasRows)
            {
                // Header
                Output.SelectionColor = Color.Black;
                //                 5             0          1      2             3/4    3/4    3/4
                //                 testnet       04.00.0154.55     11/17/2004    3      0      100%
                Output.AppendText("Environment   Build             Date          Pass   Fail   Rate\n");
                Output.AppendText("===========   ==============    ==========    ====   ====   ====\n");

                while (sr.Read() && bFormActive)
                {
                    // Expect either 1 or 2 rows for each TestCase, depending on Result
                    // Expect 4 columns total
                    //
                    // 0 - BuildNo (string)
                    // 1 - IterationNO (int32)
                    // 2 - Date (datetime)
                    // 3 - Result (int32)
                    // 4 - ResultCount (int32)
                    // 5 - Environment

                    build = (sr.GetString(5)).PadRight(14);
                    build += sr.GetString(0) + "." + sr.GetInt32(1).ToString().PadRight(3+4);

                    // If we moved to a new record, then dump previous record now
                    if (lastbuild != build && rowcount > 0)
                    {
                        Output.SelectionColor = (countfail > 0) ? Color.Red : Color.Black;
                        Output.AppendText(lastbuild);
                        Output.AppendText(date.PadRight(10 + 4));
                        Output.AppendText(countpass.ToString().PadRight(3 + 4));
                        Output.AppendText(countfail.ToString().PadRight(3 + 4));
                        percentpass = (int)(100 * countpass / (countfail + countpass));
                        Output.AppendText(percentpass.ToString() + "%\n");
                        countpass = 0;
                        countfail = 0;
                    }

                    lastbuild = build;
                    date = sr.GetDateTime(2).ToShortDateString();
                    int result = sr.GetInt32(3);
                    int resultcount = sr.GetInt32(4);
                    if (result > 0)
                        countpass += resultcount;
                    else
                        countfail += resultcount;
                    rowcount++;
                }

                // Dump last record
                Output.SelectionColor = (countfail > 0) ? Color.Red : Color.Black;
                Output.AppendText(lastbuild.PadRight(13 + 4) + date.PadRight(10 + 4));
                Output.AppendText(countpass.ToString().PadRight(3 + 4));
                Output.AppendText(countfail.ToString().PadRight(3 + 4));
                percentpass = (int)(100 * countpass / (countfail + countpass));
                Output.AppendText(percentpass.ToString() + "%\n");
            }
            else
            {
                Output.AppendText("\nNo regression history was found.\n");
            }

            Output.AppendText("\ndone.\n");
        }

        private void DisplayForTest(SqlDataReader sr)
        {
            if (sr.HasRows)
            {
                // Header
                Output.SelectionColor = Color.Black;
                //                 testnet       04.00.0826.55     1/11/2006     pass
                Output.AppendText("Environment   Build             Date          Result\n");
                Output.AppendText("===========   ==============    ==========    ======\n");

                while (sr.Read() && bFormActive)
                {
                    // Expect 4 columns total
                    //
                    // 0 - BuildNo (string)
                    // 1 - IterationNO (int32)
                    // 2 - Date (datetime)
                    // 3 - Result (int32)
                    // 4 - Environment

                    // Pass/fail flag
                    string build = (sr.GetString(4)).PadRight(14);
                    build += (sr.GetString(0) + "." + sr.GetInt32(1).ToString()).PadRight(14+4);
                    string date = sr.GetDateTime(2).ToShortDateString().PadRight(10 + 4);
                    bool pass = sr.GetInt32(3) > 0;

                    if (pass)
                        Output.SelectionColor = Color.Black;
                    else
                        Output.SelectionColor = Color.Red;

                    Output.AppendText(build + date.PadRight(10 + 4));
                    if (pass)
                    {
                        Output.AppendText("pass\n");
                    }
                    else
                    {
                        Output.AppendText("fail\n");
                    }
                }
            }
            else
            {
                Output.AppendText("\nNo regression history was found.\n");
            }
            Output.AppendText("\ndone.\n");
        }

        #endregion

        private void DebugMsg(string format, params object[] args)
        {
            if (bFormActive)
            {
                Output.AppendText(String.Format(format, args) + "\n");
                Output.Update();
            }
            Global.RO.Debug(format, args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\RegDBForm.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using Microsoft.Win32;
using ServerTestFramework;

namespace STFRunner
{
	/// <summary>
	/// Summary description for RegDBForm.
	/// </summary>
	public class RegDBForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.NumericUpDown numericUpDown1;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.PictureBox pictureBox1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Label label4;
		public System.Windows.Forms.ComboBox comboBox1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public RegDBForm(string[] ServerIPs )
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
            if (ServerIPs == null)
            {
                Global.RO.Debug("Warning: no server ips specified for RegDBForm. This is probably bad.");
            }
            else
            {
                foreach (string ip in ServerIPs)
                {
                    if (ip == null)
                    {
                        Global.RO.Debug("Warning: trying to add a null IP to RegDBForm ServerIP combo box. Why are you doing this?.  ServerIPs.Length={0}", ServerIPs.Length);
                    }
                    else
                    {
                        comboBox1.Items.Add(ip);
                    }
                }
            }

			textBox1.Text = GetLastUsedBuildNumberFromRegistry();
			comboBox1.Text = GetLastUsedIpFromRegistry();

			if (comboBox1.Text == "" && comboBox1.Items.Count > 0)
				comboBox1.SelectedIndex = 0;
			if (textBox1.Text == "")
				textBox1.Text = "00.00.0000";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(RegDBForm));
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.panel1 = new System.Windows.Forms.Panel();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.panel2 = new System.Windows.Forms.Panel();
            this.comboBox1 = new System.Windows.Forms.ComboBox();
            this.label4 = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();
            this.panel1.SuspendLayout();
            this.panel2.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label1.Location = new System.Drawing.Point(16, 24);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(168, 23);
            this.label1.TabIndex = 0;
            this.label1.Text = "Log results to \\\\xonlinetest";
            this.label1.Visible = false;
            // 
            // label2
            // 
            this.label2.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label2.Location = new System.Drawing.Point(23, 64);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(48, 16);
            this.label2.TabIndex = 1;
            this.label2.Text = "Build #:";
            // 
            // textBox1
            // 
            this.textBox1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.textBox1.Location = new System.Drawing.Point(95, 64);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(104, 21);
            this.textBox1.TabIndex = 2;
            this.textBox1.Text = "00.00.0000";
            this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
            // 
            // label3
            // 
            this.label3.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label3.Location = new System.Drawing.Point(23, 100);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(64, 16);
            this.label3.TabIndex = 3;
            this.label3.Text = "Iteration #:";
            // 
            // numericUpDown1
            // 
            this.numericUpDown1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.numericUpDown1.Location = new System.Drawing.Point(95, 96);
            this.numericUpDown1.Name = "numericUpDown1";
            this.numericUpDown1.Size = new System.Drawing.Size(104, 21);
            this.numericUpDown1.TabIndex = 4;
            this.numericUpDown1.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // button1
            // 
            this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.button1.Location = new System.Drawing.Point(168, 244);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(72, 24);
            this.button1.TabIndex = 5;
            this.button1.Text = "OK";
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // button2
            // 
            this.button2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button2.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.button2.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.button2.Location = new System.Drawing.Point(80, 244);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(72, 24);
            this.button2.TabIndex = 6;
            this.button2.Text = "Cancel";
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // panel1
            // 
            this.panel1.BackColor = System.Drawing.SystemColors.Highlight;
            this.panel1.Controls.Add(this.pictureBox1);
            this.panel1.Dock = System.Windows.Forms.DockStyle.Left;
            this.panel1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.panel1.Location = new System.Drawing.Point(8, 8);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(72, 278);
            this.panel1.TabIndex = 7;
            // 
            // pictureBox1
            // 
            this.pictureBox1.BackColor = System.Drawing.SystemColors.Highlight;
            this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
            this.pictureBox1.Location = new System.Drawing.Point(5, 19);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(64, 64);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
            this.pictureBox1.TabIndex = 3;
            this.pictureBox1.TabStop = false;
            // 
            // panel2
            // 
            this.panel2.Controls.Add(this.comboBox1);
            this.panel2.Controls.Add(this.label4);
            this.panel2.Controls.Add(this.button1);
            this.panel2.Controls.Add(this.button2);
            this.panel2.Controls.Add(this.label1);
            this.panel2.Controls.Add(this.numericUpDown1);
            this.panel2.Controls.Add(this.textBox1);
            this.panel2.Controls.Add(this.label2);
            this.panel2.Controls.Add(this.label3);
            this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
            this.panel2.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.panel2.Location = new System.Drawing.Point(80, 8);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(258, 278);
            this.panel2.TabIndex = 8;
            // 
            // comboBox1
            // 
            this.comboBox1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.comboBox1.Location = new System.Drawing.Point(94, 130);
            this.comboBox1.Name = "comboBox1";
            this.comboBox1.Size = new System.Drawing.Size(154, 21);
            this.comboBox1.TabIndex = 8;
            this.comboBox1.Visible = false;
            // 
            // label4
            // 
            this.label4.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label4.Location = new System.Drawing.Point(23, 136);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(56, 16);
            this.label4.TabIndex = 7;
            this.label4.Text = "RegDB IP";
            this.label4.Visible = false;
            // 
            // RegDBForm
            // 
            this.AcceptButton = this.button1;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this.button2;
            this.ClientSize = new System.Drawing.Size(346, 294);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.panel1);
            this.DockPadding.All = 8;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "RegDBForm";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Reg DB";
            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();
            this.panel1.ResumeLayout(false);
            this.panel2.ResumeLayout(false);
            this.ResumeLayout(false);

        }
		#endregion

		private void button1_Click(object sender, System.EventArgs e)
		{
			if (!new Regex(@"^\d\d\.\d\d\.\d\d\d\d$").Match(textBox1.Text).Success)
				MessageBox.Show("Build number must be in the form 'xx.xx.xxxx'");
			//else if (!new Regex(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$").Match(comboBox1.Text).Success)
			//	MessageBox.Show("Server IP number must be in the form 'xxx.xxx.xxxx'");
            //else if (!new Regex(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(\,\d{1,5}){0,1}$").Match(comboBox1.Text).Success) //no.. we want to accept dns names too
            //    MessageBox.Show("Server IP number must be in the form 'xxx.xxx.xxx.xxx[,xxxxx]'");
            else
			{
				SetLastUsedBuildNumberInRegistry(textBox1.Text.Trim());
				SetLastUsedIpInRegistry(comboBox1.Text.Trim());
                this.DialogResult = DialogResult.OK;
				Close();
			}
		}

		private void button2_Click(object sender, System.EventArgs e)
		{
            this.DialogResult = DialogResult.Cancel;
            Close();
		}

		private void textBox1_TextChanged(object sender, System.EventArgs e)
		{
		
		}

		private void numericUpDown1_ValueChanged(object sender, System.EventArgs e)
		{
		
		}


		private string GetLastUsedBuildNumberFromRegistry()
		{
			string returnVal = "";
			
			object buildNumber = Global.CommonAppDataRegistry.GetValue("LastUsedBuildNumber");
			if (buildNumber != null)
				returnVal = buildNumber.ToString();
	
			return returnVal;
		}

		private string GetLastUsedIpFromRegistry()
		{
			string returnVal = "";
			
			object ip = Global.CommonAppDataRegistry.GetValue("LastUsedIP");
			if (ip != null)
				returnVal = ip.ToString();
			
			return returnVal;
		}

		private void SetLastUsedBuildNumberInRegistry(string buildNumber)
		{
			Global.CommonAppDataRegistry.SetValue("LastUsedBuildNumber", buildNumber);
		}

		private void SetLastUsedIpInRegistry(string ip)
		{
			Global.CommonAppDataRegistry.SetValue("LastUsedIP", ip);
		}

		public string BuildNo {get {return textBox1.Text;}}
		public int IterationNo {get {return (int)numericUpDown1.Value;}}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\StressScheduler.cs ===
//this is the old priority based schedular

using System;
using System.Collections;
using System.Diagnostics;
using System.Xml;
using System.Threading;
using System.Windows.Forms;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using STFRunner;
using STFRunner.Status;

namespace ServerTestFramework.Runner
{
    public class StressSchedulerPriority: StressTestScheduler
    {
        public StressSettingsPriority Settings;
        protected StressJobList stressJobs;
        public bool ShowDetailedExceptions = true;
        public int DeadlockSeconds = 120;

        protected static RandomEx RandGen = new RandomEx();
        protected bool running = false;
        protected DateTime startTime = DateTime.Now;
        protected DateTime endTime = DateTime.Now.AddDays(365);
        private DateTime lastPick = DateTime.Now;
        protected int initThreads;

        private ArrayList threads = new ArrayList();
        private ArrayList terminationList = new ArrayList();
        private object throttleLock = new object();
        private bool throttlingEnabled = false;
        public double ThrottlingDelay = 100;

        //private TestResult Results = new TestResult();
        private TestResultCollection AllResults = new TestResultCollection();

        private StfXmlDoc Config;
        private TestSuiteContainer Suites;
        //private FileReportDestination stressResultsDest = null;

        // For communication with the controller server
        private Controller stfController = new Controller();

        public bool ThrottlingEnabled
        {
            get{return throttlingEnabled;}
            set{throttlingEnabled=value; lastPick=DateTime.Now; Settings.UseThrottling=value;}
        }

        public DateTime EndTime
        {
            get {return endTime;}
            set 
            {
                if (value<DateTime.Now)
                    endTime=DateTime.Now;
                else
                    endTime=value;}
        }

        public int NumThreads {get {return threads.Count + terminationList.Count;}}
        public bool Running {get {return running;}}
        
        public int NumUnstoppedThreads
        {
            get
            {
                int num = 0;

                foreach (StressThread thread in threads)
                    if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                        num++;

                foreach (StressThread thread in terminationList)
                    if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                        num++;

                return num;
            }
        }

        public TimeSpan GetElapsed()
        {
            if (DateTime.Now>EndTime)
                return endTime-startTime;
            else
                return DateTime.Now-startTime;
        }

        public int SecondsRemaining
        {
            get {return (int)(endTime - DateTime.Now).TotalSeconds;}
            set {endTime = DateTime.Now.AddSeconds(value);}
        }

        public int MaxThreads
        {
            get
            {
                lock (threads)
                {
                    if (!running)
                        return initThreads;

                    return threads.Count;
                }
            }
            set
            {
                lock (threads)
                {
                    Settings.Threads = value;

                    if (!running)
                    {
                        initThreads = value;
                        return;
                    }

                    int numNewThreads = value - threads.Count;
                    if (numNewThreads >= 0)
                    {
                        // Need to create additional threads
                        for (int i = 0; i < numNewThreads; i++)
                        {
                            StressThread st = new StressThread(this);
                            threads.Add(st);
                            st.Start();
                        }
                    }
                    else
                    {
                        // Need to kill some threads
                        TerminateThreads(-numNewThreads);
                    }
                }
            }
        }

/*
        [ThreadStatic]
        private static bool _waitTimeLastChangeInited;
        [ThreadStatic]
        private static DateTime _waitTimeLastChange;
        private DateTime waitTimeLastChange
        {
            get
            {
                // Initialize the waitTimeMs if it hasn't already been
                if (_waitTimeLastChangeInited == false)
                {
                    _waitTimeLastChange = DateTime.Now;
                    _waitTimeLastChangeInited = true;
                }
                return(_waitTimeLastChange);
            }
            set
            {
                _waitTimeLastChange = value;
            }
        }

        private bool WaitTimeChangeAllowed()
        {
            if ((DateTime.Now - waitTimeLastChange).TotalSeconds >= 1)
            {
                return(true);
            }
            return(false);
        }

        [ThreadStatic]
        private static bool _waitTimeMsInited;
        [ThreadStatic]
        private static int _waitTimeMs;
        private int waitTimeMs
        {
            get
            {
                // Initialize the waitTimeMs if it hasn't already been
                if (_waitTimeMsInited == false)
                {
                    if (Settings.ThrottlingTps <= 0)
                    {
                        throw new Exception("Throttling TPS cannot be equal to or less than 0");
                    }

                    _waitTimeMs = (int)Math.Ceiling((double)(1000 / Settings.ThrottlingTps * MaxThreads));
                    _waitTimeMsInited = true;
                    Global.RO.Debug("_waitTimeMs initialized to {0}", _waitTimeMs);
                }
                return(_waitTimeMs);
            }
            set
            {
                _waitTimeMs = value;
                waitTimeLastChange = DateTime.Now;
            }
        }

        private const int waitMsStep = 5;
*/

        private object waitTimeLastChangeLock = new object();
        private DateTime waitTimeLastChange = DateTime.Now;
        private bool WaitTimeChangeAllowed()
        {
            if ((DateTime.Now - startTime).TotalSeconds < 20)
            {
                return(false);
            }
            lock(waitTimeLastChangeLock)
            {
                if ((DateTime.Now - waitTimeLastChange).TotalSeconds >= 1)
                {
                    return(true);
                }
            }
            return(false);
        }

        private volatile bool _waitTimeMsInited = false;
        private object _waitTimeMsLock = new object();
        private volatile int _waitTimeMs = 0;
        private int waitTimeMs
        {
            get
            {
                lock(_waitTimeMsLock)
                {
                    // Initialize the waitTimeMs if it hasn't already been
                    if (_waitTimeMsInited == false)
                    {
                        if (Settings.ThrottlingTps <= 0)
                        {
                            throw new Exception("Throttling TPS cannot be equal to or less than 0");
                        }
                        _waitTimeMs = (int)Math.Ceiling(1000.0 / Settings.ThrottlingTps * NumThreads);
                        _waitTimeMsInited = true;
                        Global.RO.Debug("_waitTimeMs initialized to {0}", _waitTimeMs);
                    }
                    return(_waitTimeMs);
                }
            }
            set
            {
                lock(_waitTimeMsLock)
                {
                    if (WaitTimeChangeAllowed())
                    {
                        _waitTimeMs = value;
                        lock(waitTimeLastChangeLock)
                        {
                            waitTimeLastChange = DateTime.Now;
                        }
                    }
                }
            }
        }

        private const int waitMsStep = 1;

        virtual public StressJob PickTest()
        {
            try
            {
                while (stressJobs.TotalPriority == 0)
                    Thread.Sleep(500);

                if (throttlingEnabled)
                {
                    if (StressGUI.CurrentTPS > Settings.ThrottlingTps && StressGUI.CurrentShortTPS > Settings.ThrottlingTps)
                    {
                        // We're going too fast
                        if (WaitTimeChangeAllowed())
                        {
                            if (RandGen.Next(1, 3) == 1) // 50% chance of adjustment for a kinder, more gentle tuning
                            {
                                if (waitTimeMs <= int.MaxValue - waitMsStep)
                                {
                                    waitTimeMs += waitMsStep;
                                    //Global.RO.Debug("Increased waitTimeMs to {0}", waitTimeMs);
                                }
                            }
                        }
                        if (RandGen.Next(1, 51) == 1)
                        {
                            Global.RO.Debug("Too fast (StressGUI.RealTPS == {0}), Sleeping for {1} ms", StressGUI.RealTPS, waitTimeMs);
                        }
                        Thread.Sleep(waitTimeMs);
                    }
                    else if (StressGUI.CurrentTPS < Settings.ThrottlingTps && StressGUI.CurrentShortTPS > Settings.ThrottlingTps)
                    {
                        // We're going too slow
                        if (WaitTimeChangeAllowed())
                        {
                            if (RandGen.Next(1, 5) == 1) // 25% chance of adjustment for a kinder, more gentle tuning
                            {
                                if (waitTimeMs >= waitMsStep)
                                {
                                    waitTimeMs -= waitMsStep;
                                    //Global.RO.Debug("Decreased waitTimeMs to {0}", waitTimeMs);
                                }
                            }
                        }
                        if (waitTimeMs != 0)
                        {
                            if (RandGen.Next(1, 51) == 1)
                            {
                                Global.RO.Debug("Too slow (StressGUI.RealTPS == {0}), Sleeping for {1} ms", StressGUI.RealTPS, waitTimeMs);
                            }
                            Thread.Sleep(waitTimeMs);
                        }
                    }
                }
                /*
                            if (throttlingEnabled)
                            {
                                lock (throttleLock)
                                {
                                    while ((DateTime.Now-lastPick).TotalMilliseconds<=ThrottlingDelay)
                                        System.Threading.Thread.Sleep(0);
                                    lastPick+=new TimeSpan(0,0,0,0,(int) ThrottlingDelay);
                                }
                            }
                */

                float testToRun = RandGen.Next(stressJobs.TotalPriority);

                foreach (StressJob job in stressJobs)
                {
                    testToRun -= job.Priority;
                    if (testToRun <= 0)
                        return job;
                }

            }
            catch (Exception e)
            {
                Global.RO.Error("Caught exception {0}", e.ToString());
            }

            Global.RO.Error("StressScheduler.PickTest didn't find a test to run!");
            return null;
        }

        //
        public void Initialize(StfXmlDoc config, TestSuiteContainer suites, StressJobList jobListReference, object schedulerSettings)
        {
            if (schedulerSettings==null)
            {
                Settings=new StressSettingsPriority(config);
            }
            else
            {
                Settings=(StressSettingsPriority)schedulerSettings;
            }

            Config = config;
            Suites = suites;
            stressJobs=jobListReference;
            
            //
            SecondsRemaining = Settings.SecondsRemaining;
            MaxThreads = Settings.Threads;
            ThrottlingDelay=1000.0/(double)Settings.ThrottlingTps;
        }

        //Shuts down the scheduler.
        public void Shutdown()
        {
            // Make sure the controller is dead
            stfController.Stop();
        }

        //This call should block and run tests and block until someone calls Stop.
        public void Run()
        {
            if (stressJobs.Count == 0)
            {
                Global.RO.Warn("Stress can not start because no stress jobs are set to run.");
                return;
            }

            BeginStress();
        }

        //Stop running tests.
        public void Stop()
        {
            //TODO: Stuff needs moved from the non-interface functions that currently do this to here.
        }

        public bool ValidateParameters()
        {
            return true;
        }

        /// <summary>
        /// Listener for commands from controller server
        /// </summary>
        /// <param name="msg"></param>
        public void CmdHandler_Stop()
        {
            // Server said we need to shutdown stress.

            // I think this is all we need to do.. It will update the button text,
            // update asyncaction state, and call the registered "stop stress"
            // delegate, which is EndStress() below. Looks good to me.
            StressGUI.asyncAction.Stop(this, null);
            //EndStress();

        }

        /// <summary>
        /// Called by AsyncButtonClickAction when Start button is clicked. This is when we
        /// actually start doing the stress test work.
        /// </summary>
        protected void BeginStress()
        {
            Global.RO.Debug("Stress has started.");
            
            startTime = DateTime.Now;

            string suiteName = "";
            foreach (TestSuite suite in Suites.GetLoadedSuites())
                suiteName += suite.Name + ",";
            suiteName=suiteName.TrimEnd(new char[] {','});

            
            StatusHtmlReport statusHtmlReport = null;
            bool useResultsHtml = Settings.UseResultsHtml;
            if (useResultsHtml)
            {
                statusHtmlReport = new StatusHtmlReport(suiteName, stressJobs, AllResults, 600);
                statusHtmlReport.Start();
                statusHtmlReport.Tick();
            }

            // Register with the control server that we're starting
            stfController.Start(
                TestType.Stress, 
                TestState.running,
                suiteName,
                Global.StfControllerIp,
                new CmdListener_Stop(this.CmdHandler_Stop));

            // Create threads. By setting MaxThreads, it will create all of the threads, but
            // it will only do this if running=true.  Convoluted.
            lock (threads)
            {
                running = true;
                MaxThreads = initThreads;
            }

            lastPick = DateTime.Now;

            // Main loop
            while (SecondsRemaining > 0 && running)
            {
                Thread.Sleep(1000);

                HandleDeadlocks();

                CleanTerminationList();

                VerifyThreadsAreRunning();

                if (stressJobs.TotalPriority == 0)
                {
                    Global.RO.Warn("No jobs are scheduled to run.  Please check your priorities.");
                    Thread.Sleep(500);
                }
            }

            if (useResultsHtml)
            {
                statusHtmlReport.End();
                statusHtmlReport.Tick();
            }

            Global.RO.Debug("Stopping stress...");
            TerminateAllThreads();
            Global.RO.Debug("Stress stopped.");
        }

        /// <summary>
        /// Called by AsyncButtonClickAction when Stop button is clicked.
        /// </summary>
        public void EndStress()
        {
            running = false;

            // Stop heartbeats, unregister with controller server
            stfController.Stop();
        }

        /// <summary>
        /// Terminate some number of threads gently. 
        /// </summary>
        /// <param name="count"></param>
        protected void TerminateThreads(int count)
        {
            lock (threads)
            {
                ArrayList removalList = new ArrayList();

                for (int i = 0; i < count; i++)
                {
                    ((StressThread)threads[i]).SoftTerminate();
                    removalList.Add(threads[i]);
                }

                foreach (StressThread thread in removalList)
                {
                    terminationList.Add(thread);
                    threads.Remove(thread);
                }
            }
        }

        /// <summary>
        /// Terminate all threads, used when stopping stress run.
        /// </summary>
        protected void TerminateAllThreads()
        {
            lock (threads)
            {
                // Softly abort all threads
                TerminateThreads(threads.Count);

                // Then wait a bit for them to stop executing
                int waitTime = 10;
                bool threadsStillRunning = true;
                for (int termSecs = 0; termSecs < waitTime && threadsStillRunning; termSecs++)
                {
                    // TODO: put in a ticker here
                    System.Threading.Thread.Sleep(1000);

                    threadsStillRunning = false;
                    foreach (StressThread thread in terminationList)
                        if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                            threadsStillRunning = true;
                }

                foreach (StressThread thread in terminationList)
                {
                    // We've given the thread some time to shut itself down. It hasn't.
                    // So let's force it to terminate. MSDN says this technique will
                    // "usually" terminate a thread.
                    if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                        thread.Terminate();
                }

                // After aborting the threads, we're going to call Join() which 
                // will wait for them to abort.  
                // TODO: It appears this will happen sequentially, which probably
                // isn't desirable.
                foreach (StressThread thread in terminationList)
                {
                    if (!thread.Join())
                    {
                        Global.RO.Warn("Failed to forcefully terminate thread {0}", thread.ToString());
                    }
                }

                CleanTerminationList();
            }
        }

        protected void HandleDeadlocks()
        {
            lock (threads)
            {
                for (int i = 0; i < threads.Count; i++)
                {
                    StressThread thread = (StressThread)threads[i];
                    if (DateTime.Now > thread.Updated + new TimeSpan(0, 0, DeadlockSeconds))
                    {
                        thread.Terminate();

                        if (thread.CurrentJob != null)
                            thread.CurrentJob.Results.Deadlock();

                        thread = new StressThread(this);
                        thread.Start();
                        threads[i] = thread;
                    }
                }
            }
        }

        protected void CleanTerminationList()
        {
            lock (threads)
            {
                bool itemRemovedFromTerminationList = true;
                while (itemRemovedFromTerminationList)
                {
                    itemRemovedFromTerminationList = false;
                    foreach (StressThread thread in terminationList)
                    {
                        if (thread.ThreadState != System.Threading.ThreadState.Running)
                        {
                            terminationList.Remove(thread);
                            itemRemovedFromTerminationList = true;
                            break;
                        }
                    }
                }
            }
        }

        [Conditional("DEBUG")]
        private void VerifyThreadsAreRunning()
        {
            lock (threads)
            {
                foreach (StressThread thread in threads)
                    Debug.Assert(thread.ThreadState != System.Threading.ThreadState.Stopped);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\StressSettings.cs ===
using System;
using System.Xml;
using ServerTestFramework.Runner;

namespace STFRunner
{
    public class StressSettingsPriority
    {
        private XmlDocument config;

        public int Threads;
        public int SecondsRemaining;
        public bool UseResultsHtml;
        //public bool UseFileReport;
        public bool UseThrottling;
        public volatile int ThrottlingTps;
        public bool VerboseExceptions;

        public StressSettingsPriority(XmlDocument config)
        {
            this.config = config;

            Threads = GetInt32OptionDefault("initialthreads", 1);
            SecondsRemaining = GetInt32OptionDefault("secondsremaining", (int)TimeSpan.FromHours(72).TotalSeconds);
            UseResultsHtml = GetBoolOptionDefault("resultshtml", false);
            //UseFileReport = GetBoolOptionDefault("filereport", false);
            UseThrottling = GetBoolOptionDefault("usethrottling", false);
            ThrottlingTps = GetInt32OptionDefault("throttlingtps", 10);
            VerboseExceptions = GetBoolOptionDefault("verboseexceptions", true);
        }

        private string LookupXmlOption(string name)
        {
            try
            {
                XmlNode xn = config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']");
                if (xn == null)
                    return null;

                XmlAttribute xa = xn.Attributes["value"];
                if (xa == null)
                    return null;

                return xa.Value;
            }
            catch (Exception)
            {
                return null;
            }
        }

        private int GetInt32OptionDefault(string option, int def)
        {
            string s = LookupXmlOption(option);
            if (s == null)
                return def;
            return Convert.ToInt32(s);
        }
        
        private bool GetBoolOptionDefault(string option, bool def)
        {
            string s = LookupXmlOption(option);
            if (s == null)
                return def;

            if (s != "true" && s != "false")
                throw new ArgumentException("Xml boolean values must be 'true' or 'false'.");

            return s == "true";
        }

        private void WriteOptionToXml(StfXmlDoc doc, string name, string val)
        {
            XmlNode option = doc.AddPath("/stf/config/stress/option");

            XmlAttribute attrName = doc.CreateAttribute("name");
            attrName.Value = name;
            option.Attributes.Append(attrName);

            XmlAttribute attrValue = doc.CreateAttribute("value");
            attrValue.Value = val;
            option.Attributes.Append(attrValue);
        }

        private void WriteToXmlDoc(StfXmlDoc doc)
        {
            WriteOptionToXml(doc, "initialthreads", Threads.ToString());
            WriteOptionToXml(doc, "secondsremaining", SecondsRemaining.ToString());
            WriteOptionToXml(doc, "resultshtml", UseResultsHtml.ToString());
            //WriteOptionToXml(doc, "filereport", UseFileReport.ToString());
            WriteOptionToXml(doc, "usethrottling", UseThrottling.ToString());
            WriteOptionToXml(doc, "throttlingtps", ThrottlingTps.ToString());
            WriteOptionToXml(doc, "verboseexceptions", VerboseExceptions.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\RegDBQueryManager.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.Data;
using System.Diagnostics;
using ServerTestFramework.Reporting;

namespace RegDBViewer
{
	public class Server
	{
		public string Servername;
		public string ServerDescription;
		public int ID;
		public Server(string name ,int id,string Description)
		{
			Servername=name;
			ID=id;
			ServerDescription=Description;
		}

		public override string ToString()
		{
			return Servername.Trim();
		}
	}

	public class ServerList : CollectionBase
	{
		public void Add(Server a)
		{
			List.Add(a);
		}

		public Server Item(int index)
		{
			return (Server)List[index];
		}
	}


	public class Build
	{
		public string BuildName;
		public string BuildDescription;
		public int ID;
		public Build(string name ,int id,string Description)
		{
			BuildName=name;
			ID=id;
			BuildDescription=Description;
		}

		public override string ToString()
		{
			return BuildName.Trim();
		}
	}

	public class BuildList : CollectionBase
	{
		public void Add(Build a)
		{
			List.Add(a);
		}

		public Build Item(int index)
		{
			return (Build)List[index];
		}
	}


	public class RegDBQueryManager
	{
		ItemRowList items; 
		RegDb  regData;
	//	const string server = "xonlinetest";
		public static string RegDBIP;
		
		public void UpdateSrvDescription(int ServerID,string Description)
		{
			regData.UpdateSrvDescription(ServerID,Description);
		}

		public void ReNameBuild(int IterationID,string NewBuildNO,int NewIterationNO,string NewDescription)
		{
			regData.ReNameBuild(IterationID,NewBuildNO,NewIterationNO,NewDescription);
		}

		public void DeleteBuild(int IterationID)
		{
			regData.DeleteBuild(IterationID);
		}

		public void UpdateIterationDescription(int IterationID,string Description)
		{
			regData.UpdateIterationDescription(IterationID,Description);
		}

		
		public RegDBQueryManager(string regDb)
		{
			RegDBIP = regDb;
			regData = new RegDb();
		}
		public RegDBQueryManager()
		{
			regData = new RegDb();
		}

		public ServerList GetServerList()
		{
				return regData.GetServerList();
		}
		public BuildList GetBuildList()
		{
			return regData.GetBuildList();
		}

		public ItemRowList GetItems(RegDBQuery query, ItemRow selected)
		{
			if(selected == null)
			{
				items = new ItemRowList();
				items= regData.GetBuildSummary(query);
			}
			else if(selected.Children==null)
			{
				ItemRow temp;
				for (temp = selected;temp.Parent!=null;temp= temp.Parent);
				int iterationID = temp.ID;
				switch(selected.Depth)
				{
					case 0:
						selected.Children= regData.GetSubCompSummary( iterationID,selected,query);
						break;
					case 1:
						selected.Children= regData.GetTestGroupSummary( iterationID,selected.ID,selected);
						break;
					case 2:
						selected.Children= regData.GetTestCaseSummary( iterationID,selected.ID,selected);
						break;
				}
				
			}
			return items; ///LoadBranch(null, selected, "IterationID = {0}", null, new LoadBranchCallback(LoadComponentBranch));
		}

	}


	public class RegDb
	{
		SqlConnection connection= null;
		
		int pass =1;
		//int fail=4;
		ItemRow parent;
		public RegDb()
		{
            connection = RegDB.OpenSQLConnection();			
		}

		public ItemRowList GetBuildSummary(RegDBQuery query)
		{
			parent=null;
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			try
			{
				sqlCmd = new SqlCommand("sp_BuildsSummary",connection);

				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;
				sqlCmd.Parameters.Add(ret);

				if(query !=null && query.GetServerCount()>0)
				{
					for(int i=0 ; i<query.GetServerCount();i++)
					{
						string param= "@SID"+(1+i);
						sqlCmd.Parameters.Add(param,SqlDbType.Int).Value=query.GetServerAT(i);
					}
				}

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string name = sqlReader.GetString(1)+"("+sqlReader.GetInt32(2)+")";
					string Description = null;
					if (!sqlReader.IsDBNull(5))
						Description = sqlReader.GetString(5);
					
					AddBuildFailItem(sqlReader.GetInt32(0),name,sqlReader.GetInt32(3),sqlReader.GetInt32(4),dataRowsList,0,Description,sqlReader.GetDateTime(6));
				}
			}
			catch(Exception)
			{
				throw;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}

			return  dataRowsList;
		}
		
		public ItemRowList GetSubCompSummary(int IterationID,ItemRow Parent,RegDBQuery query)
		{
			parent=Parent;
			Debug.Assert(parent.Parent ==null);
			
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			
			try
			{
				sqlCmd = new SqlCommand("sp_SubComponentStatForBuild",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				
				if(query !=null && query.GetServerCount()>0)
				{
					for(int i=0 ; i<query.GetServerCount();i++)
					{
						string param= "@SID"+(1+i);
						sqlCmd.Parameters.Add(param,SqlDbType.Int).Value=query.GetServerAT(i);
					}
				}
			

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					AddSubCompItem(sqlReader.GetInt32(0),sqlReader.GetString(1),sqlReader.GetInt32(2),sqlReader.GetInt32(3),dataRowsList,1);
					
				}

			}
			catch(Exception)
			{
				throw;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			return  dataRowsList;
		}
		public ItemRowList GetTestGroupSummary(int IterationID,int SubCompID,ItemRow Parent)
		{
			parent=Parent;
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			
			try
			{
				sqlCmd = new SqlCommand("sp_TestGroupStatForBuild",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				sqlCmd.Parameters.Add("@SubCompID",SqlDbType.Int).Value=SubCompID;

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					if(sqlReader.GetInt32(2)== pass)
						AddPassItem(sqlReader.GetInt32(0),sqlReader.GetString(1),sqlReader.GetInt32(3),dataRowsList,2);
					else
						AddFailItem(sqlReader.GetInt32(0),sqlReader.GetString(1),sqlReader.GetInt32(3),dataRowsList,2);

				}

			}
			catch(Exception)
			{
				throw ;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			return  dataRowsList;
		}
		public ItemRowList GetTestCaseSummary(int IterationID,int TestGroupID,ItemRow Parent)
		{
			parent=Parent;
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			
			try
			{
				sqlCmd = new SqlCommand("sp_TestCaseStatForBuild",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				sqlCmd.Parameters.Add("@TestGroupID",SqlDbType.Int).Value=TestGroupID;

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string result=null;
					
					if (!sqlReader.IsDBNull(3))
						result =sqlReader.GetString(3);
					
					if(sqlReader.GetInt32(2)== pass)
						AddTestCasePassItem(sqlReader.GetInt32(0),sqlReader.GetString(1),1,dataRowsList,3,result,0);
					else
						AddTestCaseFailItem(sqlReader.GetInt32(0),sqlReader.GetString(1),1,dataRowsList,3,result,0);

				}

			}
			catch(Exception )
			{
				throw ;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			return  dataRowsList;
		}
		

		public ServerList GetServerList()
		{
			ServerList SrvList = new ServerList();
			
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			try
			{
				sqlCmd = new SqlCommand("Select * from SubComponent",connection);
				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string Description=null;
					if (!sqlReader.IsDBNull(1))
						Description =sqlReader.GetString(1);

					SrvList.Add(new Server(sqlReader.GetString(2), sqlReader.GetInt32(0),Description));	
				}

			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			
			return SrvList;
		}

		public BuildList GetBuildList()
		{
			BuildList bldList = new BuildList();
			
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			try
			{
				sqlCmd = new SqlCommand("Select * from Iteration",connection);
				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string Description=null;
					if (!sqlReader.IsDBNull(4))
						Description =sqlReader.GetString(4);

					bldList.Add(new Build(sqlReader.GetString(1)+"("+sqlReader.GetSqlInt32(2)+")", sqlReader.GetInt32(0),Description));	
				}
			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			
			return bldList;

		}

		
		public void ReNameBuild(int IterationID,string NewBuildNO,int NewIterationNO,string NewDescription)
		{
			SqlCommand sqlCmd= null;
									
			try
			{
				sqlCmd = new SqlCommand("sp_BuildRename",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@ItnIDToRename",SqlDbType.Int).Value=IterationID;
				sqlCmd.Parameters.Add("@BuildNew",SqlDbType.Char).Value=NewBuildNO;
				sqlCmd.Parameters.Add("@ItnoNew",SqlDbType.Int).Value=NewIterationNO;
				sqlCmd.Parameters.Add("@BuildDescription",SqlDbType.Char).Value=NewDescription;
				
				
				int rowsaffected =sqlCmd.ExecuteNonQuery();
				if(rowsaffected <=0)
					throw new Exception("Update failed to rename build");
				

			}
			catch(Exception)
			{
				throw;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
		}

		public void UpdateSrvDescription(int ServerID,string Description)
		{
						
			SqlCommand sqlCmd= null;
			
			try
			{
				string Query = "update [SubComponent] Set [SubCompDescription]='"+Description+"' where [SubCompID]="+ServerID;
				sqlCmd = new SqlCommand(Query,connection);
				int RowsAffected =sqlCmd.ExecuteNonQuery();

				if(RowsAffected !=1)
					throw new Exception("Update failed" );

				

			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
			

		}

		public void DeleteBuild(int IterationID)
		{
			SqlCommand sqlCmd= null;
					
			try
			{
				sqlCmd = new SqlCommand("sp_DeleteIteration",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				

				sqlCmd.ExecuteNonQuery();
				

			}
			catch(Exception )
			{
				throw ;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
		}

		public void UpdateIterationDescription(int IterationID,string Description)
		{
						
			SqlCommand sqlCmd= null;
			
			try
			{
				string Query = "update [Iteration] Set [Description]='"+Description+"' where [IterationID]="+IterationID;
				sqlCmd = new SqlCommand(Query,connection);
				int RowsAffected =sqlCmd.ExecuteNonQuery();

				

			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
			

		}

		protected void AddSubCompItem(int ID , string Name, int Passcount,int FailCount,ItemRowList dataRowsList,int Depth)
		{
			ItemRow temp= new ItemRow();
			temp.ID=ID;
			temp.Name=Name;
			temp.Pass=Passcount;
			temp.Fail=FailCount;
			temp.Parent=parent;
			temp.Depth=Depth;
			dataRowsList.Add(temp);
		}
		protected void AddPassItem(int ID , string Name, int count,ItemRowList dataRowsList,int Depth)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Pass=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				ItemRow temp= new ItemRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Pass=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				dataRowsList.Add(temp);
			}
		}
								
		protected void AddFailItem(int ID , string Name, int count,ItemRowList dataRowsList, int Depth)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Fail=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				ItemRow temp= new ItemRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Fail=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				dataRowsList.Add(temp);
			}
		}


		protected void AddBuildFailItem(int ID , string Name, int PassCount,int FailCount,ItemRowList dataRowsList,int Depth,string Description,DateTime Date)
		{
			IterationRow temp= new IterationRow();
			temp.ID=ID;
			temp.Name=Name;
			temp.Pass=PassCount;
			temp.Fail=FailCount;
			temp.Parent=parent;
			temp.Depth=Depth;
			temp.Description=Description;
			temp.StartTime=Date;
			dataRowsList.Add(temp);

		}
		
		protected void AddTestCasePassItem(int ID , string Name, int count,ItemRowList dataRowsList,int Depth,string ResultDetails,int BugID)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Pass=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				TestCaseRow temp= new TestCaseRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Pass=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				temp.ResultDetails=ResultDetails;
				temp.BugID=BugID;
				dataRowsList.Add(temp);
			}
		}
								
		protected void AddTestCaseFailItem(int ID , string Name, int count,ItemRowList dataRowsList, int Depth, string ResultDetails,int BugID)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Fail=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				TestCaseRow temp= new TestCaseRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Fail=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				temp.ResultDetails=ResultDetails;
				temp.BugID=BugID;
				dataRowsList.Add(temp);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\Server.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;


namespace STFRunner.Service
{
	/// <summary>
	/// Server encapsulation to issue commands over a socket to a runner on a remote machine
	/// </summary>
	public class Server
	{
		static ServerTestFramework.Report ro = new ServerTestFramework.Report("Server");

		Listener listener;
		ArrayList clients;
		ManualResetEvent killServer;
		DateTime startTime;
		ServerScheduler scheduler;
		Hashtable commands;

		public static void Run()
		{
			Server server = new Server();
			server.Startup();
			server.WaitTillFinished();
		}

		public Server()
		{
			killServer = new ManualResetEvent(false);
			listener = new Listener(this);
			clients = new ArrayList(16);
			commands = new Hashtable(16);
			startTime = DateTime.Now;

			// add builtin commands
			EnableCommands(this);
		}
		
		public Client FindClient(string clientIP)
		{
			IPAddress addr = IPAddress.Parse(clientIP);
			foreach(Client c in clients) 
			{
				if(c.MatchesAddress(addr))
				{
					return c;
				}
			}
			return null;
		}


	#region Built-in commands
		[ServerCommandAttribute("help", "Show descriptions about all of the currently available commands")]
		public void Help(Client src, string []args)
		{
			foreach(Command cmd in commands.Values)
			{
				src.SendMessage(ClientCode.StatusLine, cmd.command + ": " + cmd.desc);
			}
			src.SendMessage(ClientCode.StatusOkay, "Done");
		}
		[ServerCommandAttribute("exit", "Exit currently connected session")]
		public void Exit(Client src, string []args)
		{
			src.SendMessage(ClientCode.StatusOkay, "Goodbye");
			src.Shutdown();
		}

		[ServerCommandAttribute("killclient", "Kill a connected client")]
		public void KillClient(Client src, string []args)
		{			
			string clientIP;
			CommandHelper.ReadArgument(src, args, 1, out clientIP, "A client IP is required");
			Client c = FindClient(clientIP);
			if(c != null)
			{
				// client will remove itself after it disconnects
				c.Shutdown();
			}
		}
		[ServerCommandAttribute("killserver", "Kill the server and all connected clients")]
		public void KillServer(Client src, string []args)
		{
			listener.Shutdown();
		}

		[ServerCommandAttribute("showclients", "Show all clients that are connected to the server")]
		public void ShowClients(Client src, string []args)
		{
			foreach(Client c in clients)
			{
				src.SendMessage(ClientCode.StatusLine, c.ToString());
			}
			src.SendMessage(ClientCode.StatusOkay, "Done");
		}
		[ServerCommandAttribute("showclient", "Show detailed information on a single client")]
		public void ShowClient(Client src, string []args)
		{
			string clientIP;
			Client c;

			if(args.Length > 1) 
			{
				CommandHelper.ReadArgument(src, args, 1, out clientIP, "A client IP is required");
				c = FindClient(clientIP);
			}
			else
				c = src;

			if(c != null) 
				src.SendMessage(ClientCode.StatusOkay, c.ToString());
		}
		[ServerCommandAttribute("uptime", "Show server uptime")]
		public void ShowUptime(Client src, string []args)
		{
			src.SendMessage(ClientCode.StatusOkay, (DateTime.Now - startTime).ToString());
		}
		[ServerCommandAttribute("runfunc", "Run functional tests")]
		public void RunFunctional(Client src, string []args)
		{
			scheduler = new ServerScheduler();
			//scheduler.Config.Merge(src.GenerateTestConfig(), "/stf");
			//scheduler.Client = src;
			scheduler.Initialize(src.config, src.suites, null, null);
			scheduler.Run();
			src.SendMessage(ClientCode.StatusOkay, "Finished");
		}
		[ServerCommandAttribute("list", "List path elements at current context")]
		public void List(Client src, string []args)
		{
			src.context.List();
		}
		[ServerCommandAttribute("context", "Change path of current context")]
		public void ChangeContextPath(Client src, string []args)
		{
			string path;
			CommandHelper.ReadArgument(src, args, 1, out path, "Path required");
			src.context.ChangePath(path);
		}
		[ServerCommandAttribute("enable", "Enable the current context or path if supplied")]
		public void Enable(Client src, string []args)
		{
			string path = "...";
			if(args.Length > 1)
			{
				CommandHelper.ReadArgument(src, args, 1, out path, "Path required");		
			}
		
			src.context.Enable(path);
		}

		[ServerCommandAttribute("disable", "Disable the current context or path if supplied")]
		public void Disable(Client src, string []args)
		{
			string path = "...";
			if(args.Length > 1)
			{
				CommandHelper.ReadArgument(src, args, 1, out path, "Path required");		
			}
		
			src.context.Disable(path);
		}


		[ServerCommandAttribute("cwd", "Show current working directory of server")]
		public void Cd(Client src, string []args)
		{
			src.SendMessage(ClientCode.StatusOkay, Directory.GetCurrentDirectory());
		}
		[ServerCommandAttribute("load", "Load a test suite")]
		public void LoadSuite(Client src, string []args)
		{
		}
		[ServerCommandAttribute("unload", "UnLoad a test suite")]
		public void UnloadSuite(Client src, string []args)
		{
		}
		#endregion

		public void EnableCommands(Object o)
		{
			foreach (MethodInfo method in o.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
			{
				foreach(Object attr in method.GetCustomAttributes(typeof(ServerCommandAttribute), false))
				{
					ServerCommandAttribute serverCommand = (ServerCommandAttribute)attr;
					string commandName = serverCommand.name.ToLower();

					ro.Debug("Server: Enabling command: " + commandName + ", desc: " + serverCommand.description);
					
					Command commandObj = new Command(o, method, commandName, serverCommand.description);
					commands[commandName] = commandObj;
				}
			}
		}	
		
		public void ProcessCommand(Client client, string commandLine)
		{
			ro.Debug("Server.ProcessCommand(): " + commandLine);
			try
			{
				CommandTokenizer tok = new CommandTokenizer(commandLine);
				if(tok.args == null || tok.args.Length == 0)
				{
					throw new Exception("A command is required");
				}
			
				string commandName = tok.args[0].ToLower();
				Command command = (Command)commands[commandName];

				if(command == null)
				{
					client.SendMessage(ClientCode.NotFound, "Command not found: " + commandName);
				}
				else
				{
					command.Execute(client, tok.args);
				}
			}
			catch(Exception ex)
			{
				client.SendMessage(ClientCode.GenericError, ex.GetBaseException().Message);
			}
			ro.Debug("Server.ProcessCommand() finished");
		}

		public void WaitTillFinished()
		{
			killServer.WaitOne();
		}

		public void AddClient(Client client)
		{
			clients.Add(client);
			client.context.LoadContext(scheduler);
		}

		public void RemoveClient(Client client)
		{
			if(client != null)
			{
				clients.Remove(client);
				ro.Info("Server: client removed: " + client.ToString());
			}
		}

		public void Startup()
		{
			listener.Go();
		}

		public void Shutdown()
		{
			// shutdown all the clients
			foreach(Client c in clients) 
			{
				c.Shutdown();
			}
			clients.Clear();

			// shutdown the listener
			listener.Shutdown();
		}

		
		// The command helper aids in command methods reading their arguments out
		// of the argument vector and throwing the appropriate exception when
		// an argument is not found
		public class CommandHelper
		{
			public static void ReadArgument(Client src, string []args, int index, out string val, string error)
			{
				if(index >= args.Length)
				{
					throw new Exception("Parameter " + index + " not supplied: " + error);
				}

				val = args[index];
			}
		}

		public class ServerCommandAttribute : Attribute
		{
			public string name;
			public string description;

			public ServerCommandAttribute(string _name, string _description)
			{
				name = _name;
				description = _description;
			}
		}
		
		// A command encapsulates the name and description that a method should
		// be linked to on the server for invokation.
		public class Command
		{
			public string command;
			public string desc;
			object instance;
			MethodInfo method;

			public Command(object _instance, MethodInfo _method, string _command, string _desc)
			{
				instance = _instance;
				method = _method;
				command = _command;
				desc = _desc;
			}
			
			public void Execute(Client src, string []args)
			{
				method.Invoke(instance, new Object[] {src, args});
			}
		}

		
		public class CommandTokenizer
		{
			public string []args;

			public CommandTokenizer(String commandLine)
			{
				ArrayList toks = new ArrayList();
				

				int i, l, c;
				for(i = 0, l = 0, c = commandLine.Length; i < c; i++)
				{
					if(Char.IsWhiteSpace(commandLine, i))
					{
						toks.Add(commandLine.Substring(l, i-l));

						// skip additional whitespace
						while(Char.IsWhiteSpace(commandLine, i))
							i++;

						l = i; 
					}
				}

				if(i > l)
				{
					toks.Add(commandLine.Substring(l, i-l));
				}

				args = new string[toks.Count];
				toks.CopyTo(args);
			}
		};
		
		public class ClientStream : Stream
		{
			public Client client;
			public override long Position
			{
				get
				{
					return 0;
				}
				set
				{
				}
			}
			public override long Length
			{
				get
				{
					return 0;
				}
			}
			public override bool CanRead
			{
				get
				{
					return false;
				}
			}
			public override bool CanSeek
			{
				get
				{
					return false;
				}
			}
			public override bool CanWrite
			{
				get
				{
					return true;
				}
			}

			public ClientStream(Client cl)
			{
				client = cl;
			}

			public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
			{
				return client.socket.BeginReceive(buffer, offset, count, SocketFlags.None, callback, state);
			}
			public override int EndRead(IAsyncResult result)
			{
				return client.socket.EndReceive(result);
			}
			public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
			{
				return client.socket.BeginSend(buffer, offset, count, SocketFlags.None, callback, state);
			}
			public override void EndWrite(IAsyncResult asyncResult)
			{
				client.socket.EndSend(asyncResult);
			}

			public override int Read(byte[] buffer, int offset, int count)
			{
				return client.socket.Receive(buffer, offset, count, SocketFlags.None);
			}

			public override void Write(byte[] buffer, int offset, int count)
			{								
				client.socket.Send(buffer, offset, count, SocketFlags.None);
			}
			public override int ReadByte()
			{
				return base.ReadByte ();
			}
			public override void Flush()
			{

			}

			public override long Seek(long offset, SeekOrigin origin)
			{
				return 0;
			}
			public override void SetLength(long value)
			{

			}


		}

		public abstract class SocketWorker : ThreadBase
		{
			public Socket socket;
			protected ManualResetEvent shutdownEvent;

			public SocketWorker()
			{
				shutdownEvent = new ManualResetEvent(false);
			}
			
			public bool MatchesAddress(IPAddress address)
			{
				IPEndPoint remoteEP = (IPEndPoint)socket.RemoteEndPoint;
				return remoteEP.Address.Equals(address);
			}

			// this routine cleanly closes down a socket by making sure
			// to stop any additional buffers from being sent
			public void CleanClose()
			{
				// stop outgoing data, should send a fin
				if(socket.Connected)
				{
					socket.Shutdown(SocketShutdown.Send);

					// read any remaining data on the socket
					byte []tmpdata = new byte[256];
					while(socket.Receive(tmpdata, 0, tmpdata.Length, SocketFlags.None) > 0)
						; // loop till done
				
					// close down and de-allocate socket
					socket.Close();
				}
			}
			
			// perform any setup that is required to create 
			// the socket if it has not been created already
			public abstract bool Setup();

			// cleanup any specific resources
			public abstract void Cleanup();
		
			// start working on some task, needs to return the async
			// result object from the overlapped IO call
			public abstract IAsyncResult StartWork();

			protected override void ThreadBody()
			{
				if(!Setup())
				{
					throw new Exception("Setup() failed");
				}

				if(socket == null)
				{
					throw new Exception("Setup() did not create a socket");
				}
			
				// put the shutdown event into the unsignaled state
				shutdownEvent.Reset();
			
				WaitHandle []handles = new WaitHandle[2];
				handles[0] = shutdownEvent;
				
				while(true)
				{
					handles[1] = StartWork().AsyncWaitHandle;
					if(WaitHandle.WaitAny(handles) == 0)
					{
						// shutdown event was set
						break;
					}
				}

				Cleanup();
				CleanClose();
			}

			public void Shutdown()
			{
				// tell handler loop to shutdown
				shutdownEvent.Set();
			}
		}
		
		public class PathExprTokenizer 
		{
			public enum TokenType
			{
				None,
				Root,
				Enter,
				Leave,
				Glob,
				Subtree
			}

			public class Token
			{
				public string val;
				public int pos;
				public TokenType type;

				public Token(string _val, int _pos, TokenType _type)
				{
					val = _val;
					pos = _pos;
					type = _type;
				}
			}

			ArrayList tokens;
			int iterator;

			public PathExprTokenizer()
			{
				Initialize();
			}

			public PathExprTokenizer(string pathExpr)
			{
				Initialize();
				Parse(pathExpr);
			}
		
			protected void Initialize()
			{
				tokens = new ArrayList(16);
			}

			public void Parse(string pathExpr)
			{
				int i = 0; 
				int l = i;
				pathExpr += "\b";
				int count = pathExpr.Length;
				StringBuilder buffer = new StringBuilder(64);
				tokens.Clear();
			
				// add a special terminating character
				

				for(; i < count; ++i)
				{
					char ch = pathExpr[i];
					switch(ch)
					{
						case '\b':
						case '/':
							if(buffer.Length == 0)
							{
								if(tokens.Count == 0) // first token
								{
									tokens.Add(new Token("/", i, TokenType.Root));
									buffer.Remove(0, buffer.Length);
								}
								else
								{
									buffer.Append(ch);
								}
							}
							else
							{
								string val = buffer.ToString();
								if(val == ".")
								{
									// do nothing
								}
								else if(val == "..")
								{
									tokens.Add(new Token(val, i-1, TokenType.Leave));
								}
								else if(val == "...")
								{
									tokens.Add(new Token(val, i-2, TokenType.Subtree));
								}
								else
								{
									tokens.Add(new Token(val, i - buffer.Length, TokenType.Enter));
								}
								buffer.Remove(0, buffer.Length);
							}
							break;
						case '*':
							tokens.Add(new Token("*", i, TokenType.Glob));
							buffer.Remove(0, buffer.Length);
							break;
						default:
							buffer.Append(ch);		
							break;
					}
				}
			}

			public bool HasMoreTokens()
			{
				return iterator < tokens.Count;
			}
			public Token NextToken()
			{
				return (Token)tokens[iterator++];
			}
		}
		
		public class PathElement
		{
			public PathElement parent;
			public object element;
			public int level;
			public bool enabled;
			public string name;
			public ArrayList children;

			public PathElement(object _element, string _name)
			{
				element = _element;
				name = _name;
			}
			public PathElement(PathElement _parent, object _element, string _name)
			{
				_parent.AppendChild(this);
				element = _element;
				name = _name;
			}

			public bool HasParent()
			{
				return parent != null;
			}

			public bool HasChildren()
			{
				return children != null && children.Count > 0;
			}
			
			public PathElement GetChildNamed(string name)
			{
				if(children != null)
				{
					foreach(PathElement el in children) 
					{
						if(el.name == name) 
							return el;
					}
				}

				return null;
			}

			public void AppendChild(PathElement child)
			{
				if(child != null)
				{
					if(child.HasParent()) 
						child.parent.RemoveChild(child);
					if(children == null)
						children = new ArrayList();
					children.Add(child);
					child.parent = this;
				}
			}

			public void RemoveChild(PathElement child)
			{
				if(child != null)
					children.Remove(child);
			}

			public override string ToString()
			{
				StringBuilder builder = new StringBuilder(128);
				BuildPathString(builder);
				if(element == null) 
					return builder.ToString();
				else
					return builder.ToString() + " [" + element.GetType().BaseType.ToString() + "]";
			}
			public void BuildPathString(StringBuilder builder)
			{
				if(parent != null) 
				{
					parent.BuildPathString(builder);
					builder.Append(name);
					builder.Append("/");
				}
				else
				{
					builder.Append(name);
				}
			}
		}

		public enum ClientCode
		{
			StatusOkay = 200,
			StatusLine = 201,
			GenericError = 400,
			Busy = 401,
			NotFound = 404,
			ParseError = 405
		}

		public enum ClientState
		{
			Ready,
			Running,
			Disconnecting
		}

		public enum ClientContextLevel
		{
			TestRoot = 0, 
			TestSuite,
			TestGroup,
			TestCase
		}

		public class ClientContext 
		{
			Client client;
			PathElement currentPath;
			PathElement root;

			public ClientContext(Client _client)
			{
				client = _client;
				root = new PathElement(null, "/");
				currentPath = root;
			}
			
			public void LoadContext(ServerScheduler scheduler)
			{
				PathElement parent = root;
				PathElement el;

				foreach(TestSuite suite in client.suites.GetLoadedSuites())
				{
					el = new PathElement(parent, suite, suite.Name);
					parent = el;

					foreach(TestBaseGroup group in suite.GetTestsWithPreservation())
					{
						el = new PathElement(parent, group, group.Name);
						parent = el;

						foreach(TestBase test in group)
						{
							el = new PathElement(parent, test, test.Name);
						}
						parent = parent.parent;
					}
					parent = parent.parent;
				}
			}

			public void ChangePath(string pathExpr)
			{
				PathExprTokenizer pathtok = new PathExprTokenizer(pathExpr);

				while(pathtok.HasMoreTokens())
				{
					PathExprTokenizer.Token token = pathtok.NextToken();
					switch(token.type)
					{
						case PathExprTokenizer.TokenType.Root:
							currentPath = root;
							break;
						case PathExprTokenizer.TokenType.Leave:
							if(currentPath != root)
								currentPath = currentPath.parent;
							break;
						case PathExprTokenizer.TokenType.Enter:
							{
								PathElement el = currentPath.GetChildNamed(token.val);
								if(el != null)
									currentPath = el;
							}
							break;
						default:
							client.SendMessage(ClientCode.ParseError, "Path token not valid for ChangePath at:" + token.pos);
							break;
					}
				}
				client.SendMessage(ClientCode.StatusOkay, "Context: " + currentPath.ToString());
			}

			public void Select(string pathExpr, out ArrayList elements)
			{
				PathElement current = currentPath;
				PathExprTokenizer pathtok = new PathExprTokenizer(pathExpr);
				elements = new ArrayList();

				while(pathtok.HasMoreTokens())
				{
					PathExprTokenizer.Token token = pathtok.NextToken();
					switch(token.type)
					{
						case PathExprTokenizer.TokenType.Root:
							current = root;
							break;
						case PathExprTokenizer.TokenType.Leave:
							if(current != root)
								current = current.parent;
							break;
						case PathExprTokenizer.TokenType.Enter:
							if(current.HasChildren())
							{
								PathElement el = current.GetChildNamed(token.val);
								if(el != null)
									current = el;

								if(el != null && !pathtok.HasMoreTokens())
								{
									elements.Add(el);
								}
							}
							break;
						case PathExprTokenizer.TokenType.Glob:
							if(current.HasChildren())
							{
								foreach(PathElement el in currentPath.children)
								{
									elements.Add(el);
								}
							}
							break;
						case PathExprTokenizer.TokenType.Subtree:
							if(!pathtok.HasMoreTokens())
							{
								Stack visit = new Stack();
								visit.Push(current);

								while(visit.Count > 0)
								{
									// pop next item off the visit stack
									PathElement el = (PathElement)visit.Pop();
									if(el.HasChildren())
									{
										// push any of it's children
										foreach(PathElement child in el.children)
										{
											visit.Push(child);
										}
									}
									
									// add current item to the selection list
									elements.Add(el);
								}
								
								visit = null;
							}
							else
							{
								client.SendMessage(ClientCode.ParseError, "Subtree path tokens must be the last item in the path expression");
							}
							break;
						default:
							client.SendMessage(ClientCode.ParseError, "Path token not valid for ChangePath at:" + token.pos);
							break;
					}
				}
			}

			public void Enable(string path)
			{
				PathExprTokenizer pathtok = new PathExprTokenizer(path);
				ArrayList elements;

				Select(path, out elements);
				foreach(PathElement el in elements)
				{
					client.SendMessage(ClientCode.StatusLine, "Enabled: " + el.ToString());
					el.enabled = true;
				}
				client.SendMessage(ClientCode.StatusOkay, "Done");
			}

			public void Disable(string path)
			{
				PathExprTokenizer pathtok = new PathExprTokenizer(path);
				ArrayList elements;

				Select(path, out elements);
				foreach(PathElement el in elements)
				{
					client.SendMessage(ClientCode.StatusLine, "Disabled: " + el.ToString());
					el.enabled = true;
				}
				client.SendMessage(ClientCode.StatusOkay, "Done");
			}

			public void List()
			{
				if(!currentPath.HasChildren())
				{
					client.SendMessage(ClientCode.StatusOkay, "No children");
				}
				foreach(PathElement el in currentPath.children)
				{
					client.SendMessage(ClientCode.StatusLine, el.ToString());
				}
				client.SendMessage(ClientCode.StatusOkay, "Done");
			}

			public void GenerateTestConfig(XmlDocument doc, XmlNode node, PathElement el)
			{
				if(el.element != null)
				{
					Type type = el.element.GetType();
					XmlElement xel = null;
					
					if(type.IsSubclassOf(typeof(TestSuite)))
					{
						xel = doc.CreateElement("suite");
						xel.SetAttribute("name", el.name);
						node.AppendChild(xel);
						node = xel;

						xel = doc.CreateElement("functional");
					}
					else if(type.IsSubclassOf(typeof(TestBaseGroup)))
					{
						xel = doc.CreateElement("group");
						xel.SetAttribute("name", el.name);
					}
					else if(type.IsSubclassOf(typeof(TestBase)))
					{
						xel = doc.CreateElement("test");
						xel.SetAttribute("name", el.name);
					}

					if(xel != null)
					{
						node.AppendChild(xel);
						node = xel;
					}
				}
				if(el.HasChildren())
				{
					foreach(PathElement child in el.children)
					{
						GenerateTestConfig(doc, node, child);
					}
				}
			}

			public void GenerateTestConfig(XmlDocument doc, XmlNode node)
			{
				GenerateTestConfig(doc, node, root);
			}

		}

		//
		// The client class encapsulates a single client 
		//
		public class Client : SocketWorker, TestEventListener
		{
			public class Buffer 
			{
				public const int MaxSize = 1024;
				public byte []data;
				
				public Buffer()
				{
					data = new byte[MaxSize];
				}
				public Buffer(string stringData)
				{
					data = Encoding.ASCII.GetBytes(stringData);
				}
			}

			Server server;
			StringBuilder builder;
			Buffer buffer;
			ClientState state;
			public StfXmlDoc config;
			public TestSuiteContainer suites;
			public ClientContext context;
			public StreamWriter stream;
			bool debug = false;
			int totalRead, totalWrite; // stats

			public Client(Server _server, Socket _socket)
			{
				server = _server;
				socket = _socket;
				builder = new StringBuilder(Buffer.MaxSize);
				buffer = new Buffer();
				state = ClientState.Ready;
				context = new ClientContext(this);
				stream = new StreamWriter(new ClientStream(this));
			}

			public void OnTestEvent(TestEventArgs e)
			{
			}
			
			public void SendMessage(ClientCode code, string data)
			{
				Buffer sendBuf = new Buffer(((int)code).ToString() + " " + data + "\r\n");
				socket.BeginSend(sendBuf.data, 0, sendBuf.data.Length, SocketFlags.None, new AsyncCallback(AsyncWriteCallback), sendBuf);
				
				if(debug)
					ro.Info("Client: SendMessage: " + sendBuf.data.Length + " bytes");
			}

			public override bool Setup()
			{
				// make the client socket non-blocking
				socket.Blocking = false;

				// send the client a hello, do any validation that may be required
				SendMessage(ClientCode.StatusOkay, "Hello, welcome to STF runner");

				return true;
			}
			
			public override string ToString()
			{
				return	("Local: " + socket.LocalEndPoint.ToString() + 
						", Remote: " + socket.RemoteEndPoint.ToString() +
						", State: " + state.ToString() + 
						", Read/Write: " + totalRead + "/" + totalWrite);
			}

			public void AsyncReadCallback(IAsyncResult result)
			{
				
			
				int n = socket.EndReceive(result);
				totalRead += n;

				if(debug)
					ro.Info("Client: read completed: " + n + " bytes");


				if(n == 0)
				{
					Shutdown();
				}

				// read data off the socket and send the command to the server
				// object
				byte []data = ((Buffer)result.AsyncState).data;
				
				for(int i = 0; i < n; ++i)
				{
					char c = (char)data[i];
					
					switch(c)
					{
						case '\r':
						case '\n':
							if(builder.Length  > 1)
							{
								ProcessCommand();

								// reset the string builder
								builder.Remove(0, builder.Length);
							}
							break;
						default:
							builder.Append((char)data[i]);
							break;
					}
				}				
			}

			public void AsyncWriteCallback(IAsyncResult result)
			{
				int n = socket.EndSend(result);
				totalWrite += n;

				if(debug)
					ro.Info("Client: write completed: " + n + " bytes");
			}

			public override IAsyncResult StartWork()
			{
				if(debug)
					ro.Info("Client: Start work");

				return socket.BeginReceive(buffer.data, 0, Buffer.MaxSize, SocketFlags.None, new AsyncCallback(AsyncReadCallback), buffer);
			}

			public override void Cleanup() 
			{
				// send disconnect message

				// remove from client list
				server.RemoveClient(this);
			}
			
			public void ProcessCommand()
			{
				string command = builder.ToString();				
				server.ProcessCommand(this, command);
			}

			public XmlDocument GenerateTestConfig()
			{
				XmlDocument doc=new XmlDocument();
			
				XmlElement stfNode=doc.CreateElement("stf");
				doc.AppendChild(stfNode);

				XmlElement testsNode=doc.CreateElement("tests");
				stfNode.AppendChild(testsNode);

				context.GenerateTestConfig(doc, testsNode);

				return doc;
			}
		}

		public class Listener : SocketWorker
		{
			public class ClientAccept
			{
				public Socket socket;
				public Server server;
			}

			Server server;
			bool configured;

			public Listener(Server _server)
			{
				configured = false;
				server = _server;
			}
			
			public override bool Setup()
			{
				return Setup(RunnerGlobal.DefaultPort);
			}

			public bool Setup(int port)
			{
				if(!configured)
				{
					try 
					{
						Shutdown();

						IPHostEntry hostinfo = Dns.GetHostEntry(Dns.GetHostName());
						IPAddress addr = hostinfo.AddressList[0];
						IPEndPoint endpoint = new IPEndPoint(IPAddress.Any, port);

						// Create a TCP/IP socket.
						socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp );
			
						socket.Bind(endpoint);
						socket.Listen(5);

						configured = true;

						ro.Info("Listener: configured server endpoint: " + endpoint.ToString());
					}
					catch(Exception e)
					{
						ro.Error("Listener: failed to setup the server socket: " + e.ToString());
					}
				}
				else
				{
					ro.Warn("Listener already configured");
				}

				return configured;
			}
			
			public void AsyncAcceptCallback(IAsyncResult result)
			{
				// new client has arrived
				Socket clsock = socket.EndAccept(result);
				Client c = new Client(server, clsock);
				c.Go();

				server.AddClient(c);
				
				ro.Info("Listener: Accepted connection " +
					clsock.LocalEndPoint.ToString() + " -> " +
					clsock.RemoteEndPoint.ToString());
			}

			public override IAsyncResult StartWork()
			{
				return socket.BeginAccept(new AsyncCallback(AsyncAcceptCallback), this);
			}

			public override void Cleanup()
			{
				ro.Info("Listener has been shutdown");
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\TestResultTree.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows.Forms;
using ServerTestFramework.Reporting;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for TestResultTree.
	/// </summary>
	public class TestResultTree : System.Windows.Forms.UserControl
	{
		private ItemRow lastSelected;

		private System.Windows.Forms.PictureBox pictureBox1;
		private ControlTree controlTree1;
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public TestResultTree()
		{
			// This call is required by the Windows.Forms Form Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call

		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.pictureBox1 = new System.Windows.Forms.PictureBox();
			this.controlTree1 = new RegDBViewer.ControlTree();
			this.SuspendLayout();
			// 
			// pictureBox1
			// 
			this.pictureBox1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Top;
			this.pictureBox1.Location = new System.Drawing.Point(0, 0);
			this.pictureBox1.Name = "pictureBox1";
			this.pictureBox1.Size = new System.Drawing.Size(150, 16);
			this.pictureBox1.TabIndex = 0;
			this.pictureBox1.TabStop = false;
			this.pictureBox1.SizeChanged += new System.EventHandler(this.pictureBox1_SizeChanged);
			this.pictureBox1.Paint += new System.Windows.Forms.PaintEventHandler(this.pictureBox1_Paint);
			// 
			// controlTree1
			// 
			this.controlTree1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.controlTree1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.controlTree1.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
			this.controlTree1.Location = new System.Drawing.Point(0, 16);
			this.controlTree1.Name = "controlTree1";
			this.controlTree1.Size = new System.Drawing.Size(150, 132);
			this.controlTree1.TabIndex = 0;
			this.controlTree1.SelectedIndexChanged += new System.EventHandler(this.controlTree1_SelectedIndexChanged);
			// 
			// TestResultTree
			// 
			this.Controls.Add(this.controlTree1);
			this.Controls.Add(this.pictureBox1);
			this.Name = "TestResultTree";
			this.Load += new System.EventHandler(this.TestResultTree_Load);
			this.ResumeLayout(false);

		}
		#endregion

		private void pictureBox1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			ControlTree.DrawAnItem(new DrawItemEventArgs(e.Graphics, controlTree1.Font, pictureBox1.ClientRectangle, -1, DrawItemState.Default, controlTree1.ForeColor, controlTree1.BackColor), null);
		}

		private void pictureBox1_SizeChanged(object sender, System.EventArgs e)
		{
			pictureBox1.Refresh();
		}

		private void TestResultTree_Load(object sender, System.EventArgs e)
		{
			pictureBox1.SizeChanged +=new EventHandler(pictureBox1_SizeChanged);
		}

		public ListBox.ObjectCollection Items {get {return controlTree1.Items;}}

//		public object SelectedItem {get {return controlTree1.SelectedItem;} set {controlTree1.SelectedItem = value;}}
//
		
		private void CloseSubTreeUp(ItemRow item)
		{
			if (item.Parent != null)
			{
				item.Parent.SubTreeOpen = false;
				CloseSubTreeUp(item.Parent);
			}
		}

		private void CloseSubTreeDown(ItemRow item)
		{
			item.SubTreeOpen = false;

			if (item.Children != null)
				foreach (ItemRow ir in item.Children)
					CloseSubTreeDown(ir);
		}

		private void OpenSubTree(ItemRow item)
		{
			item.SubTreeOpen = true;
			if (item.Parent != null)
				OpenSubTree(item.Parent);
		}

		private void controlTree1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			ItemRow item = (ItemRow)controlTree1.SelectedItem;

			if (item == lastSelected)
				return;

			if (lastSelected != null)
			{
				CloseSubTreeUp(lastSelected);
				CloseSubTreeDown(lastSelected);
			}

			lastSelected = item;

			OpenSubTree(item);

			if (item.Total > 1 || item.Depth < 3)
				OnSelectedIndexChanged(this, new SelectedRowChangedEventArgs(item));

			controlTree1.SelectedIndexChanged -= new EventHandler(controlTree1_SelectedIndexChanged);
			controlTree1.SelectedItem = item;
			controlTree1.SelectedIndexChanged += new EventHandler(controlTree1_SelectedIndexChanged);
		}

		public event SelectedRowChangedHandler SelectedIndexChanged;

		public void OnSelectedIndexChanged(object sender, SelectedRowChangedEventArgs e)
		{
			if (SelectedIndexChanged != null)
				SelectedIndexChanged(sender, e);
		}

		public ItemRow LastSelected {get {return lastSelected;} set {lastSelected = value;}}

		new public void SuspendLayout()
		{
			base.SuspendLayout();
			controlTree1.SuspendLayout();
		}

		new public void ResumeLayout()
		{
			base.ResumeLayout();
			controlTree1.ResumeLayout();
		}
	}

	public class SelectedRowChangedEventArgs : EventArgs
	{
		public ItemRow Row;

		public SelectedRowChangedEventArgs(ItemRow row)
		{
			this.Row = row;
		}
	}

	public delegate void SelectedRowChangedHandler(object sender, SelectedRowChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\StressThread.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;

namespace STFRunner
{
    public class StressThread
    {
        private StressSchedulerPriority scheduler;
        private Thread thread = null;
        private bool running = false;
        public bool Running {get {return running;}}
        private DateTime updated = DateTime.Now; // last update time
        public DateTime Updated {get {return updated;}}
        private StressJob currentJob = null;

        public ThreadState ThreadState {get {return thread.ThreadState;}}
        public StressJob CurrentJob {get {return currentJob;}}

        public StressThread(StressSchedulerPriority scheduler)
        {
            this.scheduler = scheduler;
        }

        /// <summary>
        /// Sets the terminate flag, the thread will stop after the current job is complete.
        /// </summary>
        public void SoftTerminate()
        {
            running = false;
        }

        /// <summary>
        /// Kills the thread.
        /// </summary>
        public void Terminate()
        {
            thread.Abort();
        }

        public Thread Start()
        {
            running = true;
            updated = DateTime.Now;

            thread = new Thread(new ThreadStart(StressThreadFunc));
            thread.Start();

            return thread;
        }

        public bool Join()
        {
            // Wait 10 seconds for thread to abort
            return thread.Join(10000);
        }

        virtual protected void StressThreadFunc()
        {
            MinimumTestBase tb = null;
            TEST_RESULTS resultCode;
            float elapsedTime = 0;
            try
            {
                while (Running)
                {
                    try
                    {
                        currentJob = scheduler.PickTest();
                        if (currentJob==null)
                        {
                            System.Threading.Thread.Sleep(100);
                            continue;
                        }

                        tb = currentJob.CreateInstance();

                        elapsedTime = 0;
                        updated = DateTime.Now;
                        try
                        {
                            resultCode = tb.Run();
                        }
                        finally
                        {
                            elapsedTime = (float)((DateTime.Now - updated).TotalSeconds);
                        }

                        // If the test case is using PASSED | FAILED result reporting,
                        // set the composite fields accordingly and pass through to the
                        // composite handler.

                        if (resultCode == TEST_RESULTS.PASSED)
                        {
                            Pass(tb.CasesExecuted);
                        }
                        else if (resultCode == TEST_RESULTS.FAILED)
                        {
                            Fail(null, tb.CasesExecuted);
                        }
                        else if (resultCode == TEST_RESULTS.COMPOSITE)
                        {
                            // This better be derived from StressTestBase
                            StressTestBase tb2 = (StressTestBase)tb;
                            Pass(tb2.CasesPassedComposite);
                            Fail(null, tb2.CasesFailedComposite);
                            tb2.CasesPassedComposite = 0;
                            tb2.CasesFailedComposite = 0;
                        }
                        else if (resultCode == TEST_RESULTS.NOT_EXECUTED)
                        {
                            Skip(tb.CasesExecuted);
                        }

                    }
                    catch (ThreadAbortException)
                    {
                        throw;  // This is to make sure the outer handler catches this instead of the general one below
                    }
                    catch (Exception e)
                    {
                        Fail(e, 1);

                        // When the test fails, we want to pause for a bit, since typically, a failing test
                        // fails very quickly, thus bumping up its TPS and failing even more often. This can
                        // cause the event log to get spammed. 
                        // This assumes non-sporadic failures, such as when Testnet gets rebuilt. For sporadic 
                        // failures where you may not want to pause, catch the exception yourself.
                        System.Threading.Thread.Sleep(1000);  // 1000 ms

                    }
                }
            }
            catch (ThreadAbortException)
            {
                running = false;
            }
        }

        protected void Pass(int count)
        {
            for (int i = 0; i < count; i++)
            {
                currentJob.Results.Pass();
            }
            
            if (currentJob.UseCounters)
            {
                for (int i = 0; i < count; i++)
                {
                    Counters.Increment("STFTests."+currentJob.SuiteName,currentJob.Name);
                }
            }
        }

        protected void Fail(Exception e, int count)
        {
            if (count <= 0)
                return;

            for (int i = 0; i < count; i++)
            {
                currentJob.Results.Fail();
            }

            if (currentJob.UseCounters)
            {
                for (int i = 0; i < count; i++)
                {
                    Counters.Increment("STFTests."+currentJob.SuiteName,currentJob.Name+"Failed");
                }
            }

            bool emptyException = e == null || e.Message == null || e.Message == "";
            string execTime="("+Convert.ToInt32((DateTime.Now-updated).TotalSeconds*1000)+" msecs)";
            if (!emptyException)
            {
                Global.RO.Error("  Test " + currentJob.Name + " failed (" + count + ") "+execTime+" - " + e.GetType().Name + ": " + e.Message);
                if (scheduler.ShowDetailedExceptions)
                    Global.RO.Error("  " + e.ToString().Replace("\n", "\n  "));
            }
            else
            {
                Global.RO.Error("  Test " + currentJob.Name + " failed (" + count + ") "+execTime);
            }
        }

        protected void Skip(int count)
        {
            for (int i = 0; i < count; i++)
            {
                currentJob.Results.Skip();
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\WebstoreInstall.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Net;
using System.IO;
using System.ServiceProcess;
using System.Diagnostics;
using System.Xml;

using ServerTestFramework;

namespace STFRunner
{
    public partial class WebstoreInstall : Form
    {
        public WebstoreInstall()
        {
            InitializeComponent();

            // load npdb IP addresses from stf.xml file
            int count = Global.NpdbSettings.Count;
            List<NpdbSetting> npdbs = new List<NpdbSetting>();
            for (int i = 0; i < count; i++)
            {
                if (IsXblob(((NpdbSetting)Global.NpdbSettings[i])))
                    npdbs.Add((NpdbSetting)Global.NpdbSettings[i]);
            }

            // update the IP address text boxes
            int index = 0;
            count = npdbs.Count;
            if (count > index)
            {
                textBox1.Text = npdbs[index].environment;
                textBoxIp1.Text = npdbs[index++].ip;
            }
            if (count > index)
            {
                textBox2.Text = npdbs[index].environment;
                textBoxIp2.Text = npdbs[index++].ip;
            }
            if (count > index)
            {
                textBox3.Text = npdbs[index].environment;
                textBoxIp3.Text = npdbs[index++].ip;
            }
            if (count > index)
            {
                textBox4.Text = npdbs[index].environment;
                textBoxIp4.Text = npdbs[index++].ip;
            }
            if (count > index)
            {
                textBox5.Text = npdbs[index].environment;
                textBoxIp5.Text = npdbs[index++].ip;
            }
        }

        private bool IsXblob(NpdbSetting npdb)
        {
            bool xblob = true;
            string env = npdb.environment;
            if (env.ToLower() == "testnet" || env.ToLower() == "bvtnet" || env.ToLower() == "qfenet" || env.ToLower() == "funcnet"
                || env.ToLower() == "argonet" || env.ToLower() == "stressnet" || env.ToLower() == "upgradenet" || env.ToLower() == "xblob")
            {
                xblob = false;
            }
            else   // check if ip address exits
            {
                try
                {
                    string host = Dns.GetHostEntry(npdb.ip.Trim()).HostName;
                    host = host.Substring(0, host.IndexOf('.'));
                }
                catch
                {
                    xblob = false;
                }
            }
            return xblob;
        }

        private void buttonMsi_Click(object sender, EventArgs e)
        {
            openFileDialogMsi.Filter = "Installation file (*.msi)|*.msi";
            if (openFileDialogMsi.ShowDialog() != DialogResult.OK)
                return;

            textBoxMsi.Text = openFileDialogMsi.FileName;
        }

        private void buttonInstall_Click(object sender, EventArgs e)
        {
            string config = "";
            string host1 = "";
            string host2 = "";
            string host3 = "";
            string host4 = "";
            string host5 = "";
            string userName = textBoxUserName.Text.Trim();
            string password = textBoxPassword.Text.Trim();
            string wstMsi = textBoxMsi.Text.Trim();

            if (string.IsNullOrEmpty(wstMsi) || string.IsNullOrEmpty(userName) || string.IsNullOrEmpty(password))
            {
                MessageBox.Show("To continue, Webstore client msi, user name and password are needed!!!");
                return;
            }

            string webstoreMsi = "WstClientLib.msi";
            if (wstMsi.LastIndexOf(webstoreMsi, StringComparison.CurrentCultureIgnoreCase) < 0 || !File.Exists(wstMsi))
            {
                MessageBox.Show("The Webstore client msi is not right or cannot be found.");
                return;
            }

            int index = 1;
            StringBuilder err = new StringBuilder();
            try
            {
                if (!string.IsNullOrEmpty(textBoxIp1.Text.Trim()))
                {
                    host1 = Dns.GetHostEntry(textBoxIp1.Text.Trim()).HostName;
                    host1 = host1.Substring(0, host1.IndexOf('.'));
                    if (host1.ToLower() != textBox1.Text.Trim().ToLower())
                        err.Append("Xblob #" + index + ": IP address and computer name don't match!\n");
                    config += textBox1.Text.Trim() + '/' + host1 + ';';
                }
                index++;
                if (!string.IsNullOrEmpty(textBoxIp2.Text.Trim()))
                {
                    host2 = Dns.GetHostEntry(textBoxIp2.Text.Trim()).HostName;
                    host2 = host2.Substring(0, host2.IndexOf('.'));
                    if (host2.ToLower() != textBox2.Text.Trim().ToLower())
                        err.Append("Xblob #" + index + ": IP address and computer name don't match!\n");
                    config += textBox2.Text.Trim() + '/' + host2 + ';';
                }
                index++;
                if (!string.IsNullOrEmpty(textBoxIp3.Text.Trim()))
                {
                    host3 = Dns.GetHostEntry(textBoxIp3.Text.Trim()).HostName;
                    host3 = host3.Substring(0, host3.IndexOf('.'));
                    if (host3.ToLower() != textBox3.Text.Trim().ToLower())
                        err.Append("Xblob #" + index + ": IP address and computer name don't match!\n");
                    config += textBox3.Text.Trim() + '/' + host3 + ';';
                }
                index++;
                if (!string.IsNullOrEmpty(textBoxIp4.Text.Trim()))
                {
                    host4 = Dns.GetHostEntry(textBoxIp4.Text.Trim()).HostName;
                    host4 = host4.Substring(0, host4.IndexOf('.'));
                    if (host4.ToLower() != textBox4.Text.Trim().ToLower())
                        err.Append("Xblob #" + index + ": IP address and computer name don't match!\n");
                    config += textBox4.Text.Trim() + '/' + host4 + ';';
                }
                index++;
                if (!string.IsNullOrEmpty(textBoxIp5.Text.Trim()))
                {
                    host5 = Dns.GetHostEntry(textBoxIp5.Text.Trim()).HostName;
                    host5 = host5.Substring(0, host5.IndexOf('.'));
                    if (host5.ToLower() != textBox5.Text.Trim().ToLower())
                        err.Append("Xblob #" + index + ": IP address and computer name don't match!\n");
                    config += textBox5.Text.Trim() + '/' + host5 + ';';
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Xblob #" + index + " IP address error: " + ex.Message);
                return;
            }

            // IP address and computer name don't match
            if (err.Length > 0)
            {
                MessageBox.Show(err + "\nPlease fix your stf xml config file and then re-run this program.");
                return;
            }

            textBoxConfigServers.Text = config;

            if (string.IsNullOrEmpty(textBoxConfigServers.Text.Trim()))
            {
                MessageBox.Show("To continue, at least one Xblob IP address is needed!!!");
                return;
            }

            // prepare the install and uninstall script
            string webstoreFolder = "Microsoft Webstore";
            string webstoreService = "WstService";
            string webstoreExe = webstoreService + ".exe";

            string exePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), webstoreFolder);
            exePath = Path.Combine(exePath, webstoreExe);

            string uninstall = "/passive /norestart /x {E4028626-5939-4FA8-9E0F-E3186295AE77}";
            string install = "/qb /norestart /i \"" + textBoxMsi.Text.Trim() + "\" WSTSERVICEACCT=" 
                + textBoxUserName.Text.Trim() + " WSTSERVICEPWD=" + textBoxPassword.Text.Trim() 
                + " CONFIGSERVERS=\"" + textBoxConfigServers.Text.Trim() + "\" /L*v C:\\Webstore4.i.msi.txt";

            if (File.Exists(exePath))
            {
                // uninstall the existing Webstore
                InstallMsi("msiexec.exe", uninstall);
            }

            // install Webstore
            if (InstallMsi("msiexec.exe", install))
            {
                MessageBox.Show("Webstore Client has been installed successfully.");
                this.Close();
            }
        }

        private bool InstallMsi(string fileName, string arguments)
        {
            ProcessStartInfo psi = new ProcessStartInfo(fileName, arguments);
            psi.RedirectStandardOutput = true;
            psi.RedirectStandardError = true;
            psi.UseShellExecute = false;
            psi.CreateNoWindow = true;

            Process p = new Process();
            p.StartInfo = psi;

            bool installed = true;
            try
            {
                p.Start();
                p.WaitForExit();
                if (p.ExitCode != 0)
                {
                    MessageBox.Show(
                        "MSI install failed with exit code: " + p.ExitCode +
                        "\n Standard Out:\n" + p.StandardOutput.ReadToEnd() +
                        "\n Standard Error:\n" + p.StandardError.ReadToEnd());
                    installed = false;
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(
                    "MSI install failed." +
                    "\n Standard Out:\n" + p.StandardOutput.ReadToEnd() +
                    "\n Standard Error:\n" + p.StandardError.ReadToEnd() +
                    "\n Exception\n" + e);
                installed = false;
            }

            return installed;
        }

        private bool IsServiceInstalled(string serviceName)
        {
            bool installed = false;
            foreach (ServiceController sc in ServiceController.GetServices())
            {
                if (sc.ServiceName == serviceName)
                {
                    installed = true;
                    break;
                }
            }

            return installed;
        }

        private bool IsServiceRunning(string serviceName)
        {
            ServiceController sc = new ServiceController(serviceName);
            bool running = false;
            try
            {
                running = (sc.Status == ServiceControllerStatus.Running);
            }
            catch (InvalidOperationException) { }

            return running;
        }

        private void buttonCancel_Click(object sender, EventArgs e)
        {
            this.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\Status\StatusHandler.cs ===
using System;
using System.Threading;
using ServerTestFramework.Runner;
using STFRunner;

namespace STFRunner.Status
{
    abstract public class StatusHandler
    {
        protected int intervalSeconds = 0;
        protected TestResultCollection results;
        private Timer timer = null;
        private DateTime startTime = DateTime.Now;

        public TimeSpan Elapsed {get {return DateTime.Now - startTime;}}

        public int IntervalSeconds
        {
            get {return intervalSeconds;}
            set
            {
                intervalSeconds = value >= 0 ? value : 0; 
                timer.Change(intervalSeconds * 1000, intervalSeconds * 1000);
            }
        }

        public StatusHandler(TestResultCollection results, int intervalSeconds)
        {
            if (results == null)
                throw new ArgumentException("results must not be null");

            this.results = results;
            this.intervalSeconds = intervalSeconds >= 0 ? intervalSeconds : 0;
        }

        // For use by the Timer
        private void Tick(object state) {Tick();}

        // Override this to do your work
        abstract public void Tick();

        public void Start()
        {
            if (timer != null)
                timer.Dispose();
            timer = new Timer(new TimerCallback(Tick), null, intervalSeconds * 1000, intervalSeconds * 1000);
            startTime = DateTime.Now;
        }

        public void End()
        {
            timer.Dispose();
            timer = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\WebstoreInstall.Designer.cs ===
namespace STFRunner
{
    partial class WebstoreInstall
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(WebstoreInstall));
            this.label1 = new System.Windows.Forms.Label();
            this.textBoxMsi = new System.Windows.Forms.TextBox();
            this.buttonMsi = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.textBoxUserName = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.textBoxPassword = new System.Windows.Forms.TextBox();
            this.label5 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.textBox5 = new System.Windows.Forms.TextBox();
            this.textBox4 = new System.Windows.Forms.TextBox();
            this.textBox3 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label7 = new System.Windows.Forms.Label();
            this.label15 = new System.Windows.Forms.Label();
            this.label14 = new System.Windows.Forms.Label();
            this.label13 = new System.Windows.Forms.Label();
            this.label12 = new System.Windows.Forms.Label();
            this.label10 = new System.Windows.Forms.Label();
            this.textBoxIp5 = new System.Windows.Forms.TextBox();
            this.label9 = new System.Windows.Forms.Label();
            this.textBoxConfigServers = new System.Windows.Forms.TextBox();
            this.textBoxIp4 = new System.Windows.Forms.TextBox();
            this.textBoxIp3 = new System.Windows.Forms.TextBox();
            this.textBoxIp2 = new System.Windows.Forms.TextBox();
            this.textBoxIp1 = new System.Windows.Forms.TextBox();
            this.label11 = new System.Windows.Forms.Label();
            this.buttonInstall = new System.Windows.Forms.Button();
            this.openFileDialogMsi = new System.Windows.Forms.OpenFileDialog();
            this.buttonCancel = new System.Windows.Forms.Button();
            this.groupBox1.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label1.ForeColor = System.Drawing.Color.Red;
            this.label1.Location = new System.Drawing.Point(23, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(584, 60);
            this.label1.TabIndex = 0;
            this.label1.Text = "Only use this install when running tests against Xblob from a Corpnet computer (not Xblob itself). If running tests in Testnet or from Xblob itself, " +
                "please DO NOT install Webstore client from here. Doing so may corrupt existing settings.\r\nPlease make sure your stf config xml file is updated, see http://xblwiki for more details.";
            // 
            // textBoxMsi
            // 
            this.textBoxMsi.Location = new System.Drawing.Point(86, 100);
            this.textBoxMsi.Name = "textBoxMsi";
            this.textBoxMsi.Size = new System.Drawing.Size(483, 20);
            this.textBoxMsi.TabIndex = 1;
            // 
            // buttonMsi
            // 
            this.buttonMsi.Location = new System.Drawing.Point(575, 96);
            this.buttonMsi.Name = "buttonMsi";
            this.buttonMsi.Size = new System.Drawing.Size(32, 23);
            this.buttonMsi.TabIndex = 2;
            this.buttonMsi.Text = "...";
            this.buttonMsi.UseVisualStyleBackColor = true;
            this.buttonMsi.Click += new System.EventHandler(this.buttonMsi_Click);
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(20, 96);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(60, 31);
            this.label2.TabIndex = 3;
            this.label2.Text = "Webstore Client MSI";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(20, 153);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(60, 13);
            this.label3.TabIndex = 5;
            this.label3.Text = "User Name";
            // 
            // textBoxUserName
            // 
            this.textBoxUserName.Location = new System.Drawing.Point(86, 148);
            this.textBoxUserName.Name = "textBoxUserName";
            this.textBoxUserName.Size = new System.Drawing.Size(204, 20);
            this.textBoxUserName.TabIndex = 4;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(20, 199);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(53, 13);
            this.label4.TabIndex = 7;
            this.label4.Text = "Password";
            // 
            // textBoxPassword
            // 
            this.textBoxPassword.Location = new System.Drawing.Point(86, 194);
            this.textBoxPassword.Name = "textBoxPassword";
            this.textBoxPassword.Size = new System.Drawing.Size(204, 20);
            this.textBoxPassword.TabIndex = 6;
            this.textBoxPassword.UseSystemPasswordChar = true;
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(83, 123);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(524, 13);
            this.label5.TabIndex = 8;
            this.label5.Text = "For example: D:\\depot\\public\\ext\\xonline-ext\\webstore\\4.7.0512.0000\\WstClientLib\\" +
                "DISK1\\WstClientLib.msi";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(83, 171);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(136, 13);
            this.label6.TabIndex = 9;
            this.label6.Text = "For example: redmond\\xxxx";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.textBox5);
            this.groupBox1.Controls.Add(this.textBox4);
            this.groupBox1.Controls.Add(this.textBox3);
            this.groupBox1.Controls.Add(this.textBox2);
            this.groupBox1.Controls.Add(this.textBox1);
            this.groupBox1.Controls.Add(this.label7);
            this.groupBox1.Controls.Add(this.label15);
            this.groupBox1.Controls.Add(this.label14);
            this.groupBox1.Controls.Add(this.label13);
            this.groupBox1.Controls.Add(this.label12);
            this.groupBox1.Controls.Add(this.label10);
            this.groupBox1.Controls.Add(this.textBoxIp5);
            this.groupBox1.Controls.Add(this.label9);
            this.groupBox1.Controls.Add(this.textBoxConfigServers);
            this.groupBox1.Controls.Add(this.textBoxIp4);
            this.groupBox1.Controls.Add(this.textBoxIp3);
            this.groupBox1.Controls.Add(this.textBoxIp2);
            this.groupBox1.Controls.Add(this.textBoxIp1);
            this.groupBox1.Location = new System.Drawing.Point(23, 231);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(584, 293);
            this.groupBox1.TabIndex = 10;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Xblob IP Addresses and Names";
            // 
            // textBox5
            // 
            this.textBox5.Location = new System.Drawing.Point(319, 200);
            this.textBox5.Name = "textBox5";
            this.textBox5.ReadOnly = true;
            this.textBox5.Size = new System.Drawing.Size(244, 20);
            this.textBox5.TabIndex = 34;
            // 
            // textBox4
            // 
            this.textBox4.Location = new System.Drawing.Point(319, 170);
            this.textBox4.Name = "textBox4";
            this.textBox4.ReadOnly = true;
            this.textBox4.Size = new System.Drawing.Size(244, 20);
            this.textBox4.TabIndex = 33;
            // 
            // textBox3
            // 
            this.textBox3.Location = new System.Drawing.Point(319, 140);
            this.textBox3.Name = "textBox3";
            this.textBox3.ReadOnly = true;
            this.textBox3.Size = new System.Drawing.Size(244, 20);
            this.textBox3.TabIndex = 32;
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(319, 113);
            this.textBox2.Name = "textBox2";
            this.textBox2.ReadOnly = true;
            this.textBox2.Size = new System.Drawing.Size(244, 20);
            this.textBox2.TabIndex = 31;
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(319, 80);
            this.textBox1.Name = "textBox1";
            this.textBox1.ReadOnly = true;
            this.textBox1.Size = new System.Drawing.Size(244, 20);
            this.textBox1.TabIndex = 30;
            // 
            // label7
            // 
            this.label7.Location = new System.Drawing.Point(23, 29);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(540, 34);
            this.label7.TabIndex = 15;
            this.label7.Text = "The Xblob IP addresses and names are loaded from stf.xml file (or your own stf xml config file). To change any IP address or names, you need to change your stf xml config file and then re-run this program.";
            // 
            // label15
            // 
            this.label15.AutoSize = true;
            this.label15.Location = new System.Drawing.Point(20, 203);
            this.label15.Name = "label15";
            this.label15.Size = new System.Drawing.Size(16, 13);
            this.label15.TabIndex = 29;
            this.label15.Text = "5.";
            // 
            // label14
            // 
            this.label14.AutoSize = true;
            this.label14.Location = new System.Drawing.Point(20, 173);
            this.label14.Name = "label14";
            this.label14.Size = new System.Drawing.Size(16, 13);
            this.label14.TabIndex = 28;
            this.label14.Text = "4.";
            // 
            // label13
            // 
            this.label13.AutoSize = true;
            this.label13.Location = new System.Drawing.Point(20, 143);
            this.label13.Name = "label13";
            this.label13.Size = new System.Drawing.Size(16, 13);
            this.label13.TabIndex = 27;
            this.label13.Text = "3.";
            // 
            // label12
            // 
            this.label12.AutoSize = true;
            this.label12.Location = new System.Drawing.Point(20, 113);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(16, 13);
            this.label12.TabIndex = 26;
            this.label12.Text = "2.";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(20, 83);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(16, 13);
            this.label10.TabIndex = 25;
            this.label10.Text = "1.";
            // 
            // textBoxIp5
            // 
            this.textBoxIp5.Location = new System.Drawing.Point(42, 200);
            this.textBoxIp5.Name = "textBoxIp5";
            this.textBoxIp5.ReadOnly = true;
            this.textBoxIp5.Size = new System.Drawing.Size(244, 20);
            this.textBoxIp5.TabIndex = 22;
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(20, 237);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(98, 13);
            this.label9.TabIndex = 21;
            this.label9.Text = "CONFIGSERVERS";
            // 
            // textBoxConfigServers
            // 
            this.textBoxConfigServers.Location = new System.Drawing.Point(23, 258);
            this.textBoxConfigServers.Name = "textBoxConfigServers";
            this.textBoxConfigServers.ReadOnly = true;
            this.textBoxConfigServers.Size = new System.Drawing.Size(540, 20);
            this.textBoxConfigServers.TabIndex = 20;
            // 
            // textBoxIp4
            // 
            this.textBoxIp4.Location = new System.Drawing.Point(42, 170);
            this.textBoxIp4.Name = "textBoxIp4";
            this.textBoxIp4.ReadOnly = true;
            this.textBoxIp4.Size = new System.Drawing.Size(244, 20);
            this.textBoxIp4.TabIndex = 18;
            // 
            // textBoxIp3
            // 
            this.textBoxIp3.Location = new System.Drawing.Point(42, 140);
            this.textBoxIp3.Name = "textBoxIp3";
            this.textBoxIp3.ReadOnly = true;
            this.textBoxIp3.Size = new System.Drawing.Size(244, 20);
            this.textBoxIp3.TabIndex = 16;
            // 
            // textBoxIp2
            // 
            this.textBoxIp2.Location = new System.Drawing.Point(42, 110);
            this.textBoxIp2.Name = "textBoxIp2";
            this.textBoxIp2.ReadOnly = true;
            this.textBoxIp2.Size = new System.Drawing.Size(244, 20);
            this.textBoxIp2.TabIndex = 14;
            // 
            // textBoxIp1
            // 
            this.textBoxIp1.Location = new System.Drawing.Point(42, 80);
            this.textBoxIp1.Name = "textBoxIp1";
            this.textBoxIp1.ReadOnly = true;
            this.textBoxIp1.Size = new System.Drawing.Size(244, 20);
            this.textBoxIp1.TabIndex = 10;
            // 
            // label11
            // 
            this.label11.Location = new System.Drawing.Point(0, 0);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(100, 23);
            this.label11.TabIndex = 0;
            // 
            // buttonInstall
            // 
            this.buttonInstall.Location = new System.Drawing.Point(434, 534);
            this.buttonInstall.Name = "buttonInstall";
            this.buttonInstall.Size = new System.Drawing.Size(75, 23);
            this.buttonInstall.TabIndex = 11;
            this.buttonInstall.Text = "Install";
            this.buttonInstall.UseVisualStyleBackColor = true;
            this.buttonInstall.Click += new System.EventHandler(this.buttonInstall_Click);
            // 
            // buttonCancel
            // 
            this.buttonCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.buttonCancel.Location = new System.Drawing.Point(532, 534);
            this.buttonCancel.Name = "buttonCancel";
            this.buttonCancel.Size = new System.Drawing.Size(75, 23);
            this.buttonCancel.TabIndex = 14;
            this.buttonCancel.Text = "Cancel";
            this.buttonCancel.UseVisualStyleBackColor = true;
            this.buttonCancel.Click += new System.EventHandler(this.buttonCancel_Click);
            // 
            // WebstoreInstall
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.buttonCancel;
            this.ClientSize = new System.Drawing.Size(622, 567);
            this.Controls.Add(this.buttonCancel);
            this.Controls.Add(this.buttonInstall);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.label6);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.textBoxPassword);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.textBoxUserName);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.buttonMsi);
            this.Controls.Add(this.textBoxMsi);
            this.Controls.Add(this.label1);
            this.Name = "WebstoreInstall";
            this.Text = "Webstore Client Install for Xblob";
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox textBoxMsi;
        private System.Windows.Forms.Button buttonMsi;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox textBoxUserName;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.TextBox textBoxPassword;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.Button buttonInstall;
        private System.Windows.Forms.TextBox textBoxIp4;
        private System.Windows.Forms.TextBox textBoxIp3;
        private System.Windows.Forms.TextBox textBoxIp2;
        private System.Windows.Forms.TextBox textBoxIp1;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.TextBox textBoxConfigServers;
        private System.Windows.Forms.TextBox textBoxIp5;
        private System.Windows.Forms.Label label15;
        private System.Windows.Forms.Label label14;
        private System.Windows.Forms.Label label13;
        private System.Windows.Forms.Label label12;
        private System.Windows.Forms.Label label11;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.OpenFileDialog openFileDialogMsi;
        private System.Windows.Forms.Button buttonCancel;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.TextBox textBox5;
        private System.Windows.Forms.TextBox textBox4;
        private System.Windows.Forms.TextBox textBox3;
        private System.Windows.Forms.TextBox textBox2;
        private System.Windows.Forms.TextBox textBox1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\Status\StatusConsole.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

namespace STFRunner.Status
{
    public class StatusConsole : StatusHandler
    {
        DateTime startTime = DateTime.Now;
        DateTime lastUpdate = DateTime.Now;

        public StatusConsole(TestResultCollection results, int intervalSeconds) : base(results, intervalSeconds)
        {
        }

        override public void Tick()
        {
            string status = results.GetStatusLine();
            Global.RO.Info(status);
            lastUpdate = DateTime.Now;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\Status\StatusHtmlReport.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

namespace STFRunner.Status
{
    public class StatusHtmlReport : StatusHandler
    {
        private string path = "TestResults";
        private string suiteName;
        private StressJobList stressJobList;

        public StatusHtmlReport(string suiteName, StressJobList stressJobList, TestResultCollection results, int intervalSeconds) : base(results, intervalSeconds)
        {
            if (suiteName == null)
                throw new ArgumentException("results must not be null");

            this.suiteName = suiteName;
            this.stressJobList = stressJobList;
            Directory.CreateDirectory(path);
        }

        override public void Tick()
        {
            DumpStats(path + "\\" + suiteName + ".html");
            DumpStats(path + "\\" + suiteName + DateTime.Now.Ticks.ToString() + ".html");
        }

        public void DumpStats(string filename)
        {
            System.IO.TextWriter tw;

            try
            {
                tw = File.CreateText(filename);
            }
            catch(Exception)
            {
                ConsoleX.WriteLine("Can not create file '" + filename + "'.");
                return;
            }

            tw.WriteLine("<html><body>");
            tw.WriteLine("<font face=\"Lucida Console, Arial, sans-serif\">");
            tw.WriteLine(results.GetStatusHtmlTable());
            tw.WriteLine("</font>\n</body></html>");
            tw.Flush();
            tw.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\StressGUI.cs ===
using System;
using System.Diagnostics;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

using STFRunner.Status;

namespace STFRunner
{
    public class StressGUI : System.Windows.Forms.Form
    {
        // the GUI needs R/W access to this
        public StressTestScheduler scheduler;
        public StressSettingsPriority settingsPriority;
        public StressSettingsTPS settingsTPS;
        public StressJobList StressJobs;
        private TestResultCollection AllResults = new TestResultCollection();
        private GUIReportDestination guiReporter;
        private StfXmlDoc config;
        private TestSuiteContainer suites;
        private DateTime lastUpdate;
        private float sbarPositionRatio=0.5f; //splitter bar position in the window, from 0 to 1
        bool suitesInitialized=false;
//         private bool inDataGrid = false;

        public delegate void InvokeCode();

        // We need to access this from StressScheduler, since it is the main entry
        // point for starting & stopping stress (handles the button click). It's OK 
        // to make it static since we'll only have 1 StressGUI around.
        public static AsyncButtonClickAction asyncAction;

        private WireDataFuzzForm wdFuzzForm = null;

        private static object realTPSLock = new object();
        private volatile static float realTPS = 0;
        public static float RealTPS
        {
            get
            {
                lock (realTPSLock)
                {
                    return(realTPS);
                }
            }
        }
        private static object currentShortTPSLock = new object();
        private volatile static float currentShortTPS = 0;
        public static float CurrentShortTPS
        {
            get
            {
                lock (currentShortTPSLock)
                {
                    return(currentShortTPS);
                }
            }
        }
        private static object currentTPSLock = new object();
        private volatile static float currentTPS = 0;
        public static float CurrentTPS
        {
            get
            {
                lock (currentTPSLock)
                {
                    return(currentTPS);
                }
            }
        }
        private static object currentTPS120Lock = new object();
        private volatile static float currentTPS120 = 0;
        public static float CurrentTPS120
        {
            get
            {
                lock (currentTPS120Lock)
                {
                    return(currentTPS120);
                }
            }
        }

        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.GroupBox groupPriParam;
        private System.Windows.Forms.DataGrid dataGrid1;
        private System.Windows.Forms.Label lTimeToRun;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel2;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.Label lEndTime;
        private GradientControl lSuiteName;
        private System.Windows.Forms.Button bSetTime;
        private System.Windows.Forms.NumericUpDown nMaxThreads;
        private System.Windows.Forms.TextBox tCurrentThreads;
        private System.Windows.Forms.CheckBox cbThrottle;
        private System.Windows.Forms.CheckBox cbSinScale;
        private System.Windows.Forms.NumericUpDown tThrottle;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Panel panel4;
        private System.Windows.Forms.Panel panel3;
        private System.Data.DataTable dtStress;
        private System.Data.DataColumn dataColumn7;
        private System.Data.DataColumn dataColumn8;
        private System.Data.DataColumn dataColumn2;
        private System.Data.DataColumn dataColumn9;
        private System.Data.DataColumn dataColumn10;
        private System.Data.DataColumn dataColumn11;
        private System.Data.DataSet dataSet1;
        private System.Data.DataView dataView1;
        private System.Windows.Forms.Panel panel5;
        private System.Windows.Forms.Button btnStart;
        private System.Windows.Forms.Button btnStartWeekend;
        private System.Data.DataColumn dataColumn1;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label lRunTime;
        private System.Windows.Forms.Splitter splitter1;
        private STFRunner.LogView logView;
        private System.Data.DataColumn dataColumn3;
        private System.Windows.Forms.CheckBox cbLogView;
        private System.Windows.Forms.Label lblTotalTPS;
        private System.Windows.Forms.Label lblTotalTPSOut;
        private System.Windows.Forms.Label lblTPS120;
        private System.Windows.Forms.Label lblTPS120Out;
        private MenuStrip mainMenuStrip;
        private ToolStripMenuItem fuzzingToolStripMenuItem;
        private ToolStripMenuItem wireDataFuzzingToolStripMenuItem;
        private RadioButton schedTps;
        private RadioButton schedPri;
        private GroupBox boxSchedulers;
        private GroupBox groupTPSParam;
        private TrackBar tpsScaleBar;
        private TrackBar tpsReservedFastPercentBar;
        private TrackBar tpsSinScaleMag;
        private TrackBar tpsSinPeriod;
        private TrackBar tpsSinPhase;
        private Label labelScaleSpeed;
        private Label labelFastThreadPercent;
        private Label labelSinScaleCurrent;
        private Label labelSinMag;
        private Label labelSinPeriod;
        private Label labelSinPhase;
        private Label label8;
        private Label label888;
        private Label label88SinMag;
        private Label label88SinPeriod;
        private Label label88SinPhase;
        private System.ComponentModel.IContainer components = null;

        //column indices
        private const int STRESSCOL_NAME=0;
        private const int STRESSCOL_TARTPS=1;
        private const int STRESSCOL_PRI=2;
        private const int STRESSCOL_PASS=3;
        private const int STRESSCOL_FAIL=4;
        private const int STRESSCOL_RATE=5;
        private const int STRESSCOL_CURTPS=6;
        private const int STRESSCOL_PRIVTPS = 7;
        private const int STRESSCOL_INPROGRESS = 8;

        //
        private TextBox tpsParamCurrent;
        private NumericUpDown tpsParamMax;
        private Label label5;
        private CheckBox cbFastUI;
        private DataColumn dataColumn4;
        private Label label9;
        

        public StressGUI(StfXmlDoc config, TestSuiteContainer suites)
        {
            InitializeComponent();
            NondesignerInitializeComponent();
            
            // Initialize XConfig here
            Global.Initialize(config);

            // Route all reports from the root to the GUI
            guiReporter = new GUIReportDestination(logView);
            ServerTestFramework.Report.GetRoot().AddReportDestination(guiReporter);

            // Rewire STDOUT/STDERR to the gui reporter
            Console.SetError(new TextWriterReportBridge("STDERR"));
            Console.SetOut(new TextWriterReportBridge("STDOUT"));

            // Do one-time init and create custom menus if the Suites wants it.
            this.config = config;
            this.suites = suites;

            TestSuite[] suitesArray = suites.GetLoadedSuites();
            for( int i=0; i<suitesArray.Length;i++)
            {
                //
                suitesArray[i].OneTimeInitializeStress(config);

                //
                suitesArray[i].AddCustomMenus();
                if(suitesArray[i].CustomMenu.Count >0)
                {
                    if(this.Menu ==null)
                        this.Menu = new MainMenu();
                    MenuItem temp = new MenuItem(suitesArray[i].Name);
                    for (int j=0; j< suitesArray[i].CustomMenu.Count;j++)
                    {
                        temp.MenuItems.Add(((CustomMenu)suitesArray[i].CustomMenu[j]).name,((CustomMenu)suitesArray[i].CustomMenu[j]).handler);
                    }

                    this.Menu.MenuItems.Add(0,temp);                    
                }
            }

            this.Closing += new CancelEventHandler(StressGUI_Closing);
            this.Resize += new EventHandler(StressGUI_Resize);
            
            //
            ButtonCollection asyncButtons = new ButtonCollection();
            asyncButtons.Add(btnStart);
            asyncButtons.Add(btnStartWeekend);

            asyncAction = new AsyncButtonClickAction(
                    new Action(BeginStressClick), 
                    new Action(EndStressClick), 
                    asyncButtons, 
                    new CancelableAction(Start), 
                    new Action(Stopped), 
                    new Action(Status));

            StressJobs = new StressJobList(suites.GetLoadedSuites(), config, AllResults);

            LoadInitialSettings();

            SetupDataGrid();

            // Some STF methods attempt to report progress but StressGUI doesn't have a progress bar, so fake one
            FeedbackManager.Instance.SetFactory(new STFRunner.GUIFeedbackFactory(new STFRunner.STFProgressBar()));

            //TODO: Handle allowing stress to log to a file for the rare case someone would actually want that.
            /*if (Settings.UseFileReport == true)
            {
                // Setup a file to log the output of the stress test run
                stressResultsDest = new FileReportDestination("StressResults", Suites.GetLoadedSuites()[0].Name, DateTime.Now);
                ServerTestFramework.Report.GetRoot().AddReportDestination(stressResultsDest);
            }*/

            //datagrid handlers
            dtStress.ColumnChanged += new DataColumnChangeEventHandler(dtStress_ColumnChanged);
            dataGrid1.CurrentCellChanged +=new EventHandler(dataGrid1_CurrentCellChanged);

            //set the default schedular
            schedPri.Checked=true;
        }

        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.groupPriParam = new System.Windows.Forms.GroupBox();
            this.label3 = new System.Windows.Forms.Label();
            this.tThrottle = new System.Windows.Forms.NumericUpDown();
            this.cbThrottle = new System.Windows.Forms.CheckBox();
            this.cbSinScale = new System.Windows.Forms.CheckBox();
            this.tCurrentThreads = new System.Windows.Forms.TextBox();
            this.nMaxThreads = new System.Windows.Forms.NumericUpDown();
            this.lTimeToRun = new System.Windows.Forms.Label();
            this.lEndTime = new System.Windows.Forms.Label();
            this.label7 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel5 = new System.Windows.Forms.Panel();
            this.btnStartWeekend = new System.Windows.Forms.Button();
            this.btnStart = new System.Windows.Forms.Button();
            this.panel4 = new System.Windows.Forms.Panel();
            this.cbLogView = new System.Windows.Forms.CheckBox();
            this.bSetTime = new System.Windows.Forms.Button();
            this.panel2 = new System.Windows.Forms.Panel();
            this.cbFastUI = new System.Windows.Forms.CheckBox();
            this.groupTPSParam = new System.Windows.Forms.GroupBox();
            this.labelScaleSpeed = new System.Windows.Forms.Label();
            this.labelSinScaleCurrent = new System.Windows.Forms.Label();
            this.labelSinMag = new System.Windows.Forms.Label();
            this.labelSinPeriod = new System.Windows.Forms.Label();
            this.labelSinPhase = new System.Windows.Forms.Label();
            this.labelFastThreadPercent = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.label888 = new System.Windows.Forms.Label();
            this.label88SinMag = new System.Windows.Forms.Label();
            this.label88SinPeriod = new System.Windows.Forms.Label();
            this.label88SinPhase = new System.Windows.Forms.Label();
            this.tpsScaleBar = new System.Windows.Forms.TrackBar();
            this.tpsSinScaleMag = new System.Windows.Forms.TrackBar();
            this.tpsSinPeriod = new System.Windows.Forms.TrackBar();
            this.tpsSinPhase = new System.Windows.Forms.TrackBar();
            this.tpsReservedFastPercentBar = new System.Windows.Forms.TrackBar();
            this.tpsParamCurrent = new System.Windows.Forms.TextBox();
            this.tpsParamMax = new System.Windows.Forms.NumericUpDown();
            this.label5 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.boxSchedulers = new System.Windows.Forms.GroupBox();
            this.schedPri = new System.Windows.Forms.RadioButton();
            this.schedTps = new System.Windows.Forms.RadioButton();
            this.lblTPS120Out = new System.Windows.Forms.Label();
            this.lblTPS120 = new System.Windows.Forms.Label();
            this.lblTotalTPSOut = new System.Windows.Forms.Label();
            this.lblTotalTPS = new System.Windows.Forms.Label();
            this.lSuiteName = new STFRunner.GradientControl();
            this.panel3 = new System.Windows.Forms.Panel();
            this.dataGrid1 = new System.Windows.Forms.DataGrid();
            this.dataView1 = new System.Data.DataView();
            this.dtStress = new System.Data.DataTable();
            this.dataColumn7 = new System.Data.DataColumn();
            this.dataColumn1 = new System.Data.DataColumn();
            this.dataColumn8 = new System.Data.DataColumn();
            this.dataColumn2 = new System.Data.DataColumn();
            this.dataColumn9 = new System.Data.DataColumn();
            this.dataColumn11 = new System.Data.DataColumn();
            this.dataColumn10 = new System.Data.DataColumn();
            this.dataColumn3 = new System.Data.DataColumn();
            this.dataSet1 = new System.Data.DataSet();
            this.label4 = new System.Windows.Forms.Label();
            this.lRunTime = new System.Windows.Forms.Label();
            this.splitter1 = new System.Windows.Forms.Splitter();
            this.mainMenuStrip = new System.Windows.Forms.MenuStrip();
            this.fuzzingToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.wireDataFuzzingToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.logView = new STFRunner.LogView();
            this.dataColumn4 = new System.Data.DataColumn();
            this.groupPriParam.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize) (this.tThrottle)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.nMaxThreads)).BeginInit();
            this.panel1.SuspendLayout();
            this.panel5.SuspendLayout();
            this.panel4.SuspendLayout();
            this.panel2.SuspendLayout();
            this.groupTPSParam.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize) (this.tpsScaleBar)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsSinScaleMag)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsSinPeriod)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsSinPhase)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsReservedFastPercentBar)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsParamMax)).BeginInit();
            this.boxSchedulers.SuspendLayout();
            this.panel3.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize) (this.dataGrid1)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.dataView1)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.dtStress)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.dataSet1)).BeginInit();
            this.mainMenuStrip.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(14, 24);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(88, 16);
            this.label1.TabIndex = 10;
            this.label1.Text = "Current threads:";
            this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(14, 45);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(88, 23);
            this.label2.TabIndex = 11;
            this.label2.Text = "Max threads:";
            this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.label2.Click += new System.EventHandler(this.label2_Click);
            // 
            // groupPriParam
            // 
            this.groupPriParam.Controls.Add(this.label3);
            this.groupPriParam.Controls.Add(this.tThrottle);
            this.groupPriParam.Controls.Add(this.cbThrottle);
            this.groupPriParam.Controls.Add(this.tCurrentThreads);
            this.groupPriParam.Controls.Add(this.nMaxThreads);
            this.groupPriParam.Controls.Add(this.label1);
            this.groupPriParam.Controls.Add(this.label2);
            this.groupPriParam.Location = new System.Drawing.Point(114, 37);
            this.groupPriParam.Name = "groupPriParam";
            this.groupPriParam.Size = new System.Drawing.Size(365, 115);
            this.groupPriParam.TabIndex = 19;
            this.groupPriParam.TabStop = false;
            this.groupPriParam.Text = "Priority Schedular Parameters";
            this.groupPriParam.Visible = false;
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(182, 85);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(27, 21);
            this.label3.TabIndex = 17;
            this.label3.Text = "tps";
            // 
            // tThrottle
            // 
            this.tThrottle.Enabled = false;
            this.tThrottle.Location = new System.Drawing.Point(102, 82);
            this.tThrottle.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.tThrottle.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.tThrottle.Name = "tThrottle";
            this.tThrottle.Size = new System.Drawing.Size(80, 20);
            this.tThrottle.TabIndex = 16;
            this.tThrottle.Value = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.tThrottle.ValueChanged += new System.EventHandler(this.tThrottle_ValueChanged);
            // 
            // cbThrottle
            // 
            this.cbThrottle.Location = new System.Drawing.Point(14, 82);
            this.cbThrottle.Name = "cbThrottle";
            this.cbThrottle.Size = new System.Drawing.Size(80, 24);
            this.cbThrottle.TabIndex = 15;
            this.cbThrottle.Text = "Throttling";
            this.cbThrottle.CheckedChanged += new System.EventHandler(this.cbThrottle_CheckedChanged);
            // 
            // cbSinScale
            // 
            this.cbSinScale.Location = new System.Drawing.Point(200, 8);
            this.cbSinScale.Name = "cbSinScale";
            this.cbSinScale.Size = new System.Drawing.Size(125, 24);
            this.cbSinScale.TabIndex = 15;
            this.cbSinScale.Text = "Sine Wave Scaling:";
            this.cbSinScale.CheckedChanged += new System.EventHandler(this.cbSinScale_CheckedChanged);
            // 
            // tCurrentThreads
            // 
            this.tCurrentThreads.Enabled = false;
            this.tCurrentThreads.Location = new System.Drawing.Point(102, 24);
            this.tCurrentThreads.Name = "tCurrentThreads";
            this.tCurrentThreads.Size = new System.Drawing.Size(80, 20);
            this.tCurrentThreads.TabIndex = 14;
            this.tCurrentThreads.Text = "---";
            // 
            // nMaxThreads
            // 
            this.nMaxThreads.Location = new System.Drawing.Point(102, 48);
            this.nMaxThreads.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.nMaxThreads.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.nMaxThreads.Name = "nMaxThreads";
            this.nMaxThreads.Size = new System.Drawing.Size(80, 20);
            this.nMaxThreads.TabIndex = 13;
            this.nMaxThreads.Value = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.nMaxThreads.ValueChanged += new System.EventHandler(this.nMaxThreads_ValueChanged);
            // 
            // lTimeToRun
            // 
            this.lTimeToRun.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.lTimeToRun.Location = new System.Drawing.Point(609, 53);
            this.lTimeToRun.Name = "lTimeToRun";
            this.lTimeToRun.Size = new System.Drawing.Size(136, 23);
            this.lTimeToRun.TabIndex = 22;
            this.lTimeToRun.Text = "---";
            // 
            // lEndTime
            // 
            this.lEndTime.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.lEndTime.Location = new System.Drawing.Point(609, 93);
            this.lEndTime.Name = "lEndTime";
            this.lEndTime.Size = new System.Drawing.Size(184, 23);
            this.lEndTime.TabIndex = 25;
            this.lEndTime.Text = "---";
            // 
            // label7
            // 
            this.label7.Location = new System.Drawing.Point(609, 77);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(100, 16);
            this.label7.TabIndex = 24;
            this.label7.Text = "End time:";
            // 
            // label6
            // 
            this.label6.Location = new System.Drawing.Point(609, 37);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(69, 18);
            this.label6.TabIndex = 23;
            this.label6.Text = "Time to run:";
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.panel5);
            this.panel1.Controls.Add(this.panel4);
            this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.panel1.Location = new System.Drawing.Point(0, 493);
            this.panel1.Name = "panel1";
            this.panel1.Padding = new System.Windows.Forms.Padding(4);
            this.panel1.Size = new System.Drawing.Size(608, 32);
            this.panel1.TabIndex = 24;
            // 
            // panel5
            // 
            this.panel5.Controls.Add(this.btnStartWeekend);
            this.panel5.Controls.Add(this.btnStart);
            this.panel5.Dock = System.Windows.Forms.DockStyle.Right;
            this.panel5.Location = new System.Drawing.Point(396, 4);
            this.panel5.Name = "panel5";
            this.panel5.Size = new System.Drawing.Size(208, 24);
            this.panel5.TabIndex = 27;
            // 
            // btnStartWeekend
            // 
            this.btnStartWeekend.Dock = System.Windows.Forms.DockStyle.Left;
            this.btnStartWeekend.Location = new System.Drawing.Point(0, 0);
            this.btnStartWeekend.Name = "btnStartWeekend";
            this.btnStartWeekend.Size = new System.Drawing.Size(120, 24);
            this.btnStartWeekend.TabIndex = 28;
            this.btnStartWeekend.Text = "Start Weekend Run";
            this.btnStartWeekend.Click += new System.EventHandler(this.btnStartWeekend_Click);
            // 
            // btnStart
            // 
            this.btnStart.Dock = System.Windows.Forms.DockStyle.Right;
            this.btnStart.Location = new System.Drawing.Point(128, 0);
            this.btnStart.Name = "btnStart";
            this.btnStart.Size = new System.Drawing.Size(80, 24);
            this.btnStart.TabIndex = 27;
            this.btnStart.Text = "Start";
            // 
            // panel4
            // 
            this.panel4.Controls.Add(this.cbLogView);
            this.panel4.Controls.Add(this.bSetTime);
            this.panel4.Dock = System.Windows.Forms.DockStyle.Left;
            this.panel4.Location = new System.Drawing.Point(4, 4);
            this.panel4.Name = "panel4";
            this.panel4.Size = new System.Drawing.Size(360, 24);
            this.panel4.TabIndex = 25;
            // 
            // cbLogView
            // 
            this.cbLogView.Checked = true;
            this.cbLogView.CheckState = System.Windows.Forms.CheckState.Checked;
            this.cbLogView.Location = new System.Drawing.Point(96, 0);
            this.cbLogView.Name = "cbLogView";
            this.cbLogView.Size = new System.Drawing.Size(112, 24);
            this.cbLogView.TabIndex = 24;
            this.cbLogView.Text = "Enable LogView";
            this.cbLogView.CheckedChanged += new System.EventHandler(this.cbLogView_CheckedChanged);
            // 
            // bSetTime
            // 
            this.bSetTime.Dock = System.Windows.Forms.DockStyle.Left;
            this.bSetTime.Location = new System.Drawing.Point(0, 0);
            this.bSetTime.Name = "bSetTime";
            this.bSetTime.Size = new System.Drawing.Size(75, 24);
            this.bSetTime.TabIndex = 23;
            this.bSetTime.Text = "Set Time";
            this.bSetTime.Click += new System.EventHandler(this.bSetTime_Click);
            // 
            // panel2
            // 
            this.panel2.Controls.Add(this.cbFastUI);
            this.panel2.Controls.Add(this.groupTPSParam);
            this.panel2.Controls.Add(this.boxSchedulers);
            this.panel2.Controls.Add(this.lTimeToRun);
            this.panel2.Controls.Add(this.lblTPS120Out);
            this.panel2.Controls.Add(this.lEndTime);
            this.panel2.Controls.Add(this.lblTPS120);
            this.panel2.Controls.Add(this.label7);
            this.panel2.Controls.Add(this.label6);
            this.panel2.Controls.Add(this.lblTotalTPSOut);
            this.panel2.Controls.Add(this.lblTotalTPS);
            this.panel2.Controls.Add(this.lSuiteName);
            this.panel2.Controls.Add(this.groupPriParam);
            this.panel2.Dock = System.Windows.Forms.DockStyle.Top;
            this.panel2.Location = new System.Drawing.Point(0, 0);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(608, 158);
            this.panel2.TabIndex = 25;
            // 
            // cbFastUI
            // 
            this.cbFastUI.AutoSize = true;
            this.cbFastUI.Location = new System.Drawing.Point(8, 128);
            this.cbFastUI.Name = "cbFastUI";
            this.cbFastUI.Size = new System.Drawing.Size(100, 17);
            this.cbFastUI.TabIndex = 36;
            this.cbFastUI.Text = "Fast UI Refresh";
            this.cbFastUI.UseVisualStyleBackColor = true;
            this.cbFastUI.CheckedChanged += new System.EventHandler(this.cbFastUI_CheckedChanged);
            // 
            // groupTPSParam
            // 
            this.groupTPSParam.Controls.Add(this.labelScaleSpeed);
            this.groupTPSParam.Controls.Add(this.labelSinScaleCurrent);
            this.groupTPSParam.Controls.Add(this.labelSinMag);
            this.groupTPSParam.Controls.Add(this.labelSinPeriod);
            this.groupTPSParam.Controls.Add(this.labelSinPhase);
            this.groupTPSParam.Controls.Add(this.labelFastThreadPercent);
            this.groupTPSParam.Controls.Add(this.label8);
            this.groupTPSParam.Controls.Add(this.label888);
            this.groupTPSParam.Controls.Add(this.label88SinMag);
            this.groupTPSParam.Controls.Add(this.label88SinPeriod);
            this.groupTPSParam.Controls.Add(this.label88SinPhase);
            this.groupTPSParam.Controls.Add(this.tpsScaleBar);
            this.groupTPSParam.Controls.Add(this.tpsSinScaleMag);
            this.groupTPSParam.Controls.Add(this.tpsSinPeriod);
            this.groupTPSParam.Controls.Add(this.tpsSinPhase);
            this.groupTPSParam.Controls.Add(this.tpsReservedFastPercentBar);
            this.groupTPSParam.Controls.Add(this.tpsParamCurrent);
            this.groupTPSParam.Controls.Add(this.tpsParamMax);
            this.groupTPSParam.Controls.Add(this.label5);
            this.groupTPSParam.Controls.Add(this.label9);
            this.groupTPSParam.Controls.Add(this.cbSinScale);
            this.groupTPSParam.Location = new System.Drawing.Point(114, 37);
            this.groupTPSParam.Name = "groupTPSParam";
            this.groupTPSParam.Size = new System.Drawing.Size(365, 115);
            this.groupTPSParam.TabIndex = 35;
            this.groupTPSParam.TabStop = false;
            this.groupTPSParam.Text = "TPS Scheduler Parameters";
            // 
            // labelScaleSpeed
            // 
            this.labelScaleSpeed.AutoSize = true;
            this.labelScaleSpeed.Location = new System.Drawing.Point(310, 95);
            this.labelScaleSpeed.Name = "labelScaleSpeed";
            this.labelScaleSpeed.Size = new System.Drawing.Size(33, 13);
            this.labelScaleSpeed.TabIndex = 4;
            this.labelScaleSpeed.Text = "100%";
            // 
            // labelSinScaleCurrent
            // 
            this.labelSinScaleCurrent.AutoSize = true;
            this.labelSinScaleCurrent.Location = new System.Drawing.Point(315, 13);
            this.labelSinScaleCurrent.Name = "labelSinScaleCurrent";
            this.labelSinScaleCurrent.Size = new System.Drawing.Size(33, 13);
            this.labelSinScaleCurrent.TabIndex = 4;
            this.labelSinScaleCurrent.Text = "--";
            // 
            // labelSinMag
            // 
            this.labelSinMag.AutoSize = true;
            this.labelSinMag.Location = new System.Drawing.Point(315, 30);
            this.labelSinMag.Name = "labelSinMag";
            this.labelSinMag.Size = new System.Drawing.Size(33, 13);
            this.labelSinMag.TabIndex = 4;
            this.labelSinMag.Text = "50%";
            // 
            // labelSinPeriod
            // 
            this.labelSinPeriod.AutoSize = true;
            this.labelSinPeriod.Location = new System.Drawing.Point(315, 45);
            this.labelSinPeriod.Name = "labelSinPeriod";
            this.labelSinPeriod.Size = new System.Drawing.Size(33, 13);
            this.labelSinPeriod.TabIndex = 4;
            this.labelSinPeriod.Text = "1 day";
            // 
            // labelSinPhase
            // 
            this.labelSinPhase.AutoSize = true;
            this.labelSinPhase.Location = new System.Drawing.Point(315, 60);
            this.labelSinPhase.Name = "labelSinPhase";
            this.labelSinPhase.Size = new System.Drawing.Size(33, 13);
            this.labelSinPhase.TabIndex = 4;
            this.labelSinPhase.Text = "PI/2";
            // 
            // labelFastThreadPercent
            // 
            this.labelFastThreadPercent.AutoSize = true;
            this.labelFastThreadPercent.Location = new System.Drawing.Point(310, 76);
            this.labelFastThreadPercent.Name = "labelFastThreadPercent";
            this.labelFastThreadPercent.Size = new System.Drawing.Size(33, 13);
            this.labelFastThreadPercent.TabIndex = 4;
            this.labelFastThreadPercent.Text = "5%";
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Location = new System.Drawing.Point(3, 91);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(61, 13);
            this.label8.TabIndex = 3;
            this.label8.Text = "Scale TPS";
            // 
            // label888
            // 
            this.label888.AutoSize = true;
            this.label888.Location = new System.Drawing.Point(3, 72);
            this.label888.Name = "label888";
            this.label888.Size = new System.Drawing.Size(59, 13);
            this.label888.TabIndex = 3;
            this.label888.Text = "Reserved Threads";
            // 
            // label88SinMag
            // 
            this.label88SinMag.AutoSize = true;
            this.label88SinMag.Location = new System.Drawing.Point(180, 30);
            this.label88SinMag.Name = "label88SinMag";
            this.label88SinMag.Size = new System.Drawing.Size(59, 13);
            this.label88SinMag.TabIndex = 3;
            this.label88SinMag.Text = "Wave: Mag";
            // 
            // label88SinPeriod
            // 
            this.label88SinPeriod.AutoSize = true;
            this.label88SinPeriod.Location = new System.Drawing.Point(205, 45);
            this.label88SinPeriod.Name = "label88SinPeriod";
            this.label88SinPeriod.Size = new System.Drawing.Size(59, 13);
            this.label88SinPeriod.TabIndex = 3;
            this.label88SinPeriod.Text = "Period";
            // 
            // label88SinPhase
            // 
            this.label88SinPhase.AutoSize = true;
            this.label88SinPhase.Location = new System.Drawing.Point(205, 60);
            this.label88SinPhase.Name = "label88SinPhase";
            this.label88SinPhase.Size = new System.Drawing.Size(59, 13);
            this.label88SinPhase.TabIndex = 3;
            this.label88SinPhase.Text = "Phase";
            // 
            // tpsScaleBar
            // 
            this.tpsScaleBar.AutoSize = false;
            this.tpsScaleBar.LargeChange = 20;
            this.tpsScaleBar.Location = new System.Drawing.Point(100, 93);
            this.tpsScaleBar.Maximum = 200;
            this.tpsScaleBar.Name = "tpsScaleBar";
            this.tpsScaleBar.Size = new System.Drawing.Size(210, 20);
            this.tpsScaleBar.TabIndex = 2;
            this.tpsScaleBar.TickFrequency = 20;
            this.tpsScaleBar.TickStyle = System.Windows.Forms.TickStyle.None;
            this.tpsScaleBar.Value = 20;
            this.tpsScaleBar.Scroll += new System.EventHandler(this.tpsScaleBar_Scroll);
            // 
            // tpsSinScaleMag
            // 
            this.tpsSinScaleMag.AutoSize = false;
            this.tpsSinScaleMag.LargeChange = 1;
            this.tpsSinScaleMag.Location = new System.Drawing.Point(245, 30);
            this.tpsSinScaleMag.Minimum = 0;
            this.tpsSinScaleMag.Maximum = 100;
            this.tpsSinScaleMag.Name = "tpsSinScaleMag";
            this.tpsSinScaleMag.Size = new System.Drawing.Size(70, 18);
            this.tpsSinScaleMag.TabIndex = 2;
            this.tpsSinScaleMag.TickFrequency = 10;
            this.tpsSinScaleMag.TickStyle = System.Windows.Forms.TickStyle.None;
            this.tpsSinScaleMag.Value = 50;
            this.tpsSinScaleMag.Scroll += new System.EventHandler(this.tpsSinScaleMag_Scroll);
            // 
            // tpsSinPeriod
            // 
            this.tpsSinPeriod.AutoSize = false;
            this.tpsSinPeriod.LargeChange = 1;
            this.tpsSinPeriod.Location = new System.Drawing.Point(245, 45);
            this.tpsSinPeriod.Minimum = 0;
            this.tpsSinPeriod.Maximum = 7;
            this.tpsSinPeriod.Name = "tpsSinPeriod";
            this.tpsSinPeriod.Size = new System.Drawing.Size(70, 18);
            this.tpsSinPeriod.TabIndex = 2;
            this.tpsSinPeriod.TickFrequency = 1;
            this.tpsSinPeriod.TickStyle = System.Windows.Forms.TickStyle.None;
            this.tpsSinPeriod.Value = 7;
            this.tpsSinPeriod.Scroll += new System.EventHandler(this.tpsSinPeriod_Scroll);
            // 
            // tpsSinPhase
            // 
            this.tpsSinPhase.AutoSize = false;
            this.tpsSinPhase.LargeChange = 1;
            this.tpsSinPhase.Location = new System.Drawing.Point(245, 60);
            this.tpsSinPhase.Minimum = 0;
            this.tpsSinPhase.Maximum = 3;
            this.tpsSinPhase.Name = "tpsSinPhase";
            this.tpsSinPhase.Size = new System.Drawing.Size(70, 18);
            this.tpsSinPhase.TabIndex = 2;
            this.tpsSinPhase.TickFrequency = 1;
            this.tpsSinPhase.TickStyle = System.Windows.Forms.TickStyle.None;
            this.tpsSinPhase.Value = 1;
            this.tpsSinPhase.Scroll += new System.EventHandler(this.tpsSinPhase_Scroll);
            // 
            // tpsReservedFastPercentBar
            // 
            this.tpsReservedFastPercentBar.AutoSize = false;
            this.tpsReservedFastPercentBar.LargeChange = 5;
            this.tpsReservedFastPercentBar.Location = new System.Drawing.Point(100, 74);
            this.tpsReservedFastPercentBar.Minimum = 0;
            this.tpsReservedFastPercentBar.Maximum = 75;
            this.tpsReservedFastPercentBar.Name = "tpsReservedFastPercentBar";
            this.tpsReservedFastPercentBar.Size = new System.Drawing.Size(210, 20);
            this.tpsReservedFastPercentBar.TabIndex = 2;
            this.tpsReservedFastPercentBar.TickFrequency = 10;
            this.tpsReservedFastPercentBar.TickStyle = System.Windows.Forms.TickStyle.None;
            this.tpsReservedFastPercentBar.Value = 5;
            this.tpsReservedFastPercentBar.Scroll += new System.EventHandler(this.tpsReservedFastPercentBar_Scroll);
            // 
            // tpsParamCurrent
            // 
            this.tpsParamCurrent.Enabled = false;
            this.tpsParamCurrent.Location = new System.Drawing.Point(97, 16);
            this.tpsParamCurrent.Name = "tpsParamCurrent";
            this.tpsParamCurrent.Size = new System.Drawing.Size(80, 20);
            this.tpsParamCurrent.TabIndex = 14;
            this.tpsParamCurrent.Text = "---";
            // 
            // tpsParamMax
            // 
            this.tpsParamMax.Location = new System.Drawing.Point(97, 40);
            this.tpsParamMax.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.tpsParamMax.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.tpsParamMax.Name = "tpsParamMax";
            this.tpsParamMax.Size = new System.Drawing.Size(80, 20);
            this.tpsParamMax.TabIndex = 13;
            this.tpsParamMax.Value = new decimal(new int[] {
            100,
            0,
            0,
            0});
            this.tpsParamMax.ValueChanged += new System.EventHandler(this.nMaxThreads_ValueChanged);
            // 
            // label5
            // 
            this.label5.Location = new System.Drawing.Point(9, 37);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(88, 23);
            this.label5.TabIndex = 11;
            this.label5.Text = "Max threads:";
            this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label9
            // 
            this.label9.Location = new System.Drawing.Point(9, 16);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(88, 16);
            this.label9.TabIndex = 10;
            this.label9.Text = "Active threads:";
            this.label9.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // boxSchedulers
            // 
            this.boxSchedulers.Controls.Add(this.schedPri);
            this.boxSchedulers.Controls.Add(this.schedTps);
            this.boxSchedulers.Location = new System.Drawing.Point(4, 37);
            this.boxSchedulers.Name = "boxSchedulers";
            this.boxSchedulers.Size = new System.Drawing.Size(104, 60);
            this.boxSchedulers.TabIndex = 34;
            this.boxSchedulers.TabStop = false;
            this.boxSchedulers.Text = "Scheduler";
            // 
            // schedPri
            // 
            this.schedPri.AutoSize = true;
            this.schedPri.Location = new System.Drawing.Point(6, 15);
            this.schedPri.Name = "schedPri";
            this.schedPri.Size = new System.Drawing.Size(89, 17);
            this.schedPri.TabIndex = 32;
            this.schedPri.Text = "Priority (old)";
            this.schedPri.UseVisualStyleBackColor = true;
            this.schedPri.CheckedChanged += new System.EventHandler(this.schedPri_CheckedChanged);
            // 
            // schedTps
            // 
            this.schedTps.AutoSize = true;
            this.schedTps.Location = new System.Drawing.Point(6, 37);
            this.schedTps.Name = "schedTps";
            this.schedTps.Size = new System.Drawing.Size(79, 17);
            this.schedTps.TabIndex = 33;
            this.schedTps.Text = "TPS / Async";
            this.schedTps.UseVisualStyleBackColor = true;
            this.schedTps.CheckedChanged += new System.EventHandler(this.schedTps_CheckedChanged);
            // 
            // lblTPS120Out
            // 
            this.lblTPS120Out.Location = new System.Drawing.Point(543, 64);
            this.lblTPS120Out.Name = "lblTPS120Out";
            this.lblTPS120Out.Size = new System.Drawing.Size(54, 24);
            this.lblTPS120Out.TabIndex = 30;
            this.lblTPS120Out.Text = "0";
            // 
            // lblTPS120
            // 
            this.lblTPS120.Location = new System.Drawing.Point(485, 64);
            this.lblTPS120.Name = "lblTPS120";
            this.lblTPS120.Size = new System.Drawing.Size(64, 23);
            this.lblTPS120.TabIndex = 29;
            this.lblTPS120.Text = "TPS120:";
            // 
            // lblTotalTPSOut
            // 
            this.lblTotalTPSOut.Location = new System.Drawing.Point(543, 40);
            this.lblTotalTPSOut.Name = "lblTotalTPSOut";
            this.lblTotalTPSOut.Size = new System.Drawing.Size(54, 24);
            this.lblTotalTPSOut.TabIndex = 28;
            this.lblTotalTPSOut.Text = "0";
            // 
            // lblTotalTPS
            // 
            this.lblTotalTPS.Location = new System.Drawing.Point(485, 40);
            this.lblTotalTPS.Name = "lblTotalTPS";
            this.lblTotalTPS.Size = new System.Drawing.Size(64, 23);
            this.lblTotalTPS.TabIndex = 27;
            this.lblTotalTPS.Text = "Total TPS:";
            // 
            // lSuiteName
            // 
            this.lSuiteName.BackColor = System.Drawing.SystemColors.ActiveCaptionText;
            this.lSuiteName.Dock = System.Windows.Forms.DockStyle.Top;
            this.lSuiteName.Font = new System.Drawing.Font("Microsoft Sans Serif", 14.0F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.lSuiteName.ForeColor = System.Drawing.SystemColors.ActiveCaption;
            this.lSuiteName.Location = new System.Drawing.Point(0, 0);
            this.lSuiteName.Name = "lSuiteName";
            this.lSuiteName.Size = new System.Drawing.Size(608, 31);
            this.lSuiteName.TabIndex = 15;
            this.lSuiteName.TabStop = false;
            // 
            // panel3
            // 
            this.panel3.Controls.Add(this.dataGrid1);
            this.panel3.Dock = System.Windows.Forms.DockStyle.Top;
            this.panel3.Location = new System.Drawing.Point(0, 158);
            this.panel3.Name = "panel3";
            this.panel3.Size = new System.Drawing.Size(608, 176);
            this.panel3.TabIndex = 26;
            // 
            // dataGrid1
            // 
            this.dataGrid1.AllowNavigation = false;
            this.dataGrid1.AlternatingBackColor = System.Drawing.Color.LightGray;
            this.dataGrid1.BackColor = System.Drawing.Color.Gainsboro;
            this.dataGrid1.BackgroundColor = System.Drawing.Color.Silver;
            this.dataGrid1.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.dataGrid1.CaptionBackColor = System.Drawing.Color.LightSteelBlue;
            this.dataGrid1.CaptionForeColor = System.Drawing.Color.MidnightBlue;
            this.dataGrid1.CaptionText = "Stress run";
            this.dataGrid1.DataMember = "";
            this.dataGrid1.DataSource = this.dataView1;
            this.dataGrid1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.dataGrid1.FlatMode = true;
            this.dataGrid1.Font = new System.Drawing.Font("Tahoma", 8F);
            this.dataGrid1.ForeColor = System.Drawing.Color.Black;
            this.dataGrid1.GridLineColor = System.Drawing.Color.DimGray;
            this.dataGrid1.GridLineStyle = System.Windows.Forms.DataGridLineStyle.None;
            this.dataGrid1.HeaderBackColor = System.Drawing.Color.MidnightBlue;
            this.dataGrid1.HeaderFont = new System.Drawing.Font("Tahoma", 8F, System.Drawing.FontStyle.Bold);
            this.dataGrid1.HeaderForeColor = System.Drawing.Color.White;
            this.dataGrid1.LinkColor = System.Drawing.Color.MidnightBlue;
            this.dataGrid1.Location = new System.Drawing.Point(0, 0);
            this.dataGrid1.Name = "dataGrid1";
            this.dataGrid1.ParentRowsBackColor = System.Drawing.Color.DarkGray;
            this.dataGrid1.ParentRowsForeColor = System.Drawing.Color.Black;
            this.dataGrid1.RowHeadersVisible = false;
            this.dataGrid1.SelectionBackColor = System.Drawing.Color.CadetBlue;
            this.dataGrid1.SelectionForeColor = System.Drawing.Color.White;
            this.dataGrid1.Size = new System.Drawing.Size(608, 176);
            this.dataGrid1.TabIndex = 0;
            this.dataGrid1.Enter += new System.EventHandler(this.dataGrid1_Enter);
            this.dataGrid1.Navigate += new System.Windows.Forms.NavigateEventHandler(this.dataGrid1_Navigate);
            this.dataGrid1.Leave += new System.EventHandler(this.dataGrid1_Leave);
            // 
            // dataView1
            // 
            this.dataView1.AllowDelete = false;
            this.dataView1.AllowNew = false;
            this.dataView1.Table = this.dtStress;
            // 
            // dtStress
            // 
            this.dtStress.Columns.AddRange(new System.Data.DataColumn[] {
            this.dataColumn7,
            this.dataColumn1,
            this.dataColumn8,
            this.dataColumn2,
            this.dataColumn9,
            this.dataColumn11,
            this.dataColumn10,
            this.dataColumn3,
            this.dataColumn4});
            this.dtStress.TableName = "Stress";
            // 
            // dataColumn7
            // 
            this.dataColumn7.ColumnName = "Name";
            this.dataColumn7.DefaultValue = "<none>";
            this.dataColumn7.ReadOnly = true;
            // 
            // dataColumn1
            // 
            this.dataColumn1.Caption = "Target TPS";
            this.dataColumn1.ColumnName = "TargetTPS";
            // 
            // dataColumn8
            // 
            this.dataColumn8.ColumnName = "Priority";
            this.dataColumn8.DataType = typeof(float);
            this.dataColumn8.DefaultValue = 0F;
            // 
            // dataColumn2
            // 
            this.dataColumn2.ColumnName = "Passed";
            // 
            // dataColumn9
            // 
            this.dataColumn9.ColumnName = "Failed";
            // 
            // dataColumn11
            // 
            this.dataColumn11.ColumnName = "Rate";
            this.dataColumn11.DefaultValue = "0";
            // 
            // dataColumn10
            // 
            this.dataColumn10.Caption = "TPS (10 sec)";
            this.dataColumn10.ColumnName = "TPS";
            this.dataColumn10.DefaultValue = "0";
            // 
            // dataColumn3
            // 
            this.dataColumn3.Caption = "PrivateTPS (10 sec)";
            this.dataColumn3.ColumnName = "PrivateTPS";
            this.dataColumn3.DefaultValue = "0";
            // 
            // dataSet1
            // 
            this.dataSet1.DataSetName = "NewDataSet";
            this.dataSet1.Locale = new System.Globalization.CultureInfo("en-US");
            this.dataSet1.Tables.AddRange(new System.Data.DataTable[] {
            this.dtStress});
            // 
            // label4
            // 
            this.label4.Location = new System.Drawing.Point(160, 16);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(100, 16);
            this.label4.TabIndex = 26;
            this.label4.Text = "Run time:";
            // 
            // lRunTime
            // 
            this.lRunTime.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.lRunTime.Location = new System.Drawing.Point(160, 32);
            this.lRunTime.Name = "lRunTime";
            this.lRunTime.Size = new System.Drawing.Size(136, 23);
            this.lRunTime.TabIndex = 27;
            this.lRunTime.Text = "---";
            // 
            // splitter1
            // 
            this.splitter1.Dock = System.Windows.Forms.DockStyle.Top;
            this.splitter1.Location = new System.Drawing.Point(0, 334);
            this.splitter1.Name = "splitter1";
            this.splitter1.Size = new System.Drawing.Size(608, 3);
            this.splitter1.TabIndex = 27;
            this.splitter1.TabStop = false;
            this.splitter1.Move += new System.EventHandler(this.splitter1_Move_Delegate);
            // 
            // mainMenuStrip
            // 
            this.mainMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fuzzingToolStripMenuItem});
            this.mainMenuStrip.Location = new System.Drawing.Point(0, 0);
            this.mainMenuStrip.Name = "mainMenuStrip";
            this.mainMenuStrip.Size = new System.Drawing.Size(608, 24);
            this.mainMenuStrip.TabIndex = 29;
            this.mainMenuStrip.Text = "menuStrip1";
            this.mainMenuStrip.Visible = false;
            this.mainMenuStrip.MenuActivate += new System.EventHandler(this.mainMenuStrip_MenuActivate);
            this.mainMenuStrip.MenuDeactivate += new System.EventHandler(this.mainMenuStrip_MenuDeactivate);
            // 
            // fuzzingToolStripMenuItem
            // 
            this.fuzzingToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.wireDataFuzzingToolStripMenuItem});
            this.fuzzingToolStripMenuItem.Name = "fuzzingToolStripMenuItem";
            this.fuzzingToolStripMenuItem.Size = new System.Drawing.Size(59, 20);
            this.fuzzingToolStripMenuItem.Text = "Fuzzing";
            // 
            // wireDataFuzzingToolStripMenuItem
            // 
            this.wireDataFuzzingToolStripMenuItem.Name = "wireDataFuzzingToolStripMenuItem";
            this.wireDataFuzzingToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.wireDataFuzzingToolStripMenuItem.Text = "WireData Fuzzing...";
            this.wireDataFuzzingToolStripMenuItem.Click += new System.EventHandler(this.wireDataFuzzingToolStripMenuItem_Click);
            // 
            // logView
            // 
            this.logView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logView.Font = new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            this.logView.Location = new System.Drawing.Point(0, 337);
            this.logView.Name = "logView";
            this.logView.Size = new System.Drawing.Size(608, 156);
            this.logView.TabIndex = 28;
            // 
            // dataColumn4
            // 
            this.dataColumn4.Caption = "Number of tests currently being executed.";
            this.dataColumn4.ColumnName = "InProgress/Threads";
            this.dataColumn4.DataType = typeof(string);
            this.dataColumn4.DefaultValue = "- / -";
            // 
            // StressGUI
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(608, 525);
            this.Controls.Add(this.logView);
            this.Controls.Add(this.splitter1);
            this.Controls.Add(this.panel3);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.mainMenuStrip);
            this.MainMenuStrip = this.mainMenuStrip;
            this.MinimumSize = new System.Drawing.Size(584, 536);
            this.Name = "StressGUI";
            this.Text = "STFRunner - Stress";
            this.Closed += new System.EventHandler(this.StressGUI_Closed);
            this.Load += new System.EventHandler(this.StressGUI_Load);
            this.groupPriParam.ResumeLayout(false);
            this.groupPriParam.PerformLayout();
            ((System.ComponentModel.ISupportInitialize) (this.tThrottle)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.nMaxThreads)).EndInit();
            this.panel1.ResumeLayout(false);
            this.panel5.ResumeLayout(false);
            this.panel4.ResumeLayout(false);
            this.panel2.ResumeLayout(false);
            this.panel2.PerformLayout();
            this.groupTPSParam.ResumeLayout(false);
            this.groupTPSParam.PerformLayout();
            ((System.ComponentModel.ISupportInitialize) (this.tpsScaleBar)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsSinScaleMag)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsSinPeriod)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsSinPhase)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsReservedFastPercentBar)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.tpsParamMax)).EndInit();
            this.boxSchedulers.ResumeLayout(false);
            this.boxSchedulers.PerformLayout();
            this.panel3.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize) (this.dataGrid1)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.dataView1)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.dtStress)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.dataSet1)).EndInit();
            this.mainMenuStrip.ResumeLayout(false);
            this.mainMenuStrip.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }
        #endregion

        private void NondesignerInitializeComponent ()
        {
            // Manually Create a style object to control the width and colors.
            DataGridTableStyle dgts = new DataGridTableStyle();
            dgts.MappingName = dtStress.TableName;

            foreach (DataColumn dc in dtStress.Columns)
            {
                DataGridColumnStyle dgc = new DataGridTextBoxColumn();

                dgc.MappingName = dc.ColumnName;
                dgc.HeaderText = dc.ColumnName;
                if (dc.ColumnName == "Name")
                    dgc.Width = 200;
                else if (dc.ColumnName == dataColumn4.ColumnName)
                    dgc.Width = 120;
                else
                    dgc.Width = 70;

                dgts.GridColumnStyles.Add(dgc);
            }
            dgts.AlternatingBackColor = System.Drawing.Color.LightGray;
            dgts.BackColor = System.Drawing.Color.Gainsboro;
            dgts.ForeColor = System.Drawing.Color.Black;
            dgts.GridLineColor = System.Drawing.Color.DimGray;
            dgts.GridLineStyle = System.Windows.Forms.DataGridLineStyle.None;
            dgts.HeaderBackColor = System.Drawing.Color.MidnightBlue;
            dgts.HeaderFont = new System.Drawing.Font("Tahoma", 8F, System.Drawing.FontStyle.Bold);
            dgts.HeaderForeColor = System.Drawing.Color.White;
            dgts.LinkColor = System.Drawing.Color.MidnightBlue;
            dgts.RowHeadersVisible = false;
            dgts.SelectionBackColor = System.Drawing.Color.CadetBlue;
            dgts.SelectionForeColor = System.Drawing.Color.White;
            this.dataGrid1.TableStyles.Add(dgts);
        }

        public void BeginStressClick()
        {
            try
            {
                //disable changing schedulers
                boxSchedulers.Invoke(new InvokeCode(delegate {boxSchedulers.Enabled=false;}));

                //Initialize suites if needed
                if (!suitesInitialized)
                {
                    suitesInitialized=true;

                    foreach (TestSuite suite in suites.GetLoadedSuites())
                    {
                        suite.InitializeStress(config);
                    }
                }

                //run
                StatusConsole statusConsole = new StatusConsole(AllResults, 1);
                statusConsole.Start();

                if (scheduler!=null) scheduler.Run();

                statusConsole.End();
                statusConsole.Tick();
                if (this.Created) this.Invoke(new InvokeCode(delegate {UpdateGUI();}));
            }
            catch (Exception e)
            {
                Global.RO.Fatal("Exception trying to begin stress: "+e.Message+"\n"+e.StackTrace);
            }
        }

        public void EndStressClick()
        {
            try
            {
                if (scheduler==null) return;

                scheduler.Stop();

                //TODO: leftover junk from the priority scheduler's interface abuse
                if (scheduler is StressSchedulerPriority)
                {
                    ((StressSchedulerPriority)scheduler).EndStress();
                }
            }
            catch (Exception e)
            {
                Global.RO.Fatal("Exception trying to end stress: "+e.Message+"\n"+e.StackTrace);
            }
        }

        private bool Start()
        {
            //
            lastUpdate = DateTime.Now;
            UpdateGUI();

            return true;
        }

        private void Stopped()
        {
            UpdateGUI();

            //Deinitialize suites
            try
            {
                if (suitesInitialized)
                {
                    suitesInitialized=false;

                    foreach (TestSuite suite in suites.GetLoadedSuites())
                    {
                        suite.DeinitializeStress();
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Fatal("Exception trying to deinitialize suites: "+e.Message+"\n"+e.StackTrace);
            }

            //re-enable changing schedulers
            boxSchedulers.Invoke(new InvokeCode(delegate {boxSchedulers.Enabled=true;}));
        }

        private void Status()
        {
            UpdateGUI();
        }

        private void StressGUI_Closed(object sender, System.EventArgs e)
        {
            //stop schedulers
            if (asyncAction.State == AsyncState.Started)
                asyncAction.Stop(sender, e);

            if (scheduler!=null)
            {
                scheduler.Stop();
                scheduler.Shutdown();
            }

            //Deinitialize suites if needed
            if (suitesInitialized)
            {
                suitesInitialized=false;

                foreach (TestSuite suite in suites.GetLoadedSuites())
                {
                    suite.DeinitializeStress();
                }
            }

            //Do one-time suite deinit
            foreach (TestSuite suite in suites.GetLoadedSuites())
            {
                suite.OneTimeDeinitializeStress();
            }
        }

        private void StressGUI_Resize(object sender, System.EventArgs e)
        {
            //move the splitter bar so the ratio of the top half to the bottom half is the same
            float sbarPosY = sbarPositionRatio * this.ClientRectangle.Size.Height;
            this.splitter1.SplitPosition = (int)sbarPosY;
        }

        private void LoadInitialSettings()
        {
            //priority schedular settings
            settingsPriority = new StressSettingsPriority(config);

            //tps scheduler settings
            settingsTPS = new StressSettingsTPS();
            tpsParamMax.Value=settingsTPS.MaxThreads;
            tpsScaleBar.Value=(int)(settingsTPS.ScaleTPS*20);
            tpsReservedFastPercentBar.Value=(int)(settingsTPS.ReserveHighTPSThreadRatio*100);

            // look up the report log filters and reflect on gui report and menu
            uint currentFilters = Global.RO.Filter;
            try
            {
                // Setup log filters
                string strSetting = currentFilters.ToString();
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.ReportLogFilterKeyName, strSetting);
                currentFilters = UInt32.Parse(strSetting);
                
                // Setup window size
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.StressWindowTopKeyName, this.Top.ToString());
                this.Top = Int32.Parse(strSetting);
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.StressWindowLeftKeyName, this.Left.ToString());
                this.Left = Int32.Parse(strSetting);
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.StressWindowWidthKeyName, this.Width.ToString());
                this.Width = Int32.Parse(strSetting);
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.StressWindowHeightKeyName, this.Height.ToString());
                this.Height = Int32.Parse(strSetting);

                // Set the log splitter
                strSetting = (string)Global.CommonAppDataRegistry.GetValue(RunnerGlobal.StressWindowSplitterRatioKeyName, this.sbarPositionRatio.ToString());
                this.sbarPositionRatio = float.Parse(strSetting);
                StressGUI_Resize(null,null); //reset splitterbar pos based on that ratio
            }
            catch(Exception ex)
            {
                Global.RO.Error(ex.GetType().FullName + " trying to open the registry key: " + Global.CommonAppDataRegistry.Name + ", message: " + ex.Message);
            }
        }

        private void SetupDataGrid()
        {
            foreach(StressJob job in StressJobs)
            {
                DataRow r=dtStress.NewRow();
                r[STRESSCOL_NAME]=job.Name;
                r[STRESSCOL_PRI]=job.Priority;
                r[STRESSCOL_PASS]=job.Results.Passed;
                r[STRESSCOL_FAIL]=job.Results.Failed;
                r[STRESSCOL_CURTPS]=0;
                r[STRESSCOL_RATE]="-";
                r[STRESSCOL_TARTPS]=job.TargetTPS;
                r[STRESSCOL_PRIVTPS] = 0;
                r[STRESSCOL_INPROGRESS] = 0;
                dtStress.Rows.Add(r);
            }

            // auto resize the first column
            float maxWidth = (float) dataGrid1.TableStyles[0].GridColumnStyles[STRESSCOL_NAME].Width;
            Graphics g = dataGrid1.CreateGraphics();

            foreach (DataRow row in dtStress.Rows)
            {
                maxWidth = Math.Max(maxWidth, g.MeasureString((string) row[STRESSCOL_NAME], dataGrid1.Font).Width);
            }

            dataGrid1.TableStyles[0].GridColumnStyles[STRESSCOL_NAME].Width = ((int) maxWidth) + 5;
        }

        //private ArrayList TPS120Values = new ArrayList(120);

        private void UpdateGUI()
        {
            try
            {
                int i = 0;
                float newRealTPS = 0;
                float newCurrentShortTPS = 0;
                float newCurrentTPS = 0;
                float newCurrentTPS120 = 0;
                if (StressJobs!=null && dtStress.Columns.Count>0 && dtStress.Rows.Count>0)
                {
                    foreach(StressJob job in StressJobs)
                    {
                        if (dataGrid1.CurrentRowIndex == i && (dataGrid1.CurrentCell.ColumnNumber==STRESSCOL_TARTPS || dataGrid1.CurrentCell.ColumnNumber==STRESSCOL_PRI) )
                        {
                            i++;
                            continue;
                        }

                        DataRow r = dtStress.Rows[i];
                        r["Passed"]=job.Results.Passed;
                        r["Failed"]=job.Results.Failed;
                        r[STRESSCOL_INPROGRESS] = job.Results.InProgress + " / "+job.Results.Threads;

                        // Begin new stuff
                        job.Results.TakeSample();

                        newRealTPS += job.Results.TPS();
                        newCurrentShortTPS += job.Results.RunningShortTPS();
                        newCurrentTPS += job.Results.RunningTPS();
                        newCurrentTPS120 += job.Results.RunningTPS120();
                        r["TPS"] = job.Results.RunningTPS().ToString("F2");
                        r["PrivateTPS"] = job.Results.RunningPrivateTPS().ToString("F2");
                        r["Rate"] = job.Results.Total == 0 ? "-" : (job.Results.PassRate*100).ToString("F2")+"%";
                        //r["TargetTPS"] = job.TargetTPS.ToString("F2");

                        i++;
                    }
                }

                lock (realTPSLock)
                {
                    realTPS = newRealTPS;
                }
                lock (currentShortTPSLock)
                {
                    currentShortTPS = newCurrentShortTPS;
                }
                lock (currentTPSLock)
                {
                    currentTPS = newCurrentTPS;
                }
                lblTotalTPSOut.Text = CurrentTPS.ToString("F2").PadLeft(6);
                lock (currentTPS120Lock)
                {
                    currentTPS120 = newCurrentTPS120;
                }
                lblTPS120Out.Text = CurrentTPS120.ToString("F2").PadLeft(6);

                lastUpdate = DateTime.Now;

                // - priority schedular stuff
                if (scheduler is StressSchedulerPriority)
                {
                    StressSchedulerPriority psched=(StressSchedulerPriority)scheduler;

                    //validate each param before we set it
                    if (psched.ThrottlingDelay>0)
                    {
                        tThrottle.Value=(decimal) (1000.0/psched.ThrottlingDelay);
                    }
                    else
                    {
                        Global.RO.Warn("stressgui pri: psched.ThrottlingDelay <=0");
                    }

                    cbThrottle.Checked=psched.ThrottlingEnabled;

                    if (psched.MaxThreads>0)
                    {
                        nMaxThreads.Value=psched.MaxThreads;
                    }
                    else
                    {
                        Global.RO.Warn("stressgui pri: psched.MaxThreads <=0");
                    }

                    //
                    if (psched.Running)
                        tCurrentThreads.Text = psched.NumThreads.ToString() + " / "+psched.MaxThreads;
                    else
                        tCurrentThreads.Text = psched.MaxThreads.ToString();  
                }

                // - TODO: fixup the timer function so it works on all schedulers. For now it only works on priority
                if (scheduler is StressSchedulerPriority)
                {
                    StressSchedulerPriority psched=(StressSchedulerPriority)scheduler;

                    TimeSpan ts=new TimeSpan(0,0,0,psched.SecondsRemaining,0);
                    lTimeToRun.Text=ts.ToString();
                    
                    lRunTime.Text=new TimeSpan(0,0,0,(int) psched.GetElapsed().TotalSeconds,0).ToString();

                    lEndTime.Text=(DateTime.Now+ts).ToString();
                }

                // - tps schedular stuff
                if (scheduler is StressSchedulerTPS)
                {
                    tpsParamCurrent.Text=settingsTPS.Status_CurrentThreads.ToString();
                    labelSinScaleCurrent.Text=string.Format("{0:f3}",settingsTPS.Status_CurrentSinScalar);
                }

                // -
                if (suites.GetLoadedSuites()!=null && suites.GetLoadedSuites().Length>0)
                    lSuiteName.Text=suites.GetLoadedSuites()[STRESSCOL_NAME].Name;
                else
                {
                    Global.RO.Warn("err... no suites loaded... (bad .dll filename maybe?)");
                    lSuiteName.Text="???";
                }
            }
            catch (Exception e) //this should never happen... but just in case...
            {
                Global.RO.Fatal("Exception updating the stress gui.  This should never happen.  Please consider restarting the program.");
                Global.RO.Fatal("Exception: "+e.Message+"\n"+e.StackTrace);
            }
        }

        private void StressGUI_Load(object sender, System.EventArgs e)
        {
            UpdateGUI();        
        }

        private void bSetTime_Click(object sender, System.EventArgs e)
        {
            fSetTime fs=new fSetTime();
            fs.Time=((StressSchedulerPriority)scheduler).EndTime;
            fs.ShowDialog();
            if (fs.DialogResult==DialogResult.OK)
            {
                if (fs.Time<DateTime.Now)
                {
                    MessageBox.Show("Failed to set stress end time (time < Now)");
                    return;
                }
                ((StressSchedulerPriority)scheduler).EndTime=fs.Time;
                UpdateGUI();
            }
        }

        private void nMaxThreads_ValueChanged(object sender, System.EventArgs e)
        {
            if (scheduler!=null && scheduler is StressSchedulerPriority)
            {
                int numThreads = (int)nMaxThreads.Value;
                if (numThreads>0)
                {
                    ((StressSchedulerPriority)scheduler).MaxThreads = numThreads;
                }
                else
                {
                    Global.RO.Warn("stressgui pri: nMaxThreads_ValueChanged says changed to <= 0... ignoring it");
                }
            }

            if (scheduler!=null && scheduler is StressSchedulerTPS)
            {
                int numThreads = (int)tpsParamMax.Value;
                if (numThreads>0)
                {
                    settingsTPS.MaxThreads = numThreads;
                }
                else
                {
                    Global.RO.Warn("stressgui tps: nMaxThreads_ValueChanged says changed to <= 0... ignoring it");
                }
            }

            UpdateGUI();
        }
        
        private void cbThrottle_CheckedChanged(object sender, System.EventArgs e)
        {
            if (scheduler!=null && scheduler is StressSchedulerPriority)
            {
                tThrottle.Enabled=cbThrottle.Checked;
                ((StressSchedulerPriority)scheduler).ThrottlingEnabled=cbThrottle.Checked;
            }
        }

        private void cbSinScale_CheckedChanged(object sender, System.EventArgs e)
        {
            if (scheduler!=null && scheduler is StressSchedulerTPS)
            {
                settingsTPS.SinWaveEnabled=cbSinScale.Checked;

                //enable/disable related controls
                tpsSinScaleMag.Enabled=cbSinScale.Checked;
                tpsSinPeriod.Enabled=cbSinScale.Checked;
                tpsSinPhase.Enabled=cbSinScale.Checked;
                label88SinMag.Enabled=cbSinScale.Checked;
                label88SinPeriod.Enabled=cbSinScale.Checked;
                label88SinPhase.Enabled=cbSinScale.Checked;
                labelSinMag.Enabled=cbSinScale.Checked;
                labelSinPeriod.Enabled=cbSinScale.Checked;
                labelSinPhase.Enabled=cbSinScale.Checked;
            }
        }

        private void tThrottle_ValueChanged(object sender, System.EventArgs e)
        {
            if (scheduler!=null && scheduler is StressSchedulerPriority)
            {
                settingsPriority.ThrottlingTps = (int)tThrottle.Value;
                ((StressSchedulerPriority)scheduler).ThrottlingDelay=1000.0/(double)tThrottle.Value;
            }
        }

        private void dtStress_ColumnChanged(object sender, DataColumnChangeEventArgs e)
        {
            // Priority column
            if (e.Column.Ordinal == STRESSCOL_PRI)
            {
                foreach(StressJob job in StressJobs)
                {
                    if (e.Row[STRESSCOL_NAME] == (object)job.Name)
                        job.Priority = Convert.ToSingle(e.Row[STRESSCOL_PRI]);
                }

                //Global.RO.Debug("Priorities have changed.");
                //foreach(StressJob job in StressJobs)
                //    Global.RO.Debug("Job: {0}, Priority: {1}", job.Name, job.Priority);
            }
                // Target TPS column
            else if (e.Column.Ordinal == STRESSCOL_TARTPS)
            {
                foreach (StressJob job in StressJobs)
                {
                    if (e.Row[STRESSCOL_NAME] == (object)job.Name)
                        job.TargetTPS = Convert.ToSingle(e.Row[STRESSCOL_TARTPS]);
                }
                //Global.RO.Debug("TargetTPS has changed...");
                //foreach (StressJob job in StressJobs)
                //    Global.RO.Debug("Job: {0}, TargetTPS: {1}", job.Name, job.TargetTPS);
            }
        }

        private void dataGrid1_CurrentCellChanged(object sender, EventArgs e)
        {
//             inDataGrid = (dataGrid1.CurrentCell.ColumnNumber == 1);
//             if (!inDataGrid)
//             {
//                 // Force DG to lose focus. What a horrible hack
//                 dataGrid1.Enabled=false;
//                 dataGrid1.Enabled=true;
//             }
         }

        private void dataGrid1_Enter(object sender, System.EventArgs e)
        {
//             inDataGrid = (dataGrid1.CurrentCell.ColumnNumber == 1);
        }

        private void dataGrid1_Leave(object sender, System.EventArgs e)
        {
//             inDataGrid = false;
            UpdateGUI();
        }

        private void btnStartWeekend_Click(object sender, System.EventArgs e)
        {
            settingsPriority.UseResultsHtml = true;

            DateTime monday = DateTime.Today + new TimeSpan(1, 4, 0, 0);
            while (monday.DayOfWeek != DayOfWeek.Monday)
                monday += new TimeSpan(1, 0, 0, 0);

            ((StressSchedulerPriority)scheduler).EndTime = monday;
            UpdateGUI();
        }

        private void StressGUI_Closing(object sender, CancelEventArgs e)
        {
            try
            {
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.StressWindowTopKeyName, this.Top.ToString());
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.StressWindowLeftKeyName, this.Left.ToString());
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.StressWindowWidthKeyName, this.Width.ToString());
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.StressWindowHeightKeyName, this.Height.ToString());
                Global.CommonAppDataRegistry.SetValue(RunnerGlobal.StressWindowSplitterRatioKeyName, this.sbarPositionRatio.ToString());
            }
            catch(Exception ex)
            {
                Global.RO.Error(ex.GetType().FullName + " trying to open the registry key: " + Global.CommonAppDataRegistry.Name + ", message: " + ex.Message);
            }
        }

        public void AddLogViewIfRemoved()
        {
            if (cbLogView.CheckState == CheckState.Unchecked)
            {
                cbLogView.CheckState = CheckState.Checked;
            }
        }

        private void cbLogView_CheckedChanged(object sender, System.EventArgs e)
        {
            if (cbLogView.CheckState == CheckState.Checked)
            {
                Report.GetRoot().SetLevelFilter(Report.FILTER_ALL);
            }
            else
            {
                Report.GetRoot().SetLevelFilter(0);
            }
        }

        private void splitter1_Move_Delegate (object o, System.EventArgs e)
        {
            if (this.ClientRectangle.Size.Height > 0)
            {
                sbarPositionRatio = (float) splitter1.SplitPosition / this.ClientRectangle.Size.Height;
                if (sbarPositionRatio < 0.05f) sbarPositionRatio = 0.05f;
                if (sbarPositionRatio > 0.95f) sbarPositionRatio = 0.95f;
            }
        }

        private void wireDataFuzzingToolStripMenuItem_Click (object sender, EventArgs e)
        {
            // thread safety through invoke, not that we care too much if we make two of these
            if (wdFuzzForm == null)
            {
                wdFuzzForm = new ServerTestFramework.Utilities.WireDataFuzzForm();
            }

            wdFuzzForm.Show();
            wdFuzzForm.BringToFront();
            wdFuzzForm.WindowState = FormWindowState.Normal;
        }

        private void mainMenuStrip_MenuActivate (object sender, EventArgs e)
        {
            mainMenuStrip.Visible = true;
        }

        private void mainMenuStrip_MenuDeactivate (object sender, EventArgs e)
        {
            mainMenuStrip.Visible = false;
        }

        private void dataGrid1_Navigate(object sender,NavigateEventArgs ne)
        {

        }

        private void schedTps_CheckedChanged(object sender,EventArgs e)
        {
            if (scheduler==null || !(scheduler is StressSchedulerTPS)) ChangeScheduler();
        }

        private void schedPri_CheckedChanged(object sender,EventArgs e)
        {
            if (scheduler==null || !(scheduler is StressSchedulerPriority)) ChangeScheduler();
        }

        //called when the scheduler changes
        private void ChangeScheduler()
        {
            //stop old one
            if (scheduler!=null)
            {
                scheduler.Stop();
                scheduler.Shutdown();
                scheduler=null;
            }

            //setup new one
            if (schedTps.Checked) //choose tps based
            {
                //update gui
                groupTPSParam.Visible=true;
                groupPriParam.Visible=false;

                foreach (DataGridTableStyle dgts in dataGrid1.TableStyles)
                {
                    dgts.GridColumnStyles[STRESSCOL_TARTPS].Width=70;
                    dgts.GridColumnStyles[STRESSCOL_PRI].Width=0;
                }

                //change scheduler
                scheduler = new StressSchedulerTPS();
                scheduler.Initialize(config, suites, StressJobs, settingsTPS);

                //TODO: for now disable the timer gui parts for this scheduler.
                bSetTime.Visible=false;
                btnStartWeekend.Visible=false;
                lTimeToRun.Text="-----";
                lEndTime.Text="-----";

                cbSinScale_CheckedChanged(null,null);
            }
            else //choose old priority based
            {
                //update gui
                groupTPSParam.Visible=false;
                groupPriParam.Visible=true;

                foreach (DataGridTableStyle dgts in dataGrid1.TableStyles)
                {
                    dgts.GridColumnStyles[STRESSCOL_TARTPS].Width=0;
                    dgts.GridColumnStyles[STRESSCOL_PRI].Width=70;
                }

                //change scheduler
                StressSchedulerPriority psched=new StressSchedulerPriority();;
                scheduler = psched;
                scheduler.Initialize(config, suites, StressJobs, settingsPriority);

                //another grr: sync settings with gui
                nMaxThreads.Value = settingsPriority.Threads;
                cbThrottle.Checked = settingsPriority.UseThrottling;
                tThrottle.Value = settingsPriority.ThrottlingTps;
                psched.MaxThreads=(int)nMaxThreads.Value;
                psched.ThrottlingEnabled=cbThrottle.Checked;

                //TODO: temp until timers are moved out of pri scheduler
                bSetTime.Visible=true;
                btnStartWeekend.Visible=true;
                lTimeToRun.Text="";
                lEndTime.Text="";
            }

            //fixup gui
            UpdateGUI();
        }

        private void tpsScaleBar_Scroll(object sender,EventArgs e)
        {
            labelScaleSpeed.Text=100*tpsScaleBar.Value/20 + "%";
            settingsTPS.ScaleTPS=((float)tpsScaleBar.Value/20);
        }

        private void tpsSinScaleMag_Scroll(object sender,EventArgs e)
        {
            labelSinMag.Text=(int)(tpsSinScaleMag.Value) + "%";
            settingsTPS.SinWaveMagnitude=(float)tpsSinScaleMag.Value/100.0f;
        }

        private void tpsSinPeriod_Scroll(object sender,EventArgs e)
        {
            if (tpsSinPeriod.Value==0)
            {
                labelSinPeriod.Text="20 sec";
                settingsTPS.SinWavePeriod=20;
            }
            else if (tpsSinPeriod.Value==1)
            {
                labelSinPeriod.Text="1 min";
                settingsTPS.SinWavePeriod=60;
            }
            else if (tpsSinPeriod.Value==2)
            {
                labelSinPeriod.Text="5 min";
                settingsTPS.SinWavePeriod=60*5;
            }
            else if (tpsSinPeriod.Value==3)
            {
                labelSinPeriod.Text="20 min";
                settingsTPS.SinWavePeriod=60*20;
            }
            else if (tpsSinPeriod.Value==4)
            {
                labelSinPeriod.Text="1 hr";
                settingsTPS.SinWavePeriod=60*60;
            }
            else if (tpsSinPeriod.Value==5)
            {
                labelSinPeriod.Text="4 hrs";
                settingsTPS.SinWavePeriod=60*60*4;
            }
            else if (tpsSinPeriod.Value==6)
            {
                labelSinPeriod.Text="12 hrs";
                settingsTPS.SinWavePeriod=60*60*12;
            }
            else if (tpsSinPeriod.Value==7)
            {
                labelSinPeriod.Text="1 day";
                settingsTPS.SinWavePeriod=60*60*24;
            }
            else
            {
                labelSinPeriod.Text="???";
            }
        }

        private void tpsSinPhase_Scroll(object sender,EventArgs e)
        {
            if (tpsSinPhase.Value==0) labelSinPhase.Text="0";
            else if (tpsSinPhase.Value==1) labelSinPhase.Text="PI/2";
            else if (tpsSinPhase.Value==2) labelSinPhase.Text="PI";
            else if (tpsSinPhase.Value==3) labelSinPhase.Text="3PI/2";
            else labelSinPhase.Text="???";

            settingsTPS.SinWavePhase=(float)tpsSinPhase.Value*(float)Math.PI/2;
        }

        private void tpsReservedFastPercentBar_Scroll(object sender,EventArgs e)
        {
            labelFastThreadPercent.Text=tpsReservedFastPercentBar.Value + "%";
            settingsTPS.ReserveHighTPSThreadRatio=((float)tpsReservedFastPercentBar.Value/100);
        }

        private void label2_Click(object sender,EventArgs e)
        {

        }

        private void cbFastUI_CheckedChanged(object sender,EventArgs e)
        {
            if (cbFastUI.Checked) asyncAction.TimerInterval=200;
            else asyncAction.TimerInterval=1000;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFService\AsyncSocket.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;

namespace STFService
{
	// State object for reading client data asynchronously
	public class StateObject 
	{
		// Client  socket.
		public Socket workSocket = null;
		// Size of receive buffer.
		public const int BufferSize = 1500;
		// Receive buffer.
		public byte[] buffer = new byte[BufferSize];
		// Received data string.
		public StringBuilder sb = new StringBuilder();  
	}

	public class AsynchronousSocketListener 
	{
    
		// Incoming data from client.
		public static string data = null;
		public static TestConfig localConfig;

		// Thread signal.
		public static ManualResetEvent allDone = new ManualResetEvent(false);

		public AsynchronousSocketListener() 
		{
		}

		public static void CopyFile(string src, string dest) 
		{
			try 
			{
				// Create the file and clean up handles.
				using (FileStream fs = File.Create(src)) {}

				// Ensure that the target does not exist.
				File.Delete(dest);

				// Copy the file.
				File.Copy(src, dest);
				Console.WriteLine("{0} copied to {1}", src, dest);
			}

			catch 
			{
				Console.WriteLine("Double copy is not allowed.");
			}
		}

		
		private static bool ConfirmCommand(String command)
		{
			String cmd = command.ToLower();
			// Only the following commands are valid
			// Copy latest build
			if(cmd.Equals("getlatest"))
				return true;
			// Copy build X
			if(cmd.IndexOf("getbuild") == 0)
				return true;
			// STFRunner commands
			if(cmd.IndexOf("stfrunner") == 0)
				return true;
			return false;
		}

		private static void DoWork(String command)
		{
			String cmd = command.ToLower();
			if(cmd.Equals("getlatest") || cmd.IndexOf("getbuild") == 0)
			{
				// Look at the build share and figure out what 
				// the latest build is.
				
				// Copy files to the local machine
				// File.Copy(localConfig.serverPath+localConfig.buildVersion+"\\test\\stfrunner\\*.*", localConfig.installLocation);
			}
			
			// STFRunner commands
			if(cmd.IndexOf("stfrunner ") == 0)
			{
				string arguments = cmd.Remove(0, 10); // knocks off the stfrunner from the beginning
				// Run the stfrunner command
				Process.Start("stfrunner.exe", arguments);
			}
		}

		public void StartListening(TestConfig TC) 
		{
			// Data buffer for incoming data.
			byte[] bytes = new Byte[1500];

			localConfig = TC;

			// Establish the local endpoint for the socket.
			// The DNS name of the computer
			// running the listener is "host.contoso.com".
			IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress = ipHostInfo.AddressList[0];
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 11042);

			// Create a TCP/IP socket.
			Socket listener = new Socket(AddressFamily.InterNetwork,
				SocketType.Stream, ProtocolType.Tcp );

			// Bind the socket to the local endpoint and listen for incoming connections.
			try 
			{
				listener.Bind(localEndPoint);
				listener.Listen(100);

				while (true) 
				{
					// Set the event to nonsignaled state.
					allDone.Reset();

					// Start an asynchronous socket to listen for connections.
					Console.WriteLine("Waiting for a connection...");
					listener.BeginAccept( 
						new AsyncCallback(AcceptCallback),
						listener );

					// Wait until a connection is made before continuing.
					allDone.WaitOne();
				}

			} 
			catch (Exception e) 
			{
				Console.WriteLine(e.ToString());
			}

			Console.WriteLine("\nPress ENTER to continue...");
			Console.Read();
        
		}

		public static void AcceptCallback(IAsyncResult ar) 
		{
			// Signal the main thread to continue.
			allDone.Set();

			// Get the socket that handles the client request.
			Socket listener = (Socket) ar.AsyncState;
			Socket handler = listener.EndAccept(ar);

			// Create the state object.
			StateObject state = new StateObject();
			state.workSocket = handler;
			handler.BeginReceive( state.buffer, 0, StateObject.BufferSize, 0,
				new AsyncCallback(ReadCallback), state);
		}

		public static void ReadCallback(IAsyncResult ar) 
		{
			String content = String.Empty;
			String confirm = "<Confirm>";
			String invalid = "<Invalid Command>";
        
			// Retrieve the state object and the handler socket
			// from the asynchronous state object.
			StateObject state = (StateObject) ar.AsyncState;
			Socket handler = state.workSocket;

			// Read data from the client socket. 
			int bytesRead = handler.EndReceive(ar);

			if (bytesRead > 0) 
			{
				// Get the command one packet at a time.
				content = Encoding.ASCII.GetString(state.buffer,0,bytesRead);

				// All the data has been read from the 
				// client. Confirm a valid command exists
				if(ConfirmCommand(content))
				{
					// Send the confirm to the client
					Send(handler, confirm);

					// Run the command
					DoWork(content);
				}
				else
				{
					Send(handler, invalid);
				}
			}
		}
    
		private static void Send(Socket handler, String data) 
		{
			// Convert the string data to byte data using ASCII encoding.
			byte[] byteData = Encoding.ASCII.GetBytes(data);

			// Begin sending the data to the remote device.
			handler.BeginSend(byteData, 0, byteData.Length, 0,
				new AsyncCallback(SendCallback), handler);
		}

		private static void SendCallback(IAsyncResult ar) 
		{
			try 
			{
				// Retrieve the socket from the state object.
				Socket handler = (Socket) ar.AsyncState;

				// Complete sending the data to the remote device.
				int bytesSent = handler.EndSend(ar);
				Console.WriteLine("Sent {0} bytes to client.", bytesSent);

				handler.Shutdown(SocketShutdown.Both);
				handler.Close();

			} 
			catch (Exception e) 
			{
				Console.WriteLine(e.ToString());
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFService\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;

namespace STFService
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller serviceInstaller1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
			this.serviceInstaller1 = new System.ServiceProcess.ServiceInstaller();
			// 
			// serviceProcessInstaller1
			// 
			this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
			this.serviceProcessInstaller1.Password = null;
			this.serviceProcessInstaller1.Username = null;
			// 
			// serviceInstaller1
			// 
			this.serviceInstaller1.ServiceName = "STFService";
			this.serviceInstaller1.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.serviceProcessInstaller1,
																					  this.serviceInstaller1});

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\StfRunner\TestTree.cs ===
// If we use image lists, we can put a 16x16 image between the checkbox and the text of each tree node.
// I was thinking of using a cell phone signal strength indicator analogy, but it doesn't really add much 
// value. Maybe if we could make prettier icons or something. For now, the text showing pass percentage
// works just fine. I'm leaving the imagelist code #if'd out.  
//#define USE_IMAGELIST

using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Data;
using System.Reflection;
using System.Xml;
using System.Windows.Forms;
using ServerTestFramework;
using ServerTestFramework.Runner;

namespace STFRunner
{
    public class TestTree : TreeView
    {
        private System.ComponentModel.Container components = null;

        // Default colors for the tree, use the k_* names instead of the colors
        private Color k_PassBackColor       = Color.LightGreen;
        private Color k_FailBackColor       = Color.Red;
        private Color k_FailKnownBackColor  = Color.Orange;
        private Color k_CurrentBackColor    = Color.LightGray;
        private Color k_DefaultBackColor    = Color.White;
        private Color k_DefaultForeColor    = Color.Black;
        private Color k_DisabledForeColor   = Color.Gray;
        private Color k_ErrorForeColor      = Color.Red;

        private ToolTip         toolTip;
        private TestTreeNode    nodeUnderMouse = null;
        private int             oldNodeIndex = -1;

        public TestTreeNode NodeUnderMouse
        {
            get { return nodeUnderMouse; }
            set { nodeUnderMouse=value; }
        }

        public bool AllowFancyTags = true;

#if USE_IMAGELIST
        private ImageList imageList;
#endif


        public TestTree()
        {
            InitializeComponent();

            toolTip = new ToolTip();
            toolTip.InitialDelay = 300;
            toolTip.AutoPopDelay = 8000;
            toolTip.ReshowDelay = 100;
            toolTip.ShowAlways = true;  // always show whether or not the form is active

            
#if USE_IMAGELIST
            imageList = new ImageList();
            imageList.ImageSize = new Size(16, 16);
            imageList.Images.Add(Image.FromFile("lines_0.bmp"));
            imageList.Images.Add(Image.FromFile("lines_1.bmp"));
            imageList.Images.Add(Image.FromFile("lines_2.bmp"));
            imageList.Images.Add(Image.FromFile("lines_3.bmp"));
            imageList.Images.Add(Image.FromFile("lines_4.bmp"));
            imageList.Images.Add(Image.FromFile("lines_5.bmp"));
            imageList.Images.Add(Image.FromFile("lines_6.bmp"));
            imageList.Images.Add(Image.FromFile("lines_7.bmp"));
            imageList.Images.Add(Image.FromFile("lines_8.bmp"));
            this.ImageList = imageList;
            this.ImageIndex = 0;
            this.SelectedImageIndex = 0;
#endif
        }

        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        // fix the broken behaviour for bolded text
        protected override void OnHandleCreated(EventArgs e)
        {
            base.OnHandleCreated(e);

            const int CCM_FIRST = 0x2000;
            const int CCM_SETVERSION = CCM_FIRST + 0x7;

            Message msg = Message.Create(this.Handle, CCM_SETVERSION, new IntPtr(5), new IntPtr(0));
            this.DefWndProc(ref msg);

            this.SetStyle(	ControlStyles.DoubleBuffer
                |ControlStyles.AllPaintingInWmPaint
                |ControlStyles.Opaque,true);
        }

        #region Component Designer generated code
        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            // 
            // TestTree
            // 
            this.CheckBoxes = true;
            this.AfterCheck += new System.Windows.Forms.TreeViewEventHandler(this.TestTree_AfterCheck);
            this.BeforeCheck += new System.Windows.Forms.TreeViewCancelEventHandler(this.TestTree_BeforeCheck);
            this.MouseMove += new MouseEventHandler(this.TestTree_MouseMove);
            this.MouseDown += new MouseEventHandler(this.TestTree_MouseDown);

        }
        #endregion


        private int DoNotEnter=0;
        private void TestTree_AfterCheck(object sender, System.Windows.Forms.TreeViewEventArgs e)
        {
            if (DoNotEnter>0)
            {
                DoNotEnter--;
                return;
            }

            CheckAll(e.Node.Nodes, (e.Node.Checked));

            TreeNode parent=e.Node.Parent;
            while (parent!=null)
            {
                bool hasCheckedKids=false;
                // determine if this parent has any selected nodes
                foreach(TreeNode n in parent.Nodes)
                {
                    if (n.Checked)
                    {
                        hasCheckedKids=true;
                        break;
                    }
                }

                if (hasCheckedKids && parent.Checked==false)
                {
                    DoNotEnter++;
                    parent.Checked=e.Node.Checked;
                }
                if (!hasCheckedKids)
                {
                    DoNotEnter++;
                    parent.Checked=false;
                }
                parent=parent.Parent;
            }		
        }

        private void TestTree_BeforeCheck(object sender, System.Windows.Forms.TreeViewCancelEventArgs e)
        {
            if (e.Node.ForeColor == k_ErrorForeColor)
            {
                MessageBox.Show((string)e.Node.Tag, "Suite could not be loaded.");
                e.Cancel = true;
            }
        }

        // Save node that mouse is over, to allow a hack to make tool tips work for 
        // TreeNodes.
        private void TestTree_MouseMove(object sender, MouseEventArgs e)
        {
            // Find node under mouse
            nodeUnderMouse = (TestTreeNode)this.GetNodeAt(e.X, e.Y);

            if (nodeUnderMouse != null)
            {
                // Did we move nodes?
                if (nodeUnderMouse.Index != oldNodeIndex)
                {
                    // Save old one
                    oldNodeIndex = nodeUnderMouse.Index;

                    if (toolTip.Active)
                    {
                        // Turn it off
                        toolTip.Active = false;
                        toolTip.SetToolTip(this, nodeUnderMouse.ToolTipString);
                        // Turn it back on
                        toolTip.Active = true;
                    }
                    else
                    {
                        toolTip.SetToolTip(this, nodeUnderMouse.ToolTipString);
                    }
                }
            }
        }

        private void TestTree_MouseDown(object sender, MouseEventArgs e)
        {
            nodeUnderMouse = (TestTreeNode)this.GetNodeAt(e.X, e.Y);

            // Right-clicking should also select a node, makes more intuitive sense
            this.SelectedNode = nodeUnderMouse;
        }
        
        private void GenerateSuiteXml(XmlDocument doc, TestTreeNode suiteNode, XmlNode testsNode)
        {
            bool allGroupsChecked = true;
            bool anyTestsChecked = false;
            foreach(TestTreeNode group in suiteNode.Nodes)
            {
                foreach(TestTreeNode test in group.Nodes)
                {
                    if (!group.Checked || !test.Checked)
                        allGroupsChecked = false;
                    else if (group.Checked || test.Checked)
                        anyTestsChecked = true;
                }
            }

            if (!anyTestsChecked)
                return;

            // Suite
            XmlElement		suite=doc.CreateElement("suite");
            XmlAttribute	suiteName=doc.CreateAttribute("name");
            suiteName.Value=suiteNode.TestName;
            suite.Attributes.Append(suiteName);

            testsNode.AppendChild(suite);

            XmlElement functionalNode=doc.CreateElement("functional");
            suite.AppendChild(functionalNode);

            if (allGroupsChecked)
            {
                functionalNode.AppendChild(doc.CreateElement("suite"));
            }
            else
            {
                foreach(TestTreeNode group in suiteNode.Nodes)
                {
                    if (!group.Checked)
                        continue;

                    bool allTestsChecked = true;
                    foreach(TestTreeNode test in group.Nodes)
                        if (!test.Checked)
                            allTestsChecked = false;

                    if (allTestsChecked)
                    {
                        XmlElement		elGroup=doc.CreateElement("group");
                        XmlAttribute	atGroup=doc.CreateAttribute("name");
                        atGroup.Value=group.TestName;
                        elGroup.Attributes.Append(atGroup);
                        functionalNode.AppendChild(elGroup);
                    }
                    else
                    {
                        foreach(TestTreeNode test in group.Nodes)
                        {
                            if (!test.Checked)
                                continue;
                            XmlElement		elTest=doc.CreateElement("test");
                            XmlAttribute	atTestGroup=doc.CreateAttribute("group");
                            atTestGroup.Value=group.TestName;
                            XmlAttribute	atTestName=doc.CreateAttribute("name");
                            atTestName.Value=test.TestName;
                            elTest.Attributes.Append(atTestGroup);
                            elTest.Attributes.Append(atTestName);
                            functionalNode.AppendChild(elTest);
                        }
                    }
                }
            }
        }

        public XmlDocument GenerateConfigFile()
        {
            XmlDocument doc=new XmlDocument();
			
            XmlElement stfNode=doc.CreateElement("stf");
            doc.AppendChild(stfNode);

            XmlElement testsNode=doc.CreateElement("tests");
            stfNode.AppendChild(testsNode);

            foreach(TestTreeNode node in Nodes)
                GenerateSuiteXml(doc, node, testsNode);

            return doc;
        }

        public TestTreeNode GetTreeNode(string suiteName, string groupName, string testName)
        {
            foreach(TestTreeNode suite in Nodes)
            {
                if(suite.TestName == suiteName)
                {
                    if(groupName==null || groupName.Length==0)
                        return suite;

                    foreach(TestTreeNode group in suite.Nodes)
                    {
                        if(group.TestName == groupName)
                        {
                            if(testName==null || testName.Length==0)
                                return group;

                            foreach(TestTreeNode test in group.Nodes)
                            {
                                if(test.TestName == testName)
                                    return test;
                            }
                        }
                    }
                }
            }

            return null;
        }

        public void ResetTreeStatus()
        {
            foreach(TestTreeNode suite in Nodes)
            {
                _ResetTreeStatus_R(suite);
            }

            this.CheckBoxes = AllowFancyTags;
        }

        private void _ResetTreeStatus_R(TestTreeNode node)
        {
            // Do not update tree status for disabled tests
            if(node.ForeColor != k_DisabledForeColor)
            {
                node.Reset();
	
                if(node.Nodes != null && node.Nodes.Count > 0)
                {
                    foreach(TestTreeNode child in node.Nodes)
                    {
                        _ResetTreeStatus_R(child);
                    }
                }
            }
        }

        public void MarkTreeStatus(TestAction action, string suiteName, string groupName, string testName, string resultDetails)
        {
			// May still enter this from receiving a test status event even though 
			// the application is in the process of shutting down.
			if(IsDisposed)
			{
				return;
			}

            BeginUpdate();
            //ignoreEraseBG = true;

            int NodeLevel = 0;
            TestTreeNode node = GetTreeNode(suiteName, groupName, testName);
            node.Details = resultDetails;
            TestTreeNode lastNode = node;
            while(node != null)
            {
                switch(action)
                {
                    case TestAction.Start:
                    {
                        // mark the tree node bold
                        Font currentFont = node.NodeFont;
                        if(currentFont != null)
                            node.NodeFont = new Font(currentFont, currentFont.Style | FontStyle.Bold);
                        else
                            node.NodeFont = new Font(this.Font, FontStyle.Bold);

                        // Only apply to base node, not to parents
                        if (NodeLevel == 0)
                        {
                            node.BackColor = k_CurrentBackColor;
                        }
                    }
                        break;
                    case TestAction.Pass:
                    {
                        node.NodeFont = null;

                        if (NodeLevel == 0)
                        {
                            // Applies to child only
                            node.BackColor = k_PassBackColor;
                        }
                        else
                        {
                            // When child passes, parent only goes from:
                            //   Default to Pass
                            if (node.BackColor == this.k_DefaultBackColor)
                            {
                                node.BackColor = k_PassBackColor;
                            }
                        }

                        node.TestsPassed++;
#if USE_IMAGELIST
                        if (NodeLevel > 0)
                            node.Update(0, this.ImageList.Images.Count - 1);
#endif
                    }
                        break;
                    case TestAction.Fail:
                    {
                        if (NodeLevel == 0)
                        {
                            if (node.BugID != null)
                                node.BackColor = k_FailKnownBackColor;
                            else
                                node.BackColor = k_FailBackColor;
                        }
                        else
                        {
                            // When child fails, parent only goes from:
                            //   Default to Fail/KnownFail
                            //   Pass to Fail/KnownFail
                            //   KnownFail to Fail/KnownFail
                            if (node.BackColor == k_PassBackColor ||
                                node.BackColor == k_DefaultBackColor ||
                                node.BackColor == k_FailKnownBackColor)
                            {
                                node.BackColor = lastNode.BackColor;
                            }
                        }
                            
                        // Applies to child and parents
                        node.NodeFont = null;
                        node.TestsFailed++;
#if USE_IMAGELIST
                        if (NodeLevel > 0)
                            node.Update(0, this.ImageList.Images.Count - 1);
#endif

                    }
                        break;
                    case TestAction.Retry:
                    {
                        // mark the tree node bold
                        Font currentFont = node.NodeFont;
                        if(currentFont != null)
                            node.NodeFont = new Font(currentFont, currentFont.Style | FontStyle.Bold);
                        else
                            node.NodeFont = new Font(this.Font, FontStyle.Bold);

                        // Only apply to base node, not to parents
                        if (NodeLevel == 0)
                        {
                            node.BackColor = k_FailBackColor;
                        }

                        --node.TestsFailed;
                    }
                        break;
                }


                // Walk up the tree through the parents
                lastNode = node;
                node = (TestTreeNode)node.Parent;
                NodeLevel++;
            }

            // redraw labels
            EndUpdate();
            //ignoreEraseBG = false;
        }

        public bool ContainsSuite(string name)
        {
            foreach(TestTreeNode node in Nodes)
            {
                if(node.TestName == name)
                    return true;
            }
            return false;
        }

        public string[] GetEnabledSuiteNames()
        {
            ArrayList al = new ArrayList();

            for (int i = 0; i < Nodes.Count; i++)
                if (Nodes[i].Checked)
                    al.Add(((TestTreeNode)Nodes[i]).TestName);

            return (string[])al.ToArray(typeof(string));
        }


        public void AddSuite(TestSuite suite)
        {
            if (!ContainsSuite(suite.Name))
            {
                // This will be the first time the DLL is referenced, some people assume that they
                // have a full environment setup here and have put test initialization into statics
                // on their suite or groups, this is bad behavior as it makes initialization non-deterministic
                try
                {
                    XmlDocument testDesc = new XmlDocument();
                    testDesc.LoadXml(suite.DescribeTestTree());
                    AddSuiteTestsFromDocument(testDesc);
                }
                catch(Exception ex)
                {
                    // The type of exception caught here is a target invokation exception which is not the root
                    // cause of the problem.
                    if(ex.InnerException != null)
                        ex = ex.InnerException;

                    Global.RO.Error("Critical error referencing suite: " + suite.Name + "\nReason: " + ex.Message + "\nStackTrace: " + ex.StackTrace);
                }
            }
        }

        public void RemoveSuite(string suiteName)
        {
            TestTreeNode node = GetTreeNode(suiteName, null, null);
            node.Remove();
        }

        public void AddSuiteTestsFromDocument(XmlDocument xml)
        {
            this.CheckBoxes = AllowFancyTags;

            if(xml.DocumentElement.Name == "error")
            {
                TestTreeNode failNode=new TestTreeNode(xml.DocumentElement.GetAttribute("name"));
                failNode.ParentTree=this;
                failNode.ForeColor = k_ErrorForeColor;
                failNode.Tag = "Suite " + failNode.TestName + " failed to load because its GetTests method threw the following exception:\n\n" + xml.DocumentElement.ToString();
                Nodes.Add(failNode);
            }
            else
            {
                XmlNodeList groups = xml.DocumentElement.SelectNodes("group");
                ArrayList addGroups = new ArrayList();
	
                foreach (XmlNode group in groups)
                {
                    bool ignoreGroup = false;
                    XmlNodeList tests = group.SelectNodes("test");
                    ArrayList addTests = new ArrayList();

                    XmlElement groupEl = (group as XmlElement);
                    if(groupEl.GetAttribute("ignore") != "")
                    {
                        ignoreGroup = true;
                    }

                    foreach (XmlNode test in tests)
                    {
                        XmlElement testEl = (test as XmlElement);
                        TestTreeNode tn = new TestTreeNode(testEl.GetAttribute("name"));
                        tn.ParentTree=this;
                        tn.NodeLevel = 2;
                        if(ignoreGroup || testEl.GetAttribute("ignore") != "")
                        {
                            if (AllowFancyTags) tn.ForeColor = k_DisabledForeColor;	
                        }

                        string bugid = testEl.GetAttribute("bugid");
                        if (bugid != "")
                        {
                            tn.BugID = bugid;
                        }

                        string desc = testEl.GetAttribute("desc");
                        if (desc != "")
                        {
                            tn.Description = desc;
                        }

                        uint asyncgroup=0;
                        if (testEl.GetAttribute("asyncgroup").Length!=0)
                        {
                            asyncgroup=uint.Parse(testEl.GetAttribute("asyncgroup"));
                        }
                        tn.AsyncGroup = asyncgroup;

                        addTests.Add(tn);
                    }
					
                    TestTreeNode groupTn = new TestTreeNode(groupEl.GetAttribute("name"), (TreeNode []) addTests.ToArray(typeof(TestTreeNode)));
                    groupTn.ParentTree=this;
                    groupTn.NodeLevel = 1;
                    groupTn.ShowPassFail = true;
                    if(ignoreGroup)
                    {
                        if (AllowFancyTags) groupTn.ForeColor = k_DisabledForeColor;
                    }

                    if (groupEl.GetAttribute("asyncset").Length!=0)
                    {
                        groupTn.AsyncSet=uint.Parse(groupEl.GetAttribute("asyncset"));
                    }

                    addGroups.Add(groupTn);
                }
				
                TestTreeNode suiteNode=new TestTreeNode(xml.DocumentElement.GetAttribute("name"), 
                    (TreeNode []) addGroups.ToArray(typeof(TestTreeNode)));
                suiteNode.ParentTree=this;
                suiteNode.NodeLevel = 0;
                suiteNode.ShowPassFail = true;

                Nodes.Add(suiteNode);

                // Every Suite node should start off expanded, in my opinion
                suiteNode.Expand();
            }
        }

        public void	ClearAllChecks()
        {
            this.SuspendLayout();
            foreach(TestTreeNode n in Nodes)
            {
                n.Checked=false;
            }
            this.ResumeLayout();
        }

        private void CheckAll(TreeNodeCollection col, bool newValue)
        {
            this.SuspendLayout();
            foreach (TreeNode node in col)
            {
                node.Checked=newValue;
                CheckAll(node.Nodes, newValue);
            }
            this.ResumeLayout();
        }

        public void CheckNode(TestTreeNode node, bool newValue, bool bRecursive)
        {
            node.Checked = newValue;
            if (bRecursive)
            {
                CheckAll(node.Nodes, newValue);
            }
        }

        public void ExpandCheckedNodes()
        {
            // Only expand suites and groups
            foreach (TreeNode n in Nodes)
            {
                if (n.Checked)
                {
                    // Expand this (suite node)
                    n.Expand();
                    
                    // Expand children (group node)
                    foreach (TreeNode n2 in n.Nodes)
                    {
                        if (n2.Checked)
                        {
                            n2.Expand();
                        }
                    }
                }
            }
        }

        // Load saved state from the merged config XML document
        public void LoadState()
        {
            LoadState(Global.Config);
        }

        public void LoadState(System.Xml.XmlDocument xmldoc)
        {
            XmlNodeList funcRoots = xmldoc.SelectNodes("stf/tests/suite/functional");

            // Iterate through each 'functional' section
            foreach (XmlNode funcRoot in funcRoots)
            {
                XmlElement suiteEl = (funcRoot.ParentNode as XmlElement);
                foreach (XmlNode node in funcRoot.ChildNodes)
                {
                    XmlElement nodeEl = (node as XmlElement);
                    TestTreeNode treeNode = null;
                    if (node.Name == "test")
                    {
                        treeNode = GetTreeNode(suiteEl.GetAttribute("name"), nodeEl.GetAttribute("group"), nodeEl.GetAttribute("name"));
                    }
                    else if (node.Name == "group")
                    {
                        treeNode = GetTreeNode(suiteEl.GetAttribute("name"), nodeEl.GetAttribute("name"), null);
                    }
                    else if (node.Name == "suite")
                    {
                        treeNode = GetTreeNode(suiteEl.GetAttribute("name"), null, null);
                    }

                    if(treeNode != null)
                    {
                        treeNode.Checked = true;
                        CheckAll(treeNode.Nodes, true);
                    }

                }
            }
        }

        public void PruneChecksToFailedTests()
        {
            PruneChecksToFailedTests(this.Nodes);
        }

        protected void PruneChecksToFailedTests(TreeNodeCollection nodes)
        {
            foreach(TreeNode n in nodes)
            {
                // If checked but not marked as failed, uncheck the node
                if (n.Checked && !(n.BackColor==k_FailBackColor || n.BackColor==k_FailKnownBackColor))
                {
                    n.Checked = false;
                }
                // Recurse over children
                PruneChecksToFailedTests(n.Nodes);
            }
        }

    }


    public class TestTreeNode : TreeNode
    {
        public bool         ShowPassFail    = false;
        public int          NodeLevel       = 0;        // 0=suite, 1=group, 2=test

        private string      _BugID          = null;
        private int         _TestsPassed    = 0;
        private int         _TestsFailed    = 0;
        private string      _TestName       = null;
        private string      _Description    = null;
        private string      _Details        = null;
        private uint        _AsyncGroup     = 0;
        private uint        _AsyncSet       = 0;
        private uint        _AsyncSuite     = 0;
        private TestTree    _Tree           = null;

        public string BugID
        {
            get { return _BugID; }
            set { _BugID = value; UpdateText(); }
        }

        public int TestsPassed
        {
            get { return _TestsPassed; }
            set { _TestsPassed = value; UpdateText(); }
        }

        public int TestsFailed
        {
            get { return _TestsFailed; }
            set { _TestsFailed = value; UpdateText(); }
        }

        public TestTree ParentTree
        {
            get { return _Tree; }
            set { _Tree=value; }
        }

        /// <summary>
        /// The actual name of the test, determined by reflection. Use this when getting/setting test names.
        /// </summary>
        public string TestName
        {
            get 
            { 
                if (_TestName == null)
                    _TestName = base.Text;
                return _TestName; 
            }
            set 
            { 
                _TestName = value;
                UpdateText();
            }
        }
    
        /// <summary>
        /// Test description, from Description attribute, to be displayed when mouse hovers
        /// </summary>
        public string Description
        {
            get { return _Description; }
            set { _Description = value; }
        }

        /// <summary>
        /// AsyncGroup - Tests within the same group that have the same value can be run at the same time.
        /// </summary>
        public uint AsyncGroup
        {
            get { return _AsyncGroup; }
            set { _AsyncGroup=value; UpdateText(); }
        }

        /// <summary>
        /// AsyncSet - Groups with same value can be run at the same time.
        /// </summary>
        public uint AsyncSet
        {
            get { return _AsyncSet; }
            set { _AsyncSet=value; UpdateText(); }
        }

        /// <summary>
        /// AsyncSuite - Suites with same value can be run at the same time.
        /// </summary>
        public uint AsyncSuite
        {
            get { return _AsyncSuite; }
            set { _AsyncSuite=value; UpdateText(); }
        }

        /// <summary>
        /// Test details, usually the exception text when a test fails
        /// </summary>
        public string Details
        {
            get { return _Details; }
            set { _Details = value; }
        }

        /// <summary>
        /// Handy string for displaying the tooltip text
        /// </summary>
        public string ToolTipString
        {
            get 
            {
                if (Details == null)
                    return Description;
                else if (Description == null)
                    return Details;
                else
                    return Description + "\n" + Details;
            }
        }

        /// <summary>
        /// Handy string for displaying bug id
        /// </summary>
        public string BugString
        {
            get { return "(bug " + BugID + ")"; }
        }

        /// <summary>
        /// Handy string for displaying pass/fail percentage
        /// </summary>
        public string PassFailString
        {
            get { return "[" + TestsPassed + "/" + (TestsPassed + TestsFailed) + "]"; }
        }

        /// <summary>
        /// Calculates the passing percentage rate
        /// </summary>
        public float PercentPassed
        {
            get { return (float)((float)TestsPassed / (float)(TestsPassed + TestsFailed)); }
        }

        /// <summary>
        /// String representation of the NodeLevel
        /// </summary>
        public string TestTypeString
        {
            get
            {
                return (
                    NodeLevel == 0 ? "Suite" :
                    NodeLevel == 1 ? "Group" :
                    NodeLevel == 2 ? "Test" :
                    "<Unknown>"
                    );
            }
        }

        public bool Ignored
        {
            set
            {
                //us
                ForeColor=(value?Color.Gray:Color.Black);
                UpdateText();

                //undo parent's ignore if it's on
                if (Parent!=null && !value)
                {
                    ((TestTreeNode)Parent).Ignored=false;
                }
            }
        }

        /// <summary>
        /// The name of the test plus additional information, like passing rate and bug id. Should
        /// be used only for display.
        /// </summary>
        public new string Text 
        {
            get 
            {
                bool fancy=true;
                if (_Tree!=null && _Tree.AllowFancyTags==false)
                    fancy=false;

                string str = null;
                if (ShowPassFail && fancy)
                    str = PassFailString + " " + TestName;
                else
                    str = TestName;
                
                if (fancy)
                {
                    if (BugID != null)
                        str += " " + BugString;

                    if (AsyncSuite!=0)
                        str += "   [AsyncSuite="+AsyncSuite+"]";

                    if (AsyncSet!=0)
                        str += "   [AsyncSet="+AsyncSet+"]";

                    if (AsyncGroup!=0)
                        str += "   [AsyncGroup="+AsyncGroup+"]";
                }

                return str;
            }
            set 
            { 
                TestName = value; 
            }
        }


        public TestTreeNode(string label) : 
            base(label)
        {
        }

        public TestTreeNode(string label, TreeNode[] nodes) :
            base(label, nodes)
        {
        }

        /// <summary>
        /// Update node's image index, assumes imagelist has a range of icons representing various
        /// passing percentages.
        /// </summary>
        /// <param name="startIdx">First element of image list representing 0% passing</param>
        /// <param name="stopIdx">Last element of image list representing 100% passing</param>
        public void Update(int startIdx, int stopIdx)
        {
            // Update image
            float p = PercentPassed;
            float range = stopIdx - startIdx;
            //int imgbucket = (int)(p * (float)(this.ImageList.Images.Count - 1));
            int imgbucket = (int)(p * range);
            ImageIndex = imgbucket;
        }

        /// <summary>
        /// This is required to make the TreeView show our new node Text.  Apparently touching 
        /// base.Text causes this to happen. This is also required because we did a 'new Text' 
        /// property instead of 'override Text'. Can't control that..
        /// </summary>
        private void UpdateText()
        {
			base.Text = this.Text;
        }

        public void Reset()
        {
            bool bNeedToUpdate = false;
            if (_TestsPassed != 0 || _TestsFailed != 0)
                bNeedToUpdate = true;

            _TestsPassed = 0;
            _TestsFailed = 0;
            ForeColor = Color.Black;
            BackColor = Color.White;
            NodeFont = null;
            ImageIndex = 0;
            Details = null;  // clear out any exception text

            if (bNeedToUpdate)
                UpdateText();
        }

        //gets the name of every node from this one up to the root suite
        public void GetNodeHierarchyNames(out string outSuiteName, out string outGroupName, out string outCaseName)
        {
            outSuiteName=outGroupName=outCaseName="";

            if (NodeLevel==0) //suite
            {
                outSuiteName=TestName;
            }
            else if (NodeLevel==1) //group
            {
                outGroupName=TestName;
                outSuiteName=(Parent as TestTreeNode).TestName;
            }
            else if (NodeLevel==2) //case
            {
                outCaseName=TestName;
                outGroupName=(Parent as TestTreeNode).TestName;
                outSuiteName=((Parent as TestTreeNode).Parent as TestTreeNode).TestName;
            }
        }

    } //TestTreeNode

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFService\Service.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration;
using System.Data;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Schema;
using System.Diagnostics;
using System.ServiceProcess;
using ServerTestFramework;
using STFRunner;

namespace STFService
{
	public class STFService : System.ServiceProcess.ServiceBase
	{
		public static TestConfig TC;
		public AsynchronousSocketListener ASL;

		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public STFService()
		{
			// This call is required by the Windows.Forms Component Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitComponent call
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;
	
			// More than one user Service may run within the same process. To add
			// another service to this process, change the following line to
			// create a second service object. For example,
			//
			//   ServicesToRun = new System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
			//
			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new STFService() };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);

			TC = new TestConfig();
			if(TC.Init())
			{
				TC.bRunning = true;
			
				AsynchronousSocketListener ASL = new AsynchronousSocketListener();
				ASL.StartListening(TC);
			}
			else
			{
				Console.WriteLine("Initialization failed.");
			}
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
			this.ServiceName = "STFService";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			// Determine if we need to run the installer
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			// TODO: Add code here to perform any tear-down necessary to stop your service.
			TC.bRunning = false;
		}

	}

	public class TestConfig
	{
		public StfXmlDoc Config;
		public bool bRunning;
		public string serverPath;
		public string binaryType;
		public string buildVersion;
		public string installLocation;
		public string latestTxt;
		public uint kVersionLength;

		public TestConfig()
		{
			kVersionLength = 9;
		}

		// Reads the xml config file and assigns config values
		public bool Init()
		{
			try 
			{
				Config = new StfXmlDoc();
				try
				{
					Config.Merge(new StfXmlDoc("stfservice.xml"), "/stfservice");
				}
				catch (XmlException e)
				{
					Console.WriteLine(e.ToString());
					return false;
				}

				XmlNode Server = Config.SelectSingleNode("/stfservice/config/server");
				if(Server != null)
				{
					serverPath = Server.Attributes["location"].Value;
				}
				else
				{
					return false;
				}
				
				// This is the name of the file that contains the latest version which
				// is also the build directory
				Server = Config.SelectSingleNode("/stfservice/config/latest");
				if(Server != null)
				{
					latestTxt = Server.Attributes["name"].Value;
					// open the latestTxt file and save the build version
					using (FileStream fs = File.Open(serverPath+latestTxt, FileMode.Open, FileAccess.Read, FileShare.None)) 
					{
						byte[] b = new byte[kVersionLength];	// The version will always be 9 chars
						UTF8Encoding temp = new UTF8Encoding(true);

						if(fs != null)
						{
							fs.Read(b,0,b.Length);
							buildVersion = temp.GetString(b);
						}
						else
						{
							Console.WriteLine("Cannot open version file: "+serverPath+latestTxt);
							return false;
						}
					}
				}
				else
				{
					return false;
				}

				// This is the local directory on the service machine that will contain
				// the STF binaries and test dlls
				Server = Config.SelectSingleNode("/stfservice/config/install");
				if(Server != null)
				{
					installLocation = Server.Attributes["location"].Value;
				}
				else
				{
					return false;
				}
				
				// In case the user wants to specify a specific version, use this field
				// it will override what was read from the latest.txt file above
				Server = Config.SelectSingleNode("/stfservice/config/build");
				if(Server != null)
				{
					buildVersion = Server.Attributes["version"].Value;
				}

				// retail or debug
				Server = Config.SelectSingleNode("/stfservice/config/type");
				if(Server != null)
				{
					binaryType = Server.Attributes["type"].Value;
				}
				else
				{
					return false;
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
				return false;
			}

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LegacyCode\STFService\StfXmlDoc.cs ===
using System;
using System.Xml;

namespace STFRunner
{
	public class StfXmlDoc : XmlDocument
	{
		public StfXmlDoc() : base()
		{
		}

		public StfXmlDoc(string fileName) : base()
		{
			Load(fileName);
		}

		public void Merge(XmlDocument doc, string pathToMerge)
		{
			XmlNode myRoot = SelectSingleNode(pathToMerge);
			if (myRoot == null)
			{
				AppendChild(ImportNode(doc.SelectSingleNode(pathToMerge), true));
			}
			else
			{
				foreach (XmlNode child in doc.SelectSingleNode(pathToMerge).ChildNodes)
				{
					XmlNode localChild = ImportNode(child, true);
					myRoot.AppendChild(localChild);
				}
			}
		}

		public XmlNode AddPath(string xpath)
		{
			xpath = xpath.TrimStart(new char[] {'/'});
			string[] pieces = xpath.Split(new char[] {'/'});
			string path = "/";
			XmlNode node = this;

			for (int i = 0; i < pieces.Length; i++)
			{
				path += "/" + pieces[i];
				XmlNode child = node.SelectSingleNode(path);
				if (child == null)
				{
					child = this.CreateElement(pieces[i]);
					node.AppendChild(child);
				}

				node = child;
			}

			return node;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\General.cs ===
using ServerTestFramework;

namespace xonline.test.stftests.LiveBVT
{
    [TestGroup, TestCasePriority(1)]
    public class General: TestNode
    {
        [TestCase, LiveLKG, Owner("LukeL"), TestFrequency("BVT"), TestCasePriority(1), Description("This is not a test of any functionality.  It is here to gather information on the machine running the tests.")]
        public void CollectInformation()
        {
            DumpLogin();
            DumpStfEnvironment();
            DumpProxy();
            DumpWebstore();
        }

        void DumpLogin()
        {
            try
            {
                Global.RO.Info("Current user: "+System.Security.Principal.WindowsIdentity.GetCurrent().Name);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Failed to check current user: "+e);
            }
        }

        void DumpStfEnvironment()
        {
            try
            {
                Global.RO.Info("Current environment: "+Global.XEnv.GetEnv());
                Global.RO.Info("STF Environment: "+Global.CurrentEnvironment);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Failed to check current environment: "+e);
            }
        }

        void DumpProxy()
        {
            try
            {
                Microsoft.Win32.RegistryKey key=Microsoft.Win32.Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", false);
                object valServer=key.GetValue("ProxyServer");
                object valEnabled=key.GetValue("ProxyEnable");
                Global.RO.Info("Proxy settings in registry: Server="+valServer+" Enabled="+valEnabled);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Failed to check proxy in registry: "+e);
            }
        }

        void DumpWebstore()
        {
            //UODB
            string uodbServers="";
            try
            {
                string applicationName=xonline.common.sql.webstore.WSClient.SiteName+xonline.common.config.ConfigUtil.UodbWebstoreApp;
                using (Microsoft.Webstore.WstClient.WstConnection con=new Microsoft.Webstore.WstClient.WstConnection(applicationName))
                {
                    con.Open();

                    foreach (Microsoft.Webstore.MetaData.WebstoreSQLFss fss in con.SqlPartitions)
                    {
                        foreach (Microsoft.Webstore.MetaData.WebstoreDatabase wsdb in fss.Databases)
                        {
                            if (uodbServers.Length>0)
                            {
                                uodbServers+=", ";
                            }

                            uodbServers+=wsdb.ServerName+"("+wsdb.Name+")";
                        }
                    }
                }
            }
            catch (System.Exception e)
            {
                uodbServers+="- Unexpected exception: "+e;
            }
            Global.RO.Info("Webstore UODB Servers: "+uodbServers);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\LiveFoundation.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Net;
using System.Net.Cache;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Security.Cryptography.X509Certificates;

using live.client;
using live.common;
using live.internaltest;
using live.lfm;
using live.lfm.xbox360Internal;
using live.protocol;
using live.server;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.XCrypto;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.LiveInfo;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

using RandomEx = ServerTestFramework.Core.Utilities.RandomEx;
using XOService = ServerTestFramework.LiveService.XOService;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;
using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;
using XSigSignature = xonline.common.protocol.XSigSignature;
using XUserTests;
using xonline.xuser.soap;

namespace xonline.test.stftests.LiveBVT
{
    [TestGroup, TestCasePriority(1)]
    public class LiveFoundation : TestNode
    {
        ///////////////////////////////////////////////////////////////////////
        //
        //  User Creation BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class CreateUser : TestNode
        {
            [TestCase, Owner("stevewar"), TestFrequency("BVT"), EnvRequirement(""), TestCasePriority(1)]
            [LiveLKG]
            public class CreatePassport : TestNode
            {
                public override void Run()
                {
                    for(int ii=1; ii<=10; ii++)
                    {
                        XRLXePassportCreate request = new XRLXePassportCreate();
                        XRLXePassportCreateResponse response;

                        try
                        {

                            string memberName     = "xbltest-" + Guid.NewGuid().ToString()  + Global.PassportMemberDomain;
                            string password       = "foobar";
                            string secretQuestion = "What color car do you drive?";
                            string secretAnswer   = "Hot smoking pink!";

                            request.PassportMemberName = memberName;
                            request.SecretQuestion = secretQuestion;

                            PassportTestClient passport = new PassportTestClient();
                            passport.Init();
                            passport.GenerateEncryptedCredentials("", password, secretAnswer, out request.EncryptedPassword);

                            Global.RO.Info("Creating passport user: {0}...", memberName);

                            request.Slot.userPuid0 = 0;
                            request.Slot.machinePuid = 0xFA00000000000001;

                            if (!request.Execute(out response)) throw new Exception(request.GetDumpString());
                            if (request.XErr != ServerTestFramework.LiveService.HResult.S_OK) throw new Exception(request.GetDumpString());

                            Global.RO.Info("Creating passport passed");

                            break;
                        }
                        catch(Exception ex)
                        {
                            Global.RO.Warn("Creating passport failed {0}", ii);
                            Thread.Sleep(60000);
                            if(ii == 10)
                                throw new UnexpectedTestResultException(ex.Message);
                        }
                    }
                }
            }

            [TestCase, Owner("yixuanl"), TestFrequency("BVT"), EnvRequirement("Billing"), TestCasePriority(1)]
            [LiveLKG]
            public class CreateLiveAccount : TestNode
            {
                public override void Run()
                {
                    for(int ii=1; ii<=10; ii++)
                    {
                        try
                        {
                            Global.RO.Info("Creating Live Account with Fake Passport...");

                            XeUser user = new XeUser(false);
                            ulong puid = user.Create();

                            Global.RO.Info("Creating Live Account passed");

                            break;
                        }
                        catch(Exception ex)
                        {
                            Global.RO.Warn("Creating Live Account failed {0}", ii);
                            Thread.Sleep(60000);
                            if(ii == 10)
                                throw new UnexpectedTestResultException(ex.Message);
                        }
                    }
                }
            }

            [TestCase, Owner("yixuanl"), TestFrequency("BVT"), TestCasePriority(1), EnvRequirement("Billing")]
            [LiveLKG]
            public class CreateUserAndBillableAccount : TestNode
            {
                public override void Run()
                {
                    XRLCreateUserAndBillableAccount xrl = new XRLCreateUserAndBillableAccount();
                    UacsCommon uc = new UacsCommon();
                    UacsCommon.PassportUser passportUser = uc.CreatePassportUser();
                    xrl.Request.signedUserPassportPuid = passportUser.SessionToken;
                    xrl.Request.signedOwnerPassportPuid = passportUser.SessionToken;
                    xrl.Request.birthdate = DateTime.Now.AddYears(-23);
                    xrl.Request.email = passportUser.MemberName;
                    xrl.Request.languageId = 1;              // English
                    xrl.Request.countryId = 103;             // US
                    xrl.Request.msftOptIn = false;
                    xrl.Request.partnerOptIn = false;
                    xrl.Request.isFreeGamertagChangeEligible = true;
                    xrl.Request.offlineXuid = 0;

                    for (int ii = 0; ii < 3; ii++)
                    {
                        xrl.Request.gamertag = RandomEx.GlobalRandGen.GenerateRandomName();
                        try
                        {
                            if (!xrl.Execute())
                            {
                                if (ii < 3 && (xrl.XErr == ServerTestFramework.LiveService.HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN 
                                              || xrl.XErr == ServerTestFramework.LiveService.HResult.XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG))
                                {
                                    Global.RO.Info("CreateUserAndBillableAccount got XONLINE_E_ACCOUNTS_NAME_TAKEN or XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG. Retrying...");
                                    continue;
                                }
                                throw new UnexpectedTestResultException("CreateUserAndBillableAccount failed: " + xrl.ErrorStatusMessage);

                            }
                        }
                        catch (xonline.common.service.XRLException e)
                        {
                            if ( xonline.common.service.HResult.XONLINE_E_SERVICE_KEY_NOT_FOUND == xonline.common.service.XRLException.ToHResult( e, 0 ))
                           {
                                Global.RO.Warn("Looks like you are running this test on a machine that doesn't have the MasterKey!  Try installing the MasterKey and rerun the test.");
                                // drop\debug\tools\xkeymgr\xkeymgr.exe STOREMK private\op\sitecfg\xblob\secure\MasterKeyV1.prv
                            }
                            throw;
                        }
                        Global.RO.Info("CreateUserAndBillableAccount passed");
                        break;
                    }
                }
            }

            [TestCase, Owner("fejiang"), TestFrequency("BVT"), EnvRequirement("Billing"), TestCasePriority(1)]
            public class CreateFamily : TestNode
            {
                public override void PreRun()
                {
                    base.PreRun();
                }

                public override void Run()
                {
                    XeUser _primary = null;
                    XeUser _secondary = null;

                    for (int nthRetry = 0; nthRetry < 10; nthRetry++)
                    {
                        _primary = UacsCommon.XeUserCreationHelper.CreateXeSilverUser();
                        _secondary = UacsCommon.XeUserCreationHelper.CreateChildXenonUser(_primary);

                        //Parent purchases family
                        string parentPaymentInstrumentId = "";

                        for (int nthAddPiRetry = 0; nthAddPiRetry < 10; nthAddPiRetry++)
                        {
                            try
                            {
                                Global.RO.Info(String.Format("Try AddPaymentInstrumentVisa for {0}th time...\n", nthAddPiRetry));
                                parentPaymentInstrumentId = _primary.AddPaymentInstrumentVisa();
                                break;
                            }
                            catch (System.Exception e)
                            {
                                Global.RO.Warn(String.Format("AddPaymentInstrumentVisa failed for the {0}th time with error message:\n{1}\n ", nthAddPiRetry, e.Message));
                                nthAddPiRetry ++;
                            }
                            if (nthAddPiRetry >= 10)
                                throw new UnexpectedTestResultException("AddPaymentInstrumentVisa failed.");
                        }

                        try
                        {
                            Global.RO.Info(String.Format("Try XbosOffer.PurchaseCCSubscription for family gold for {0}th time...\n", nthRetry));
                            XbosOffer.PurchaseCCSubscription(_primary, parentPaymentInstrumentId, new Guid("8000004A-0000-4000-8000-0000FFFE07D1"), (uint)99, (uint)99, 51, 0);
                            break;
                        }
                        catch (System.Exception e)
                        {
                            Global.RO.Warn(String.Format("XbosOffer.PurchaseCCSubscription failed for the {0}th time with error message:\n{1}\n ", nthRetry, e.Message));
                            nthRetry++;
                        }

                        if (nthRetry >= 10)
                            throw new UnexpectedTestResultException("PurchaseCCSubscription");
                    }

                    //Assign gold seat
                    UacsCommon.AssignGoldUser(_primary, _secondary);
                }
            }
        }

        [TestGroup]
        public class UacsAccountManagementGroup : TestNode
        {
            protected static live.common.XblUser user = null;
            protected static Xbox360 xbox360 = null;

            public override void PreRun()
            {
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
            }
            
            [TestCase, Owner("styoo"), TestFrequency("BVT"), TestCasePriority(1), EnvRequirement("Billing")]
            [LiveLKG]
            public class VerifyDefaultPrivileges : TestNode
            {
                public override void Run()
                {
                    XRLXeGetUserWebInfo request = new XRLXeGetUserWebInfo();
                    XRLXeGetUserWebInfoResponse response = new XRLXeGetUserWebInfoResponse();
                                        
                    request.UserPuid = user.Puid;
                    if (!request.Execute(out response))
                        throw new UnexpectedTestResultException("XRLXeGetUserWebInfo failed: " + request.GetDumpString());
                    if (request.XErr != ServerTestFramework.LiveService.HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserWebInfo returned XErr=0x{0:x}", request.XErr));

                    //PrintResponse(response);

                    UserPrivileges privs = new UserPrivileges(response.UserPrivileges);

                    UserPrivileges defaultPrivs = UserPrivileges.GetGoldDefaults();

                    for (int i = xonline.common.service.XOn.XPRIVILEGE_MIN; i <= xonline.common.service.XOn.XPRIVILEGE_MAX; i++)
                    {
                        if (defaultPrivs.GetPrivilege(i) == true && privs.GetPrivilege(i) == false)
                        {
                            throw new Exception(String.Format("Verify Privilege {0} Failed! Expected: {1}, Actual: {2}", i, defaultPrivs.GetPrivilege(i), privs.GetPrivilege(i)));
                        }
                    }


                    Global.RO.Info("Verify Default Privileges passed");
                }
            }

            [TestCase, Owner("yixuanl"), TestFrequency("BVT"), TestCasePriority(1), EnvRequirement("Billing")]
            public class SwitchUserCountry : TestNode
            {
                public override void Run()
                {
                    XRLSwitchUserCountry request = new XRLSwitchUserCountry(user.Puid, (byte)XeUser.Country.BR, (ushort)XeUser.Language.pt);
                    ServerTestFramework.LiveService.FDTransaction.sReceiveTimeOut = ServerTestFramework.LiveService.FDTransaction.BillingReceiveTimeout;
                    for (int ii = 0; ii < 3; ii++)
                    {
                        Global.RO.Info(String.Format("Try SwitchUserCountry for {0}th time...\n", ii));
                        if (request.Execute())
                        {
                            break;
                        }
                        Thread.Sleep(10000); 
                    }
                    if (!request.Execute())
                        throw new UnexpectedTestResultException("XRLSwitchUserCountry failed: " + request.GetDumpString());
                    if (request.XErr != ServerTestFramework.LiveService.HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLSwitchUserCountry returned XErr=0x{0:x}", request.XErr));
                    
                    Global.RO.Info("Switch user country passed");
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Login BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class LoginGroup : TestNode
        {
            public static live.lfm.Xbox360 xbox360 = null;
            public static live.common.XblUser user = null;

            public override void PreRun()
            {
                xbox360 = new Xbox360();
                xbox360.Client.BypassKDC = true;
                live.common.XblUserSettings settings =
                    new live.common.XblUserSettings(XblUserTier.Gold, PassportType.Real);
                GamerAge age = GamerAge.FromBirthDate(settings.PersonalInfo.BirthDate);
                CountryInfo countryInfo = Countries.CountryInfo(settings.PersonalInfo.CountryId);
                settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;
                settings.UserPassportInfo.CountryId = settings.PersonalInfo.CountryId;
                try
                {
                    if (age.AgeInYears >= (int)countryInfo.Billing)
                    {
                        PassportUtils.CreatePassportAccounts(xbox360.Client, settings, true);
                    }
                    else
                    {
                        if (settings.UserPassportInfo.MemberName == settings.OwnerPassportInfo.MemberName)
                        {
                            settings.OwnerPassportInfo.MemberName = settings.OwnerPassportInfo.MemberName.Replace("@", "_owner@");
                        }
                        PassportUtils.CreatePassportAccounts(xbox360.Client, settings, false);
                    }
                }
                catch (XErrFailedException ex)
                {
                    throw new Exception("Failed to create user; hr = " + ex.HResult);
                }

                uint hr = UACS.XeCreateLiveAccount(xbox360.Client, settings, out user);
                if (hr != 0)
                {
                    throw new Exception("Failed to create user; hr = " + hr);
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class LoginAndLogout : TestNode
            {
                public override void Run()
                {
                    // Logon
                    xbox360.Client.UserLoggingOn(user);
                    Presence.Alive2(xbox360.Client, user);
                    Presence.SetState(xbox360.Client, user, live.protocol.Presence.XonPresNoti.P_STATE_MASK_ONLINE);
                    xbox360.Client.LoggedOnUsers.Add(user);
                    xbox360.ActiveUser = user;

                    // Logout
                    xbox360.Client.UserLoggingOff(user);
                    Presence.LogOut(xbox360.Client, user);
                    xbox360.Client.LoggedOnUsers.Remove(user);
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement(""), TestCasePriority(0)]
            [LiveLKG]
            public class LoginToTitle : TestNode
            {
                public override void Run()
                {
                    // Login to a title
                    TitleBase title = new TitleBase("FFFF0072.xlast");
                    title.ParseXlast();
                    xbox360.Client.TitleObject = title;

                    xbox360.Client.UserLoggingOn(user);
                    Presence.Alive2(xbox360.Client, user);
                    Presence.SetState(xbox360.Client, user, live.protocol.Presence.XonPresNoti.P_STATE_MASK_ONLINE);
                    xbox360.Client.LoggedOnUsers.Add(user);
                    xbox360.ActiveUser = user;

                    // Logoff
                    xbox360.Client.UserLoggingOff(user);
                    Presence.LogOut(xbox360.Client, user);
                    xbox360.Client.LoggedOnUsers.Remove(user);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Security Gateway BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        public class SgBVTException : Exception
        {
            public SgBVTException(string message) : base(message) { }
        }

        //TODO: In the future when more cases are added, we may want to split out the platforms into explicitly coded groups so platform-specific tests can be added
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
        [TestGroup, AsyncGroup(77)]
        public class SGBvt : TestNode
        {
            [TestCase, Owner("JDamp"), EnvRequirement(""), TestFrequency("BVT"), Description("Uses the full KDC to get a ticket, then presents that to the SG.")]
            public class SignIn : TestNode
            {
                protected SgClient sg = null;

                public override void Run()
                {
                    int previousDefault = 0;
                    int totalAttempts = 5;

                    for (int i = 0; i < totalAttempts; ++i)
                    {
                        try
                        {
                            previousDefault = AuthClientBase.DefaultTimeoutInMs;
                            AuthClientBase.DefaultTimeoutInMs = 10000;

                            AuthContext ctx = new AuthContext((AuthContext.ClientTypes)Parent.MyValues[0]);
                            ctx.UseXmacsTestKey = true;
                            ctx.SetDashTitle();

                            sg = new SgClient(ctx);
                            sg.TimeoutInMs = 10000;

                            if (ctx.IsXenonTitle || ctx.IsPanorama)
                            {
                                sg.bUseRealXKDC = true;
                                sg.bUseSgIpFromKDC = true;
                                sg.KDCEmulateClientBehavior = false;
                            }

                            sg.SignInSG();

                            return;
                        }
                        catch (ServerTestFramework.Utilities.TimeoutException te)
                        {
                            Global.RO.Debug("Sign In Timeout: " + te.Message);
                        }
                        finally
                        {
                            AuthClientBase.DefaultTimeoutInMs = previousDefault;
                        }
                    }

                    throw new UnexpectedTestResultException("Signin failed after "+totalAttempts+" attempts.");
                }
            }

            [TestCase, TestFrequency("BVT"), EnvRequirement(""), Description("Uses the full KDC to get a ticket, then presents that to the SG. Follows with a QoS exchange that ensures the key-exchange was good."), TestCasePriority(1)]
            [LiveLKG]
            public class SignInAndQoS : SignIn
            {
                public override void Run()
                {
                    base.Run();

                    QOS q = new QOS();
                    if (!q.SendRecv(sg))
                    {
                        throw new SgBVTException("QoS test timed out, we may be unable to communicate with the SG.");
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  XCrypto BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class XCryptoBVT : TestNode
        {
            [TestCase, Owner("benran"), Description("Ensures that a crypto sign request and verification is successful"), TestFrequency("BVT"), EnvRequirement(""), TestCasePriority(0)]
            [LiveLKG]
            public class XCryptoSignVerify : TestNode
            {
                public override void Run()
                {
                    XRLXCryptoSign sign = new XRLXCryptoSign();
                    //
                    // Random Fake sha1 to sign
                    //
                    Byte[] sha1 = RandomEx.GlobalRandGen.GenerateRandomBlob(20);
                    sign.Request.sha1 = new xonline.common.protocol.XCryptoData(sha1, sha1.Length);
                    sign.Request.containerClass = 1;

                    Global.RO.Debug("Blob[{0}]: {1}", sign.Request.sha1.dataLength, ServerTestFramework.Utilities.Hexer.tohex(sign.Request.sha1.data));

                    if (!sign.Execute())
                    {
                        throw new UnexpectedTestResultException("XCryptoSign request failed: " + sign.GetDumpString());
                    }

                    Global.RO.Success("Response[{0}]: {1}", sign.Response.sig.dataLength, ServerTestFramework.Utilities.Hexer.tohex(sign.Response.sig.data));


                    XRLXCryptoVerifySignature verifySignature = new XRLXCryptoVerifySignature();
                    // Take the sha1 from the request
                    verifySignature.Request.sha1 = sign.Request.sha1;
                    // and the signed data from the response
                    verifySignature.Request.sig = sign.Response.sig;
                    verifySignature.Request.containerClass = 1;

                    if (!verifySignature.Execute())
                    {
                        throw new UnexpectedTestResultException("XCryptoVerifySignature request failed: " + verifySignature.GetDumpString());
                    }

                    Global.RO.Success("Verified: {0}", verifySignature.Response.verified);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  LiveHive BVT
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class LiveHive : TestNode
        {
            [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Add a setting to LiveHive, then call GetLiveConfig and check for new setting"), TestCasePriority(0)]
            [LiveLKG]
            public class GetLiveConfig : TestNode
            {
                private static string configTableName = "t_live_registry_settings";
                private static string configName = "xenon";
                private static string settingPrefix = "LiveHiveBvt_";

                private MachineEditor machine;

                public override void PreRun()
                {
                    machine = MachineEditor.CreateNew();
                }

                public override void Run()
                {
                    String settingName = settingPrefix + RandomEx.GlobalRandGen.GenerateRandomString(16);
                    String settingValue = RandomEx.GlobalRandGen.GenerateRandomString(16);
                    String settingString = settingName + "=" + settingValue;

                    try
                    {
                        // Add a setting to the database
                        Global.RO.Info("Adding setting {0} to LiveHive", settingName);
                        AddConfigDatabaseSetting(settingName, settingValue, configName, null);
                        Global.RO.Info("Forcing LiveHive Cache Refresh");
                        Global.XEnv.ExecuteXmgmtCommand(Interface.liveinfo, "e :LiveInfo ReloadLiveHive", 10);

                        Global.RO.Info("Creating GetLiveConfig Request...");
                        XRLGetLiveConfig xrl = new XRLGetLiveConfig();
                        xrl.Request.configname = configName;
                        xrl.Slot.machinePuid = machine.Id;
                        xrl.SetClientVersion(2, 0, 0, 0);
                        xrl.SetBetaGroupFlag(false);

                        Global.RO.Info("Executing GetLiveConfig Request...");
                        if (!xrl.Execute())
                        {
                            throw new UnexpectedTestResultException("GetLiveConfig Request Failed: " + xrl.GetDumpString());
                        }

                        Global.RO.Success("GetLiveConfig request was successful.");

                        if (!xrl.Response.config.Contains(settingString))
                        {
                            throw new UnexpectedTestResultException("Unable to find setting " + settingName + " in LiveHive Settings");
                        }

                        Global.RO.Success("Found setting " + settingName + " in LiveHive Settings");
                    }
                    finally
                    {
                        RemoveConfigDatabaseSetting(settingName, configName);
                    }
                }

                public static int AddConfigDatabaseSetting(string _settingName, string _settingValue, string _configName, string _environment)
                {
                    //
                    // Setup the connection to NPDB and execute the command
                    //
                    Npdb npdb = new Npdb();
                    npdb.ConnectToServer();
                    string sql;

                    if (_environment == null)
                    {
                        sql = string.Format(
                            "INSERT INTO {0} (vc_environment, vc_setting, vc_client_config, vc_value) VALUES ('{1}', '{2}', '{3}', '{4}')",
                            configTableName,
                            xonline.common.config.Config.Environment,
                            _settingName,
                            _configName,
                            _settingValue
                            );
                    }
                    else
                    {
                        sql = string.Format(
                            "INSERT INTO {0} (vc_environment, vc_setting, vc_client_config, vc_value) VALUES ('{1}', '{2}', '{3}', '{4}')",
                            configTableName,
                            _environment,
                            _settingName,
                            _configName,
                            _settingValue
                            );
                    }

                    int numRows = npdb.IssueCommand(sql);
                    npdb.Close();

                    if (numRows < 1)
                    {
                        throw new Exception(string.Format("{0} FAILED", sql));
                    }

                    return numRows;

                }

                /// <summary>
                /// Removes a single setting from the config database
                /// </summary>
                /// <param name="_settingName">Setting name to remove</param>
                /// <param name="_configName">Which configuration to remove the setting from. Pass null for all.</param>
                /// <returns></returns>
                public static int RemoveConfigDatabaseSetting(string _settingName, string _configName)
                {
                    //
                    // Setup the connection to NPDB and execute the command
                    //
                    Npdb npdb = new Npdb();
                    npdb.ConnectToServer();
                    string sql;

                    //
                    // Delete any row from that table whos setting is LIKE _settingLike
                    //
                    if (_configName != null)
                    {
                        sql = string.Format("DELETE FROM {0} WHERE vc_setting LIKE '%{1}%' AND vc_client_config = '{2}'", configTableName, _settingName, _configName);
                    }
                    else
                    {
                        sql = string.Format("DELETE FROM {0} WHERE vc_setting = '{1}'", configTableName, _settingName);
                    }

                    int numRows = npdb.IssueCommand(sql);
                    npdb.Close();

                    return numRows;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Signature BVT
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup, Description("xsig and signature widget verification"), AsyncGroup(77)]
        public class SignatureBVT : TestNode
        {
            /// <summary>
            /// Convenience method for getting a cached Xbox360 user
            /// </summary>
            /// <returns>A CachedUserInfo for an Xbox360 user</returns>
            protected static CachedUserInfo GetCachedUser()
            {
                CachedUserInfo userInfo = Utils.GetCachedUser(UserCreationType.Xbox360, "Xbox360");
                Utils.WaitOnXCache(userInfo);

                return userInfo;
            }

            /// <summary>
            /// Convenience  method for getting a cached Xbox360 machine
            /// </summary>
            /// <returns>A CachedMachineInfor for an Xbox360</returns>
            protected static CachedMachineInfo GetCachedMachine()
            {
                return Utils.GetCachedMachine(MachineType.Xbox360);
            }

            /// <summary>
            /// Adds permission for DebugPartner to call an API in webdb, if it is missing
            /// </summary>
            /// <param name="api">The API to add permission for</param>
            protected static void EnableWebDBApiForDebugPartner(string api)
            {
                bool didUpdateWebDB = false;

                //update every webdb server
                string[] webDBServers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.webdb);
                foreach (string server in webDBServers)
                {
                    SqlConnection c = new SqlConnection("Data Source=" + server + ";Initial Catalog=WebDB;Integrated Security=SSPI");
                    c.Open();

                    //first verify that DebugPartner exists
                    string query = "use WebDB; select count(*) from t_partners where vc_subject_name='DebugPartner'";
                    SqlCommand cmd = new SqlCommand(query, c);
                    object o = cmd.ExecuteScalar();
                    if ((int)o == 0)
                    {
                        throw new System.Exception("WebDB " + server + " is missing DebugPartner in t_partners.");
                    }

                    //see if permission is already set
                    query = "use WebDB; select count(*) from t_partner_allowed_apis where vc_api_name='" + api + "' and i_partner_id=(select i_partner_id from t_partners where vc_subject_name='DebugPartner')";
                    cmd = new SqlCommand(query, c);
                    o = cmd.ExecuteScalar();
                    if ((int)o > 0)
                    {
                        continue;
                    }

                    //it isn't set, so update db
                    Global.RO.Info("Setting WebDB DebugPartner permissions on API '" + api + "' on " + server + " since it is not set...");
                    didUpdateWebDB = true;

                    query = "use WebDB; declare @grr int; set @grr=(select i_partner_id from t_partners where vc_subject_name='DebugPartner'); insert into t_partner_allowed_apis (i_partner_id,vc_api_name) values (@grr,'" + api + "');";
                    cmd = new SqlCommand(query, c);
                    cmd.ExecuteNonQuery();

                    c.Close();
                }

                //reload widget partners
                if (didUpdateWebDB)
                {
                    Global.RO.Warn("WebDB was updated: Permission to call " + api + " was added to DebugPartner.  We will now reload partner lists on all wcsignature servers.");

                    string[] widgetServers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.wcsignature);
                    foreach (string server in widgetServers)
                    {
                        string result;
                        string xcmd = "e :wcsignature ReloadPartners";
                        bool worked = ServerTestFramework.LiveService.ManagementConsole.Execute(server, xcmd, out result);
                        if (worked)
                        {
                            Global.RO.Debug(server + " reloaded");
                        }
                        else
                        {
                            Global.RO.Error("Error executing \"" + xcmd + "\" on " + server + ": " + result);
                            Global.RO.Error("The DebugPartner may not be allowed to call the API on this server as a result.");
                        }
                    }
                }
            }

            /// <summary>
            /// Oscar APIs
            /// </summary>
            [TestGroup, Description("Oscar APIs"), AsyncGroup(10)]
            public class OscarBVT : TestNode
            {
                /// <summary>
                /// Request an Oscar Certificate, and verify that teh call succeeds
                /// </summary>
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), AsyncGroup(1), Description("Make a request for an oscar certificate, and verify that the call succeeded.")]
                public class CreateCertificate : TestNode
                {
                    byte[] examplePublicKey = null;

                    public override void PreRun()
                    {
                        Global.RO.Info("Loading oscar public key...");
                        //load the public example key
                        if (examplePublicKey == null)
                        {
                            examplePublicKey = System.IO.File.ReadAllBytes(@"SuitesData\LiveBVT\OscarPublicKey.bin");
                        }

                        //ensure we have a machine and user available
                        Global.RO.Info("Getting machine and user...");
                        GetCachedMachine();
                        GetCachedUser();
                    }

                    public override void Run()
                    {
                        // Set up request
                        Global.RO.Info("Setting up CreateCertificate request...");
                        XRLCreateCertificate xrl = new XRLCreateCertificate();
                        xrl.Request.PubKey = examplePublicKey;
                        xrl.Request.appId = "Oscar";
                        xrl.Request.userPuid = GetCachedUser().Puid;

                        Global.RO.Info("Performing CreateCertificate request...");
                        if (!xrl.Execute(GetCachedMachine().Id))
                        {
                            throw new UnexpectedTestResultException("CreateCertificate failed:\n" + xrl.GetDumpString());
                        }

                        Global.RO.Success("CreateCertificate successful.");
                    }
                }
            }

            /// <summary>
            /// Carbon APIs
            /// </summary>
            [TestGroup, Description("Carbon APIs"), AsyncGroup(10)]
            public class CarbonBVT : TestNode
            {
                private static readonly byte[] Key = ServerTestFramework.Utilities.Hexer.unhex("00000020000100010000000000000000ECA1D8681FC1E539F03FEAE24BD3D4CECCE1F30A44A9FDC5968E209BA7E0589B485B82342144A8B3F1F40F237E921F2504306DA007DBDE53BEAD9A56DFF108088FBD2D89DADCB14BD94554893C338B8A04882135DA7DAF8B9082F5580531E3D3DA471D16BEA3539FF252F8730FA0B45F636F5C76129D5633BCBAB859DEDE249CCFDB50986690AC3A63AC4A38009465FA33B9D1FD1CF6BB796326B3335C3C66DDCC84EF7B4F00544AA46C368845C27BD397702D22AD6352F0CD09FC348775C2D95461FD1A2F518A371A642B16A49BDE2103EA245E5555FD85E0A6854B4088B6390C6E4CF88CB85D07C4F716DAA09227ADB7EF46D5BC266B96A873E8DDC37F1929");

                /// <summary>
                /// Resets the request object to the standard starting state
                /// </summary>
                public static void ResetRequest(ref XRLXmstvCreateCertificate createCert)
                {
                    if (createCert == null)
                    {
                        createCert = new XRLXmstvCreateCertificate();
                    }
                    createCert.Request.Flags = 0;
                    createCert.Request.AvPubKey = CloneKey(Key);
                    createCert.Request.NonAvPubKey = CloneKey(Key);
                    createCert.Request.KeyNonce = RandomEx.GlobalRandGen.NextUlong();
                    createCert.Slot = ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.GetSlot();
                    //request.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
                    createCert.Request.KeyedHash = GenerateKeyedHash(createCert);
                }

                /// <summary>
                /// Clone the provided key
                /// </summary>
                /// <returns>A copy of the cloned key</returns>
                public static byte[] CloneKey(byte[] key)
                {
                    byte[] clone = new byte[XRLXmstvCreateCertificate.RSAPUB_2048_SIZE];
                    key.CopyTo(clone, 0);
                    return clone;
                }

                /// <summary>
                /// generates a valid keyed hash from a given request
                /// </summary>
                /// <param name="request">The request to generate a hash for</param>
                /// <returns>A KeyedHash for the given request</returns>
                public static byte[] GenerateKeyedHash(XRLXmstvCreateCertificate createCert)
                {
                    //first get the (endian-corrected) bytes for the portion of the request used for this
                    List<byte> requestBytes = new List<byte>();
                    requestBytes.AddRange(ConvertPrimitive(createCert.Request.Flags, BitConverter.GetBytes));
                    requestBytes.AddRange(createCert.Request.AvPubKey);
                    requestBytes.AddRange(createCert.Request.NonAvPubKey);
                    requestBytes.AddRange(ConvertPrimitive(createCert.Request.KeyNonce, BitConverter.GetBytes));
                    byte[] origBytes = requestBytes.ToArray();

                    //compute the SHA1 hash of the bytes
                    byte[] digest = new SHA1Managed().ComputeHash(origBytes);
                    return digest;
                }

                /// <summary>
                /// Convert a primative into a byte array and reverses the endian
                /// </summary>
                /// <typeparam name="T">The type of object to convert</typeparam>
                /// <param name="prim">The object to convert</param>
                /// <param name="converter">The converter to use</param>
                /// <returns>A reversed byte array representing the object</returns>
                private static byte[] ConvertPrimitive<T>(T prim, Converter<T, byte[]> converter)
                {
                    byte[] bytes = converter(prim);
                    Array.Reverse(bytes);
                    return bytes;
                }

                /// <summary>
                /// Request an XMSTV certificate and verify that the call succeeds
                /// </summary>
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Request an XMSTV certificate and verify that the call succeeds"), AsyncGroup(1)]
                public class XmstvCreateCertificate : TestNode
                {
                    public override void Run()
                    {
                        XRLXmstvCreateCertificate xrl = new XRLXmstvCreateCertificate();
                        ResetRequest(ref xrl);

                        // Create a valid machine and pass the id to our slot
                        xrl.Slot.machinePuid = GetCachedMachine().Id;

                        if (!xrl.Execute())
                        {
                            throw new UnexpectedTestResultException("XmstvCreateCertificate request failed: " + xrl.GetDumpString());
                        }
                    }
                }
            }

            /// <summary>
            /// Licensing APIs
            /// </summary>
            [TestGroup, EnvRequirement("Billing, Catalog"), Description("Licensing APIs"), AsyncGroup(20)]
            public class LicenseBVT : TestNode
            {
                static LicenseUtils.MediaMatrix matrix = null;

                static XeUser user;
                static CachedMachineInfo client;

                public override void PreRun()
                {
                    matrix = new LicenseUtils.MediaMatrix();
                    matrix.PopulateOfferTable();

                    client = GetCachedMachine();

                    Global.RO.Info("Creating Gold User...");
                    user = AuthContext.MakeNewBillingUser(false, true, true);
                    user.MachinePuid = client.Id;

                    Global.RO.Info("Adding points...");
                    LicenseUtils.AddPoints(user, user.MachinePuid, ServerTestFramework.LiveService.Billing.Offers.PointsOffers.PP4000);
                }

                [TestCase, Ignore, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement("Billing, Catalog"), Description("Attempt to Acquire a PPV Media License and then Acknowledge it")]
        //[Ignore("Due to some changes in marketplace functionality and the fact that LiveBVT's still depend on LiveLib, this test will fail until I get a chance to replace my LicenseUtility stuff.")]
                public class AcquireAcknowledgeMediaLicense_PPV : TestNode
                {
                    xonline.common.protocol.MediaInstanceIdOfferIdPair[] mediaIds = null;

                    public override void PreRun()
                    {
                        uint count = 1;
                        List<LicenseUtils.VideoInformation> mediaInfo = matrix.GetOffers(LicenseUtils.VIDEOTYPE.MOVIE, LicenseUtils.VIDEOQUALITY.HD, count);

                        if (mediaInfo.Count < count)
                        {
                            throw new UnexpectedTestResultException("Unable to get the expected number of media offers. Ensure all expected content is propped.");
                        }

                        OfferExpectedPrice[] oep = new OfferExpectedPrice[count];
                        OfferMediaTypeExpectedPrice[] omp = new OfferMediaTypeExpectedPrice[count];
                        mediaIds = new xonline.common.protocol.MediaInstanceIdOfferIdPair[count];

                        for (int i = 0; i < count; i++)
                        {
                            omp[i] = new OfferMediaTypeExpectedPrice();
                            omp[i].OfferId = mediaInfo[i].videoInstances[0].offerId;
                            omp[i].ExpectedPriceWhole = (uint)mediaInfo[i].videoInstances[0].pointsPrice;
                            omp[i].ExpectedPriceFractional = 0;
                            omp[i].MediaTypeId = (int)mediaInfo[i].mediaType;

                            mediaIds[i] = new xonline.common.protocol.MediaInstanceIdOfferIdPair();
                            mediaIds[i].oid = mediaInfo[i].videoInstances[0].offerId;
                            mediaIds[i].miid = mediaInfo[i].videoInstances[0].mediaInstanceId;
                        }

                        Global.RO.Info("Attempting to purchase video offer...");
                        LicenseUtils.PurchaseMediaOffers(user.UserPuid, user.MachinePuid, omp);
                    }

                    public override void Run()
                    {
                        // Offer has been purchased so just attempt to acquire a license for it.
                        Global.RO.Info("Acquiring media license...");

                        xonline.common.protocol.AcquireMediaLicensesResponse acqResp = LicenseUtils.AcquireMediaLicenses(user.UserPuid, user.MachinePuid, mediaIds);

                        if (acqResp.mediaLicensesLength == 0)
                        {
                            throw new UnexpectedTestResultException("No media licenses recieved.");
                        }
                        else if (acqResp.mediaLicenses[0].hr != ServerTestFramework.LiveService.HResult.S_OK)
                        {
                            String msg = String.Format("Unexpected result during License Acquire - Expected: 0x{0:X}, Got: 0x{1:X}",
                                ServerTestFramework.LiveService.HResult.S_OK, acqResp.mediaLicenses[0].hr);

                            throw new UnexpectedTestResultException(msg);
                        }
                        Global.RO.Success("License sucessfully acquired.");

                        // Acquire was successful, so lets try to acknowledge it
                        Global.RO.Info("Acknowledging license delivery...");
                        xonline.common.protocol.AcknowledgeLicensesDeliveryResponse ackResp = LicenseUtils.AcknowledgeLicensesDelivery(user.UserPuid, user.MachinePuid, mediaIds);

                        if(ackResp.acknowledgements.Length == 0)
                        {
                            throw new UnexpectedTestResultException("No acknowledgments recieved.");
                        }
                        else if (ackResp.acknowledgements[0].hr != ServerTestFramework.LiveService.HResult.S_OK)
                        {
                            throw new UnexpectedTestResultException(string.Format("Unexpected result during License Acknowledge - Expected: 0x{0:X}, Got: 0x{1:X}", ServerTestFramework.LiveService.HResult.S_OK, ackResp.acknowledgements[0].hr));
                        }
                        Global.RO.Success("License successfully acknowledged.");
                    }
                }

                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement("Billing, Catalog"), Description("Attempt to Refresh a Game License")]
                public class RefreshGameLicense : TestNode
                {
                    static ServerTestFramework.LiveService.Billing.License.ContentLicense license = null;

                    public override void PreRun()
                    {
                        // Purchase Texas Hold 'em
                        OfferMediaTypeExpectedPrice[] omp = new OfferMediaTypeExpectedPrice[1];
                        omp[0] = new OfferMediaTypeExpectedPrice();
                        omp[0].OfferId = new Guid("00000001-0000-4000-8000-0000584107F6");
                        omp[0].ExpectedPriceWhole = (uint)800;
                        omp[0].ExpectedPriceFractional = 0;
                        omp[0].MediaTypeId = 23; // ArcadeGame

                        Global.RO.Info("Attempting to purchase game offer...");
                        LicenseUtils.PurchaseMediaOffers(user.UserPuid, user.MachinePuid, omp);

                        // Generate an empty license, and then request a refresh of it.
                        // This content id was grabbed from the catalog database using the following query (with no breaks).
                        // The resulting XML contains a Base64 encoded content id which can be used for this request
                        /*
                         http://localhost:12020/Catalog/Catalog.asmx/Query?methodName=FindGameOffers&Names=Locale&
                         Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=1&Names=PageSize&Values=100&
                         Names=PageNum&Values=1&Names=DetailView&Values=5&Names=UserTypes&Values=2&Names=MediaTypes&Values=5&
                         Names=MediaTypes&Values=18&Names=MediaTypes&Values=19&Names=MediaTypes&Values=20&
                         Names=MediaTypes&Values=21&Names=MediaTypes&Values=22&Names=MediaTypes&Values=23&
                         Names=MediaTypes&Values=30&Names=MediaTypes&Values=34&Names=OrderBy&Values=1&
                         Names=OrderDirection&Values=1&Names=OfferIds&Values=00000001-0000-4000-8000-0000584107F6
                         */

                        Global.RO.Info("Generating license data...");
                        license = LicenseUtils.GenerateLicenseData(
                            new Byte[] { 0xBD, 0x58, 0xCC, 0x03,
                                         0xA4, 0xAA, 0x36, 0x99,
                                         0x59, 0x0E, 0x34, 0xE4,
                                         0xE0, 0x65, 0xBB, 0xC0,
                                         0x56, 0xDE, 0x59, 0x8F },
                            new ulong[] { user.UserPuid });
                    }

                    public override void Run()
                    {
                        Global.RO.Info("Refreshing game license...");
                        xonline.common.protocol.RefreshGameLicenseResponse refreshResp = LicenseUtils.RefreshGameLicense(user.UserPuid, user.MachinePuid, license.ToArray());

                        if (refreshResp.licenseLength == 0 || refreshResp.license == null)
                        {
                            throw new UnexpectedTestResultException("No game license recieved.");
                        }

                        Global.RO.Success("Game license refreshed successfully.");
                    }
                }
            }

            /// <summary>
            /// LicenseMigration APIs
            /// </summary>
            [TestGroup, Description("LicenseMigration APIs"), AsyncGroup(20)]
            public class LicenseMigrationBVT : TestNode
            {
                /// <summary>
                /// Get the LicenseTransfer state for a given user
                /// </summary>
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Attempt to get the current license transfer state"), AsyncGroup(1)]
                public class GetLicenseTransferState : TestNode
                {
                    public override void PreRun()
                    {
                        GetCachedUser();
                    }

                    public override void Run()
                    {
                        XRLGetLicenseTransferState xrl = new XRLGetLicenseTransferState();
                        xrl.Request.userPuid = GetCachedUser().Puid;

                        if (!xrl.Execute())
                        {
                            throw new UnexpectedTestResultException(string.Format("GetLicenseTransferState request failed: {0}", xrl.GetDumpString()));
                        }
                    }
                }

                /// <summary>
                /// Start a license transfer, then attempt to complete it (which should fail) and then cancel the transfer.
                /// The cancel is required to allow the test to be repeatable.  All calls should succeed of fail with
                /// given expected errors.
                /// </summary>
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Attempt to start a license transfer and complete it"), AsyncGroup(1)]
                public class UpdateLicenseTransferState : TestNode
                {
                    public override void PreRun()
                    {
                        GetCachedUser();
                    }

                    public override void Run()
                    {
                        XRLUpdateLicenseTransferState xrl = new XRLUpdateLicenseTransferState();
                        xrl.Request.command = xonline.common.protocol.UpdateTransferStateEnum.Start;
                        xrl.Request.userPuid = GetCachedUser().Puid;

                        Global.RO.Info("Attempting to start License Transfer.");
                        if (!xrl.Execute())
                        {
                            throw new UnexpectedTestResultException(string.Format("UpdateLicenseTransferState request failed: {0}", xrl.GetDumpString()));
                        }
                        Global.RO.Success("License Transfer Successfully Started.");

                        xrl.Request.command = xonline.common.protocol.UpdateTransferStateEnum.Complete;

                        Global.RO.Info("Attempting to complete License Transfer.");
                        if (xrl.Execute() || !xrl.TestNegative(xonline.common.service.HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND))
                        {
                            throw new UnexpectedTestResultException(string.Format("Unexpected Error from UpdateLicenseTransferState: {0}", xrl.GetDumpString()));
                        }

                        xrl.Request.command = xonline.common.protocol.UpdateTransferStateEnum.Cancel;
                        Global.RO.Info("Attempting to Cancel License Transfer.");
                        if (!xrl.Execute())
                        {
                            throw new UnexpectedTestResultException(string.Format("Unable to cancel License Transfer: {0}", xrl.GetDumpString()));
                        }
                        Global.RO.Success("License Transfer Cancelled.");
                    }
                }

                /// <summary>
                /// Transfer a license using the widget api
                /// </summary>
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Transfer a license using the widget api"), AsyncGroup(1)]
                public class TransferUserLicense : TestNode
                {
                    public override void PreRun()
                    {
                        EnableWebDBApiForDebugPartner("Signature.TransferUserLicenses");

                        //ensure we have a machine and user available
                        GetCachedMachine();
                        Utils.WaitOnXCache(GetCachedUser());
                    }

                    public override void Run()
                    {
                        string consoleId = GetCachedMachine().ConsoleId.Substring(3); //strip the XE. portion of the id... the api does not want that.

                        ServerTestFramework.WebWidget.WCSignature wcSig = new ServerTestFramework.WebWidget.WCSignature();
                        wcSig.TransferUserLicenses(GetCachedUser().Puid, consoleId);
                    }
                }
            }

            /// <summary>
            /// XSig APIs
            /// </summary>
            [TestGroup, Description("BVT Test cases for the XSig service"), AsyncGroup(20)]
            public class XSigBVT : TestNode
            {
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Request the Signing Key From the Server and ensure it's received")]
                public class GetSigningKey : TestNode
                {
                    public override void Run()
                    {
                        XRLGetSigningKey xrl = new XRLGetSigningKey();
                        XSigSignature sig = xrl.Execute();

                        if (sig == null || xrl.httpStatus != HttpStatusCode.OK)
                        {
                            throw new UnexpectedTestResultException("Unable to Get Signing Key: " + xrl.GetDumpString());
                        }
                    }
                }

                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Sign a number of objects and ensure that they succeed")]
                public class SignOnBehalf : TestNode
                {
                    private ulong GetPuid()
                    {
                        return 0xFF09000000000000 + (ulong)RandomEx.GlobalRandGen.Next();
                    }

                    public override void Run()
                    {
                        Int32 numReqs = 5;
                        XRLXSigSignOnBehalf signOnBehalf = new XRLXSigSignOnBehalf(numReqs);
                        for (int i = 0; i < numReqs; i++)
                        {
                            signOnBehalf.Requests[i] = XRLXSigSignOnBehalf.CreateSignRequest(
                                (uint)RandomEx.GlobalRandGen.Next(1, (int)XOService.MaxService),
                                RandomEx.GlobalRandGen.GenerateRandomBlob(100));

                            signOnBehalf.Requests[i]._authData._titleID = (uint)RandomEx.GlobalRandGen.Next();
                            signOnBehalf.Requests[i]._authData._titleVersion = (uint)RandomEx.GlobalRandGen.Next();
                            signOnBehalf.Requests[i]._authData._XboxID = GetPuid();
                            signOnBehalf.Requests[i]._authData._userID1 = GetPuid();
                            signOnBehalf.Requests[i]._authData._userID2 = GetPuid();
                            signOnBehalf.Requests[i]._authData._userID3 = GetPuid();
                            signOnBehalf.Requests[i]._authData._userID4 = GetPuid();
                        }

                        if (!signOnBehalf.Execute())
                        {
                            throw new UnexpectedTestResultException("XSigSignOnBehalf request failed: " + signOnBehalf.GetDumpString());
                        }
                    }
                }

                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Send a Verify Signature Request and ensure it succeds"), TestCasePriority(0)]
                [LiveLKG]
                public class VerifySignature : TestNode
                {
                    public override void Run()
                    {
                        XRLXSigVerifySignature verify = new XRLXSigVerifySignature(
                            RandomEx.GlobalRandGen.GenerateRandomBlob(20));
                        XSigSignature sig = new XRLGetSigningKey().Execute();

                        if (sig == null)
                        {
                            throw new UnexpectedTestResultException("Unable to get signing key.");
                        }

                        verify.Requests[0]._signature = sig;

                        if (!verify.Execute())
                        {
                            throw new UnexpectedTestResultException("VerifySignature request failed: " + verify.GetDumpString());
                        }
                    }
                }

                /// <summary>
                /// Generate a random file and attempt to get a signed header for it.
                /// </summary>
                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Try to Get A Signed Header for a License"), TestCasePriority(0)]
                [LiveLKG]
                public class GetSignedHeader : TestNode
                {
                    // Only valid file type id
                    private const uint FILE_TYPE = 0x52475459;

                    public override void Run()
                    {
                        XRLGetSignedHeader getSignedHeader = new XRLGetSignedHeader();

                        Byte[] file = RandomEx.GlobalRandGen.GenerateRandomBlob(RandomEx.GlobalRandGen.Next(1024));
                        if (!getSignedHeader.Execute(file))
                        {
                            throw new UnexpectedTestResultException("GetSignedHeader request failed: " + getSignedHeader.GetDumpString());
                        }
                    }
                }

                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Attempt to validate a certificate against the service"), TestCasePriority(0)]
                [LiveLKG]
                public class ValidateCertificate : TestNode
                {
                    Byte[] NetflixServerCert = new Byte[] {
                        0x30, 0x82, 0x05, 0x00, 0x30, 0x82, 0x03, 0xE8, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x1E,
                        0x94, 0xD2, 0xA6, 0x82, 0x65, 0x6D, 0x90, 0x43, 0xD9, 0x8C, 0x8E, 0xCC, 0xDA, 0xA9, 0x01, 0x30,
                        0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81,
                        0xB0, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17,
                        0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67,
                        0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B,
                        0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74,
                        0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04,
                        0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20,
                        0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76,
                        0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20,
                        0x28, 0x63, 0x29, 0x30, 0x35, 0x31, 0x2A, 0x30, 0x28, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x21,
                        0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33,
                        0x20, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x43,
                        0x41, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x39, 0x30, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
                        0x30, 0x5A, 0x17, 0x0D, 0x31, 0x30, 0x30, 0x33, 0x30, 0x35, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39,
                        0x5A, 0x30, 0x74, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
                        0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0A, 0x43, 0x61, 0x6C, 0x69, 0x66,
                        0x6F, 0x72, 0x6E, 0x69, 0x61, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x14, 0x09,
                        0x4C, 0x6F, 0x73, 0x20, 0x47, 0x61, 0x74, 0x6F, 0x73, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55,
                        0x04, 0x0A, 0x14, 0x0B, 0x4E, 0x65, 0x74, 0x66, 0x6C, 0x69, 0x78, 0x2E, 0x63, 0x6F, 0x6D, 0x31,
                        0x0C, 0x30, 0x0A, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x14, 0x03, 0x77, 0x77, 0x77, 0x31, 0x18, 0x30,
                        0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x14, 0x0F, 0x77, 0x77, 0x77, 0x2E, 0x6E, 0x65, 0x74, 0x66,
                        0x6C, 0x69, 0x78, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
                        0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81, 0x89,
                        0x02, 0x81, 0x81, 0x00, 0xAC, 0x7E, 0x9A, 0xE6, 0x56, 0x2D, 0x55, 0x10, 0x54, 0x13, 0x91, 0xB6,
                        0xCA, 0x72, 0xC9, 0xD8, 0x1E, 0xA9, 0xD1, 0x94, 0xCE, 0x44, 0xA6, 0x5D, 0x28, 0x0D, 0x53, 0x20,
                        0x39, 0xC6, 0xD7, 0xC5, 0x90, 0xED, 0xDC, 0x5A, 0x85, 0x5D, 0x70, 0x85, 0x61, 0x27, 0x13, 0xF6,
                        0x80, 0xD4, 0x27, 0x7F, 0x26, 0xA5, 0xAB, 0x0A, 0x20, 0x8A, 0xBD, 0xAA, 0x14, 0x04, 0x97, 0x94,
                        0xDA, 0xB2, 0x12, 0xEE, 0xF0, 0xE3, 0x96, 0x94, 0x65, 0x0A, 0x76, 0x1C, 0x52, 0x53, 0x0C, 0x97,
                        0xFD, 0x14, 0x7D, 0x51, 0x45, 0x8B, 0x04, 0x11, 0xE2, 0xA3, 0x00, 0x23, 0x76, 0xB2, 0x0F, 0xBB,
                        0xF5, 0x4D, 0x01, 0xDB, 0xF2, 0x27, 0x07, 0x42, 0xD1, 0x6E, 0xBC, 0xD8, 0x98, 0x4F, 0xD2, 0xB0,
                        0x8C, 0xFE, 0x51, 0xA1, 0x94, 0x7F, 0x61, 0xEB, 0x53, 0x3F, 0xA2, 0x81, 0x20, 0x28, 0x30, 0x6B,
                        0xD5, 0xC4, 0x14, 0x31, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0xD3, 0x30, 0x82, 0x01,
                        0xCF, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0B, 0x06, 0x03,
                        0x55, 0x1D, 0x0F, 0x04, 0x04, 0x03, 0x02, 0x05, 0xA0, 0x30, 0x44, 0x06, 0x03, 0x55, 0x1D, 0x1F,
                        0x04, 0x3D, 0x30, 0x3B, 0x30, 0x39, 0xA0, 0x37, 0xA0, 0x35, 0x86, 0x33, 0x68, 0x74, 0x74, 0x70,
                        0x3A, 0x2F, 0x2F, 0x53, 0x56, 0x52, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x2D, 0x63, 0x72, 0x6C,
                        0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x53, 0x56,
                        0x52, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x32, 0x30, 0x30, 0x35, 0x2E, 0x63, 0x72, 0x6C, 0x30,
                        0x44, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x3D, 0x30, 0x3B, 0x30, 0x39, 0x06, 0x0B, 0x60, 0x86,
                        0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30, 0x2A, 0x30, 0x28, 0x06, 0x08, 0x2B,
                        0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F,
                        0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F,
                        0x6D, 0x2F, 0x72, 0x70, 0x61, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x16, 0x30, 0x14,
                        0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05,
                        0x05, 0x07, 0x03, 0x02, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80,
                        0x14, 0x6F, 0xEC, 0xAF, 0xA0, 0xDD, 0x8A, 0xA4, 0xEF, 0xF5, 0x2A, 0x10, 0x67, 0x2D, 0x3F, 0x55,
                        0x82, 0xBC, 0xD7, 0xEF, 0x25, 0x30, 0x79, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01,
                        0x01, 0x04, 0x6D, 0x30, 0x6B, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30,
                        0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76,
                        0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x43, 0x06, 0x08, 0x2B,
                        0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x37, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
                        0x53, 0x56, 0x52, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x2D, 0x61, 0x69, 0x61, 0x2E, 0x76, 0x65,
                        0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x53, 0x56, 0x52, 0x53, 0x65,
                        0x63, 0x75, 0x72, 0x65, 0x32, 0x30, 0x30, 0x35, 0x2D, 0x61, 0x69, 0x61, 0x2E, 0x63, 0x65, 0x72,
                        0x30, 0x6E, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x0C, 0x04, 0x62, 0x30, 0x60,
                        0xA1, 0x5E, 0xA0, 0x5C, 0x30, 0x5A, 0x30, 0x58, 0x30, 0x56, 0x16, 0x09, 0x69, 0x6D, 0x61, 0x67,
                        0x65, 0x2F, 0x67, 0x69, 0x66, 0x30, 0x21, 0x30, 0x1F, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E, 0x03,
                        0x02, 0x1A, 0x04, 0x14, 0x4B, 0x6B, 0xB9, 0x28, 0x96, 0x06, 0x0C, 0xBB, 0xD0, 0x52, 0x38, 0x9B,
                        0x29, 0xAC, 0x4B, 0x07, 0x8B, 0x21, 0x05, 0x18, 0x30, 0x26, 0x16, 0x24, 0x68, 0x74, 0x74, 0x70,
                        0x3A, 0x2F, 0x2F, 0x6C, 0x6F, 0x67, 0x6F, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E,
                        0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x76, 0x73, 0x6C, 0x6F, 0x67, 0x6F, 0x31, 0x2E, 0x67, 0x69, 0x66,
                        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
                        0x82, 0x01, 0x01, 0x00, 0x05, 0x87, 0x19, 0xEE, 0x2E, 0xA5, 0x9C, 0x89, 0xBF, 0x8C, 0x4C, 0xE8,
                        0x99, 0x50, 0x76, 0xDA, 0x1F, 0x2A, 0xC0, 0x91, 0x35, 0x6E, 0x06, 0x2D, 0x52, 0x17, 0xC4, 0x35,
                        0xF5, 0xDD, 0xAC, 0x58, 0x1E, 0x4E, 0x40, 0x1E, 0x89, 0x62, 0x7A, 0x20, 0x0B, 0x79, 0xB5, 0x16,
                        0xCE, 0xEB, 0xB3, 0xC7, 0x61, 0xFC, 0x70, 0x11, 0x20, 0x29, 0x36, 0xA4, 0xF4, 0x50, 0x70, 0xFC,
                        0xFB, 0xD1, 0x8D, 0xEC, 0x12, 0x3A, 0x32, 0x3E, 0x6B, 0x56, 0xE0, 0xCF, 0xD1, 0x7A, 0x28, 0x25,
                        0xD8, 0x40, 0x10, 0x75, 0xC4, 0x00, 0xA4, 0x1C, 0x6F, 0xBB, 0x43, 0xE2, 0x6F, 0x3A, 0x8A, 0xFF,
                        0x27, 0x78, 0x3A, 0x8B, 0xE1, 0xD3, 0x4C, 0x18, 0x6F, 0x3E, 0x02, 0xF5, 0xBE, 0x85, 0x2F, 0x59,
                        0xB5, 0x0E, 0x74, 0xFE, 0xA8, 0xDB, 0xB1, 0x92, 0x61, 0x9D, 0xE2, 0xD5, 0x71, 0x94, 0xB3, 0xAA,
                        0x2C, 0x73, 0xF9, 0x27, 0xF2, 0xBB, 0x43, 0x28, 0x65, 0x13, 0xC2, 0x7C, 0xB0, 0x30, 0x79, 0xDB,
                        0xA6, 0x37, 0x01, 0xCA, 0x90, 0xDC, 0x36, 0x0E, 0x71, 0xFA, 0xEC, 0x3B, 0xE3, 0x0D, 0x14, 0xCF,
                        0x95, 0xAF, 0x7F, 0x42, 0x42, 0x46, 0xB7, 0x9F, 0xD7, 0x82, 0xD3, 0x81, 0x51, 0x8A, 0x9E, 0xC6,
                        0x2A, 0x42, 0xBC, 0x1B, 0xB2, 0x97, 0x35, 0x83, 0xD1, 0x69, 0x56, 0x73, 0x5E, 0xE1, 0xA8, 0xEF,
                        0x12, 0x43, 0x36, 0xA9, 0xF2, 0x16, 0x48, 0x58, 0xC6, 0xCE, 0x4E, 0x1B, 0x17, 0x27, 0x21, 0x0F,
                        0xA6, 0x96, 0x61, 0x6F, 0x7D, 0xA9, 0xA9, 0x28, 0x8B, 0xD9, 0x94, 0x6F, 0x63, 0xDA, 0x55, 0x29,
                        0x37, 0x35, 0x8C, 0xB0, 0x61, 0x7D, 0x38, 0x23, 0xEC, 0xE5, 0xC5, 0x1E, 0x6B, 0x1B, 0x27, 0x10,
                        0x09, 0x9D, 0xE2, 0xAC, 0xEE, 0x12, 0xA9, 0xF0, 0x16, 0x81, 0x40, 0x60, 0x7F, 0x3A, 0x9F, 0xAE,
                        0x25, 0xFD, 0x03, 0x42,
                    };


                    public override void Run()
                    {
                        XRLValidateCertificate xrl = new XRLValidateCertificate();
                        X509Certificate2 cert = new X509Certificate2(NetflixServerCert);

                        if (!xrl.Execute(cert))
                        {
                            throw new UnexpectedTestResultException("Unable to validate certificate");
                        }
                        else
                        {
                            Global.RO.Success("Successfully validated certificate");
                            return;
                        }
                    }
                }

                [TestCase, Owner("BenRan"), TestFrequency("BVT"), EnvRequirement(""), Description("Create a console certificate for Client Authentication"), TestCasePriority(0)]
                [LiveLKG] // Until the issue with the first execution of this test failing can be resolved
                public class CreateCertificate2 : TestNode
                {
                    public override void Run()
                    {
                        Global.RO.Info("Loading valid console certificate...");
                        // We're going to read in a harcoded valid console certificate from
                        // a random dev kit with console id "XE.029877704969"
                        ConsoleCertificate validConsoleCert = new ConsoleCertificate();

                        validConsoleCert.ReadBytes(new Byte[] {
                            0x01, 0xA8, 0x0B, 0x21, 0x5C, 0x28, 0x09, 0x58, 0x38, 0x31, 0x33, 0x39, 0x35, 0x33, 0x2D, 0x30,
                            0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x31, 0x2D, 0x31,
                            0x34, 0x2D, 0x30, 0x37, 0x00, 0x01, 0x00, 0x01, 0xF4, 0xDE, 0x7B, 0x46, 0x97, 0x2F, 0x41, 0x4D,
                            0xD3, 0xBD, 0xBC, 0xF1, 0xBC, 0x13, 0x78, 0x75, 0xD6, 0x3E, 0x49, 0x86, 0x82, 0xF3, 0xBF, 0x27,
                            0x22, 0xB2, 0xC6, 0x02, 0x60, 0x3F, 0x80, 0x60, 0x0F, 0x64, 0xCC, 0x7B, 0x3C, 0x56, 0x4A, 0xDD,
                            0xA5, 0x1C, 0xB9, 0x2E, 0x58, 0x03, 0x03, 0xCF, 0x46, 0x87, 0x8F, 0xA2, 0x2A, 0x52, 0xE7, 0xD9,
                            0x21, 0x6C, 0x50, 0x14, 0xBD, 0x4B, 0x76, 0xA6, 0x8A, 0x6F, 0xC3, 0x16, 0xE1, 0x1F, 0xA3, 0x70,
                            0xA0, 0xA0, 0xFF, 0xA6, 0x4C, 0x27, 0x4A, 0x38, 0xFD, 0xD8, 0xE1, 0x11, 0xFC, 0x56, 0x85, 0x02,
                            0x47, 0x2B, 0x53, 0x99, 0xE4, 0x33, 0xC6, 0xDF, 0xA2, 0x24, 0xE6, 0x11, 0x11, 0x58, 0x92, 0xFF,
                            0x29, 0x6E, 0xFC, 0x40, 0x42, 0x9A, 0x0A, 0xEA, 0x66, 0x3A, 0x1D, 0xD8, 0xAA, 0xC3, 0x44, 0xFE,
                            0xC2, 0xEA, 0x28, 0xCC, 0xFD, 0x55, 0x8D, 0x2D,
                            0xE8, 0xBE, 0x6D, 0xF6, 0xD8, 0xDD, 0x0A, 0x9B, 0xAE, 0x1C, 0x61, 0xCB, 0x1E, 0x0F, 0x60, 0x73,
                            0x94, 0x02, 0xB2, 0xF7, 0x42, 0x91, 0x9D, 0x34, 0xEC, 0x93, 0xCD, 0xD8, 0xC7, 0xE6, 0xA3, 0x62,
                            0x47, 0x6A, 0x11, 0x85, 0xF2, 0x89, 0xFE, 0x98, 0xCF, 0xC6, 0xB6, 0xDC, 0x03, 0xAD, 0x64, 0xC5,
                            0x80, 0x83, 0x33, 0x7A, 0x46, 0x1A, 0x54, 0x45, 0xCC, 0x11, 0xD0, 0x2F, 0x96, 0x04, 0xE1, 0xD8,
                            0x77, 0x67, 0x44, 0xB9, 0x59, 0x47, 0x2B, 0xD6, 0x0F, 0x7C, 0xE4, 0x51, 0xBE, 0x43, 0x68, 0xEE,
                            0x61, 0xDF, 0x45, 0x52, 0x36, 0xE4, 0xB3, 0xCC, 0x5F, 0xD8, 0xDF, 0x26, 0x33, 0x32, 0x6F, 0x90,
                            0x3C, 0xCE, 0x0A, 0xAC, 0x0B, 0xC9, 0xA7, 0xE3, 0x76, 0x8D, 0x4D, 0x9E, 0xCF, 0xF5, 0x27, 0x3E,
                            0x9C, 0xF6, 0x86, 0xF0, 0x08, 0x10, 0x82, 0x0C, 0x64, 0xEA, 0x52, 0xC6, 0x57, 0xFE, 0x78, 0x4C,
                            0x8F, 0x37, 0x9C, 0xA2, 0x19, 0xEB, 0x77, 0x80, 0x0D, 0x38, 0xBB, 0x54, 0xD5, 0xBF, 0x5B, 0x14,
                            0x8C, 0xB2, 0xCB, 0x8A, 0xDE, 0x85, 0x51, 0x78, 0xB5, 0xE9, 0x9D, 0xD0, 0xB5, 0x3F, 0x6A, 0xB3,
                            0xC2, 0xB5, 0xEA, 0xF0, 0x19, 0x33, 0xCD, 0x9E, 0x8E, 0xBD, 0xDF, 0xD7, 0x9C, 0xB2, 0x53, 0x13,
                            0x34, 0xC3, 0xF9, 0x56, 0x19, 0x69, 0x5F, 0x91, 0xCE, 0x04, 0xFF, 0x7A, 0x8B, 0xAB, 0x14, 0xA9,
                            0x5A, 0x6A, 0xE2, 0xDF, 0x8D, 0x81, 0x61, 0x69, 0xD3, 0x35, 0xF4, 0x4E, 0x4A, 0x40, 0xB9, 0x70,
                            0x59, 0x60, 0xBC, 0xD6, 0x2B, 0x54, 0xDD, 0x81, 0xA3, 0x35, 0x38, 0x6F, 0x4E, 0xA9, 0x6D, 0x72,
                            0xF2, 0x0C, 0xB5, 0xF6, 0x4E, 0x75, 0x00, 0xB5, 0x79, 0xE7, 0x99, 0x45, 0xDB, 0x06, 0xA4, 0x11,
                            0x6A, 0xDC, 0x54, 0xAE, 0x17, 0x10, 0xAF, 0xAD, 0x3A, 0xE0, 0x64, 0x2C, 0x24, 0xBD, 0x26, 0x36,
                        });

                        Global.RO.Info("Generating CreateCertificate2 request...");
                        XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                        // Set the console certificate to our valid one.  We doing a deep copy the easy way
                        xrl.ConsoleCert = new ConsoleCertificate();
                        xrl.ConsoleCert.ReadBytes((byte[])validConsoleCert);
                        // Create a new Xenon Client
                        xrl.Client = new XmacsClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                        // And then sign in with the same console id as the one in our hardcode certificate
                        xrl.Client.SignInXmacsWithConsoleID("XE.029877704969");

                        Global.RO.Info("Performing CreateCertificate2 request...");

                        int retryCount = 5;

                        do
                        {
                            try
                            {
                                if (xrl.Execute(false))
                                {
                                    Global.RO.Success("Successfully created client authentication certificate");
                                    break;
                                }
                                else
                                {
                                    throw new UnexpectedTestResultException("CreateCertificate2 failed: " + xrl.GetDumpString());
                                }
                            }
                            catch (UnexpectedTestResultException)
                            {
                                // We don't want to do anything with these because they mean
                                // the call failed in some significant way
                                throw;
                            }
                            catch (Exception e)
                            {
                                // Any other exceptions may be timeouts or connection issues
                                // so retry after waiting a few seconds.
                                if (retryCount > 0)
                                {
                                    retryCount--;
                                    Global.RO.Warn("CreateCertificate2 request failed.  Will retry in a few seconds.  Exception: " + e.ToString());
                                    Thread.Sleep(5000);
                                }
                                else
                                {
                                    Global.RO.Error("CreateCertificate2 request failed after multiple retries.");
                                    throw;
                                }
                            }
                        }
                        while (true);
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  KDC BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup, Description("Simple verification of xmacs, askdc, and xkdc"), AsyncGroup(77)]
        [LiveLKG]
        public class KDC: TestNode
        {
            //titles to use
            public const uint Xbox1TitleID = 0xFFFE0000; //xbox1 dashboard
            public const uint Xbox360TitleID = 0xFFFE07D1; //xbox360 dashboard
            public const uint PCTitleID = 0x585207D1; //pc account creation

            // -- setup and helpers

            private static KdcUser cachedUser=null;
            private static string cachedUserEnvironment="";
            private static object userLock=new object();

            public static KdcUser GetCachedUser(bool needsPassport)
            {
                lock (userLock)
                {
                    //create the user if needed
                    string curEnvironment=Global.XEnv.GetEnv();
                    if (cachedUserEnvironment!=curEnvironment || cachedUser==null)
                    {
                        Global.RO.Debug("Creating a user...");
                        KdcUser newUser=new KdcUser();
                        newUser.CreateUser(false);
                        cachedUser=newUser;
                        cachedUserEnvironment=curEnvironment;
                    }

                    //link them to a passport if needed
                    if (needsPassport && cachedUser.Passport==null)
                    {
                        Global.RO.Debug("Creating and linking a passport to the user...");

                        for (int i=0; i<3; ++i)
                        {
                            try
                            {
                                cachedUser.LinkPassport(null);
                                break;
                            }
                            catch (System.Exception e)
                            {
                                Global.RO.Warn("Passport creation failed ("+e.Message+").");
                                if (i<2)
                                {
                                    Global.RO.Warn("Waiting 10s to retry passport creation.");
                                    System.Threading.Thread.Sleep(10000);
                                }
                                else
                                {
                                    throw;
                                }
                            }
                        }
                    }

                    //cache tickets for them if needed
                    if (needsPassport)
                    {
                        for (int i=0; i<3; ++i)
                        {
                            try
                            {
                                cachedUser.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                                cachedUser.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                            }
                            catch (System.Exception e)
                            {
                                Global.RO.Warn("Failed to get a ticket from passport using IDCRL ("+e.Message+").");
                                if (i<2)
                                {
                                    Global.RO.Warn("Waiting 10s to retry getting a passport ticket.");
                                    System.Threading.Thread.Sleep(10000);
                                }
                                else
                                {
                                    throw;
                                }
                            }
                        }
                    }

                    return cachedUser;
                }
            }

            private bool prevKdcVerbose=false;

            public override void PreRun()
            {
                prevKdcVerbose=KdcClient.VerboseOutput;
                KdcClient.VerboseOutput=true; //be verbose while we run these
            }

            public override void PostRun()
            {
                KdcClient.VerboseOutput=prevKdcVerbose;
            }

            //gets a real (non-vip) internal-facing IP for every kdc
            protected static string[] GetKdcIPs()
            {
                System.Net.IPEndPoint[] eps = ManagementListener.GetXmgmtEndPoints(xonline.common.config.Interface.kdcsvc);
                if (eps.Length == 0)
                {
                    throw new System.Exception("GetXmgmtEndPoints returned 0 entries for " + xonline.common.config.Interface.kdcsvc);
                }

                string[] ips = new string[eps.Length];
                for (int i = 0; i < eps.Length; ++i)
                {
                    ips[i] = eps[i].Address.ToString();
                }

                return ips;
            }

            //runs an xmgmt command on every KDC
            protected static void ExecuteXmgmtCommand(string command)
            {
                Global.RO.Debug("Running command on every kdc: " + command);
                string[] serverIPs = GetKdcIPs();
                for (uint i = 0; i < (uint)serverIPs.Length; ++i)
                {
                    string result;
                    bool worked = ServerTestFramework.LiveService.ManagementConsole.Execute(serverIPs[i], command, out result);
                    if (!worked || result.Contains("not found"))
                    {
                        throw new System.Exception("xmgmt command failed on KDC " + serverIPs[i] + ": " + result);
                    }
                }
            }


            private static object ticketLock = new object();

            //Returns whether we think nCipher is enabled for this environment
            protected static bool IsNCipherEnabled()
            {
                try
                {
                    return Global.XEnv.GetBoolSetting("kdcsvc_xmacs_useNCipher");
                }
                catch (System.Exception e) //assume ncipher works if we can't access npdb to check
                {
                    Global.RO.Warn("Exception trying to check npdb setting kdcsvc_xmacs_useNCipher, so assuming that nCihper is enabled.\nException message: " + e.Message);
                    return true;
                }
            }

            //verifies xkdc replies are success
            public static void VerifyXkdcResult(XkdcGenericReplyOutput result)
            {
                //overall HR
                ValueCheck.Test("Overall HR for site "+result.SiteIP, 0, result.Hr);

                //verify that all requested services were granted or on another site
                foreach (XkdcGenericReplyOutput.ServiceResult service in result.ServiceResults)
                {
                    if (!(service.Hr==0 || service.Hr==1))
                    {
                        throw new UnexpectedTestResultException("Service "+service.Service+" was not granted for site "+result.SiteIP+": ServiceHr="+service.Hr);
                    }
                }

                //verify user HRs
                int i=0;
                foreach (uint uhr in result.HrUser)
                {
                    ValueCheck.Test("User hr["+i+"]", 0, uhr);
                    ++i;
                }
            }

            // -- tests

            [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Verifies that xmgmt is responding for xmacs, askdc, and xkdc on each KDC."), TestCasePriority(0)]
            public class XmgmtCheck : TestNode
            {
                public override void Run()
                {
                    ExecuteXmgmtCommand("e :xmacs uptime");
                    ExecuteXmgmtCommand("e :askdc uptime");
                    ExecuteXmgmtCommand("e :xkdc uptime");
                }
            }

            //xbox360 tests
            [TestGroup, AsyncGroup(1), Description("xbox360 tests")]
            public class Xbox360 : TestNode
            {
                protected static KdcClientXbox360 kdc0=null; //for the machine-only request
                protected static KdcClientXbox360 kdc1=null; //for the user key request
                protected static KdcClientXbox360 kdc2=null; //for the user passport request

                //xmacs request, using the test key.  this actually does 2 requests, to set up 2 contexts to use for later tests.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an xmacs request using the test key."), TestCasePriority(0)]
                public class Xmacs_TestKey : TestNode
                {
                    public override void Run()
                    {
                        //create one to be used for machine only requests
                        kdc0=new KdcClientXbox360();
                        kdc0.CreateXmacsRequest();
                        kdc0.XmacsRequest.Input.UseTestKey=true;
                        kdc0.ExecuteXmacs(true);

                        //create one to be used for user key requests
                        kdc1=new KdcClientXbox360();
                        kdc1.CreateXmacsRequest();
                        kdc1.XmacsRequest.Input.UseTestKey=true;
                        kdc1.ExecuteXmacs(true);

                        //create one to be used for user passport requests
                        kdc2=new KdcClientXbox360();
                        kdc2.CreateXmacsRequest();
                        kdc2.XmacsRequest.Input.UseTestKey=true;
                        kdc2.ExecuteXmacs(true);
                    }
                }

                //xmacs request, using the test key.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an xmacs reset on a machine using the test key."), RunDependency("Xmacs_TestKey")]
                public class Xmacs_TestKey_Reset : TestNode
                {
                    public override void Run()
                    {
                        kdc1.CreateXmacsRequest();
                        kdc1.ExecuteXmacs(true);
                    }
                }

                //xmacs request, using the normal key (requires nCipher)
                [TestCase, Owner("lukel"), TestFrequency("BVT"), EnvRequirement("ncipher"), Description("Do an xmacs request using the normal key.")]
                public class Xmacs_RealKey : TestNode
                {
                    public override void Run()
                    {
                        //first check if ncipher is enabled for xmacs in this environment.  if not then skip out.
                        if (!IsNCipherEnabled())
                        {
                            throw new DidNotExecuteException("NCipher is not enabled in this environment, so not running NormalKey test.");
                        }

                        //do the request
                        KdcClientXbox360 kdc=new KdcClientXbox360();
                        kdc.CreateXmacsRequest();
                        kdc.XmacsRequest.Input.UseTestKey=false;
                        kdc.ExecuteXmacs(true);
                    }
                }

                //askdc machine-only
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an askdc request for only a machine."), RunDependency("Xmacs_TestKey")]
                public class Askdc_MachineOnly : TestNode
                {
                    public override void Run()
                    {
                        kdc0.CreateAskdcMachineRequest();
                        kdc0.ExecuteAskdc(true);
                    }
                }

                //askdc user
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an askdc request for a machine+user with key auth."), RunDependency("Xmacs_TestKey")]
                public class Askdc_KeyUser : TestNode
                {
                    public override void PreRun()
                    {
                        //make sure the user is available
                        GetCachedUser(false);
                    }

                    public override void Run()
                    {
                        kdc1.ClearAskdc();

                        kdc1.CreateAskdcMachineRequest();
                        kdc1.ExecuteAskdc(true);

                        kdc1.CreateAskdcUserRequest(GetCachedUser(false));
                        kdc1.AskdcRequest.Input.EncryptedPassport=null;
                        kdc1.ExecuteAskdc(true);
                    }
                }

                //askdc user
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an askdc request for a machine+user with passport auth."), RunDependency("Xmacs_TestKey")]
                public class Askdc_PassportUser : TestNode
                {
                    public override void PreRun()
                    {
                        //make sure the user is available
                        GetCachedUser(true);
                    }

                    public override void Run()
                    {
                        kdc2.ClearAskdc();

                        kdc2.CreateAskdcMachineRequest();
                        kdc2.ExecuteAskdc(true);

                        KdcUser user=GetCachedUser(true);
                        kdc2.CreateAskdcUserRequest(user);
                        kdc2.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                        kdc2.ExecuteAskdc(true);
                    }
                }

                //xkdc machine-only request
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an xkdc request for only a machine."), RunDependency("LiveBVT.LiveFoundation.KDC.Xbox360.Askdc_MachineOnly")]
                [CompoundCase("SR2", 4, null)]
                [CompoundCase("SR3V5", 5, 5)]
                [CompoundCase("SR3V6", 5, 6)]
                public class Xkdc_MachineOnly : TestNode
                {
                    public override void Run()
                    {
                        uint preauthToUse=(uint)(int)MyValues[0];
                        ushort? preauthVersion=MyValues[1]==null?(ushort?)null:(ushort?)(int)MyValues[1];

                        //copy output from askdc/xmacs to use for xkdc on a new client
                        KdcClientXbox360 kdc=new KdcClientXbox360();
                        kdc.XmacsOutput=kdc0.XmacsOutput;
                        kdc.AskdcOutput=kdc0.AskdcOutput;

                        //do requests
                        while (kdc.XkdcResultHasMoreSites())
                        {
                            kdc.SetXkdcRequestForNextSite();
                            kdc.XkdcRequest.Input.TitleID=Xbox360TitleID;
                            kdc.XkdcRequest.Input.XenonPreauthVersion=preauthToUse;
                            kdc.XkdcRequest.Input.ServiceRequestVersion=preauthVersion;
                            kdc.ExecuteXkdc(true);

                            VerifyXkdcResult(kdc.XkdcOutput);
                        }
                    }
                }

                //xkdc user request
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an xkdc request with a user"), RunDependency("LiveBVT.LiveFoundation.KDC.Xbox360.Askdc_KeyUser")]
                [CompoundCase("SR2", 4, null)]
                [CompoundCase("SR3V5", 5, 5)]
                [CompoundCase("SR3V6", 5, 6)]
                public class Xkdc_User : TestNode
                {
                    public override void Run()
                    {
                        uint preauthToUse=(uint)(int)MyValues[0];
                        ushort? preauthVersion=MyValues[1]==null?(ushort?)null:(ushort?)(int)MyValues[1];

                        //copy output from askdc/xmacs to use for xkdc on a new client
                        KdcClientXbox360 kdc=new KdcClientXbox360();
                        kdc.XmacsOutput=kdc1.XmacsOutput;
                        kdc.AskdcOutput=kdc1.AskdcOutput;

                        //We need the user trusted on this machine for V6+
                        if (preauthVersion!=null && (ushort)preauthVersion>=6)
                        {
                            KdcUser user=GetCachedUser(false);

                            UserMachineHistoryEditor umhe=UserMachineHistoryEditor.CreateOrUseExisting(user.UserID, kdc.XmacsOutput.MachineId);
                            Global.RO.Debug("Setting user 0x{0:X} as trusted on machine 0x{1:X}.", user.UserID, kdc.XmacsOutput.MachineId);
                            umhe.TrustLevel=1;
                        }

                        //do requests
                        while (kdc.XkdcResultHasMoreSites())
                        {
                            kdc.SetXkdcRequestForNextSite();
                            kdc.XkdcRequest.Input.TitleID=Xbox360TitleID;
                            kdc.XkdcRequest.Input.XenonPreauthVersion=preauthToUse;
                            kdc.XkdcRequest.Input.ServiceRequestVersion=preauthVersion;
                            kdc.ExecuteXkdc(true);

                            VerifyXkdcResult(kdc.XkdcOutput);
                        }
                    }
                }
            }

            //panorama tests
            [TestGroup, AsyncGroup(1), Description("PC tests")]
            public class PC : TestNode
            {
                protected static KdcClientPC kdc0=null; //for the machine-only request
                protected static KdcClientPC kdc0xmacs2=null; //for the machine-only request, xmacs preauth 2
                protected static KdcClientPC kdc1=null; //for the user request

                //xmacs request using the normal unlimited test voucher.  this actually does 2 requests, to set up 2 contexts to use for later tests.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do a normal xmacs request."), AsyncGroup(1)]
                public class Xmacs_Normal : TestNode
                {
                    public override void PreRun()
                    {
                        //ensure we have a cached user and ticket ready
                        GetCachedUser(true);
                    }

                    public override void Run()
                    {
                        KdcUser user=GetCachedUser(true);

                        //create one to be used for machine only requests
                        kdc0=new KdcClientPC();
                        kdc0.CreateXmacsRequest();
                        kdc0.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        kdc0.ExecuteXmacs(true);

                        //create one to be used for user requests
                        kdc1=new KdcClientPC();
                        kdc1.CreateXmacsRequest();
                        kdc1.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        kdc1.ExecuteXmacs(true);
                    }
                }

                //xmacs reset request using the normal unlimited test voucher.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do a normal xmacs reset."), RunDependency("Xmacs_Normal")]
                public class Xmacs_Normal_Reset : TestNode
                {
                    public override void Run()
                    {
                        KdcUser user=GetCachedUser(true);

                        kdc1.CreateXmacsRequest();
                        kdc1.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        kdc1.ExecuteXmacs(true);
                    }
                }

                //xmacs request using the normal unlimited test voucher.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do a normal xmacs request."), AsyncGroup(1)]
                public class Xmacs2_Normal : TestNode
                {
                    public override void PreRun()
                    {
                        //ensure we have a cached user and ticket ready
                        GetCachedUser(true);
                    }

                    public override void Run()
                    {
                        KdcUser user=GetCachedUser(true);

                        //create one to be used for machine only requests
                        kdc0xmacs2=new KdcClientPC();
                        kdc0xmacs2.CreateXmacsRequest();
                        kdc0xmacs2.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
                        kdc0xmacs2.ExecuteXmacs(true);
                    }
                }

                //xmacs reset request using the normal unlimited test voucher.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do a normal xmacs reset."), RunDependency("Xmacs2_Normal")]
                public class Xmacs2_Normal_Reset : TestNode
                {
                    public override void Run()
                    {
                        KdcUser user=GetCachedUser(true);

                        kdc0xmacs2.CreateXmacsRequest();
                        kdc0xmacs2.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
                        kdc0xmacs2.ExecuteXmacs(true);
                    }
                }

                //xmacs request, using the limited PC voucher, which causes the machine account to be tagged as limited.
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do limited xmacs request.")]
                public class Xmacs_Limited : TestNode
                {
                    public override void PreRun()
                    {
                        //ensure we have a cached user and ticket ready
                        GetCachedUser(true);
                    }

                    public override void Run()
                    {
                        KdcUser user=GetCachedUser(true);

                        KdcClientPC kdc=new KdcClientPC();
                        kdc.CreateXmacsRequest();
                        kdc.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        kdc.XmacsRequest.Input.SponsorToken=XmacsPCRequestInput.LIMITED_MACHINE_TOKEN;
                        kdc.ExecuteXmacs(true);
                    }
                }

                //askdc machine-only
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an askdc request for only a machine."), RunDependency("Xmacs_Normal")]
                public class Askdc_MachineOnly : TestNode
                {
                    public override void Run()
                    {
                        kdc0.CreateAskdcMachineRequest();
                        kdc0.ExecuteAskdc(true);
                    }
                }

                //askdc user
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an askdc request for a machine+user."), RunDependency("Xmacs_Normal")]
                public class Askdc_User : TestNode
                {
                    public override void PreRun()
                    {
                        //make sure the user is available
                        GetCachedUser(true);
                    }

                    public override void Run()
                    {
                        KdcUser user=GetCachedUser(true);

                        kdc1.CreateAskdcUserRequest(user);
                        kdc1.AskdcRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        kdc1.ExecuteAskdc(true);

                        kdc1.CreateAskdcMachineRequest();
                        kdc1.ExecuteAskdc(true);
                    }
                }

                //xkdc machine-only request
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an xkdc request for only a machine."), RunDependency("Askdc_MachineOnly")]
                public class Xkdc_MachineOnly : TestNode
                {
                    public override void Run()
                    {
                        while (kdc0.XkdcResultHasMoreSites())
                        {
                            kdc0.SetXkdcRequestForNextSite();
                            kdc0.XkdcRequest.Input.TitleID=PCTitleID;
                            kdc0.ExecuteXkdc(true);

                            VerifyXkdcResult(kdc0.XkdcOutput);
                        }
                    }
                }

                //xkdc user request
                [TestCase, Owner("lukel"), TestFrequency("BVT"), Description("Do an xkdc request with a user"), RunDependency("Askdc_User")]
                public class Xkdc_User : TestNode
                {
                    public override void Run()
                    {
                        while (kdc1.XkdcResultHasMoreSites())
                        {
                            kdc1.SetXkdcRequestForNextSite();
                            kdc1.XkdcRequest.Input.TitleID=PCTitleID;
                            kdc1.ExecuteXkdc(true);

                            VerifyXkdcResult(kdc1.XkdcOutput);
                        }
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Storage BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class Storage : TestNode
        {
            private static RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();

            /// <summary>
            /// Read and write from Cross Title Domain
            /// </summary>
            [TestCase, Owner("JKonkle"), Description("Storage Read/Write Execution"), EnvRequirement(""), TestFrequency("BVT"), TestTag("XBlob"),]
            public class CrossTitleTest : TestNode
            {
                public override void Run()
                {
                    string readUrl = String.Format("//global/t:FFFE07D1/ach/1/{0}", DateTime.Now.ToString("yyyyMMddHHmmss"));
                    // Write a random file to Cross Storage...
                    XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", readUrl, 8000, true);
                    byte[] rand = new byte[8000];
                    rng.GetBytes(rand);
                    rand.CopyTo(writeReq.blobData, 0);

                    if (!writeReq.Execute())
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed to write to Global Domain: {0}", writeReq.XErr.ToString("x")));
                    }

                    // Read it back
                    XRLReadFileResponse readResp;
                    XRLReadFile readReq = new XRLReadFile(readUrl);
                    if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.stfd_storage), out readResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed to read from Global Domain: {0}", readReq.XErr.ToString("x")));
                    }
                }
            }
        }

        [TestGroup, Description("Verification that the databases are in a good state.")]
        public class Database: TestNode
        {
            [TestGroup]
            public class Uodb: TestNode
            {
                [TestCase]
                [Owner("LukeL"), TestFrequency("BVT")]
                public class VerifyReplication: TestNode
                {
                    public override void Run()
                    {
                        //connect to webstore to get information about uodb
                        using (WstConnection con=new WstConnection(WSClient.SiteName+ConfigUtil.UodbWebstoreApp))
                        {
                            con.Open();

                            //first see if this environment even has replicas set up (xblobs don't), and if it does that all partitions have the same count and are in a good state
                            Global.RO.Info("Checking all partitions...");
                            System.Nullable<int> firstFSSCount=null;
                            string firstSetName=null;
                            foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
                            {
                                if (firstFSSCount==null)
                                {
                                    firstSetName=failSafeSet.PrimaryDB.Name;
                                    firstFSSCount=failSafeSet.Databases.Count;
                                }
                                else if (failSafeSet.Databases.Count!=firstFSSCount)
                                {
                                    throw new UnexpectedTestResultException("UODB Partitions have an inconsistent number failsafe sets.  The set for "+failSafeSet.PrimaryDB.Name+" has "+failSafeSet.Databases.Count+", but the set for "+firstSetName+" has "+firstFSSCount);
                                }

                                foreach (WebstoreDatabase wsdb in failSafeSet.Databases)
                                {
                                    if (wsdb.Status!=WebstoreResourceStatus.Online)
                                    {
                                        throw new UnexpectedTestResultException("Database "+wsdb.Name+" on "+wsdb.ServerName+" has a unexpected status: "+wsdb.Status);
                                    }
                                }
                            }

                            if (firstFSSCount==null)
                            {
                                throw new UnexpectedTestResultException("There are no UODB databases!");
                            }

                            if (firstFSSCount==1) //xblobs don't have failsafe sets, the databases count for each partition is 1 in this case, so consider us ok
                            {
                                Global.RO.Info("This environment does not have UODB replication.");
                                return;
                            }

                            //write a piece of data to each primary
                            Global.RO.Info("Writing data to all primaries...");
                            System.Collections.Generic.Dictionary<WebstoreSQLFss, ulong> partitionMachines=new System.Collections.Generic.Dictionary<WebstoreSQLFss, ulong>();
                            foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
                            {
                                using (WstCommand cmd=con.CreateCommand())
                                {
                                    cmd.WstFailoverMode=WstFailoverMode.SpecificDatabase;
                                    cmd.Database=failSafeSet.PrimaryDB;
                                    cmd.CommandTimeout=10; //10 seconds should be more than plenty for a simple insert

                                    //build the query to add an entry to t_machines.  the machine doesn't have to be valid in any way, since all we're checking is that the data that we put here makes it to the replicas
                                    string cid="testrepl"+RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(7);
                                    ulong puid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
                                    int bucket=UodbWS.GetHashBucket(puid);
                                    cmd.CommandText="exec p_xmacs_insertmachine '"+cid+"', "+(long)puid+", "+(int)bucket+", 0, 0x0";

                                    Global.RO.Debug("Adding row to "+cmd.Database.Name+" ("+cmd.Database.ServerName+")");
                                    try
                                    {
                                        cmd.ExecuteNonQuery();
                                    }
                                    catch (System.Exception e)
                                    {
                                        throw new UnexpectedTestResultException("Exception executing query on server "+cmd.Database.ServerName+" on db "+cmd.Database.Name+": "+cmd.CommandText, e);
                                    }

                                    partitionMachines.Add(failSafeSet, puid);
                                }
                            }

                            //wait for that data to appear in the replicas
                            Global.RO.Info("Waiting for data to appear in replicas...");
                            System.DateTime startWaitTime=System.DateTime.UtcNow;
                            foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
                            {
                                ulong puid=partitionMachines[failSafeSet];

                                foreach (WebstoreDatabase wsdb in failSafeSet.Databases)
                                {
                                    if (wsdb==failSafeSet.PrimaryDB) //don't need to compare a db to itself
                                    {
                                        continue;
                                    }

                                    using (WstCommand cmd=con.CreateCommand())
                                    {
                                        cmd.WstFailoverMode=WstFailoverMode.SpecificDatabase;
                                        cmd.Database=wsdb;
                                        cmd.CommandTimeout=5; //5 seconds should be more than plenty for a simple select on the primary key
                                        cmd.CommandText="select count(*) from t_machines where bi_machine_puid="+(long)puid;

                                        while (true)
                                        {
                                            int count=0;
                                            try
                                            {
                                                count=(int)cmd.ExecuteScalar();
                                            }
                                            catch (System.Exception e)
                                            {
                                                throw new UnexpectedTestResultException("Exception executing query on server "+wsdb.ServerName+" on db "+wsdb.Name+": "+cmd.CommandText, e);
                                            }

                                            if (count==1) //it made it there
                                            {
                                                Global.RO.Debug("Found row in "+wsdb.Name+" ("+wsdb.ServerName+")");
                                                break;
                                            }

                                            const int secsToWait=30;
                                            if (System.DateTime.UtcNow-startWaitTime > new System.TimeSpan(0, 0, secsToWait)) //if we have to wait more than this long something is wrong
                                            {
                                                throw new UnexpectedTestResultException("Data in t_machines (puid="+(long)puid+") was not replicated from "+failSafeSet.PrimaryDB.Name+" ("+failSafeSet.PrimaryDB.ServerName+") to "+wsdb.Name+" ("+wsdb.ServerName+") within "+secsToWait+" seconds.");
                                            }

                                            System.Threading.Thread.Sleep(500); //not there yet, so wait half a second then check again
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }; // class Database

        [TestGroup]
        public class XMachine: TestNode
        {
            [TestCase, Owner("LukeL"), Description("Calls the XMachine LookupConsoleIdsByMachinePuids API with a single puid."), TestFrequency("BVT")]
            [LiveLKG]
            public void LookupConsoleIdsByMachinePuids()
            {
                MachineEditor mach=MachineEditor.CreateNew();
                Global.RO.Debug("Created machine: Puid=0x{0:X16} ConsoleId={1}", mach.Id, mach.ConsoleId);

                xonline.server.xmachine.fd.soap.MachinePuidInfo []ret=new xonline.server.xmachine.fd.soap.XMachineSoapClient().LookupConsoleIdsByMachinePuids(new ulong[]{mach.Id});
                ValueCheck.Test("Number of return values", 1, ret.Length);
                ValueCheck.Test("ConsoleId returned", mach.ConsoleId, ret[0].ConsoleId);
                ValueCheck.Test("MachinePuid returned", mach.Id, ret[0].MachinePuid);
            }

            [TestCase, Owner("LukeL"), Description("Calls the XMachine LookupMachinePuidsByConsoleIds API with a single console id."), TestFrequency("BVT")]
            [LiveLKG]
            public void LookupMachinePuidsByConsoleId()
            {
                MachineEditor mach=MachineEditor.CreateNew();
                Global.RO.Debug("Created machine: Puid=0x{0:X16} ConsoleId={1}", mach.Id, mach.ConsoleId);

                xonline.server.xmachine.fd.soap.ConsoleIdInfo []ret=new xonline.server.xmachine.fd.soap.XMachineSoapClient().LookupMachinePuidsByConsoleIds(new string[]{mach.ConsoleId});
                ValueCheck.Test("Number of return values", 1, ret.Length);
                ValueCheck.Test("ConsoleId returned", mach.ConsoleId, ret[0].ConsoleId);
                ValueCheck.Test("MachinePuid returned", mach.Id, ret[0].MachinePuid);
                ValueCheck.Test("SecondaryIdentifier returned", mach.CertHash, ret[0].SecondaryIdentifier);
            }
        }; //class XMachine

        [TestGroup]
        public class XUser : TestNode
        {
            [TestCase, Owner("LukeL"), Description("Sets the FriendlyName from null to a valid string"), TestFrequency("BVT")]
            public void MachineFriendlyNameSet()
            {
                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();
                UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

                string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
                new XUserTestSoapClient().MachineFriendlyNameSet(user.Puid, true, mach.Id, true, friendlyName);

                ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
            }

            [TestCase, Owner("LukeL"), Description("Verifies MachineGet for a user on one console"), TestFrequency("BVT")]
            public void MachineGet()
            {

                UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory("XE.067303653001", "XUser1Machin");

                XUserTestSoapClient client = XUserTestUtil.GetUserClient();

                xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
                if (machines.Length != 1)
                {
                    throw new ExpectedValueCheckException(
                            string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
                }
                XUserTestUtil.PrintMachines(machines);
                XUserTestUtil.VerifyMachine(machines[0], ume);
            }

            [TestCase, Owner("LukeL"), Description("Sets the trust level from Untrusted to Trusted"), TestFrequency("BVT")]
            public void MachineTrustLevelSet()
            {
                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();
                UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
                umh.TrustLevel=1;

                new XUserTestSoapClient().MachineTrustLevelSet(user.Puid, true, mach.Id, true, MachineTrustLevel.Untrusted, true);

                ValueCheck.Test("Machine trust level in DB", 0, umh.TrustLevel);
            }

            [TestCase, Owner("LukeL"), Description("Calls the UserKeyGet to verify basic functionality"), TestFrequency("BVT")]
            public void GetUserKey()
            {
                UserEditor user=UserEditor.CreateNew();
                UserKey ret=new XUserTestSoapClient().UserKeyGet(user.Puid, true);
                XUserTestUtil.ValidateUserKeyAgainstUserEditor(ret, user);
            }

            [TestCase, Owner("LukeL"), Description("Resets a valid users key information"), TestFrequency("BVT")]
            [LiveLKG]
            public void UserKeyReset()
            {
                UserEditor user=UserEditor.CreateNew();
                UserKey origKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);

                UserKey ret=new XUserTestSoapClient().UserKeyReset(user.Puid, true);
                XUserTestUtil.ValidateUserKeyAgainstUserEditor(ret, user);

                UserKey newKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
                XUserTestUtil.ValidateKeysAreDifferent(origKey, newKey);
            }

            [TestCase, Owner("LukeL"), Description("Verifies basic UserNotify functionality"), TestFrequency("BVT")]
            public void UserNotify()
            {
                XUserNotify xuserPost = new XUserNotify();
                UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
                Global.RO.Debug("Machine {0}, User: {1}", ume.MachinePuid, ume.UserPuid);
                xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
                HttpStatusCode resp = xuserPost.GetResponse();
                if (resp != HttpStatusCode.OK)
                {
                    throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
                }
                if (ume.LastSignin == null)
                {
                    throw new ExpectedValueCheckException("LastSignin not set");
                }

                if (ume.LastSignout != null)
                {
                    throw new ExpectedValueCheckException("LastSigout was set");
                }
            }

        }; //class XUser
    }


    /// <summary>
    ///
    /// Live Foundation Utility Class
    ///
    /// </summary>
    public class Utils
    {
        public const int XCacheWaitTimeInMS = 30000 + 5000;

        private static Dictionary<string, CachedUserInfo> cachedUsers = new Dictionary<string, CachedUserInfo>();
        private static Dictionary<string, CachedMachineInfo> cachedMachines = new Dictionary<string, CachedMachineInfo>();

        /// <summary>
        /// Get a user of a given type and platform.  If a user of this type has already been created,
        /// then return a cached one
        /// </summary>
        /// <param name="userType">The user type to create</param>
        /// <param name="platformName">The platform to create the user for</param>
        /// <returns>A new user of the provided type and platform, or the cached user if one exists</returns>
        public static CachedUserInfo GetCachedUser(UserCreationType userType, string platformName)
        {
            string key = Global.XEnv.GetEnv() + "*" + userType.ToString() + "*" + platformName;
            CachedUserInfo user = new CachedUserInfo();

            lock (cachedUsers)
            {
                if (cachedUsers.ContainsKey(key))
                {
                    user = cachedUsers[key];
                }
                else
                {
                    //directly create the user (very fast and eliminates dependiences on FDs)
                    Global.RO.Info("Directly creating a user of type " + userType.ToString() + "(" + platformName + ")...");
                    UserEditor directUser = UserEditor.CreateNew(userType);
                    user.Puid = directUser.Puid;
                    user.Gamertag = directUser.Gamertag;
                    if (userType == UserCreationType.Xbox1)
                    {
                        user.Key = directUser.XboxKey;
                    }
                    else
                    {
                        user.Key = directUser.XenonKey;
                    }
                    user.CreatedDate = (directUser.CreatedDate != null ? (DateTime)directUser.CreatedDate : DateTime.UtcNow);
                    user.HasLinkedPassport = false;

                    System.Threading.Thread.Sleep(500); //give replication a moment to catch up??

                    Global.RO.Debug("New " + userType.ToString() + "(" + platformName + ") user created: Gamertag=" + user.Gamertag + " and Puid=0x" + string.Format("{0:X}", user.Puid));
                    cachedUsers.Add(key, user);
                }
            }

            return user;
        }

        /// <summary>
        /// Delay for the required time until a newly created user is picked up by XCache
        /// </summary>
        /// <param name="user">The user to wait on</param>
        public static void WaitOnXCache(CachedUserInfo user)
        {
            int msSinceCreation = (int)(DateTime.UtcNow - user.CreatedDate).TotalMilliseconds;
            int msToWait = XCacheWaitTimeInMS - msSinceCreation;
            if (msToWait > 0)
            {
                Global.RO.Info("Waiting {0}s on new user to be picked up by xcache...", (int)(msToWait / 1000));
                System.Threading.Thread.Sleep(msToWait);
            }
        }

        /// <summary>
        /// Get a machine information blob for a common machine
        /// </summary>
        /// <returns>A new machine, or the cached on if it already exists</returns>
        public static CachedMachineInfo GetCachedMachine(MachineType machineType)
        {
            string key = Global.XEnv.GetEnv() + "*" + machineType.ToString();
            CachedMachineInfo machine = new CachedMachineInfo();

            lock (cachedMachines)
            {
                if (cachedMachines.ContainsKey(key))
                {
                    machine = cachedMachines[key];
                }
                else
                {
                    //do it directly
                    try
                    {
                        Global.RO.Info("Directly creating a machine...");
                        MachineEditor me = MachineEditor.CreateNew(machineType);
                        machine.ConsoleId = me.ConsoleId;
                        machine.Id = me.Id;
                    }
                    catch (System.Exception e)
                    {
                        Global.RO.Warn("Directly creating machine failed: " + e + "\nFalling back to using xmacs.");

                        //that failed for some reason, so try going through xmacs
                        AuthContext ctx = new AuthContext(AuthContext.ClientTypes.Xenon);
                        ctx.UseXmacsTestKey = true;
                        XmacsClient xmacs = new XmacsClient(ctx);
                        xmacs.EmulateClientBehavior = true;
                        xmacs.SignInXmacs();

                        machine.Id = xmacs.GetMachinePuid();
                        machine.ConsoleId = "XE." + xmacs.ConsoleId;
                    }

                    Global.RO.Debug("New machine created: ConsoleId=" + machine.ConsoleId + " and Id=0x" + string.Format("{0:X}", machine.Id));
                    cachedMachines.Add(key, machine);
                }
            }

            return machine;
        }
    }

    /// <summary>
    /// Stores information about a cached user
    /// </summary>
    public class CachedUserInfo
    {
        public ulong Puid;
        public string Gamertag;
        public byte[] Key;
        public DateTime CreatedDate;

        public bool HasLinkedPassport;
        public string PPUserName = null;
        public string PPUserPassword = null;
        public byte[] SessionKey = null;
        public byte[] TicketBlob = null;
    }

    /// <summary>
    /// Stores information about a cached machine
    /// </summary>
    public class CachedMachineInfo
    {
        public ulong Id;
        public string ConsoleId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\Common.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.lfm;
using live.server;

using ServerTestFramework;

namespace xonline.test.stftests.LiveBVT
{
    /// <summary>
    /// This attribute should be applied only to TestCase classes.
    /// This flags tests within the LiveBVT suite as LKG-level BVT cases
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public class LiveLKGAttribute : TestTagAttribute
    {
        public LiveLKGAttribute() : base("LiveLKG") { }
    }
    
    public static class Common
    {
        public const uint GAME_TITLE_ID = 0xFFFF0072;

        public static uint CreateBVTUser(XblUserTier tier, PassportType passportType, ref live.lfm.Xbox360 console, out live.common.XblUser user, bool loginToTitle)
        {
            int retryCount = 0;
            uint hr = 0; 
            user = null;
            live.common.XblUserSettings settings = null;
            

            
            do
            {
                try
                {
                    if (null == console)
                    {
                        console = new Xbox360();
                        console.Client.BypassKDC = true;

                        if (loginToTitle)
                        {
                            // sign into a title
                            console.Client.TitleObject = new TitleBase(GAME_TITLE_ID.ToString("X8") + ".xlast");
                            console.Client.TitleObject.ParseXlast();
                        }
                    }

                    settings = new live.common.XblUserSettings(tier, passportType);
                    GamerAge age = GamerAge.FromBirthDate(settings.PersonalInfo.BirthDate);
                    CountryInfo countryInfo = Countries.CountryInfo(settings.PersonalInfo.CountryId);
                    settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;
                    settings.UserPassportInfo.CountryId = settings.PersonalInfo.CountryId;

                    if (age.AgeInYears >= (int)countryInfo.Billing)
                    {
                        PassportUtils.CreatePassportAccounts(console.Client, settings, true);
                    }
                    else
                    {
                        if (settings.UserPassportInfo.MemberName == settings.OwnerPassportInfo.MemberName)
                        {
                            settings.OwnerPassportInfo.MemberName = settings.OwnerPassportInfo.MemberName.Replace("@", "_owner@");
                        }
                        PassportUtils.CreatePassportAccounts(console.Client, settings, false);
                    }


                    hr = UACS.XeCreateLiveAccount(console.Client, settings, out user);
                    
                    if (0 == hr)
                    {
                        console.Client.UserLoggingOn(user);
                        Presence.Alive2(console.Client, user);
                        Presence.SetState(console.Client, user, live.protocol.Presence.XonPresNoti.P_STATE_MASK_ONLINE);
                        console.Client.LoggedOnUsers.Add(user);
                        console.ActiveUser = user;
                        return hr;
                    }
                    else
                    {
                        Global.RO.Error("CreateUser failed with hr: " + HResult.XErrToString(hr));
                        Global.RO.Info(" Retrying...");
                        console = null;
                        retryCount++;
                    }
                }
                catch (XErrFailedException xerr)
                {
                    Global.RO.Error("Failed to create user: {0}\n{1}", HResult.XErrToString(xerr.HResult), xerr.ToString());
                    Global.RO.Info(" Retrying...");
                    hr = xerr.HResult;
                    retryCount++;
                    console = null;
                    continue;
                }                
            }
            while (retryCount <10);
            Global.RO.Info("Finally give up to create user!");
            return hr;                        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\CommunityAndGames.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Xml;
using live.common;
using live.lfm;
using live.lfm.xbox360Internal;
using live.protocol;
using live.protocol.Presence;
using live.server;
using Microsoft.Xbox.Identity;
using Microsoft.Xbox.Privacy.Client;
using Microsoft.Xbox.Privacy.Interfaces;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
// Can't include the whole xonline.common.config namespace as it conflicts with live.common.config
using CommonConfig = xonline.common.config.Config;
using Setting = xonline.common.config.Setting;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace xonline.test.stftests.LiveBVT
{
    [TestGroup]
    public class CommunityAndGames : TestNode
    {
        ///////////////////////////////////////////////////////////////////////
        //
        //  Privacy BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class Privacy : TestNode 
        {
            public override void PreRun()
            {
                base.PreRun();
            }

            [TestCase, Owner("nkoller"), TestFrequency("BVT"), EnvRequirement(""), LiveLKG]
            public class HealthCheck : TestNode 
            {
                public override void Run() 
                {
                    var virtualInterface = new ServerTestFramework.LiveService.XConfig().GetVirtualInterface("privacy_int");
                    live.lfm.Xbox360 xbox360 = new Xbox360();

                    XeUser user1 = new XeUser();
                    XeUser user2 = new XeUser();
                    user1.Create();
                    user2.Create();
                    FriendsCommon.WaitForXCache();
                    Thread.Sleep(TimeSpan.FromSeconds(10));

                    PrivacyRule[] rules = new PrivacyRule[] 
                    {
                        new PrivacyRule(new PrivacyRuleKey(PrivacySetting.GameHistory, Relationship.Everyone), false),
                        new PrivacyRule(new PrivacyRuleKey(PrivacySetting.GameHistory, Relationship.Friends), true)
                    };

                    using (PrivacyClientInternal internalClient = new PrivacyClientInternal(new IPEndPoint(virtualInterface.Address, virtualInterface.Port))) 
                    {
                        // make sure we can get the templates
                        internalClient.GetPCGLegacyTemplateRules();

                        // these don't have a return value, just make sure they don't fail.
                        internalClient.SetPrivacy(user1.UserPuid, rules);

                        bool gameHistoryCheckUser1User2 = internalClient.CheckPrivacy(new PrivacyCheckRequest(user2.UserPuid, user1.UserPuid, PrivacySetting.GameHistory));

                        Assert.AreEqual(false, gameHistoryCheckUser1User2);

                        FriendsCommon fc = new FriendsCommon();

                        using (PNUser viewerPNUser = new PNUser(user1.Gamertag, user1.UserPuid))
                        {
                            using (PNUser targetPNUser = new PNUser(user2.Gamertag, user2.UserPuid))
                            {
                                fc.MakeFriend(viewerPNUser, targetPNUser);
                            }
                        }
                        FriendsCommon.WaitForXCache();
                        Thread.Sleep(TimeSpan.FromSeconds(10));

                        gameHistoryCheckUser1User2 = internalClient.CheckPrivacy(new PrivacyCheckRequest(user1.UserPuid, user2.UserPuid, PrivacySetting.GameHistory));
                        Assert.AreEqual(true, gameHistoryCheckUser1User2);
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Feedback BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class Feedback : TestNode
        {
            protected static int idx = 0;
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static Xbox360 observingXbox = null;
            protected static XblUser observingUser = null;

            public override void PreRun()
            {
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
                observingXbox = new Xbox360();
                observingUser = observingXbox.SignUp.CreateUser();
                observingXbox.Live.Logon(observingUser, xbox360.Client.TitleId);
                Thread.Sleep(Int32.Parse(CommonConfig.GetSetting(Setting.xcache_db_pollingInterval)) * 1000);
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class SendReview : TestNode
            {
                public override void Run()
                {
                    FeedbackDefs.PlayerReview playerReview = FeedbackDefs.PlayerReview.AvoidTrashTalk;
                    live.server.Feedback.SendReview(xbox360.Client, user, observingUser.Puid, xbox360.Client.TitleId, playerReview, GetContext());
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class FileComplaint : TestNode
            {
                public override void Run()
                {
                    FeedbackDefs.ComplaintType complaintType = FeedbackDefs.ComplaintType.OffensiveInGame;
                    live.server.Feedback.SendComplaint(xbox360.Client, user, observingUser.Puid, xbox360.Client.TitleId, complaintType, GetContext());
                }
            }

            public static ulong GetContext()
            {
                return (ulong)(0xFF000 + Interlocked.Increment(ref idx));
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Stats BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class Stats : TestNode
        {
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;

            public override void OneTimeSetup()
            {
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
            }

            [TestGroup]
            public class Achievements : TestNode
            {
                private static StatsSpec[] statsSpecs = new StatsSpec[1];

                [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
                public class EnumAchievements : TestNode
                {
                    public override void Run()
                    {
                        AchievementEnumResponse resp = live.server.Achievements.EnumAchievement(xbox360.Client, user, xbox360.Client.TitleObject.TitleId, user.Puid, 0, 0, 32);
                    }
                }

                [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
                public class SyncAchievements : TestNode
                {
                    public override void Run()
                    {
                        live.protocol.Achievement[] achievements = new live.protocol.Achievement[1];
                        achievements[0] = new live.protocol.Achievement(1, DateTime.UtcNow, (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED);
                        SyncAchievementsResponse resp = live.server.Achievements.SyncAchievements(xbox360.Client, user, xbox360.Client.TitleObject.TitleId, achievements);
                    }
                }

                [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
                public class StatsEnumByUser : TestNode
                {
                    public override void Run()
                    {
                        StatsSpec statsSpec = new StatsSpec();
                        uint[] keys = new uint[xbox360.Client.TitleObject.Leaderboards.Count];
                        xbox360.Client.TitleObject.Leaderboards.Keys.CopyTo(keys, 0);
                        statsSpec.ViewId = xbox360.Client.TitleObject.Leaderboards[keys[Randomizer.Random.Next(xbox360.Client.TitleObject.Leaderboards.Count)]].LeaderBoardId;

                        statsSpecs[0] = statsSpec;
                        StatsEnumResponse resp = live.server.Stats.StatsEnumByUser(xbox360.Client, user, user.Puid, statsSpecs);
                    }
                }

                [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
                public class StatsEnumByRank : TestNode
                {
                    public override void Run()
                    {
                        ulong rank = 1;
                        StatsEnumResponse resp = live.server.Stats.StatsEnumByRank(xbox360.Client, user, rank, statsSpecs);
                    }
                }

                [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
                public class StatsEnumByRating : TestNode
                {
                    public override void Run()
                    {
                        ulong rating = 1;
                        StatsEnumResponse resp = live.server.Stats.StatsEnumByRating(xbox360.Client, user, rating, statsSpecs);
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Community BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class Community : TestNode
        {
            private static GamerProfileScene gamercard;
            private static CompareGamesScene games;
            //private static GameAchievementsScene achievements;
            private static EditGamerProfileScene editGamercard;
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static Xbox360 observingXbox = null;
            protected static XblUser observingUser = null;

            public override void PreRun()
            {
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
                observingXbox = new Xbox360();
                observingUser = observingXbox.SignUp.CreateUser();
                observingXbox.Live.Logon(observingUser, xbox360.Client.TitleId);
                Thread.Sleep(Int32.Parse(CommonConfig.GetSetting(Setting.xcache_db_pollingInterval)) * 1000);
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class SendFriendRequest : TestNode
            {
                public override void Run()
                {
                    xbox360.Live.Friends.AddFriend(user, observingUser);
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class ViewFriends : TestNode
            {
                public override void Run()
                {
                    ulong[] friends = new ulong[1];
                    friends[0] = observingXbox.ActiveUser.Puid;
                    UserSettings.ReadSettings(xbox360.Client, user, xbox360.Client.TitleId, friends,
                        new uint[]
                        {
                            ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,
                            ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY
                        });
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class ViewMessages : TestNode
            {
                public override void Run()
                {
                    PNState pn = Presence.GetPresence(user);
                    UserMsgFolder msgFolder = new UserMsgFolder(pn);
                    ushort numberOfMessages = msgFolder.Load2();

                    foreach (UserMessage msg in msgFolder.Inbox)
                    {
                        if (msg.Type == ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.MSG_TYPE_FRIEND_REQUEST)
                            continue;
                        uint hr = msg.GetDetails(pn);
                        if (!HResult.Succeeded(hr))
                            throw new Exception("Failed to load message details with HR=0x" + hr.ToString("x"));

                    }
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class SendMessage : TestNode
            {
                public override void Run()
                {
                    xbox360.Live.Messages.SendPersonalMessage(user, new XblUser(observingUser.Puid, observingUser.Gamertag), "Hello From Live BVT!");
                }
            }

            [TestCase, Owner("paully"), TestFrequency("BVT"), EnvRequirement("")]
            public class ViewGamercard : TestNode
            {
                public override void Run()
                {
                    xbox360.Live.Profile.GamerProfileScene.InitGamercard(observingUser.Puid);
                    gamercard = xbox360.Live.Profile.GamerProfileScene;
                }
            }

            [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
            public class CompareGames : TestNode
            {
                public override void Run()
                {
                    games = xbox360.Live.Profile.GamerProfileScene.ViewCompareGamesScene;
                }
            }

            [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
            public class EditGamerProfile : TestNode
            {
                public override void Run()
                {
                    editGamercard = xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene;
                }
            }

            [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
            public class EditMotto : TestNode
            {
                public override void Run()
                {
                    string motto = string.Format("My Motto - {0}", DateTime.Now.ToShortTimeString());
                    xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene.EditMotto(motto);
                }
            }

            [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
            public class EditGamerZone : TestNode
            {
                public override void Run()
                {
                    int gamerZone = 1;
                    xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene.EditGamerZone(gamerZone);
                }
            }

            [TestCase, Owner("kkline"), TestFrequency("BVT"), EnvRequirement("")]
            public class EditGamerPicture : TestNode
            {
                public override void Run()
                {
                    // the personal gamer picture XPROFILE_GAMERCARD_PERSONAL_PICTURE has a requirement that
                    // the 24 unicode characters be of the format FFFE07000000XXXX0000XXXX where XXXX must be
                    // a random number because that is how the caller determines if the picture has updated to they can
                    // update the cached picture. FFFE0700 is used as the titleid as it is the X_CUSTOM_PICTURE_TITLEID
                    int randomInt = Randomizer.Random.Next(9999);
                    string gamerPicture = string.Format("FFFE0700" + "0000" + randomInt.ToString("X4") + "0000" + randomInt.ToString("X4"));

                    // This call is actually going to update both the public and personal picture key, but only
                    // the personal picture key gets this gamerPicture string with the random value.
                    xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene.EditGamerPicture(gamerPicture);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Match BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class MatchGroup : TestNode
        {
            //private static Session session;
            private static ulong sessionId;
            private static uint privateSlots;
            private static uint publicSlots;
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static Xbox360 observingXbox = null;
            protected static XblUser observingUser = null;

            public override void OneTimeSetup()
            {
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
                observingXbox = new Xbox360();
                observingUser = observingXbox.SignUp.CreateUser();
                observingXbox.Live.Logon(observingUser, xbox360.Client.TitleId);
                Thread.Sleep(Int32.Parse(CommonConfig.GetSetting(Setting.xcache_db_pollingInterval)) * 1000);
            }

            [TestCase, Owner("jeffng"), TestFrequency("BVT"), EnvRequirement("")]
            public class CreateSession : TestNode
            {
                public override void Run()
                {
                    privateSlots = 0;
                    publicSlots = 2;

                    MatchSessionReply matchSessionReply = live.server.Matchmaking.CreateSession(xbox360.Client, user, publicSlots, privateSlots);
                    sessionId = matchSessionReply.qwSessionId;
                    privateSlots--;
                }
            }

            [TestCase, Owner("jeffng"), TestFrequency("BVT"), EnvRequirement("")]
            public class JoinSession : TestNode
            {
                public override void Run()
                {
                    live.server.Matchmaking.UpdateSession(xbox360.Client, user, sessionId, publicSlots--, publicSlots++);
                }
            }

            [TestCase, Owner("jeffng"), TestFrequency("BVT"), EnvRequirement("")]
            public class SearchSession : TestNode
            {
                public override void Run()
                {
                    MatchSearchReply resp = live.server.Matchmaking.SearchSession(observingXbox.Client, observingUser);
                }
            }

            [TestCase, Owner("jeffng"), TestFrequency("BVT"), EnvRequirement("")]
            public class SendGameInvite : TestNode
            {
                public override void Run()
                {
                    PNState pn = Presence.GetPresenceForRequest(xbox360.Client, user);
                    PNState targetPn = Presence.GetPresence(new XblUser(observingUser.Puid, observingUser.Gamertag));
                    pn.Invite(new PNState[] { targetPn }, 42);

                }
            }

            [TestCase, Owner("jeffng"), TestFrequency("BVT"), EnvRequirement("")]
            public class DeleteSession : TestNode
            {
                public override void Run()
                {
                    live.server.Matchmaking.DeleteSession(xbox360.Client, user, sessionId);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Connection Server BVT
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class ConnectionServerGroup : TestNode
        {
            protected static int idx = 0;
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static Xbox360 observingXbox = null;
            protected static XblUser observingUser = null;

            public override void PreRun()
            {
                Global.RO.Info("CreateConnection.PreRun");
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
                observingXbox = new Xbox360();
                observingUser = observingXbox.SignUp.CreateUser();
                observingXbox.Live.Logon(observingUser, xbox360.Client.TitleId);
                Thread.Sleep(Int32.Parse(CommonConfig.GetSetting(Setting.xcache_db_pollingInterval)) * 1000);
            }

            [TestCase, Owner("shailesh"), TestFrequency("BVT"), EnvRequirement("")]
            public class CreateConnection : TestNode
            {
                public override void Run()
                {
                    ITransaction currentTransObj = xbox360.Client.GetTransactionObject(XOService.ConnectionServer);
                    IXOnSecurityProvider currentProvider = currentTransObj.SecurityProvider;
                    if (currentProvider.GetType() != typeof(live.client.FakeSGSecurityProvider))
                    {
                        throw new DidNotExecuteException("This test needs FakeSG to run. Skipping this test since current security provider type is " + currentProvider.GetType().ToString());
                    }

                    Global.RO.Info("Beginning CreateConnection");
                    ServerTestFramework.LiveService.XConnSrv.PNConnection connection = null;

                    //Connect the user to connection server.
                    connection = new ServerTestFramework.LiveService.XConnSrv.PNConnection(xbox360.Client.MachinePuid);
                    ServerTestFramework.LiveService.XConnSrv.CONNECT_REPLY reply = connection.Connect(new int[] { 0 }, new ulong[] { user.Puid });
                    if (reply.hr != 0)
                    {
                        throw new UnexpectedTestResultException("Connect failed with HR : " + reply.hr.ToString());
                    }


                    //Create dos for basic notification for observingUser
                    DATA_OBJECT_SPECIFIER[] basic = new DATA_OBJECT_SPECIFIER[1];
                    DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
                    doSpec.dwDataSubType = 0;
                    doSpec.qwOwnerXUID = observingUser.Puid;
                    doSpec.wDataType = (ushort)DATA_TYPES.eBasicPresence;
                    //unsafe
                    //{
                    //    doSpec.wObjectSize = (ushort)sizeof(BASIC_PRESENCE_DATA);
                    //}
                    doSpec.wObjectSize = 56; //Since we can't use unsafe here, the objectsize is hardcoded to size of BASIC_PRESENCE_DATA
                    basic[0] = doSpec;

                    //Subscribe to observingUser
                    ServerTestFramework.LiveService.XConnSrv.SUBSCRIBE_REPLY subscribereply_basic = connection.Subscribe(basic);
                    if (subscribereply_basic.hr != 0)
                    {
                        throw new UnexpectedTestResultException("Subscribe failed with HR : " + subscribereply_basic.hr.ToString());
                    }


                    //Hook in for receiving notification
                    NotificationCounter ctr = new NotificationCounter();
                    connection.Notified += new ServerTestFramework.LiveService.XConnSrv.ConnSrvConnection.NotifiedEventHandler(ctr.OnNotification);

                    //bring up the observingUser
                    Presence.SetState(observingXbox.Client, observingUser, ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.P_STATE_MASK_ONLINE | ServerTestFramework.LiveService.PresNotiCommon.XonPresNoti.P_STATE_MASK_PLAYING);
                    Thread.Sleep(3000);

                    if (ctr.Count == 0)
                    {
                        throw new UnexpectedTestResultException("Notification counter is 0. We did not recieve notification in time.");
                    }
                }
            }

            public class NotificationCounter
            {
                public int Count = 0;
                public void OnNotification(object oSender, ServerTestFramework.LiveService.XConnSrv.ConnSrvConnection.NotifiedEventArgs args)
                {
                    Count++;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\LicenseUtils.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.Catalog;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.protocol;

using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;

namespace xonline.test.stftests.LiveBVT
{
    public class LicenseUtils
    {
        public enum VIDEOTYPE
        {
            MOVIE = 0,
            TV
        }

        public enum VIDEOQUALITY
        {
            HD = 0,
            SD,
            XD
        }

        public enum LICENSETYPE
        {
            LICENSE11,
            LICENSE12,
            LICENSE13,
            LICENSE14,
            LICENSE15
        }

        public class MediaMatrix
        {
            public List<VideoInformation> MovieOffers;
            public List<VideoInformation> TVOffers;

            public VideoInformation ZuneDTOVideoOffer_1;
            public VideoInformation ZuneDTOVideoOffer_2;

            public MediaInformation Season_Offer;

            public GameInformation TexasHoldEmOffer;
            //public GameInformation SmashTVOffer;
            public GameInformation GameOfferLicense11;
            public GameInformation GameOfferLicense12;
            public GameInformation GameOfferLicense13;
            public GameInformation GameOfferLicense14;
            public GameInformation GameOfferLicense15;
            public GameInformation GameOfferGeofenced;
            public GameInformation AvatarOffer;

            public GameInformation InGameContent;
            public GameInformation Theme;
            public GameInformation GamerPicture;
            public GameInformation GameDemo;
            public GameInformation ArcadeGame;

            public MediaMatrix()
            {
                MovieOffers = new List<VideoInformation>();
                TVOffers = new List<VideoInformation>();

                //
                // This is messy, but it's the best way to get the data that we need
                // in one place.
                //

                ZuneDTOVideoOffer_1 = new VideoInformation(
                    new Guid("68602D7A-D6CE-4B70-B989-11B48E3F4DC7"),
                    new MediaInstanceInfo(
                        new Guid("68602D7A-D6CE-4B70-B989-11B48E3F4DC7"),
                        new Guid("5482715D-E60D-4694-8B06-0E3AE887FFF2"),
                        160),
                    new MediaInstanceInfo(
                        new Guid("68602D7A-D6CE-4B70-B989-11B48E3F4DC7"),
                        new Guid("5482715D-E60D-4694-8B06-0E3AE887FFF2"),
                        160)
                    );

                ZuneDTOVideoOffer_2 = new VideoInformation(
                    new Guid("3B2B540F-C83E-4DA1-9AB5-09D5FD6A93AC"),
                    new MediaInstanceInfo(
                        new Guid("3B2B540F-C83E-4DA1-9AB5-09D5FD6A93AC"),
                        new Guid("C7DD6ABC-7935-429C-9615-ACBD58DAD95B"),
                        160),
                    new MediaInstanceInfo(
                        new Guid("3B2B540F-C83E-4DA1-9AB5-09D5FD6A93AC"),
                        new Guid("C7DD6ABC-7935-429C-9615-ACBD58DAD95B"),
                        160)
                    );

                Season_Offer = null;

                TexasHoldEmOffer = new GameInformation(new Guid("00000001-0000-4000-8000-0000584107F6"), 800);
                TexasHoldEmOffer.ContentId =
                    new Byte[] { 0xBD, 0x58, 0xCC, 0x03,
                             0xA4, 0xAA, 0x36, 0x99, 
                             0x59, 0x0E, 0x34, 0xE4, 
                             0xE0, 0x65, 0xBB, 0xC0,
                             0x56, 0xDE, 0x59, 0x8F };
                //SmashTVOffer = new GameInformation(new Guid("66ACD000-77FE-1000-9115-D802584107E1"), 400);
                GameOfferLicense11 = new GameInformation(new Guid("11000000-0000-4000-8000-0000584107d8"), 200, LICENSETYPE.LICENSE11, new Guid("B7C618DC-4D87-40E8-809B-8E8E76AF6DC9"));
                GameOfferLicense12 = new GameInformation(new Guid("12000000-0000-4000-8000-0000584107d8"), 200, LICENSETYPE.LICENSE12, new Guid("B7C618DC-4D87-40E8-809B-8E8E76AF6DC9"));
                GameOfferLicense13 = new GameInformation(new Guid("13000000-0000-4000-8000-0000584107d8"), 200, LICENSETYPE.LICENSE13, new Guid("B7C618DC-4D87-40E8-809B-8E8E76AF6DC9"));
                GameOfferLicense14 = new GameInformation(new Guid("14000000-0000-4000-8000-0000584107d8"), 200, LICENSETYPE.LICENSE14, new Guid("B7C618DC-4D87-40E8-809B-8E8E76AF6DC9"));
                GameOfferLicense15 = new GameInformation(new Guid("15000000-0000-4000-8000-0000584107d8"), 200, LICENSETYPE.LICENSE15, new Guid("B7C618DC-4D87-40E8-809B-8E8E76AF6DC9"));

                GameOfferGeofenced = new GameInformation(new Guid("14000000-0000-4000-8000-0000584107d9"), 200, LICENSETYPE.LICENSE14, new Guid("B7C618DC-4D87-40E8-809B-8E8E76AF6DC9"));

                AvatarOffer = new GameInformation(new Guid("00000047-0000-4000-8000-000050190002"), 0, LICENSETYPE.LICENSE12, new Guid("10000000-0047-4000-8000-000220130002"), 47);
                AvatarOffer.ContentId = Hexer.unhex("0x1000000000470000000050190000");

                InGameContent = new GameInformation(new Guid("000000B1-0000-4000-8000-0000FFFE07D1"), 0, LICENSETYPE.LICENSE14);
                Theme = new GameInformation(new Guid("000000B2-0000-4000-8000-0000FFFE07D1"), 0, LICENSETYPE.LICENSE14);
                GamerPicture = new GameInformation(new Guid("000000B3-0000-4000-8000-0000FFFE07D1"), 0, LICENSETYPE.LICENSE14);
                GameDemo = new GameInformation(new Guid("000000B5-0000-4000-8000-0000FFFE07D1"), 0, LICENSETYPE.LICENSE14);
                ArcadeGame = new GameInformation(new Guid("000000B6-0000-4000-8000-0000FFFE07D1"), 0, LICENSETYPE.LICENSE14);
            }

            /// <summary>
            /// Dumps out the data about each offer that was collected from the query.
            /// </summary>
            public void DumpMediaInfo()
            {

                Global.RO.Info("####[ Movie Offers: {0} ]####", MovieOffers.Count);
                foreach (MediaInformation info in MovieOffers)
                {
                    info.Dump();
                }

                Global.RO.Info("####[ TV Offers: {0} ]####", TVOffers.Count);
                foreach (MediaInformation info in TVOffers)
                {
                    info.Dump();
                }
            }

            /// <summary>
            ///  Searches the specified list for the offer.
            /// </summary>
            /// <param name="offers">The list of media info to search</param>
            /// <param name="offer">The item to look for</param>
            /// <returns>True if the item exists, false otherwise</returns>        
            private bool OfferExist<T>(List<T> offers, T offer) where T : MediaInformation
            {
                return offers.Exists(delegate(T t)
                {
                    return t.Equals(offer);
                });
            }

            /// <summary>
            /// Get a single media information object from the catalog
            /// </summary>
            /// <param name="type">The type of media to find</param>
            /// <param name="quality">The quality of media to find</param>
            /// <returns>A list contaning a single media item of the requested type</returns>
            public List<VideoInformation> GetOffers(VIDEOTYPE type, VIDEOQUALITY quality)
            {
                return GetOffers(type, quality, 1);
            }

            /// <summary>
            /// Get a number of media information objects from the catalog
            /// </summary>
            /// <param name="type">The type of media to find</param>
            /// <param name="quality">The quality of media to find</param>
            /// <param name="count">The number of items to find</param>
            /// <returns>A list contaning media items of the requested type</returns>
            public List<VideoInformation> GetOffers(VIDEOTYPE type, VIDEOQUALITY quality, uint count)
            {
                List<VideoInformation> results = new List<VideoInformation>();

                switch (type)
                {
                    case VIDEOTYPE.MOVIE:
                        if (MovieOffers.Count >= count)
                        {
                            for (int i = 0; i < count; i++)
                            {
                                // Find the video instance that contains the quality the request contains.
                                foreach (MediaInstanceInfo videoInstance in MovieOffers[i].videoInstances)
                                {
                                    if ((videoInstance.flags & (uint)quality) == (uint)quality)
                                    {
                                        // Clone the VideoInformation but only add the video instance requested
                                        VideoInformation tempOffer = MovieOffers[i].Clone();
                                        tempOffer.videoInstances.Add(videoInstance);

                                        results.Add(tempOffer);
                                        break;
                                    }
                                }
                            }
                        }
                        break;

                    case VIDEOTYPE.TV:
                        if (TVOffers.Count >= count)
                        {
                            for (int i = 0; i < count; i++)
                            {
                                results.Add(TVOffers[i]);
                            }
                        }
                        break;
                };

                return results;
            }

            /// <summary>
            /// Runs a FindVideoOffer query and populates the matrix with the data it
            /// collected.  Creates a user and client automatically for the requests
            /// </summary>
            public void PopulateOfferTable()
            {
                Global.RO.Info("Populating offer info...");

                TVOffers.Clear();
                MovieOffers.Clear();

                QueryRequest<FindVideosFilter> findVideos = new QueryRequest<FindVideosFilter>();
                //QueryWebPayload<FindVideosFilter> findVideos = new QueryWebPayload<FindVideosFilter>();
                findVideos.Filter.Locale = "en-US";
                findVideos.Filter.LegalLocale = "en-US";
                findVideos.Filter.Store = 1;
                findVideos.Filter.PageSize = 25;
                findVideos.Filter.PageNum = 1;
                findVideos.Filter.DetailView = 3;
                findVideos.Filter.OfferFilterLevel = 2;
                findVideos.Filter.UserTypes = live.common.ListEx.NewList(2);
                findVideos.Filter.MediaTypes = live.common.ListEx.NewList(2);
                findVideos.Filter.OrderBy = 3;
                findVideos.Filter.OrderDirection = 2;
                findVideos.Filter.VideoFilter = 1;

                Global.RO.Info("Requesting Movie media...");
                if (findVideos.SendRequest())
                {
                    ParseFindVideoResponse(findVideos.Response);
                }
                else
                {
                    Global.RO.Error("Unable to request movie media");
                    return;
                }

                List<Guid> allMediaIds = new List<Guid>();
                foreach (MediaInformation mi in MovieOffers)
                {
                    Guid tempGuid = mi.mediaId;
                    allMediaIds.Add(tempGuid);
                }

                findVideos = new QueryRequest<FindVideosFilter>();
                //findVideos = new QueryWebPayload<FindVideosFilter>();
                findVideos.Filter.Locale = "en-US";
                findVideos.Filter.LegalLocale = "en-US";
                findVideos.Filter.Store = 1;
                findVideos.Filter.PageSize = 25;
                findVideos.Filter.PageNum = 1;
                findVideos.Filter.DetailView = 3;
                findVideos.Filter.OfferFilterLevel = 2;
                findVideos.Filter.UserTypes = live.common.ListEx.NewList(2);
                findVideos.Filter.MediaTypes = live.common.ListEx.NewList(8);
                findVideos.Filter.OrderBy = 3;
                findVideos.Filter.OrderDirection = 2;
                findVideos.Filter.VideoFilter = 1;

                Global.RO.Info("Requesting TV media...");
                if (findVideos.SendRequest())
                {
                    ParseFindVideoResponse(findVideos.Response);
                }
                else
                {
                    Global.RO.Error("Unable to request tv media");
                    return;
                }

                if (TVOffers.Count + MovieOffers.Count == 0)
                {
                    return;
                }

                foreach (MediaInformation mi in TVOffers)
                {
                    Guid tempGuid = mi.mediaId;
                    allMediaIds.Add(tempGuid);
                }

                QueryRequest<FindVideoOffersFilter> findOffers = new QueryRequest<FindVideoOffersFilter>();
                //QueryWebPayload<FindVideoOffersFilter> findOffers = new QueryWebPayload<FindVideoOffersFilter>();
                findOffers.Filter.Locale = "en-US";
                findOffers.Filter.LegalLocale = "en-US";
                findOffers.Filter.Store = 1;
                findOffers.Filter.PageSize = 100;
                findOffers.Filter.PageNum = 1;
                findOffers.Filter.DetailView = 5;
                findOffers.Filter.MediaIds = allMediaIds;
                findOffers.Filter.UserTypes = live.common.ListEx.NewList(2);
                findOffers.Filter.MediaTypes = live.common.ListEx.NewList(2, 8);

                Global.RO.Info("Requesting media offers...");
                if (findOffers.SendRequest())
                {
                    ParseFindVideoOffersResponse(findOffers.Response);
                }
                else
                {
                    Global.RO.Error("Unable to request media offers");
                    return;
                }

                CleanUpList(TVOffers);
                CleanUpList(MovieOffers);
                // Prints out all the different groups of content
                DumpMediaInfo();

                Global.RO.Info("Offer info successfully populated.");
            }

            /// <summary>
            /// Parses the repsonse recieved from a catalog FindVideo request and 
            /// stores all of the discovered media items in the MediaMatrix
            /// </summary>
            /// <param name="responseXml">The XML Catalog FindVideo response</param>
            private void ParseFindVideoResponse(string responseXml)
            {
                // Load the response
                XDocument resp = XDocument.Parse(responseXml);
                // And create the namespaces we need
                XNamespace ns = resp.Root.GetDefaultNamespace();
                XNamespace lns = resp.Root.GetNamespaceOfPrefix("live");

                // Look for each entry and grab the MediaId, Title and MediaType
                var entries = from e in resp.Descendants(ns + "entry")
                              select new
                              {
                                  id = StripGuidTags((String)e.Element(ns + "id")),
                                  title = (String)e.Element(ns + "title"),
                                  mediaType = (int)e.Element(lns + "media").Element(lns + "mediaType"),
                              };

                // Create a VideoInfo object for each entry
                foreach (var entry in entries)
                {
                    VideoInformation vinfo = new VideoInformation();
                    vinfo.mediaId = entry.id;
                    vinfo.title = entry.title;
                    vinfo.mediaType = entry.mediaType;

                    // And store it in the appropriate list
                    switch (vinfo.mediaType)
                    {
                        case 2: // Movie
                            {
                                if (!OfferExist(MovieOffers, vinfo))
                                    MovieOffers.Add(vinfo);
                            }
                            break;
                        case 8: // TVEpisode
                            {
                                if (!OfferExist(TVOffers, vinfo))
                                    TVOffers.Add(vinfo);
                            }
                            break;
                    };
                }
            }

            /// <summary>
            /// Parses the repsonse recieved from a catalog FindVideoOffers request 
            /// and stores all of the discovered offers in the MediaMatrix
            /// </summary>
            /// <param name="responseXml">The XML Catalog FindVideoOffers response</param>
            private void ParseFindVideoOffersResponse(string responseXml)
            {
                // Load the document from the response
                XDocument resp = XDocument.Parse(responseXml);
                // And create the namespaces we need to use
                XNamespace ns = resp.Root.GetDefaultNamespace();
                XNamespace lns = resp.Root.GetNamespaceOfPrefix("live");

                // Look through each of the entries
                var entries = from e in resp.Descendants(ns + "entry")
                              select new
                              {
                                  // And extract the offer data we want
                                  offerId = StripGuidTags((String)e.Element(ns + "id")),
                                  mediaType = (UInt32)e.Element(lns + "offer").Element(lns + "mediaType"),
                                  price = (UInt32)e.Element(lns + "offer").Element(lns + "offerInstances").Element(lns + "offerInstance").Element(lns + "pointsPrice"),
                                  mediaId = StripGuidTags((String)e.Element(lns + "mediaInstances").Element(lns + "videoMediaInstance").Element(lns + "mediaId")),
                                  videoInstanceId = StripGuidTags((String)e.Element(lns + "mediaInstances").Element(lns + "videoMediaInstance").Element(lns + "videoInstanceId")),
                                  videoDefinition = (String)e.Element(lns + "mediaInstances").Element(lns + "videoMediaInstance").Element(lns + "videoDefinition")
                              };

                // Then loop through each entry
                foreach (var entry in entries)
                {
                    VideoInformation videoInfo = null;

                    // Find a media item with the same media id and
                    // media type as the one in the current offer
                    var media = from mi in MovieOffers.Concat(TVOffers)
                                where entry.mediaId == mi.mediaId
                                   && entry.mediaType == mi.mediaType
                                select mi;

                    // If no media found, continue. This shouldn't happen, 
                    // but that's not what we're testing
                    if (media.Count() == 0)
                    {
                        continue;
                    }

                    // Get the media item
                    videoInfo = media.First();

                    // And add an offer instance
                    videoInfo.videoInstances.Add(
                        new MediaInstanceInfo(
                            entry.offerId,
                            entry.videoInstanceId,
                            entry.price,
                            GetVideoInstanceFlags(entry.videoDefinition)
                        ));

                }
            } // END ParseXML

            /// <summary>
            /// Strip any indentifier tags from the beginning of a GUID string
            /// and return the guid represented by the data
            /// </summary>
            /// <param name="guidString">The string from the XML document representing a GUID</param>
            /// <returns>A Guid representation of the string data</returns>
            private Guid StripGuidTags(string guidString)
            {
                return new Guid(guidString.Substring(guidString.LastIndexOf(':') + 1));
            }

            /// <summary>
            /// Convert a string video definition into it's corresponding flags
            /// </summary>
            /// <param name="videoDefinition">The video definition string</param>
            /// <returns>A UInt32 representation of the flags</returns>
            private UInt32 GetVideoInstanceFlags(String videoDefinition)
            {
                UInt32 flags = 0x0;

                switch (videoDefinition.ToLower())
                {
                    case "hd":
                        flags = (UInt32)VIDEOQUALITY.HD;
                        break;
                    case "sd":
                        flags = (UInt32)VIDEOQUALITY.SD;
                        break;
                    case "xd":
                        flags = (UInt32)VIDEOQUALITY.XD;
                        break;
                    default:
                        break;
                }

                return flags;
            }

            /// <summary>
            /// Loop through a list of media info items and remove all
            /// empty video instances from each one.  Then remove all
            /// empty media items.
            /// </summary>
            /// <param name="videoInfoList">The list of items to clean</param>
            private void CleanUpList(List<VideoInformation> videoInfoList)
            {
                // Loop through each video info object
                videoInfoList.RemoveAll(
                    delegate(VideoInformation vi)
                    {
                        // Remove all empty media instances
                        vi.videoInstances.RemoveAll(MediaInstanceInfo.CheckEmpty);

                        // Then remove this media item, if it has no media instances
                        return vi.videoInstances.Count == 0;
                    }
                );
            }
        }

        /// <summary>
        /// Encapsulates all of the information for a single media item, including the media type, 
        /// offer and media ids and information and specific media instances
        /// </summary>
        public class MediaInformation
        {
            public Guid offerId;
            public Guid mediaId;
            public string title = null;

            public int mediaType = 0;
            public uint flags = 0; //1 = HD, 2 = SD, 3 = XD?

            public virtual Guid OfferId { get { return offerId; } }
            public virtual Guid MediaId { get { return mediaId; } }
            public virtual UInt32 ExpectedPrice { get { return 0; } }

            public OfferMediaTypeExpectedPrice OfferMediaTypeExpectedPrice
            {
                get
                {
                    OfferMediaTypeExpectedPrice offer = new OfferMediaTypeExpectedPrice();
                    offer = new OfferMediaTypeExpectedPrice();

                    offer.ExpectedPriceWhole = ExpectedPrice;
                    offer.ExpectedPriceFractional = 0;
                    offer.MediaTypeId = mediaType;
                    offer.OfferId = OfferId;

                    return offer;
                }
            }

            public OfferExpectedPrice OfferExpectedPrice
            {
                get
                {
                    OfferExpectedPrice offer = new OfferExpectedPrice();
                    offer.expectedPrice = ExpectedPrice;
                    offer.offerId = OfferId;

                    return offer;
                }
            }

            /// <summary>
            /// Create an empty MediaInformation object
            /// </summary>
            public MediaInformation()
            {
            }

            /// <summary>
            /// Creates a MediaInformation object for the given offerId with one or more media instances
            /// </summary>
            /// <param name="offerId">The Offer GUID to create the info for</param>
            public MediaInformation(Guid offerId)
            {
                this.offerId = offerId;
            }

            /// <summary>
            /// Creates a MediaInformation object for the given media properties
            /// </summary>
            /// <param name="offerId">The Offer GUID to create the info for</param>
            /// <param name="mediaId">The Media GUID to create the info for</param>
            /// <param name="mediaType">The media type of the media item</param>
            /// <param name="title">The title of the media item</param>
            /// <param name="flags">Additional media information</param>
            public MediaInformation(Guid offerId, Guid mediaId, int mediaType, string title, uint flags)
            {
                this.offerId = offerId;
                this.mediaId = mediaId;
                this.mediaType = mediaType;
                this.title = title;
                this.flags = flags;
            }

            /// <summary>
            /// Clone this media information object.
            /// </summary>
            /// <returns>A deep copy of this media information object</returns>
            public virtual MediaInformation Clone()
            {
                MediaInformation clone = new MediaInformation(this.offerId, this.mediaId, this.mediaType, this.title, this.flags);

                return clone;
            }

            /// <summary>
            /// Dump a bunch of debug information about this media item
            /// </summary>
            public virtual void Dump()
            {
                Global.RO.Debug("-------------------------------------------------- ");
                Global.RO.Debug("## [Title]\t\t\t" + title);
                Global.RO.Debug("## [MediaType]\t\t" + mediaType);
                Global.RO.Debug("## [OfferId]\t\t\t" + offerId);
                Global.RO.Debug("## [MediaId]\t\t\t" + mediaId);
            }
        }

        /// <summary>
        /// Encapsulates all of the information for a specific media instance
        /// </summary>
        public class MediaInstanceInfo
        {
            public Guid offerId;
            public Guid mediaInstanceId;
            public uint pointsPrice = 0;
            public uint flags = 0;

            public bool IsHD
            {
                get { return flags == (uint)VIDEOQUALITY.HD; }
            }

            public bool IsSD
            {
                get { return flags == (uint)VIDEOQUALITY.SD; }
            }

            /// <summary>
            /// True if this media instance has an empty OfferID or
            /// an empty MediaInstanceId
            /// </summary>
            public bool IsEmpty
            {
                get { return offerId == Guid.Empty || mediaInstanceId == Guid.Empty; }
            }

            /// <summary>
            /// Creates an empty MediaInstanceObject
            /// </summary>
            public MediaInstanceInfo()
            {
                this.offerId = Guid.Empty;
                this.mediaInstanceId = Guid.Empty;
            }

            /// <summary>
            /// Create a MediaInstance for the given offer/media instance ID pair and price
            /// </summary>
            /// <param name="offerId">The associated offer GUID</param>
            /// <param name="mediaInstanceId">The media instance GUID</param>
            /// <param name="pointsPrice">The price of this media instance</param>
            public MediaInstanceInfo(Guid offerId, Guid mediaInstanceId, uint pointsPrice)
            {
                this.offerId = offerId;
                this.mediaInstanceId = mediaInstanceId;
                this.pointsPrice = pointsPrice;
            }

            /// <summary>
            /// Create a MediaInstance for the given offer/media instance ID pair and price
            /// </summary>
            /// <param name="offerId">The associated offer GUID</param>
            /// <param name="mediaInstanceId">The media instance GUID</param>
            /// <param name="pointsPrice">The price of this media instance</param>
            /// <param name="flags">Additional media instance info</param>
            public MediaInstanceInfo(Guid offerId, Guid mediaInstanceId, uint pointsPrice, uint flags)
            {
                this.offerId = offerId;
                this.mediaInstanceId = mediaInstanceId;
                this.pointsPrice = pointsPrice;
                this.flags = flags;
            }

            /// <summary>
            /// Create a clone of this media instance object
            /// </summary>
            /// <returns>A copy of this MediaInstance object</returns>
            public MediaInstanceInfo Clone()
            {
                return new MediaInstanceInfo(this.offerId, this.mediaInstanceId, this.pointsPrice, this.flags);
            }

            /// <summary>
            /// Dump a bunch of debug information about this media item
            /// </summary>
            public void Dump()
            {
                Global.RO.Debug("#### [Media Instance]");
                Global.RO.Debug("###### [Definition]\t\t" + (IsHD ? "HD" : (IsSD ? "SD" : "XD")));
                Global.RO.Debug("###### [PointsPrice]\t" + pointsPrice);
                Global.RO.Debug("###### [OfferId]\t\t" + offerId);
                Global.RO.Debug("###### [MediaInstnaceId]\t" + mediaInstanceId);
            }

            public static bool CheckEmpty(MediaInstanceInfo mii)
            {
                return mii.IsEmpty;
            }
        }

        public class VideoInformation : MediaInformation
        {
            // MediaInstances
            public List<MediaInstanceInfo> videoInstances = new List<MediaInstanceInfo>();

            /// <summary>
            /// The default expected price, retrieved from the first video instance
            /// </summary>
            public override UInt32 ExpectedPrice
            {
                get { return videoInstances[0].pointsPrice; }
            }

            /// <summary>
            /// The default OfferId, retrieved from the first video instance
            /// </summary>
            public override Guid OfferId
            {
                get { return videoInstances[0].offerId; }
            }

            public MediaInstanceIdOfferIdPair MediaInstanceIdOfferIdPair
            {
                get
                {
                    MediaInstanceIdOfferIdPair pair = new MediaInstanceIdOfferIdPair();
                    pair.miid = videoInstances[0].mediaInstanceId;
                    pair.oid = OfferId;

                    return pair;
                }
            }

            /// <summary>
            /// Create and empty VideoInformation object
            /// </summary>
            public VideoInformation()
                : base()
            { }

            /// <summary>
            /// Creates a VideoInformation object for the given offerId with one or more media instances
            /// </summary>
            /// <param name="offerId">The Offer GUID to create the info for</param>
            /// <param name="videoInstanceList">MediaInstance information for the given offer</param>
            public VideoInformation(Guid offerId, params MediaInstanceInfo[] videoInstanceList)
                : base(offerId)
            {
                this.offerId = offerId;
                this.videoInstances.AddRange(videoInstanceList);
            }

            /// <summary>
            /// Creates a VideoInformation object for the given media properties
            /// </summary>
            /// <param name="offerId">The Offer GUID to create the info for</param>
            /// <param name="mediaId">The Media GUID to create the info for</param>
            /// <param name="mediaType">The media type of the media item</param>
            /// <param name="title">The title of the media item</param>
            /// <param name="flags">Additional media information</param>
            public VideoInformation(Guid offerId, Guid mediaId, int mediaType, string title, uint flags)
                : base(offerId, mediaId, mediaType, title, flags)
            { }

            /// <summary>
            /// Clone this media information object.  Does not clone video instances
            /// </summary>
            /// <returns>A deep copy of this media information object</returns>
            public new VideoInformation Clone()
            {
                return this.Clone(false);
            }

            /// <summary>
            /// Clone this media information object and optionally, any media instances
            /// </summary>
            /// <param name="cloneMediaInstances">If true, all media instances are cloned</param>
            /// <returns>A deep copy of this media information object and optionally it's media instances</returns>
            public VideoInformation Clone(bool cloneMediaInstances)
            {
                VideoInformation clone = new VideoInformation(this.offerId, this.mediaId, this.mediaType, this.title, this.flags);

                if (cloneMediaInstances)
                {
                    foreach (MediaInstanceInfo miInfo in this.videoInstances)
                    {
                        clone.videoInstances.Add(miInfo.Clone());
                    }
                }

                return clone;
            }

            public override void Dump()
            {
                base.Dump();

                foreach (MediaInstanceInfo mediaInstance in videoInstances)
                {
                    mediaInstance.Dump();
                }
            }
        }

        public class GameInformation : MediaInformation
        {
            /// <summary>
            /// This is currently just set to a default content ID that seems to work for the tests
            /// </summary>
            private Byte[] contentId = new Byte[] { 0xB7, 0xC6, 0x18, 0xDC, 
                                                0x4D, 0x87, 0xE8, 0x9B, 
                                                0x8E, 0x8E, 0x76, 0xAF, 
                                                0x6D, 0xC9, 0xB0, 0x50, 
                                                0x60, 0x3A, 0xFE, 0x9D };
            public Byte[] ContentId
            {
                get { return contentId; }
                set { contentId = value; }
            }

            private UInt32 expectedPrice = 0;
            public override uint ExpectedPrice
            {
                get { return this.expectedPrice; }
            }

            private Guid instanceId;
            public Guid InstanceId
            {
                get { return instanceId; }
            }

            private LICENSETYPE licenseType = LICENSETYPE.LICENSE11;
            public LICENSETYPE LicenseType
            {
                get { return licenseType; }
            }

            public GameInformation(Guid offerId, UInt32 expectedPrice)
                : this(offerId, expectedPrice, LICENSETYPE.LICENSE11, Guid.Empty, 23)
            { }

            public GameInformation(Guid offerId, UInt32 expectedPrice, LICENSETYPE licenseType)
                : this(offerId, expectedPrice, licenseType, Guid.Empty, 23)
            { }

            public GameInformation(Guid offerId, UInt32 expectedPrice, LICENSETYPE licenseType, Guid instanceId)
                : this(offerId, expectedPrice, licenseType, instanceId, 23)
            { }

            public GameInformation(Guid offerId, UInt32 expectedPrice, LICENSETYPE licenseType, Guid instanceId, int mediaType)
                : base()
            {
                this.offerId = offerId;
                this.expectedPrice = expectedPrice;
                this.licenseType = licenseType;
                this.instanceId = instanceId;
                this.mediaType = mediaType;
            }
        }

        public static void AddPoints(XeUser user, ulong machinePuid, ServerTestFramework.LiveService.Billing.Offers.PointsOffers offer)
        {
            Global.RO.Debug("Purchasing points offer {0} for user 0x{0:X}", offer, user.UserPuid);

            ServerTestFramework.LiveService.Billing.XRLXeOfferPurchase xrl = new ServerTestFramework.LiveService.Billing.XRLXeOfferPurchase();
            xrl.CountryID = user.CountryId;
            xrl.LanguageID = (ushort)user.LanguageId;
            xrl.Tier = 6;

            xrl.UserPuid = user.UserPuid;
            xrl.MachinePuid = machinePuid;
            
            xrl.OfferID = 0;
            xrl.OfferIDs = new ulong[] { ServerTestFramework.LiveService.Billing.Offers.GetPointsOfferId(offer) };
            xrl.OfferIDLength = (uint)xrl.OfferIDs.Length;

            xrl.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token;
            xrl.BillingToken = ServerTestFramework.LiveService.Billing.Offers.GetPointsOfferVoucherCode(offer);
            xrl.BillingTokenLength = (ushort)xrl.BillingToken.Length;
            xrl.PaymentInstrumentID = "";
            xrl.PaymentInstrumentIDLength = (ushort)xrl.PaymentInstrumentID.Length;

            for (int i = 0; i < 5; i++)
            {
                if (!xrl.Execute())
                {
                    if (i < 4)
                    {
                        Global.RO.Warn("Error attempting to purchase points.  Retrying. " + xrl.GetDumpString());
                    }
                    else
                    {
                        throw new XErrException(xrl.XErr,
                            String.Format("Unable to purchase points offer {0} for user 0x{1:X} - {2}", offer, user.UserPuid, xrl.GetDumpString()));
                    }
                }
                else
                {
                    break;
                }
            }
        }

        public static void PurchaseOffers(ulong userPuid, ulong machinePuid, ServerTestFramework.LiveService.Billing.OfferExpectedPrice[] offers)
        {
            XRLPurchaseOffers purchase = new XRLPurchaseOffers();

            purchase.UserPuid = userPuid;
            purchase.MachinePuid = machinePuid;

            purchase.Offers = offers;
            purchase.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
            purchase.BillingToken = "";
            purchase.PaymentInstrumentID = "";

            // Do we need this?
            //purchase.SchemaVersion = ServerTestFramework.WireData.MakeSchemaVersion(4, 0);

            if (!purchase.Execute())
            {
                throw new UnexpectedTestResultException("Unable to purchase offers: " + purchase.GetDumpString());
            }            
        }

        public static void PurchaseMediaOffers(ulong userPuid, ulong machinePuid, ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice[] offers)
        {
            XRLPurchaseMediaOffers purchase = new XRLPurchaseMediaOffers();

            purchase.UserPuid = userPuid;
            purchase.MachinePuid = machinePuid;            
            
            purchase.Offers = offers;
            purchase.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
            purchase.BillingToken = "";
            purchase.PaymentInstrumentID = "";

            if (!purchase.Execute())
            {
                throw new UnexpectedTestResultException("Unable to purchase offers: " + purchase.GetDumpString());
            }
        }

        public static AcquireMediaLicensesResponse AcquireMediaLicenses(ulong userPuid, ulong machinePuid, MediaInstanceIdOfferIdPair[] mediaIds)
        {
            XRLAcquireMediaLicenses acquire = new XRLAcquireMediaLicenses();
            
            acquire.Request.clientInfoBlocks = XRLAcquireMediaLicenses.GetValidSampleBlocks();
            acquire.Request.clientInfoBlockCount = (ushort)acquire.Request.clientInfoBlocks.Length;

            acquire.Request.userPuid = userPuid;
            acquire.Request.idPairs = mediaIds;

            if (!acquire.Execute(machinePuid))
            {
                throw new Exception("AcquireMediaLicenses request failed: " + acquire.GetDumpString());
            }

            return acquire.Response;
        }

        public static AcknowledgeLicensesDeliveryResponse AcknowledgeLicensesDelivery(ulong userPuid, ulong machinePuid, MediaInstanceIdOfferIdPair[] mediaIds)
        {
            XRLAcknowlegeLicensesDelivery acknowledge = new XRLAcknowlegeLicensesDelivery();

            acknowledge.Request.userPuid = userPuid;
            acknowledge.Request.idPairs = mediaIds;

            if (!acknowledge.Execute(machinePuid))
            {
                throw new Exception("AcquireMediaLicenses request failed: " + acknowledge.GetDumpString());
            }

            return acknowledge.Response;
        }

        public static RefreshGameLicenseResponse RefreshGameLicense(ulong userPuid, ulong machinePuid, byte[] licenseData)
        {
            XRLRefreshGameLicense refresh = new XRLRefreshGameLicense();

            refresh.Request.userId = userPuid;
            refresh.Request.machineId = machinePuid;
            refresh.Request.license = licenseData;

            if (!refresh.Execute())
            {
                throw new Exception("RefreshGameLicense request failed: " + refresh.GetDumpString());
            }

            return refresh.Response;
        }

        /// <summary>
        /// Generate a ContentLicense for a given Content ID Blob and a set of users
        /// </summary>
        /// <param name="_contentId">Conent ID Blob to license</param>
        /// <param name="_licensees">List of User PUIDS to generate license for</param>
        /// <returns>A content license for the provided content id blob and users</returns>
        public static ContentLicense GenerateLicenseData(Byte[] _contentId, ulong[] _licensees)
        {
            // Create a Signature and initialize everything
            ContentLicenseSignature signature = new ContentLicenseSignature();
            signature.signatureType = 0;
            signature.reserved = new byte[ContentLicense.ReservedLen];
            signature.signature = new byte[ContentLicense.LiveSignatureLen];

            // Create a Body for the license
            ContentLicenseBody body = new ContentLicenseBody();
            body.licensees = new ContentLicensee[ContentLicense.LicenseesLen];

            // Throw each licensee into the body and floor everything else
            for (int i = 0; i < ContentLicense.LicenseesLen; i++)
            {
                if (i < _licensees.Length)
                {
                    body.licensees[i] = new ContentLicensee();
                    body.licensees[i].licenseeId = _licensees[i];
                    body.licensees[i].licenseBits = 0;
                    body.licensees[i].licenseFlags = 0;
                }
                else
                {
                    body.licensees[i] = new ContentLicensee();
                    body.licensees[i].licenseeId = 0;
                    body.licensees[i].licenseBits = 0;
                    body.licensees[i].licenseFlags = 0;
                }
            }

            body.ContentId = _contentId;

            // Create a ContentLicense with the Body and Signature
            ContentLicense license = new ContentLicense();
            license.signature = signature;
            license.body = body;

            return license;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\ContentDownloadHandle.cs ===
using System;
using System.IO;

using xonline.common.config;

namespace LiveContentTest
{
	/// <summary>
	/// Static Utility class which simplifies accessing a path in the content download share,
	/// given a LiveContentData
	/// </summary>
	public class ContentDownloadHandle
	{
		/// <summary>
		/// Delete content from the previous content download share.  Does not report if the
		/// file was absent.
		/// </summary>
		public static void Nuke(ContentTestData testData, int site) 
		{
			Nuke(testData.TitleId, testData.ContentId, site);
			if (testData.HasSecondOfferFile())
			{
				Nuke(testData.TitleId, testData.ContentId2, site);
			} 
		}
		public static void Nuke(uint titleId, string contentId, int site) 
		{
			string contentFilePath = GetPath(titleId, contentId, site);
			if (File.Exists(contentFilePath)) 
			{
				Console.WriteLine("Found old content download package, deleting {0}", contentFilePath);
				File.Delete(contentFilePath);
			} 
		}

		/// <summary>
		/// Given a ContentTestData, verify whether the package specified in that data
		/// was copied to the download share.
		/// </summary>
		/// <param name="testData">Data specifying the package, titleId and contentId</param>
		public static bool Verify(ContentTestData testData, int site) 
		{
			bool passed = true;
			passed = passed && Verify(testData.TitleId, testData.ContentId, site);
			if (testData.HasSecondOfferFile()) 
			{
				passed = passed && Verify(testData.TitleId, testData.ContentId2, site);
			}
			return passed;
		}

		public static bool Verify(uint titleId, string contentId, int site) 
		{
			string contentFilePath = GetPath(titleId, contentId, site);
			if (!File.Exists(contentFilePath))
			{
				Console.WriteLine("Content package failed to copy to location:");
				Console.WriteLine(contentFilePath);
				return false;
			}
			return true;
		}

		/// <summary>
		/// Returns the expected path to the package stored in the content download directory
		/// </summary>
		/// <param name="titleId"></param>
		/// <param name="contentId"></param>
		/// <param name="site"></param>
		/// <returns></returns>
		private static string GetPath(uint titleId, string contentId, int site) 
		{
			IVirtualInterfaceInfo info;
			info = Config.GetVirtualInterface(VirtualInterface.download, site);

			string contentDownloadLocation = GetContentDownloadShare(site);
			string contentFilePath = Path.Combine(contentDownloadLocation, titleId.ToString("x"));
			contentFilePath = Path.Combine(contentFilePath, contentId + ".xcp");
			return contentFilePath;
		}
			
		/// <summary>
		/// Returns a UNC path to the share where content downloads are stored.  These are
		/// referred to by site.
		/// </summary>
		/// <remarks>
		/// This code is directly lifted from the LiveContent tool's DownloadServerList.cs
		/// </remarks>
		/// <param name="siteNum">The ID of the content download site.</param>
		private static string GetContentDownloadShare(int siteNum) 
		{

			string [] serverList = null;
			serverList = Config.GetServerListByInterface(Interface.download_share);

			//Names not yet cached
			for (int c=0; c<serverList.Length; c++) 
			{
				IInterfaceInfo info;
				string shareName;
				int siteId;

				info = Config.GetInterface(serverList[c], Interface.download_share);
				Config.GetServerInfo(serverList[c], out siteId);

				if(siteNum == siteId)
				{
					shareName = String.Format("\\\\{0}{1}\\", 
						info.IPAddressString, 
						info.Sharename);
                            
					if ((null == shareName) || (0 == shareName.Length)) 
					{
						throw new Exception("Invalid share name found when searching for content download server!");
					}
                            
					if ('\\' != shareName[shareName.Length-1])
						shareName += "\\";
					return shareName;
				}
			}
			//no matches!
			throw new Exception("No share name found when searching for content download server!");
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveBVT\Marketplace.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.lfm;
using live.lfm.xbox360Internal;
using live.lfm.xbox360Internal.HUD;
using live.protocol;
using live.server;

using ServerTestFramework;
using STFLive = ServerTestFramework.LiveService;
using STFUserAccount = ServerTestFramework.LiveService.UserAccount;
using STFBilling = ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Ratings;
using System.Threading;

using MIXTesting;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Serialization;


namespace xonline.test.stftests.LiveBVT
{
    [TestGroup]
    public class Marketplace : TestNode
    {
        ///////////////////////////////////////////////////////////////////////
        //
        //  Account Management BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class AccountManagementGroup : TestNode
        {
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static MarketplaceScene marketplace = null;

            public override void PreRun()
            {
                xbox360 = null;
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
                LfmState lfmState = new LfmState();
                lfmState.ActiveUser = user;
                lfmState.Client = xbox360.Client;
                marketplace = new MarketplaceScene(lfmState);
            }

            [TestCase, Owner("yixuanl"), TestFrequency("BVT"), TestCasePriority(1), EnvRequirement("Billing"), LiveLKG]
            public class UpdatePersonalInfo : TestNode
            {
                public override void Run()
                {
                    marketplace.AccountMgmt.PersonalInfoScene.UpdateInfo(Randomizer.Persons.RegularUserInfo);
                }
            }

            [TestCase, Owner("yuanfeiw"), TestFrequency("BVT"), TestCasePriority(1), EnvRequirement("Billing"), LiveLKG]
            public class ViewCurrentMembershipDetails : TestNode
            {
                public override void Run()
                {
                    CurrentSubscriptionsScene currentSubs = marketplace.AccountMgmt.ViewCurrentSubscriptionsScene;
                    int total = currentSubs.CurrentSubscriptions.Count();
                    int select = Randomizer.Random.Next(0, total);

                    CurrentSubscriptionScene currentSubDetail = currentSubs.CurrentSubscriptions[select];
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class ViewPaymentOptions : TestNode
            {
                public override void Run()
                {
                    PaymentOptionsScene paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class AddPaymentInstrument : TestNode
            {
                public override void Run()
                {
                    CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                    PaymentOptionsScene paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;

                    paymentOptions.AddPaymentInstrument(ccinfo);
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class PaymentOptionDetail : TestNode
            {
                public override void Run()
                {
                    PaymentOptionsScene paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;
                    if (paymentOptions.PISelector.Count() == 0)
                    {
                        CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                        paymentOptions.AddPaymentInstrument(ccinfo);
                        paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;
                    }
                    PaymentInstrumentScene selectedPaymentInstrument = paymentOptions.PISelector[0];
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class UpdatePaymentInstrument : TestNode
            {
                public override void Run()
                {
                    CreditCardInfo updatedCcInfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                    PaymentOptionsScene paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;

                    if (paymentOptions.PISelector.Count() == 0)
                    {
                        // gotta add a payment instrument before we can update it
                        CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                        paymentOptions.AddPaymentInstrument(ccinfo);
                        paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;
                    }
                    paymentOptions.PISelector[0].Update(updatedCcInfo);
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class PurchasePointswithCC : TestNode
            {
                public override void Run()
                {
                    // Get points must be called before purchasing.
                    uint points = UACS.XeGetPointsBalance(xbox360.Client, xbox360.ActiveUser);

                    // Make sure a credit card is associated with this user
                    PaymentOptionsScene paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;
                    if (paymentOptions.PISelector.Count() == 0)
                    {
                        CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                        paymentOptions.AddPaymentInstrument(ccinfo);
                    }

                    // Purchase the points
                    marketplace.PurchasePoints(Offers.PointsOffers.CC5000US).Confirm();
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class ViewMembershipDetails : TestNode
            {
                public override void Run()
                {
                    SubscriptionsScene newSubcriptions = marketplace.AccountMgmt.ViewSubscriptionsScene;
                    int total = newSubcriptions.availableSubscription.Count();
                    if (total > 0)
                    {
                        SubscriptionScene selectedSubscription = newSubcriptions.availableSubscription[0];
                    }
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class PurchaseSubscription : TestNode
            {
                public override void Run()
                {
                    SubscriptionsScene newSubcriptions = marketplace.AccountMgmt.ViewSubscriptionsScene;
                    int total = newSubcriptions.availableSubscription.Count();
                    if (total > 0)
                    {
                        for (int i = 0; i < total; i++)
                        {
                            if (((PurchasableItem)(newSubcriptions.availableSubscription[i].Subscription)).offerID == Offers.GetOfferId(Offers.BaseOffers.GoldCC1Month))
                            {
                                SubscriptionScene selectedSubscription = newSubcriptions.availableSubscription[i];
                                selectedSubscription.ConfirmPurchase();
                                return;
                            }
                        }

                    }
                    throw new Exception("Can not purchase since GoldCC1Month 0xFFFE07D180000008 does not get returned.");

                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class RedeemPointsCode : TestNode
            {
                public override void PreRun()
                {
                    XblUser tokenUser;
                    Common.CreateBVTUser( XblUserTier.Silver, PassportType.Real, ref xbox360, out tokenUser, true );
                    LfmState lfmState = new LfmState();
                    lfmState.ActiveUser = tokenUser;
                    lfmState.Client = xbox360.Client;
                    marketplace = new MarketplaceScene( lfmState );
                }

                public override void Run()
                {
                    marketplace.RedeemMSPointsCode(Offers.PointsOffers.PP4000, Offers.GetPrepaidVoucherCode(Offers.PointsOffers.PP4000)).RedeemNow();
                }
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing"), LiveLKG]
            public class RedeemSubscriptionCode : TestNode
            {
                public override void Run()
                {
                    marketplace.RedeemSubscriptionCode(Offers.BaseOffers.GoldPP1Month, Offers.GetPrepaidVoucherCode(Offers.BaseOffers.GoldPP1Month)).RedeemNow();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Server-Side Download Queue BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class ServerSideDownloadQueueGroup : TestNode
        {
            [TestCase, Owner("arnemich"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement(""), LiveLKG]
            public class DownloadQueueBVT : TestNode
            {
                protected const String ListProperties = "<RootNode><dest>100</dest></RootNode>";
                protected const String ModifiedListProperties = "<RootNode><dest>200</dest></RootNode>";
                protected const String ListItemXml =
                "<RootNode><effectiveTitleId>*</effectiveTitleId>" +
                "<mediaId>feeddeaf-beef-fade-bead-deed12345678</mediaId>" +
                "<mediaType>23</mediaType>" +
                "<ratingId>-1</ratingId>" +
                "<contentId>abc=</contentId>" +
                "<offerId>feeddeaf-beef-fade-bead-deed12345678</offerId>" +
                "<offerName>Testing</offerName>" +
                "<size>5</size>" + "<state>6</state></RootNode>";

                protected static XblUser user = null;
                protected static Xbox360 xbox360 = null;

                public override void PreRun()
                {
                    Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, false);
                }

                public override void Run()
                {
                    uint hr = 0;

                    // Go through all the List APIs                        
                    int listId = 0;
                    DateTime timestamp;

                    // CreateDownloadQueue
                    hr = DownloadQueue.CreateDownloadQueue(
                        xbox360.Client,
                        user,
                        "Test Download Queue",
                        ListProperties,
                        out listId,
                        out timestamp);

                    if (hr != 0)
                    {
                        throw new Exception(
                            "CreateDownloadQueue failed : 0x" +
                            hr.ToString("X8"));
                    }

                    // ModifyDownloadQueue
                    hr = DownloadQueue.ModifyDownloadQueue(
                        xbox360.Client,
                        user,
                        listId,
                        timestamp,
                        ModifiedListProperties,
                        out timestamp);

                    if (hr != 0)
                    {
                        throw new Exception(
                            "ModifyDownloadQueue failed : 0x" +
                            hr.ToString("X8"));
                    }

                    // QueryDownloadQueues
                    ListInfo[] results = null;
                    ushort totalLists = 0;
                    hr = DownloadQueue.QueryDownloadQueues(
                        xbox360.Client,
                        user,
                        listId,
                        new DateTime(1700, 1, 1),
                        1,
                        1,
                        1,
                        out results,
                        out totalLists);

                    if (hr != 0)
                    {
                        throw new Exception(
                            "QueryDownloadQueues failed : 0x" +
                            hr.ToString("X8"));
                    }

                    if (totalLists != 1)
                    {
                        throw new Exception(
                            String.Format(
                                "QueryDownloadQueues returned {0} " +
                                "lists but expected 1 list to be returned",
                                totalLists));
                    }

                    // InsertDownloadItems
                    live.protocol.ListItem[] items =
                        new live.protocol.ListItem[2];

                    items[0] = new live.protocol.ListItem();
                    items[0].itemId = Guid.NewGuid();
                    items[0].priority = 0;
                    items[0].xmlItem = ListItemXml.Replace("*", "0");

                    items[1] = new live.protocol.ListItem();
                    items[1].itemId = Guid.NewGuid();
                    items[1].priority = 0;
                    items[1].xmlItem = ListItemXml.Replace("*", "1");

                    hr = DownloadQueue.InsertDownloadItems(xbox360.Client,
                                                           user,
                                                           listId,
                                                           timestamp,
                                                           items,
                                                           out timestamp);

                    if (hr != 0)
                    {
                        throw new Exception(
                            "InsertDownloadItems failed : 0x" +
                            hr.ToString("X8"));
                    }

                    // QueryDownloadItems (Query all items)
                    live.protocol.ListItem[] queryItems = null;
                    ushort totalItems = 0;

                    hr = DownloadQueue.QueryDownloadItems(xbox360.Client,
                                                          user,
                                                          listId,
                                                          30,
                                                          1,
                                                          1,
                                                          new Guid[0],
                                                          out queryItems,
                                                          out totalItems,
                                                          out timestamp);

                    if (hr != 0)
                    {
                        throw new Exception(
                            "QueryDownloadItems failed : 0x" +
                            hr.ToString("X8"));
                    }

                    if (totalItems != 2)
                    {
                        throw new Exception(
                            String.Format(
                                "QueryDownloadItems returned {0} items " +
                                "but expected {1} items",
                                totalItems,
                                2));
                    }

                    // ModifyDownloadItems
                    ListItemMod[] modifiedItems = new ListItemMod[1];

                    // Modify the first item
                    modifiedItems[0] = new ListItemMod();
                    modifiedItems[0].itemId = items[0].itemId;
                    modifiedItems[0].xmlItem = ListItemXml.Replace("*", "2");

                    hr = DownloadQueue.ModifyDownloadItems(xbox360.Client,
                                                           user,
                                                           listId,
                                                           timestamp,
                                                           modifiedItems,
                                                           out timestamp);

                    if (hr != 0)
                    {
                        throw new Exception(
                            "ModifyDownloadItems failed : 0x" +
                            hr.ToString("X8"));
                    }

                    // MoveDownloadItems
                    ListItemIndex[] indices = new ListItemIndex[1];

                    // Move the second item to the top
                    indices[0] = new ListItemIndex();
                    indices[0].itemId = items[1].itemId;
                    indices[0].priority = 0;
                    indices[0].index = 0; // First slot

                    hr = DownloadQueue.MoveDownloadItems(xbox360.Client,
                                                         user,
                                                         listId,
                                                         timestamp,
                                                         indices,
                                                         out timestamp);
                    if (hr != 0)
                    {
                        throw new Exception(
                            "MoveDownloadItems failed : 0x" +
                            hr.ToString("X8"));
                    }

                    // DeleteDownloadItems

                    // Delete the first item
                    Guid[] itemIds = new Guid[1];
                    itemIds[0] = items[0].itemId;

                    hr = DownloadQueue.DeleteDownloadItems(xbox360.Client,
                                                           user,
                                                           listId,
                                                           timestamp,
                                                           itemIds,
                                                           out timestamp);


                    if (hr != 0)
                    {
                        throw new Exception(
                            "DeleteDownloadItems failed : 0x" +
                            hr.ToString("X8"));
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  User Rating BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class UserRatingsGroup : TestNode
        {
            public const string GameMediaId = "66ACD000-77FE-1000-9115-D802584107F6";  // BVT title 0x584107F6, Texas Holdem

            /// <summary>
            /// Obtains the XCache refresh period from NPDB and waits until the cache should have updated.
            /// </summary>
            public static void SleepUntilXCacheIsUpdated()
            {
                //
                // Get the interval and pad it by 10%, to ensure that the refresh has occurred before we
                // attempt to access the XCache.
                //
                float paddedPollingInterval = xonline.common.config.Config.GetIntSetting("xcache_db_pollingInterval") * 1000 * 1.1f;
                System.Threading.Thread.Sleep((int)paddedPollingInterval);
            }

            public static STFUserAccount.XeUser ratingUser = null;

            [TestCase, Owner("jeremyj"), TestFrequency("BVT"), EnvRequirement("Billing,Catalog"), TestCasePriority(1), LiveLKG]
            public class RateMediaBVT : TestNode
            {
                public override void Run()
                {
                    if (ratingUser == null || ratingUser.UserPuid == 0)
                    {
                        ratingUser = new STFUserAccount.XeUser(true, STFUserAccount.XeUser.Country.US);
                        if (ratingUser.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + ratingUser.GetDumpString());
                        SleepUntilXCacheIsUpdated();
                    }

                    XRLMsnSubmitRating request = new XRLMsnSubmitRating();
                    request.Request.userXuid = ratingUser.UserPuid;
                    request.Request.mediaId = new Guid(GameMediaId);
                    request.Request.ratingValue = 1;
                    request.Request.userCountryId = 103;
                    request.Slot.AddService(STFLive.XOService.Ratings);

                    //
                    // Make the Service Call
                    //
                    if (!request.Execute())
                    {
                        throw new UnexpectedTestResultException("XRLMsnSubmitRating failed: " + request.GetDumpString());
                    }
                    if (request.XErr != HResult.S_OK)
                    {
                        throw new UnexpectedTestResultException(String.Format("XRLMsnSubmitRating returned XErr=0x{0:x}", request.XErr));
                    }
                }
            }

            [TestCase, Owner("jeremyj"), TestFrequency("BVT"), EnvRequirement("Billing,Catalog"), TestCasePriority(1), LiveLKG]
            public class GetRatingBVT : TestNode
            {
                public override void Run()
                {
                    if (ratingUser == null || ratingUser.UserPuid == 0)
                    {
                        ratingUser = new STFUserAccount.XeUser(true, STFUserAccount.XeUser.Country.US);
                        if (ratingUser.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + ratingUser.GetDumpString());
                        SleepUntilXCacheIsUpdated();
                    }

                    XRLMsnGetRating request = new XRLMsnGetRating();
                    request.Request.userXuid = ratingUser.UserPuid;
                    request.Request.mediaId = new Guid(GameMediaId);
                    request.Request.userCountryId = 103;
                    request.Slot.AddService(STFLive.XOService.Ratings);

                    //
                    // Make the Service Call
                    //
                    if (!request.Execute())
                    {
                        throw new UnexpectedTestResultException("XRLMsnGetRating failed: " + request.GetDumpString());
                    }
                    if (request.XErr != HResult.S_OK)
                    {
                        throw new UnexpectedTestResultException(String.Format("XRLMsnGetRating returned XErr=0x{0:x}", request.XErr));
                    }

                    Global.RO.Info("RatingCount: " + request.Response.ratingsCount + ", RatingAverage: " + request.Response.ratingsAverage);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  InGame Marketplace BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class InGameMarketplaceGroup : TestNode
        {
            public const ulong gameOfferId = 0x584107F600000001;    // BVT title 0x584107F6, Texas Holdem
            public const uint gameTitleId = 0x584107F6; // BVT title 0x584107F6, Texas Holdem
            public static STFUserAccount.XeUser user = null;

            [TestCase, Owner("wirosas"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing,Catalog"), LiveLKG]
            public class InGameContentAvailable : TestNode
            {
                public override void Run()
                {
                    int retries = 3;
                    while (retries > 0)
                    {
                        try
                        {
                            // create a silver user
                            if (user == null || user.UserPuid == 0)
                            {
                                user = new STFUserAccount.XeUser(true, STFUserAccount.XeUser.Country.US);
                                if (user.Create() == 0)
                                    throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
                            }

                            STFBilling.XRLInGameContentAvailable request = new STFBilling.XRLInGameContentAvailable();
                            STFBilling.XRLInGameContentAvailableResponse response = new STFBilling.XRLInGameContentAvailableResponse();

                            request.TitleID = gameTitleId;
                            request.UserPuid = user.UserPuid;

                            if (!request.Execute(out response))
                                throw new UnexpectedTestResultException("XRLInGameContentAvailable failed: " + request.GetDumpString());
                            if (request.XErr != HResult.S_OK)
                                throw new UnexpectedTestResultException(String.Format("XRLInGameContentAvailable returned XErr=0x{0:x}", request.XErr));

                            Global.RO.Info("TotalOffers count: " + response.TotalOffers.Length + ", NewOffers count: " + response.NewOffers.Length);
                            break;

                        }
                        catch (System.IO.IOException ioe)
                        {
                            --retries;
                            Global.RO.Warn(ioe.Message);
                            Global.RO.Warn("Failure due to connection, retrying...");
                            Thread.Sleep(30000); //sleep 30 seconds
                        }
                    }

                    if (retries <= 0) //ran out of retries and the error threw again
                        throw new UnexpectedTestResultException("Ran out of retries.");
                    else //still have retries remaining and got here?  Pass!
                        return;
                }
            }

            [TestCase, Owner("wirosas"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing,Catalog"), LiveLKG]
            public class InGameContentEnumerate : TestNode
            {
                public override void Run()
                {
                    int retries = 3;
                    while (retries > 0)
                    {
                        try
                        {
                            // create a silver user
                            if (user == null || user.UserPuid == 0)
                            {
                                user = new STFUserAccount.XeUser(true, STFUserAccount.XeUser.Country.US);
                                if (user.Create() == 0) 
                                    throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
                            }

                            STFBilling.XRLInGameContentEnumerate request = new STFBilling.XRLInGameContentEnumerate();
                            STFBilling.XRLInGameContentEnumerateResponse response = new STFBilling.XRLInGameContentEnumerateResponse();

                            request.SchemaVersion = ServerTestFramework.WireData.MakeSchemaVersion(5, 2);
                            request.UserPuid = user.UserPuid;
                            request.EmsGameRating = 0x3fff;
                            request.TierRequired = 3;
                            request.TitleID = 0;

                            if (!request.Execute(out response))
                                throw new UnexpectedTestResultException("XRLInGameContentEnumerate failed: " + request.GetDumpString());
                            if (request.XErr != HResult.S_OK)
                                throw new UnexpectedTestResultException(String.Format("XRLInGameContentEnumerate returned XErr=0x{0:x}", request.XErr));

                            PrintResponse(response, request.SchemaVersion);
                            break;

                        }
                        catch (System.IO.IOException ioe)
                        {
                            --retries;
                            Global.RO.Warn(ioe.Message);
                            Global.RO.Warn("Failure due to connection, retrying...");
                            Thread.Sleep(30000); //sleep 30 seconds
                        }
                    }

                    if (retries <= 0) //ran out of retries and the error threw again
                        throw new UnexpectedTestResultException("Ran out of retries.");
                    else //still have retries remaining and got here?  Pass!
                        return;
                }

                public static void PrintResponse(STFBilling.XRLInGameContentEnumerateResponse response, uint version)
                {
                    Global.RO.Info("{0} total content records", response.OffersTotal);
                    Global.RO.Info("{0} content records returned", response.OffersReturned);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Catalog Query BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class CatalogQueryGroup : TestNode
        {
            static string GameMediaId = "66ACD000-77FE-1000-9115-D802584107F6";  // BVT title 0x584107F6, Texas Holdem
            static live.client.ZuneClient WebClient = new live.client.ZuneClient();
            public static void ExecuteQuery(string query)
            {
                live.protocol.next.GenericQueryRequest req = new live.protocol.next.GenericQueryRequest(query);
                live.protocol.next.CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, req);
                Global.RO.Info("Response is: \n" + resp.Response);
            }

            [TestCase, Owner("wirosas"), TestFrequency("BVT"), EnvRequirement("Catalog"), TestCasePriority(1), LiveLKG]
            public class FindCategories : TestNode
            {
                public override void Run()
                {
                    string CustomQuery = "methodName=FindCategories&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=1&Names=PageSize&Values=5&Names=PageNum&Values=1&Names=DetailView&Values=3&Names=OfferFilterLevel&Values=1&Names=CategorySystemId&Values=4000&Names=OrderBy&Values=11&Names=OrderDirection&Values=1";
                    ExecuteQuery(CustomQuery);
                }
            }

            [TestCase, Owner("wirosas"), TestFrequency("BVT"), EnvRequirement("Catalog"), TestCasePriority(1), LiveLKG]
            public class FindContributors : TestNode
            {
                public override void Run()
                {
                    string movieMediaId = "00030003-0002-0001-0113-20071004b001";
                    string CustomQuery = "methodName=FindContributors&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=1&Names=PageSize&Values=5&Names=PageNum&Values=1&Names=DetailView&Values=2&Names=MediaIds&Values=" + movieMediaId + "&Names=ContributorLimit&Values=4&Names=OrderBy&Values=13&Names=OrderDirection&Values=1";
                    ExecuteQuery(CustomQuery);
                }
            }

            [TestCase, Owner("wirosas"), TestFrequency("BVT"), EnvRequirement("Catalog"), TestCasePriority(1), LiveLKG]
            public class FindGames : TestNode
            {
                public override void Run()
                {
                    string CustomQuery = "methodName=FindGames&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=1&Names=PageSize&Values=5&Names=PageNum&Values=1&Names=DetailView&Values=5&Names=OfferFilterLevel&Values=1&Names=MediaIds&Values=" + GameMediaId + "&Names=UserTypes&Values=2&Names=MediaTypes&Values=1&Names=MediaTypes&Values=21&Names=MediaTypes&Values=23&Names=MediaTypes&Values=37&Names=MediaTypes&Values=46&Names=ImageFormats&Values=4&Names=ImageFormats&Values=5&Names=ImageSizes&Values=13&Names=ImageSizes&Values=22&Names=ImageSizes&Values=23";
                    ExecuteQuery(CustomQuery);
                }
            }

            [TestCase, Owner("wirosas"), TestFrequency("BVT"), EnvRequirement("Catalog"), TestCasePriority(1), LiveLKG]
            public class FindGameOffers : TestNode
            {
                public override void Run()
                {
                    string CustomQuery = "methodName=FindGameOffers&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=1&Names=PageSize&Values=5&Names=PageNum&Values=1&Names=DetailView&Values=5&Names=MediaIds&Values=" + GameMediaId + "&Names=UserTypes&Values=2&Names=MediaTypes&Values=1&Names=MediaTypes&Values=5&Names=MediaTypes&Values=18&Names=MediaTypes&Values=19&Names=MediaTypes&Values=20&Names=MediaTypes&Values=21&Names=MediaTypes&Values=22&Names=MediaTypes&Values=23&Names=MediaTypes&Values=30&Names=MediaTypes&Values=34&Names=MediaTypes&Values=37&Names=ImageFormats&Values=4&Names=ImageFormats&Values=5&Names=ImageSizes&Values=15&Names=Relations&Values=2&Names=OrderBy&Values=5&Names=OrderDirection&Values=2";
                    ExecuteQuery(CustomQuery);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        //
        //  Games Blade BVTs
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup]
        public class GamesBlade : TestNode
        {
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static MarketplaceScene marketplace = null;

            public override void PreRun()
            {
                Common.CreateBVTUser(XblUserTier.Gold, PassportType.Real, ref xbox360, out user, true);
                LfmState lfmState = new LfmState();
                lfmState.ActiveUser = user;
                lfmState.Client = xbox360.Client;
                marketplace = new MarketplaceScene(lfmState);

                // Add points to this user
                PaymentOptionsScene paymentOptions = marketplace.AccountMgmt.ViewPaymentOptionsScene;
                CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                paymentOptions.AddPaymentInstrument(ccinfo);
                marketplace.PurchasePoints(Offers.PointsOffers.CC5000US).Confirm();
            }

            [TestCase, Owner("pefan"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Billing, Catalog"), LiveLKG]
            public class GamePurchase : TestNode
            {
                public override void Run()
                {   //find game offer
                    //
                    GamesInternal gameStore;
                    gameStore = marketplace.Games;
                    Guid GameMediaId = new Guid("66ACD000-77FE-1000-9115-D802584107F6");

                    if (gameStore.SelectPaidOffer(GameMediaId))
                        gameStore.PurchaseGame();
                    else
                    {
                        Global.RO.Info("Cannot Find Game: Texas Hold 'em, Full Version");
                        Global.RO.Info("MediaId: 66ACD000-77FE-1000-9115-D802584107F6");
                        Global.RO.Info("OfferId: 00000001-0000-4000-8000-0000584107F6");
                        Global.RO.Info("For debugging, try executing this stored proc against FECatalogDBXbox.  You should get the full game of Texas Hold 'em back.");
                        Global.RO.Info("exec FindGameOffers @locale=N'en-US',@legalLocale=N'en-US',@store=1,@detailView=5,@offerIds=NULL,@mediaIds=N'<a b=\"66acd000-77fe-1000-9115-d802584107f6\" />',@ratingIds=NULL,@userTypes=N'<a b=\"2\" />',@mediaTypes=N'<a b=\"1\" /><a b=\"5\" /><a b=\"18\" /><a b=\"19\" /><a b=\"20\" /><a b=\"21\" /><a b=\"22\" /><a b=\"23\" /><a b=\"30\" /><a b=\"34\" /><a b=\"37\" />',@categoryIds=NULL,@imageTypeIds=NULL,@imageFormats=N'<a b=\"4\" /><a b=\"5\" />',@imageSizes=N'<a b=\"15\" />',@titleFilters=NULL,@relations=N'<a b=\"2\" />',@orderBy=5,@orderDirection=2,@queryModifiers=0,@visibilityLevel=2,@editorialPrivilege=1,@avatarBodyTypes=NULL,@pageSize=300,@pageNum=1,@exemptMediaTypes=N'<a b=\"20\"/><a b=\"22\"/><a b=\"47\"/>',@exemptGCForTitles=N'<a b=\"1161889833\"/><a b=\"1161889897\"/><a b=\"1161922701\"/><a b=\"1263405024\"/><a b=\"1263405046\"/><a b=\"1096157159\"/><a b=\"1096157175\"/><a b=\"1096157232\"/><a b=\"1096157210\"/><a b=\"1096157209\"/><a b=\"1263405043\"/><a b=\"1263405026\"/><a b=\"1263405020\"/><a b=\"1263405031\"/><a b=\"1263405039\"/><a b=\"1112934367\"/><a b=\"1112934368\"/><a b=\"1112934374\"/><a b=\"1297287304\"/>',@nonExemptRatingSystems=NULL,@nonExemptMediaIds=NULL");
                        throw new UnexpectedTestResultException("Cannot find game.");
                    }
                }
            }
        }




        ///////////////////////////////////////////////////////////////////////
        //
        //  Mix Tests
        //
        ///////////////////////////////////////////////////////////////////////

        [TestGroup, Ignore]
        public class MixProductManagment : TestNode
        {
            protected static Game gameSetup;

            public override void PreRun()
            {
                gameSetup = (Game)Template.CreateGameTemplateV1();
                ConfigureProduct((Product)gameSetup);
            }

            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateGame : TestNode
            {
                Game game;
                public override void Run()
                {
                    #region payload
                    game = (Game)Template.CreateGameTemplateV1();
                    #endregion

                    #region Execution
                    ConfigureProduct(game);
                    DoVerification(game);
                    #endregion

                }
            }

            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateAvatarItem : TestNode
            {
                AvatarItem avatarItem;
                public override void Run()
                {

                    #region payload
                    avatarItem = (AvatarItem)Template.CreateAvatarItemTemplateV1();
                    avatarItem.Packages[0].PackageId = gameSetup.Executables[0].PackageId;
                    avatarItem.Packages[0].ContentId = gameSetup.Executables[0].ContentId;
                    avatarItem.AssetId = gameSetup.VideoPreviews[0].PackageId;
                    avatarItem.GameRelationships[0].GameId = gameSetup.ProductId;
                    #endregion


                    #region Execution

                    ConfigureProduct((Product)avatarItem);
                    DoVerification(avatarItem);

                    #endregion
                }
            }




            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateGameConsumable : TestNode
            {
                GameConsumable gameConsumable;
                public override void Run()
                {

                    #region payload
                    gameConsumable = (GameConsumable)Template.CreateGameConsumableTemplateV1();

                    gameConsumable.Packages[0].PackageId = gameSetup.Executables[0].PackageId;
                    gameConsumable.Packages[0].ContentId = gameSetup.Executables[0].ContentId;
                    gameConsumable.GameRelationships[0].GameId = gameSetup.ProductId;

                    #endregion


                    #region Execution

                    ConfigureProduct((Product)gameConsumable);
                    DoVerification(gameConsumable);

                    #endregion
                }
            }





            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateGameContent : TestNode
            {
                GameContent gameContent;
                public override void Run()
                {

                    #region payload
                    gameContent = (GameContent)Template.CreateGameContentTemplateV1();

                    gameContent.Packages[0].PackageId = gameSetup.Executables[0].PackageId;
                    gameContent.Packages[0].ContentId = gameSetup.Executables[0].ContentId;
                    gameContent.GameRelationships[0].GameId = gameSetup.ProductId;

                    #endregion


                    #region Execution

                    ConfigureProduct((Product)gameContent);
                    DoVerification(gameContent);

                    #endregion
                }
            }



            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateImage : TestNode
            {
                Image image;
                public override void Run()
                {

                    #region Payload

                    image = (Image)Template.CreateImageTemplateV1();
                    image.ProductRelationships[0].ProductId = gameSetup.ProductId;

                    #endregion


                    #region Execution

                    ConfigureProduct((Product)image);
                    DoVerification(image);

                    #endregion
                }
            }

            public static void DoVerification(Product expected)
            {
                Global.RO.Warn("Expected media:");
                XmlDocument expectedXml = DataContractSerialize.ObjectToXml(expected);
                Global.RO.Info(MediaOperationsHelper.FormatXml(expectedXml.DocumentElement));

                Exception e = null;
                var mediaFromDb = Catalog.GetProduct(out e, expected.ProductId, null);

                if (e != null)
                {
                    throw new UnexpectedTestResultException("GetObject error " + e.Message);
                }
                if (mediaFromDb == null)
                {
                    throw new UnexpectedTestResultException("GetObject returned NULL for " + expected.ProductId);
                }

                Global.RO.Info("Verify Media: " + expected.ProductId);

                Global.RO.Warn("Media returned from the server: ");
                XmlDocument actualXml = DataContractSerialize.ObjectToXml(mediaFromDb);
                Global.RO.Success(MediaOperationsHelper.FormatXml(actualXml.DocumentElement));


                if (!Catalog.Compare(mediaFromDb,(MediaBase)expected))
                {
                    throw new UnexpectedTestResultException("CompareMedia failed");
                }
            }

            public static void ConfigureProduct(Product product)
            {
                Exception x = null;

                ProductManagementWCFClient client = new ProductManagementWCFClient();
                Global.RO.Warn("Configuring product:");
                XmlDocument expectedXml = DataContractSerialize.ObjectToXml(product);
                Global.RO.Info(MediaOperationsHelper.FormatXml(expectedXml.DocumentElement));
                client.ConfigureProduct(product, out x);
                if (x != null)
                {
                    Global.RO.Error("error in ConfigureProduct: " + x.Message);
                    throw new UnexpectedTestResultException ("Failed to configure product",x);
                }
            }

        }


        [TestGroup, Ignore]
        public class MixOfferManagment : TestNode
        {
            protected static XblUser user = null;
            protected static Xbox360 xbox360 = null;
            protected static MarketplaceScene marketplace = null;
            protected static Game gameSetup;
            protected static Catalog catalog;

            public override void PreRun()
            {
                gameSetup = (Game)Template.CreateGameTemplateV1();
                gameSetup.GameAttributes[0].Country = "US";
                MixProductManagment.ConfigureProduct((Product)gameSetup);
            }


            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateOffer : TestNode
            {

                xonline.mix.offermanagement.contracts.V1.Offer offer;

                public override void Run()
                {

                    #region payload
                    offer = Template.CreateOfferTemplateV1();
                    Random random = new Random(offer.OfferId.GetHashCode());
                    offer.LiveOfferId = (long)(random.NextDouble() * 1154240922855342083);
                    offer.ProductId = gameSetup.ProductId;
                    offer.Instances[0].OfferProducts[0].ProductId = gameSetup.ProductId;
                    offer.Instances[0].Packages[0].PackageId = gameSetup.Executables[0].PackageId;
                    offer.OfferRelationShips = null;

                    #endregion

                    #region Execution
                    ConfigureOffer(offer);
                    DoVerification(offer);
                    #endregion

                }
            }


            [TestCase, Owner("achang"), TestCasePriority(1), TestFrequency("BVT"), EnvRequirement("Catalog"), LiveLKG]
            public class CreateConsumableOffer : TestNode
            {
                GameConsumable gameConsumableSetup;
                xonline.mix.offermanagement.contracts.V1.Offer offer;

                public override void PreRun()
                {
                    gameConsumableSetup = (GameConsumable)Template.CreateGameConsumableTemplateV1();
                    gameConsumableSetup.Packages[0].PackageId = gameSetup.Executables[0].PackageId;
                    gameConsumableSetup.Packages[0].ContentId = gameSetup.Executables[0].ContentId;
                    gameConsumableSetup.GameRelationships[0].GameId = gameSetup.ProductId;
                    MixProductManagment.ConfigureProduct((Product)gameConsumableSetup);


                }
                public override void Run()
                {

                    #region Payload

                    offer = Template.CreateOfferTemplateV1();
                    offer.ProductId = gameConsumableSetup.ProductId;
                    Random random = new Random(offer.OfferId.GetHashCode());
                    offer.LiveOfferId = (long)(random.NextDouble() * 1154240922855342083);
                    offer.Instances[0].Packages[0].Quantity = 10;
                    offer.Instances[0].OfferProducts[0].ProductId = gameConsumableSetup.ProductId;
                    offer.Instances[0].Packages[0].PackageId = gameConsumableSetup.Packages[0].PackageId;
                    offer.OfferRelationShips = null;

                    #endregion


                    #region Execution

                    ConfigureOffer(offer);
                    DoVerification(offer);

                    #endregion
                }
            }



            public static void DoVerification(xonline.mix.offermanagement.contracts.V1.Offer expected)
            {
                Exception e = null;
                var offerFromDb = Catalog.GetOffer(out e, expected.OfferId, null);

                if (e != null)
                {
                    throw new UnexpectedTestResultException("GetObject error " + e.Message);
                }

                if (offerFromDb == null)
                {
                    throw new UnexpectedTestResultException("GetObject returned NULL for " + expected.OfferId);
                }


                Global.RO.Warn("Expected offer:");
                OfferXMLTestBase.FixNullArrays(expected);
                XmlDocument expectedXml = DataContractSerialize.ObjectToXml(expected);
                Global.RO.Info(MediaOperationsHelper.FormatXml(expectedXml.DocumentElement));


                Global.RO.Warn("Returned offer from server:");
                OfferXMLTestBase.FixNullArrays(offerFromDb);
                XmlDocument actualXml = DataContractSerialize.ObjectToXml(offerFromDb);
                Global.RO.Success(MediaOperationsHelper.FormatXml(actualXml.DocumentElement));

                Global.RO.Info("Verify Offer: " + expected.OfferId);

                if (!Catalog.Compare(offerFromDb, expected))
                {
                    throw new UnexpectedTestResultException("CompareOffer failed");
                }
            }

            public static void ConfigureOffer(xonline.mix.offermanagement.contracts.V1.Offer offer)
            {
                Exception x = null;

                OfferManagementWCFClient client = new OfferManagementWCFClient();
                Global.RO.Warn("Configuring offer:");
                XmlDocument expectedXml = DataContractSerialize.ObjectToXml(offer);
                Global.RO.Info(MediaOperationsHelper.FormatXml(expectedXml.DocumentElement));


                client.ConfigureOffer(offer, out x);
                if (x != null)
                {
                    Global.RO.Error("error in ConfigureOffer: " + x.Message);
                    throw new UnexpectedTestResultException("Failed to configure offer", x);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\ContentTestData.cs ===
using System.IO;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

using System;

namespace LiveContentTest
{
	/// <summary>
	/// A class to describe sets of arguments passed into LiveContent.
	/// </summary>
	public class ContentTestData 
	{
		//passed in variables, and any needed property accessors.
		private uint titleId;
		private string packageName;
		private ulong offerId;
		private string offerFile;
		private ulong offerId2;
		private string offerFile2;

		//if this flag is set to true, instead of offerFile and offerFile2 being used,
		//they will be copied from the appropriate default offer file
		//private bool isDefaultOffer;
		public uint TitleId {get { return titleId; } }
		public string PackageName {get { return packageName; } }
		public ulong OfferId {get { return offerId; } }
		public string OfferFile {get { return offerFile; } }
		public ulong OfferId2 {get { return offerId2; } }
		public string OfferFile2 {get { return offerFile2; } }


		//parsed variables of the OfferFile.
		private string contentId;
		private string contentId2;  //optional, if a second offer file is present.

		//When any of these is requested, the OfferFile is parsed, and these variables
		//retrieved from it.
		public string ContentId
		{
			get 
			{
				if (contentId == null) { ParseOfferFile(); }
				return contentId;  
			}
		}
		public string ContentId2
		{
			get 
			{
				if ((contentId2 == null) && HasSecondOfferFile()) { ParseOfferFile(); }
				return contentId2;  
			}
		}

		public ContentTestData(string inputFilePath, uint titleId, string packageName)
		{
			this.titleId=titleId;
			this.packageName=Path.Combine(inputFilePath, packageName);
		}

		public ContentTestData(string inputFilePath, uint titleId, string packageName, 
			ulong offerId, string offerFile) : this(inputFilePath, titleId, packageName)
		{
			this.offerId=offerId;
			this.offerFile=Path.Combine(inputFilePath, offerFile);
		}

		public ContentTestData(string inputFilePath, uint titleId, 
			string packageName, ulong offerId,
			string offerFile, ulong offerId2, 
			string offerFile2) : this(inputFilePath, titleId, packageName, offerId, offerFile)
		{
			this.offerId2=offerId2;
			this.offerFile2=Path.Combine(inputFilePath, offerFile2);
		}

		public void ApplyToLiveContentHandle(LiveContent lcHandle) 
		{
			lcHandle.SetPackageFile(packageName, titleId);
			if ((offerId != 0) && (offerFile != null))
			{
				lcHandle.SetOfferFile(offerFile, offerId);
			}
			if ((offerId2 != 0) && (offerFile2 != null))
			{
				lcHandle.SetOfferFile2(offerFile2, offerId2);
			}
		}

		/// <summary>
		/// Parses the offer file and gathers variables of interest.  Is called 
		/// the first time any of the required variables is processed, as well as whenever
		/// the outside world believes it necessary to refresh this info.
                ///
                /// This is set to work only for 360 offers.
                /// TODO:Work Xbox1 offers into this.
		/// </summary>
		public void ParseOfferFile() 
		{
			//Parse the offer file for desired variables.
                        XmlOfferFile parsedOffer = new XmlOfferFile(offerFile, XmlOfferFile.platform.xbox360);
			contentId = parsedOffer.getContentId();
			if (offerFile2 != null) 
			{
                                XmlOfferFile parsedOffer2 = new XmlOfferFile(offerFile2, XmlOfferFile.platform.xbox360);
				contentId2 = parsedOffer2.getContentId();
			}
		}

		/// <summary>
		/// Allows outside to know if an offer file was given.
		/// </summary>
		public bool HasOfferFile() 
		{
			return (!(offerFile == null));
		}

		/// <summary>
		/// Allows outside to check if its offer file actually exists.
		/// </summary>
		public bool OfferFileIsPresent() 
		{
			return File.Exists(offerFile);
		}

		/// <summary>
		/// Allows outside to know if a second offer file was given.
		/// </summary>
		public bool HasSecondOfferFile() 
		{
			return (!(offerFile2 == null));
		}

		/// <summary>
		/// Allows outside to check if second offer file actually exists.
		/// </summary>
		public bool SecondOfferFileIsPresent() {
			return File.Exists(offerFile);
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\LiveContentTest.cs ===
using System;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.Utilities;
using System.Threading;

namespace LiveContentTest
{

    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")] 
    public class EndToEndLiveContentAndLiveOffer: TestNode 
    {
        static string [] testChoices = {"BVT_InGame", "BVT_Theme", "BVT_GamerPics", 
                                        "BVT_Trailer_HI_AND_LO", "BVT_Demo", "BVT_Arcade", 
                                        "BVT_Trailer_HI", "BVT_Trailer_LO", "BVT_Video_HI_AND_LO",
                                        "BVT_Video_HI", "BVT_Video_LO"};
        
        [TestCase, DVT]
        //Toasts all BVT stuff.  This includes cab files propped to titlevault/contentdownload,
        //as well as the related offer from the service.  Offer files copied to titlevault are
        //not removed, however.  This is not a test, per se, and no error checking occurs here.
        class CleanAllBVTs : ContentTestBase {
            override protected void Execute() {
                foreach (string testName in testChoices) 
                {
                    CleanData(testName, 1);
                    CleanOffer(testName);
                }
                SetResultCode(true);
            }
        }

        [TestCase, DVT]
        class BVT_InGame : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[0]));
            }
        }

        [TestCase, DVT]
        class BVT_Theme : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[1]));
            }
        }
        [TestCase, DVT]
        class BVT_GamerPics : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[2]));
            }
        }
        [TestCase]
        class BVT_Trailer_HI_AND_LO : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[3]));
            }
        }
        [TestCase]
        class BVT_Demo : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[4]));
            }
        }
        [TestCase]
        class BVT_Arcade : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[5]));
            }
        }
        [TestCase]
        class BVT_Trailer_HI : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[6]));
            }
        }
        [TestCase]
        class BVT_Trailer_LO : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[7]));
            }
        }
        [TestCase]
        class BVT_Video_HI_AND_LO : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[8]));
            }
        }
        [TestCase]
        class BVT_Video_HI : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[9]));
            }
        }
        [TestCase]
        public class BVT_Video_LO : ContentTestBase {
            override protected void Execute() {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                SetResultCode(TestLCAndLiveOfferNoFlags(testChoices[10]));
            }
        }

        [TestCase]
        public class Concurrency : ContentTestBase
        {
            private ManualResetEvent[] doneEvents;
            private int _threads = 3;
            private int _currentTest = 0;
            bool _pass = true;
            private static Mutex _mut = new Mutex();

            protected override void  Execute()
            {
                // Clear out everything... 
                foreach (string testName in testChoices)
                {
                    CleanData(testName, 1);
                    CleanOffer(testName);
                }
                // Set up thread events...
                doneEvents = new ManualResetEvent[3];
                for (int i = 0; i < _threads; i++)  // Set up doneEvents for our threads.  There is a 64 thread limit currently on WaitHandle.
                {
                    doneEvents[i] = new ManualResetEvent(false);
                }
                for (int i = 0; i < _threads; i++)
                {
                    Thread t = new Thread(new ParameterizedThreadStart(DoQueue));
                    t.Start(i);
                }

                WaitHandle.WaitAll(doneEvents);  // Wait for all threads to finish...

                ResultCode = TEST_RESULTS.PASSED;
            }

            private void DoQueue(object ThreadID)
            {
                bool done = false;
                int iThread = (int)ThreadID;
                string current;

                Global.RO.Info(String.Format("Thread {0} started...", iThread));
                while (!done)
                {
                    _mut.WaitOne();
                    current = GetNextQueue();
                    _mut.ReleaseMutex();
                    if (current != "")
                    {
                        _pass = _pass && TestLCAndLiveOfferNoFlags(current);
                    }
                    else
                    {
                        done = true;
                    }

                }
                Global.RO.Info(String.Format("Thread {0} finished.", iThread));
                doneEvents[iThread].Set();
            }

            private string GetNextQueue()
            {
                if (_currentTest < testChoices.Length)
                {
                    return testChoices[_currentTest++];
                }
                else return "";
            }
        }
			
    }
/*
  [TestGroup]
  /// <summary>
  /// This class allows easy basic manipulations of title updates for testing purposes.
  /// The title affected, FFFE07EA, is built as a re-titled version of testupd.xex
  /// </summary>
  public class EndToEndTitleUpdate : TestNode {

  }
*/
    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")]
    public class PositiveTestCases : TestNode {
        /// <summary>
        /// Basic test--All kinds of 360 content.
        /// </summary>
        [TestCase]
        class Xbox360ContentBVTs : ContentTestBase {
            override protected void Execute() {
                bool success = true;
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                int site = 1; //for this test, use only one site, ID 1

                string [] testChoices = {"BVT_InGame", "BVT_Theme", "BVT_GamerPics", 
                                         "BVT_Trailer_HI_AND_LO", "BVT_Demo", "BVT_Arcade", 
                                         "BVT_Trailer_HI", "BVT_Trailer_LO", "BVT_Video_HI_AND_LO",
                                         "BVT_Video_HI", "BVT_Video_LO"};
                try {
                    foreach (string testName in testChoices) {
                        Console.WriteLine("Cleaning old content download share and titlevault files for " + testName + "...");
                        CleanData(testName, site);
                    }
					
					
                    foreach (string testName in testChoices) {
                        success = success && ExpectPass(testName, site);
                    }
                } 
                catch (LiveContentException e) {
                    Console.Error.WriteLine(e.ProcessOutput);
                    success = false;
                }

                SetResultCode(success);
            }
        }

        [TestCase]
        class Xbox360TitleAU : UpdateTestBase {
            override protected void Execute() {
                bool success = VerifyAllPositiveMatrixTests();
                SetResultCode(success);
            }
        }

        //These cabs are NOT SOLID yet.
        static string [] NovXDK_cabs = {"2417.4_InGame", "2417.4_Theme", "2417.4_GamerPics",
                                        "2417.4_Trailer", "2417.4_Demo", "2417.4_Arcade"};
        [TestCase]
        class All_NovXDKCabs : ContentTestBase {
            override protected void Execute() {
                bool success = true;
                foreach (string testName in NovXDK_cabs) {
                    success = success && TestLCAndLiveOfferNoFlags(testName);
                }
                SetResultCode(success);
            }
        }

	
    }


    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")]
    public class UseDefaultOfferFlagTest : TestNode {
		
        [TestCase]
        class Xbox360InGameContentDefaultOffer : ContentTestBase
        {
            override protected void Execute()
            {
                TestUseDefaultOfferFlag("POS_InGame_DefaultOffer");
            }
        }

        [TestCase]
        class Xbox360ThemeContentDefaultOffer : ContentTestBase
        {
            override protected void Execute() {
                TestUseDefaultOfferFlag("POS_Theme_DefaultOffer");
            }
        }

        [TestCase]
        class Xbox360GamerPicsContentDefaultOffer : ContentTestBase
        {
            override protected void Execute()
            {
                TestUseDefaultOfferFlag("POS_GamerPics_DefaultOffer");
            }
        }

/*
// Trailers and Videos are not supported for the /usedefaultoffer flag
// (they require two offer files, and the naming convention for that was not settled.)
[TestCase]
class Xbox360TrailerBothContentDefaultOffer : ContentTestBase
{
override protected void Execute()
{
TestUseDefaultOfferFlag("POS_Trailer_Both_DefaultOffer");
}
}

[TestCase]
class Xbox360TrailerLoOnlyContentDefaultOffer : ContentTestBase
{
override protected void Execute()
{
TestUseDefaultOfferFlag("POS_Trailer_LoOnly_DefaultOffer");
}
}

[TestCase]
class Xbox360TrailerHiOnlyContentDefaultOffer : ContentTestBase
{
override protected void Execute()
{
TestUseDefaultOfferFlag("POS_Trailer_HiOnly_DefaultOffer");
}
}

[TestCase]
class Xbox360VideoContentDefaultOffer : ContentTestBase {
override protected void Execute() {
TestUseDefaultOfferFlag("POS_Video_DefaultOffer");
}
}
*/


        [TestCase]
        class Xbox360DemoContentDefaultOffer : ContentTestBase
        {
            override protected void Execute()
            {
                TestUseDefaultOfferFlag("POS_Demo_DefaultOffer");
            }
        }
        
        [TestCase]
        class Xbox360ArcadeContentDefaultOffer : ContentTestBase
        {
            override protected void Execute()
            {
                TestUseDefaultOfferFlag("POS_Arcade_DefaultOffer");
            }
        }

        /// <summary>
        /// Basic test.  A content offer that is both paid and free.
        /// Uses the /usedefaultoffer flag
        /// </summary>
        [TestCase]
        class Xbox1ContentUseDefault : ContentTestBase 
        {
            override protected void Execute() 
            {
                //livecontent /action:xbox1content /package:c:\temp\LiveContentXbox1Test.xcp /titleid:FFFE07EB /site:1 /overwrite /usedefaultoffer
                string testPackage = "LiveContentXbox1Test.xcp";
                LiveContent lc = new LiveContent(_liveContentPath);
                SetupTempDir(new string[] {Path.Combine(_inputFilePath, testPackage)});
                lc.SetPackageFile(Path.Combine(_tempFilePath, testPackage), 0xFFFE07EB);
                lc.UseDefaultOffer = true;
                lc.DeployXbox1Content();
                SetResultCode(true);
                CleanupTempDir();
            }
        }

        /// <summary>
        /// Basic test.  A content offer that is both paid and free.
        /// </summary>
        [TestCase]
        class Xbox1ContentIsDefault : ContentTestBase
        {
            override protected void Execute()
            {
                //livecontent /action:xbox1content /package:c:\temp\LiveContentXbox1Test.xcp /titleid:FFFE07EB /site:1 /overwrite /offerfile:Xbox1_FreeDefaultContent.offer /offerid:FFFE07EB00000013 /isdefaultoffer:yes /startdate:7/12/2006 /enddate:7/12/2026
                string testPackage = "LiveContentXbox1Test.xcp";
                string offerFile = "Xbox1_FreeDefaultContent.offer";
                LiveContent lc = new LiveContent(_liveContentPath);
                SetupTempDir(new string[] { Path.Combine(_inputFilePath, testPackage), Path.Combine(Path.Combine(TitleVaultHandle.GetDefaultFolder(),"ZDefault\\"),offerFile) });
                lc.SetPackageFile(Path.Combine(_tempFilePath, testPackage), 0xFFFE07EB);
                lc.SetOfferFile(Path.Combine(_tempFilePath, offerFile), 0xFFFE07EB00000013);
                lc.IsDefaultOffer = true;
                lc.DeployXbox1Content();
                SetResultCode(true);
                CleanupTempDir();
            }
        }

        [TestCase]
        class Xbox1ContentDefault : ContentTestBase
        {
            override protected void Execute()
            {
                string titleID = "FFFE07EB";
                Global.RO.Info(TitleVaultHandle.GetDefaultFolder());
                string strPackageFolder = Path.Combine(_inputFilePath, "ZDefaultPackages");
                LiveContent lc = new LiveContent(_liveContentPath);
                SetupTempDir(Directory.GetFiles(strPackageFolder));
                lc.RunWithOnlyStringArguments(String.Format("/action:xbox1content /adddefault /package:{0} /titleid:{1} /site:1 /overwrite", _tempFilePath, titleID));
                SetResultCode(true);
                CleanupTempDir();
            }
        }
        [TestCase]
        class Xbox1AUDefault : ContentTestBase
        {
            override protected void Execute()
            {
                string titleID = "FFFE07EB";
                // Using the default directory.  Might need to move to use the temp directory later... will have to copy over the new folder to temp.
                string strPackageFolder = Path.Combine(_inputFilePath, "ZDefaultUpdate");
                LiveContent lc = new LiveContent(_liveContentPath);
                //SetupTempDir(Directory.GetFiles(strPackageFolder));
                lc.RunWithOnlyStringArguments(String.Format("/action:xbox1update /adddefault /package:{0} /titleid:{1} /site:1 /overwrite", strPackageFolder, titleID));
                SetResultCode(true);
                //CleanupTempDir();
            }
        }
        //test with an offer file.  See if it modifies certain properties 
        //in the offer file, such as start/end date, contentID
    }


    //individual props.  These allow ease of end-to-end testing by automatically sending up
    //or clearing a given title update.  Note that absolutely no verification occurs.  These
    //are not tests, but merely convenient ways of sending up the updates.
    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")]
    public class Manual360AUTest : TestNode {
        [TestCase]
        class ManualCleanTitleVersions : UpdateTestBase {
            override protected void Execute() {
                ResetDBUpdates(0xFFFE07EA, 1);
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }

        [TestCase]
        class ManualProp_1_101 : UpdateTestBase {
            override protected void Execute() {
                Prop360Update("Test1_101");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
        [TestCase]
        class ManualProp_1_201 : UpdateTestBase {
            override protected void Execute() {
                Prop360Update("Test1_201");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
        [TestCase]
        class ManualProp_1_301 : UpdateTestBase {
            override protected void Execute() {
                Prop360Update("Test1_301");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }

    }

    //individual props.  Same as above, but for the Halo 2 updates.
    [TestGroup]
    public class ManualXbox1AUTest : TestNode {
        [TestCase]
        class ManualCleanTitleVersions : UpdateTestBase {
            override protected void Execute() {
                ResetDBUpdates(0x4d530064, 3);
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
        [TestCase]
        class ManualPropH2_1 : UpdateTestBase {
            override protected void Execute() {
                PropXbox1Update("Halo2_AU1");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
        [TestCase]
        class ManualPropH2_2 : UpdateTestBase {
            override protected void Execute() {
                PropXbox1Update("Halo2_AU2");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
        [TestCase]
        class ManualPropH2_3 : UpdateTestBase {
            override protected void Execute() {
                PropXbox1Update("Halo2_AU3");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
        [TestCase]
        class ManualPropH2_5 : UpdateTestBase {
            override protected void Execute() {
                PropXbox1Update("Halo2_AU5");
                PrintUODBTitleVersions();
                SetResultCode(true);
            }
        }
    }

    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")]
    public class NegativeTestCases : TestNode
    {
        [TestCase]
        class Xbox360TitleAU_NegativeMatrix : UpdateTestBase {
            override protected void Execute() {
                bool success = VerifyAllNegativeMatrixTests();
                SetResultCode(success);
            }
        }

        //give an invalid titleID, watch for error
        [TestCase]
        class Mismatched_TitleId : ContentTestBase
        {
            override protected void Execute() 
            {
                bool success = true;
                const string TEST_NAME = "Mismatched_TitleId";
                int site = 1;

                Console.WriteLine("Cleaning old content download share and titlevault files...");
                CleanData(TEST_NAME, site);

                success = ExpectFail(TEST_NAME, site);
                SetResultCode(success);
            }
        }
	
        [TestCase]
        class ContentX2_Offer : ContentTestBase
        {
            override protected void Execute() 
            {
                bool success = true;
                const string TEST_NAME = "2Content_Offer";
                int site = 1;

                Console.WriteLine("Cleaning old content download share and titlevault files...");
                CleanData(TEST_NAME, site);

                success = ExpectFail(TEST_NAME, "only one Content section allowed", site);
                SetResultCode(success);
            }
        }

        [TestCase]
        class No_ContentOffer : ContentTestBase
        {
            override protected void Execute()
            {
                bool success = true;
                const string TEST_NAME = "No_ContentOffer";
                int site = 1;

                Console.WriteLine("Cleaning old content download share and titlevault files...");
                CleanData(TEST_NAME, site);

                success = ExpectFail(TEST_NAME, "at least one ContentOffer section required", site);
                SetResultCode(success);
            }
        }      

        //give an empty offer file, watch for error.
        [TestCase]
        class Empty_OfferFile : ContentTestBase
        {
            override protected void Execute() 
            {
                bool success = true;
                const string TEST_NAME = "Empty_OfferFile";
                int site = 1;
				
                success = ExpectExceptionOnly(TEST_NAME, site);
                SetResultCode(success);
            }
        }

		
        //give an empty cab file, watch for error
        [TestCase]
        class Empty_Cab_File : ContentTestBase
        {
            override protected void Execute() 
            {
                bool success = true;
                const string TEST_NAME = "Empty_CabFile";
                int site = 1;
				
                success = ExpectExceptionOnly(TEST_NAME, site);
                SetResultCode(success);
            }
        }


        //give empty cab file with /usedefaultoffer flag.
        [TestCase]
        class Bad_Cab_With_Use_Default : ContentTestBase {
            override protected void Execute() {
                bool success = true;
                const string TEST_NAME = "Bad_CabFile";
                int site = 1;
				
                success = ExpectExceptionOnly(TEST_NAME, site);
                SetResultCode(success);
            }
        }

        [TestCase]
        class Bad_Offer : ContentTestBase {
            override protected void Execute() {
                bool success = true;
                const string TEST_NAME = "Bad_OfferFile";
                int site = 1;
				
                success = ExpectExceptionOnly(TEST_NAME, site);
                SetResultCode(success);
            }
        }
		
        [TestCase]
        class No_Action_Flag : ContentTestBase
        {
            override protected void Execute()
            {
                SetResultCode(RunManualNegTest("/package /site:1 /titleid", "/action was not specified"));
            }
        }

        [TestCase]
        class Invalid_Action : ContentTestBase
        {
            override protected void Execute()
            {
                SetResultCode(RunManualNegTest("/action:buil /package /site:1 /titleid", "invalid action specified"));
            }
        }
        [TestCase]
        class No_Sites : ContentTestBase
        {
            override protected void Execute()
            {
                SetResultCode(RunManualNegTest("/action /package /site /titleid", "failed to parse site list"));
            }
        }
        [TestCase]
        class No_Site_Flag : ContentTestBase
        {
            override protected void Execute()
            {
                SetResultCode(RunManualNegTest("/action /package /titleid", "/site flag is missing"));
            }
        }
        [TestCase]
        class No_Package_Flag : ContentTestBase
        {
            override protected void Execute()
            {
                SetResultCode(RunManualNegTest("/action /site:1 /titleid", "/package flag is missing"));
            }
        }
        [TestCase]
        class No_TitleID_Flag : ContentTestBase
        {
            override protected void Execute()
            {
                SetResultCode(RunManualNegTest("/action /package /site", "/titleid flag is missing"));
            }
        }
  
        /*
        //Ensure no offer can be matched with a wrong content file.
        [TestCase]
        class Mismatched_Offer_Matrix : ContentTestBase {
            override protected void Execute() {
                

            }
        }
        */  

        /*
         * TODO:Write ExpectExceptionAndRegex.
         [TestCase] //PS 43407
         class Invalid_OfferId : ContentTestBase {
         override protected void Execute() {
         bool success = true;
         const string TEST_NAME = "Invalid_OfferId";
         int site = 1;
				
         success = ExpectExceptionAndRegex(TEST_NAME, site, "failed to parse offerid");
         SetResultCode(success);
         }
         }

         [TestCase]  //PS 43407
         class Invalid_TitleId : ContentTestBase {
         override protected void Execute() {
         bool success = true;
         const string TEST_NAME = "Invalid_TitleId";
         int site = 1;
				
         success = ExpectExceptionAndRegex(TEST_NAME, site, "failed to parse titleid");
         SetResultCode(success);
         }
         }

         [TestCase]  //PS 43407
         class Invalid_TitleId_and_OfferId : ContentTestBase {
         override protected void Execute() {
         bool success = true;
         const string TEST_NAME = "Invalid_TitleId_and_OfferID";
         int site = 1;
				
         success = ExpectExceptionAndRegex(TEST_NAME, site, "failed to parse");
         SetResultCode(success);
         }
         }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\UpdateTestBase.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.Utilities;
using System.Xml;

using ServerTestFramework.Database;

using System.Collections;


namespace LiveContentTest {
	/// <summary>
	/// TestBase for the update side of LiveContent.  NOTE:This uses data structures from UODB.cs
	/// when grabbing info out of the database.
	/// </summary>
	abstract public class UpdateTestBase : TestBase	{
		public static Hashtable _testFiles; 
		protected static string _inputFilePath;
		protected static string _liveContentPath;

		public static ArrayList _positiveVersionTests;
		public static Hashtable _updateInstSet;  //the six instructions used in the test matrix.
		public static ArrayList _posMatrixData;
		public static ArrayList _negMatrixData;


		public UpdateTestBase()	{
			//Initialize some useful constants out of the .ini
			//One day merge common parts of ContentTestBase and UpdateTestBase into a parent
			#region Grab XML Data

			XmlNode liveContentConfig = Global.Config.SelectSingleNode("descendant::LiveContentTest");
			XmlNode inputFilePath = liveContentConfig.SelectSingleNode("InputFilePath");
			_inputFilePath = Path.GetFullPath(inputFilePath.InnerXml);

			XmlNode defaultToolsPath = liveContentConfig.SelectSingleNode("DefaultToolsPath");
			XmlNode liveContentExe = liveContentConfig.SelectSingleNode("LiveContentExe");
			_liveContentPath = Path.Combine(Path.GetFullPath(defaultToolsPath.InnerXml), liveContentExe.InnerXml);
			#endregion
			
			_testFiles = new Hashtable();
			#region Initialize Test Data

			#region Xbox360AUs
			//positive tests
			_testFiles.Add("Test1_101", new UpdateTestData(_inputFilePath, 0xFFFE07EA, "FFFE07EA_001_101.cab", 0x1, 0x101));
			_testFiles.Add("Test1_201", new UpdateTestData(_inputFilePath, 0xFFFE07EA, "FFFE07EA_001_201.cab", 0x1, 0x201));
			_testFiles.Add("Test1_301", new UpdateTestData(_inputFilePath, 0xFFFE07EA, "FFFE07EA_001_301.cab", 0x1, 0x301));


			#region Positive Test Matrix Data

			//this is *ugly*, but in terms of expediency, let's throw all the data
			//into the ArrayList.
			_posMatrixData = new ArrayList(30);

			//#1
			TestMatrixCase newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddExpectedRow(0x1, 0x1, 0x101,2);
            newSet.AddExpectedRow(0x101, 0x101, 0x101, 2);
			_posMatrixData.Add(newSet);

			//#2
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], false);
            newSet.AddExpectedRow(0x1, 0x101, 0x101, 2);
            newSet.AddExpectedRow(0x101, 0x101, 0x101, 2);
			_posMatrixData.Add(newSet);

			//#3
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
            newSet.AddExpectedRow(0x1, 0x1, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);

			//#4
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], false);
            newSet.AddExpectedRow(0x1, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);
			
			//#5
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], UPDATETYPE.MAKEFULL);
            newSet.AddExpectedRow(0x1, 0x101, 0x101, 2);
            newSet.AddExpectedRow(0x101, 0x101, 0x101, 2);
			_posMatrixData.Add(newSet);

			//#6
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
            newSet.AddExpectedRow(0x1, 0x1, 0x201, 2);
            newSet.AddExpectedRow(0x101, 0x101, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);

			//#7
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], false);
            newSet.AddExpectedRow(0x1, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x101, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);

			//#8
			//1->101 S
			//101->201 S   ???  We can have updates starting at 101??  TODO
			
			//#9
			//1->101 S
			//101-->201 G

			//#10
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
            newSet.AddExpectedRow(0x1, 0x101, 0x201, 2);
            newSet.AddExpectedRow(0x101, 0x101, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);

			//#11
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], false);
            newSet.AddExpectedRow(0x1, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x101, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);
			
			//#12
			//1->101 G
			//101->201 S

			//#13
			//1->101 G
			//101->201 G

			//#14
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], UPDATETYPE.MAKEFULL);
            newSet.AddExpectedRow(0x1, 0x101, 0x201, 2);
            newSet.AddExpectedRow(0x101, 0x101, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);

			//#15
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], UPDATETYPE.MAKEFULL);
            newSet.AddExpectedRow(0x1, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x101, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_posMatrixData.Add(newSet);

			//#16
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_301"], true);
            newSet.AddExpectedRow(0x1, 0x1, 0x301, 2);
            newSet.AddExpectedRow(0x101, 0x101, 0x301, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x301, 2);
            newSet.AddExpectedRow(0x301, 0x301, 0x301, 2);
			_posMatrixData.Add(newSet);

			//#17
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_301"], false);
            newSet.AddExpectedRow(0x1, 0x301, 0x301, 2);
            newSet.AddExpectedRow(0x101, 0x301, 0x301, 2);
            newSet.AddExpectedRow(0x201, 0x301, 0x301, 2);
            newSet.AddExpectedRow(0x301, 0x301, 0x301, 2);
			_posMatrixData.Add(newSet);

			//#18
			//1->101S
			//1->201S
			//101->201G

			//#19
			//1 => 101 Selective 
			//1 => 201 Selective 
			//101 => 201 Selective

			//#20
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_301"], true);
            newSet.AddExpectedRow(0x1, 0x201, 0x301, 2);
            newSet.AddExpectedRow(0x101, 0x201, 0x301, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x301, 2);
            newSet.AddExpectedRow(0x301, 0x301, 0x301, 2);
			_posMatrixData.Add(newSet);

			//#21
			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_301"], false);
            newSet.AddExpectedRow(0x1, 0x301, 0x301, 2);
            newSet.AddExpectedRow(0x101, 0x301, 0x301, 2);
            newSet.AddExpectedRow(0x201, 0x301, 0x301, 2);
            newSet.AddExpectedRow(0x301, 0x301, 0x301, 2);
			_posMatrixData.Add(newSet);

			//#22

			/*  REMAINING TEST CASES. TODO
			 * 1 => 101 Global 
				1 => 201 Global 
				201 => 301 Selective

				1 => 101 Global 
				1 => 201 Global 
				201 => 301 Global

				1 => 101 Global 
				101 => 201 Selective 
				1 => 201 Global

				1 => 101 Global 
				101 => 201 Selective 
				1 => 301 Selective

				1 => 101 Global 
				101 => 201 Selective 
				1 => 301 Global

				1 => 101 Global 
				101 => 201 Selective 
				101 => 301 Selective

				1 => 101 Global 
				101 => 201 Selective 
				101 => 301 Global

				1 => 101 Global 
				101 => 201 Selective 
				201 => 301 Selective

				1 => 101 Global 
				101 => 201 Selective 
				201 => 301 Global
				*/
			#endregion

			//negative tests
			#region Negative Test Matrix Data
			_negMatrixData = new ArrayList(30);

			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], UPDATETYPE.MAKEFULL);
			newSet.AddExpectedRow(0x1, 0x1, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_negMatrixData.Add(newSet);

			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], true);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
            newSet.AddExpectedRow(0x1, 0x1, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_negMatrixData.Add(newSet);

			newSet = new TestMatrixCase(0xFFFE07EA);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_201"], false);
			newSet.AddInst((UpdateTestData) _testFiles["Test1_101"], true);
            newSet.AddExpectedRow(0x1, 0x201, 0x201, 2);
            newSet.AddExpectedRow(0x201, 0x201, 0x201, 2);
			_negMatrixData.Add(newSet);
			#endregion
			#endregion

			#region Xbox1AUs
			
			_testFiles.Add("Halo2_AU1", new UpdateTestData(_inputFilePath, 0x4d530064, "MS10003W-MS-1.PAC", 0x1, 0x101));
			_testFiles.Add("Halo2_AU2", new UpdateTestData(_inputFilePath, 0x4d530064, "MS10003W-MS-2.PAC", 0x1, 0x201));
			_testFiles.Add("Halo2_AU3", new UpdateTestData(_inputFilePath, 0x4d530064, "MS10003W-MS-3.PAC", 0x1, 0x301));
			_testFiles.Add("Halo2_AU5", new UpdateTestData(_inputFilePath, 0x4d530064, "MS10003W-MS-5.PAC", 0x1, 0x501));
																  
			#endregion

			#endregion
		}

		/// <summary>
		/// Encapsulates all creations of LiveContent.  Allows general modifications to 
		/// all LiveContent executions(such as -noreload to save time, or timeout modifications)
		/// </summary>
		/// <param name="pathName"></param>
		/// <returns></returns>
		static public LiveContent CreateNewLCHandle() {
			LiveContent newLCHandle = new LiveContent(_liveContentPath);
			newLCHandle.Timeout = 600;
			newLCHandle.setUpdateFlag(LiveContent.updateType.global);  //so that we default to seeing AUs.
			return newLCHandle;
		}


		public void ResetDBUpdates(uint titleId, uint baseVer) {
			//toast the DB for titleID.
			//adds the base version to the title afterwards.
			//still need to manually reload the XKDC afterwards!

			//TODO:Should this rely on LiveTitle?  for now, manually hits Uodb.cs.
			//NOTE:DOES NOT CLEAN PACKAGES in Titlevault or ContentDownload
			//NOTE:Does we actually copy to Titlevault?
			//NOTE:We need contentID, but this is constant--capture the contentId once and store
			//in code.
			UodbWS.DeleteAllTitleUpdateInfo(titleId, baseVer);
		}

		public void Prop360Update(string testName) {
			LiveContent lcHandle = CreateNewLCHandle();
			UpdateTestData testData = ((UpdateTestData) _testFiles[testName]);
			testData.ApplyToLiveContentHandle(lcHandle);

			lcHandle.Deploy360Package();
			Console.WriteLine(lcHandle.Output);
			//Verify360Update(testName);
		}

		public void PropXbox1Update(string testName) {
			LiveContent lcHandle = CreateNewLCHandle();
			UpdateTestData testData = ((UpdateTestData) _testFiles[testName]);
			testData.ApplyToLiveContentHandle(lcHandle);

			lcHandle.DeployXbox1AutoUpdate();
			Console.WriteLine(lcHandle.Output);
			//VerifyXbox1Update(testName);
		}

		//ensure that the expected changes are made to everything except t_title_versions.
		//t_title_versions cannot be checked here because it depends on a previous state.
		public bool Verify360Update(string testName) {
			//verification
			//make sure entries added to update_packages
			//make sure XRL contentID matches parsed contentID for all entries that update
			//   to this update.
			//re-form XRL?  right server?
			//make sure entries added to update_locations.
			//make sure contentID matches parsed contentID and file.
			//make sure i_package_size matches rebuilt package at content download spot
			return true;		
		}

		public bool VerifyUpdatePackages(string testName) {
			//ensure added to TitleVault, contentdownload, etc.?
			return true;
		}

		public bool VerifyAllPositiveMatrixTests() {
			const uint TITLEID = 0xFFFE07EA;
			bool success = true;
			for (int i=0; i<_posMatrixData.Count; i++) {
				success = success && VerifyPositiveTitleMatrix(i, TITLEID);
			}
			return success;
		}

		//Verify that a matrix test leaves the versions table in the right state.
		//Checks only the matrix.  Does no verification on if the file is copied
		//to the TitleVault, or if the other two tables are modified as well.
		public bool VerifyPositiveTitleMatrix(int caseNum, uint titleId) {
			bool success = true;
			TestMatrixCase thisCase = (TestMatrixCase) _posMatrixData[caseNum];
			UodbWS.DeleteAllTitleUpdateInfo(titleId, 1);
			
			for (int i=0; i< thisCase.Steps.Count; i++) 
            {
                // Run commands for each step...
                success = ((UpdateInst)thisCase.Steps[i]).Execute();
                /*
				lcHandle = CreateNewLCHandle();
				((UpdateInst) thisCase.Steps[i]).ApplyInstToLiveContentHandle(lcHandle);
				try {
					lcHandle.Deploy360Package();
				} catch (LiveContentException e) {
					Global.RO.Error("Unexpected Excpetion:" + e.Message);
					Global.RO.Info(lcHandle.Output);
					success = false;				
				}
				//DEBUG
				Global.RO.Info(lcHandle.Output);
                 */
			}

			bool titleVersionsOkay = VerifyTitleVersions(thisCase.ExpectedRows);
			if (titleVersionsOkay) {
				Global.RO.Success("Matrix case {0} tests correctly.", caseNum);
			} else {
				Global.RO.Error("Error!  Matrix case {0} fails!", caseNum);
                                Global.RO.Warn("Expecting the following in t_title_versions:");
                                Global.RO.Info(thisCase.ExpectedRows.ToString());
                                Global.RO.Warn("Instead observed the following:");
                                PrintUODBTitleVersions();
			}
			success = success && titleVersionsOkay;

				
			//grab existing matrices from all uodbs.
			//TODO:ensure all uodb matrices are identical.
			return success;
		}
	

		public bool VerifyTitleVersions(TitleVersions expectedRows) {
			//ensure expected matrix == first uodb matrix.
			ArrayList version_db_sets = UodbWS.GetAllTitleVersions(0xFFFE07EA);
			TitleVersions versionResult = (TitleVersions) version_db_sets[0];
            foreach (TitleVersion tversion in expectedRows)
            {
                tversion.Changed = versionResult[0].Changed;
            }
			return versionResult.Contains(expectedRows[0]);
		}

		public bool VerifyAllNegativeMatrixTests() {
			const uint TITLEID = 0xFFFE07EA;
			bool success = true;
			for (int i=0; i<_negMatrixData.Count; i++) {
				success = success && VerifyNegativeTitleMatrix(i, TITLEID);
			}
			return success;
		}

		//Version just for negative cases.
		public bool VerifyNegativeTitleMatrix(int caseNum, uint titleId) {
			bool success = true;
			TestMatrixCase thisCase = (TestMatrixCase) _negMatrixData[caseNum];
			UodbWS.DeleteAllTitleUpdateInfo(titleId, 1);
			
			LiveContent lcHandle = null;
			
			try { //try is outside--we expect any one of the steps to fail.
				for (int i=0; i< thisCase.Steps.Count; i++) {
					lcHandle = CreateNewLCHandle();
					((UpdateInst) thisCase.Steps[i]).ApplyInstToLiveContentHandle(lcHandle);
					lcHandle.Deploy360Package();
					Global.RO.Info(lcHandle.Output);
				}
				Global.RO.Error("Exception did not occur as expected!");
				success = false;				

			} catch (LiveContentException e) {
				Global.RO.Success("Exception occurred as expected.");
				Global.RO.Info("Exception text:" + e.Message);
			}
			//verify t_title_versions is the way we expect it to be.
			bool titleVersionsOkay = VerifyTitleVersions(thisCase.ExpectedRows);
			if (titleVersionsOkay) {
				Global.RO.Success("Matrix case {0} tests correctly.", caseNum);
			} else {
				Global.RO.Error("Error!  Matrix case {0} fails!", caseNum);
			}
			success = success && titleVersionsOkay;

			return success;

		}
		
		public void PrintUODBTitleVersions() {
			ArrayList version_db_sets = UodbWS.GetAllTitleVersions(0xFFFE07EA);
			foreach (TitleVersions t in version_db_sets) {
				Global.RO.Info(t.ToString());
			}
		}

		public void SetResultCode(bool success) {
			if (success) {
				ResultCode = TEST_RESULTS.PASSED;
			} 
			else {
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}

	/// <summary>
	/// Similar to ContentTestData, but has additional information per data such as the
	/// title update information.  
	/// TODO:One day pull similar code from ContentTestData and 
	///       UpdateTestData into a common parent.
	/// </summary>
	public class UpdateTestData {
		private uint titleId;
		private string packageName;

		private uint baseVer;
		private uint updateVer;

		public uint TitleId {get { return titleId; } }
		public uint BaseVer {get { return baseVer; } }
		public uint UpdateVer {get { return updateVer; } }

		public UpdateTestData(string inputFilePath, uint titleId, string packageName, uint baseVer, uint updateVer) {
			this.titleId=titleId;
			this.packageName=Path.Combine(inputFilePath, packageName);
			this.baseVer=baseVer;
			this.updateVer=updateVer;
		}

		public void ApplyToLiveContentHandle(LiveContent lcHandle) {
			lcHandle.SetPackageFile(packageName, titleId);
		}
	}

	/// <summary>
	/// Helper class for TestMatrixCase.  Pairs a test with selective/not selective.
	/// </summary>
	public class UpdateInst {
		public UpdateTestData testData;
		public bool selective;
        public UPDATETYPE updateType;
		public UpdateInst(UpdateTestData testData, bool selective) {
			this.testData = testData;
			this.selective = selective;
		}

        public UpdateInst(UpdateTestData testData, UPDATETYPE type)
        {
            this.testData = testData;
            this.updateType = type;
        }

		public void ApplyInstToLiveContentHandle(LiveContent lcHandle) 
        {
			testData.ApplyToLiveContentHandle(lcHandle);
			if (selective) {
				lcHandle.setUpdateFlag(LiveContent.updateType.selective);
			} else {
				lcHandle.setUpdateFlag(LiveContent.updateType.global);
			}
	    }

        public bool Execute()
        {
            LiveContent lcHandle = UpdateTestBase.CreateNewLCHandle();
            
            try
            {
                switch (updateType)
                {
                    case UPDATETYPE.SELECTIVE:
                    case UPDATETYPE.FULL:
                        selective = (updateType == UPDATETYPE.SELECTIVE);
                        ApplyInstToLiveContentHandle(lcHandle);
                        lcHandle.Deploy360Package();
                        break;
                    case UPDATETYPE.MAKEFULL:
                        lcHandle.MakeAutoUpdateFull(testData.TitleId, testData.BaseVer, testData.UpdateVer, LiveContent.platformType.xenon );
                        break;
                }
            }
            catch (LiveContentException e)
            {
                Global.RO.Error("Unexpected Excpetion:" + e.Message);
                Global.RO.Info(lcHandle.Output);
                return false;
            }
            //DEBUG
            Global.RO.Info(lcHandle.Output);
            return true;
        }
	}		

    public enum UPDATETYPE { SELECTIVE, FULL, MAKEFULL };
	
	public class TestMatrixCase {
		//A TestMatrixCase is a set of instructions
		private ArrayList steps;

		//and an expected result.
		private TitleVersions expectedRows;

		public ArrayList Steps {
			get { return steps; }
		}

		public TitleVersions ExpectedRows { 
			get { return expectedRows; } 
		}

		//this is needed to fill out information in UODB.
		private uint titleId;

		public TestMatrixCase(uint titleId) {
			steps = new ArrayList();
			expectedRows = new TitleVersions();
			this.titleId = titleId;
		}

		public void AddInst(UpdateTestData updateFile, bool selective) 
        {
			//steps.Add(new UpdateInst(updateFile, selective));
            if (selective)
                steps.Add(new UpdateInst(updateFile, UPDATETYPE.SELECTIVE));
            else
                steps.Add(new UpdateInst(updateFile, UPDATETYPE.FULL));
		}

        public void AddInst(UpdateTestData updateFile, UPDATETYPE updateType)
        {
            steps.Add(new UpdateInst(updateFile, updateType));
        }

		public void AddExpectedRow(uint baseVer, uint updateVer, uint betaVer, byte consoleType) 
        {
			TitleVersion t = new TitleVersion();
			t.TitleId = titleId;
			t.BaseVersion = baseVer;
			t.UpdateVersion = updateVer;
			t.BetaVersion = betaVer;
			t.Changed = DateTime.MinValue;
			t.ConsoleTypeId = consoleType;
			expectedRows.Add(t);
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\TitleVaultHandle.cs ===
using System;
using System.IO;
using xonline.common.config;

namespace LiveContentTest
{
	/// <summary>
	/// Static class which simplifies accessing a path in the titlevault, given a
	/// LiveContentData.
	/// </summary>
	public class TitleVaultHandle 
	{
		/// <summary>
		/// Delete content from the previous content download share.  Does not report if the
		/// file was absent.
		/// </summary>
		public static void Nuke(ContentTestData testData) 
		{
			Nuke(testData.TitleId, testData.OfferId, testData.ContentId);
			if (testData.HasSecondOfferFile()) 
			{
				Nuke(testData.TitleId, testData.OfferId2, testData.ContentId2);
			}
		}
		private static void Nuke(uint titleId, ulong offerId, string contentId) 
		{
			string filePath = GetPath(titleId, offerId, contentId);
			if (File.Exists(filePath)) 
			{
				Console.WriteLine("Found old TitleVault file, deleting {0}", filePath);
				File.Delete(filePath);
			} 
		}
		
		/// <summary>
		/// Given a ContentTestData, determine if the package file was copied to
		/// the TitleVault
		/// </summary>
		/// <param name="testData">Data specifying the package, titleId and contentId</param>
		public static bool Verify(ContentTestData testData) 
		{
			bool passed = true;
			passed = passed && Verify(testData.TitleId, testData.OfferId, testData.ContentId);
			if (testData.HasSecondOfferFile()) 
			{
				passed = passed && Verify(testData.TitleId, testData.OfferId2, testData.ContentId2);
			}
			return passed;
		}

        public static bool Verify(uint titleId, ulong offerId, string contentId) 
		{
			string filePath = GetPath(titleId, offerId, contentId);
			Console.WriteLine("Checking:{0}", filePath);
			if (!File.Exists(filePath))
			{
				Console.WriteLine("TitleVault file failed to copy!");
				return false;
			}
			return true;
		}

        public static string GetPath(uint titleId, ulong offerId, string contentId) 
		{
			string titleRoot = Path.Combine(Config.GetSetting( Setting.titlevault_root ), 
				titleId.ToString("x"));
			return Path.Combine(titleRoot, offerId.ToString("x") + "_" + contentId + ".cab");
		}

        public static string GetDefaultFolder()
        {
            return Path.Combine(Config.GetSetting(Setting.titlevault_root),Config.Environment);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\ContentTestBase.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using System.Collections;
using System.Xml;
using System.Reflection;
//using System.Text.RegularExpressions.Regex;

using xonline.common.config;

namespace LiveContentTest {
	/// <summary>
	/// Contains code for verifying that content has been successfully
	/// propped.  This does not include Autoupdates.
	/// </summary>
	abstract public class ContentTestBase : TestBase {
		public static Hashtable _testFiles; 
		protected static string _inputFilePath;
		protected static string _liveContentPath;
		protected static string _liveOfferPath;
        protected static string _tempFilePath;

		public ContentTestBase() {
			//Initialize some useful constants out of the .ini
			#region Grab XML Data

			XmlNode liveContentConfig = Global.Config.SelectSingleNode("descendant::LiveContentTest");
			XmlNode node = liveContentConfig.SelectSingleNode("InputFilePath");
			_inputFilePath = Path.GetFullPath(node.InnerText);

            node = liveContentConfig.SelectSingleNode("TempFilePath");
            if (node != null)
            {
                _tempFilePath = Path.GetFullPath(node.InnerText);
            }
            else
            {
                _tempFilePath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Temp\\Content");
            }

			XmlNode defaultToolsPath = liveContentConfig.SelectSingleNode("DefaultToolsPath");
			XmlNode liveContentExe = liveContentConfig.SelectSingleNode("LiveContentExe");
			_liveContentPath = Path.Combine(Path.GetFullPath(defaultToolsPath.InnerXml), liveContentExe.InnerXml);

			XmlNode liveOfferExe = liveContentConfig.SelectSingleNode("LiveOfferExe");
			_liveOfferPath = Path.Combine(Path.GetFullPath(defaultToolsPath.InnerXml), liveOfferExe.InnerXml);
			#endregion
			
			//This test data is not to be modified after initialization.
			//It is used to contain paths to filenames and their 
			//associated titleID and offerIDs.  One day should put in a file.  For
			//now though, it will make little difference, as adding/removing test cases
			//would require code changes anyway.  It'd only help if we wanted to move these
			//files around.
			_testFiles = new Hashtable();
			#region Initialize Test Data
			//positive tests
			
			//xbox360Content
			_testFiles.Add("BVT_InGame", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B1.cab", 0xFFFE07D1000000B1, "FFFE07D1000000B1.offer" ));
			_testFiles.Add("BVT_Theme", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B2.cab", 0xFFFE07D1000000B2, "FFFE07D1000000B2.offer" ));
			_testFiles.Add("BVT_GamerPics", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B3.cab", 0xFFFE07D1000000B3, "FFFE07D1000000B3.offer" ));
			_testFiles.Add("BVT_Trailer_HI_AND_LO", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B4.cab",
				0xFFFE07D1000000B4, "FFFE07D1000000B4.offer",
				0xFFFE07D1000000B7, "FFFE07D1000000B7.offer" ));
			_testFiles.Add("BVT_Demo", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B5.cab", 0xFFFE07D1000000B5, "FFFE07D1000000B5.offer" ));
			_testFiles.Add("BVT_Arcade", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B6.cab", 0xFFFE07D1000000B6, "FFFE07D1000000B6.offer" ));

			_testFiles.Add("BVT_Trailer_HI", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B8.cab", 0xFFFE07D1000000B8, "FFFE07D1000000B8.offer"));
			_testFiles.Add("BVT_Trailer_LO", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B9.cab", 0xFFFE07D1000000B9, "FFFE07D1000000B9.offer"));
			_testFiles.Add("BVT_Video_HI_AND_LO", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000BA.cab", 
				0xFFFE07D1000000BA, "FFFE07D1000000BA.offer",
				0xFFFE07D1000000BD, "FFFE07D1000000BD.offer"));
			_testFiles.Add("BVT_Video_HI", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000BB.cab", 0xFFFE07D1000000BB, "FFFE07D1000000BB.offer"));
			_testFiles.Add("BVT_Video_LO", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000BC.cab", 0xFFFE07D1000000BC, "FFFE07D1000000BC.offer"));

			//xbox360OldContent
			_testFiles.Add("2417.4_InGame", new ContentTestData(_inputFilePath, 0xFFFE07EB, "FFFE07EB00000001.cab", 0xFFFE07EB00000001, "0xFFFE07EB00000001.offer" ));
			_testFiles.Add("2417.4_Theme", new ContentTestData(_inputFilePath, 0xFFFE07EB, "FFFE07EB00000002.cab", 0xFFFE07EB00000002, "0xFFFE07EB00000002.offer" ));
			_testFiles.Add("2417.4_GamerPics", new ContentTestData(_inputFilePath, 0xFFFE07EB, "FFFE07EB00000003.cab", 0xFFFE07EB00000003, "0xFFFE07EB00000003.offer" ));
			_testFiles.Add("2417.4_Trailer", new ContentTestData(_inputFilePath, 0xFFFE07EB, "FFFE07EB00000004.cab",
				0xFFFE07EB00000004, "0xFFFE07EB00000004.offer",
				0xFFFE07EB00000007, "0xFFFE07EB00000007.offer"));
			_testFiles.Add("2417.4_Demo", new ContentTestData(_inputFilePath, 0xFFFE07EB, "FFFE07EB00000005.cab", 0xFFFE07EB00000005, "0xFFFE07EB00000005.offer" ));
			_testFiles.Add("2417.4_Arcade", new ContentTestData(_inputFilePath, 0xFFFE07EB, "FFFE07EB00000006.cab", 0xFFFE07EB00000006, "0xFFFE07EB00000006.offer" ));
			
			//xbox1Content


			//default offer tests
			//numbering system here for OfferID is [titleID][type][ID within that type]
			_testFiles.Add("POS_InGame_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100200001.cab", 0xFFFE07F100200001, "0xFFFE07F100200001.offer"));
			_testFiles.Add("POS_Theme_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100500001.cab", 0xFFFE07F100500001, "0xFFFE07F100500001.offer"));
			_testFiles.Add("POS_GamerPics_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100400001.cab", 0xFFFE07F100400001, "0xFFFE07F100400001.offer"));
			_testFiles.Add("POS_Trailer_Both_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100100001.cab", 0xFFFE07F100100001, "0xFFFE07F100100001.offer"));   
			_testFiles.Add("POS_Trailer_LoOnly_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100100002.cab", 0xFFFE07F100100002, "0xFFFE07F100100002.offer"));
			_testFiles.Add("POS_Trailer_HiOnly_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100100003.cab", 0xFFFE07F100100003, "0xFFFE07F100100003.offer"));
			_testFiles.Add("POS_Demo_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100300001.cab", 0xFFFE07F100300001, "0xFFFE07F100300001.offer"));
			_testFiles.Add("POS_Arcade_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100600001.cab", 0xFFFE07F100600001, "0xFFFE07F100600001.offer"));
			_testFiles.Add("POS_Video_DefaultOffer", new ContentTestData(_inputFilePath, 0xFFFE07F1, "FFFE07F100700001.cab", 0xFFFE07F100700001, "0xFFFE07F100700001.offer"));

			//negative tests
			_testFiles.Add("Mismatched_TitleId", new ContentTestData(_inputFilePath, 0x12345678, "FFFE07D1000000B1.cab", 0xFFFE07D1000000B1, "FFFE07D1000000B1.offer" ));
			_testFiles.Add("Empty_CabFile", new ContentTestData(_inputFilePath, 0xFFFE07D1, "empty.cab", 0xFFFE07D1000000B1, "FFFE07D1000000B1.offer"));
			_testFiles.Add("Bad_CabFile", new ContentTestData(_inputFilePath, 0xFFFE07D1, "bad.cab", 0xFFFE07D1000000B1, "FFFE07D1000000B1.offer"));
			_testFiles.Add("Empty_OfferFile", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B1.cab", 0xFFFE07D1000000B1, "empty.offer"));
			_testFiles.Add("Bad_OfferFile", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B1.cab", 0xFFFE07D1000000B1, "bad.offer"));
			_testFiles.Add("Two_Content_Trailer_But_One_Offer_File", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B4.cab", 0xFFFE07D1000000B4, "FFFE07D1000000B4.offer"));
			_testFiles.Add("Two_Content_Video_But_One_Offer_File", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000BA.cab", 0xFFFE07D1000000BA, "FFFE07D1000000BA.offer"));
            _testFiles.Add("2Content_Offer", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B1.cab", 0xFFFE07D1000000B1, "2Content.offer"));
            _testFiles.Add("No_ContentOffer", new ContentTestData(_inputFilePath, 0xFFFE07D1, "FFFE07D1000000B1.cab", 0xFFFE07D1000000B1, "NoContentOffer.offer"));
            
			#endregion

		}

		/// <summary>
		/// Encapsulates all creations of LiveContent.  Allows general modifications to 
		/// all LiveContent executions(such as -noreload to save time, or timeout modifications)
		/// </summary>
		/// <param name="pathName"></param>
		/// <returns></returns>
		public LiveContent CreateNewLCHandle() {
			LiveContent newLCHandle = new LiveContent(_liveContentPath);
			newLCHandle.Timeout = 600;
			return newLCHandle;
		}

		/// <summary>
		/// Use this to run a test case with no special flags, but run LiveOffer afterwards.
		/// </summary>
		/// <param name="testName"></param>
		/// <returns></returns>
		public bool TestLCAndLiveOfferNoFlags(string testName) {
			bool success = TestLCNoFlags(testName);
			success = success && PropOffer((ContentTestData) _testFiles[testName]);
			return success;
		}

        /// <summary>
        /// Creates the temp folder and copies the array of files to that directory.
        /// </summary>
        /// <param name="tempFiles">Path and filenames to copy to temp dir</param>
        public void SetupTempDir(string[] tempFiles)
        {
            // Create the temp dir if it isn't there...
            if (!Directory.Exists(_tempFilePath))
            {
                Directory.CreateDirectory(_tempFilePath);
            }

            // Copy all the files to the temp dir that are in the string array.
            foreach (string tempFile in tempFiles)
            {
                File.Copy(tempFile, Path.Combine(_tempFilePath, Path.GetFileName(tempFile)));
            }
        }

        public void CleanupTempDir()
        {
            if (Directory.Exists(_tempFilePath))
            {
                string[] files = Directory.GetFiles(_tempFilePath);

                foreach (string file in files)
                {
                    File.Delete(file);
                }
            }
        }

		/// <summary>
		/// Use this to run a test case with no special flags on a particular test case.
		/// </summary>
		/// <param name="testName"></param>
		/// <returns></returns>
		public bool TestLCNoFlags(string testName) {
			bool success = true;
			int site = 1; //for this test, use only one site, ID 1
			
			Console.WriteLine("Cleaning old content download share and titlevault files for " + testName + "...");
			CleanData(testName, site);
		
			success = success && ExpectPass(testName, site);
			return success;
		}

        public bool RunManualTest(string argString, string expectedString)
        {
            bool success = false;
            LiveContent lcHandle = new LiveContent(_liveContentPath);
            try
            {
                lcHandle.RunWithOnlyStringArguments(argString);
            }
            finally 
            {
                success = (lcHandle.Output.IndexOf(expectedString) > -1);
            }
            return success;
        }

        public bool RunManualNegTest(string argString, string expectedString)
        {
            bool success = false;
            LiveContent lcHandle = new LiveContent(_liveContentPath);
            try
            {
                lcHandle.RunWithOnlyStringArguments(argString);
                Global.RO.Info("No exception... bad!");
            }
            catch(LiveContentException e)
            {
                Global.RO.Info(e.ProcessOutput);
                Global.RO.Info(lcHandle.Output);
                success = (lcHandle.Output.IndexOf(expectedString) > -1);
            }
            return success;
        }

		/// <summary>
		/// Use this to test offers with a /usedefaultoffer flag enabled.
		/// </summary>
		/// <param name="testName">Name of the test to use.</param>
		public void TestUseDefaultOfferFlag(string testName) {
			bool success = true;
			ResultCode = TEST_RESULTS.NOT_EXECUTED;
			int site = 1; //for this test, use only one site, ID 1
			try {
				LiveContent lcHandle = CreateNewLCHandle();
				ContentTestData testData = ((ContentTestData) _testFiles[testName]);

				//This test is special;  The first time it runs, there is no offer file to discover
				//the files to clean.  Do not clean files unless the offer exists.  Afterwards, 
				//clean even the offer file.  Assume for two-offer cases, user hasn't maliciously
				//deleted one offer but not the other.
				if (testData.OfferFileIsPresent()) {
					CleanData(testName, site);
					//delete referenced pictures
					File.Delete(Path.Combine(_inputFilePath, testData.OfferFile));
					if (testData.HasSecondOfferFile()) {
						File.Delete(Path.Combine(_inputFilePath, testData.OfferFile2));
					}

				}
				//testData.ApplyToLiveContentHandle(lcHandle);  //we do NOT tell it offer files to use.
				lcHandle.SetPackageFile(testData.PackageName, testData.TitleId);
				lcHandle.UseDefaultOffer = true;
				success = ExpectPass(lcHandle, testName, site);
				//Additionally--verify that Offer type is of expected type.
				//verify picture(s) referenced in default offer file are copied
				
			} 
			catch (LiveContentException e) {
				Global.RO.Info(e.ProcessOutput);
				success = false;
			}

			SetResultCode(success);
		}

		/// <summary>
		/// Run a test and expect it to pass.  Verify things that LiveContent has
		/// finished successfully.  Runs LiveContent with a default set of arguments,
		/// including only an expected set of flags.
		/// </summary>
		public bool ExpectPass(string testName, int site) {
			LiveContent lcHandle = CreateNewLCHandle();
			ContentTestData testData = ((ContentTestData) _testFiles[testName]);
			testData.ApplyToLiveContentHandle(lcHandle);
			return ExpectPass(lcHandle, testName, site);
		}

		/// <summary>
		/// Run a test and expect it to pass.  Verify things that LiveContent has
		/// finished successfully.  This version allows the caller to prepare a LiveContent
		/// handle with whatever flags they deem fit.
		/// </summary>
		public bool ExpectPass(LiveContent lcHandle, string testName, int site)	{
			bool success = true;
			ContentTestData testData = ((ContentTestData) _testFiles[testName]);
			try {
				lcHandle.Deploy360Package();
				Global.RO.Info(lcHandle.Output);
			} 
			catch (LiveContentException e) {
				Global.RO.Error("Unexpected exception thrown!");
				Global.RO.Error("Exception states:" + e.Message);
				Global.RO.Info(lcHandle.Output);
				return false;
			}
			//verification
			testData.ParseOfferFile();
			success = success && TitleVaultHandle.Verify(testData);
			success = success && ContentDownloadHandle.Verify(testData, site);
			success = success && ValidateOfferFile(testData);

			if (success) {
				Global.RO.Success("Success--cab files placed correctly");
			} else {
				Global.RO.Error("One or more errors occurred on this prop!");
			}
			return success;
		}

		/// <summary>
		/// Run a test and expect it to fail by returning an error code.
		/// Verify that LiveContent did not make any changes as well.
		/// </summary>
		public bool ExpectFail(string testName, int site) {
			bool success;
			LiveContent lcHandle = CreateNewLCHandle();
			ContentTestData testData = ((ContentTestData) _testFiles[testName]);
			testData.ApplyToLiveContentHandle(lcHandle);

			success = RunLiveContentExpectingException(lcHandle);

			//verification
			testData.ParseOfferFile();
			success = success && !TitleVaultHandle.Verify(testData);
			success = success && !ContentDownloadHandle.Verify(testData, site);
			return success;
		}

        /// <summary>
        /// Run a test and expect it to fail by returning an error code.
        /// Verify that LiveContent did not make any changes as well.
        /// </summary>
        /// <param name="testName">Name of testfile</param>
        /// <param name="failSearchStr">String to search for in error output</param>
        /// <param name="site">Site number</param>
        /// <returns></returns>
        public bool ExpectFail(string testName, string failSearchStr, int site)
        {
            bool success;
            LiveContent lcHandle = CreateNewLCHandle();
            ContentTestData testData = ((ContentTestData)_testFiles[testName]);
            testData.ApplyToLiveContentHandle(lcHandle);

            success = RunLiveContentExpectingException(lcHandle);
            // See if our search string is in the output...
            success = success && (lcHandle.Output.IndexOf(failSearchStr) > -1);
            //verification
            testData.ParseOfferFile();
            success = success && !TitleVaultHandle.Verify(testData);
            success = success && !ContentDownloadHandle.Verify(testData, site);
            return success;
        }

		/// <summary>
		/// Run a test and expect it to fail by exception.  Here, it is assumed that nothing
		/// else can be checked, and the exception is the only thing we're looking for.
		/// </summary>
		public bool ExpectExceptionOnly(string testName, int site) {
			LiveContent lcHandle = CreateNewLCHandle();
			ContentTestData testData = ((ContentTestData) _testFiles[testName]);
			testData.ApplyToLiveContentHandle(lcHandle);

			return RunLiveContentExpectingException(lcHandle);
		}

		/// <summary>
		/// Runs the given LiveContent handle and expects an exception.
		/// </summary>
		/// <param name="?"></param>
		/// <returns></returns>
		public bool RunLiveContentExpectingException(LiveContent lcHandle) {
			bool success;
			try {
				lcHandle.Deploy360Package();
				Global.RO.Info(lcHandle.Output);
				success = false;
			}
			catch (LiveContentException e) {
				Global.RO.Success("Exception occurred and was expected");
				Global.RO.Info(e.ProcessOutput);
				success = true;
			}
			return success;
		}
	
		/// <summary>
		/// Deletes the expected results of LiveContent.
		/// </summary>
		/// <param name="testName"></param>
		/// <param name="site"></param>
		public void CleanData(string testName, int site) 
		{
			ContentTestData testData = ((ContentTestData) _testFiles[testName]);
			testData.ParseOfferFile();
			ContentDownloadHandle.Nuke(testData, site);
			TitleVaultHandle.Nuke(testData);
		}

		/// <summary>
		/// Removes the offer(s) associated with a test.  Must run with a debug version 
		/// of LiveOffer.  Will fail otherwise.
		/// </summary>
		/// <param name="testName">Name of the test to clean.</param>
		public void CleanOffer(string testName) 
		{
			LiveOffer lo = new LiveOffer(_liveOfferPath);
			lo.noTransaction = true;
			ContentTestData testData = ((ContentTestData) _testFiles[testName]);
			if (testData.HasOfferFile()) {
				//lo.NukeOffer(testData.OfferId);
                ServerTestFramework.LiveService.Billing.ContentOfferLoader.CleanOffers(testData.OfferId);
				if (testData.HasSecondOfferFile()) {
					//lo.NukeOffer(testData.OfferId2);				
                    ServerTestFramework.LiveService.Billing.ContentOfferLoader.CleanOffers(testData.OfferId);
				}
			}
		}

		/// <summary>
		/// Use LiveOffer to validate the offers in a 360 ContentTestData.
		/// </summary>
		/// <param name="testData"></param>
		/// <returns></returns>
		public bool ValidateOfferFile(ContentTestData testData) {
			bool validated = true;
			Global.RO.Info("Validating modified offer files...");
			LiveOffer lo = new LiveOffer(_liveOfferPath);
			lo.noTransaction = true;
			try {
				if (testData.HasOfferFile()) {
					lo.Validate360Offer(testData.OfferFile);
				} 
				if (testData.HasSecondOfferFile()) {
					lo.Validate360Offer(testData.OfferFile2);
				} 

				//ensure titleID is expected titleID
				//ensure offerID is expected offerID
				//for Arcade, ensure second offerID is different from first
				

			} catch (LiveOfferException e) {
				validated = false;
				Global.RO.Error("Unexpected exception thrown!");
				Global.RO.Error("Exception states:" + e.Message);
				Global.RO.Info(lo.Output);
			}
			return validated;

		}

        /// <summary>
        /// Use LiveOffer to validate the offers in a xbox ContentTestData.
        /// </summary>
        /// <param name="testData"></param>
        /// <returns></returns>
        public bool ValidateXboxOfferFile(ContentTestData testData)
        {
            bool validated = true;
            Global.RO.Info("Validating modified offer files...");
            LiveOffer lo = new LiveOffer(_liveOfferPath);
			lo.noTransaction = true;
            try
            {
                if (testData.HasOfferFile())
                {
                    lo.ValidateXboxOffer(testData.OfferFile);
                }
                if (testData.HasSecondOfferFile())
                {
                    lo.ValidateXboxOffer(testData.OfferFile2);
                }

                //ensure titleID is expected titleID
                //ensure offerID is expected offerID
                //for Arcade, ensure second offerID is different from first


            }
            catch (LiveOfferException e)
            {
                validated = false;
                Global.RO.Error("Unexpected exception thrown!");
                Global.RO.Error("Exception states:" + e.Message);
                Global.RO.Info(lo.Output);
            }
            return validated;

        }

		/// <summary>
		/// Props an offer, given a TestData.  This allows LiveContent to perform an
		/// end-to-end test.  After these tests are run, a user should be able to connect to
		/// the service and download the test content to finish the end-to-end pass.
		/// </summary>
		/// <param name="testData"></param>
		/// <returns></returns>
		public bool PropOffer(ContentTestData testData) {
			bool success = true;
			LiveOffer lo = new LiveOffer(_liveOfferPath);
			lo.noTransaction = true;
			Global.RO.Info("Propping offer file(s) to service.");
			try {
				if (testData.HasOfferFile()) {
					lo.Prop360Offer(testData.OfferFile, testData.TitleId, 
									LiveOffer.dbType.all, false);
					if (testData.HasSecondOfferFile()) {
						lo.Prop360Offer(testData.OfferFile2, testData.TitleId, 
							LiveOffer.dbType.all, false);
					}
				} else {
					Global.RO.Warn("Warning!  No offer files given for this testData, but PropOffer was called!");
				}
				Global.RO.Success("Offer(s) propped successfully");
			} catch (LiveOfferException e) {
				success = false;
				Global.RO.Error("Unexpected exception thrown!");
				Global.RO.Error("Exception states:" + e.Message);
				Global.RO.Info(lo.Output);
			}
			return success;
		}
/*
  //TODO:Add support for a negative test where every content is run with an offer that is the
         wrong type.  Create one offer file of each type, and regex the offerid so it matches
         a good cab.
            //slurps the entire offer file into a single string.
            public string ReadOfferFile(string filename) {
                StreamReader offerMapStream = File.OpenText(filename);
                String file = offerMapStream.ReadToEnd();
                return file;
            }

            public string RegexString(string source, string regex) {
                return Regex.Replace(source, regex);
            }
            
            //Writes an offer file to "temp.offer".  This file is always to be replaced, and is
            //specifically for temporary uses only.
            public string writeOfferFile(string data) {
                StreamWriter offerMapWriter = new StreamWriter(Path.Combine(_inputFilePath, "temp.offer");
                offerMapWriter.Write(data);
                
            }

*/

            public void SetResultCode(bool success) {
                if (success) {
                    ResultCode = TEST_RESULTS.PASSED;
                } else {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livecontenttest_none_12.4.56.0_none_6598c0d7c6ac49a4
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livecontenttest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.manifest
XP_MANIFEST_PATH=manifests\msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.cat
XP_CATALOG_PATH=manifests\msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.cat
XP_PAYLOAD_PATH=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livecontenttest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\CTitleId.cs ===
using System;
using System.Globalization;

using xonline.common.service;

namespace LiveMatchTest 
{
    /// <summary>
    /// A utiltiy class to make working with title IDs simpler.
    /// Today, a title ID is a 32 bit integer.
    /// This class is immutable once constructed
    /// </summary>
    public class CTitleId
    {
        /// <summary> The title id as a 32 bit unsigned integer </summary>
        protected uint _uiTitleId;
        /// <summary>
        /// The title id as an 8 character hex string, including leading zeros,
        /// but with no "0x" prefix
        /// </summary>
        protected string _sTitleIdHexNoPrefix;

        /// <summary>
        /// Constructs a CTitleId object from a 32 bit unsigned integer value
        /// </summary>
        /// <param name="uiTitleId">
        /// The title id as a 32 bit unsigned integer
        ///.</param>
        public CTitleId(uint uiTitleId)
        {
            CtorHelper(uiTitleId);
        }

        /// <summary>
        /// Constructs a CTitleId object from a string value
        /// </summary>
        /// <param name="sTitleId">
        /// The title id as a string. Leading or trailing whitespace is ignored.
        /// if the string begins with "0x" or "0X" it will be interpreted as a hexadecimal
        /// value. Otherwise, it is interpreted as a decimal value. Only the decimal or
        /// hex digits and the hex prefix are permitted.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// sTitleId is a null reference
        /// </exception>
        /// <exception cref="FormatException">
        /// sTitleId could not be parsed as either a decimal or hexadecimal integer
        /// </exception>
        /// <exception cref="OverflowException">
        /// sTitleId represents a number smaller than 0 or larger than 0xFFFFFFFF
        /// </exception>
        public CTitleId(string sTitleId)
        {
            if (sTitleId == null)
            {
                throw new ArgumentNullException("null string passed to CTitleId(string)");
            }

            uint tid = SafeConvert.ToUInt32(sTitleId);
            if (tid == 0)
            {
                throw new ApplicationException("Invalid title id '" + sTitleId + "'");
            }

            CtorHelper(tid);
        }

        // need this because I don't want to duplicate logic, and it's illegal to call CTitleId(uint) from the
        // body of CTitleId(string)
        private void CtorHelper(uint uiTitleId)
        {
            _uiTitleId = uiTitleId;
            _sTitleIdHexNoPrefix = String.Format("{0,8:X8}", uiTitleId);
        }

        /// <summary>
        /// Gets the title id represented by this object as a 32 bit unsigned integer value
        /// </summary>
        public uint uiTitleId
        {
            get
            {
                return _uiTitleId;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// that contains the title id in hex format, e.g. "0x1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public string sTitleIdHex
        {
            get
            {
                return "0x" + _sTitleIdHexNoPrefix;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// the contains the title id in hex format, but with no hex prefix
        /// e.g. "1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public string sTitleIdHexNoPrefix
        {
            get
            {
                return _sTitleIdHexNoPrefix;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// the contains the title id in decimal format e.g. "305441741"
        /// (equvalient to a hex value of 0x1234ABCD).
        /// No leading zeros will be prepended
        /// </summary>
        public string sTitleIdDecimal
        {
            get
            {
                return _uiTitleId.ToString("d");
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// that contains the title id in hex format, e.g. "0x1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public override string ToString()
        {
            return sTitleIdHex;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\LtcXml.cs ===
using System;
using System.Xml;
using System.Reflection;
using System.IO;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.STFTools;

namespace LiveMatchTest
{
    public struct RoundRobinNode
    {
        public byte Type;
        public byte Mode;
        public string ServerName;

        public RoundRobinNode(byte type, byte mode, string serverName)
        {
            Type = type;
            Mode = mode;
            ServerName = serverName;
        }
    }

    public class LtcXml
    {
        private string m_OriginalTitleConfigFile;

        public LtcXml(uint titleId)
        {
            m_OriginalTitleConfigFile = titleId.ToString("X08") + "_LTC.original.xml";
        }

        /// <summary>
        /// Saves the original LTC XML from the service.  If an original already exists,
        /// it will not be overwritten.
        /// </summary>
        public void SaveOriginalToCache()
        {
            if (!File.Exists(m_OriginalTitleConfigFile))
            {
                Global.RO.Info("Saving original LTC XML to {0}", m_OriginalTitleConfigFile);

                string currentLtcXml = GetCurrentFromService();

                StreamWriter sw = new StreamWriter(m_OriginalTitleConfigFile);
                sw.Write(currentLtcXml);
                sw.Close();
            }
        }

        /// <summary>
        /// Restores the original LTC XML if it has changed
        /// </summary>
        /// <returns>True if data was written, false if it was unnecessary</returns>
        public bool RestoreOriginalToService()
        {
            string originalXml = GetOriginalFromCache();
            string currentXml = GetCurrentFromService();

            if (originalXml != currentXml)
            {
                Global.RO.Info("LTC XML has changed, restoring original data");
                WriteToService(originalXml);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the current LTC XML for the test title ID
        /// </summary>
        /// <returns>XML contents</returns>
        private string GetCurrentFromService()
        {
            LiveTitleConfigRow liveTitleConfigRow;

            using (NpdbUtility npdb = new NpdbUtility())
            {
                npdb.ConnectToServer();
                liveTitleConfigRow = npdb.GetLiveTitleConfig(LiveMatchTestConfig.TitleID);
                npdb.Close();
            }

            return liveTitleConfigRow.XmlTitleConfig;
        }

        /// <summary>
        /// Returns the contents of the original LTC XML configuration
        /// </summary>
        /// <returns>Original LTC XML contents</returns>
        protected string GetOriginalFromCache()
        {
            StreamReader sr = new StreamReader(m_OriginalTitleConfigFile);
            string originalXml = sr.ReadToEnd();
            sr.Close();

            return originalXml;
        }

        /// <summary>
        /// Overwrites the LTC XML on the service with the given XML contents
        /// </summary>
        /// <param name="ltcXml">New LTC XML contents</param>
        private void WriteToService(string ltcXml)
        {
            Global.RO.Info("Writing LTC XML to service ({0} characters)", ltcXml.Length);

            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                npdb.IssueCommand(
                    String.Format("UPDATE t_live_title_config SET xml_title_config = '{0}' WHERE i_title_id = 0x{1:X08}", ltcXml, LiveMatchTestConfig.TitleID)
                );
                npdb.Close();
            }
        }

        /// <summary>
        /// Writes the original LTC XML with additional round robin buckets
        /// </summary>
        /// <param name="rrNodes">Round robin bucket metadata</param>
        public void WriteOriginalWithAdditionalRoundRobin(RoundRobinNode[] rrNodes)
        {
            string ltcXml = GetOriginalFromCache();

            foreach (RoundRobinNode rrNode in rrNodes)
            {
                ltcXml = InsertRoundRobinNode(ltcXml, rrNode);
            }

            WriteToService(ltcXml);
        }

        /// <summary>
        /// Inserts a round robin node entry into an existing LTC XML document.
        /// </summary>
        /// <param name="ltcXml">XML document as a string</param>
        /// <param name="rrNode">Round robin node metadata</param>
        /// <returns>Modified XML document</returns>
        private string InsertRoundRobinNode(string ltcXml, RoundRobinNode rrNode)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(ltcXml);

            // Alias the namespace for LiveTitleConfig
            XmlNamespaceManager xmlNSM = new XmlNamespaceManager(xmlDoc.NameTable);
            xmlNSM.AddNamespace("LTC", "http://www.xboxlive.com/livetitleconfig");

            // Select the appropriate type/mode parent element
            XmlNode nodeParent = xmlDoc.SelectSingleNode(
                String.Format("//LTC:MatchPartitions/LTC:GameType[@typeid={0}]/LTC:GameMode[@modeid={1}]", rrNode.Type, rrNode.Mode),
                xmlNSM
                );

            if (nodeParent == null)
            {
                throw new XmlException(
                    String.Format("Could not find XML entry for type {0} and mode {1}", rrNode.Type, rrNode.Mode)
                    );
            }

            // Create the element we want to insert
            // <RRServer servername="<serverName>" />
            XmlElement newElement = xmlDoc.CreateElement("RRServer");
            XmlAttribute attrServerName = xmlDoc.CreateAttribute("servername");
            attrServerName.Value = rrNode.ServerName.ToLower();
            newElement.Attributes.Append(attrServerName);

            // Insert the element
            nodeParent.AppendChild(newElement);

            // Return the new XML
            return xmlDoc.OuterXml;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\MatchMigrationTestBase.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;

namespace LiveMatchTest
{
    /// <summary>
    /// Base class for migration test cases
    /// </summary>
    abstract public class MatchMigrationTestBase : MatchTestBase
    {
        private List<int> m_DirtyBucketIds = new List<int>();

        public override void PreRun(RUN_TYPE runType)
        {
            base.PreRun(runType);

            // Ensure at least two match servers are available in our environment
            if (String.IsNullOrEmpty(LiveMatchTestConfig.MatchTestServer2))
            {
                throw new Exception("Two match servers are required for migration tests");
            }

            m_DirtyBucketIds.Clear();
        }

        public override void PostRun()
        {
            // Reset all buckets that the test marked as potentially dirty
            foreach (int bucketId in m_DirtyBucketIds)
            {
                int rrid = (bucketId & 0xFF);
                int mode = (bucketId >> 8) & 0xFF;
                int type = (bucketId >> 16) & 0xFF;

                ResetMigrationForBucket(type, mode, rrid);
            }

            // Remove all matchmaking sessions on both servers
            ResetMatchSessions(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.MatchTestServer1);

            if (!String.IsNullOrEmpty(LiveMatchTestConfig.MatchTestServer2))
            {
                ResetMatchSessions(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.MatchTestServer2);
            }

            ResetMigrationForTitle();
            base.PostRun();
        }

        /// <summary>
        /// Marks a bucket ID as dirty, meaning that the test will probably touch it and it
        /// needs to be reset at the end of the test case
        /// </summary>
        /// <param name="type">Bucket Type</param>
        /// <param name="mode">Bucket Mode</param>
        /// <param name="rrid">Bucket Round Robin ID</param>
        protected void MarkBucketAsDirty(int type, int mode, int rrid)
        {
            int bucketId = ConvertToBucketId(type, mode, rrid);

            if (!m_DirtyBucketIds.Contains(bucketId))
            {
                m_DirtyBucketIds.Add(bucketId);
            }
        }

        /// <summary>
        /// Resets the XMatch sessions created
        /// </summary>
        protected void ResetMatchSessions(uint titleid, string server)
        {
            StringBuilder sqlTextStandard = new StringBuilder();
            StringBuilder sqlTextRanked = new StringBuilder();

            m_MatchDB.Close();
            m_MatchDB.ConnectToServer(server);

            foreach (string tableType in new string[] { "standard", "ranked" })
            {
                string tableName = String.Format("t_match_sessions_0x{0:x}_{1}", titleid, tableType);
                string sqlCmd = String.Format("IF OBJECT_ID (N'{0}', N'U') IS NOT NULL DELETE FROM {0}", tableName);
                m_MatchDB.IssueCommand(sqlCmd);
            }
        }

        /// <summary>
        /// Resets the Migration back to the state prior to starting migration
        /// Updates the SQL table t_interface_buckets manually
        /// </summary>
        protected void ResetMigrationForBucket(int type, int mode, int rrid)
        {
            StringBuilder sqlText = new StringBuilder();
            int iBucket = 0;

            iBucket = ConvertToBucketId(type, mode, rrid);

            sqlText.Append("update t_interface_buckets set vc_next_server = vc_server, dt_migration_start='1900-01-01 12:00:00.000'");
            sqlText.AppendFormat(" where vc_environment='{0}'", Global.CurrentEnvironment.Environment);
            sqlText.AppendFormat(" and i_title_id=0x{0:x}", LiveMatchTestConfig.TitleID);
            sqlText.AppendFormat(" and i_bucket={0} and vc_interface='xmatch'", iBucket);
            ExecuteNpdbCommand(sqlText.ToString());
        }

        /// <summary>
        /// Resets the Migration back to the state prior to starting migration
        /// Updates the SQL table t_interface_buckets manually
        /// </summary>
        protected void ResetMigrationForTitle()
        {
            StringBuilder sqlText = new StringBuilder();

            sqlText.Append("update t_interface_buckets set vc_next_server = vc_server, dt_migration_start='1900-01-01 12:00:00.000'");
            sqlText.AppendFormat(" where vc_environment='{0}'", Global.CurrentEnvironment.Environment);
            sqlText.AppendFormat(" and i_title_id=0x{0:x}", LiveMatchTestConfig.TitleID);
            sqlText.AppendFormat(" and vc_interface='xmatch'");
            ExecuteNpdbCommand(sqlText.ToString());
        }

        /// <summary>
        /// Sets the Migration start time to now so Expedite can be run
        /// Updates the SQL table t_interface_buckets manually
        /// </summary>
        protected void UpdateMigrationBucketStartTime(int type, int mode, int rrid)
        {
            StringBuilder sqlText = new StringBuilder();
            int iBucket = 0;

            iBucket = ConvertToBucketId(type, mode, rrid);

            sqlText.Append("update t_interface_buckets set dt_migration_start=getutcdate()");
            sqlText.AppendFormat(" where vc_environment='{0}'", Global.CurrentEnvironment.Environment);
            sqlText.AppendFormat(" and i_title_id=0x{0:x}", LiveMatchTestConfig.TitleID);
            sqlText.AppendFormat(" and i_bucket={0} and vc_interface='xmatch'", iBucket);
            ExecuteNpdbCommand(sqlText.ToString());
        }

        /// <summary>
        /// Sets the Migration start time to now so Expedite can be run
        /// Updates the SQL table t_interface_buckets manually
        /// </summary>
        protected void UpdateMigrationTitleStartTime()
        {
            StringBuilder sqlText = new StringBuilder();

            sqlText.Append("update t_interface_buckets set dt_migration_start=getutcdate()");
            sqlText.AppendFormat(" where vc_environment='{0}'", Global.CurrentEnvironment.Environment);
            sqlText.AppendFormat(" and i_title_id=0x{0:x}", LiveMatchTestConfig.TitleID);
            sqlText.AppendFormat(" and vc_interface='xmatch'");
            ExecuteNpdbCommand(sqlText.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveContentTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livecontenttest_none_12.4.56.0_none_6598c0d7c6ac49a4
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livecontenttest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.manifest
XP_MANIFEST_PATH=manifests\msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.cat
XP_CATALOG_PATH=manifests\msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82.cat
XP_PAYLOAD_PATH=msil_livecontenttest_no-public-key_12.4.56.0_x-ww_102a1e82
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livecontenttest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\LiveMatchTestConfig.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

namespace LiveMatchTest
{
    public class LiveMatchTestConfig
    {
        public static string BadServerName { get; private set; }
        public static string InputFilePath { get; private set; }
        public static string MatchTestServer1 { get; private set; }
        public static string MatchTestServer2 { get; private set; }
        public static string[] ServerNames { get; private set; }
        public static uint TitleID { get; private set; }
        public static string ToolPath { get; private set; }
        public static uint XboxTitleID { get; private set; }

        private static bool isConfigLoaded = false;

        /// <summary>
        /// Reads an XML node from the Live Match STF configuration
        /// </summary>
        /// <param name="nodeName">Node name</param>
        /// <param name="isRequired">True if the node must exist, false otherwise</param>
        /// <returns>String value if the node was found, null otherwise</returns>
        private static string ReadNode(string nodeName, bool isRequired)
        {
            XmlNode baseNode = Global.Config.SelectSingleNode("descendant::LiveMatchTest");

            if (baseNode == null)
            {
                throw new Exception("LiveMatchTest configuration not found!");
            }

            XmlNode node = baseNode.SelectSingleNode(nodeName);

            if (isRequired && node == null)
            {
                throw new XmlException("Required configuration node \"" + nodeName + "\" was not found!");
            }

            return node == null ? null : node.InnerText;
        }

        /// <summary>
        /// Reads the Live Match STF configuration into this static class
        /// </summary>
        public static void ReadConfig()
        {
            if (isConfigLoaded)
                return;

            string toolPath = ReadNode("DefaultToolPath", true);
            ToolPath = Path.Combine(toolPath, "LiveMatch.exe");

            InputFilePath = ReadNode("InputFilePath", true);

            string titleIdString = ReadNode("TitleID", true);
            CTitleId titleId = new CTitleId(titleIdString);
            TitleID = titleId.uiTitleId;

            string xboxTitleIdString = ReadNode("XboxTitleID", true);
            CTitleId xboxTitleId = new CTitleId(xboxTitleIdString);
            XboxTitleID = xboxTitleId.uiTitleId;

            BadServerName = ReadNode("BadServerName", false);
            if (String.IsNullOrEmpty(BadServerName))
            {
                BadServerName = "XXXXXXXXX";
            }

            MatchTestServer1 = ReadNode("MatchTestServer", false);
            MatchTestServer2 = ReadNode("MatchTestServer2", false);

            // If both names are empty, grab the servers from NPDB
            if (String.IsNullOrEmpty(MatchTestServer1) && String.IsNullOrEmpty(MatchTestServer2))
            {
                Global.RO.Info("Getting Matchmaking server names from NPDB");

                ServerNames = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.xmatch);

                if (ServerNames.Length > 0)
                {
                    MatchTestServer1 = ServerNames[0];
                }
                else
                {
                    throw new Exception("No servers found in configuration XML or NPDB");
                }

                if (ServerNames.Length > 1)
                {
                    MatchTestServer2 = ServerNames[1];
                    Global.RO.Info("Using servers {0} and {1}", MatchTestServer1, MatchTestServer2);
                }
                else
                {
                    Global.RO.Warn("Only one server detected({0}).  Migration scenarios will fail.", MatchTestServer1);
                }
            }
            else
            {
                ServerNames = new string[] { MatchTestServer1, MatchTestServer2 };
            }

            isConfigLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\PositiveTests.cs ===
using System;
using System.IO;
using ServerTestFramework;
using xonline.common.config;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Matchmaking;
using STFDB = ServerTestFramework.Database;
namespace LiveMatchTest
{
    /// <summary>
    /// LiveMatch Positive Test cases for title deployment
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class PositiveDeploymentTests : TestNode
    {
        [TestCase, DVT, TestFrequency("BVT"), TestCasePriority(1)]
        class TitleIDCase : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                // setup checking of log for front doors...
                string[] servers = Config.GetServerListByInterface(Interface.xmatchfd_int);
                Events change = new Events(servers);
                change.Source = "xmatchfd";
                change.Init();

                m_MatchTool.DeployMatchServer(LiveMatchTestConfig.TitleID, false, false, false, null);

                VerifyAll();

                Global.RO.Info("Databases verified, checking strings");
                // Check output to make sure that front doors got reloaded by checking strings...
                if (m_MatchTool.StandardOutput.IndexOf("HealthCheck") > 0 &&
                    m_MatchTool.StandardOutput.IndexOf("Sending reloadtitleinfo command") > 0)
                {
                    //verify config log changed...
                    if (!change.TestForChange("reloadtitleinfo"))
                    {
                        throw new UnexpectedTestResultException("Could not verify 'reloadtitleinfo'");
                    }
                }
                else
                {
                    throw new UnexpectedTestResultException("Could not find reset of front doors");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class TitleIDDropTable : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.DeployMatchServer(LiveMatchTestConfig.TitleID, true, false, false, null);

                VerifyAll();
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class NoReload : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.NoReloadFrontDoors = true;
                // Set up checking event log for front door...
                string[] servers = Config.GetServerListByInterface(Interface.xmatchfd_int);
                Events change = new Events(servers);
                change.Source = "xmatchfd";
                change.Init();

                m_MatchTool.DeployMatchServer(LiveMatchTestConfig.TitleID, false, false, false, null);

                VerifyAll();

                // Check output to make sure that front doors did not reload by checking strings...
                if (m_MatchTool.StandardOutput.Contains("Sending health check XRL to all xmatchfd servers") ||
                    m_MatchTool.StandardOutput.Contains("Sending reloadtitleinfo xmgmt command to all xmatchfd servers"))
                {
                    throw new UnexpectedTestResultException("Found reset of front doors.");
                }
            }
        }

        [TestCase]
        class ScriptCase : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.ScriptFile = String.Format("{0:x}.sql", LiveMatchTestConfig.TitleID);
                m_MatchTool.DeployMatchServer(LiveMatchTestConfig.TitleID, false, true, false, null);

                // No matches should be created.
                if (VerifyAll(false))
                {
                    throw new UnexpectedTestResultException("No matches should have been created");
                }
            }
        }
    }

    /// <summary>
    /// LiveMatch Positive Test cases for Bucket Migration
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class PositiveMigrationBucketTests : TestNode
    {
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class StartMigrationBucket : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;
                m_MatchTool.RRID = 0;

                MarkBucketAsDirty(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed startmigrationforbucket"))
                {
                    throw new UnexpectedTestResultException("startmigrationforbucket was not successfully executed");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class ExpediteMigrationBucket : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;
                m_MatchTool.RRID = 0;

                MarkBucketAsDirty(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                MatchSession matchSess = new MatchSession(false);

                for (int i = 0; i < 5; i++)
                    matchSess = MatchPartUtil.CreateGenericSession("LiveMatchSession", (long)m_MatchTool.TypeID, (long)m_MatchTool.ModeID, LiveMatchTestConfig.TitleID);

                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                // Update the migration start time in t_interface_buckets so we can expedite the migration
                UpdateMigrationBucketStartTime(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 2, null);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed expeditemigrationforbucket"))
                {
                    throw new UnexpectedTestResultException("expeditemigrationforbucket was not successfully executed");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class MigrationStatusBucket : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;
                m_MatchTool.RRID = 0;
                int secondModeID = 2;

                MarkBucketAsDirty(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                MatchSession matchSess = new MatchSession(false);

                for (int i=0; i<5; i++)
                    matchSess = MatchPartUtil.CreateGenericSession("LiveMatchSession", (long)m_MatchTool.TypeID, (long)m_MatchTool.ModeID, LiveMatchTestConfig.TitleID);

                matchSess.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(secondModeID)));

                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                // Check the migration status now
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 1, null);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed migrationstatusforbucket"))
                {
                    throw new UnexpectedTestResultException("migrationstatusforbucket was not successfully executed");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class EndMigrationBucket : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;
                m_MatchTool.RRID = 0;

                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                // Run Endmigration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 3, null);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed endmigrationforbucket"))
                {
                    throw new UnexpectedTestResultException("endmigrationforbucket was not successfully executed");
                }

                // Now return the bucket to the prior state by calling startmigration  and then endmigration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1);
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 3, null);
            }
        }
    }

    /// <summary>
    /// LiveMatch Positive Test cases for Title Migration
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class PositiveMigrationTitleTests : TestNode
    {
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class StartMigrationTitle : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed startmigrationfortitle"))
                {
                    throw new UnexpectedTestResultException("startmigrationfortitle was not executed successfully");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class ExpediteMigrationTitle : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;  //Standard
                m_MatchTool.ModeID = 1;
                int secondModeID = 2;

                MatchSession matchSess = new MatchSession(false);

                for (int i = 0; i < 50; i++)
                {
                    matchSess = MatchPartUtil.CreateGenericSession("LiveMatchSession", (long)m_MatchTool.TypeID, (long)m_MatchTool.ModeID, LiveMatchTestConfig.TitleID);

                    if (i % 3 == 0)
                        matchSess.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(secondModeID)));
                }

                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1 ,LiveMatchTestConfig.MatchTestServer2);

                // Update the migration start time in t_interface_buckets so we can expedite the migration
                UpdateMigrationTitleStartTime();

                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 2, LiveMatchTestConfig.MatchTestServer1, null);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed expeditemigrationfortitle"))
                {
                    throw new UnexpectedTestResultException("expeditemigrationfortitle was not executed successfully");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class MigrationStatusTitle : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;
                int secondModeID = 2;

                MatchSession matchSess = new MatchSession(false);

                for (int i = 0; i < 50; i++)
                {
                    matchSess = MatchPartUtil.CreateGenericSession("LiveMatchSession", (long)m_MatchTool.TypeID, (long)m_MatchTool.ModeID, LiveMatchTestConfig.TitleID);
                    if (i % 3 == 0)
                        matchSess.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(secondModeID)));
                }

                // Start Migration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);

                // Check the migration status now
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 1, LiveMatchTestConfig.MatchTestServer1, null);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed migrationstatusfortitle"))
                {
                    throw new UnexpectedTestResultException("migrationstatusfortitle was not executed successfully");
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class EndMigrationTitle : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;
                int secondModeID = 2;


                MatchSession matchSess = new MatchSession(false);

                for (int i = 0; i < 50; i++)
                {
                    matchSess = MatchPartUtil.CreateGenericSession("LiveMatchSession", (long)m_MatchTool.TypeID, (long)m_MatchTool.ModeID, LiveMatchTestConfig.TitleID);
                    if (i % 3 == 0)
                        matchSess.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(secondModeID)));
                }

                //Start Migration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);

                // Run Endmigration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 3, LiveMatchTestConfig.MatchTestServer1, null);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed endmigrationfortitle"))
                {
                    throw new UnexpectedTestResultException("endmigrationfortitle was not executed successfully");
                }

                // Now return the bucket to the prior state by calling startmigration  and then endmigration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2, LiveMatchTestConfig.MatchTestServer1);
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 3, LiveMatchTestConfig.MatchTestServer2, null);
            }
        }
    }

    /// <summary>
    /// LiveMatch Positive Test cases for AddRRBucket option
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class PositiveAddRRBucketTests : TestNode
    {
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class AddRRBucket : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;

                //the title *must* be 0xfffe07e3, the title which we can reset buckets for.
                m_MatchTool.MatchAddRRBucket(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.MatchTestServer2);

                if (!m_MatchTool.StandardOutput.Contains("Succesfully Executed addrrbucket"))
                {
                    throw new UnexpectedTestResultException("addrrbucket was not executed successfully");
                }
            }
        }

        [TestCase]
        class AddRRBucketWhenDraining : MatchMigrationTestBase
        {

            //expected behavior is to set the least draining bucket to not-draining, and then add the rrbucket.
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                const int TYPE = 0;
                const int MODE = 2;
                m_MatchTool.TypeID = TYPE;
                m_MatchTool.ModeID = MODE;

                STFDB.InterfaceBucketCollection bucketsExpected = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                for (int i=0; i<3; i++) {
                    //let's drain 3 buckets.
                    Global.RO.Info("Executing drain number " + (i+1) + "...");
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                    PerformActionOnBuckets(RoundRobinAction.DRAIN, false, bucketsExpected);

                    Global.RO.Info("Verifying drain number " + (i+1) + "...");
                    STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);
                    CompareBucketCollections(bucketsExpected, bucketsActual);
                    Global.RO.Success("Drain number " + (i+1) + " successful.");
                }

                //Begin undraining, verifying as we go.  The title *must* be 0xfffe07e3, the title
                //which we can reset buckets for.  We'll add 4, meaning the fourth one is a real
                //addrrbucket that doesn't "un-drain".
                for (int i=0; i<4; i++) {
                    Global.RO.Info("Executing addrrbucket number " + (i+1) + "...");
                    m_MatchTool.MatchAddRRBucket(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.MatchTestServer2);
                    PerformActionOnBuckets(RoundRobinAction.ADD, false, bucketsExpected, LiveMatchTestConfig.MatchTestServer2);

                    Global.RO.Info("Verifying addrrbucket number " + (i+1) + "...");
                    STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);
                    CompareBucketCollections(bucketsExpected, bucketsActual);
                    Global.RO.Success("addrrbucket number " + (i+1) + " successful.");
                }
            }
        }

    }


    /// <summary>
    /// LiveMatch Positive Test cases for DrainRRBucket option
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class PositiveDrainRRBucketTests : TestNode
    {
        //drain one bucket off a set of two.  Reprop afterwards.
        [TestCase]
        class Mainline : RoundRobinTestBase
        {
            protected override void Execute()
            {
                const int TYPE = 0;
                const int MODE = 0;
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = TYPE;
                m_MatchTool.ModeID = MODE;

                STFDB.InterfaceBucketCollection bucketsExpected = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                if ((CountDrainingBuckets(bucketsExpected)) > 0) {
                    throw new UnexpectedTestResultException(
                        "Error, a draining bucket was found beforehand.  This is unexpected.  Repropping title; Please rerun test afterwards."
                    );
                }

                m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                PerformActionOnBuckets(RoundRobinAction.DRAIN, false, bucketsExpected);

                STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                CompareBucketCollections(bucketsExpected, bucketsActual);
            }
        }

        //drain two buckets off a set of five.  Reprop afterwards.
        [TestCase]
        class Drain_Two_In_A_Row : RoundRobinTestBase
        {
            protected override void Execute()
            {
                const int TYPE = 0;
                const int MODE = 2;
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = TYPE;
                m_MatchTool.ModeID = MODE;

                STFDB.InterfaceBucketCollection bucketsExpected = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                for (int i=0; i<2; i++) {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                    PerformActionOnBuckets(RoundRobinAction.DRAIN, false, bucketsExpected);

                    STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                    CompareBucketCollections(bucketsExpected, bucketsActual);
                }
            }
        }
        //drain four buckets off a set of five.  Reprop afterwards.
        [TestCase]
        class Drain_Four_In_A_Row : RoundRobinTestBase
        {
            protected override void Execute()
            {
                const int TYPE = 0;
                const int MODE = 2;
                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = TYPE;
                m_MatchTool.ModeID = MODE;

                STFDB.InterfaceBucketCollection bucketsExpected = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                for (int i=0; i<4; i++) {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                    PerformActionOnBuckets(RoundRobinAction.DRAIN, false, bucketsExpected);

                    STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                    CompareBucketCollections(bucketsExpected, bucketsActual);
                }
            }
        }

    }

    /// <summary>
    /// LiveMatch Positive Test cases for RemoveRRBucket option
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class PositiveRemoveRRBucketTests : TestNode
    {
        //Remove the top RR Bucket after draining it.
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        class Mainline : RoundRobinTestBase
        {
            protected override void Execute()
            {
                const int TYPE = 0;
                const int MODE = 2;

                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = TYPE;
                m_MatchTool.ModeID = MODE;

                STFDB.InterfaceBucketCollection bucketsExpected = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                PerformActionOnBuckets(RoundRobinAction.DRAIN, false, bucketsExpected);
                m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                PerformActionOnBuckets(RoundRobinAction.REMOVE, false, bucketsExpected);

                STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                CompareBucketCollections(bucketsExpected, bucketsActual);
            }
        }

        //Remove the top RR Bucket before draining it, by using the /force command.
        [TestCase]
        class RemoveViaForce : RoundRobinTestBase
        {
            protected override void Execute()
            {
                const int TYPE = 0;
                const int MODE = 2;

                ResultCode = TEST_RESULTS.PASSED;

                m_MatchTool.TypeID = TYPE;
                m_MatchTool.ModeID = MODE;
                STFDB.InterfaceBucketCollection bucketsExpected = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, true);
                PerformActionOnBuckets(RoundRobinAction.REMOVE, true, bucketsExpected);

                STFDB.InterfaceBucketCollection bucketsActual = MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, TYPE, MODE);

                CompareBucketCollections(bucketsExpected, bucketsActual);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\NegativeTests.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.STFTools;

namespace LiveMatchTest
{
    public class ErrorStrings {
        public static string BadServerErrorString(string serverName) {
            return "Error: Bad server name: '" + serverName + "'";
        }
    }

    /// <summary>
    /// Live Match Negative Test Cases for deployment
    ///
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class NegativeDeploymentTests : TestNode
    {
        [TestCase]
        class NonImportedTitleID : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.DeployMatchServer(0xFFFFAB17, false, false, false, null);
                }
                catch(LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Unable to find live title configuration for title id 0xFFFFAB17 in NPDB", false);
                }
            }
        }

        [TestCase]
        class NoTitleID : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.RunLiveMatch("/deploymatch /titleid"); // change this when bug about not needing /deploymatch is fixed
                }
                catch(LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing deploymatch", false);
                }
            }
        }

        [TestCase]
        class InvalidTitleID : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.RunLiveMatch("/deploymatch /titleid:FFFFFFFFF");  // change this when bug about not needing /deploymatch is fixed
                }
                catch(LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Invalid title id '0xFFFFFFFFF'", false);
                }
            }
        }

        [TestCase]
        class DropTableNoID : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.RunLiveMatch("/deploymatch /droptable"); // change this when bug about not needing /deploymatch is fixed
                }
                catch(LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing deploymatch", false);
                }
            }
        }
    }

    /// <summary>
    /// Live Match Negative Test Cases for bucket migration
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class NegativeMigrationBucketTests : TestNode
    {
        [TestCase]
        class StartMigrationBucketNoType : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing startmigrationforbucket", false);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketNoMode : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.RRID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing startmigrationforbucket", false);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketNoRRID : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing startmigrationforbucket", false);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketNoDest : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, "");
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing startmigrationforbucket", false);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketBadType : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 4; // only 0 and 1 are currently valid, but 3 is possible in the future
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.StartMigrationForBucket]: Failed to start migration.  Bucket may be invalid.", true);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketBadMode : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 65;  //Can only be up to 63 modes I believe.
                m_MatchTool.RRID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.StartMigrationForBucket]: Failed to start migration.  Bucket may be invalid.", true);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketBadRRID : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 10;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.StartMigrationForBucket]: Failed to start migration.  Bucket may be invalid.", true);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketBadDest : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                try
                {
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.BadServerName);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, ErrorStrings.BadServerErrorString(LiveMatchTestConfig.BadServerName), false);
                }
            }
        }

        [TestCase]
        class StartMigrationBucketMigrationAlreadyStarted : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                MarkBucketAsDirty(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                // Start a migration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                try
                {
                    // Try to start migration before start has become official
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(
                        e,
                        "[MatchAdmin.ConfigureMatch]: Server name in LTC is out of sync with one of the server names in t_interface_buckets, for bucket ID 0.  " +
                        "This is probably due to the bucket being in migration, in which case migration should be completed before deploying.",
                        true
                        );
                }
            }
        }

        [TestCase]
        class StartMigrationBucketBucketIsDraining : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                MarkBucketAsDirty(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                //drain the top RR bucket.
                m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);

                try
                {
                    //try to migrate.
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.ConfigureMatch]: Server name in LTC is out of sync with " +
                                                "one of the server names in t_interface_buckets, for bucket ID 0.  This is probably due " +
                                                "to the bucket being in migration, in which case migration should be completed before deploying.", true);
                }
            }
        }


        [TestCase]
        class ExpediteMigrationBucketMigrationNotStarted : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                MarkBucketAsDirty(m_MatchTool.TypeID, m_MatchTool.ModeID, m_MatchTool.RRID);

                // Start a migration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                try
                {
                    // Try to expedite migration before start has become official
                    m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 2, null);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(
                        e,
                        "[MatchAdmin.ExpediteMigration]: Failed expedite -- you can't expedite a bucket that's not set for migration, or for which the migration has not yet started.",
                        true
                        );
                }
            }
        }
    }

    /// <summary>
    /// Live Match Negative Test Cases for title migration
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class NegativeMigrationTitleTests : TestNode
    {
        [TestCase]
        class StartMigrationTitleNoSource : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, null, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing startmigrationfortitle", false);
                }
            }
        }

        [TestCase]
        class StartMigrationTitleNoDest : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, null);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Missing Parameters for executing startmigrationfortitle", false);
                }
            }
        }


        [TestCase]
        class StartMigrationTitleBadDest : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                try
                {
                    m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.BadServerName);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, ErrorStrings.BadServerErrorString(LiveMatchTestConfig.BadServerName), false);
                }
            }
        }

        [TestCase]
        class StartMigrationTitleMigrationAlreadyStarted : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                // Start a migration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);

                try
                {
                    // Try to start migration before start has become official
                    m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.ConfigureMatch]: Server name in LTC is out of sync with " +
                                                "one of the server names in t_interface_buckets, for bucket ID 0.  This is probably due " +
                                                "to the bucket being in migration, in which case migration should be completed before deploying.", true);
                }
            }
        }

        [TestCase]
        class ExpediteMigrationTitleMigrationNotStarted : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);

                // Start a migration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);

                try
                {
                    // Try to expedite migration before start has become official
                    m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 2, LiveMatchTestConfig.MatchTestServer1, null);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(
                        e,
                        "[MatchAdmin.ExpediteMigration]: Failed expedite -- you can't expedite a bucket that's not set for migration, or for which the migration has not yet started.",
                        true
                        );
                }
            }
        }
    }
    /// <summary>
    /// Live Match Negative Test Cases for adding RRBuckets.
    /// </summary>
    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class NegativeAddRRBucketTests : TestNode
    {
        [TestCase]
        class AddRRBucketBadType : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 4;
                m_MatchTool.ModeID = 0;

                try
                {
                    m_MatchTool.MatchAddRRBucket(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.AddRRServer]: No existing buckets found with the type/mode you specified.  No RR server can be added.", false);
                }
            }
        }

        [TestCase]
        class AddRRBucketBadMode : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 10;

                try
                {
                    m_MatchTool.MatchAddRRBucket(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.MatchTestServer2);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "[MatchAdmin.AddRRServer]: No existing buckets found with the type/mode you specified.  No RR server can be added.", false);
                }
            }
        }

        [TestCase]
        class AddRRBucketBadServer : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;

                try
                {
                    m_MatchTool.MatchAddRRBucket(LiveMatchTestConfig.TitleID, LiveMatchTestConfig.BadServerName);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, ErrorStrings.BadServerErrorString(LiveMatchTestConfig.BadServerName), false);
                }
            }
        }
    }


    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class NegativeDrainTopRRBucketTests : TestNode
    {
        [TestCase]
        class DrainTopRRBucketBadType : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 4;
                m_MatchTool.ModeID = 0;

                try
                {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "No non-draining buckets found for the type/mode you specified.  No buckets can be drained.", false);
                }
            }
        }

        [TestCase]
        class DrainTopRRBucketBadMode : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 27;

                try
                {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "No non-draining buckets found for the type/mode you specified.  No buckets can be drained.", false);
                }
            }
        }

        [TestCase]
        class DrainTopRRBucketOnlyOneLeft : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 1;

                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Only one bucket exists for the type/mode you specified, and it can not be drained.", false);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }

        [TestCase]
        class DrainTopRRBucketInMigration : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;

                // Start Migration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "A migration for this title is in process.  No buckets can be drained.", true);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }

        [TestCase]
        class DrainTopRRBucketDiffModeInMigration : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;
                m_MatchTool.RRID = 0;
                // Start Migration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                //try to drain a different mode
                m_MatchTool.ModeID = 2;
                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchDrainTopRRBucket(LiveMatchTestConfig.TitleID);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "A migration for this title is in process.  No buckets can be drained.", true);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }
    }


    [TestGroup, Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class NegativeRemoveTopRRBucketTests : TestNode
    {
        [TestCase]
        class RemoveTopRRBucketBadType : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 4;
                m_MatchTool.ModeID = 0;

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "No buckets found for the type/mode you specified.", false);
                }
            }
        }

        [TestCase]
        class RemoveTopRRBucketBadMode : MatchTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 27;

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "No buckets found for the type/mode you specified.", false);
                }
            }
        }


        [TestCase]
        class RemoveTopRRBucket_WhenNotDrainingAndNoForceFlag : RoundRobinTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 2;

                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "The top bucket is not marked for draining.  To remove it, you must specify the 'force' flag.", false);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint)m_MatchTool.TypeID, (uint)m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }

        [TestCase]
        class RemoveTopRRBucket_DuringMigration : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 0;

                // Start Migration
                m_MatchTool.MatchMigrationTitle(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer1, LiveMatchTestConfig.MatchTestServer2);

                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "A migration for this title is in process.  No buckets can be removed.", true);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }

        [TestCase]
        class RemoveTopRRBucket_DuringMigrationOnDiffMode : MatchMigrationTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 2;
                m_MatchTool.RRID = 0;
                // Start Migration
                m_MatchTool.MatchMigrationBucket(LiveMatchTestConfig.TitleID, 0, LiveMatchTestConfig.MatchTestServer2);

                //set to a different mode.
                m_MatchTool.ModeID = 0;

                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "A migration for this title is in process.  No buckets can be removed.", true);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }

        [TestCase]
        class RemoveTopRRBucket_RemoveLastBucket : RoundRobinTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 0;
                m_MatchTool.ModeID = 1;

                InterfaceBucketCollection bucketsBefore =
                    MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, false);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Only one bucket exists for the type/mode you specified, and it can not be removed.", false);

                    InterfaceBucketCollection bucketsAfter =
                            MatchUtil.GetMatchBucketsForModeAndType(LiveMatchTestConfig.TitleID, (uint) m_MatchTool.TypeID, (uint) m_MatchTool.ModeID);

                    CompareBucketCollections(bucketsBefore, bucketsAfter);
                }
            }
        }


        [TestCase]
        class RemoveTopRRBucket_RemoveLastViaForce : RoundRobinTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                MatchClearAllDB(LiveMatchTestConfig.TitleID);
                m_MatchTool.TypeID = 1;
                m_MatchTool.ModeID = 1;

                try
                {
                    m_MatchTool.MatchRemoveTopRRBucket(LiveMatchTestConfig.TitleID, true);
                }
                catch (LiveMatchException e)
                {
                    VerifyExpectedToolError(e, "Only one bucket exists for the type/mode you specified, and it can not be removed.", false);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\RoundRobinTestBase.cs ===
using System;
using ServerTestFramework;

namespace LiveMatchTest
{
    /// <summary>
    /// Base class for round robin bucket tests.  All such tests require multiple buckets on the service,
    /// so this base class ensures that a customized LTC XML is present and deployed.
    /// </summary>
    abstract public class RoundRobinTestBase : MatchTestBase
    {
        public override void PreRun(RUN_TYPE runType)
        {
            base.PreRun(runType);
            UploadRoundRobinConfiguration();
        }

        public override void PostRun()
        {
            if (m_LtcXml.RestoreOriginalToService())
            {
                m_MatchTool.RunLiveMatch("/titleid:0x" + LiveMatchTestConfig.TitleID.ToString("X08") + " /overridebuckets");
            }

            base.PostRun();
        }

        /// <summary>
        /// Resets the buckets by forcefully repropping the LTC and running running LiveMatch.  This
        /// only works for titleID FFFE07E3, the test title given.
        /// </summary>
        private void UploadRoundRobinConfiguration()
        {
            Global.RO.Info("Uploading round robin configuration for test title 0x" + LiveMatchTestConfig.TitleID.ToString("X08"));

            // Define the round robin nodes we want in addition to the baseline title prop
            RoundRobinNode[] rrNodes = new RoundRobinNode[] {
                    new RoundRobinNode(0, 0, String.IsNullOrEmpty(LiveMatchTestConfig.MatchTestServer2) ? LiveMatchTestConfig.MatchTestServer1 : LiveMatchTestConfig.MatchTestServer2),
                    new RoundRobinNode(0, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(0, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(0, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(0, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(1, 0, String.IsNullOrEmpty(LiveMatchTestConfig.MatchTestServer2) ? LiveMatchTestConfig.MatchTestServer1 : LiveMatchTestConfig.MatchTestServer2),
                    new RoundRobinNode(1, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(1, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(1, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(1, 2, LiveMatchTestConfig.MatchTestServer1),
                    new RoundRobinNode(1, 2, LiveMatchTestConfig.MatchTestServer1)
                };

            m_LtcXml.WriteOriginalWithAdditionalRoundRobin(rrNodes);

            // Redeploy the buckets with LiveMatch
            m_MatchTool.RunLiveMatch("/titleid:0x" + LiveMatchTestConfig.TitleID.ToString("X08") + " /overridebuckets");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveOfferTest\LiveOfferTest.cs ===
//LiveOfferTest.cs




using System;
using ServerTestFramework;
using ServerTestFramework.STFTools;

namespace LiveOfferTest
{
    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")] 
    public class Xbox360Tests : TestNode {

        [TestCase, DVT]
        class Xbox360BVTOffers : LiveOfferTestBase {
            override protected void Execute() {
                string[] testNames = {"ContentOffer", "ThemeOffer", "TileOffer", "TrailerOffer", 
                                      "DemoOffer", "ArcadeOffer", "VideoOffer", "ConsumableOffer", 
                                      "ConsumableOffer-Zero"};
                bool success = true;
                foreach (string testName in testNames) {
                    CleanOffer(testName);
                    RunLiveOffer(testName);
//                    success = success && IsOfferVisible(testName); //this not implemented yet.
                    success = success && VerifyOfferMapping(testName);
                }
                SetResultCode(success);
            }
        }

        [TestCase]
        class Xbox360DMPTest : LiveOfferTestBase {
            override protected void Execute() {
                bool success = true;
                string testName = "ArcadeOffer";
                RunLiveOffer(testName, LiveOffer.dbType.noflag, true);
                success = success && VerifyOfferMapping(testName);
                success = success && VerifyOfferMapping(testName, _Xbox360DMPOfferMap);
                SetResultCode(success);                
            }
        }

        /*
        [TestCase]
        class Xbox360LongOfferTest : LiveOfferTestBase {
            override protected void Execute() {
                string testName = "LongOffer";
                CleanOffer(testName);
                RunLiveOffer(testName);
//                    success = success && IsOfferVisible(testName); //this not implemented yet.
                SetResultCode(VerifyOfferMapping(testName));                                
            }
        }
         */

        [TestCase]
        class Xbox360BOBO : LiveOfferTestBase
        {
            protected override void Execute()
            {
                string testName = "BOBO";
                //CreatePropXLAST(0xFFFE07EC, "Bill On Behalf Of Test", XLASTTitleType.ArcadeTitle);
                CleanOffer(testName);
                RunLiveOffer(testName);
                SetResultCode(VerifyOfferMapping(testName));
            }
        }

        [TestCase]
        class PCArcade : LiveOfferTestBase
        {
            protected override void Execute()
            {
                string testName = "PCArcade";
                //CreatePropXLAST(0xFFFE07EC, "LiveOffer PC Arcade Test", XLASTTitleType.ArcadeTitle);
                CleanOffer(testName);
                RunLiveOffer(testName);
                SetResultCode(VerifyOfferMapping(testName));
            }
        }

    }


    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")] 
    public class Xbox1Tests : TestNode 
    {
        [TestCase]
        class Xbox1HaloOffers : LiveOfferTestBase {
            override protected void Execute() {
                string[] testNames = {"Halo2Map1", "Halo2Map2", "Halo2Map3"};
                bool success = true;
                foreach (string testName in testNames) {
                    RunLiveOffer(testName);
                    success = success && IsOfferVisible(testName);
                    success = success && VerifyOfferMapping(testName);
                }
                SetResultCode(success);
            }
        }

        [TestCase]
        class Xbox1ExpiringTests : LiveOfferTestBase {
            override protected void Execute() {
                bool success = true;

                Global.RO.Info("Propping offer that has not started yet.");
                Global.RO.Info("Note:An offer that has not begun will still be returned by service.");
                Global.RO.Info("Xbox1 is responsible for filtering offers that are not active yet.");
                success = success && ExpectPass("Halo2Map1_not_started", true);
                Global.RO.Info("Propping offer that should be visible");
                RunLiveOffer("Halo2Map1");
                if (IsOfferVisible("Halo2Map1")) {
                    Global.RO.Success("Offer replaces and is visible.");
                } else { 
                    Global.RO.Error("Offer replaces but is not visible.");
                    success = false; 
                }
                
                Global.RO.Info("Propping expired offer");
                RunLiveOffer("Halo2Map1_expired");
                if (!IsOfferVisible("Halo2Map1")) {
                    Global.RO.Success("Offer replaces and is now expired.");
                } else {
                    Global.RO.Error("Offer replaces but is not expired.");
                }
                SetResultCode(success);
            }
        }
    }

    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")]
    public class NegativeTests : TestNode 
    {
        [TestCase]
        class BadOfferIDInOffer : LiveOfferTestBase {
            override protected void Execute() {
                string testName = "BadOfferId";
                if (!RunLiveOffer(testName))
                {
                    Global.RO.Success("LiveOffer throws exception, as expected.");
                    SetResultCode(true);
                    return;
                }
                Global.RO.Error("LiveOffer does not throw exception!");
                SetResultCode(false);
            }
        }

        [TestCase]
        class EmptyXbox1Offer : LiveOfferTestBase {
            override protected void Execute() {
                string testName = "EmptyOffer";
                if (!RunLiveOffer(testName))
                {
                    Global.RO.Success("LiveOffer throws exception, as expected.");
                    SetResultCode(true);
                    return;
                }
                Global.RO.Error("LiveOffer does not throw exception!");
                SetResultCode(false);
            }
        }
        
        [TestCase]
        class NegConsumableOver : LiveOfferTestBase
        {
            protected override void Execute()
            {
                string testName = "ConsumableOffer-Over";
                if (!RunLiveOffer(testName))
                {
                    Global.RO.Success("LiveOffer throws exception, as expected.");
                    SetResultCode(true);
                    return;
                }
                Global.RO.Error("LiveOffer does not throw exception!");
                SetResultCode(false);
            }
        }

        [TestCase]
        class NegConsumableNeg : LiveOfferTestBase
        {
            protected override void Execute()
            {
                string testName = "ConsumableOffer-Neg";
                if (!RunLiveOffer(testName))
                {
                    Global.RO.Success("LiveOffer throws exception, as expected.");
                    SetResultCode(true);
                    return;
                }
                Global.RO.Error("LiveOffer does not throw exception!");
                SetResultCode(false);
            }
        }

        [TestCase]
        class NegMismatchTitleID : LiveOfferTestBase
        {
            protected override void Execute()
            {
                // LiveOffer error (aborting): /titleid fffe07d0 parameter does not match the titleid in the offer file, which was fffe07d1
                string testName = "MismatchTitleID";
                if (!RunLiveOffer(testName))
                {
                    Global.RO.Success("LiveOffer throws exception, as expected.");
                    SetResultCode(true);
                    return;
                }
                Global.RO.Error("LiveOffer does not throw exception!");
                SetResultCode(false);
            }
        }
        [TestCase]
        class NegBOBO : LiveOfferTestBase
        {
            protected override void Execute()
            {
                string testName = "BOBO-Neg";
                if (!RunLiveOffer(testName))
                {
                    Global.RO.Success("LiveOffer throws exception, as expected.");
                    SetResultCode(true);
                    return;
                }
                Global.RO.Error("LiveOffer does not throw exception!");
                SetResultCode(false);
            }
        }


    }


    //[TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated"]
    public class ManualXbox1Utils : TestNode
    {
        //[TestCase]
        class CleanAllHalo2Packages : LiveOfferTestBase {
            override protected void Execute() {
                CleanOffer("Halo2Map1");
                CleanOffer("Halo2Map2");
                CleanOffer("Halo2Map3");
            }
        }
    }

    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")] 
    public class DebugVerifyXbox1 : TestNode {
        [TestCase]
        class VerifyOfferOnly : LiveOfferTestBase {
            override protected void Execute() {
                SetResultCode(VerifyOfferMapping("Halo2Map2"));
            }
        }

    }

    [TestGroup, Owner("wirosas"), Description("Deprecated"), TestFrequency("None"), EnvRequirement("Deprecated")] 
    public class DebugVerifyXbox360 : TestNode {
        [TestCase]
        class VerifyOfferOnly : LiveOfferTestBase {
            override protected void Execute() {
                SetResultCode(VerifyOfferMapping("ArcadeOffer"));
            }
        }

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveOfferTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveOfferTest\LiveOfferTestBase.cs ===
using System;
using System.IO;
using System.Collections;
using System.Xml;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

namespace LiveOfferTest {

    abstract public class LiveOfferTestBase : TestBase {
        public static Hashtable _testFiles; 
        protected static string _inputFilePath;
        protected static string _liveOfferPath;
        protected static string _tempPath;

        protected string _Xbox1OfferMap;
        protected string _Xbox360OfferMap;
        protected string _Xbox360DMPOfferMap;

        public LiveOfferTestBase() {
            //Initialize some useful constants out of the .ini
#region Grab XML Data

            XmlNode LiveOfferConfig = Global.Config.SelectSingleNode("descendant::LiveOfferTest");
            if (LiveOfferConfig == null) {
                throw new LiveOfferException("ERROR: No .xml file found!  Important paths cannot be loaded.");
            }

            XmlNode inputFilePath = LiveOfferConfig.SelectSingleNode("InputFilePath");
            _inputFilePath = Path.GetFullPath(inputFilePath.InnerXml);

            XmlNode node = LiveOfferConfig.SelectSingleNode("TempFilePath");
            if (node != null)
            {
                _tempPath = Path.GetFullPath(node.InnerText);
            }
            else
            {
                _tempPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Temp\\Offers");
            }

            XmlNode defaultToolsPath = LiveOfferConfig.SelectSingleNode("DefaultToolsPath");

            XmlNode liveOfferExe = LiveOfferConfig.SelectSingleNode("LiveOfferExe");
            _liveOfferPath = Path.Combine(Path.GetFullPath(defaultToolsPath.InnerXml), liveOfferExe.InnerXml);

            _Xbox1OfferMap = LiveOfferConfig.SelectSingleNode("LiveOfferXbox1Map").InnerXml;
            _Xbox360OfferMap = LiveOfferConfig.SelectSingleNode("LiveOfferXbox360Map").InnerXml;
            _Xbox360DMPOfferMap = LiveOfferConfig.SelectSingleNode("LiveOfferXbox360DMPMap").InnerXml;

#endregion
            
            _testFiles = new Hashtable();
#region Initialize Test Data
            _testFiles.Add("Halo2Map1", new OfferTestData(_inputFilePath, "4d53006400000001.offer", 0x4d530064, 0x4d53006400000001, OfferTestData.platform.xbox1));
            _testFiles.Add("Halo2Map2", new OfferTestData(_inputFilePath, "4d53006400000002.offer", 0x4d530064, 0x4d53006400000002, OfferTestData.platform.xbox1));
            _testFiles.Add("Halo2Map3", new OfferTestData(_inputFilePath, "4d53006400000003.offer", 0x4d530064, 0x4d53006400000003, OfferTestData.platform.xbox1));

            _testFiles.Add("Halo2Map1_not_started", new OfferTestData(_inputFilePath, "4d53006400000001_not_started.offer", 0x4d530064, 0x4d53006400000001, OfferTestData.platform.xbox1));
            _testFiles.Add("Halo2Map1_expired", new OfferTestData(_inputFilePath, "4d53006400000001_expired.offer", 0x4d530064, 0x4d53006400000001, OfferTestData.platform.xbox1));

            _testFiles.Add("ContentOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000B1.offer", 0xFFFE07D1, 0xFFFE07D1000000B1, OfferTestData.platform.xbox360));
            _testFiles.Add("ThemeOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000B2.offer", 0xFFFE07D1, 0xFFFE07D1000000B2, OfferTestData.platform.xbox360));
            _testFiles.Add("TileOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000B3.offer", 0xFFFE07D1, 0xFFFE07D1000000B3, OfferTestData.platform.xbox360));
            _testFiles.Add("TrailerOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000B8.offer", 0xFFFE07D1, 0xFFFE07D1000000B8, OfferTestData.platform.xbox360));
            _testFiles.Add("DemoOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000B5.offer", 0xFFFE07D1, 0xFFFE07D1000000B5, OfferTestData.platform.xbox360));
            _testFiles.Add("ArcadeOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000B6.offer", 0xFFFE07D1, 0xFFFE07D1000000B6, OfferTestData.platform.xbox360));
            _testFiles.Add("VideoOffer", new OfferTestData(_inputFilePath, "FFFE07D1000000BC.offer", 0xFFFE07D1, 0xFFFE07D1000000BC, OfferTestData.platform.xbox360));

            _testFiles.Add("LongOffer", new OfferTestData(_inputFilePath, "long.offer", 0x584107d4, 0x584107d400000000, OfferTestData.platform.xbox360));

            _testFiles.Add("BadOfferId", new OfferTestData(_inputFilePath, "badOfferId.offer", 0x12345678, 0x1234567812345678, OfferTestData.platform.xbox1));
            _testFiles.Add("EmptyOffer", new OfferTestData(_inputFilePath, "empty.offer", 0x12345678, 0x1234567812345678, OfferTestData.platform.xbox1));

            // positive consumables...
            _testFiles.Add("ConsumableOffer", new OfferTestData(_inputFilePath, "FFFE07D10fffab23.offer", 0xFFFE07D1, 0xFFFE07D10fffab23, OfferTestData.platform.xbox360));
            _testFiles.Add("ConsumableOffer-Max", new OfferTestData(_inputFilePath, "FFFE07D10fffab23-maxquan.offer", 0xFFFE07D1, 0xFFFE07D10fffab23, OfferTestData.platform.xbox360));
            _testFiles.Add("ConsumableOffer-Zero", new OfferTestData(_inputFilePath, "FFFE07D10fffab23-zeroquan.offer", 0xFFFE07D1, 0xFFFE07D10fffab23, OfferTestData.platform.xbox360));
            // neg consumables...
            _testFiles.Add("ConsumableOffer-Over", new OfferTestData(_inputFilePath, "FFFE07D10fffab23-overquan.offer", 0xFFFE07D1, 0xFFFE07D10fffab23, OfferTestData.platform.xbox360));
            _testFiles.Add("ConsumableOffer-Neg", new OfferTestData(_inputFilePath, "FFFE07D10fffab23-negquan.offer", 0xFFFE07D1, 0xFFFE07D10fffab23, OfferTestData.platform.xbox360));
            // Neg cases...
            _testFiles.Add("MismatchTitleID", new OfferTestData(_inputFilePath, "FFFE07D100000001.offer", 0xFFFE07D0, 0xFFFE07D10fffab23, OfferTestData.platform.xbox360));
			//_testFiles.Add("Mis-sizedPNG", new OfferTestData(_inputFilePath, "", 0xFFFE07D1
            // PC Arcade...
            _testFiles.Add("PCArcade", new OfferTestData(_inputFilePath, "0xFFFE07EC00000000.offer", 0xFFFE07EC, 0xFFFE07EC00000000, OfferTestData.platform.xbox360));
            // BOBO: Bill On Behalf Of...
            _testFiles.Add("BOBO", new OfferTestData(_inputFilePath, "FFFE07D1000000BD.offer", 0xFFFE07D1, 0xFFFE07D1000000BD, OfferTestData.platform.xbox360));
            // BOBO Negative...
            _testFiles.Add("BOBO-Neg", new OfferTestData(_inputFilePath, "FFFE07D1000000BD-bad.offer", 0xFFFE07D1, 0xFFFE07D1000000BD, OfferTestData.platform.xbox360));

//we want a 360 offer of every type
//xbox offer of every type
#endregion

        }
        
        //run a vanilla LiveOffer run, returning true if the offer is visible or not-visible as expected.
        public bool ExpectPass(string testName, bool shouldBeVisible) {
            bool success = true;
            CleanOffer(testName);
            RunLiveOffer(testName);            bool isVisible = IsOfferVisible(testName);
            if (shouldBeVisible == isVisible) {
                Global.RO.Success("Offer visibility:" + isVisible + ", as expected");
            } else {
                Global.RO.Error("Offer visibility:" + isVisible + ", expected " + shouldBeVisible);
                success = false;
            }
            if (VerifyOfferMapping(testName, _Xbox1OfferMap)) {
                Global.RO.Success("Offer verifies and is correctly propped.");
            } else {
                Global.RO.Error("One or more rows were not inserted correctly!");
                success = false;
            }
            return success;
        }

        /// <summary>
        /// Removes the offer associated with a test.  Must run with a debug version 
        /// of LiveOffer.  Will fail otherwise.
        /// </summary>
        /// <param name="testName">Name of the test to clean.</param>
        public void CleanOffer(string testName) 
        {
            OfferTestData testData = ((OfferTestData) _testFiles[testName]);
            LiveOffer lo = new LiveOffer(_liveOfferPath);
            //lo.NukeOffer(testData.OfferId);
            ServerTestFramework.LiveService.Billing.ContentOfferLoader.CleanOffers(testData.OfferId);
        }

        public bool IsOfferVisible(string testName) {
            OfferTestData testData = ((OfferTestData) _testFiles[testName]);
            if (testData.OfferType == OfferTestData.platform.xbox1) {
                return IsXbox1OfferVisible(testData.OfferId,  103, testData.TitleId);
            } else {
                return IsXbox360OfferVisible(testData.OfferId,  103, testData.TitleId);
            }
        }

        //default LiveOffer settings.
        public bool RunLiveOffer(string testName) {
            //OfferTestData testData = ((OfferTestData) _testFiles[testName]);
            return RunLiveOffer(testName, LiveOffer.dbType.noflag, false);
        }

        public bool RunLiveOffer(string testName, LiveOffer.dbType DBFlag, bool overrideDMP) {
            LiveOffer lo = new LiveOffer(_liveOfferPath);
            OfferTestData testData = ((OfferTestData) _testFiles[testName]);
            // Use noTransaction switch for now...
            lo.noTransaction = true;
            try {
                if (testData.OfferType == OfferTestData.platform.xbox1) 
                {
                    // Validate the offer, so we get coverage on that as well...
                    lo.ValidateXboxOffer(testData.Filename);
                    lo.PropXboxOffer(testData.Filename, testData.TitleId, DBFlag, overrideDMP);
                } 
                else if (testData.OfferType == OfferTestData.platform.xbox360) 
                {
                    lo.Validate360Offer(testData.Filename);
                    lo.Prop360Offer(testData.Filename, testData.TitleId, DBFlag, overrideDMP);
                }
            } catch (LiveOfferException e) {
                Global.RO.Error("Error!  LiveOffer failed to run.  Exception states:");
                Global.RO.Error(e.Message);
                Global.RO.Info(lo.Output);
                return false;
            }
            return true;
        }
        
        ///Perhaps we can call the appropriate p_xbos commands, and this will simulate seeing it on
        ///a box.  p_xbos_enumerate for an xbox1, what's xbox360 call?
        public bool IsXbox360OfferVisible(ulong expectedOfferId, uint countryId, ulong titleId) {
            //STUB
//Will need to exec the following statement:
//exec dbo.p_xbos_content_enumerate @i_country_id = 103, @i_culture_id = 1033, @i_starting_index = 0, @i_max_results = 1000, @bi_user_puid = 2533274790397952, @i_rating_system_id = 63, @i_rating_rank = 255, @i_offer_type_id = 32767, @i_payment_type_id = 4, @i_tier_required = 6, @i_title_id = -129071, @i_title_bit_filter = -1, @i_user_played_game_filter = 0, @i_user_has_purchased_filter = 0, @i_new_content_window_hours = 0, @i_genre_id = 0
            return true;
        }


        //Simulate an xbox1 call, which should be this:
        //exec dbo.p_xbos_enumerate @countryid = 103, @titleid = 1297285220, @offeringtype = -1, @descriptionindex = 0, @bitfilter = -1, @esrbrating = 0
        //This will be a UODB call--one day we should verify all UODBs, but for now we'll just query
        //one.  Data should be synchronized.
        //
        //returns true if the offerId is there for the given title, false otherwise.
        public bool IsXbox1OfferVisible(ulong expectedOfferId, uint countryId, uint titleId) {
            bool success = false;

            success = UodbWS.IsOfferVisible(expectedOfferId, countryId, titleId);    
            if (success) {
                Global.RO.Info("OfferId found");
            } else {
                Global.RO.Info("OfferId not found");
            }
            return success;
        }
        
        //selects the offer map dependent on the platform of the test.
        public bool VerifyOfferMapping(string testName) {
            OfferTestData testData = ((OfferTestData) _testFiles[testName]);
            if (testData.OfferType == OfferTestData.platform.xbox360) {
                return VerifyOfferMapping(testName, _Xbox360OfferMap);
            } else if (testData.OfferType == OfferTestData.platform.xbox1) {
                return VerifyOfferMapping(testName, _Xbox1OfferMap);
            }
            throw new Exception("Attempt to verify offer of invalid platform type!");
        }

        public bool VerifyOfferMapping(string testName, string offerMapFilePath) {
            OfferTestData testData = ((OfferTestData) _testFiles[testName]);
            XmlOfferFile fileToVerify;
            if (testData.OfferType == OfferTestData.platform.xbox360) {
             fileToVerify = new XmlOfferFile(testData.Filename, XmlOfferFile.platform.xbox360);
            } else if (testData.OfferType == OfferTestData.platform.xbox1) {
                fileToVerify = new XmlOfferFile(testData.Filename, XmlOfferFile.platform.xbox1);
            } else {
                throw new Exception("Attempt to verify offer of invalid platform type!");
            }

            //create an XmlOfferMap
            XmlOfferMap offerMap = new XmlOfferMap(offerMapFilePath);
            //load up the offer, pass it into the offermap
            ArrayList queries = offerMap.CreateQueries(fileToVerify);
            //let's not go overboard with output...
            bool quiet = false;
            if (queries.Count >= 100) {
                Global.RO.Warn("Over 100 queries involved in this test.  Suppressing query execution output.");
                quiet = true;
            }

            foreach (String query in queries) {
                if (!((int)(UodbWS.ExecuteSQLScalar(query, null))==1)) {
                    Global.RO.Error("ERROR: Test Query returns incorrect number of rows(not 1).  Query is as follows:");
                    Global.RO.Error(query);
                    return false;
                } else {
                    if (!quiet) {
                        Global.RO.Success(query);
                    }
                }
            }
            Global.RO.Success("All queries return one row as expected.");
            return true;
        }
        

        public void SetResultCode(bool success) {
            if (success) {
                ResultCode = TEST_RESULTS.PASSED;
            } else {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        protected void CreatePropXLAST(uint titleID, string titleName, XLASTTitleType titleType)
        {
            string path;
            XLASTFactory factory = new XLASTFactory();
            XboxLiveSubmissionProject xlast = factory.Create(XLASTFactory.SchemaVersion03, titleType, titleID, titleName, XLASTLanguage.English);
            path = Path.Combine(_tempPath, String.Format("{0:x}.xlast", titleID));
            LiveTitle liveTitleTool = new LiveTitle();
            liveTitleTool.XlastPath = path;
            ConfigFileSerializer.ToXml(liveTitleTool.XlastPath, xlast);
            // Deploy
            liveTitleTool.CreateXbox360LTCFile();
            liveTitleTool.DeployXbox360Title(titleID);

        }

    }

    public class OfferTestData {
        private string _filename;
        private uint _titleId;
        private ulong _offerId;
        private platform _offerType;

        public string Filename {get {return _filename; } }
        public uint TitleId { get {return _titleId; } }
        public ulong OfferId { get {return _offerId; } }
        public platform OfferType { get { return _offerType; } }

        public enum platform{xbox1, xbox360};

        public OfferTestData(string inputFilePath, string filename, uint titleId, ulong offerId, platform offerType) {
            _filename = Path.Combine(inputFilePath, filename);
            _titleId = titleId;
            _offerId = offerId;
            _offerType = offerType;
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveOfferTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveMatchTest\MatchTestBase.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.STFTools;

namespace LiveMatchTest
{
    /// <summary>
    /// Base Test class that defines pathing and verification.
    /// </summary>
    abstract public class MatchTestBase : ToolsTestBase
    {
        protected LtcXml m_LtcXml;
        protected XMatch m_MatchDB = null;
        protected LiveMatch m_MatchTool = null;
        protected string m_OriginalTitleConfig = null;

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            LiveMatchTestConfig.ReadConfig();

            m_MatchDB = new XMatch();
            m_MatchDB.ConnectToServer(LiveMatchTestConfig.MatchTestServer1);

            m_LtcXml = new LtcXml(LiveMatchTestConfig.TitleID);
            m_LtcXml.SaveOriginalToCache();
        }

        public override void PreRun(RUN_TYPE runType)
        {
            base.PreRun(runType);

            // Check that the test title is propped
            using (NpdbUtility npdb = new NpdbUtility())
            {
                npdb.ConnectToServer();
                LiveTitleConfigRow liveTitleConfigRow = npdb.GetLiveTitleConfig(LiveMatchTestConfig.TitleID);
                npdb.Close();

                if (liveTitleConfigRow == null)
                {
                    throw new Exception("Live title config not found for title ID 0x" + LiveMatchTestConfig.TitleID.ToString("X08"));
                }
            }

            // Setup the LiveMatch tool interface
            m_MatchTool = new LiveMatch(LiveMatchTestConfig.ToolPath, true);

            // Restore the original LTC XML
            if (m_LtcXml.RestoreOriginalToService())
            {
                m_MatchTool.RunLiveMatch("/titleid:0x" + LiveMatchTestConfig.TitleID.ToString("X08") + " /overridebuckets");
            }
        }

        /// <summary>
        /// Either throws an exception or logs an error
        /// </summary>
        /// <param name="shouldThrow">True to throw an exception, false to log an error message</param>
        /// <param name="errorMsg">Error message</param>
        private void ThrowOnErrorHelper(bool shouldThrow, string errorMsg)
        {
            if (shouldThrow)
            {
                throw new UnexpectedTestResultException(errorMsg);
            }
            else
            {
                Global.RO.Error(errorMsg);
            }
        }

        /// <summary>
        /// Verifies the tables were created
        /// </summary>
        protected bool VerifyTables(string server, bool throwOnFailure)
        {
            string table1, table2;
            string[] tables;

            string tableNames = m_MatchDB.GetMatchTables(LiveMatchTestConfig.TitleID);

            // Check to see if we have any tables...
            if (!String.IsNullOrEmpty(tableNames))
            {
                Global.RO.Info("VerifyTables: Found Match Tables on " + server + ": " + tableNames);
                // Have tables, now check them...
                tables = tableNames.Split(',');
                if (tables.Length != 2)
                {
                    ThrowOnErrorHelper(throwOnFailure, "VerifyTables: Not 2 tables on " + server);
                    return false;
                }

                // Right now will just check to see if the tables were created the same...
                table1 = m_MatchDB.GetTableColumns(tables[0]);
                table2 = m_MatchDB.GetTableColumns(tables[1]);

                if (table1 != table2)
                {
                    ThrowOnErrorHelper(throwOnFailure, "VerifyTables: Table column mismatch on " + server);
                    return false;
                }
            }
            else
            {
                ThrowOnErrorHelper(throwOnFailure, "VerifyTables: Could not find match tables on " + server);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Verifies that Match stored procs were created for Title
        /// </summary>
        protected bool VerifyProcs(string server, bool throwOnFailure)
        {
            string procNames = m_MatchDB.GetStoredProcs(LiveMatchTestConfig.TitleID);

            if (!String.IsNullOrEmpty(procNames))
            {
                Global.RO.Info("VerifyProcs: Found Match Procs on " + server + ": " + procNames);

                XmlDocument xmlDoc = new XmlDocument();

                // Get # of queries from XLAST that is in NPBD
                NpdbUtility npdb = new ServerTestFramework.Database.NpdbUtility();
                npdb.ConnectToServer();
                GameConfigRow gameConfig = null;
                npdb.GetGameConfig(LiveMatchTestConfig.TitleID, out gameConfig);
                ServerTestFramework.STFTools.ConfigFiles.XboxGameConfig xlast = new ServerTestFramework.STFTools.ConfigFiles.XboxGameConfig();
                xmlDoc.LoadXml(gameConfig.XmlConfig);
                npdb = null;

                XmlNamespaceManager nsmgr = new XmlNamespaceManager(xmlDoc.NameTable);
                nsmgr.AddNamespace("xl", "http://www.xboxlive.com/xlast");

                int queries = xmlDoc.SelectNodes("//xl:Query",nsmgr).Count;
                xmlDoc = null;

                // see http://xblwiki/default.aspx/XboxLive/LiveMatch.html for why this works
                // Fall Release 2006 - p_match_session_<titleid>_search_findbyid_list added
                // Fall Release 2007 - p_match_session_<version>_<titleid>_updatecomplete, p_match_session_<version>_<titleid>_lock_and_read
                //                     p_match_session_<version>_<titleid>_release_lock added.
                // Spring Release 2009 - p_match_session_<version>_<titleid>_<querynum>_search_weighted_ranked/standard added
                int numProcs = (queries * 5) + 10;
                if (procNames.Split(',').Length != numProcs)
                {
                    ThrowOnErrorHelper(
                        throwOnFailure,
                        String.Format("VerifyProcs: Number of Procs different on {0}: Got {1}, but expected {2}", server, procNames.Split(',').Length, numProcs)
                        );
                    return false;
                }
            }
            else
            {
                ThrowOnErrorHelper(throwOnFailure, "VerifyProcs: No Stored Procs found on " + server);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Executes a SQL command against NPDB
        /// </summary>
        /// <param name="sqlCmd">SQL command to execute</param>
        protected void ExecuteNpdbCommand(string sqlCmd)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                npdb.IssueCommand(sqlCmd);
                npdb.Close();
            }
        }

        const String DRAIN_STRING = "drain";  //the string in vc_info1 of t_interface_buckets that
                                              //indicates a draining RR bucket.

        public enum RoundRobinAction {
            ADD,   //addrrbucket
            DRAIN, //the action for draintoprrbucket.
            REMOVE  //the action for remove
        }

        /// <summary>
        /// Briefly returns whether a bucket is draining or not.
        /// </summary>
        public static bool IsDraining(InterfaceBucket bucket) {
            if (bucket.Info1 == null) return false;
            return bucket.Info1.Equals(DRAIN_STRING);
        }


        /// <summary>
        /// Count the number of buckets that are draining.
        /// </summary>
        public static int CountDrainingBuckets(InterfaceBucketCollection buckets) {
            int answer = 0;
            foreach(InterfaceBucket bucket in buckets) {
                if (IsDraining(bucket)) answer++;
            }
            return answer;
        }

        //list of the possible drain states when looking for the highest ordered bucket.
        public enum DrainState {
            DRAIN,
            NOT_DRAIN,
            ANY
        }

        /// <summary>
        /// Return whether a bucket fits the following criteria--
        /// ANY means true if either draining/not draining.
        /// DRAIN returns true if draining
        /// NOT_DRAIN returns true if not draining.
        /// </summary>
        public static bool DrainStateMatch(InterfaceBucket bucket, DrainState filter) {
            if (filter == DrainState.ANY) return true;
            if ((filter == DrainState.DRAIN) && (IsDraining(bucket))) return true;
            if ((filter == DrainState.NOT_DRAIN) && (!IsDraining(bucket))) return true;
            return false;
        }


        /// <summary>
        /// Returns the highest numbered bucket that is draining/is not draining, depending on the passed-in DrainState.
        /// </summary>
        public static InterfaceBucket GetMaxBucketOfType(InterfaceBucketCollection buckets, DrainState filter) {
            InterfaceBucket maxSoFar = null;
            foreach(InterfaceBucket bucket in buckets) {
                if ((maxSoFar == null) ||
                    ((bucket.Bucket > maxSoFar.Bucket) && (DrainStateMatch(bucket, filter)))) {
                    maxSoFar = bucket;
                }
            }
            return maxSoFar;
        }

        /// <summary>
        /// Returns the lowest numbered bucket that is draining/is not draining, depending on the passed-in DrainState.
        /// </summary>
        public static InterfaceBucket GetMinBucketOfType(InterfaceBucketCollection buckets, DrainState filter) {
            InterfaceBucket minSoFar = null;
            foreach(InterfaceBucket bucket in buckets) {
                if ((minSoFar == null) ||
                    ((bucket.Bucket < minSoFar.Bucket) && (DrainStateMatch(bucket, filter)))) {
                    minSoFar = bucket;
                }
            }
            return minSoFar;
        }

        /// <summary>
        /// Perform the action on the supplied InterfaceBucketCollection and returns empty string.
        /// If the action is invalid, returns an expected errorString.
        ///
        /// NOTE:This modifies the bucket collection.
        /// <summary>
        public static string PerformActionOnBuckets(RoundRobinAction action,
                                                    bool force,
                                                    InterfaceBucketCollection buckets) {

            if (action == RoundRobinAction.ADD) {
                throw new UnexpectedTestResultException("Error!  Cannot call PerformActionOnBuckets with an ADD action without a string for the new RR server.");
            } else {
                return PerformActionOnBuckets(action, force, buckets, "");
            }
        }

        public static string PerformActionOnBuckets(RoundRobinAction action,
                                                    bool force,
                                                    InterfaceBucketCollection buckets,
                                                    string newRRServer) {
            if (((action == RoundRobinAction.DRAIN) || (action == RoundRobinAction.REMOVE)) && (buckets.Count == 1)) {
                return("Only one bucket found.  DRAIN and REMOVE actions cannot be performed.");
            }

            //Count draining buckets.  If that's all but one, errorstring.
            //Otherwise find the highest numbered non-draining item and set to drain.
            if (action == RoundRobinAction.DRAIN) {
                int numDraining = CountDrainingBuckets(buckets);
                if (numDraining >= (buckets.Count - 1)) {
                    return("Only one bucket exists for the type/mode you specified, and it can not be drained.");
                }
                //find max non-draining bucket
                InterfaceBucket bucket = GetMaxBucketOfType(buckets, DrainState.NOT_DRAIN);
                bucket.Info1 = DRAIN_STRING;
                return "";
            }

            //find the highest numbered bucket.
            //If that is draining, remove.
            //If it is not draining, then we error unless we have the force flag.
            //if we have the force flag, remove.
            if (action == RoundRobinAction.REMOVE) {
                InterfaceBucket bucket = GetMaxBucketOfType(buckets, DrainState.ANY);
                if ((IsDraining(bucket)) || force) {
                    buckets.Remove(bucket);
                    return "";
                } else {
                    return("Attempt to remove bucket without the /force flag.");
                }
            }


            //if there is a bucket draining, undrain the lowest one.  If there is none, add an rrbucket.
            if (action == RoundRobinAction.ADD) {
                InterfaceBucket bucket = GetMinBucketOfType(buckets, DrainState.DRAIN);
                if (IsDraining(bucket)) {
                    bucket.Info1 = "";
                } else {
                    //if it's *not* draining, it means none of them were.  Add a new RR bucket.  Same
                    //titleId, but the server will be the new server name.
                    bucket = GetMaxBucketOfType(buckets, DrainState.ANY);
                    InterfaceBucket newBucket = new InterfaceBucket();
                    newBucket.Environment = bucket.Environment;
                    newBucket.Interface = bucket.Interface;
                    newBucket.TitleId = bucket.TitleId;
                    newBucket.Bucket = bucket.Bucket + 1;
                    newBucket.Server = newRRServer;
                    newBucket.NextServer = newRRServer;
                    newBucket.MigrationStart = bucket.MigrationStart;  //we don't check this, anyway.
                    buckets.Add(newBucket);
                }
                return "";
            }

            throw new Exception("Invalid execution path in test code.  Invalid action supplied " +
                                "or not all cases covered in PerformActionOnBuckets handler.");
        }

        /// <summary>
        /// For every bucket in the expected group, check if a bucket of the same id exists in the
        /// actual group, and if the info1 matches or does not match.  O(n^2).  We're probably dealing
        /// with 5-7 buckets max, so efficiency isn't a big deal here.
        /// </summary>
        public static void CompareBucketCollections(InterfaceBucketCollection bucketsExpected,
                                                    InterfaceBucketCollection bucketsActual) {
            foreach (InterfaceBucket bucketToCheck in bucketsExpected) {
                bool bucketFound = false;
                //find the bucket in bucketsActual
                foreach (InterfaceBucket bucket in bucketsExpected) {
                    if (bucketToCheck.Bucket == bucket.Bucket) {
                        bucketFound = true;
                        if (bucketToCheck.Info1 != bucket.Info1) {
                            throw new UnexpectedTestResultException(
                                String.Format(
                                    "CompareBucketCollections:The bucket expected does not have the same Info1 as the actual! Expected: {0}, Actual: {1}",
                                    bucketToCheck,
                                    bucket
                                )
                            );
                        }
                    }
                }

                if (!bucketFound)
                {
                    throw new UnexpectedTestResultException("CompareBucketCollections:An expected bucket was not found!  The following bucket was expected: " + bucketToCheck.ToString());
                }
            }
        }

        /// <summary>
        /// Takes in the type, mode and RRID and returns the i_bucket value that will be used in the database
        /// </summary>
        public static int ConvertToBucketId(int type, int mode, int RRID)
        {
            //type is bits 23-16
            type = type & 0xFF;  //take eight bits each
            mode = mode & 0xFF;
            RRID = RRID & 0xFF;
            return ((type << 16) | (mode << 8) | RRID);
        }

        /// <summary>
        /// Checks the t_interface_buckets to find the server list, and validates tables and sprocs on XMatch DB
        /// This only works for 360 titles
        /// </summary>
        protected bool VerifyAll(bool throwOnFailure)
        {
            bool result = true;

            foreach (string server in LiveMatchTestConfig.ServerNames)
            {
                m_MatchDB.Close();
                m_MatchDB.ConnectToServer(server);

                result = result && VerifyTables(server, throwOnFailure);
                result = result && VerifyProcs(server, throwOnFailure);
            }

            return result;
        }

        protected bool VerifyAll()
        {
            return VerifyAll(true);
        }

        /// <summary>
        /// Verifies that the LiveMatch tool failed with an expected error string and that
        /// table and sproc validation appropriately fails.
        /// </summary>
        /// <param name="ex">Exception from LiveMatch tool</param>
        /// <param name="expectedError">Expected error string</param>
        protected void VerifyExpectedToolError(LiveMatchException ex, string expectedError, bool shouldVerifySucceed)
        {
            if (!ex.ProcessOutput.Contains(expectedError))
            {
                Global.RO.Warn(ex.ProcessOutput);
                throw new UnexpectedTestResultException("Process output did not contain expected error \"" + expectedError + "\"");
            }

            bool verifyResult = VerifyAll(false);

            if ((verifyResult && !shouldVerifySucceed) || (!verifyResult && shouldVerifySucceed))
            {
                throw new UnexpectedTestResultException(
                    String.Format("VerifyAll() unexpectedly {0}", shouldVerifySucceed ? "failed" : "passed")
                );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveOfferTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_liveoffertest_none_12.4.56.0_none_7b62b1efb6d4e80b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=liveoffertest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.manifest
XP_MANIFEST_PATH=manifests\msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.cat
XP_CATALOG_PATH=manifests\msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.cat
XP_PAYLOAD_PATH=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=liveoffertest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveOfferTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_liveoffertest_none_12.4.56.0_none_7b62b1efb6d4e80b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=liveoffertest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.manifest
XP_MANIFEST_PATH=manifests\msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.cat
XP_CATALOG_PATH=manifests\msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5.cat
XP_PAYLOAD_PATH=msil_liveoffertest_no-public-key_12.4.56.0_x-ww_940557a5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=liveoffertest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\FuncMove.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;

namespace LiveStatsTest
{
    /// <summary>
    /// Test group for leaderboard move tests.
    /// </summary>
    /// <remarks>
    /// Includes the following test cases:
    ///     FuncMoveSingleLeaderboard
    ///     FuncMoveAllLeaderboards
    ///     FuncMoveWithMultipleServers
    /// </remarks>
    [TestGroup]
    public class FuncMoveGroup : TestNode
    {
        /// <summary>
        /// Move a single Leaderboard.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Move a user defined leaderboard.
        /// </remarks>
        [TestCase, DVT]
        public class FuncMoveSingleLeaderboard : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveSingleLeaderboard");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Move a single leaderboard to a new server
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(_liveTitleTool.LTCPath);
                MoveLeaderboard(titleId, ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID,
                    ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs, _secondLeaderboardServer);

                // Verify that the LTC file in NPDB has been updated
                // and that the leaderboard is now on that server
                ResultCode = TEST_RESULTS.PASSED;
                Xbox360Stats stats = Xbox360Stats.Create(titleId);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                ltc = LiveTitleConfig.FromXml(reader);
                if (String.Compare(ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs, _secondLeaderboardServer, true) != 0)
                {
                    StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs,
                        "Hosting server mismatch for leaderboard {0}", ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    if (ib.Bucket == ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID)
                    {
                        if (String.Compare(ib.Server, _secondLeaderboardServer, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        break;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Move a TruSkill Leaderboard.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Move a TruSkill leaderboard for an Xbox 360 title.
        /// </remarks>
        [TestCase]
        public class FuncMoveTruSkillLeaderboard : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveTruSkillLeaderboard");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Move a single leaderboard to a new server
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(_liveTitleTool.LTCPath);
                // Use leaderboard 3 (since this file has only 2 normal leaderboards) if we can't find one by searching
                int truSkillArrayLoc = 3;
                for (int loopVar = 0; loopVar < ltc.LeaderboardConfigs.LeaderboardConfigCollection.Count; loopVar++)
                {
                    if (ltc.LeaderboardConfigs.LeaderboardConfigCollection[loopVar].LeaderboardID < 0)
                    {
                        // We found a TruSkill Leaderboard
                        truSkillArrayLoc = loopVar;
                        _report.Debug("Found a TruSkill leaderboard at {0}. ID:{1}, Server:{2}",
                                    truSkillArrayLoc,
                                    ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].LeaderboardID,
                                    ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].HostingLbs);
                        break;
                    }
                }
                MoveLeaderboard(titleId, ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].LeaderboardID,
                    ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].HostingLbs, _secondLeaderboardServer);

                // Verify that the LTC file in NPDB has been updated
                // and that the leaderboard is now on that server
                ResultCode = TEST_RESULTS.PASSED;
                Xbox360Stats stats = Xbox360Stats.Create(titleId);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                ltc = LiveTitleConfig.FromXml(reader);
                if (String.Compare(ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].HostingLbs, _secondLeaderboardServer, true) != 0)
                {
                    StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].HostingLbs,
                        "Hosting server mismatch for leaderboard {0}", ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].LeaderboardID);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    if (ib.Bucket == ltc.LeaderboardConfigs.LeaderboardConfigCollection[truSkillArrayLoc].LeaderboardID)
                    {
                        if (String.Compare(ib.Server, _secondLeaderboardServer, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        break;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Move all Leaderboards.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Specify All as the leaderboard ID.
        /// </remarks>
        [TestCase, DVT]
        public class FuncMoveAllLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveAllLeaderboards");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);
                
                // Deploy the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Move all leaderboards to a new server
                MoveLeaderboard(titleId, LiveStats.ALL_LEADERBOARDS,
                    _liveTitleTool.LeaderboardServer, _secondLeaderboardServer);

                // Verify that the LTC file in NPDB has been updated
                // and that all the leaderboards are now on the new server
                ResultCode = TEST_RESULTS.PASSED;
                Xbox360Stats stats = Xbox360Stats.Create(titleId);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(reader);
                foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                    {
                        StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                            "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    // make sure this is a lbsvr and not a xmatch comparison
                    if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                        && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                    {
                        StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                            "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Move all Leaderboards.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Specify ALL for a title that has leaderboards on different servers.
        /// </remarks>
        [TestCase]
        public class FuncMoveWithMultipleServers : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveWithMultipleServers");

                uint titleId = 0xFFFE07DB;
                string newLbServer = _secondLeaderboardServer;
                string destLbServer = _secondLeaderboardServer;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);
                
                // Deploy the title - make sure the leaderboard server being used is the default
                _liveTitleTool.LeaderboardServer = _defaultLeaderboardServer;
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Redeploy the title with leaderboards added to a different lb server
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_new_leaderboards.xlast");
                _liveTitleTool.LeaderboardServer = newLbServer;
                _liveTitleTool.CreateXbox360LTCFile(0, 0);
                _liveTitleTool.DeployXbox360Title(titleId, false, false);

                // Deploy the new leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Move the original leaderboards to the new server
                MoveLeaderboard(titleId, LiveStats.ALL_LEADERBOARDS, _defaultLeaderboardServer, destLbServer);

                // Verify that the LTC file in NPDB has been updated
                // and that all the leaderboards are now on the new server
                ResultCode = TEST_RESULTS.PASSED;
                Xbox360Stats stats = Xbox360Stats.Create(titleId);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(reader);
                foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    if (String.Compare(destLbServer, lbc.HostingLbs, true) != 0)
                    {
                        StatsVerifier.ReportVerificationFailure(destLbServer, lbc.HostingLbs,
                            "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                        && (String.Compare(destLbServer, ib.Server, true) != 0))
                    {
                        StatsVerifier.ReportVerificationFailure(destLbServer, ib.Server,
                            "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Move a single Leaderboard.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Negative Functional: Specify a non-existent title id.
        /// Negative Functional: Specify a non-existent leaderboard id.
        /// Negative Functional: Specify a source server that doesn't exist.
        /// Negative Functional: Specify a different source server than the leaderboard is on.
        /// Negative Functional: Specify a non-existent destination server.
        /// Negative Functional: Specify the same server for source and destination.
        /// </remarks>
        [TestCase]
        public class FuncNegativeMoveLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncNegativeMoveLeaderboards");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Move a single leaderboard to a new server
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(_liveTitleTool.LTCPath);
                MoveLeaderboard(titleId, ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID,
                    ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs, _secondLeaderboardServer);

                // Verify that the LTC file in NPDB has been updated
                // and that the leaderboard is now on that server
                ResultCode = TEST_RESULTS.PASSED;
                Xbox360Stats stats = Xbox360Stats.Create(titleId);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                ltc = LiveTitleConfig.FromXml(reader);
                if (String.Compare(ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs, _secondLeaderboardServer, true) != 0)
                {
                    StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs,
                        "Hosting server mismatch for leaderboard {0}", ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    if (ib.Bucket == ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID)
                    {
                        if (String.Compare(ib.Server, _secondLeaderboardServer, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        break;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Move all Leaderboards from multiple titles.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Specify All as the leaderboard ID.
        /// </remarks>
        [TestCase]
        public class FuncMoveMultipleTitles : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveMultipleTitles");

                ResultCode = TEST_RESULTS.PASSED;
                uint titleId1 = 0xFFFE07DB;
                uint titleId2 = 0xFFFE07DC;
                LiveTitle liveTitleTool2 = new LiveTitle();
                liveTitleTool2.LiveTitlePath = _liveTitleTool.LiveTitlePath;
                liveTitleTool2.LeaderboardServer = _liveTitleTool.LeaderboardServer;
                string firstLeaderboardServer = _liveTitleTool.LeaderboardServer;

                DeleteTitle(titleId1);
                DeleteTitle(titleId2);
                CopyInputFiles(titleId1);
                CopyInputFiles(titleId2);

                // Deploy the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId1.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId1, true, false);
                liveTitleTool2.XlastPath = Path.Combine(_tempPath, titleId2.ToString("X8") + ".xlast");
                liveTitleTool2.DeployXbox360Title(titleId2, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId1, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId2, false);

                // Move all leaderboards to a new server
                _report.Debug("Moving titles to second leaderboard server");
                MoveLeaderboard(titleId1, LiveStats.ALL_LEADERBOARDS,
                    firstLeaderboardServer, _secondLeaderboardServer);
                MoveLeaderboard(titleId2, LiveStats.ALL_LEADERBOARDS,
                    firstLeaderboardServer, _secondLeaderboardServer);

                // Verify that the LTC file in NPDB has been updated
                // and that all the leaderboards are now on the new server
                Xbox360Stats stats = Xbox360Stats.Create(titleId1);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(reader);
                foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                    {
                        StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                            "Hosting server mismatch for leaderboard {0} on title {1}", lbc.LeaderboardID, titleId1);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    // make sure this is a lbsvr and not a xmatch comparison
                    if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                        && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                    {
                        StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                            "Interface bucket server mismatch for leaderboard {0} on title {1}", ib.Bucket, titleId1);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                stats = Xbox360Stats.Create(titleId2);
                reader = new StringReader(stats.LiveTitleConfigXml);
                ltc = LiveTitleConfig.FromXml(reader);
                foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                    {
                        StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                            "Hosting server mismatch for leaderboard {0} on title {1}", lbc.LeaderboardID, titleId2);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    // make sure this is a lbsvr and not a xmatch comparison
                    if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                        && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                    {
                        StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                            "Interface bucket server mismatch for leaderboard {0} on title {1}", ib.Bucket, titleId2);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId1);
                    ClearTempDirectory(titleId2);
                }
            }
        }

        /// <summary>
        /// Move all Leaderboards from multiple titles.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Specify All as the leaderboard ID.
        /// </remarks>
        [TestCase, StressTest]
        public class FuncMoveMultipleTitlesStress : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveMultipleTitlesStress");

                ResultCode = TEST_RESULTS.PASSED;
                uint titleId1 = 0xFFFE07DB;
                uint titleId2 = 0xFFFE07DC;
                LiveTitle liveTitleTool2 = new LiveTitle();
                liveTitleTool2.LiveTitlePath = _liveTitleTool.LiveTitlePath;
                liveTitleTool2.LeaderboardServer = _liveTitleTool.LeaderboardServer;
                liveTitleTool2.WorkingDirectory = _liveTitleTool.WorkingDirectory;
                string firstLeaderboardServer = _liveTitleTool.LeaderboardServer;

                DeleteTitle(titleId1);
                DeleteTitle(titleId2);
                CopyInputFiles(titleId1);
                CopyInputFiles(titleId2);

                // Deploy the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId1.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId1, true, false);
                liveTitleTool2.XlastPath = Path.Combine(_tempPath, titleId2.ToString("X8") + ".xlast");
                liveTitleTool2.DeployXbox360Title(titleId2, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId1, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId2, false);

                for (int stressLoopNum = 0; stressLoopNum < MaxStressIterations; stressLoopNum++)
                {
                    _report.Info("Starting Loop: {0}", stressLoopNum);
                    // Move all leaderboards to a new server
                    _report.Info("Moving titles to second leaderboard server");
                    MoveLeaderboard(titleId1, LiveStats.ALL_LEADERBOARDS,
                        firstLeaderboardServer, _secondLeaderboardServer);
                    MoveLeaderboard(titleId2, LiveStats.ALL_LEADERBOARDS,
                        firstLeaderboardServer, _secondLeaderboardServer);

                    // Verify that the LTC file in NPDB has been updated
                    // and that all the leaderboards are now on the new server
                    Xbox360Stats stats = Xbox360Stats.Create(titleId1);
                    StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                    LiveTitleConfig ltc = LiveTitleConfig.FromXml(reader);
                    foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                    {
                        if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                                "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                    {
                        // make sure this is a lbsvr and not a xmatch comparison
                        if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                            && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    stats = Xbox360Stats.Create(titleId2);
                    reader = new StringReader(stats.LiveTitleConfigXml);
                    ltc = LiveTitleConfig.FromXml(reader);
                    foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                    {
                        if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                                "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                    {
                        // make sure this is a lbsvr and not a xmatch comparison
                        if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                            && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    // Move all leaderboards to a new server
                    _report.Info("Moving titles back to first leaderboard server");
                    MoveLeaderboard(titleId1, LiveStats.ALL_LEADERBOARDS,
                        _secondLeaderboardServer, firstLeaderboardServer);
                    MoveLeaderboard(titleId2, LiveStats.ALL_LEADERBOARDS,
                        _secondLeaderboardServer, firstLeaderboardServer);

                    // Verify that the LTC file in NPDB has been updated
                    // and that all the leaderboards are now on the new server
                    stats = Xbox360Stats.Create(titleId1);
                    reader = new StringReader(stats.LiveTitleConfigXml);
                    ltc = LiveTitleConfig.FromXml(reader);
                    foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                    {
                        if (String.Compare(firstLeaderboardServer, lbc.HostingLbs, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(firstLeaderboardServer, lbc.HostingLbs,
                                "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                    {
                        // make sure this is a lbsvr and not a xmatch comparison
                        if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                            && (String.Compare(firstLeaderboardServer, ib.Server, true) != 0))
                        {
                            StatsVerifier.ReportVerificationFailure(firstLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    stats = Xbox360Stats.Create(titleId2);
                    reader = new StringReader(stats.LiveTitleConfigXml);
                    ltc = LiveTitleConfig.FromXml(reader);
                    foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                    {
                        if (String.Compare(firstLeaderboardServer, lbc.HostingLbs, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(firstLeaderboardServer, lbc.HostingLbs,
                                "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                    {
                        // make sure this is a lbsvr and not a xmatch comparison
                        if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                            && (String.Compare(firstLeaderboardServer, ib.Server, true) != 0))
                        {
                            StatsVerifier.ReportVerificationFailure(firstLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                    if (ResultCode == TEST_RESULTS.FAILED)
                        break;
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId1);
                    ClearTempDirectory(titleId2);
                }
            }
        }

        /// <summary>
        /// Move all Leaderboards from multiple titles.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Specify All as the leaderboard ID.
        /// </remarks>
        [TestCase, StressTest]
        public class FuncMoveMultipleTitlesOneWayStress : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveMultipleTitlesOneWayStress");

                ResultCode = TEST_RESULTS.PASSED;
                uint titleId1 = 0xFFFE07DB;
                uint titleId2 = 0xFFFE07DC;
                LiveTitle liveTitleTool2 = new LiveTitle();
                liveTitleTool2.LiveTitlePath = _liveTitleTool.LiveTitlePath;
                liveTitleTool2.LeaderboardServer = _liveTitleTool.LeaderboardServer;
                liveTitleTool2.WorkingDirectory = _liveTitleTool.WorkingDirectory;
                string firstLeaderboardServer = _liveTitleTool.LeaderboardServer;

                for (int stressLoopNum = 0; stressLoopNum < MaxStressIterations; stressLoopNum++)
                {
                    _report.Info("Starting Loop: {0}", stressLoopNum);
                    //Cleanup
                    DeleteTitle(titleId1);
                    DeleteTitle(titleId2);
                    CopyInputFiles(titleId1);
                    CopyInputFiles(titleId2);

                    // Deploy the title
                    _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId1.ToString("X8") + ".xlast");
                    liveTitleTool2.XlastPath = Path.Combine(_tempPath, titleId2.ToString("X8") + ".xlast");
                    _liveTitleTool.DeployXbox360Title(titleId1, true, false);
                    liveTitleTool2.DeployXbox360Title(titleId2, true, false);

                    // Deploy the leaderboards
                    _liveStatsTool.DeployXbox360Leaderboard(titleId1, false);
                    _liveStatsTool.DeployXbox360Leaderboard(titleId2, false);

                    // Move all leaderboards to a new server
                    _report.Info("Moving titles to second leaderboard server");
                    MoveLeaderboard(titleId1, LiveStats.ALL_LEADERBOARDS,
                        firstLeaderboardServer, _secondLeaderboardServer);
                    MoveLeaderboard(titleId2, LiveStats.ALL_LEADERBOARDS,
                        firstLeaderboardServer, _secondLeaderboardServer);

                    // Verify that the LTC file in NPDB has been updated
                    // and that all the leaderboards are now on the new server
                    Xbox360Stats stats = Xbox360Stats.Create(titleId1);
                    StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                    LiveTitleConfig ltc = LiveTitleConfig.FromXml(reader);
                    foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                    {
                        if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                                "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                    {
                        // make sure this is a lbsvr and not a xmatch comparison
                        if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                            && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    stats = Xbox360Stats.Create(titleId2);
                    reader = new StringReader(stats.LiveTitleConfigXml);
                    ltc = LiveTitleConfig.FromXml(reader);
                    foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                    {
                        if (String.Compare(_secondLeaderboardServer, lbc.HostingLbs, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, lbc.HostingLbs,
                                "Hosting server mismatch for leaderboard {0}", lbc.LeaderboardID);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }

                    foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                    {
                        // make sure this is a lbsvr and not a xmatch comparison
                        if ((String.Compare("lbsvr", ib.Interface, true) == 0)
                            && (String.Compare(_secondLeaderboardServer, ib.Server, true) != 0))
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                    if (ResultCode == TEST_RESULTS.FAILED)
                        break;
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId1);
                    ClearTempDirectory(titleId2);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\FuncBoundary.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace LiveStatsTest
{
    /// <summary>
    /// Test group for deploying boundary cases for Xbox 360 Leaderboards.
    /// Includes the following test cases:
    ///     FuncDeployTitleID0x0
    ///     FuncRemoveTitleID0x0
    ///     FuncDeployTitleID0x1
    ///     FuncDeployTitleID0xFFFFFFFF
    ///     FuncDeployMaxLeaderboards
    ///     FuncDeployMaxPlus1Leaderboards
    /// </summary>
    [TestGroup]
    public class FuncBoundaryCases : TestNode
    {
        /// <summary>
        /// Test case to deploy a title with a Title ID of 0x0
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Generic Cases: When specifying ids, try 0, the signed min/max, and unsigned max. Also try underflow and overflow values.
        /// </remarks>
        [TestCase]
        public class FuncDeployTitleID0x0 : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployTitleID0x0");

                uint titleId = 0x00000000;

                DeleteTitle(titleId);

                //Behavior changed by 261872--instead of reporting no leaderboards found in a
                //special manner, it will act as normal, but not have any leaderboards to report.
                try
                {
                    string expectedString1 = "0 leaderboards and 0 competition templates were configured.";
                    string expectedString2 = 
                        "ServerName      TitleID    LBID    Rst t100 TmLB Arb DcyDy ELO_E ELO_K ELO_N ELO_CT Attach MxAttch LastReset\r\n" +
                        "\r\n" +
                        "\r\n" +
                        "Title Configuration Complete.";
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                    if ((_liveStatsTool.Output.IndexOf(expectedString1) > 0) && (_liveStatsTool.Output.IndexOf(expectedString2) > 0))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        _report.Error("Running LiveStats on a title ID of 0x0 successfully deployed. Output:\r\n{0}\r\n",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (LiveStatsException lsEx)
                {
                    // Make sure this didn't generate an unhandled exception
                    if (lsEx.ProcessOutput.IndexOf("Unhandled Exception") >= 0)
                    {
                        _report.Error("Running LiveStats on a title ID of 0x0 threw an unhandled exception. Output:\r\n{0}\r\n",
                            lsEx.ProcessOutput);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to delete a title with a Title ID of 0x0
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Generic Cases: When specifying ids, try 0, the signed min/max, and unsigned max. Also try underflow and overflow values.
        /// </remarks>
        [TestCase]
        public class FuncRemoveTitleID0x0 : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncRemoveTitleID0x0");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Delete TitleID 0
                _liveStatsTool.DeleteLeaderboards(0x00);

                // Verify the leaderboard data on the service after deleting TitleID 0x0
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to deploy a title with a Title ID of 0x1
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Generic Cases: When specifying ids, try 0, the signed min/max, and unsigned max. Also try underflow and overflow values.
        /// </remarks>
        [TestCase]
        public class FuncDeployTitleID0x1 : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployTitleID0x1");

                uint titleId = 0x00000001;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to deploy a title with a Title ID of 0xFFFFFFFF
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Generic Cases: When specifying ids, try 0, the signed min/max, and unsigned max. Also try underflow and overflow values.
        /// </remarks>
        [TestCase]
        public class FuncDeployTitleID0xFFFFFFFF : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployTitleID0xFFFFFFFF");

                uint titleId = 0xFFFFFFFF;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to deploy a title with a maximum number of leaderboards (currently 250)
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Deploy the maximum number of leaderboards that a title is allowed as defined in the LTC file.
        /// Generic Cases: When specifying ids, try 0, the signed min/max, and unsigned max. Also try underflow and overflow values.
        /// </remarks>
        [TestCase]
        public class FuncDeployMaxLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployMaxLeaderboards");

                uint titleId = 0xFFFE07DC;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_max_lbs.xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to deploy a title with a maximum number of leaderboards + 1 (currently 250)
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Negative Functional: Deploy the maximum number of leaderboards that a title is allowed as defined in the LTC file.
        /// Generic Cases: When specifying ids, try 0, the signed min/max, and unsigned max. Also try underflow and overflow values.
        /// </remarks>
        [TestCase]
        public class FuncDeployMaxPlus1Leaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployMaxPlus1Leaderboards");

                uint titleId = 0xFFFE07DC;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_overmax_lbs.xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\FuncOther.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace LiveStatsTest
{
    /// <summary>
    /// Test group for deploying and redeploying Xbox 360 Leaderboards.
    /// Includes the following test cases:
    ///     FuncDeleteTitle
    ///     FuncDeleteInvalidTitle
    ///     FuncReportConfiguration
    ///     FuncInvalidReportConfiguration
    ///     FuncReloadFrontDoor
    ///     FuncReloadWebStats
    /// </summary>
    [TestGroup]
    public class FuncOtherTestCases : TestNode
    {
        /// <summary>
        /// Basic leaderboard deployment delete.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Run /deletetitle with valid parameters.
        /// </remarks>
        [TestCase, DVT]
        public class FuncDeleteTitle : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeleteTitle");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Delete the leaderboard
                _liveStatsTool.DeleteLeaderboards(titleId);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                _report.Debug("The title was deleted. No leaderboards should have been found.");
                // The data shouldn't be there since it was deleted.
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Negative leaderboard deployment delete case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Negative Functional: Run /deletetitle with invalid parameters.
        /// </remarks>
        [TestCase]
        public class FuncDeleteInvalidTitle : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeleteInvalidTitle");

                uint titleId = 0xF0000002;

                // Delete the leaderboard
                _liveStatsTool.DeleteLeaderboards(titleId);
                _report.Debug(_liveStatsTool.Output);

                ResultCode = TEST_RESULTS.PASSED;
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Positive Test /reportconfiguration.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Run /reportconfiguration with a valid title id
        /// </remarks>
        [TestCase]
        public class FuncReportConfiguration : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncReportConfiguration");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Call /reportconfiguration
                string[] lbList = _liveStatsTool.ReportConfiguration(titleId);
                _report.Debug("Leaderboard List:");
                foreach (string lbstr in lbList)
                    _report.Debug("{0}", lbstr);
                _report.Debug(_liveStatsTool.Output);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Negative Test /reportconfiguration.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Negative Functional: Run /reportconfiguration with an invalid title id
        /// </remarks>
        [TestCase]
        public class FuncInvalidReportConfiguration : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncInvalidReportConfiguration");

                uint titleId = 0xF0000002;

                // Call /reportconfiguration
                _liveStatsTool.ReportConfiguration(titleId);
                _report.Debug(_liveStatsTool.Output);
                if (_liveStatsTool.Output.IndexOf("No leaderboards are configured in NPDB for titleID") > 0)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// <summary>
        /// Positive Test /reloadfrontdoor.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Run /reloadfrontdoor with a valid title id
        /// </remarks>
        [TestCase, DVT]
        public class FuncReloadFrontDoor : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncReloadFrontDoor");

                // Call /reloadfrontdoor
                _liveStatsTool.ReloadFrontDoor();
                _report.Debug(_liveStatsTool.Output);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Positive Test /reloadwebstats.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Run /reloadwebstats with a valid title id
        /// </remarks>
        [TestCase, DVT]
        public class FuncReloadWebStats : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncReloadWebStats");

                // Call /relaodwebstats
                _liveStatsTool.ReloadWebStats();
                _report.Debug(_liveStatsTool.Output);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\FuncDeploy.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace LiveStatsTest
{
	/// <summary>
	/// Test group for deploying and redeploying Xbox 360 Leaderboards.
	/// Includes the following test cases:
	///     FuncDeployLeaderboards
	///     FuncDeployLeaderboardsToDifferentServers
	///     FuncRedeployWithNewLeaderboards
	/// </summary>
    [TestGroup]
    public class FuncDeployXbox360Group : TestNode
    {
        /// <summary>
        /// Basic leaderboard deployment test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Run the deploy command against a correctly propped, valid title.
        /// Positive Functional: Deploy an XLAST file with leaderboards that contain all valid column types (Int, LongInt and LongFloat)
        /// Positive Functional: Deploy an XLAST file with a leaderboard that has a context column
        /// Positive Functional: Deploy an XLAST file with a leaderboard that has hidden columns
        /// Positive Functional: Deploy an XLAST file with a leaderboard that is marked hidden
        /// Positive Functional: Deploy an XLAST file that contains multiple Game Modes
        /// </remarks>
        [TestCase, DVT]
        public class FuncDeployLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployLeaderboards");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to deploy a title without user-defined leaderboards
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Deploy an XLAST file with no user-defined leaderboards
        /// </remarks>
        [TestCase]
        public class FuncDeployWithNoUserDefinedLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployWithNoUserDefinedLeaderboards");

                uint titleId = 0xFFFE07E1;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to try to deploy leaderboards on a title that has not yet been deployed.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Negative Functional: Run the deploy command on a title that has not been propped.
        /// </remarks>
        [TestCase]
        public class FuncDeployNonExistantTitle : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployNonExistantTitle");

                uint titleId = 0xFFFE07DC;

                DeleteTitle(titleId);

                // Run LiveStats without first deploying the title - we should return many "0
                // leaderboards changed".  [behavior changed by changelist 261872].  This is
                // fragile, but probably as fragile as the previous string test.
                try
                {
                    string expectedString1 = "0 leaderboards and 0 competition templates were configured.";
                    string expectedString2 = 
                        "ServerName      TitleID    LBID    Rst t100 TmLB Arb DcyDy ELO_E ELO_K ELO_N ELO_CT Attach MxAttch LastReset\r\n" +
                        "\r\n" +
                        "\r\n" +
                        "Title Configuration Complete.";
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                    if ((_liveStatsTool.Output.IndexOf(expectedString1) > 0) && (_liveStatsTool.Output.IndexOf(expectedString2) > 0))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        _report.Error("Running LiveStats on a non-deployed found leaderboards. Output:\r\n{0}\r\n",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (LiveStatsException lsEx)
                {
                    // Make sure this didn't generate an unhandled exception
                    if (lsEx.ProcessOutput.IndexOf("Unhandled Exception") >= 0)
                    {
                        _report.Error("Running LiveStats on a non-deployed title threw an unhandled exception. Output:\r\n{0}\r\n",
                            lsEx.ProcessOutput);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to verify the deploywebdbonlylb command
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Redeploy leaderboards using the /deploywebdbonlylb command
        /// Negative Functional: Deploy leaderboards using only the /deploywebdbonlylb command
        /// </remarks>
        [TestCase]
        public class FuncDeployToWebOnly : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployToWebOnly");

                uint titleId = 0xFFFE07E0;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // First try running the command without any leaderboard data in the service
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".XLAST");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);
                try
                {
                    _liveStatsTool.DeployWebOnlyLeaderboard(titleId);
                    _report.Error("Running the deploywebdbonlylb command without existing leaderboard data "+
                        "should not succeed. Output:\r\n{0}", _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (LiveStatsException lsEx)
                {
                    // Make sure this didn't generate an unhandled exception
                    if (lsEx.ProcessOutput.IndexOf("Unhandled Exception") >= 0)
                    {
                        _report.Error("Running the deploywebdbonlylb command without existing leaderboard data " +
                            "threw an unhandled exception. Output:\r\n{0}\r\n", lsEx.ProcessOutput);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Now deploy the leaderboard data normally
                // (should not need to force this since the previous command did nothing)
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                ResultCode = VerifyXbox360StatsData(titleId);

                // If there's a failure at this point, don't bother continuing the test
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Delete the data from WebDB
                    DeleteWebDbLeaderboardInfo(titleId);

                    // Now redeploy just the webdb stuff
                    _liveStatsTool.DeployWebOnlyLeaderboard(titleId);

                    // Verify that all is good
                    ResultCode = VerifyXbox360StatsData(titleId);
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to deploy a different number of leaderboards than the LTC specifies
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Deploy an XLAST file that contains fewer leaderboards than the LTC file
        /// Negative Functional: Run the deploy command on an XLAST file that contains more leaderboards than the LTC file
        /// </remarks>
        [TestCase]
        public class FuncDeployUnequalLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployUnequalLeaderboards");

                uint titleId = 0xFFFE07DD;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Generate the LTC file
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.CreateXbox360LTCFile(0, 0);
                
                // Add a dummy entry into the LTC file so that we have more leaderboards
                // in the LTC than in the XLAST file.
                LiveTitleConfig ltc = (LiveTitleConfig)ConfigFileSerializer.FromXml
                    (typeof(LiveTitleConfig), _liveTitleTool.LTCPath);
                LeaderboardConfig dummyLb = ltc.LeaderboardConfigs.LeaderboardConfigCollection.Add();
                dummyLb.LeaderboardID = 3;
                dummyLb.HostingLbs = _liveTitleTool.LeaderboardServer;
                dummyLb.IsCompetition = false;
                ConfigFileSerializer.ToXml(_liveTitleTool.LTCPath, ltc);

                // Deploy the title with this updated ltc file
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // This deployment should succeed
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data, but not the leaderboard locations
                ResultCode = VerifyXbox360StatsData(titleId, false);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Now remove a couple leaderboard config lines from the LTC and try to deploy
                    ltc.LeaderboardConfigs.LeaderboardConfigCollection.RemoveAt(0);
                    ltc.LeaderboardConfigs.LeaderboardConfigCollection.RemoveAt(0);
                    ConfigFileSerializer.ToXml(_liveTitleTool.LTCPath, ltc);
                    _liveTitleTool.DeployXbox360Title(titleId, false, false);

                    // We should get an error with this deployment
                    try
                    {
                        _liveStatsTool.DeployXbox360Leaderboard(titleId, true);
                        _report.Warn("Running LiveStats with fewer leaderboard configs in the LTC file should not succeed.\r\n{0}",
                            _liveStatsTool.Output);
                    }
                    catch (LiveStatsException lsEx)
                    {
                        // Make sure this didn't generate an unhandled exception
                        if (lsEx.ProcessOutput.IndexOf("Unhandled Exception") >= 0)
                            throw;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Redeploy the same File with no changes.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Run the deploy command to redeploy the same title with no config changes
        /// </remarks>
        [TestCase, DVT]
        public class FuncReDeployLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncReDeployLeaderboards");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Prop the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data on the service
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to add leaderboards to an existing title
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Add leaderboards and redeploy to the same leaderboard server
        /// </remarks>
        [TestCase, DVT]
        public class FuncRedeployWithNewLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncRedeployWithNewLeaderboards");

                uint titleId = 0xFFFE07DC;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Deploy the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.DeployXbox360Title(titleId, true, false);
                
                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the leaderboard data
                ResultCode = VerifyXbox360StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Deploy the updated XLAST file
                    _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_new_lbs.xlast");
                    _liveTitleTool.CreateXbox360LTCFile(0, 0);
                    _liveTitleTool.DeployXbox360Title(titleId, false, false);

                    // Deploy the new leaderboards
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                    _report.Debug(_liveStatsTool.Output);

                    // Verify the updated leaderboard data
                    ResultCode = VerifyXbox360StatsData(titleId);
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Deploys leaderboards for one title to two different leaderboard servers.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Add leaderboards and redeploy to a different leaderboard server
        /// </remarks>
        [TestCase]
        public class FuncDeployLeaderboardsToDifferentServers : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployLeaderboardsToDifferentServers");

                uint titleId = 0xFFFE07DB;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Deploy the title
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.CreateXbox360LTCFile(0, 0);
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Save a copy of the leaderboard configs from the LTC file for later verification
                LiveTitleConfig origLtc = (LiveTitleConfig)ConfigFileSerializer.FromXml
                    (typeof(LiveTitleConfig), _liveTitleTool.LTCPath);

                // Redeploy the title with leaderboards added to a different lb server
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_new_leaderboards.xlast");
                _liveTitleTool.LeaderboardServer = _secondLeaderboardServer;
                _liveTitleTool.CreateXbox360LTCFile(0, 0);
                _liveTitleTool.DeployXbox360Title(titleId, false, false);

                // Deploy the new leaderboards
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Verify the new ltc file has all the original leaderboard configs on their original server
                // and any new configs on the new server.
                LiveTitleConfig newLtc = (LiveTitleConfig)ConfigFileSerializer.FromXml
                    (typeof(LiveTitleConfig), _liveTitleTool.LTCPath);
                _report.Info("Verifying the Leaderboard server assignments in the LTC file...");
                ResultCode = StatsVerifier.VerifyLTCLeaderboardAssignments(_secondLeaderboardServer, newLtc,
                    origLtc.LeaderboardConfigs.LeaderboardConfigCollection);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Verify the leaderboards have all been deployed to the correct servers
                    ResultCode = VerifyXbox360StatsData(titleId);
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to change the settings of an existing leaderboard and redeploy
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Change an existing leaderboard and redeploy without and then with the /force parameter
        /// </remarks>
        [TestCase]
        public class FuncChangeAndRedeploy : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncChangeAndRedeploy");

                uint titleId = 0xFFFE07DB;
                string xlastName, newXlastName;
                string forceText = "/force flag was not specified and is necessary to continue.";
                //string noforceText = "Updating LBID 1 Without a Reset";
                string [] lbConfig;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                ResultCode = TEST_RESULTS.PASSED;

                // Prop the title and deploy the leaderboards
                _report.Info("Deploying Basic Xlast");
                xlastName = Path.Combine(_tempPath, titleId.ToString("X8") + ".XLAST");
                _liveTitleTool.XlastPath = xlastName;
                _liveTitleTool.CreateXbox360LTCFile();
                _liveTitleTool.DeployXbox360Title(titleId, true, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                _report.Info("Deploying Modified ResetType");
                // Load the XLAST file
                XboxLiveSubmissionProject xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), xlastName);
                // Modify the Reset Type and redeploy
                xlast.GameConfigProject.StatsViews.StatsViewCollection[0].resetType = resetType.Monthly;
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_ResetType.xlast");
                ConfigFileSerializer.ToXml(newXlastName, xlast);
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId, false, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                if (_liveStatsTool.Output.IndexOf(forceText) >= 0)
                {
                    _report.Error("Changing the ResetType value should not require the force parameter.\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    lbConfig = GetLbConfigFromOutput(1);
                    if (lbConfig != null)
                    {
                        // The Reset Type value is in the 4th column
                        if (lbConfig[3] != ((int)xlast.GameConfigProject.StatsViews.StatsViewCollection[0].resetType).ToString())
                        {
                            _report.Error(
                                ((int)xlast.GameConfigProject.StatsViews.StatsViewCollection[0].resetType).ToString(),
                                lbConfig[3], "Reset Type didn't get updated.");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                            {
                                _report.Error("The leaderboard data on the server doesn't match the xlast file");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        _report.Error("Unable to retrieve the leaderboard configuration from the LiveStats output.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                _report.Info("Deploying Modified Entry Expiration");
                // Modify the Entry Expiration and redeploy
                xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), xlastName);
                xlast.GameConfigProject.StatsViews.StatsViewCollection[0].entryExpiration = 45;
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_EntryExpiration.xlast");
                ConfigFileSerializer.ToXml(newXlastName, xlast);
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId, false, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                if (_liveStatsTool.Output.IndexOf(forceText) >= 0)
                {
                    _report.Error("Changing the Entry Expiration value should not require the force parameter.\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    lbConfig = GetLbConfigFromOutput(1);
                    if (lbConfig != null)
                    {
                        // The Entry Expiration value is in the 8th column
                        if (lbConfig[7] != xlast.GameConfigProject.StatsViews.StatsViewCollection[0].entryExpiration.ToString())
                        {
                            _report.Error(
                                xlast.GameConfigProject.StatsViews.StatsViewCollection[0].entryExpiration.ToString(),
                                lbConfig[7], "Entry Expiration didn't get updated.");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                            {
                                _report.Error("The leaderboard data on the server doesn't match the xlast file");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        _report.Error("Unable to retrieve the leaderboard configuration from the LiveStats output.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                _report.Info("Deploying modified Top 100");
                // Modify the Top 100 flag and redeploy
                xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), xlastName);
                xlast.GameConfigProject.StatsViews.StatsViewCollection[0].topEntries = 100;
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_Top100.xlast");
                ConfigFileSerializer.ToXml(newXlastName, xlast);
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId, false, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                if (_liveStatsTool.Output.IndexOf(forceText) >= 0)
                {
                    _report.Error("Changing the Top100 value should not require the force parameter.\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    lbConfig = GetLbConfigFromOutput(1);
                    if (lbConfig != null)
                    {
                        // The Top 100 value is in the 5th column
                        if (lbConfig[4] != "1")
                        {
                            _report.Error("1", lbConfig[7], "Top 100 flag didn't get updated.");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                            {
                                _report.Error("The leaderboard data on the server doesn't match the xlast file");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        _report.Error("Unable to retrieve the leaderboard configuration from the LiveStats output.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                _report.Info("Deploying modified maxAttachments");
                // Modify the maxAttachments value and redeploy
                xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), xlastName);
                xlast.GameConfigProject.StatsViews.StatsViewCollection[0].maxAttachments = 100;
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_MaxAttachments.xlast");
                ConfigFileSerializer.ToXml(newXlastName, xlast);
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId);
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                if (_liveStatsTool.Output.IndexOf(forceText) >= 0)
                {
                    _report.Error("Changing the maxAttachments value should not require the force parameter.\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    lbConfig = GetLbConfigFromOutput(1);
                    if (lbConfig != null)
                    {
                        // The Attachments value is in the 13th column
                        if (lbConfig[12] != "100")
                        {
                            StatsVerifier.ReportVerificationFailure("100", lbConfig[12], "Max Attachments value didn't get updated.");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                            {
                                _report.Error("The leaderboard data on the server doesn't match the xlast file");
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                    else
                    {
                        _report.Error("Unable to retrieve the leaderboard configuration from the LiveStats output.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                _report.Info("Deploying modified Arbitration Flag");
                // Modify the Requires Arbitration flag and redeploy
                xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), xlastName);
                xlast.GameConfigProject.StatsViews.StatsViewCollection[0].arbitrated = false;
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_Arbitrated.xlast");
                ConfigFileSerializer.ToXml(newXlastName, xlast);
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId, false, false);
                try
                {
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect the changed Requires Arbitration value.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                _liveStatsTool.DeployXbox360Leaderboard(titleId, true);
                lbConfig = GetLbConfigFromOutput(1);
                if (lbConfig != null)
                {
                    // The Requires Arbitration value is in the 7th column
                    if (lbConfig[6] != "F")
                    {
                        StatsVerifier.ReportVerificationFailure("F", lbConfig[7], "Requires Arbitration flag didn't get updated.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                        {
                            _report.Error("The leaderboard data on the server doesn't match the xlast file");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                }
                else
                {
                    _report.Error("Unable to retrieve the leaderboard configuration from the LiveStats output.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                _report.Info("Deploying modified column type");
                // Modify the column type and redeploy
                // NOTE: This will require the /force parameter to be successfully deployed,
                //       so the xlast file from the preceeding case needs to be used to make sure other changes don't affect it
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_modify_column.xlast");
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId);
                try
                {
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect the modified column type that should require a /force.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                _liveStatsTool.DeployXbox360Leaderboard(titleId, true);
                if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                {
                    _report.Error("The leaderboard data on the server doesn't match the xlast file\r\n{0}", _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                _report.Info("Deploying removed column");
                // Remove a column and redeploy
                // NOTE: This will require the /force parameter to be successfully deployed,
                //       so the xlast file from the preceeding case needs to be used to make sure other changes don't affect it
                newXlastName = Path.Combine(_tempPath, titleId.ToString("X8") + "_remove_column.xlast");
                _liveTitleTool.XlastPath = newXlastName;
                _liveTitleTool.DeployXbox360Title(titleId);
                try
                {
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect the removed column that should require a /force.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        _liveStatsTool.DeployXbox360Leaderboard(titleId, true);
                        if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                        {
                            _report.Error("The leaderboard data on the server doesn't match the xlast file");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                }

                _report.Info("Deploying added column");
                // Add a column and redeploy
                // Using the original xlast file to re-add the removed column
                _liveTitleTool.XlastPath = xlastName;
                _liveTitleTool.DeployXbox360Title(titleId);
                try
                {
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect the added column that should require a /force.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        _liveStatsTool.DeployXbox360Leaderboard(titleId, true);
                        if (VerifyXbox360StatsData(titleId) == TEST_RESULTS.FAILED)
                        {
                            _report.Error("The leaderboard data on the server doesn't match the xlast file");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to delete an existing leaderboard and redeploy
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Delete a leaderboard from the title and redeploy without and then with the /force parameter
        /// </remarks>
        [TestCase]
        public class FuncDeleteAndRedeploy : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeleteAndRedeploy");

                uint titleId = 0xFFFE07DB;
                string forceText = "/force flag was not specified and is necessary to continue.";

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                ResultCode = TEST_RESULTS.PASSED;

                // Deploy the title and the leaderboards
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _liveTitleTool.CreateXbox360LTCFile();
                _liveTitleTool.DeployXbox360Title(titleId, true, false);
                _liveStatsTool.DeployXbox360Leaderboard(titleId, false);

                // Load the XLAST file and delete leaderboard 1
                XboxLiveSubmissionProject xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), _liveTitleTool.XlastPath);
                xlast.GameConfigProject.StatsViews.StatsViewCollection.RemoveAt(0);
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Redeploy the title and rerun LiveStats without Force, then with Force
                _liveTitleTool.DeployXbox360Title(titleId, false, false);
                try
                {
                    _liveStatsTool.DeployXbox360Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect a deleted leaderboard.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                _liveStatsTool.DeployXbox360Leaderboard(titleId, true);
                if (GetLbConfigFromOutput(1) != null)
                {
                    _report.Error("LiveStats did not correctly delete leaderboard 1.\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }
    }

    /// <summary>
    /// Test group for deploying and redeploying Xbox 1 Leaderboards.
    /// Includes the following test cases:
    ///     FuncDeployLeaderboards
    ///     FuncDeployWithoutXscFile
    ///     FuncDeleteAndRedeploy
    ///     FuncMoveSingleLeaderboard
    /// </summary>
    [TestGroup]
    public class FuncDeployXbox1Group : TestNode
    {
        /// <summary>
        /// Basic Xbox 1 leaderboard deployment case
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Deploy an Xbox1 title that has uses all supported leaderboard types
        /// </remarks>
        [TestCase, DVT]
        public class FuncDeployLeaderboards : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployLeaderboards");

                uint titleId = 0xFFFFAB08;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Deploy the title
                _liveTitleTool.XBOXPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xbox");
                _liveTitleTool.XSCPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xsc");
                _liveTitleTool.DeployXbox1Title(titleId);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox1Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                ResultCode = VerifyXbox1StatsData(titleId);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Test case to try to deploy leaderboards for an Xbox 1 title without an XSC file
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Negative Functional: Run the deploy command on an Xbox1 title that has been propped without an XSC file
        /// </remarks>
        [TestCase, DVT]
        public class FuncDeployWithoutXscFile : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeployWithoutXscFile");

                uint titleId = 0xFFFFAB09;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Deploy the title without the xsc file
                _liveTitleTool.XBOXPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xbox");
                _liveTitleTool.DeployXbox1Title(titleId);

                // Try to deploy the leaderboards for this title (error expected)
                try
                {
                    _liveStatsTool.DeployXbox1Leaderboard(titleId, false);
                    _report.Error("Running LiveStats on an Xbox1 title without an XSC file should not succeed. Output:\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (LiveStatsException lsEx)
                {
                    // Make sure this didn't generate an unhandled exception
                    if (lsEx.ProcessOutput.IndexOf("Unhandled Exception") >= 0)
                    {
                        _report.Error("Running LiveStats on an Xbox1 title without an XSC file generated an unhandled exception. Output:\r\n{0}",
                            lsEx.ProcessOutput);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }

        }

        /// <summary>
        /// Test case to delete an existing leaderboard and redeploy
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Delete a Xbox1 leaderboard from the title and redeploy without and then with the /force parameter
        /// Positive Functional: Add a Competition Templates to an Xbox1 title and redeploy
        /// </remarks>
        [TestCase]
        public class FuncDeleteAndRedeploy : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncDeleteAndRedeploy");

                uint titleId = 0xFFFFAB08;
                string forceText = "/force flag was not specified and is necessary to continue.";

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                ResultCode = TEST_RESULTS.PASSED;

                // Deploy the title and the leaderboards
                _liveTitleTool.XBOXPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xbox");
                _liveTitleTool.XSCPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xsc");
                _liveTitleTool.DeployXbox1Title(titleId);
                _liveStatsTool.DeployXbox1Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Redeploy the title with deleted leaderboards and rerun LiveStats without Force, then with Force
                _liveTitleTool.XSCPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_deleted_lbs.xsc");
                _liveTitleTool.DeployXbox1Title(titleId);
                try
                {
                    _liveStatsTool.DeployXbox1Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect a deleted leaderboard.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                _liveStatsTool.DeployXbox1Leaderboard(titleId, true);
                if (GetLbConfigFromOutput(9) != null)
                {
                    _report.Error("LiveStats did not correctly delete leaderboard 1.\r\n{0}",
                        _liveStatsTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Redeploy the title with added leaderboard and rerun LiveStats without Force, then with Force
                _liveTitleTool.XSCPath = Path.Combine(_tempPath, titleId.ToString("X8") + "_new_lbs.xsc");
                _liveTitleTool.DeployXbox1Title(titleId);
                try
                {
                    _liveStatsTool.DeployXbox1Leaderboard(titleId, false);
                }
                catch (LiveStatsException)
                {
                    if (_liveStatsTool.Output.IndexOf(forceText) < 0)
                    {
                        _report.Error("LiveStats did not detect the changed ResetType value.\r\n{0}",
                            _liveStatsTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                _liveStatsTool.DeployXbox1Leaderboard(titleId, true);

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ResultCode = VerifyXbox1StatsData(titleId);
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }

        /// <summary>
        /// Move a single Leaderboard.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// Positive Functional: Move a Team leaderboard for an Xbox1 title.
        /// </remarks>
        [TestCase, DVT]
        public class FuncMoveSingleLeaderboard : LiveStatsTestBase
        {
            protected override void Execute()
            {
                BeginCase("FuncMoveSingleLeaderboard");

                uint titleId = 0xFFFFAB08;

                DeleteTitle(titleId);
                CopyInputFiles(titleId);

                // Prop the title
                _liveTitleTool.XBOXPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xbox");
                _liveTitleTool.XSCPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xsc");
                _liveTitleTool.DeployXbox1Title(titleId);

                // Deploy the leaderboards
                _liveStatsTool.DeployXbox1Leaderboard(titleId, false);
                _report.Debug(_liveStatsTool.Output);

                // Move a single leaderboard to a new server
                LiveTitleConfig ltc = LiveTitleConfig.FromXml(_liveTitleTool.LTCPath);
                MoveLeaderboard(titleId, ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID,
                    ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs, _secondLeaderboardServer);

                // Verify that the LTC file in NPDB has been updated
                // and that the leaderboard is now on that server
                ResultCode = TEST_RESULTS.PASSED;
                Xbox1Stats stats = Xbox1Stats.Create(titleId);
                StringReader reader = new StringReader(stats.LiveTitleConfigXml);
                ltc = LiveTitleConfig.FromXml(reader);
                if (String.Compare(ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs, _secondLeaderboardServer, true) != 0)
                {
                    StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].HostingLbs,
                        "Hosting server mismatch for leaderboard {0}", ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                foreach (InterfaceBucket ib in stats.InterfaceBuckets)
                {
                    if (ib.Bucket == ltc.LeaderboardConfigs.LeaderboardConfigCollection[1].LeaderboardID)
                    {
                        if (String.Compare(ib.Server, _secondLeaderboardServer, true) != 0)
                        {
                            StatsVerifier.ReportVerificationFailure(_secondLeaderboardServer, ib.Server,
                                "Interface bucket server mismatch for leaderboard {0}", ib.Bucket);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                        break;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ClearTempDirectory(titleId);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\LiveStatsTests.cs ===
using System;
using ServerTestFramework;

[assembly: RootNode(typeof(LiveStatsTest.LiveStatsTests))]

namespace LiveStatsTest
{
    /// <summary>
	/// Summary description for LiveStatsTest.
	/// </summary>
    [Owner("jeffng"), TestFrequency("Regression")]
	public class LiveStatsTests : TestNode
	{

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\SVLeaderboard.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.protocol;

namespace LiveStatsTest
{
	/// <summary>
	/// This class represents a standard method of defining a leaderboard within
	/// the Stats Verification methods.
	/// </summary>
	/// <remarks>
	/// This class and it's supporting SV* classes are needed to normalize StatsView
	/// leaderboard definitions from an XLAST file with TrueSkill leaderboard definitions.
	/// </remarks>
	public class SVLeaderboard
	{
        /*
                Byte    Server thinks       Tools think

                0       Never               Weekly
                1       Weekly              Biweekly
                2       Monthly             Monthly
                3       BiMonthly           BiMonthly
                4       Quarterly           Annually
                5       SemiAnnually        Never
                6       Annually            NA
        */
        private static int [] resetTypeMapping = new int [] {1,4,2,3,6,0};
        public const uint ContextGameType = 0x0000800A;
        public const uint ContextGameMode = 0x0000800B;
        public const int GameTypeContextRanked = 0;
        public const int GameTypeContextUnranked = 1;

        private uint _leaderboardId;
        private int _resetType;
        private bool _top100;
        private bool _arbitrated;
        private int _decayDays;
        private int _maxAttachments;
        private SVLocalizedDescription [] _names;
        private SVLeaderboardColumn [] _columns;
        private SVRawAttribute [] _rawAttributes;

        protected SVLeaderboard() {}

		public SVLeaderboard(uint lbId) : this()
		{
            _leaderboardId = lbId;
		}

        #region Properties
        public uint LeaderboardId
        {
            get { return _leaderboardId; }
            set { _leaderboardId = value; }
        }

        public bool IsTrueSkill
        {
            get { return (_leaderboardId & 0xFFFF0000) == 0xFFFF0000; }
        }

        public int ResetType
        {
            get { return _resetType; }
            set { _resetType = value; }
        }

        public bool Top100
        {
            get { return _top100; }
            set { _top100 = value; }
        }

        public bool Arbitrated
        {
            get { return _arbitrated; }
            set { _arbitrated = value; }
        }

        public int DecayDays
        {
            get { return _decayDays; }
            set { _decayDays = value; }
        }

        public int MaxAttachments
        {
            get { return _maxAttachments; }
            set { _maxAttachments = value; }
        }

        public SVLocalizedDescription [] Names
        {
            get { return _names; }
            set { _names = value; }
        }

        public SVLeaderboardColumn [] Columns
        {
            get { return _columns; }
            set { _columns = value; }
        }

        public SVRawAttribute [] RawAttributes
        {
            get { return _rawAttributes; }
            set { _rawAttributes = value; }
        }
        #endregion

        /// <summary>
        /// Static method to extract user-defined and TrueSkill leaderboards from an XLAST file.
        /// </summary>
        /// <param name="xlast">An XboxLiveSubmissionProject object representing an XLAST file.</param>
        /// <returns>A hashtable containing all user-defined and TrueSkill leaderboards from the XLAST file.</returns>
        public static Hashtable GetLeaderboardsFromXlast(XboxLiveSubmissionProject xlast)
        {
            Hashtable userLbs, trueSkillLbs;

            // First munge the StatsViews into SVLeaderboard objects
            userLbs = GetUserLeaderboards(xlast);

            // Now create TrueSkill leaderboards from the GameModes
            trueSkillLbs = GetTrueSkillLeaderboards(xlast);

            // Finally, combine the two hashtables
            foreach (DictionaryEntry lb in trueSkillLbs)
            {
                userLbs.Add(lb.Key, lb.Value);
            }

            return userLbs;
        }

        private static Hashtable GetUserLeaderboards(XboxLiveSubmissionProject xlast)
        {
            SVLeaderboard lb;
            Hashtable userLbs = new Hashtable();
            int i;

            foreach (StatsView userLb in xlast.GameConfigProject.StatsViews.StatsViewCollection)
            {
                lb = new SVLeaderboard(userLb.id);
                lb.Arbitrated = userLb.arbitrated;
                lb.DecayDays = userLb.entryExpiration;
                lb.ResetType = MapResetType(userLb.resetType);
                lb.Top100 = (userLb.topEntries == 100);
                lb.MaxAttachments = userLb.maxAttachments;
                lb.Names = GetLocalizedStrings(userLb.stringId, xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);

                // Process the columns
                i = 0;
                lb.Columns = new SVLeaderboardColumn[userLb.Columns.Count];
                foreach (ViewFieldType column in userLb.Columns.FieldCollection)
                {
                    lb.Columns[i] = new SVLeaderboardColumn(((uint)column.attributeId).ToString(), (uint)column.attributeId,
                        string.Format("attr[{0}]!=null?attr[{0}]:0", (uint)column.attributeId));
                    lb.Columns[i++].Descriptions = GetLocalizedStrings(column.stringId,
                        xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                }

                lb.RawAttributes = GetRawAttributesFromLbColumn(lb.Columns);
                userLbs.Add(userLb.id, lb);
            }

            return userLbs;
        }

        private static Hashtable GetTrueSkillLeaderboards(XboxLiveSubmissionProject xlast)
        {
            uint lbID;
            SVLeaderboard lb;
            Hashtable trueSkillLeaderboards = new Hashtable();

            foreach (ServerTestFramework.STFTools.ConfigFiles.GameMode gm in xlast.GameConfigProject.GameModes.GameModeCollection)
            {
                Context c = FindGameTypeContext(xlast.GameConfigProject.Contexts.ContextCollection);

                /*
                    The enumeration for this special GameType context is guaranteed to be 
                        0 - Ranked
                        1 - Standard
                */
                foreach (ContextValue cv in c.ContextValueCollection)
                {
                    if (cv.value == GameTypeContextRanked)
                    {
                        if (cv.friendlyName == "RANKED")
                        {
                            lbID = 0xFFFF0000 + (uint)gm.value;
                        }
                        else
                        {
                            throw new StfException("GAME_TYPE Context 0 is not RANKED - Has it been hand edited?");
                        }
                    }
                    else if (cv.value == GameTypeContextUnranked)
                    {
                        if (cv.friendlyName == "STANDARD")
                        {
                            lbID = 0xFFFE0000 + (uint)gm.value;
                        }
                        else
                        {
                            throw new StfException("GAME_TYPE Context 1 is not STANDARD - Has it been hand edited");     
                        }
                    }
                    else
                    {
                        continue; //not supported
                    }

                    lb = new SVLeaderboard(lbID);
                    lb.Arbitrated = (lbID & 0xFFFF0000) == 0xFFFF0000;
                    lb.Columns = GetTrueSkillColumns(xlast.GameConfigProject.LocalizedStrings.defaultLocale);

                    SVLocalizedDescription [] localizedGameModes = GetLocalizedStrings(gm.stringId,
                        xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                    lb.Names = GetLocalizedTrueSkillDescriptions(localizedGameModes, cv,
                        xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);

                    lb.RawAttributes = GetRawAttributesFromLbColumn(lb.Columns);
                    trueSkillLeaderboards.Add(lbID, lb);
                }
            }

            return trueSkillLeaderboards;
        }

        private static int MapResetType(resetType xlastResetType)
        {
            return resetTypeMapping[(int)xlastResetType];
        }

        private static Context FindGameTypeContext(ContextCollection contexts)
        {
            foreach (Context context in contexts)
            {
                if (uint.Parse(context.id.Substring(2), System.Globalization.NumberStyles.HexNumber) == ContextGameType)
                {
                    return context;
                }
            }

            return null;
        }

        private static SVRawAttribute [] GetRawAttributesFromLbColumn(SVLeaderboardColumn [] columns)
        {
            SVRawAttribute [] attributes = null;

            attributes = new SVRawAttribute[columns.Length];

            for (int i = 0; i < attributes.Length; i++)
            {
                attributes[i] = new SVRawAttribute((int)columns[i].AttributeId, false);
            }

            return attributes;
        }

        private static SVLocalizedDescription [] GetLocalizedStrings(ushort stringId, LocalizedStringCollection xlastStrings)
        {
            SVLocalizedDescription [] strings = null;

            foreach (LocalizedString str in xlastStrings)
            {
                if (str.id == stringId)
                {
                    strings = new SVLocalizedDescription[str.TranslationCollection.Count];
                    for (int i = 0; i < strings.Length; i++)
                    {
                        strings[i] = new SVLocalizedDescription(
                            str.TranslationCollection[i].locale,
                            str.TranslationCollection[i].Value);
                    }
                    break;
                }
            }

            return strings;
        }

        private static SVLocalizedDescription [] GetLocalizedTrueSkillDescriptions(SVLocalizedDescription [] gameModes, ContextValue cv, LocalizedStringCollection xlastStrings)
        {
            SVLocalizedDescription [] localizedContexts = GetLocalizedStrings(cv.stringId, xlastStrings);
            
            foreach (SVLocalizedDescription localizedDes in gameModes)
            {
                string context = cv.friendlyName; //give it a default of friendly name
                foreach (SVLocalizedDescription localizedCon in localizedContexts)
                {
                    if (localizedDes.Locale == localizedCon.Locale)
                    {
                        context = localizedCon.Description;
                        break;
                    }
                }
                
                localizedDes.Description = String.Format("{0}-{1} TrueSkill", localizedDes.Description, context);
            }
            
            return gameModes;
        }

        enum SpecialAttribEnum
        {
            Rank                = SpecialAttrib.Rank,
            Rating              = SpecialAttrib.Rating,
            Nickname            = SpecialAttrib.Nickname,
            Skill               = SpecialAttrib.Skill,
            GamesPlayed         = SpecialAttrib.GamesPlayed,
            Mu                  = SpecialAttrib.Mu,
            Sigma               = SpecialAttrib.Sigma
        }

        private static SVLeaderboardColumn [] GetTrueSkillColumns(string defaultLocale)
        {
            /*
              TRUSKILL have 4 columns

                public const ushort Skill               = 61;
                public const ushort GamesPlayed         = 62;
                public const ushort Mu                  = 63;
                public const ushort Sigma               = 64;

              On top of usual:

                public const ushort Rank                = 0xFFFF;
                public const ushort Rating              = 0xFFFE;
                public const ushort Nickname            = 0xFFFD;
            */
            int [] arrValues = (int [])Enum.GetValues(typeof(SpecialAttribEnum));
            SVLeaderboardColumn [] arrRet = new SVLeaderboardColumn[arrValues.Length];

            for (int i = 0; i < arrRet.Length; i++)
            {
                SpecialAttribEnum mapValue = (SpecialAttribEnum)arrValues[i];
                arrRet[i] = new SVLeaderboardColumn(((uint)mapValue).ToString(), (uint)mapValue,
                    string.Format("attr[{0}]!=null?attr[{0}]:0", (uint)mapValue));
                arrRet[i].Descriptions    = new SVLocalizedDescription[1];
                arrRet[i].Descriptions[0] = new SVLocalizedDescription(defaultLocale, mapValue.ToString());
                arrRet[i].ReturnType = 12;  // it's always 12
            }

            return arrRet;
        }
    }

    /// <summary>
    /// Leaderboard column definition class for both user-defined and TrueSkill leaderboards.
    /// </summary>
    public class SVLeaderboardColumn
    {
        public string Name;
        public int ReturnType;
        public string Formula;
        public SVLocalizedDescription [] Descriptions;

        // xlast fields
        public uint AttributeId;
        public uint PropertyId;
        public string Aggregation;

        /// <summary>
        /// Creates an SVLeaderboardColumn object with the given name, attribute Id and formula
        /// </summary>
        /// <param name="name">The friendly name of the column</param>
        /// <param name="attributeId">The attribute ID of the column</param>
        /// <param name="formula">The column formula.</param>
        public SVLeaderboardColumn(string name, uint attributeId, string formula)
        {
            Name = name;
            AttributeId = attributeId;
            Formula = formula;
            ReturnType = 12;
        }

        public SVLeaderboardColumn() {}
    }

    /// <summary>
    /// This class represents a single string translation from an XLAST file.
    /// </summary>
    public class SVLocalizedDescription
    {
        public string Locale;
        public string Description;

        public SVLocalizedDescription(string locale, string description)
        {
            Locale = locale;
            Description = description;
        }

        public SVLocalizedDescription() {}
    }

    /// <summary>
    /// This class represents the raw attributes for an Xbox 1 leaderboard.
    /// </summary>
    public class SVRawAttribute
    {
        public int Id;
        public bool IsPUID;

        public SVRawAttribute(int id, bool isPuid)
        {
            Id = id;
            IsPUID = isPuid;
        }

        public SVRawAttribute() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\LiveStatsTestBase.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.protocol;

namespace LiveStatsTest
{
    /// <summary>
    /// Summary description for LiveStatsTestBase.
    ///
    /// LiveStats has been assigned the following Title ID ranges:
    /// 0xFFFE07DB - 0xFFFE07E2     Xbox 360
    /// 0xFFFFAB08 - 0xFFFFAB0F     Xbox 1
    ///
    /// </summary>
    public class LiveStatsTestBase : TestBase
    {
        public const uint ContextGameType = 0x0000800A;
        public const uint ContextGameMode = 0x0000800B;
        public const int GameTypeContextRanked = 0;
        public const int GameTypeContextUnranked = 1;
        protected const int MaxStressIterations = 100;

        protected Report _report = new Report("LiveStatsTest");
        protected LiveTitle _liveTitleTool;
        protected LiveStats _liveStatsTool;
        protected string _inputFilesPath;
        protected string _tempPath;
        protected string _defaultLeaderboardServer;
        protected string _secondLeaderboardServer;


        public LiveStatsTestBase()
        {
            _liveTitleTool = new LiveTitle();
            _liveStatsTool = new LiveStats();

            // Store the default leaderboard server from the LiveTitle tool
            _defaultLeaderboardServer = _liveTitleTool.LeaderboardServer;
            //_report.Debug("Using default leaderboard server: {0}", _defaultLeaderboardServer);

            // Get a second leaderboard server from NPDB (for multi-lb tests)
            string[] lbsvrlist = Global.XEnv.GetServerListByInterface(Interface.lbsvr);
            foreach (string lbsvrtempstr in lbsvrlist)
            {
                if (String.Compare(_defaultLeaderboardServer, lbsvrtempstr, true) != 0)
                {
                    // We found a lbsvr that isn't the default used by LiveTitle
                    _secondLeaderboardServer = lbsvrtempstr;
                    //_report.Debug("Using second leaderboard server: {0}", _secondLeaderboardServer);
                    break;
                }
                //_report.Debug("Leaderboard Server Found: {0}", lbsvrtempstr);
            }
            if (_secondLeaderboardServer == "")
            {
                _secondLeaderboardServer = _defaultLeaderboardServer;
                _report.Warn("Unable to Get a second leaderboard server from npdb. Using {0} as secondleaderboard server.", _secondLeaderboardServer);
            }

            // Query the Global object to get our test-specific data
            XmlNode liveTitleConfig = Global.Config.SelectSingleNode("descendant::LiveStatsTest");
            if (liveTitleConfig != null)
            {
                foreach (XmlNode setting in liveTitleConfig.ChildNodes)
                {
                    if (String.Compare(setting.Name, "DefaultToolPath", true) == 0)
                    {
                        _liveTitleTool.LiveTitlePath = Path.Combine(
                            Path.GetFullPath(setting.InnerText), "LiveTitle.exe");
                        _liveStatsTool.LiveStatsPath = Path.Combine(
                            Path.GetFullPath(setting.InnerText), "LiveStats.exe");
                    }
                    else if (String.Compare(setting.Name, "InputFilePath", true) == 0)
                    {
                        _inputFilesPath = Path.GetFullPath(setting.InnerText);
                    }
                    else if (String.Compare(setting.Name, "TempDirectoryPath", true) == 0)
                    {
                        _tempPath = Path.GetFullPath(setting.InnerText);
                        if (!Directory.Exists(_tempPath))
                        {
                            Directory.CreateDirectory(_tempPath);
                        }
                    }
                    else if (String.Compare(setting.Name, "DefaultLeaderboardServer", true) == 0)
                    {
                        _defaultLeaderboardServer = setting.InnerText;
                        _liveTitleTool.LeaderboardServer = _defaultLeaderboardServer;
                        _report.Debug("Overriding default leaderboard server from xml: {0}", _defaultLeaderboardServer);
                    }
                    else if (String.Compare(setting.Name, "SecondLeaderboardServer", true) == 0)
                    {
                        _secondLeaderboardServer = setting.InnerText;
                        _report.Debug("Overriding second leaderboard server from xml: {0}", _secondLeaderboardServer);
                    }
                }
            }
            else
            {
                throw new StfException("Unable to read the LiveStatsTest configuration settings.");
            }

            // Set the working directory for LiveTitle and LiveStats to be in the temporary files location
            _liveTitleTool.WorkingDirectory = _tempPath;
            _liveStatsTool.WorkingDirectory = _tempPath;
        }

        protected override void Execute()
        {
            throw new StfException("Hey you! You forgot to override the Execute method!");
        }

        protected void CopyInputFiles(uint titleId)
        {
            string [] files = Directory.GetFiles(_inputFilesPath, titleId.ToString("X8") + "*.*");

            foreach (string file in files)
            {
                File.Copy(file, Path.Combine(_tempPath, Path.GetFileName(file)), true);
            }

            // Copy all PNG files (only if they don't already exist)
            files = Directory.GetFiles(_inputFilesPath, "*.png");
            string destFile;
            foreach (string file in files)
            {
                destFile = Path.Combine(_tempPath, Path.GetFileName(file));
                if (!File.Exists(destFile))
                {
                    File.Copy(file, destFile);
                }
            }
        }

        protected void BeginCase(string caseName)
        {
            _report.Info("Begin Case: " + caseName);
        }

        /// <summary>
        /// Deletes a title from the service.
        /// </summary>
        /// <param name="titleId">Title ID of the title to delete.</param>
        protected void DeleteTitle(uint titleId)
        {
            // This is a cleaner method of deleting all leaderboard data for a title
            _liveStatsTool.DeleteLeaderboards(titleId);

            // Delete the title from NPDB
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            try
            {
                npdb.IssueCommand("EXECUTE p_live_title_config_delete 0x" + titleId.ToString("X8"));
                npdb.IssueCommand("EXECUTE p_game_delete_config 0x" + titleId.ToString("X8"));
                npdb.IssueCommand("DELETE FROM t_stringsvr_strings WHERE i_title_id=0x" + titleId.ToString("X8"));
            }
            finally
            {
                npdb.Close();
            }

            // Delete the title from UODB
            UodbWS.ExecuteNonQuery("DELETE FROM t_user_title_enumeration_times WHERE i_title_id=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("DELETE FROM t_title_services WHERE i_title_id=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("DELETE FROM t_title_ratings WHERE i_title_id=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("DELETE FROM t_title_trust_constants WHERE i_title_id=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("DELETE FROM t_title_culture_details WHERE i_title_id=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("DELETE FROM t_title_feature_data WHERE i_titleid=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("DELETE FROM t_achievements WHERE i_title_id=0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("EXECUTE p_svc_delete_alternate_titleids 0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("EXECUTE p_svc_clear_title_genres 0x" + titleId.ToString("X8"));
            UodbWS.ExecuteNonQuery("EXECUTE p_svc_clean_titles 0x" + titleId.ToString("X8"));

            // Delete the title from Webdb
            Webdb webdb = new Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            try
            {
                webdb.IssueCommand("DELETE FROM t_partner_allowed_titles WHERE i_title_id=0x" + titleId.ToString("X8"));
                webdb.IssueCommand("EXECUTE p_webdb_tmr_delete_title 0x" + titleId.ToString("X8"));
            }
            finally
            {
                webdb.Close();
            }

            // Clear the files out of the temp directory and the TitleVault
            ClearTempDirectory(titleId);
            CleanTitleVault(titleId);
        }

        /// <summary>
        /// Moves one or all leaderboards from one server to another.
        /// </summary>
        /// <param name="leaderboardId">
        /// ID of the leaderboard to move. Use the ALL_LEADERBOARDS constant to move all leaderboards.
        /// </param>
        /// <param name="sourceServer">
        /// The name of the server on which the leaderboard currently resides.
        /// </param>
        /// <param name="destServer">
        /// The name of the server to which the leaderboard will be moved.
        /// </param>
        public void MoveLeaderboard(uint titleId, int leaderboardId, string sourceServer, string destServer)
        {
            _liveStatsTool.MoveLeaderboard(titleId, leaderboardId, sourceServer, destServer);
            try
            {
                // We need to unload the data from the old server since movelb doesn't anymore or we can't move it back later
                // LiveStats used to remove the data when it was moved but it was a large overhead
                // that was determined not to be required
                if (leaderboardId == LiveStats.ALL_LEADERBOARDS)
                {
                    LiveTitleConfig ltc = LiveTitleConfig.FromXml(_liveTitleTool.LTCPath);
                    for (int loopVar = 0; loopVar < ltc.LeaderboardConfigs.LeaderboardConfigCollection.Count; loopVar++)
                    {
                        _liveStatsTool.Unload(titleId, ltc.LeaderboardConfigs.LeaderboardConfigCollection[loopVar].LeaderboardID, sourceServer);
                    }
                }
                else
                {
                    _liveStatsTool.Unload(titleId, leaderboardId, sourceServer);
                }
            }
            catch (LiveStatsException e)
            {
                _report.Warn("Leaderboard Unload from source server failed. {0}", e.ToString());
            }
        }

        /// <summary>
        /// Deletes all leaderboard data from the WebDb for a given title.
        /// </summary>
        /// <param name="titleId">The Title id to use for deletion.</param>
        protected void DeleteWebDbLeaderboardInfo(uint titleId)
        {
            Webdb webdb = new Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            try
            {
                // Call the p_webdb_tmr_clear_title_leaderboard_info sproc to delete all leaderboard info
                webdb.IssueCommand("EXECUTE p_webdb_tmr_clear_title_leaderboard_info 0x" + titleId.ToString("X8"));
            }
            finally
            {
                webdb.Close();
            }
        }

        /// <summary>
        /// Deletes all files for a given title id from the temporary directory.
        /// </summary>
        /// <param name="titleId">
        /// Title id to use for deleting files. All files that begin with the hex representation
        /// of this title id will be deleted.
        /// </param>
        protected void ClearTempDirectory(uint titleId)
        {
            string [] tempFiles = Directory.GetFiles(_tempPath, titleId.ToString("X8") + "*.*");
            foreach (string file in tempFiles)
            {
                File.Delete(file);
            }
        }

        /// <summary>
        /// Removes all files for the specified title id from the Title Vaule, including the Locked directory.
        /// </summary>
        /// <param name="titleId">Title id</param>
        protected void CleanTitleVault(uint titleId)
        {
            string titleVaultRoot = Global.XEnv.GetSetting(Setting.titlevault_root);
            string lockedRoot = Path.Combine(titleVaultRoot, "Locked");
            string dir;

            // Delete the title's directory
            dir = Path.Combine(titleVaultRoot, titleId.ToString("X8"));
            if (Directory.Exists(dir))
            {
                try
                {
                    Directory.Delete(dir, true);
                }
                catch(Exception ex)
                {
                    _report.Warn("Unable to delete the TitleVault directory '{0}':\r\n{1}",
                        dir, ex.Message);
                }
            }

            // Delete the title from the Locked directory
            dir = Path.Combine(lockedRoot, titleId.ToString("X8"));
            if (Directory.Exists(dir))
            {
                string [] files;

                // If the OLD directory exists, recurse through it and delete files
                if (Directory.Exists(Path.Combine(dir, "OLD")))
                {
                    files = Directory.GetFiles(Path.Combine(dir, "OLD"), "*.*");
                    foreach (string file in files)
                    {
                        try
                        {
                            File.SetAttributes(file, FileAttributes.Normal);
                            File.Delete(file);
                        }
                        catch (Exception ex)
                        {
                            _report.Warn("Unable to delete '{0}' from the TitleVault:\r\n{1}",
                                file, ex.Message);
                        }
                    }
                }

                // Remove the read-only attribute from each file and delete it
                files = Directory.GetFiles(dir, "*.*");
                foreach (string file in files)
                {
                    try
                    {
                        File.SetAttributes(file, FileAttributes.Normal);
                        File.Delete(file);
                    }
                    catch (Exception ex)
                    {
                        _report.Warn("Unable to delete '{0}' from the TitleVault:\r\n{1}",
                            file, ex.Message);
                    }
                }

                try
                {
                    Directory.Delete(dir, true);
                }
                catch (Exception ex)
                {
                    _report.Warn("Unable to delete the directory '{0}' from the TitleVault:\r\n{1}",
                        dir, ex.Message);
                }
            }
        }

        /// <summary>
        /// Parses the LiveStats output stream for the Leaderboard Configuration report for the given leaderboard.
        /// </summary>
        /// <param name="lbId">The ID of the leaderboard.</param>
        /// <returns>An array of strings that represents the columns of the Leaderboard Configuration report.</returns>
        /// <remarks>
        /// Currently, the following data is displayed in the Leaderboard Configuration report:
        ///     Server
        ///     TitleID
        ///     Leaderboard ID
        ///     Reset Type
        ///     Top 100 flag
        ///     Teams flag
        ///     Arbitration flag
        ///     Decay Days (Entry Expiration)
        ///     ELO Base
        ///     ELO Rating Scale Factor
        ///     ELO Initial Player Rating
        ///     ELO Max Weight Rating Array
        ///     Attachments
        ///     Max Attachment Size
        ///     Last Reset Date (this value is spread over 3 columns: Date, Time, AM/PM)
        /// </remarks>
        protected string [] GetLbConfigFromOutput(int lbId)
        {
            Regex r = new Regex(@"^\w+\x20+\d+\x20+"+lbId.ToString()+@".+(?=\r)", RegexOptions.Multiline);
            MatchCollection matches = r.Matches(_liveStatsTool.Output);
            if (matches.Count > 0)
            {
                r = new Regex("\x20+");
                return r.Replace(matches[0].Value, "|").Split('|');
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Verifies all leaderboard configuration data in the service matches the XLAST and LTC files.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="verifyLocation">Flag indicating whether or not the leaderboard locations should be verified.</param>
        /// <returns></returns>
        protected TEST_RESULTS VerifyXbox360StatsData(uint titleId, bool verifyLocation)
        {
            TEST_RESULTS res;

            // This pulls leaderboard information from the service
            Xbox360Stats stats = Xbox360Stats.Create(titleId);
            XboxLiveSubmissionProject xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                (typeof(XboxLiveSubmissionProject), _liveTitleTool.XlastPath);
            LiveTitleConfig ltc = (LiveTitleConfig)ConfigFileSerializer.FromXml
                (typeof(LiveTitleConfig), _liveTitleTool.LTCPath);

            res = Xbox360StatsVerifier.VerifyLeaderboards(xlast, stats);
            if (res == TEST_RESULTS.PASSED && verifyLocation == true)
            {
                // Verify the leaderboards are where they should be
                res = Xbox360StatsVerifier.VerifyLeaderboardLocation(ltc, stats);
            }

            return res;
        }

        protected TEST_RESULTS VerifyXbox360StatsData(uint titleId)
        {
            return VerifyXbox360StatsData(titleId, true);
        }

        protected TEST_RESULTS VerifyXbox1StatsData(uint titleId)
        {
            // This pulls leaderboard information from the service
            Xbox1Stats stats = Xbox1Stats.Create(titleId);
            XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml(_liveTitleTool.XSCPath);
            LiveTitleConfig ltc = LiveTitleConfig.FromXml(_liveTitleTool.LTCPath);

            return Xbox1StatsVerifier.VerifyAllLeaderboards(xsc.LeaderboardContainers, stats);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\TitleStats.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LiveStatsTest
{
	/// <summary>
	/// Base class for storing leaderboard data from the Xbox Live service.
	/// This class should not be used directly.
	/// </summary>
	public class TitleStatsBase
	{
        protected uint _titleId;
        protected string _gameConfigXml;
        protected string _ltcXml;
        protected LeaderboardCollection _leaderboards;
        protected InterfaceBucketCollection _interfaceBuckets;
        protected WebdbLeaderboardCollection _webLeaderboards;

		protected TitleStatsBase(uint titleId)
		{
            _titleId = titleId;
            _gameConfigXml = null;
            _ltcXml = null;
            _leaderboards = null;
            _interfaceBuckets = null;
            _webLeaderboards = null;
		}

        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        public string GameConfigXml
        {
            get { return _gameConfigXml; }
            set { _gameConfigXml = value; }
        }

        public string LiveTitleConfigXml
        {
            get { return _ltcXml; }
            set { _ltcXml = value; }
        }

        public LeaderboardCollection Leaderboards
        {
            get { return (_leaderboards == null ? new LeaderboardCollection() : _leaderboards); }
            set { _leaderboards = value; }
        }

        public InterfaceBucketCollection InterfaceBuckets
        {
            get { return (_interfaceBuckets == null ? new InterfaceBucketCollection() : _interfaceBuckets); }
            set { _interfaceBuckets = value; }
        }

        public WebdbLeaderboardCollection WebLeaderboards
        {
            get { return (_webLeaderboards == null ? new WebdbLeaderboardCollection() : _webLeaderboards); }
            set { _webLeaderboards = value; }
        }

        public virtual void Refresh()
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                GameConfigRow gc;
                LiveTitleConfigRow ltc;

                npdb.GetGameConfig(_titleId, out gc);
                _gameConfigXml = gc.XmlConfig;
                ltc = npdb.GetLiveTitleConfig(_titleId);
                _ltcXml = ltc.XmlTitleConfig;
                _leaderboards = npdb.GetLeaderboards(_titleId);
                _interfaceBuckets = npdb.GetInterfaceBuckets(_titleId);
            }
            finally
            {
                npdb.Close();
            }

            Webdb webdb = new Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            try
            {
                _webLeaderboards = webdb.GetLeaderboards(_titleId);
            }
            finally
            {
                webdb.Close();
            }
        }
	}

    /// <summary>
    /// Class used for retrieving leaderboard data from the Xbox Live service for Xbox 360 titles.
    /// </summary>
    public class Xbox360Stats : TitleStatsBase
    {
        public Xbox360Stats(uint titleId) : base(titleId) {}
        public static Xbox360Stats Create(uint titleId)
        {
            Xbox360Stats stats = new Xbox360Stats(titleId);
            stats.Refresh();
            return stats;
        }
    }

    /// <summary>
    /// Class used for retrieving leaderboard data from the Xbox Live service for Xbox 1 titles.
    /// </summary>
    public class Xbox1Stats : TitleStatsBase
    {
        protected LeaderboardCollection _templates;

        public Xbox1Stats(uint titleId) : base(titleId) {}
        public static Xbox1Stats Create(uint titleId)
        {
            Xbox1Stats stats = new Xbox1Stats(titleId);
            stats.Refresh();
            return stats;
        }

        public LeaderboardCollection CompetitionTemplates
        {
            get { return (_templates == null ? new LeaderboardCollection() : _templates); }
            set { _templates = value; }
        }

        public override void Refresh()
        {
            base.Refresh();

            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                _templates = npdb.GetCompetitionTemplates(_titleId);
            }
            finally
            {
                npdb.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livestats_none_12.4.56.0_none_53a3aa03caf1c576
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livestats
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.manifest
XP_MANIFEST_PATH=manifests\msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.cat
XP_CATALOG_PATH=manifests\msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.cat
XP_PAYLOAD_PATH=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livestats,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livestats_none_12.4.56.0_none_53a3aa03caf1c576
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livestats
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.manifest
XP_MANIFEST_PATH=manifests\msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.cat
XP_CATALOG_PATH=manifests\msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96.cat
XP_PAYLOAD_PATH=msil_livestats_no-public-key_12.4.56.0_x-ww_ba63ba96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livestats,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\TrueSkill.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.STFTools.ConfigFiles;

namespace LiveStatsTest
{
	/// <summary>
	/// Summary description for TrueSkillLeaderboard.
	/// </summary>
	public class TrueSkillLeaderboard
	{
        private uint _leaderboardId;
        private LocalizedDescription [] _names;
        private TrueSkillColumn [] _columns;
        private RawAttribute [] _rawAttributes;

        public TrueSkillLeaderboard()
        {
            _leaderboardId = 0;
            _names = null;
            _columns = null;
            _rawAttributes = null;
        }

		public TrueSkillLeaderboard(uint lbId) : this()
		{
            _leaderboardId = lbId;
		}

        public uint LeaderboardId
        {
            get { return _leaderboardId; }
            set { _leaderboardId = value; }
        }

        public LocalizedDescription [] Names
        {
            get { return _names; }
            set { _names = value; }
        }

        public TrueSkillColumn [] Columns
        {
            get { return _columns; }
            set { _columns = value; }
        }

        public RawAttribute [] RawAttributes
        {
            get { return _rawAttributes; }
            set { _rawAttributes = value; }
        }
	}

    public class TrueSkillColumn
    {
        public string Name;
        public int ReturnType;
        public string Formula;
        public LocalizedDescription [] Descriptions;

        // xlast fields
        public uint AttributeId;
        public uint PropertyId;
        public string Aggregation;

        public TrueSkillColumn(string name, uint attributeId, string formula)
        {
            Name = name;
            AttributeId = attributeId;
            Formula = formula;
            ReturnType = 12;
        }

        public TrueSkillColumn() {}
    }

    public class LocalizedDescription
    {
        public string Locale;
        public string Description;

        public LocalizedDescription(string locale, string description)
        {
            Locale = locale;
            Description = description;
        }

        public LocalizedDescription() {}
    }

    public class RawAttribute
    {
        public int Id;
        public bool IsPUID;

        public RawAttribute(int id, bool isPuid)
        {
            Id = id;
            IsPUID = isPuid;
        }

        public RawAttribute() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveStats\StatsVerifier.cs ===
using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LiveStatsTest
{
    /// <summary>
	/// Base class for the leaderboard verification classes. This class should not be used directly.
	/// </summary>
	public class StatsVerifier
	{
        protected static Report report = new Report("StatsVerifier");

        protected StatsVerifier() {}

        public static TEST_RESULTS VerifyLTCLeaderboardAssignments(string lbServer, LiveTitleConfig ltc, LeaderboardConfigCollection existingAssignments)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            if (ltc == null)
            {
                report.Error("The LiveTitleConfig object passed to VerifyLTCLeaderboardAssignments can't be NULL.");
                return TEST_RESULTS.FAILED;
            }

            if (existingAssignments != null && existingAssignments.Count > 0)
            {
                // Verify an existing LTC by making sure that all existing assignments are the same
                // and that any new leaderboard assignments match the server name.

                bool found;
                foreach (LeaderboardConfig actLb in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    found = false;
                    foreach (LeaderboardConfig expLb in existingAssignments)
                    {
                        if (actLb.LeaderboardID == expLb.LeaderboardID &&
                            actLb.IsCompetition == expLb.IsCompetition)
                        {
                            found = true;
                            if (actLb.HostingLbs != expLb.HostingLbs)
                            {
                                ReportVerificationFailure(expLb.HostingLbs, actLb.HostingLbs,
                                    "The server name for the existing leaderboard {0}{1} doesn't match.",
                                    actLb.LeaderboardID, (actLb.IsCompetition ? " (Competition Template)" : ""));
                                result = TEST_RESULTS.FAILED;
                            }
                            break;
                        }
                    }

                    if (!found)
                    {
                        if (String.Compare(lbServer, actLb.HostingLbs, true) != 0)
                        {
                            ReportVerificationFailure(lbServer, actLb.HostingLbs,
                                "Leaderboard server mismatch in LTC file for leaderboard {0}{1}.",
                                actLb.LeaderboardID, (actLb.IsCompetition ? " (Competition Template)" : ""));
                            result = TEST_RESULTS.FAILED;
                        }
                    }
                }
            }
            else
            {
                // Verify a new LTC
                foreach (LeaderboardConfig lb in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    if (String.Compare(lb.HostingLbs, lbServer, true) != 0)
                    {
                        ReportVerificationFailure(lbServer, lb.HostingLbs,
                            "Leaderboard server mismatch in LTC file for leaderboard {0}{1}.",
                            lb.LeaderboardID, (lb.IsCompetition ? " (Competition Template)" : ""));
                        result = TEST_RESULTS.FAILED;
                    }
                }
            }

            return result;
        }

        public static void ReportVerificationFailure(object expVal, object actVal, string message, params object[] args)
        {
            report.Error("Verification failure! {0}\r\n  Expected: |{1}|\r\n  Actual:   |{2}|",
                string.Format(message, args), expVal == null ? "null" : expVal.ToString(),
                actVal == null ? "null" : actVal.ToString());
        }
    }


    /// <summary>
    /// Verification class for Xbox 360 leaderboards.
    /// </summary>
    public class Xbox360StatsVerifier : StatsVerifier
    {
        protected Xbox360StatsVerifier() {}

        /// <summary>
        /// Verifies the User-Defined and TrueSkill leaderboards in a given XLAST file with what's in the service.
        /// </summary>
        /// <param name="xlast">The XLAST file containing the leaderboard definitions.</param>
        /// <param name="actData">The actual data from the Live Service.</param>
        /// <returns>
        /// If the verifications succeeded, TEST_RESULTS.PASSED is returned.
        /// If a verification fails, TEST_RESULTS.FAILED is returned.
        /// </returns>
        public static TEST_RESULTS VerifyLeaderboards(XboxLiveSubmissionProject xlast, Xbox360Stats actData)
        {
            Hashtable expLbs = SVLeaderboard.GetLeaderboardsFromXlast(xlast);
            TEST_RESULTS result = TEST_RESULTS.PASSED, tmpResult;

            // First make sure that the number of leaderboards match between NPDB, WEbDB, and the XLAST file
            if (actData.Leaderboards.Count != expLbs.Count ||
                actData.WebLeaderboards.Count != expLbs.Count)
            {
                report.Error("The number of leaderboards doesn't match:\r\n" +
                              "    Expected (XLAST): {0}\r\n" +
                              "    Actual (NPDB)   : {1}\r\n" +
                              "    Actual (WebDB)  : {2}",
                    expLbs.Count, actData.Leaderboards.Count, actData.WebLeaderboards.Count);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the leaderboard configuration data in NPDB
            foreach (ServerTestFramework.Database.Leaderboard actLb in actData.Leaderboards)
            {
                SVLeaderboard expLb = expLbs[(uint)actLb.LeaderboardId] as SVLeaderboard;
                if (expLb == null)
                {
                    report.Error("Leaderboard {0} is defined in NPDB, but not in the XLAST file.",
                        actLb.LeaderboardId);
                    result = TEST_RESULTS.FAILED;
                    continue;
                }

                tmpResult = VerifyNPDBLeaderboard(expLb, actLb);
                result = result == TEST_RESULTS.PASSED ? tmpResult : result;
            }

            // Verify the data in the WebDB
            foreach (WebdbLeaderboard actLb in actData.WebLeaderboards)
            {
                SVLeaderboard expLb = expLbs[(uint)actLb.LeaderboardId] as SVLeaderboard;
                if (expLb == null)
                {
                    report.Error("Leaderboard {0} is defined in WebDB, but not in the XLAST file.",
                        actLb.LeaderboardId);
                    result = TEST_RESULTS.FAILED;
                    continue;
                }

                tmpResult = VerifyWebDbLeaderboard(expLb, actLb);
                result = result == TEST_RESULTS.PASSED ? tmpResult : result;
            }

            return result;
        }

        public static TEST_RESULTS VerifyLeaderboardLocation(LiveTitleConfig expVal, Xbox360Stats actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool found;

            foreach (LeaderboardConfig lbc in expVal.LeaderboardConfigs.LeaderboardConfigCollection)
            {
                found = false;
                foreach (InterfaceBucket ib in actVal.InterfaceBuckets)
                {
                    // The bucket value is the leaderboard ID
                    if (lbc.LeaderboardID == ib.Bucket)
                    {
                        found = true;
                        if (lbc.HostingLbs != ib.Server)
                        {
                            ReportVerificationFailure(lbc.HostingLbs, ib.Server,
                                "Leaderboard location mismatch.");
                            result = TEST_RESULTS.FAILED;
                        }
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find a leaderboard server for leaderboard {0}", lbc.LeaderboardID);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }
        

        #region Private Verification Methods
        private static TEST_RESULTS VerifyNPDBLeaderboard(SVLeaderboard expLb, ServerTestFramework.Database.Leaderboard actLb)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            report.Info("Verifying NPDB Leaderboard data for leaderboard 0x{0:x}", expLb.LeaderboardId);

            if (actLb.RequiresArbitration != expLb.Arbitrated)
            {
                ReportVerificationFailure(expLb.Arbitrated, actLb.RequiresArbitration,
                    "Arbitration mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.DecayDays != expLb.DecayDays)
            {
                ReportVerificationFailure(expLb.DecayDays, actLb.DecayDays,
                    "Decay Days mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.ResetType != expLb.ResetType)
            {
                ReportVerificationFailure(expLb.ResetType, actLb.ResetType,
                    "Reset Type mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.Top100 != expLb.Top100)
            {
                ReportVerificationFailure(expLb.Top100, actLb.Top100,
                    "Top 100 mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            // All of these settings don't apply to Xbox 360 leaderboards,
            // so they must contain the default values
            if (actLb.AttachCount != expLb.MaxAttachments)
            {
                ReportVerificationFailure(0, actLb.AttachCount,
                    "Attach Count mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.MaxAttachSize != 0)
            {
                ReportVerificationFailure(0, actLb.MaxAttachSize,
                    "Max Attach Size mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.IsTeamLb)
            {
                ReportVerificationFailure(0, actLb.IsTeamLb,
                    "Teams flag mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloBase != "10")
            {
                ReportVerificationFailure("10", actLb.EloBase,
                    "ELO Base mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloK != 100)
            {
                ReportVerificationFailure(100, actLb.EloK,
                    "ELO K value mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloNew != 500)
            {
                ReportVerificationFailure(500, actLb.EloNew,
                    "ELO New value mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloCTable != "0:40")
            {
                ReportVerificationFailure(100, actLb.EloCTable,
                    "ELO Max Weight Rating Range Array mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        private static TEST_RESULTS VerifyWebDbLeaderboard(SVLeaderboard expLb, WebdbLeaderboard actLb)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            report.Info("Verifying WebDB Leaderboard data for leaderboard 0x{0:x}", expLb.LeaderboardId);

            // None of the main leaderboard settings in WebDB apply to Xbox 360 leaderboards,
            // so they must all be the default values.
            if (actLb.ResetType != expLb.ResetType)
            {
                ReportVerificationFailure(expLb.ResetType, actLb.ResetType,
                    "Web leaderboard Reset Type mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EntriesPerCacheLine != 50)
            {
                ReportVerificationFailure(50, actLb.EntriesPerCacheLine,
                    "Web leaderboard Entries per cache line mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.ExpirationSeconds != 900)
            {
                ReportVerificationFailure(900, actLb.ExpirationSeconds,
                    "web leaderboard Expiration seconds mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.LeaderboardType != 0)
            {
                ReportVerificationFailure(0, actLb.LeaderboardType,
                    "Web Leaderboard type mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.DontList != false)
            {
                ReportVerificationFailure(0, actLb.DontList,
                    "Web leaderboard don't list flag mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the localized leaderboard names
            SVLocalizedDescription [] actNames = GetWebdbLeaderboardLocalizedNames(actLb);
            bool found = false;
            if (actNames != null)
            {
                if (expLb.Names.Length != actNames.Length)
                {
                    report.Error("The number of localized names for Web leaderboard {0} is different:\r\n" +
                                  "    Expected (XLAST) : {1}\r\n" +
                                  "    Actual (WebDB)   : {2}",
                        expLb.LeaderboardId, expLb.Names.Length, actNames.Length);
                    result = TEST_RESULTS.FAILED;
                }

                foreach (SVLocalizedDescription expName in expLb.Names)
                {
                    found = false;
                    foreach (SVLocalizedDescription actName in actNames)
                    {
                        if (expName.Locale == actName.Locale)
                        {
                            found = true;
                            if (expName.Description != actName.Description)
                            {
                                ReportVerificationFailure(expName.Description, actName.Description,
                                    "Web leaderboard name mismatch for locale {0} in leaderboard {1}",
                                    actName.Locale, actLb.LeaderboardId);
                                result = TEST_RESULTS.FAILED;
                            }
                            break;
                        }
                    }

                    if (!found)
                    {
                        report.Error("Unable to find a {0} name string for leaderboard {1} in Webdb",
                            expName.Locale, actLb.LeaderboardId);
                        result = TEST_RESULTS.FAILED;
                    }
                }
            }
            else
            {
                report.Error("No localized names esit in Webdb for leaderboard {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the Raw Attributes
            if (expLb.RawAttributes.Length != actLb.RawAttributes.Count)
            {
                report.Error("The number of raw attributes for Web leaderboard {0} is different:\r\n" +
                              "    Expected (XLAST) : {1}\r\n" +
                              "    Actual (WebDB)   : {2}",
                    expLb.LeaderboardId, expLb.RawAttributes.Length, actLb.RawAttributes.Count);
                result = TEST_RESULTS.FAILED;
            }

            foreach (SVRawAttribute expAttrib in expLb.RawAttributes)
            {
                found = false;
                foreach (WebdbRawAttribute actAttrib in actLb.RawAttributes)
                {
                    if (expAttrib.Id == actAttrib.RawAttributeId)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find raw attribute {0} for leaderboard {1} in Webdb",
                        expAttrib.Id, actLb.LeaderboardId);
                    result = TEST_RESULTS.FAILED;
                }
            }

            // Verify the Formatted Attributes by munging the database data into an array
            // of SVLeaderboardColumn objects so that it's similar to the expected values.
            SVLeaderboardColumn [] actColumns = GetColumnsFromWebdb(actLb);
            TEST_RESULTS tmpResult = VerifyFormattedAttributes(actLb.LeaderboardId, expLb.Columns, actColumns);
            result = result == TEST_RESULTS.PASSED ? tmpResult : result;

            return result;
        }

        private static TEST_RESULTS VerifyFormattedAttributes(int lbId, SVLeaderboardColumn [] expColumns, SVLeaderboardColumn [] actColumns)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool found, descFound;

            foreach (SVLeaderboardColumn expCol in expColumns)
            {
                found = false;
                foreach (SVLeaderboardColumn actCol in actColumns)
                {
                    if (expCol.AttributeId == actCol.AttributeId)
                    {
                        found = true;
                        if (expCol.ReturnType != actCol.ReturnType)
                        {
                            ReportVerificationFailure(expCol.ReturnType, actCol.ReturnType,
                                "Return type mismatch for column {0} in leaderboard {1}",
                                expCol.AttributeId, lbId);
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expCol.Formula != actCol.Formula)
                        {
                            ReportVerificationFailure(expCol.Formula, actCol.Formula,
                                "Formula mismatch for column {0} in leaderboard {1}",
                                expCol.AttributeId, lbId);
                            result = TEST_RESULTS.FAILED;
                        }

                        // Now for the localized descriptions
                        foreach (SVLocalizedDescription expDesc in expCol.Descriptions)
                        {
                            descFound = false;
                            foreach (SVLocalizedDescription actDesc in actCol.Descriptions)
                            {
                                if (expDesc.Locale == actDesc.Locale)
                                {
                                    descFound = true;
                                    if (expDesc.Description != actDesc.Description)
                                    {
                                        ReportVerificationFailure(expDesc.Description, actDesc.Description,
                                            "The {0} description for the attribute {1} of leaderboard {2} doesn't match.",
                                            expDesc.Locale, expCol.AttributeId, lbId);
                                        result = TEST_RESULTS.FAILED;
                                    }
                                    break;
                                }
                            }

                            if (!descFound)
                            {
                                report.Error("Unable to find a {0} description string for attribute {1} of leaderboard {2}",
                                    expDesc.Locale, expCol.AttributeId, lbId);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find a formatted attribute with the id {0} for leaderboard {1}",
                        expCol.AttributeId, lbId);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        private static SVLocalizedDescription [] GetWebdbLeaderboardLocalizedNames(WebdbLeaderboard webLb)
        {
            SVLocalizedDescription [] names = new SVLocalizedDescription[webLb.Names.Count];
            int i = 0;

            foreach (WebdbLeaderboardName lbName in webLb.Names)
            {
                names[i++] = new SVLocalizedDescription(lbName.Locale, lbName.DisplayName);
            }

            return names;
        }

        private static SVLeaderboardColumn [] GetColumnsFromWebdb(WebdbLeaderboard webLb)
        {
            SVLeaderboardColumn [] attributes = new SVLeaderboardColumn[webLb.FormattedAttributes.Count];
            
            ArrayList descriptions = new ArrayList();
            int i = 0, j = 0;

            foreach (WebdbFormattedAttribute attrib in webLb.FormattedAttributes)
            {
                attributes[i] = new SVLeaderboardColumn(attrib.FriendlyName, uint.Parse(attrib.FriendlyName) , attrib.Formula);
                attributes[i].Descriptions = new SVLocalizedDescription[attrib.Names.Count];
                j = 0;

                // build the list of localized descriptions for this column
                foreach (WebdbFormattedAttributeName desc in attrib.Names)
                {
                    attributes[i].Descriptions[j++] = new SVLocalizedDescription(desc.Locale, desc.DisplayName);
                }
                i++;
            }

            return attributes;
        }
        #endregion

    }

    /// <summary>
    /// Verifier class for Xbox 1 leaderboards.
    /// </summary>
    public class Xbox1StatsVerifier : StatsVerifier
    {
        protected Xbox1StatsVerifier() {}

        public static TEST_RESULTS VerifyAllLeaderboards(XscLeaderboardContainerCollection expLbs, Xbox1Stats stats)
        {
            TEST_RESULTS tmpResult, result = TEST_RESULTS.PASSED;

            foreach (XscLeaderboardContainer container in expLbs)
            {
                if (container.Type != ContainerType.Units)
                {
                    report.Info("Verifying leaderboards in the {0} container...", container.Type);
                    tmpResult = VerifyLeaderboards(container, stats);
                    if (result == TEST_RESULTS.PASSED) result = tmpResult;
                }
                else
                {
                    report.Info("Ignoring Unit leaderboards...");
                }
            }

            return result;
        }

        public static TEST_RESULTS VerifyLeaderboards(XscLeaderboardContainer expLbs, Xbox1Stats stats)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            LeaderboardCollection actLbs;
            bool found, isCompTemplate = expLbs.Type == ContainerType.Competitions;

            // The actual leaderboards are either leaderboards or competition templates
            actLbs = (isCompTemplate) ? stats.CompetitionTemplates : stats.Leaderboards;

            foreach (XscLeaderboard expLb in expLbs.Leaderboards)
            {
                found = false;
                foreach (ServerTestFramework.Database.Leaderboard actLb in actLbs)
                {
                    if (expLb.Id == actLb.LeaderboardId)
                    {
                        found = true;
                        if (isCompTemplate != actLb.IsCompetitionTemplate)
                        {
                            ReportVerificationFailure(isCompTemplate, actLb.IsCompetitionTemplate,
                                "Leaderboard {0} should {1}be a competition template!",
                                expLb.Id, isCompTemplate ? "" : "not ");
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expLb.DecayDays != actLb.DecayDays)
                        {
                            ReportVerificationFailure(expLb.DecayDays, actLb.DecayDays,
                                "Decay Days mismatch in leaderboard {0}", expLb.Id);
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expLb.Reset != actLb.ResetType)
                        {
                            ReportVerificationFailure(expLb.Reset, actLb.ResetType,
                                "Reset Type mismatch in leaderboard {0}", expLb.Id);
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expLb.TeamsLeaderboard != actLb.IsTeamLb)
                        {
                            ReportVerificationFailure(expLb.TeamsLeaderboard, actLb.IsTeamLb,
                                "Team leaderboard flag mismatch in leaderboard {0}", expLb.Id);
                            result = TEST_RESULTS.FAILED;
                        }

                        // The Top 100 setting for competition templates is forced to True
                        // no matter what is set in the XSC file.
                        if (isCompTemplate)
                        {
                            if (!actLb.Top100)
                            {
                                ReportVerificationFailure(true, actLb.Top100,
                                    "Top 100 flag mismatch in competition template {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if (expLb.TopOneHundred != actLb.Top100)
                            {
                                ReportVerificationFailure(expLb.TopOneHundred, actLb.Top100,
                                    "Top 100 flag mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }

                        if (expLb.Attachments != null)
                        {
                            if (expLb.Attachments.Uploads != actLb.AttachCount)
                            {
                                ReportVerificationFailure(expLb.Attachments.Uploads, actLb.AttachCount,
                                    "Attachment count mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (expLb.Attachments.Size != actLb.MaxAttachSize)
                            {
                                ReportVerificationFailure(expLb.Attachments.Size, actLb.MaxAttachSize,
                                    "Maximum attachment size mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if (actLb.AttachCount != 0)
                            {
                                ReportVerificationFailure(0, actLb.AttachCount,
                                    "Attachment count mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (actLb.MaxAttachSize != 0)
                            {
                                ReportVerificationFailure(0, actLb.MaxAttachSize,
                                    "Maximum attachment size mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }

                        if (expLb.Elo != null)
                        {
                            if (String.Compare(expLb.Elo.ExponentialBase, actLb.EloBase.TrimEnd(), true) != 0)
                            {
                                ReportVerificationFailure(expLb.Elo.ExponentialBase, actLb.EloBase,
                                    "ELO Exponent Base mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (expLb.Elo.InitialPlayerRating != actLb.EloNew)
                            {
                                ReportVerificationFailure(expLb.Elo.InitialPlayerRating, actLb.EloNew,
                                    "ELO Initial Player Rating mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (expLb.Elo.RatingScaleFactor != actLb.EloK)
                            {
                                ReportVerificationFailure(expLb.Elo.RatingScaleFactor, actLb.EloK,
                                    "ELO Rating Scale Factor mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            string eloArray = EloArrayToString(expLb.Elo.MaxWeightRatingRangeArray.MaxWeightRatingRanges);
                            if (eloArray != actLb.EloCTable)
                            {
                                ReportVerificationFailure(eloArray, actLb.EloCTable,
                                    "ELO Max Weight Rating Range mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if ("10" != actLb.EloBase)
                            {
                                ReportVerificationFailure("10", actLb.EloBase,
                                    "ELO Exponent Base mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (500 != actLb.EloNew)
                            {
                                ReportVerificationFailure(500, actLb.EloNew,
                                    "ELO Initial Player Rating mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (100 != actLb.EloK)
                            {
                                ReportVerificationFailure(100, actLb.EloK,
                                    "ELO Rating Scale Factor mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if ("0:40" != actLb.EloCTable)
                            {
                                ReportVerificationFailure("0:40", actLb.EloCTable,
                                    "ELO Max Weight Rating Range mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find leaderboard {0} in the service.", expLb.Id);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        private static string EloArrayToString(XscMaxWeightRatingRangeCollection eloArray)
        {
            StringBuilder eloArrayString = new StringBuilder();

            foreach (XscMaxWeightRatingRange range in eloArray)
            {
                eloArrayString.AppendFormat("{0}:{1},", range.Start, range.MaxWeight);
            }

            if (eloArrayString.Length > 0)
            {
                eloArrayString.Length--;
            }

            return eloArrayString.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\FuncDeploy.cs ===
using System;
using System.Collections;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;

using xonline.common.config;
using xonline.common.protocol;

namespace LiveTitleTest
{
	/// <summary>
	/// LiveTitle Xbox 360 title deployment functional tests
	/// </summary>
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
	public class FuncDeployXbox360Group : TestNode
	{
        [TestCase, DVT]
        public class FuncDeployTitle : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployTitle";
                BeginCase(caseName);

                uint titleId = 0xfffe07d3;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.FullGame, titleId, caseName, XLASTLanguage.English);
                _xlastFactory.AddAchievements(xlast, 20, 1000);
                _xlastFactory.AddStatsViews(xlast, 2);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Verify the LTC defaults for a full title
                _liveTitleTool.CreateXbox360LTCFile();
                ResultCode = VerifyLTCDefaults(_liveTitleTool.LTCPath, XLASTTitleType.FullGame);

                // Deploy and verify the title
                _liveTitleTool.DeployXbox360Title(titleId);
                Xbox360Title title = Xbox360Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncDeployArcadeTitle : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployArcadeTitle";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D4;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.ArcadeTitle, titleId, caseName, XLASTLanguage.English);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Verify the LTC defaults for an arcade title
                _liveTitleTool.CreateXbox360LTCFile();
                ResultCode = VerifyLTCDefaults(_liveTitleTool.LTCPath, XLASTTitleType.ArcadeTitle);

                _liveTitleTool.DeployXbox360Title(titleId);
                Xbox360Title title = Xbox360Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncDeploySystemTitle : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeploySystemTitle";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D4;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.SystemTitle, titleId, caseName, XLASTLanguage.English);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Verify the LTC defaults for a system title
                _liveTitleTool.CreateXbox360LTCFile();
                ResultCode = VerifyLTCDefaults(_liveTitleTool.LTCPath, XLASTTitleType.SystemTitle);

                _liveTitleTool.DeployXbox360Title(titleId);
                Xbox360Title title = Xbox360Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncDeployDemoTitle : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployDemoTitle";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D4;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.DemoTitle, titleId, caseName, XLASTLanguage.English);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Verify the LTC defaults for a demo title
                _liveTitleTool.CreateXbox360LTCFile();
                ResultCode = VerifyLTCDefaults(_liveTitleTool.LTCPath, XLASTTitleType.DemoTitle);

                _liveTitleTool.DeployXbox360Title(titleId);
                Xbox360Title title = Xbox360Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }


        [TestCase]
        public class FuncDeployWithAllLanguages : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployWithAllLanguages";
                BeginCase(caseName);

                uint titleId = 0xFFFE07d5;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.FullGame, titleId, caseName, XLASTLanguage.German);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                uint[] langs = (uint[])Enum.GetValues(typeof(XLASTLanguage));
                foreach (uint lang in langs)
                {
                    if (lang == (uint)XLASTLanguage.German)
                    {
                        continue;
                    }
                    _xlastFactory.AddLanguage(xlast, (XLASTLanguage)lang);
                }
                _xlastFactory.AddProductInformation(xlast);
                _xlastFactory.AddAchievements(xlast, (uint)_rnd.Next(5, 61), 1000);
                _xlastFactory.AddContexts(xlast, 5, 4);
                _xlastFactory.AddProperties(xlast, _rnd.Next(3, 21));
                _xlastFactory.AddStatsViews(xlast, (uint)_rnd.Next(2, 31));
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Deploy the title
                _liveTitleTool.DeployXbox360Title(titleId);
                ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId));
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncDeployCrossPlatformTitle : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployCrossPlatformTitle";
                BeginCase(caseName);

                uint titleId1 = 0xFFFE07D5;
                uint titleId2 = 0xFFFE07D6;

                DeleteTitle(titleId1);
                DeleteTitle(titleId2);

                // Cross-Platform Full Title
                XboxLiveSubmissionProject fullXlast = CreateDefaultXLAST(titleId1, caseName);
                _xlastFactory.SetPlatform(fullXlast, XLASTPlatform.PC);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + "_Full.xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, fullXlast);
                _liveTitleTool.DeployXbox360Title(titleId1);
                ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId1));
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);

                    // Cross-Platform Arcade Title
                    XboxLiveSubmissionProject arcadeXlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                        XLASTTitleType.ArcadeTitle, titleId2, caseName + " Arcade", XLASTLanguage.Japanese);
                    _xlastFactory.SetPlatform(arcadeXlast, XLASTPlatform.PC);
                    _xlastFactory.AddProductInformation(arcadeXlast);
                    _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + "_Arcade.xlast");
                    ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, arcadeXlast);
                    _liveTitleTool.DeployXbox360Title(titleId2);
                    ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId2));
                    if (ResultCode == TEST_RESULTS.PASSED)
                    {
                        File.Delete(_liveTitleTool.XlastPath);
                        File.Delete(_liveTitleTool.LTCPath);
                    }
                }
            }
        }

        [TestCase]
        public class FuncDeployWithCredOverride : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployWithCredOverride";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D3;
                ResultCode = TEST_RESULTS.PASSED;

                DeleteTitle(titleId);

                // Create an XLAST file that has the required 1000 cred and deploy it
                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.FullGame, titleId, caseName, XLASTLanguage.English);
                _xlastFactory.AddAchievements(xlast, 20, 1000);
                _xlastFactory.AddProperties(xlast, 5);
                _xlastFactory.AddContexts(xlast, 4, 5);
                _xlastFactory.AddStatsViews(xlast, 2);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);
                _liveTitleTool.DeployXbox360Title(titleId, true, false, 0x65);

                // Lock the title
                _liveTitleTool.LockTitle();

                // Edit the XLAST file to add achievements and increase total cred to 1300
                _xlastFactory.AddAchievements(xlast, 4, 300);
                _xlastFactory.UpdateVersion(xlast);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + "_PDLC.xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Try to deploy the new XLAST file - this should fail since the cred is over the limit
                try
                {
                    _liveTitleTool.DeployXbox360Title(titleId, true, true);
                    // Whoops! this call to LiveTitle should have failed!
                    _report.Error("This call to LiveTitle succeeded when it should have failed!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (LiveTitleException ltEx)
                {
                    if (!ltEx.ProcessOutput.Contains("The Xlast document contains more total Cred than allowed by the LiveTitleConfig document."))
                    {
                        // It failed for a different reason - rethrow
                        throw;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Open the LTC file and raise the total amount of allowed Cred to 1300
                    LiveTitleConfig ltc = ConfigFileSerializer.FromXml(typeof(LiveTitleConfig), _liveTitleTool.LTCPath) as LiveTitleConfig;
                    ltc.MaxCred = 1300;
                    ConfigFileSerializer.ToXml(_liveTitleTool.LTCPath, ltc);

                    // Now try to deploy the XLAST file (this will throw if it fails)
                    _liveTitleTool.DeployXbox360Title(titleId, true, true);
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncCreateLTCWithTitleAndDiscId : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncCreateLTCWithTitleAndDiscId";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D3;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = CreateDefaultXLAST(titleId, caseName);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);
                _liveTitleTool.CreateXbox360LTCFile(titleId, titleId);

                // Verify the DiscID gets propogated to the LTC file
                LiveTitleConfig ltc = (LiveTitleConfig)ConfigFileSerializer.FromXml(typeof(LiveTitleConfig), _liveTitleTool.LTCPath);
                if ((uint)ltc.DiscMediaID != titleId)
                {
                    _report.Error("Verification error! Disc ID mismatch.\r\nExpected: {0:x}\r\nActual  : {1:x}",
                        titleId, ltc.DiscMediaID);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncDeployWithSpacWarnings : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployWithSpacWarnings";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D4;
                ResultCode = TEST_RESULTS.PASSED;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.FullGame, titleId, caseName, XLASTLanguage.English);
                // Add too much Cred
                _xlastFactory.AddAchievements(xlast, 5, 1005);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                _liveTitleTool.CreateXbox360LTCFile(0, 0);
                _liveTitleTool.DeployXbox360Title(titleId, true, false);

                // Verify the title deployed correctly
                Xbox360Title title = Xbox360Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase, DVT]
        public class FuncDeployWithEditedLTC : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployWithEditedLTC";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D3;
                ResultCode = TEST_RESULTS.PASSED;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = CreateDefaultXLAST(titleId, caseName);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Create the LTC file
                _liveTitleTool.CreateXbox360LTCFile(0, 0);

                // Modify the LTC file
                LiveTitleConfig ltcFile = (LiveTitleConfig)ConfigFileSerializer.FromXml
                    (typeof(LiveTitleConfig), _liveTitleTool.LTCPath);
                ltcFile.AlternateTitleID1 = (int)(titleId + 1);
                ConfigFileSerializer.ToXml(_liveTitleTool.LTCPath, ltcFile);

                // Deploy and verify the title
                _liveTitleTool.DeployXbox360Title(titleId, true, false);
                Xbox360Title title = Xbox360Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase, DVT]
        public class FuncDeployMarketplaceFile : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployMarketplaceFile";
                BeginCase(caseName);

                XboxLiveMarketplaceProject marketplaceFile;
                uint titleId = 0xFFFE07DA;

                DeleteTitle(titleId);
                CopyInputFiles(caseName);

                ResultCode = TEST_RESULTS.PASSED;

                _liveTitleTool.MarketplacePath = Path.Combine(_tempPath, caseName + ".marketplace");
                _liveTitleTool.DeployMarketplaceOnlyTitle(titleId, true);

                marketplaceFile = XboxLiveMarketplaceProject.FromXml(_liveTitleTool.MarketplacePath);

                // Now prop the "real" title XLAST file over the top of the marketplace file
                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.FullGame, titleId, caseName, XLASTLanguage.English);
                uint[] langs = (uint[])Enum.GetValues(typeof(XLASTLanguage));
                foreach (uint lang in langs)
                {
                    // Don't add English - it's already the default language
                    if (lang == (uint)XLASTLanguage.English)
                    {
                        continue;
                    }
                    _xlastFactory.AddLanguage(xlast, (XLASTLanguage)lang);
                }
                _xlastFactory.AddAllRatings(xlast);
                _xlastFactory.AddGenre(xlast, XLASTGenre.Shooter);
                _xlastFactory.AddFeatures(xlast, 5);
                _xlastFactory.AddAchievements(xlast, 33, 1000);
                _xlastFactory.AddGameModes(xlast, 3);
                _xlastFactory.AddContexts(xlast, 6, 2);
                _xlastFactory.AddProperties(xlast, 11);
                _xlastFactory.AddStatsViews(xlast, 77);

                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Up the timeout value since this is such a large XLAST file
                _liveTitleTool.ExecutionTimeout = 300;  // 5 minutes
                _liveTitleTool.CreateXbox360LTCFile(0, 0);
                _liveTitleTool.DeployXbox360Title(titleId, true, true);

                ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId));
                if (TEST_RESULTS.PASSED == ResultCode)
                {
                    File.Delete(_liveTitleTool.MarketplacePath);
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncAddBaseVersion : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncAddBaseVersion";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D3;
                TitleVersions expVersions = new TitleVersions();
                ResultCode = TEST_RESULTS.PASSED;

                // Initialize the expected versions collection
                expVersions.Add(new TitleVersion());
                expVersions.Add(new TitleVersion());
                expVersions[0].BaseVersion = 101;
                expVersions[0].UpdateVersion = 101;
                expVersions[0].BetaVersion = 101;
                expVersions[1].BaseVersion = 201;
                expVersions[1].UpdateVersion = 201;
                expVersions[1].BetaVersion = 201;

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = CreateDefaultXLAST(titleId, caseName);
                _liveTitleTool.XlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Prop the title as version 101 and add the new 201 base version
                _liveTitleTool.DeployXbox360Title(titleId, true, false, 101);
                _liveTitleTool.AddTitleBaseVersion(titleId, 201, ConsoleTypeEnum.Xenon);

                // Verify the LiveTitle version report, then the actual values in the database
                string [] versionReport = _liveTitleTool.ReportTitleVersion(titleId);
                int i = 0;
                foreach (string verChain in versionReport)
                {
                    string expChain = string.Format("{0}:{1},{2},{3}", titleId, expVersions[i].BaseVersion,
                        expVersions[i].UpdateVersion, expVersions[i].BetaVersion);
                    if (verChain.CompareTo(expChain) != 0)
                    {
                        _report.Error("Verification Error: Mismatched version chain:\n\tExpected[{0}]\n\tActual[{1}]",
                            expChain, verChain);
                        ResultCode = TEST_RESULTS.FAILED;
                        break;
                    }
                    i++;
                }
                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    ResultCode = VerifyTitleVersions(titleId, expVersions);
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Remove the 101 version and verify that only the 201 remains
                    _liveTitleTool.DeleteTitleBaseVersion(titleId, 101, ConsoleTypeEnum.Xenon);
                    expVersions.RemoveAt(0);
                    ResultCode = VerifyTitleVersions(titleId, expVersions);
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    File.Delete(_liveTitleTool.XlastPath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }
    }

    /// <summary>
    /// LiveTitle Xbox 1 title deployment functional tests
    /// </summary>
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class FuncDeployXbox1Group : TestNode
    {
        [TestCase, DVT]
        public class FuncDeployXboxTitle : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncDeployXboxTitle";
                BeginCase(caseName);

                uint titleId = 0xFFFFAB00;

                DeleteTitle(titleId);
                CopyInputFiles(caseName);

                _liveTitleTool.XBOXPath = Path.Combine(_tempPath, caseName + ".xbox");
                _liveTitleTool.CreateXbox1LTCFile();
                _liveTitleTool.DeployXbox1Title(titleId);

                Xbox1Title title = Xbox1Title.Create(titleId);
                ResultCode = VerifyAllTitleData(title);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\FuncRedeploy.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;

namespace LiveTitleTest
{
	/// <summary>
	/// LiveTitle Xbox 360 title redeployment test cases
	/// </summary>
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
	public class FuncRedeployXbox360Group : TestNode
	{
        [TestCase]
        public class FuncRedeployXbox360Title : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncRedeployXbox360Title";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D3;
                string xlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                string updatePath = Path.Combine(_inputFilesPath, caseName + "_Update.xlast");

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                    XLASTTitleType.FullGame, titleId, caseName, XLASTLanguage.English);
                _xlastFactory.AddProperties(xlast, 10);
                _xlastFactory.AddContexts(xlast, 5, 3);
                _xlastFactory.AddAchievements(xlast, 34, 1100);
                _xlastFactory.AddStatsViews(xlast, 27);
                _xlastFactory.AddGameModes(xlast, 2);
                _liveTitleTool.XlastPath = xlastPath;
                ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                // Deploy the title
                _liveTitleTool.DeployXbox360Title(titleId);
                ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId));
                if (TEST_RESULTS.PASSED == ResultCode)
                {
                    // Add a Genre
                    _xlastFactory.AddGenre(xlast, XLASTGenre.Racing);

                    // Add a feature
                    _xlastFactory.AddFeature(xlast, XLASTFeature.Camera);

                    // Remove an Achievement
                    xlast.GameConfigProject.Achievements.Remove(xlast.GameConfigProject.Achievements.Count - 1);

                    // Change the title string
                    _xlastFactory.ModifyString(xlast, (ushort)XLASTDefaultString.X_STRINGID_TITLENAME, XLASTLanguage.English, titleId.ToString("X8"));

                    // Save the new file
                    _liveTitleTool.XlastPath = updatePath;
                    ConfigFileSerializer.ToXml(_liveTitleTool.XlastPath, xlast);

                    // Redeploy the title
                    _liveTitleTool.DeployXbox360Title(titleId, true, false);

                    // Verify the redeployment succeeded.
                    Xbox360Title title = Xbox360Title.Create(titleId);
                    ResultCode = VerifyAllTitleData(title);
                }

                if (TEST_RESULTS.PASSED == ResultCode)
                {
                    File.Delete(xlastPath);
                    File.Delete(updatePath);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }

        [TestCase]
        public class FuncRedeployLockedXbox360Title : LiveTitleTestBase
        {
            protected override void Execute()
            {
                string caseName = "FuncRedeployLockedXbox360Title";
                BeginCase(caseName);

                uint titleId = 0xFFFE07D5;
                string xlastPath = Path.Combine(_tempPath, caseName + ".xlast");
                string updatePath1 = Path.Combine(_tempPath, caseName + "_Update_1.xlast");
                string updatePath2 = Path.Combine(_tempPath, caseName + "_Update_2.xlast");

                DeleteTitle(titleId);

                XboxLiveSubmissionProject xlast = CreateDefaultXLAST(titleId, caseName);
                _xlastFactory.AddProperties(xlast, 3);
                _xlastFactory.AddContexts(xlast, 2, 5);
                _xlastFactory.AddStatsViews(xlast, 17);
                ConfigFileSerializer.ToXml(xlastPath, xlast);

                // Deploy the Title
                _liveTitleTool.XlastPath = xlastPath;
                _liveTitleTool.DeployXbox360Title(titleId);
                ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId));
                if (TEST_RESULTS.PASSED == ResultCode)
                {
                    // Lock the title
                    Global.RO.Info("Locking title 0x" + titleId.ToString("X8"));
                    _liveTitleTool.LockTitle();

                    // Update only the project version in the xlast file
                    _xlastFactory.UpdateVersion(xlast);
                    ConfigFileSerializer.ToXml(updatePath1, xlast);

                    // Redeploy the locked title using the /contentupdate flag, then without
                    Global.RO.Info("Redeploying title without changes");
                    _liveTitleTool.XlastPath = updatePath1;
                    _liveTitleTool.DeployXbox360Title(titleId, true, true);
                    _liveTitleTool.DeployXbox360Title(titleId, true, false);
                    ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId));

                    if (TEST_RESULTS.PASSED == ResultCode)
                    {
                        // Add some elements to the XLAST file
                        _xlastFactory.AddAchievements(xlast, 12, 250);
                        _xlastFactory.AddGameModes(xlast, 2);
                        _xlastFactory.AddStatsViews(xlast, 10);
                        _xlastFactory.UpdateVersion(xlast);
                        ConfigFileSerializer.ToXml(updatePath2, xlast);

                        // Redeploy with and without the /contentupdate flag
                        Global.RO.Info("Redploying title with changes");
                        _liveTitleTool.XlastPath = updatePath2;
                        _liveTitleTool.DeployXbox360Title(titleId, true, true);
                        _liveTitleTool.DeployXbox360Title(titleId, true, false);
                        ResultCode = VerifyAllTitleData(Xbox360Title.Create(titleId));
                    }
                }

                if (TEST_RESULTS.PASSED == ResultCode)
                {
                    File.Delete(xlastPath);
                    File.Delete(updatePath1);
                    File.Delete(updatePath2);
                    File.Delete(_liveTitleTool.LTCPath);
                }
            }
        }
	}

    /// <summary>
    /// LiveTitle Xbox 1 title redeployment test cases
    /// </summary>
    public class FuncRedeployXbox1Group : TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\LiveTitleTests.cs ===
using System;
using ServerTestFramework;

namespace LiveTitleTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livetitle_none_12.4.56.0_none_541fd7f6e41b4c8f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livetitle
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.manifest
XP_MANIFEST_PATH=manifests\msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.cat
XP_CATALOG_PATH=manifests\msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.cat
XP_PAYLOAD_PATH=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livetitle,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\Title.cs ===
using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LiveTitleTest
{
    public enum TitleDatabase
    {
        UODB,
        PCDB
    };

    public class TitleBase
    {
        protected uint _titleId;

        protected string _gameConfigXml;
        protected string _liveTitleConfigXml;
        protected StringServerStrings _titleStrings;

        protected TitleInformation _titleInfoUodb;
        protected WebdbTitleInformation _titleInfoWebdb;

        protected TitleBase(uint titleId)
        {
            _titleId = titleId;
            _gameConfigXml = string.Empty;
            _liveTitleConfigXml = string.Empty;
            _titleStrings = new StringServerStrings();
            _titleInfoUodb = new TitleInformation();
            _titleInfoWebdb = new WebdbTitleInformation();
        }


        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        public string GameConfig
        {
            get { return _gameConfigXml; }
            set { _gameConfigXml = value; }
        }

        public string LiveTitleConfig
        {
            get { return _liveTitleConfigXml; }
            set { _liveTitleConfigXml = value; }
        }

        public StringServerStrings TitleStrings
        {
            get { return _titleStrings; }
            set { _titleStrings = value; }
        }

        public TitleInformation UODBTitleData
        {
            get { return _titleInfoUodb; }
            set { _titleInfoUodb = value; }
        }

        public WebdbTitleInformation WebDbTitleData
        {
            get { return _titleInfoWebdb; }
            set { _titleInfoWebdb = value; }
        }

        public void Refresh()
        {
            GetNpdbTitleInformation();
            GetUodbAndPcdbTitleInformation();
            GetWebdbTitleInformation();
        }


        private void GetNpdbTitleInformation()
        {
            LiveTitleConfigRow ltcRow;
            GameConfigRow gcRow;
            NpdbUtility npdb;

            _gameConfigXml = null;
            _liveTitleConfigXml = null;
            _titleStrings = null;

            npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                npdb.GetGameConfig(_titleId, out gcRow);
                ltcRow = npdb.GetLiveTitleConfig(_titleId);
                _titleStrings = npdb.GetTitleStrings(_titleId);
            }
            finally
            {
                npdb.Close();
            }

            if (gcRow != null)
            {
                _gameConfigXml = gcRow.XmlConfig.Trim();
            }

            if (ltcRow != null)
            {
                _liveTitleConfigXml = ltcRow.XmlTitleConfig.Trim();
            }
        }

        private void GetUodbAndPcdbTitleInformation()
        {
            _titleInfoUodb = UodbWS.GetTitleInformation(_titleId);
        }

        private void GetWebdbTitleInformation()
        {
            Webdb webdb = new Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            try
            {
                _titleInfoWebdb = webdb.GetTitleInformation(_titleId);
            }
            finally
            {
                webdb.Close();
            }
        }

    }

    public class Xbox360Title : TitleBase
    {
        public Xbox360Title(uint titleId) : base(titleId) {}

        public static Xbox360Title Create(uint titleId)
        {
            Xbox360Title title = new Xbox360Title(titleId);
            title.Refresh();
            return title;
        }
    }

    public class Xbox1Title : TitleBase
    {
        public Xbox1Title(uint titleId) : base(titleId) {}

        public static Xbox1Title Create(uint titleId)
        {
            Xbox1Title title = new Xbox1Title(titleId);
            title.Refresh();
            return title;
        }
    }

    public class MarketplaceTitle : TitleBase
    {
        public MarketplaceTitle(uint titleId) : base(titleId) {}

        public static MarketplaceTitle Create(uint titleId)
        {
            MarketplaceTitle title = new MarketplaceTitle(titleId);
            title.Refresh();
            return title;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livetitle_none_12.4.56.0_none_541fd7f6e41b4c8f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livetitle
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.manifest
XP_MANIFEST_PATH=manifests\msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.cat
XP_CATALOG_PATH=manifests\msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f.cat
XP_PAYLOAD_PATH=msil_livetitle_no-public-key_12.4.56.0_x-ww_2c16296f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livetitle,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\LiveTitleTestBase.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LiveTitleTest
{
    /// <summary>
    /// Summary description for LiveTitleTestBase.
    /// </summary>
    public class LiveTitleTestBase : ToolsTestBase
    {
        protected Report _report = new Report("LiveTitleTest");
        protected LiveTitle _liveTitleTool;
        protected XLASTFactory _xlastFactory;
        protected string _inputFilesPath;
        protected string _tempPath;
        protected RandomEx _rnd;

        private const uint ARCADE_GENRE = 116000000;

        public LiveTitleTestBase()
        {
            _liveTitleTool = new LiveTitle();
            _xlastFactory = new XLASTFactory();
            _rnd = new RandomEx();

            // Query the Global object to get our test-specific data
            XmlNode liveTitleConfig = Global.Config.SelectSingleNode("descendant::LiveTitleTest");
            if (liveTitleConfig != null)
            {
                foreach (XmlNode setting in liveTitleConfig.ChildNodes)
                {
                    if (String.Compare(setting.Name, "DefaultToolPath", true) == 0)
                    {
                        _liveTitleTool.LiveTitlePath = Path.Combine(
                            Path.GetFullPath(setting.InnerText), "LiveTitle.exe");
                    }
                    else if (String.Compare(setting.Name, "InputFilePath", true) == 0)
                    {
                        _inputFilesPath = Path.GetFullPath(setting.InnerText);
                    }
                    else if (String.Compare(setting.Name, "TempDirectoryPath", true) == 0)
                    {
                        _tempPath = Path.GetFullPath(setting.InnerText);
                        if (!Directory.Exists(_tempPath))
                        {
                            Directory.CreateDirectory(_tempPath);
                        }
                    }
                }
            }
            else
            {
                throw new StfException("Unable to read the LiveTitleTest configuration settings.");
            }

            // Set the working directory for LiveTitle to be in the temporary files location
            _liveTitleTool.WorkingDirectory = _tempPath;

            // Copy all the png images into the temp directory
            string[] images = Directory.GetFiles(_inputFilesPath, "*.png");
            foreach (string image in images)
            {
                File.Copy(image, Path.Combine(_tempPath, Path.GetFileName(image)), true);
            }
        }

        protected override void Execute()
        {
            throw new StfException("Hey you! You forgot to override the Execute method!");
        }

        internal XboxLiveSubmissionProject CreateDefaultXLAST(uint titleId, string titleName)
        {
            XboxLiveSubmissionProject xlast = _xlastFactory.Create(XLASTFactory.SchemaVersion03,
                XLASTTitleType.FullGame, titleId, titleName, XLASTLanguage.English);
            _xlastFactory.AddAchievements(xlast, (uint)_rnd.Next(5, 61), 1000);
            return xlast;
        }

        internal void CopyInputFiles(string baseFileName)
        {
            string[] files = Directory.GetFiles(_inputFilesPath, baseFileName + "*.*");

            foreach (string file in files)
            {
                // Make sure LTC files are not copied
                if (!file.Contains("_ltc"))
                {
                    File.Copy(file, Path.Combine(_tempPath, Path.GetFileName(file)), true);
                }
            }

            // Copy all PNG files (only if they don't already exist)
            files = Directory.GetFiles(_inputFilesPath, "*.png");
            string destFile;
            foreach (string file in files)
            {
                destFile = Path.Combine(_tempPath, Path.GetFileName(file));
                if (!File.Exists(destFile))
                {
                    File.Copy(file, destFile);
                }
            }
        }

        internal void BeginCase(string caseName)
        {
            _report.Info("Begin Case: {0}", caseName);
        }

        internal void DeleteTitle(uint titleId)
        {
            // Delete the title from NPDB
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            try
            {
                npdb.IssueCommand("EXECUTE p_live_title_config_delete 0x" + titleId.ToString("X8"));
                npdb.IssueCommand("EXECUTE p_game_delete_config 0x" + titleId.ToString("X8"));
                npdb.IssueCommand("DELETE FROM t_stringsvr_strings WHERE i_title_id=0x" + titleId.ToString("X8"));
            }
            finally
            {
                npdb.Close();
            }

            // Delete the title from UODB
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_user_title_enumeration_times WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_title_services WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_title_ratings WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_title_trust_constants WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_title_culture_details WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_title_feature_data WHERE i_titleid=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_achievements WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("DELETE FROM t_stats_leaderboard_data WHERE i_title_id=0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("EXECUTE p_svc_delete_alternate_titleids 0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("EXECUTE p_svc_clear_title_genres 0x" + titleId.ToString("X8"), null);
            UodbWS.ExecuteSQLNonQuery("EXECUTE p_svc_clean_titles 0x" + titleId.ToString("X8"), null);

            // Delete the title from Webdb
            Webdb webdb = new Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            try
            {
                webdb.IssueCommand("DELETE FROM t_partner_allowed_titles WHERE i_title_id=0x" + titleId.ToString("X8"));
                webdb.IssueCommand("EXECUTE p_webdb_tmr_delete_title 0x" + titleId.ToString("X8"));
            }
            finally
            {
                webdb.Close();
            }

            // Clean the title configuration files from TitleVault
            CleanTitleVault(titleId);

            // Delete any local LTC files
            string localLTC = Path.Combine(_liveTitleTool.WorkingDirectory, titleId.ToString("x8") + "_ltc.xml");
            if (File.Exists(localLTC))
            {
                File.Delete(localLTC);
            }
        }

        internal void CleanTitleVault(uint titleId)
        {
            string titleVaultRoot = Global.XEnv.GetSetting(Setting.titlevault_root);
            string lockedRoot = Path.Combine(titleVaultRoot, "Locked");
            string dir;

            // Delete the title's directory
            dir = Path.Combine(titleVaultRoot, titleId.ToString("X8"));
            if (Directory.Exists(dir))
            {
                Directory.Delete(dir, true);
            }

            // Delete the title from the Locked directory
            dir = Path.Combine(lockedRoot, titleId.ToString("X8"));
            if (Directory.Exists(dir))
            {
                string [] files;

                // If the OLD directory exists, recurse through it and delete files
                if (Directory.Exists(Path.Combine(dir, "OLD")))
                {
                    files = Directory.GetFiles(Path.Combine(dir, "OLD"), "*.*");
                    foreach (string file in files)
                    {
                        File.SetAttributes(file, FileAttributes.Normal);
                        File.Delete(file);
                    }
                }

                // Remove the read-only attribute from each file and delete it
                files = Directory.GetFiles(dir, "*.*");
                foreach (string file in files)
                {
                    File.SetAttributes(file, FileAttributes.Normal);
                    File.Delete(file);
                }
                Directory.Delete(dir, true);
            }
        }

        internal TEST_RESULTS VerifyLTCDefaults(string ltcPath, XLASTTitleType titleType)
        {
            if (!File.Exists(ltcPath))
            {
                _report.Error("Unable to find the LTC file: {0}", ltcPath);
                return TEST_RESULTS.FAILED;
            }

            LiveTitleConfig ltc = ConfigFileSerializer.FromXml(typeof(LiveTitleConfig), ltcPath) as LiveTitleConfig;
            LiveTitleConfig exp = new LiveTitleConfig();
            TEST_RESULTS ret = TEST_RESULTS.PASSED;

            switch (titleType)
            {
                case XLASTTitleType.FullGame:
                    exp.MinAchievements = 5;
                    exp.MaxAchievements = 60;
                    exp.MinAchievementsWithCred = 5;
                    exp.MaxAchievementsWithCred = 60;
                    exp.MinCred = 1000;
                    exp.MaxCred = 1250;
                    exp.MaxUniqueAchImages = 60;
                    break;
                case XLASTTitleType.ArcadeTitle:
                    exp.MinAchievements = 12;
                    exp.MaxAchievements = 15;
                    exp.MinAchievementsWithCred = 5;
                    exp.MaxAchievementsWithCred = 15;
                    exp.MinCred = 200;
                    exp.MaxCred = 250;
                    exp.MaxUniqueAchImages = 60;
                    break;
                case XLASTTitleType.DemoTitle:
                case XLASTTitleType.SystemTitle:
                    exp.MinAchievements = 0;
                    exp.MaxAchievements = 0;
                    exp.MinAchievementsWithCred = 0;
                    exp.MaxAchievementsWithCred = 0;
                    exp.MinCred = 0;
                    exp.MaxCred = 0;
                    exp.MaxUniqueAchImages = 60;
                    break;
            }

            if (exp.MinAchievements != ltc.MinAchievements)
            {
                _report.Error("Mismatched MinAchievements value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MinAchievements, ltc.MinAchievements);
                ret = TEST_RESULTS.FAILED;
            }

            if (exp.MaxAchievements != ltc.MaxAchievements)
            {
                _report.Error("Mismatched MaxAchievements value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MaxAchievements, ltc.MaxAchievements);
                ret = TEST_RESULTS.FAILED;
            }

            if (exp.MinAchievementsWithCred != ltc.MinAchievementsWithCred)
            {
                _report.Error("Mismatched MinAchievementsWithCred value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MinAchievementsWithCred, ltc.MinAchievementsWithCred);
                ret = TEST_RESULTS.FAILED;
            }

            if (exp.MaxAchievementsWithCred != ltc.MaxAchievementsWithCred)
            {
                _report.Error("Mismatched MaxAchievementsWithCred value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MaxAchievementsWithCred, ltc.MaxAchievementsWithCred);
                ret = TEST_RESULTS.FAILED;
            }

            if (exp.MinCred != ltc.MinCred)
            {
                _report.Error("Mismatched MinCred value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MinCred, ltc.MinCred);
                ret = TEST_RESULTS.FAILED;
            }

            if (exp.MaxCred != ltc.MaxCred)
            {
                _report.Error("Mismatched MaxCred value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MaxCred, ltc.MaxCred);
                ret = TEST_RESULTS.FAILED;
            }

            if (exp.MaxUniqueAchImages != ltc.MaxUniqueAchImages)
            {
                _report.Error("Mismatched MaxUniqueAchImages value for a title of type {0}:\r\n" +
                              "Expected: {1}\r\n" +
                              "Actual:   {2}", titleType.ToString(), exp.MaxUniqueAchImages, ltc.MaxUniqueAchImages);
                ret = TEST_RESULTS.FAILED;
            }

            return ret;
        }

        internal TEST_RESULTS VerifyAllTitleData(TitleBase title)
        {
            TEST_RESULTS result, tmpResult;

            if (title is Xbox360Title)
            {
                XboxLiveSubmissionProject xlast =
                    ConfigFileSerializer.FromXml(typeof(XboxLiveSubmissionProject), _liveTitleTool.XlastPath) as XboxLiveSubmissionProject;
                LiveTitleConfig ltc =
                    ConfigFileSerializer.FromXml(typeof(LiveTitleConfig), _liveTitleTool.LTCPath) as LiveTitleConfig;

                result = Xbox360TitleVerifier.VerifyGameConfiguration(_liveTitleTool.XlastPath, title);
                tmpResult = Xbox360TitleVerifier.VerifyLiveTitleConfiguration(_liveTitleTool.LTCPath, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyTitleInformation(xlast.GameConfigProject, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyTitleStrings(xlast, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyCultureDetails(xlast.GameConfigProject, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyRatings(xlast.GameConfigProject.ProductInformation.RatingCollection, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyGenres(xlast.GameConfigProject.ProductInformation.GenreCollection, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyAlternateTitleIds(ltc, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyBountyExempt(ltc, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox360TitleVerifier.VerifyCrossPlatform(xlast.GameConfigProject.ProductInformation.PlatformCollection, ltc, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
            }
            else if (title is Xbox1Title)
            {
                XboxConfiguration xbox = XboxConfiguration.FromXml(_liveTitleTool.XBOXPath);
                LiveTitleConfig ltc = ConfigFileSerializer.FromXml(typeof(LiveTitleConfig), _liveTitleTool.LTCPath) as LiveTitleConfig;

                result = Xbox1TitleVerifier.VerifyGameConfiguration(_liveTitleTool.XBOXPath, title);
                tmpResult = Xbox1TitleVerifier.VerifyLiveTitleConfiguration(_liveTitleTool.LTCPath, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox1TitleVerifier.VerifyTitleInformation(xbox.GameConfig, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox1TitleVerifier.VerifyTitleStrings(xbox.LocalizedStrings, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox1TitleVerifier.VerifyAlternateTitleIds(ltc, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
                tmpResult = Xbox1TitleVerifier.VerifyBountyExempt(ltc, title);
                if (result == TEST_RESULTS.PASSED)
                {
                    result = tmpResult;
                }
            }
            else
            {
                _report.Error("VerifyAllTitleData: Unknown title object: {0}", title.GetType().ToString());
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        /// <summary>
        /// Verifies the last version in the specified title's version chain.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="baseVersion">Expected Base Version</param>
        /// <param name="updateVersion">Expected Update Version</param>
        /// <param name="betaVersion">Expected Beta Version</param>
        /// <returns>A TEST_RESULTS value indicating success or failure.</returns>
        internal TEST_RESULTS VerifyTitleVersions(uint titleId, uint baseVersion, uint updateVersion, uint betaVersion)
        {
            TEST_RESULTS resultCode = TEST_RESULTS.PASSED;

            // Get the title versions from UODB
            ArrayList versionList = UodbWS.GetAllTitleVersions(titleId);
            int i;

            // The returned arraylist is for all partitions of UODB, so we'll walk each one
            // to make sure the version is correct
            foreach (TitleVersions versions in versionList)
            {
                i = versions.Count - 1;
                if (versions[i].BaseVersion != baseVersion)
                {
                    _report.Error("Verification error: Incorrect Base Version. Expected[0x{0:X8}] Actual[0x{1:X8}]",
                        baseVersion, versions[i].BaseVersion);
                    resultCode = TEST_RESULTS.FAILED;
                }
                if (versions[i].UpdateVersion != updateVersion)
                {
                    _report.Error("Verification error: Incorrect Update Version. Expected[0x{0:X8}] Actual[0x{1:X8}]",
                        updateVersion, versions[i].UpdateVersion);
                    resultCode = TEST_RESULTS.FAILED;
                }
                if (versions[i].BetaVersion != betaVersion)
                {
                    _report.Error("Verification error: Incorrect Beta Version. Expected[0x{0:X8}] Actual[0x{1:X8}]",
                        betaVersion, versions[i].BetaVersion);
                    resultCode = TEST_RESULTS.FAILED;
                }
            }

            return resultCode;
        }

        /// <summary>
        /// Verifies the last version in the specified title's version chain using a single version number.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="version">Expected value for the Base, Update and Beta versions.</param>
        /// <returns>A TEST_RESULTS value indicating success or failure.</returns>
        internal TEST_RESULTS VerifyTitleVersions(uint titleId, uint version)
        {
            return VerifyTitleVersions(titleId, version, version, version);
        }

        /// <summary>
        /// Verifies an entire version chain for the specified title.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="versionChain">A collection of TitleVersion objects that represent the expected version chain.</param>
        /// <returns>A TEST_RESULTS value indicating success or failure.</returns>
        internal TEST_RESULTS VerifyTitleVersions(uint titleId, TitleVersions versionChain)
        {
            TEST_RESULTS resultCode = TEST_RESULTS.PASSED;
            ArrayList versionList = UodbWS.GetAllTitleVersions(titleId);

            // Check each UODB partition for the correct version chain
            for (int i = 0; i < versionList.Count; i++)
            {
                TitleVersions actChain = (versionList[i] as TitleVersions);

                // Make sure the number of entries match
                if (actChain.Count != versionChain.Count)
                {
                    _report.Error("Verification failure: Unmatched version chain length in UODB partition {0}:" +
                        "\n\tExpected [{1}]\n\tActual   [{2}]",
                        i, versionChain.Count, (versionList[i] as TitleVersions).Count);
                    resultCode = TEST_RESULTS.FAILED;
                    break;
                }

                // Verify the version chain
                for (int j = 0; j < versionChain.Count; j++)
                {
                    if (versionChain[j].BaseVersion != actChain[j].BaseVersion ||
                        versionChain[j].UpdateVersion != actChain[j].UpdateVersion ||
                        versionChain[j].BetaVersion != actChain[j].BetaVersion)
                    {
                        _report.Error("Verification failure: Mismatched version chain in UODB partition {0}:" +
                            "\n\tExpected [{1},{2},{3}]" +
                            "\n\tActual   [{4},{5},{6}]",
                            i, versionChain[j].BaseVersion, versionChain[j].UpdateVersion, versionChain[j].BetaVersion,
                            actChain[j].BaseVersion, actChain[j].UpdateVersion, actChain[j].BetaVersion);
                        resultCode = TEST_RESULTS.FAILED;
                    }
                }
            }

            return resultCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LiveTitle\TitleVerifier.cs ===
using System;
using System.IO;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;

namespace LiveTitleTest
{
    /// <summary>
    /// Contains methods that verify a title's data from the service with data from configuration files.
    /// This is the base class for Xbox360TitleVerifier and Xbox1TitleVerifier
    /// </summary>
    public class TitleVerifier
    {
        protected static Report _report = new Report("TitleVerifier");

        // This table is used to determine which XLAST locale to use when verifying Culture Details strings
        // Note that these strings must appear in the same order as found in the t_languages table in UODB.
        // (Add the extra "en-US" in the zero position for index out of range protection)
        protected static string[] Languages =
            { "en-US", "en-US", "ja-JP", "de-DE", "fr-FR", "es-ES", "it-IT", "ko-KR", "zh-CHT", "pt-PT", "zh_CHS", "pl-PL", "ru-RU" };

        protected TitleVerifier() {}

        public static TEST_RESULTS VerifyGameConfiguration(string gameConfigPath, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            StreamReader reader = new StreamReader(gameConfigPath);

            try
            {
                if (title.GameConfig != null && title.GameConfig.Length > 0)
                {
                    string expXml = reader.ReadToEnd();
                    if (String.Compare(expXml.Trim(), title.GameConfig) != 0)
                    {
                        result = TEST_RESULTS.FAILED;
                    }
                }
                else
                {
                    _report.Error("The Game Configuration XML hasn't been retrieved from NPDB.");
                }
            }
            finally
            {
                reader.Close();
            }

            return result;
        }

        public static TEST_RESULTS VerifyLiveTitleConfiguration(string ltcPath, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            StreamReader reader = new StreamReader(ltcPath);

            try
            {
                if (title.LiveTitleConfig != null && title.LiveTitleConfig.Length > 0)
                {
                    string expXml = reader.ReadToEnd();
                    if (String.Compare(expXml.Trim(), title.LiveTitleConfig) != 0)
                    {
                        result = TEST_RESULTS.FAILED;
                    }
                }
                else
                {
                    _report.Error("The Live Title Configuration XML hasn't been retrieved from NPDB.");
                }
            }
            finally
            {
                reader.Close();
            }

            return result;
        }

        public static TEST_RESULTS VerifyAlternateTitleIds(LiveTitleConfig expVal, TitleBase title)
        {
            TEST_RESULTS result;

            result = VerifyAlternateTitleIds(expVal, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyAlternateTitleIds(LiveTitleConfig expVal, TitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            if (expVal.TitleRegion != actVal.AlternateTitleId.TitleRegion)
            {
                ReportVerificationFailure(expVal.TitleRegion, actVal.AlternateTitleId.TitleRegion,
                    "Title region mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.DiscMediaID != actVal.AlternateTitleId.MediaId)
            {
                ReportVerificationFailure(expVal.DiscMediaID, actVal.AlternateTitleId.MediaId,
                    "Disc media id mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.LiveTitleID != actVal.AlternateTitleId.LiveTitleId)
            {
                ReportVerificationFailure(expVal.LiveTitleID, actVal.AlternateTitleId.LiveTitleId,
                    "Live title id mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.AlternateTitleID1 != actVal.AlternateTitleId.AlternateId1)
            {
                ReportVerificationFailure(expVal.AlternateTitleID1, actVal.AlternateTitleId.AlternateId1,
                    "Alternate title id 1 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.AlternateTitleID2 != actVal.AlternateTitleId.AlternateId2)
            {
                ReportVerificationFailure(expVal.AlternateTitleID2, actVal.AlternateTitleId.AlternateId2,
                    "Alternate title id 2 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.AlternateTitleID3 != actVal.AlternateTitleId.AlternateId3)
            {
                ReportVerificationFailure(expVal.AlternateTitleID3, actVal.AlternateTitleId.AlternateId3,
                    "Alternate title id 3 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.AlternateTitleID4 != actVal.AlternateTitleId.AlternateId4)
            {
                ReportVerificationFailure(expVal.AlternateTitleID4, actVal.AlternateTitleId.AlternateId4,
                    "Alternate title id 4 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service1 != actVal.AlternateTitleId.Service1)
            {
                ReportVerificationFailure(expVal.Service1, actVal.AlternateTitleId.Service1,
                    "Service 1 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service1AltID != actVal.AlternateTitleId.Service1AltId)
            {
                ReportVerificationFailure(expVal.Service1AltID, actVal.AlternateTitleId.Service1AltId,
                    "Service 1 alternate id mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service2 != actVal.AlternateTitleId.Service2)
            {
                ReportVerificationFailure(expVal.Service2, actVal.AlternateTitleId.Service2,
                    "Service 2 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service2AltID != actVal.AlternateTitleId.Service2AltId)
            {
                ReportVerificationFailure(expVal.Service2AltID, actVal.AlternateTitleId.Service2AltId,
                    "Service 2 alternate id mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service3 != actVal.AlternateTitleId.Service3)
            {
                ReportVerificationFailure(expVal.Service3, actVal.AlternateTitleId.Service3,
                    "Service 3 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service3AltID != actVal.AlternateTitleId.Service3AltId)
            {
                ReportVerificationFailure(expVal.Service3AltID, actVal.AlternateTitleId.Service3AltId,
                    "Service 3 alternate id mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service4 != actVal.AlternateTitleId.Service4)
            {
                ReportVerificationFailure(expVal.Service4, actVal.AlternateTitleId.Service4,
                    "Service 4 mismatch.");
                result = TEST_RESULTS.FAILED;
            }
            if (expVal.Service4AltID != actVal.AlternateTitleId.Service4AltId)
            {
                ReportVerificationFailure(expVal.Service4AltID, actVal.AlternateTitleId.Service4AltId,
                    "Service 4 alternate id mismatch.");
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        public static TEST_RESULTS VerifyBountyExempt(LiveTitleConfig expVal, TitleBase title)
        {
            TEST_RESULTS result;

            result = VerifyBountyExempt(expVal, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyBountyExempt(LiveTitleConfig expVal, TitleInformation actVal)
        {
            if (expVal.BountyExempt != actVal.BountyExempt)
            {
                ReportVerificationFailure(expVal.BountyExempt, actVal.BountyExempt,
                    "Bounty exempt is specified, but the title id doesn't appear in the bounty exempt table.");
                return TEST_RESULTS.FAILED;
            }

            return TEST_RESULTS.PASSED;
        }

        protected static void ReportVerificationFailure(object expVal, object actVal, string message, params object[] args)
        {
            _report.Error("Verification failure! {0}\r\n  Expected: {1}\r\n  Actual: {2}",
                string.Format(message, args), expVal == null ? "null" : expVal.ToString(),
                actVal == null ? "null" : actVal.ToString());
        }

        protected static void ReportVerificationFailure(bool expVal, bool actVal, string message, params object[] args)
        {
            _report.Error("Verification failure! {0}\r\n  Expected: {1}\r\n  Actual: {2}",
                string.Format(message, args), expVal, actVal);
        }

        protected static TranslationCollection GetStringTranslations(LocalizedStrings xlastData, int stringId)
        {
            if (xlastData == null)
                return new TranslationCollection();
            if (stringId == 0)
                return new TranslationCollection();

            foreach (LocalizedString str in xlastData.LocalizedStringCollection)
            {
                if (str.id == stringId)
                    return str.TranslationCollection;
            }

            return new TranslationCollection();
        }

        protected static TranslationCollection GetStringTranslations(LocalizedStrings xlastData, string friendlyName)
        {
            if (xlastData == null)
                return new TranslationCollection();
            if (friendlyName == null || friendlyName.Length == 0)
                return new TranslationCollection();

            foreach (LocalizedString str in xlastData.LocalizedStringCollection)
            {
                if (str.friendlyName == friendlyName)
                {
                    return str.TranslationCollection;
                }
            }

            return new TranslationCollection();
        }

        protected static string [] GetProductInformationStrings(GameConfigProject xlastData, string locale)
        {
            string [] strings = new string[5] {null,null,null,null,null};
            string expLocale = locale;
            bool localeSupported = false;
            TranslationCollection translations = null;

            // If the given locale string is null, use the default locale
            if (expLocale == null)
            {
                expLocale = xlastData.LocalizedStrings.defaultLocale;
            }

            // Look up the language ID to use with this locale code and convert that into the XLAST locale to use
            int languageId = UodbWS.GetLanguageId(expLocale);
            expLocale = Languages[languageId];

            // If this locale is not in the list of supported locales, just return the list of null strings
            foreach (SupportedLocale sl in xlastData.LocalizedStrings.SupportedLocaleCollection)
            {
                if (String.Compare(sl.locale, expLocale, true) == 0)
                {
                    localeSupported = true;
                    break;
                }
            }
            if (!localeSupported)
            {
                return null;
            }

            // First is the Title Name
            translations = GetStringTranslations(xlastData.LocalizedStrings, "X_STRINGID_TITLENAME");
            foreach (Translation strValue in translations)
            {
                if (String.Compare(strValue.locale, expLocale, true) == 0)
                {
                    strings[0] = strValue.Value;
                    break;
                }
            }

            // Publisher
            translations = GetStringTranslations(xlastData.LocalizedStrings, (int)xlastData.ProductInformation.publisherStringId);
            foreach (Translation strValue in translations)
            {
                if (String.Compare(strValue.locale, expLocale, true) == 0)
                {
                    strings[1] = strValue.Value;
                    break;
                }
            }

            // Developer
            translations = GetStringTranslations(xlastData.LocalizedStrings, (int)xlastData.ProductInformation.developerStringId);
            foreach (Translation strValue in translations)
            {
                if (String.Compare(strValue.locale, expLocale, true) == 0)
                {
                    strings[2] = strValue.Value;
                    break;
                }
            }

            // Sell Text
            translations = GetStringTranslations(xlastData.LocalizedStrings, (int)xlastData.ProductInformation.sellTextStringId);
            foreach (Translation strValue in translations)
            {
                if (String.Compare(strValue.locale, expLocale, true) == 0)
                {
                    strings[3] = strValue.Value;
                    break;
                }
            }

            // Genre
            translations = GetStringTranslations(xlastData.LocalizedStrings, (int)xlastData.ProductInformation.genreTextStringId);
            foreach (Translation strValue in translations)
            {
                if (String.Compare(strValue.locale, expLocale, true) == 0)
                {
                    strings[4] = strValue.Value;
                    break;
                }
            }

            return strings;
        }
    }


    public class Xbox360TitleVerifier : TitleVerifier
    {
        public static TEST_RESULTS VerifyTitleInformation(GameConfigProject expInfo, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            result = VerifyTitleInformation(expInfo, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyTitleInformation(GameConfigProject expInfo, TitleInformation actInfo)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            uint expTitleId;

            // Strip the "0x" from the title id and use it to verify the value from the service
            expTitleId = UInt32.Parse(expInfo.titleId.Substring(2), System.Globalization.NumberStyles.HexNumber);
            if (expTitleId != actInfo.TitleId)
            {
                ReportVerificationFailure(expTitleId, actInfo.TitleId, "Title ID mismatch in {0}", actInfo.SourceDb);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the console type
            if (actInfo.ConsoleTypeId != (byte)ConsoleTypeEnum.Xenon)
            {
                ReportVerificationFailure((byte)ConsoleTypeEnum.Xenon, actInfo.ConsoleTypeId,
                    "Console Type ID mismatch in {0}", actInfo.SourceDb);
                result = TEST_RESULTS.FAILED;
            }

            // Product Information
            if (expInfo.ProductInformation.offlinePlayersMax != actInfo.PlayersOffline)
            {
                ReportVerificationFailure(expInfo.ProductInformation.offlinePlayersMax, actInfo.PlayersOffline,
                    "Max Offline Players mismatch in {0}", actInfo.SourceDb);
                result = TEST_RESULTS.FAILED;
            }
            if (expInfo.ProductInformation.systemLinkPlayersMax != actInfo.PlayersSystemLink)
            {
                ReportVerificationFailure(expInfo.ProductInformation.systemLinkPlayersMax, actInfo.PlayersSystemLink,
                    "Max System Link Players mismatch in {0}", actInfo.SourceDb);
                result = TEST_RESULTS.FAILED;
            }
            if (expInfo.ProductInformation.livePlayersMax != actInfo.PlayersLive)
            {
                ReportVerificationFailure(expInfo.ProductInformation.livePlayersMax, actInfo.PlayersLive,
                    "Max Live Players mismatch in {0}", actInfo.SourceDb);
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        public static TEST_RESULTS VerifyGenres(GenreCollection expGenres, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            result = VerifyGenres(expGenres, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyGenres(GenreCollection expGenres, TitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool match;

            if (expGenres.Count == actVal.TitleGenres.Count)
            {
                foreach (Genre expGenre in expGenres)
                {
                    match = false;
                    foreach (TitleGenre actGenre in actVal.TitleGenres)
                    {
                        if (expGenre.genreId == (uint)actGenre.GenreId)
                        {
                            match = true;
                            break;
                        }
                    }

                    if (!match)
                    {
                        _report.Error("Verification failure! Unable to locate the genre in the database.\r\n    Expected:{0}",
                            expGenre.ToString());
                        result = TEST_RESULTS.FAILED;
                    }
                }
            }
            else
            {
                ReportVerificationFailure(expGenres.Count, actVal.TitleGenres.Count,
                    "Genre count mismatch");
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        public static TEST_RESULTS VerifyRatings(RatingCollection expRatings, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            result = VerifyRatings(expRatings, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyRatings(RatingCollection expRatings, TitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool match;

            // If there are no ratings defined, LiveTitle will enter a default rating of 7 (ESRB-RP)
            if (expRatings.Count > 0)
            {
                if (expRatings.Count == actVal.TitleRatings.Count)
                {
                    foreach (Rating expRating in expRatings)
                    {
                        match = false;
                        foreach (TitleRating actRating in actVal.TitleRatings)
                        {
                            if (expRating.ratingSystemId == actRating.RatingSystemId &&
                                expRating.ratingId == actRating.RatingId)
                            {
                                match = true;
                                break;
                            }
                        }

                        if (!match)
                        {
                            _report.Error("Verification failure! Unable to locate the Rating in the database:\r\n    Expected:{0}",
                                expRating.ToString());
                            result = TEST_RESULTS.FAILED;
                        }
                    }
                }
                else
                {
                    ReportVerificationFailure(expRatings.Count, actVal.TitleRatings.Count,
                        "Rating count mismatch");
                    result = TEST_RESULTS.FAILED;
                }
            }
            else
            {
                if (actVal.TitleRatings.Count != 1)
                {
                    ReportVerificationFailure("1", actVal.TitleRatings.Count,
                        "Unexpected number of ratings defined for title 0x{0:x}", actVal.TitleId);
                    result = TEST_RESULTS.FAILED;
                }
                else
                {
                    if (actVal.TitleRatings[0].RatingSystemId != 0)
                    {
                        ReportVerificationFailure(0, actVal.TitleRatings[0].RatingSystemId,
                            "Rating System mismatch");
                    }
                    if (actVal.TitleRatings[0].RatingId != 7)
                    {
                        ReportVerificationFailure(0, actVal.TitleRatings[0].RatingSystemId,
                            "Rating System mismatch");
                    }
                }
            }

            return result;
        }

        public static TEST_RESULTS VerifyCultureDetails(GameConfigProject expVal, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            result = VerifyCultureDetails(expVal, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyCultureDetails(GameConfigProject expVal, TitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            // We first need to get the set of default strings that are used
            // for locales that are not explicitely defined in the XLAST file.
            // Failure here means that the XLAST file is bogus.
            string [] defaultStrings = GetProductInformationStrings(expVal, null);
            if (defaultStrings == null)
            {
                _report.Error("No Product Information strings were found in the XLAST file for title 0x{0:x}", actVal.TitleId);
                return TEST_RESULTS.FAILED;
            }

            foreach (TitleCultureDetail tcd in actVal.TitleCultureDetails)
            {
                string [] strings = GetProductInformationStrings(expVal, tcd.Locale);
                if (strings == null)
                {
                    strings = defaultStrings;
                }

                // Verify the culture-specific strings
                if (tcd.Name != strings[0])
                {
                    ReportVerificationFailure(strings[0], tcd.Name,
                        "Title Name mismatch for {0}({1})", tcd.CultureId, tcd.Locale);
                    result = TEST_RESULTS.FAILED;
                }

                if (tcd.Publisher != strings[1])
                {
                    ReportVerificationFailure(strings[1], tcd.Publisher,
                        "Publisher string mismatch for {0}({1})", tcd.CultureId, tcd.Locale);
                    result = TEST_RESULTS.FAILED;
                }

                if (tcd.Developer != strings[2])
                {
                    ReportVerificationFailure(strings[2], tcd.Developer,
                        "Developer string mismatch for {0}({1})", tcd.CultureId, tcd.Locale);
                    result = TEST_RESULTS.FAILED;
                }

                if (tcd.SellText != strings[3])
                {
                    ReportVerificationFailure(strings[3], tcd.SellText,
                        "Sell Text string mismatch for {0}({1})", tcd.CultureId, tcd.Locale);
                    result = TEST_RESULTS.FAILED;
                }

                if (tcd.Genre != strings[4])
                {
                    ReportVerificationFailure(strings[4], tcd.Genre,
                        "Genre string mismatch for {0}({1})", tcd.CultureId, tcd.Locale);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        public static TEST_RESULTS VerifyTitleStrings(XboxLiveSubmissionProject xlast, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            LocalizedString expVal = null;

            if (title.TitleStrings == null)
            {
                _report.Error("The Title Strings have not been pulled from NPBD. Make sure GetNpdbTitleInformation has been called.");
                return TEST_RESULTS.FAILED;
            }

            // First look through the expected strings collection to find a string with
            // the friendly name of X_STRINGID_TITLENAME. The id doesn't matter.
            expVal = XLASTUtility.GetString(xlast, (ushort)XLASTDefaultString.X_STRINGID_TITLENAME);
            if (expVal == null)
            {
                _report.Error("Unable to find the title string in the XLAST file.");
                return TEST_RESULTS.FAILED;
            }

            // The number of title strings in the database must be compared to the number of
            // string translations that exist for the title string in the Game Config file.
            // Also note that the database contains a row with the locale "default", so make
            // sure the count from the database is decremented by one before comparing.
            //
            // Due to a trigger that was added to this table for MsgTool, all Japanese strings
            // get duplicated to the "jp-JP" locale. We need to account for that.
            if ((title.TitleStrings.Count - 1) != expVal.TranslationCollection.Count)
            {
                _report.Warn("The number of title strings doesn't match. Expected: {0}; Actual {1}.\r\n"
                    + "If the title contains Japanese strings, this may be expected.",
                    expVal.TranslationCollection.Count, title.TitleStrings.Count - 1);
            }

            // Don't compare the IDs because LiveTitle will always enter the Title String into
            // the database with an ID of 0, no matter what the ID is in the XLAST file.

            // Loop through the translations and compare the locales and string values
            foreach (StringServerString str in title.TitleStrings)
            {
                // special case the 'default' string
                if (str.Locale == "default")
                {
                    string val = XLASTUtility.GetDefaultStringTranslation(xlast, (ushort)XLASTDefaultString.X_STRINGID_TITLENAME);
                    if (val != str.Value)
                    {
                        ReportVerificationFailure(val, str.Value, "The default title strings don't match.");
                    }
                }
                else
                {
                    string val = XLASTUtility.GetStringTranslation(xlast, (ushort)XLASTDefaultString.X_STRINGID_TITLENAME, str.Locale);
                    if (val == null)
                    {
                        _report.Error("Unable to find a title string with the locale '{0}' in the XLAST file.", str.Locale);
                    }
                    else if (String.Compare(val, str.Value) != 0)
                    {
                        ReportVerificationFailure(val, str.Value, "Title string mismatch for locale '{0}'", str.Locale);
                    }
                }
            }

            foreach (Translation str in expVal.TranslationCollection)
            {
                StringServerString expStr = new StringServerString();
                expStr.Locale = str.locale;
                expStr.Value = str.Value;
                expStr.TitleId = title.TitleId;
                expStr.StringId = 0;

                // Using Contains will call the overridden Equals method on the StringServerString
                // object, which will test all the main values against the expected result.
                if (!title.TitleStrings.Contains(expStr))
                {
                    _report.Error("Verification failure! Unable to locate a title string translation in the database:\r\n{0}",
                        expStr.ToString());
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        public static TEST_RESULTS VerifyTitleFeatures(FeatureCollection expVal, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            result = VerifyTitleFeatures(expVal, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyTitleFeatures(FeatureCollection expVal, TitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            return result;
        }

        public static TEST_RESULTS VerifyCrossPlatform(PlatformCollection platforms, LiveTitleConfig ltc, TitleBase actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool expVal = false;

            // Two conditions must be met for Cross-Platform to be set:
            //  1. Both Xbox 360 and PC platforms are selected in the XLAST file
            //  2. The AllowCrossPlatformPlay element in the LTC file is set to true
            if (ltc.AllowCrossPlatformPlay)
            {
                expVal =
                    (platforms.Count == 2 &&
                    (platforms[0].id == (uint)XLASTPlatform.PC || platforms[0].id == (uint)XLASTPlatform.Xbox360) &&
                    (platforms[1].id == (uint)XLASTPlatform.PC || platforms[1].id == (uint)XLASTPlatform.Xbox360));
            }

            if (expVal != actVal.UODBTitleData.CrossPlatform)
            {
                ReportVerificationFailure(expVal, actVal, "Cross-Platform setting mismatch");
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        public static TEST_RESULTS VerifyWebdbTitleInformation(LocalizedStrings expVal, WebdbTitleInformation actVal)
        {
            LocalizedString expString = null;
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            // Verify the default locale
            if (String.Compare(expVal.defaultLocale, actVal.DefaultLocale, true) != 0)
            {
                ReportVerificationFailure(expVal.defaultLocale, actVal.DefaultLocale,
                    "Default Locale mismatch in Webdb");
                result = TEST_RESULTS.FAILED;
            }

            // First look through the XLAST object to find a string with the friendly name
            // of X_STRINGID_TITLENAME. The id doesn't matter.
            foreach (LocalizedString str in expVal.LocalizedStringCollection)
            {
                if (str.friendlyName == "X_STRINGID_TITLENAME")
                {
                    expString = str;
                    break;
                }
            }
            if (expString == null)
            {
                _report.Error("Unable to find a string with the friendly name 'X_STRINGID_TITLENAME' in the XLAST file.");
                return TEST_RESULTS.FAILED;
            }

            // Loop through the translations and compare the locales and string values
            foreach (Translation str in expString.TranslationCollection)
            {
                WebdbTitleName expStr = new WebdbTitleName();
                expStr.Locale = str.locale;
                expStr.DisplayName = str.Value;
                expStr.TitleId = actVal.TitleId;

                // Using Contains will call the overridden Equals method on the StringServerString
                // object, which will test all the main values against the expected result.
                if (!actVal.TitleNames.Contains(expStr))
                {
                    _report.Error("Verification failure! Unable to locate a title string translation in the database:\r\n{0}",
                        expStr.ToString());
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }
    }


    public class Xbox1TitleVerifier : TitleVerifier
    {
        public static TEST_RESULTS VerifyTitleStrings(XboxLocalizedStrings expStrings, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            XboxLocalizedString expVal = null;

            if (title.TitleStrings == null)
            {
                _report.Error("The Title Strings have not been pulled from NPBD. Make sure GetNpdbTitleInformation has been called.");
                return TEST_RESULTS.FAILED;
            }

            // First look through the XBOX object to find a string with the friendly name
            // of X_STRINGID_TITLENAME. The id doesn't matter.
            foreach (XboxLocalizedString str in expStrings.LocalizedStringCollection)
            {
                if (str.FriendlyName == "X_STRINGID_TITLENAME")
                {
                    expVal = str;
                    break;
                }
            }
            if (expVal == null)
            {
                _report.Error("Unable to find a string with the friendly name 'X_STRINGID_TITLENAME' in the XBOX file.");
                return TEST_RESULTS.FAILED;
            }

            // The number of title strings in the database must be compared to the number of
            // string translations that exist for the title string in the Game Config file.
            // Also note that the database contains a row with the locale "default", so make
            // sure the count from the database is decremented by one before comparing.
            if ((title.TitleStrings.Count - 1) != expVal.TranslationCollection.Count)
            {
                ReportVerificationFailure(title.TitleStrings.Count - 1, expVal.TranslationCollection.Count,
                    "Number of title strings mismatch.");
                return TEST_RESULTS.FAILED;
            }

            // Don't compare the IDs because LiveTitle will always enter the Title String into
            // the database with an ID of 0, no matter what the ID is in the XLAST file.

            // Loop through the translations and compare the locales and string values
            foreach (XboxTranslation str in expVal.TranslationCollection)
            {
                StringServerString expStr = new StringServerString();
                expStr.Locale = str.Locale;
                expStr.Value = str.Value;
                expStr.TitleId = title.TitleId;
                expStr.StringId = 0;

                // Using Contains will call the overridden Equals method on the StringServerString
                // object, which will test all the main values against the expected result.
                if (!title.TitleStrings.Contains(expStr))
                {
                    _report.Error("Verification failure! Unable to locate a title string translation in the database:\r\n{0}",
                        expStr.ToString());
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        public static TEST_RESULTS VerifyTitleInformation(XboxGameConfig expVal, TitleBase title)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            result = VerifyTitleInformation(expVal, title.UODBTitleData);

            return result;
        }

        public static TEST_RESULTS VerifyTitleInformation(XboxGameConfig expVal, TitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            uint expTitleId;

            // Strip the "0x" from the title id and use it to verify the value from the service
            expTitleId = UInt32.Parse(expVal.TitleId.Substring(2), System.Globalization.NumberStyles.HexNumber);
            if (expTitleId != actVal.TitleId)
            {
                ReportVerificationFailure(expTitleId, actVal.TitleId, "Title ID mismatch in {0}", actVal.SourceDb);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the console type
            if (actVal.ConsoleTypeId != (byte)ConsoleTypeEnum.Xbox1)
            {
                ReportVerificationFailure((byte)ConsoleTypeEnum.Xbox1, actVal.ConsoleTypeId,
                    "Console Type ID mismatch in {0}", actVal.SourceDb);
                result = TEST_RESULTS.FAILED;
            }

            // Feature Data
            // The only flag that should be true is the XboxSupport flag
            if (actVal.XboxSupport != true)
            {
                ReportVerificationFailure("false", actVal.XboxSupport,
                    "The XboxSupport flag mismatch in {0}", actVal.SourceDb);
                result = TEST_RESULTS.FAILED;
            }
            if (!(actVal.Camera == false &&
                (actVal.Camera == actVal.CoOp == actVal.CustomSoundtrack == actVal.Dolby51 == actVal.HardDriveEnhanced ==
                actVal.HardDriveRequired == actVal.LiveAware == actVal.LiveClans == actVal.LiveCoOp == actVal.LiveDownloads ==
                actVal.LiveFriends == actVal.LiveMessaging == actVal.LiveMultiplayer == actVal.LiveScoreboard ==
                actVal.LiveServiceProxy == actVal.LiveStats == actVal.LiveTournaments == actVal.LiveVoice ==
                actVal.LiveVoiceMessaging == actVal.MemoryUnit == actVal.MultiplayerVersus == actVal.Peripherals ==
                actVal.PremiumOffers == actVal.SystemLink == actVal.UserCreatableContent == actVal.Xbox2Support)))
            {
                _report.Error("Verification failure! One of the Feature Data flags for title 0x{0:x} is not false in {1}",
                    actVal.TitleId, actVal.SourceDb);
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        public static TEST_RESULTS VerifyWebdbTitleInformation(XboxConfiguration expVal, WebdbTitleInformation actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            XboxLocalizedString expString = null;

            // Only Xbox1 titles set the ClusterId
            if (expVal.WebdbInfo.ClusterID != actVal.ClusterId.ToString())
            {
                ReportVerificationFailure(expVal.WebdbInfo.ClusterID, actVal.ClusterId,
                    "Cluster ID mismatch in Webdb.");
                result = TEST_RESULTS.FAILED;
            }

            // Verify the default locale
            if (String.Compare(expVal.WebdbInfo.DefaultLocale, actVal.DefaultLocale, true) != 0)
            {
                ReportVerificationFailure(expVal.WebdbInfo.DefaultLocale, actVal.DefaultLocale,
                    "Default Locale mismatch in Webdb");
                result = TEST_RESULTS.FAILED;
            }

            // First look through the XBOX object to find a string with the friendly name
            // of X_STRINGID_TITLENAME. The id doesn't matter.
            foreach (XboxLocalizedString str in expVal.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.FriendlyName == "X_STRINGID_TITLENAME")
                {
                    expString = str;
                    break;
                }
            }
            if (expString == null)
            {
                _report.Error("Unable to find a string with the friendly name 'X_STRINGID_TITLENAME' in the XLAST file.");
                return TEST_RESULTS.FAILED;
            }

            // Loop through the translations and compare the locales and string values
            foreach (XboxTranslation str in expString.TranslationCollection)
            {
                WebdbTitleName expStr = new WebdbTitleName();
                expStr.Locale = str.Locale;
                expStr.DisplayName = str.Value;
                expStr.TitleId = actVal.TitleId;

                // Using Contains will call the overridden Equals method on the StringServerString
                // object, which will test all the main values against the expected result.
                if (!actVal.TitleNames.Contains(expStr))
                {
                    _report.Error("Verification failure! Unable to locate a title string translation in the database:\r\n{0}",
                        expStr.ToString());
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\AttackingAccounts.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;


namespace LMATests
{   
    
    /// <summary>
    /// This is a Singleton class to create and then re-use accounts for the attacking tests
    /// of the LMA test suite.
    /// </summary>
    class AttackingAccounts
    {
        private static AttackingAccounts m_instance;          //singleton instance passed back to clients
        private static object m_syncRoot = new object();    //object used to lock cricical sections

        private BillingAccount[] m_GoldAccounts;
        private BillingAccount[] m_SilverAccounts;

        private AttackingAccounts() 
        {
            //create 1 gold account
            m_GoldAccounts = new BillingAccount[1];
            for (int i = 0; i < m_GoldAccounts.Length; i++)
            {
                m_GoldAccounts[i] = new BillingAccount();
                m_GoldAccounts[i].user = new XeUser(true);//XbosUser.XenonGoldUser();
                m_GoldAccounts[i].user.CreateAsGold = true;
                ulong mPid = (m_GoldAccounts[i].user.MachinePuid & 0x00FFFFFFFFFFFF00);
                m_GoldAccounts[i].user.MachinePuid = (mPid | 0xFB00000000000001); // pc machine puid 
                m_GoldAccounts[i].user.m_request.Slot.authDataFlags |= 0x20;      //  Mark XeUser as LMA account
                if (m_GoldAccounts[i].user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + m_GoldAccounts[i].user.GetDumpString());

                m_GoldAccounts[i].isIdle = true;
            }
            //create 1 silver account
            m_SilverAccounts = new BillingAccount[1];
            for (int i = 0; i < m_GoldAccounts.Length; i++)
            {
                m_SilverAccounts[i] = new BillingAccount();
                m_SilverAccounts[i].user = new XeUser(true);//XbosUser.XenonSilverUser();
                m_SilverAccounts[i].user.CreateAsGold = false;
                m_SilverAccounts[i].user.m_request.Slot.authDataFlags |= 0x20;      //  Mark XeUser as LMA account
                ulong mPid = (m_SilverAccounts[i].user.MachinePuid & 0x00FFFFFFFFFFFF00);
                m_SilverAccounts[i].user.MachinePuid = (mPid | 0xFB00000000000001); // pc machine puid 
                if (m_SilverAccounts[i].user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + m_SilverAccounts[i].user.GetDumpString());

                m_SilverAccounts[i].isIdle = true;
            }
        }

        /// <summary>
        /// Returns the singleton instance of BillingAccounts
        /// </summary>
        public static AttackingAccounts Instance
        {
            get
            {
                if (m_instance == null)
                {
                    lock (m_syncRoot)   //enter critical section
                    {
                        if (m_instance == null)     //double check that it is still NULL before creating again
                        {
                            m_instance = new AttackingAccounts();
                        }
                    }
                }
                return m_instance;
            }
        }

        public XeUser GetSilverAccount(string TestName)
        {
            XeUser user = null;

            //  Search for an available account
            int index;
            for (index = 0; index < m_SilverAccounts.Length; index++)
            {
                if ( m_SilverAccounts[index].isIdle )
                    break;  //we found an account so break out
            }
            if (index < m_SilverAccounts.Length) //  Make sure that we found an account in the array
            {
                lock (m_syncRoot) //lock the array to check out account
                {
                    //  check that the account is still available
                    if (!m_SilverAccounts[index].isIdle)
                    {
                        //someone took the account search for another one
                        for (index = 0; index < m_SilverAccounts.Length; index++)
                        {
                            if (m_SilverAccounts[index].isIdle)
                                break;  //we found an account so break out
                        }
                    }
                    if (index < m_SilverAccounts.Length)
                    {
                        //  We were able to find an account so let's pass it back
                        m_SilverAccounts[index].isIdle = false;
                        m_SilverAccounts[index].owner = TestName;
                        user = m_SilverAccounts[index].user;
                    }
                }
            }
            return user;
        }

        public XeUser GetGoldAccount(string TestName)
        {
            XeUser user = null;

            //  Search for an available account
            int index;
            for (index = 0; index < m_GoldAccounts.Length; index++)
            {
                if (m_GoldAccounts[index].isIdle)
                    break;  //we found an account so break out
            }
            if (index < m_GoldAccounts.Length) //  Make sure that we found an account in the array
            {
                lock (m_syncRoot) //lock the array to check out account
                {
                    //  check that the account is still available
                    if (!m_GoldAccounts[index].isIdle)
                    {
                        //someone took the account search for another one
                        for (index = 0; index < m_GoldAccounts.Length; index++)
                        {
                            if (m_GoldAccounts[index].isIdle)
                                break;  //we found an account so break out
                        }
                    }
                    if (index < m_GoldAccounts.Length)
                    {
                        //  We were able to find an account so let's pass it back
                        m_GoldAccounts[index].isIdle = false;
                        m_GoldAccounts[index].owner = TestName;
                        user = m_GoldAccounts[index].user;

                    }
                }
            }
            return user;
        }

        public void ReturnAccount(ulong UserPuid)
        {
            //  Search for the Puid and then mark it as idle
            int index;
            for (index = 0; index < m_SilverAccounts.Length; index++)
            {
                if (m_SilverAccounts[index].user.UserPuid == UserPuid)
                {
                    m_SilverAccounts[index].isIdle = true;
                    m_SilverAccounts[index].owner = "";
                    return;
                }
            }

            for (index = 0; index < m_GoldAccounts.Length; index++)
            {
                if (m_GoldAccounts[index].user.UserPuid == UserPuid)
                {
                    m_GoldAccounts[index].isIdle = true;
                    m_GoldAccounts[index].owner = "";
                    return;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\Attacks.cs ===
/*
 * Written by: johenry
 * Limited Machine Account API Attacks
 * 
 * API's covered in file:  
 * XeGetUserSubscriptionDetails
 * XeGetUserWebInfo
 * XeGetAccountInfoFromPassport
 * XeGetUserWebInfo
 * XePassportGetUserData
 * XeUpsUpdateProfile
 * XeVerifyParentCreditCard
 * XeSetAccountInfo
 * 
 * 
 */

using System;
using System.Collections;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;

using MS.Swi.Mitm;
using MS.Swi.Mitm.Services;
using ServerTestFramework.Utilities.FclFuzzer;


namespace LMATests.Attacks
{
    [TestGroup, Owner("External"), TestFrequency("DoNotRun"), Description("Limited Machine Account Security Testing for GFWL Arcade  cagood")]
    class LMAttacks : TestNode
    {
        // have some users ready
        [TestGroupSetup]
        public void Setup()
        {
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }


        public static XeUser CreateXenonUser()
        {
            XeUser user = new XeUser(false);
            user.CreateAsGold = true;       //this line of code seems to be creating some problems with various tests
            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());

            UodbWS.WaitForQueueRemoval(user.UserPuid, true);


            return user;
        }

        public static XeUser CreateXenonUserForRecovery()
        {
            XeUser user = new XeUser(false);
            user.m_request.offlineXuid = PassportUtilities.GenerateRandomULong();
            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            Global.RO.Info("User 0x{0:x} created.", user.UserPuid);

            int c = 0;
            while (UodbWS.IsUserQueued(user.UserPuid) && c < 100)
            {
                c++;
                System.Threading.Thread.Sleep(100);
            }
            if (UodbWS.IsUserQueued(user.UserPuid)) throw new UnexpectedTestResultException("User never left queue.");

            return user;
        }

        public static XeUser CreateXenonUser(XeUser.Country countryCode)
        {
            XeUser user = new XeUser(false, countryCode);
            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            Global.RO.Info("User 0x{0:x} created.", user.UserPuid);

            int c = 0;
            while (UodbWS.IsUserQueued(user.UserPuid) && c < 100)
            {
                c++;
                System.Threading.Thread.Sleep(100);
            }

            if (UodbWS.IsUserQueued(user.UserPuid))
                throw new UnexpectedTestResultException("User never left queued state.");

            return user;
        }

        public static ulong CreateXboxComUser(out ulong passportPuid)
        {
            return CreateXboxComUser(103, out passportPuid);
        }

        public static ulong CreateXboxComUser(byte countryId, out ulong passportPuid)
        {
            // create an xbox com user
            XRLXeCreateXboxComAccount createRequest = new XRLXeCreateXboxComAccount(countryId);
            XRLXeCreateXboxComAccountResponse createResponse = new XRLXeCreateXboxComAccountResponse();

            if (!createRequest.Execute(out createResponse))
                throw new UnexpectedTestResultException("XeCreateXboxComAccount() failed: " + createRequest.GetDumpString());
            if (createRequest.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XeCreateXboxComAccount returned XErr=0x{0:x}", createRequest.XErr));
            if (createResponse.UserPuid == 0)
                throw new UnexpectedTestResultException("XeCreateXboxComAccount return value was 0.");

            passportPuid = createRequest.UserPassportPuid;
            return createResponse.UserPuid;
        }



        /// <summary>
        /// Example case for LMA functionality and fuzzing
        /// </summary>
        [TestCase]
        class P_XeSetAccountInfo : UserTestBase
        {
            public P_XeSetAccountInfo()
            { }

            //*************************************************************
            //  This variable and constructor will allow us to tell the test
            //  which parameter we want it to fuzz
            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeSetAccountInfo(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                userPuid,
                machinePuid,
                firstNameLength,
                firstName,
                lastNameLength,
                lastname,
                birthdate,
                emailLength,
                email,
                addressInfo,
                phoneInfo,
                languageId,
                msftOptIn,
                partnerOptIn,
            }
            //**************************************************************

            override protected void Execute()
            {
                XRLXeSetAccountInfo request = new XRLXeSetAccountInfo();

                // must call this in order to set slot data
                request.ManualPopulateSlot();
                // slot data, required to indicate LMA
                request.Slot.authDataFlags |= 0x20;
                request.Slot.machinePuid = 0xFB00000000000001;
                request.Slot.userPuid0 = 12345678;
                // end LMA specific configuration
                    

                //Create the new user
                XeUser user = new XeUser(false);
                if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
                Global.RO.Info("User 0x{0:x} created.", user.UserPuid);

                //****************************************
                // IMPORTANT -  This is the code that sets the flag to know that this is an LMA this must
                //              appear after the XeUser is created but before you do anything else
                user.m_request.Slot.authDataFlags |= 0x20;
                //****************************************

                request.UserPuid = user.UserPuid;
                request.FirstName = "Tom";
                request.LastName = "Sawyer";
                request.Birthdate = user.BirthDate;
                request.Email = user.Email;
                request.AddressInfo = user.AddressInfo;
                request.PhoneInfo = user.PhoneInfo;
                request.LanguageId = 1;
                request.MsftOptIn = 0;
                request.PartnerOptIn = 0;

                #region Fuzzing Switch Statement
                if (LMATests.m_EnableFuzzTesting)
                {
                    switch (m_ParmToFuzz)
                    {
                        case FuzzParameter.firstName:
                            FclFuzzer.Fuzz("FirstName", ref request.FirstName);
                            break;
                        case FuzzParameter.lastname:
                            FclFuzzer.Fuzz("LastName", ref request.LastName);
                            break;
                        case FuzzParameter.email:
                            FclFuzzer.Fuzz("Email", ref request.Email);
                            break;
                        case FuzzParameter.languageId:
                            FclFuzzer.Fuzz("", "LanguageId", ref request.LanguageId);
                            break;

                        default:
                            //  parameter not found 
                            break;
                    };
                }
                #endregion

                if (!request.Execute())
                    throw new UnexpectedTestResultException("XeSetAccountInfo failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XeSetAccountInfo returned XErr=0x{0:x}", request.XErr));

                XRLXeGetAccountInfo getAccountInfo = new XRLXeGetAccountInfo();
                XRLXeGetAccountInfoResponse accountData = new XRLXeGetAccountInfoResponse();
                getAccountInfo.UserPuid = user.UserPuid;
                if (!getAccountInfo.Execute(out accountData))
                    throw new UnexpectedTestResultException("XeGetAccountInfo failed: " + request.GetDumpString());
                if (getAccountInfo.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XeGetAccountInfo returned XErr=0x{0:x}", request.XErr));

                //********************************************
                //  We only need to verify the results if we are in Functional mode so
                //  I put the actual functional verification code in this conditional
                if (!LMATests.m_EnableFuzzTesting)
                {
                    if (accountData.FirstName != request.FirstName) throw new ApplicationException("First Names don't match");
                    if (accountData.LastName != request.LastName) throw new ApplicationException("Last Names don't match");
                }
                //********************************************

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Fuzz Test listings.  
        /// </summary>

        //******************************************
        //  Each stress test here will fuzz one of the parameters for the API, this way we
        //  have the option to check or test only (to do this remove the other stress tests
        //  from GetStressTests().  We don't need to use the Priority flag as we should use
        //  the TPS / Async option in the STFRunner.exe -stress menu
        [StressTest(TargetTPS = 1)]
        public class XeSetAccountInfo_firstName : FuncToStressAdapter
        {
            public XeSetAccountInfo_firstName()
                : base(new P_XeSetAccountInfo(P_XeSetAccountInfo.FuzzParameter.firstName))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class XeSetAccountInfo_lastname : FuncToStressAdapter
        {
            public XeSetAccountInfo_lastname()
                : base(new P_XeSetAccountInfo(P_XeSetAccountInfo.FuzzParameter.lastname))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class XeSetAccountInfo_email : FuncToStressAdapter
        {
            public XeSetAccountInfo_email()
                : base(new P_XeSetAccountInfo(P_XeSetAccountInfo.FuzzParameter.email))
            { }
        }

        //End of the the Example
        //***********************************************************

        //////////////////////////
        //  LMA Allowed functions

        #region XeGetUserSubscriptionDetails
        [TestCase]
        class P_XeGetUserSubscriptionDetails : UserTestBase
        {

            #region Constructor and Fuzzing Enum
            public P_XeGetUserSubscriptionDetails() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeGetUserSubscriptionDetails(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                userPuid,
                machinePuid,
                offerId,
            }
            #endregion

            override protected void Execute()
            {
                //XeUser user = CreateXenonUser(6, true);
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeSubscriptionDetails");
                try
                {
                    XRLXeGetUserSubscriptionDetails request = new XRLXeGetUserSubscriptionDetails();
                    XRLXeGetUserSubscriptionDetailsResponse response = new XRLXeGetUserSubscriptionDetailsResponse();

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA

//                    request.Slot.authDataFlags |= 0x20;
//                    request.Slot.machinePuid = 0xFB00000000000001;
//                    request.Slot.userPuid0 = 12345678;
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    
                    // end LMA specific configuration

                    request.UserPuid = user.UserPuid;
                    request.OfferId = UodbWS.GetUsersSubscriptionOfferId(user.UserPuid);
                    request.InstanceId = UodbWS.GetUsersSubscriptionInstanceId(user.UserPuid);

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                break;
                            case FuzzParameter.machinePuid:
                                FclFuzzer.Fuzz("", "MachinePuid", ref request.MachinePuid);
                                break;
                            case FuzzParameter.offerId:
                                FclFuzzer.Fuzz("", "OfferId", ref request.OfferId);
                                break;
                            case (FuzzParameter.RandomFuzz):
                                Random randomNum = new Random();
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "MachinePuid", ref request.MachinePuid);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "OfferId", ref request.OfferId);
                                break;
                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                    {
                        Global.RO.Info("HttpStatus 0x{0:x}.", request.httpStatus );
                        throw new UnexpectedTestResultException("XRLXeGetUserSubscriptionDetails failed: " + request.GetDumpString());
                    }
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserSubscriptionDetails returned XErr=0x{0:x}", request.XErr));

                    //PrintResponse(request.UserPuid, response);

                    this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        [TestCase]
        class N_XeGetUserSubscriptionDetails : UserTestBase
        {

            #region Constructor and Fuzzing Enum
            public N_XeGetUserSubscriptionDetails() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public N_XeGetUserSubscriptionDetails(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                userPuid,
                machinePuid,
                offerId,
            }
            #endregion

            override protected void Execute()
            {
                //XeUser user = CreateXenonUser(6, true);
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeSubscriptionDetails");
                XeUser user2 = Accounts.GetSilverAccount("XeSubscriptionDetails");

                try
                {
                    XRLXeGetUserSubscriptionDetails request = new XRLXeGetUserSubscriptionDetails();
                    XRLXeGetUserSubscriptionDetailsResponse response = new XRLXeGetUserSubscriptionDetailsResponse();

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA

                    //                    request.Slot.authDataFlags |= 0x20;
                    //                    request.Slot.machinePuid = 0xFB00000000000001;
                    //                    request.Slot.userPuid0 = 12345678;
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;

                    // end LMA specific configuration

                    // ask for the profile from a different user, should fail
                    request.UserPuid = user2.UserPuid;
                    request.OfferId = UodbWS.GetUsersSubscriptionOfferId(user2.UserPuid);
                    request.InstanceId = UodbWS.GetUsersSubscriptionInstanceId(user2.UserPuid);

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                break;
                            case FuzzParameter.machinePuid:
                                FclFuzzer.Fuzz("", "MachinePuid", ref request.MachinePuid);
                                break;
                            case FuzzParameter.offerId:
                                FclFuzzer.Fuzz("", "OfferId", ref request.OfferId);
                                break;
                            case (FuzzParameter.RandomFuzz):
                                Random randomNum = new Random();
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "MachinePuid", ref request.MachinePuid);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "OfferId", ref request.OfferId);
                                break;
                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                    {
                        Global.RO.Info("HttpStatus 0x{0:x}.", request.httpStatus);
                        throw new UnexpectedTestResultException("XRLXeGetUserSubscriptionDetails failed: " + request.GetDumpString());
                    }
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserSubscriptionDetails returned XErr=0x{0:x}", request.XErr));

                    //PrintResponse(request.UserPuid, response);

                    this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        #endregion

        #region XeGetUserWebInfo

        [TestCase]
        class P_XeGetUserWebInfo : UserTestBase
        {
            #region Constructor and Fuzzing Enum
            public P_XeGetUserWebInfo() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeGetUserWebInfo(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                userPuid,
                serviceType,
            }
            #endregion

            override protected void Execute()
            {
                XRLXeGetUserWebInfo request = new XRLXeGetUserWebInfo();
                XRLXeGetUserWebInfoResponse response = new XRLXeGetUserWebInfoResponse();

                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeGetUserWebInfo");
                try
                {
                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration

                    // Original code removed for silver test and setup of gold account
                    request.UserPuid = user.UserPuid;

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                break;

                            //TODO:cagood the XRL object for this API does not have a way to get to the
                            //            serviceType parameter
                            //case FuzzParameter.serviceType:
                            //    FclFuzzer.Fuzz("", "UserPuid", ref request.serviceType);
                            //    break;

                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException("XRLXeGetUserWebInfo failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserWebInfo returned XErr=0x{0:x}", request.XErr));

                    if (response.Tier != 6 && !LMATests.m_EnableFuzzTesting) throw new ApplicationException("Expected gold tier to be returned.");

                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        [TestCase]
        class N_XeGetUserWebInfo : UserTestBase
        {
            #region Constructor and Fuzzing Enum
            public N_XeGetUserWebInfo() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public N_XeGetUserWebInfo(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }
            #endregion

            public enum FuzzParameter
            {
                None = 0,
                userPuid,
                serviceType,
            }

            override protected void Execute()
            {
                XRLXeGetUserWebInfo request = new XRLXeGetUserWebInfo();
                XRLXeGetUserWebInfoResponse response = new XRLXeGetUserWebInfoResponse();

                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeGetUserWebInfo");
                XeUser user2 = Accounts.GetSilverAccount("XeSubscriptionDetails");
                try
                {
                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration

                    // Original code removed for silver test and setup of gold account
                    request.UserPuid = user2.UserPuid;

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                break;

                            //TODO:cagood the XRL object for this API does not have a way to get to the
                            //            serviceType parameter
                            //case FuzzParameter.serviceType:
                            //    FclFuzzer.Fuzz("", "UserPuid", ref request.serviceType);
                            //    break;

                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException("XRLXeGetUserWebInfo failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserWebInfo returned XErr=0x{0:x}", request.XErr));

                    if (response.Tier != 6 && !LMATests.m_EnableFuzzTesting) throw new ApplicationException("Expected gold tier to be returned.");

                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }
        
        #region XeGetUserWebInfo Stress Tests

        [StressTest(TargetTPS = 1)]
        public class XeGetUserWebInfo_userPuid : FuncToStressAdapter
        {
            public XeGetUserWebInfo_userPuid()
                : base(new P_XeGetUserWebInfo(P_XeGetUserWebInfo.FuzzParameter.userPuid))
            { }
        }
        //[StressTest(TargetTPS = 1)]
        //public class XeGetUserWebInfo_profile : FuncToStressAdapter
        //{
        //    public XeGetUserWebInfo_profile()
        //        : base(new P_XeGetUserWebInfo(P_XeGetUserWebInfo.FuzzParameter.serviceType))
        //    { }
        //}
        #endregion


        #endregion

        #region XeUpdateParentalControls
        [TestCase]
        class P_XeUpdateParentalControls : UserTestBase
        {

            #region Constructor and Fuzzing Enum
            public P_XeUpdateParentalControls() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeUpdateParentalControls(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                userPuid,
                Source, 
                SourceLength,
                UserGrantPrivileges,
                UsuerRestrictPrivileges
            }
            #endregion

            override protected void Execute()
            {
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeUpdateParentalControls");

                try
                {
                    XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
//                    XRLXeUpdateParentalControlsResponse response = new XRLXeUpdateParentalControlsResponse();

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration
                    
                    
                    // standard information for this request
                    request.UserPuid = user.UserPuid;
                    request.Source = "";
                    request.SourceLength = 0;
                    request.UserGrantPrivileges = null;
                    request.UserRestrictPrivileges = null;
                    
                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                break;
//                            case FuzzParameter.Source:
  //                              FclFuzzer.Fuzz("", "Source", ref request.Source);
    //                            break;
                            case FuzzParameter.SourceLength:
                                FclFuzzer.Fuzz("", "SourceLength", ref request.SourceLength);
                                break;
                            case FuzzParameter.UserGrantPrivileges:
                                FclFuzzer.Fuzz("", "UserGrantPrivileges", ref request.UserGrantPrivileges[0]);
                                break;
//                            case FuzzParameter.UserRestrictPrivileges:
  //                              FclFuzzer.Fuzz("", "UserRestrictPrivileges", ref request.UserRestrictPrivileges[0]);
    //                            break;
                            case (FuzzParameter.RandomFuzz):
                                Random randomNum = new Random();
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);//
//                                if (randomNum.Next(2) == 1)
  //                                  FclFuzzer.Fuzz("", "Source", ref request.Source);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "SourceLength", ref request.SourceLength);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserGrantPrivileges", ref request.UserGrantPrivileges[0]);
//                                if (randomNum.Next(2) == 1)
  //                                  FclFuzzer.Fuzz("", "UserRestrictPrivileges", ref request.UserRestrictPrivileges[0]);


                                break;
                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute() && !LMATests.m_EnableFuzzTesting)
  //                      throw new UnexpectedTestResultException("XRLXeGetUserSubscriptionDetails failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserSubscriptionDetails returned XErr=0x{0:x}", request.XErr));

                    //PrintResponse(request.UserPuid, response);

                    this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        [TestCase]
        class N_XeUpdateParentalControls : UserTestBase
        {

            #region Constructor and Fuzzing Enum
            public N_XeUpdateParentalControls() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public N_XeUpdateParentalControls(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                userPuid,
                Source,
                SourceLength,
                UserGrantPrivileges,
                UsuerRestrictPrivileges
            }
            #endregion

            override protected void Execute()
            {
                //XeUser user = CreateXenonUser(6, true);
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeUpdateParentalControls");
                XeUser user2 = Accounts.GetSilverAccount("XeUpdateParentalControls");

                try
                {
                    XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
                    //                    XRLXeUpdateParentalControlsResponse response = new XRLXeUpdateParentalControlsResponse();

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration

                    request.UserPuid = user2.UserPuid; // should fail
                    request.Source = "";
                    request.SourceLength = 0;
                    request.UserGrantPrivileges = null;
                    request.UserRestrictPrivileges = null;

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                break;
                            //                            case FuzzParameter.Source:
                            //                              FclFuzzer.Fuzz("", "Source", ref request.Source);
                            //                            break;
                            case FuzzParameter.SourceLength:
                                FclFuzzer.Fuzz("", "SourceLength", ref request.SourceLength);
                                break;
                            case FuzzParameter.UserGrantPrivileges:
                                FclFuzzer.Fuzz("", "UserGrantPrivileges", ref request.UserGrantPrivileges[0]);
                                break;
                            //                            case FuzzParameter.UserRestrictPrivileges:
                            //                              FclFuzzer.Fuzz("", "UserRestrictPrivileges", ref request.UserRestrictPrivileges[0]);
                            //                            break;
                            case (FuzzParameter.RandomFuzz):
                                Random randomNum = new Random();
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);//
                                //                                if (randomNum.Next(2) == 1)
                                //                                  FclFuzzer.Fuzz("", "Source", ref request.Source);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "SourceLength", ref request.SourceLength);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserGrantPrivileges", ref request.UserGrantPrivileges[0]);
                                //                                if (randomNum.Next(2) == 1)
                                //                                  FclFuzzer.Fuzz("", "UserRestrictPrivileges", ref request.UserRestrictPrivileges[0]);


                                break;
                            default:
                                break;
                        }
                    }
                    #endregion

                    //                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                    //                      throw new UnexpectedTestResultException("XRLXeGetUserSubscriptionDetails failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeGetUserSubscriptionDetails returned XErr=0x{0:x}", request.XErr));

                    //PrintResponse(request.UserPuid, response);

                    this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        #endregion

        #region XeUpsGetProfile

        [TestCase]
        class P_XeUpsGetProfile : UserTestBase
        {
            #region Constructors and fuzzing enum

            public P_XeUpsGetProfile()
            {
            }

            //  This variable and constructor will allow us to tell the test which parameter we want it to fuzz
            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeUpsGetProfile(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                userPuid,
                attributesLength,
                attributes,
            }

            #endregion

            protected override void Execute()
            {
                // create a xenon user
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeUpsGetProfile");
                try
                {
                    XRLXeUpsGetProfile request = new XRLXeUpsGetProfile();
                    XRLXeUpsGetProfileResponse response;

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration

                    request.Puid = user.UserPuid;
                    request.Attributes = "attributes";

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case (FuzzParameter.userPuid):
                                FclFuzzer.Fuzz("", "Puid", ref request.Puid);
                                break;
                            case (FuzzParameter.attributesLength):
                                FclFuzzer.Fuzz("", "AttributesLength", ref request.AttributesLength);
                                break;
                            case (FuzzParameter.attributes):
                                FclFuzzer.Fuzz("Attributes", ref request.Attributes);
                                break;
                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException("Error executing XRLXeUpsGetProfile(): " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeUpsGetProfile returned XErr=0x{0:x}", request.XErr));

                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        [TestCase]
        class N_XeUpsGetProfile : UserTestBase
        {
            #region Constructors and fuzzing enum

            public N_XeUpsGetProfile()
            {
            }

            //  This variable and constructor will allow us to tell the test which parameter we want it to fuzz
            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public N_XeUpsGetProfile(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                userPuid,
                attributesLength,
                attributes,
            }

            #endregion

            protected override void Execute()
            {
                // create a xenon user
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeUpsGetProfile");
                XeUser user2 = Accounts.GetSilverAccount("XeUpsGetProfile");
                try
                {
                    XRLXeUpsGetProfile request = new XRLXeUpsGetProfile();
                    XRLXeUpsGetProfileResponse response;

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration

                    request.Puid = user2.UserPuid;
                    request.Attributes = "attributes";

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case (FuzzParameter.userPuid):
                                FclFuzzer.Fuzz("", "Puid", ref request.Puid);
                                break;
                            case (FuzzParameter.attributesLength):
                                FclFuzzer.Fuzz("", "AttributesLength", ref request.AttributesLength);
                                break;
                            case (FuzzParameter.attributes):
                                FclFuzzer.Fuzz("Attributes", ref request.Attributes);
                                break;
                            default:
                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException("Error executing XRLXeUpsGetProfile(): " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeUpsGetProfile returned XErr=0x{0:x}", request.XErr));

                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }

        #endregion

        #region XeUpsUpdateProfile
        [TestCase]
        class P_XeUpsUpdateProfile : UserTestBase
        {
            #region Constructor and Fuzzing Enum
            public P_XeUpsUpdateProfile() { }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeUpsUpdateProfile(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                profileLength,
                profile,
            }
            #endregion

            override protected void Execute()
            {
                //XeUser user = CreateXenonUser();
                AttackingAccounts Accounts = AttackingAccounts.Instance;
                XeUser user = Accounts.GetGoldAccount("XeUpsUpdateProfile");
                try
                {
                    // update the xbox namespace
                    UpsProfile xboxProfile = new UpsProfile();
                    xboxProfile.Email = user.PassportMemberName;
                    xboxProfile.PhonePrefix = user.PhoneInfo.PhonePrefix;
                    xboxProfile.PhoneNumber = user.PhoneInfo.PhoneNumber;
                    xboxProfile.PhoneExtension = user.PhoneInfo.PhoneExtension;


                    //xboxProfile.UpdateUpsProfile(user.PassportUserPuid); <before>
                    XRLXeUpsUpdateProfile request = new XRLXeUpsUpdateProfile();
                    request.Profile = xboxProfile.ReturnUpsProfileXML(user.PassportUserPuid);

                    // must call this in order to set slot data
                    request.ManualPopulateSlot();
                    // slot data, required to indicate LMA
                    request.Slot.authDataFlags = user.m_request.Slot.authDataFlags;
                    request.Slot.machinePuid = user.m_request.Slot.machinePuid;
                    request.Slot.userPuid0 = user.UserPuid;
                    // end LMA specific configuration
                  

                    #region Fuzzing Switch Statement
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.profile:
                                FclFuzzer.Fuzz("UserPuid", ref request.Profile);
                                break;
                            case FuzzParameter.profileLength:
                                FclFuzzer.Fuzz("", "UserPuid", ref request.ProfileLength);
                                break;
                            case (FuzzParameter.RandomFuzz):
                                Random randomNum = new Random();
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("UserPuid", ref request.Profile);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserPuid", ref request.ProfileLength);
                                break;
                            default:
                                break;
                        }
                    }
                    #endregion


                    if (!request.Execute() && !LMATests.m_EnableFuzzTesting)
                        throw new Exception("XRLXeUpsUpdateProfile.Execute failed: " + request.GetDumpString());


                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }
        }
        #region XeUpsUpdateProfile Stress Tests

        [StressTest(TargetTPS = 1)]
        public class XeUpsUpdateProfile_profileLength : FuncToStressAdapter
        {
            public XeUpsUpdateProfile_profileLength()
                : base(new P_XeUpsUpdateProfile(P_XeUpsUpdateProfile.FuzzParameter.profileLength))
            { }
        }
        [StressTest(TargetTPS = 1)]
        public class XeUpsUpdateProfile_profile : FuncToStressAdapter
        {
            public XeUpsUpdateProfile_profile()
                : base(new P_XeUpsUpdateProfile(P_XeUpsUpdateProfile.FuzzParameter.profile))
            { }
        }
        [StressTest(TargetTPS = 1)]
        public class XeUpsUpdateProfile_RandomFuzz : FuncToStressAdapter
        {
            public XeUpsUpdateProfile_RandomFuzz()
                : base(new P_XeUpsUpdateProfile(P_XeUpsUpdateProfile.FuzzParameter.RandomFuzz))
            { }
        }

        #endregion

        #endregion
      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\Feedback.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService;
using xonline.common.config;

// Using FCL libraries
using MS.Swi.Mitm;
using MS.Swi.Mitm.Services;
using ServerTestFramework.Utilities.FclFuzzer;

namespace LMATests
{
    /// <summary>
    /// Summary description for XeFeedback.
    /// </summary>
    abstract public class XeFeedbackTest : TestBase
    {
        static long idx = 0;
        public XeFeedbackTest()
        {

        }

        public XeFeedbackTest(string name)
            : base(name)
        {

        }

        public static ulong getRealUserPuid()
        {

            FriendsCommon fc = new FriendsCommon();

            PNUser user = fc.CreateUser(true);

            return user.UserId;
        }

        public static PNUser getPNUser()
        {

            FriendsCommon fc = new FriendsCommon();

            PNUser user = fc.CreateUser(true);

            return user;
        }

        public static ulong getContext()
        {
            return (ulong)(0xFF000 + Interlocked.Increment(ref idx));
        }

        public static void SendComplaintAndVerify(ulong senderPUID, ulong targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr)
        {
            SendComplaintAndVerify(senderPUID, targetPUID, titleID, type, context, ExpectedXErr, Modify.None);

        }

        public static void SendComplaintAndVerify(ulong senderPUID, ulong targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr, Modify flags)
        {

            SubmitComplaintRequest req = new SubmitComplaintRequest(senderPUID, targetPUID, titleID, type, context);
            //make sure that complaint is added in db.

            req.Modifyflag = flags;

            // Set the LMA bits
            req.ManualPopulateSlot();
            req.Slot.authDataFlags |= 0x20;
            req.Slot.machinePuid = 0xFB00000000000001;
            req.Slot.userPuid0 = 12345678;

            Response resp = req.Execute();

            if (HResult.Succeeded(resp.Xerr))
            {
                if (HResult.Failed(ExpectedXErr))
                    throw new Exception("Unexpected Xerror " + resp.Xerr);

                FeedbackWS.verifyComplaint((long)senderPUID, (long)targetPUID, (int)titleID, (int)type, (long)context);

            }
            else
            {
                if (resp.Xerr != ExpectedXErr)
                    throw new Exception("Unexpected Error returned by server XERROR= " + resp.Xerr);


            }

        }

        public static void SendReviewAndVerify(PNUser senderPUID, PNUser targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr, Modify flags)
        {
            SendReviewAndVerify(senderPUID, targetPUID, titleID, type, context, ExpectedXErr, flags, true);

        }

        public static void SendReviewAndVerify(PNUser senderPUID, PNUser targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr)
        {
            SendReviewAndVerify(senderPUID, targetPUID, titleID, type, context, ExpectedXErr, Modify.None, true);

        }

        public static void SendReviewAndVerify(PNUser senderPUID, PNUser targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr, Modify flags, bool VerifyRating)
        {
            int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
            double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
            SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);

            // Set the LMA bits
            req.ManualPopulateSlot();
            req.Slot.authDataFlags |= 0x20;
            req.Slot.machinePuid = 0xFB00000000000001;
            req.Slot.userPuid0 = 12345678;

            req.Modifyflag = flags;

            Response resp = req.Execute();

            if (HResult.Succeeded(resp.Xerr))
            {
                Thread.Sleep(500);
                if (HResult.Failed(ExpectedXErr))
                    throw new Exception("Unexpected Xerror " + resp.Xerr);
                // make sure the entry is add in db .
                object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

                if (Reviewval == null || ((int)Reviewval) <= 0)
                    throw new Exception("User Review entry not found in DB");

                int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                if (AggCount != (initialAggCount + 1))
                    throw new Exception("Agg Count not incremented ");

                // make sure user is added in affiliates list.
                int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
                if (type == (int)PlayerReview.Prefer)
                {
                    if (AffiliatFlag != 4)
                        throw new Exception("Affiliate with Positive Feedback not added for user " + senderPUID.UserId);
                }
                else
                {
                    if (AffiliatFlag != 8)
                        throw new Exception("Affiliate with Negative Feedback not added for user " + senderPUID.UserId);

                    int TargetAffiliatFlag = FeedbackWS.GetAffiliacteFlags(targetPUID, (long)senderPUID.UserId, (int)titleID);
                    if (TargetAffiliatFlag != 16)
                        throw new Exception("Avoided Affiliate not added for user " + targetPUID.UserId);

                }
                // verify that Feedback rating is added or changed for the user.

                if (VerifyRating && type < (int)PlayerReview.AvoidUnskilled)
                {
                    if (initialRating > 1)
                    {
                        double currentRating = FeedbackWS.GetRating(targetPUID.UserId);
                        if (initialRating == currentRating)
                            throw new Exception("Gamer Rating did not got updated");
                    }
                }

            }
            else
            {
                if (resp.Xerr != ExpectedXErr)
                    throw new Exception("Unexpected Error returned by server XERROR= " + resp.Xerr);

                //make sure that nothing is added in db.
                object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);
                if (Reviewval != null && ((int)Reviewval) != 0)
                    throw new Exception("User Review entry not found in DB");

                int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                if (AggCount != (initialAggCount))
                    throw new Exception("Agg Count not incremented ");

            }

        }


    }

    public class FeedbackTests : TestNode
    {
        [TestCase]
        public class P_Feedback_Complaints : XeFeedbackTest
        {
            [Flags]
            public enum FuzzParameter
            {
                None = 0x0,
                senderPUID = 0x1,
                targetPUID = 0x2,
                titleID = 0x4,
                type = 0x8,
                context = 0x10
            }
            private FuzzParameter _fuzzParameters;

            public P_Feedback_Complaints()
            {
                _fuzzParameters = FuzzParameter.None;
            }

            public P_Feedback_Complaints(FuzzParameter parameters)
            {
                _fuzzParameters = parameters;
            }

            protected override void  Execute()
            {
                // Initial values
                ulong senderPUID = getRealUserPuid();
                ulong targetPUID = getRealUserPuid();
                uint titleID = 50;
                uint type = (uint)ComplaintType.OffensiveMotto;
                ulong context = getContext();

                // Fuzz parameters
                if ((_fuzzParameters & FuzzParameter.senderPUID) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "senderPUID", ref senderPUID);
                }

                if ((_fuzzParameters & FuzzParameter.targetPUID) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "targetPUID", ref targetPUID);
                }

                if ((_fuzzParameters & FuzzParameter.titleID) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "titleID", ref titleID);
                }

                if ((_fuzzParameters & FuzzParameter.type) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "type", ref type);
                }

                if ((_fuzzParameters & FuzzParameter.context) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "context", ref context);
                }

                SendComplaintAndVerify(senderPUID, targetPUID, titleID, type, context, HResult.S_OK);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class P_Feedback_Review : XeFeedbackTest
        {
            [Flags]
            public enum FuzzParameter
            {
                None = 0x0,
                senderPUID = 0x1,
                targetPUID = 0x2,
                titleID = 0x4,
                type = 0x8,
                context = 0x10
            }
            private FuzzParameter _fuzzParameters;

            public P_Feedback_Review()
            {
                _fuzzParameters = FuzzParameter.None;
            }

            public P_Feedback_Review(FuzzParameter parameters)
            {
                _fuzzParameters = parameters;
            }

            protected override void Execute()
            {
                // Initial values
                PNUser senderPUID = getPNUser();
                PNUser targetPUID = getPNUser();
                uint titleID = 50;
                uint type = (uint)PlayerReview.Prefer;
                ulong context = getContext();

                // Fuzz parameters
                if ((_fuzzParameters & FuzzParameter.senderPUID) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "senderPUID", ref senderPUID.UserId);
                }

                if ((_fuzzParameters & FuzzParameter.targetPUID) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "targetPUID", ref targetPUID.UserId);
                }

                if ((_fuzzParameters & FuzzParameter.titleID) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "titleID", ref titleID);
                }

                if ((_fuzzParameters & FuzzParameter.type) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "type", ref type);
                }

                if ((_fuzzParameters & FuzzParameter.context) != FuzzParameter.None)
                {
                    FclFuzzer.Fuzz("", "context", ref context);
                }

                SendReviewAndVerify(senderPUID, targetPUID, titleID, type, context, HResult.S_OK);
                ResultCode = TEST_RESULTS.PASSED;
            }

        }

        [StressTest(TargetTPS=1)]
        public class Feedback_Complaints_All : FuncToStressAdapter
        {
            public Feedback_Complaints_All()
                : base(
                    new P_Feedback_Complaints(
                        P_Feedback_Complaints.FuzzParameter.senderPUID   |
                        P_Feedback_Complaints.FuzzParameter.targetPUID   |
                        P_Feedback_Complaints.FuzzParameter.titleID      |
                        P_Feedback_Complaints.FuzzParameter.type         |
                        P_Feedback_Complaints.FuzzParameter.context
                    )
                )
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Complaints_SenderPUID : FuncToStressAdapter
        {
            public Feedback_Complaints_SenderPUID()
                : base(new P_Feedback_Complaints(P_Feedback_Complaints.FuzzParameter.senderPUID))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Complaints_TargetPUID : FuncToStressAdapter
        {
            public Feedback_Complaints_TargetPUID()
                : base(new P_Feedback_Complaints(P_Feedback_Complaints.FuzzParameter.targetPUID))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Complaints_TitleID : FuncToStressAdapter
        {
            public Feedback_Complaints_TitleID()
                : base(new P_Feedback_Complaints(P_Feedback_Complaints.FuzzParameter.titleID))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Complaints_Type : FuncToStressAdapter
        {
            public Feedback_Complaints_Type()
                : base(new P_Feedback_Complaints(P_Feedback_Complaints.FuzzParameter.type))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Complaints_Context : FuncToStressAdapter
        {
            public Feedback_Complaints_Context()
                : base(new P_Feedback_Complaints(P_Feedback_Complaints.FuzzParameter.context))
            {
            }
        }


        [StressTest(TargetTPS = 1)]
        public class Feedback_Review_All : FuncToStressAdapter
        {
            public Feedback_Review_All()
                : base(
                    new P_Feedback_Review(
                        P_Feedback_Review.FuzzParameter.senderPUID |
                        P_Feedback_Review.FuzzParameter.targetPUID |
                        P_Feedback_Review.FuzzParameter.titleID |
                        P_Feedback_Review.FuzzParameter.type |
                        P_Feedback_Review.FuzzParameter.context
                    )
                )
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Review_SenderPUID : FuncToStressAdapter
        {
            public Feedback_Review_SenderPUID()
                : base(new P_Feedback_Review(P_Feedback_Review.FuzzParameter.senderPUID))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Review_TargetPUID : FuncToStressAdapter
        {
            public Feedback_Review_TargetPUID()
                : base(new P_Feedback_Review(P_Feedback_Review.FuzzParameter.targetPUID))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Review_TitleID : FuncToStressAdapter
        {
            public Feedback_Review_TitleID()
                : base(new P_Feedback_Review(P_Feedback_Review.FuzzParameter.titleID))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Review_Type : FuncToStressAdapter
        {
            public Feedback_Review_Type()
                : base(new P_Feedback_Review(P_Feedback_Review.FuzzParameter.type))
            {
            }
        }

        [StressTest(TargetTPS = 1)]
        public class Feedback_Review_Context : FuncToStressAdapter
        {
            public Feedback_Review_Context()
                : base(new P_Feedback_Review(P_Feedback_Review.FuzzParameter.context))
            {
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\EnumLoader.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;
using ServerTestFramework.LiveService.Stats.StatsDBSim;

public class EnumLoader
{
    static bool AlreadyPopulated = false;

    public static void PopulateLBForEnum()
    {
        //populate 10 leaderboards with 100 users each.

        //attribute 1 to 21 type int.
        //21 to 41 type long 
        // greater then 41 type double.

        if (!AlreadyPopulated)
        {
            LeaderboardInfo[] lbinfos = new LeaderboardInfo[17];
            for (int i = 0; i < lbinfos.Length; i++)
            {
                lbinfos[i] = new LeaderboardInfo((uint)(i + 1), "", 0, 0, 0);
            }

            StatsPoster tmp = new StatsPoster(816, lbinfos);
            tmp.createLB();

            tmp.AddUsers(1000, 0, 20, SpecialAttribMask.Rating);
            tmp.AddUsers(100, 1, 1, SpecialAttribMask.Rating); //64 attributes populated .
            tmp.AddUsers(100, 1, 64, SpecialAttribMask.Null);
            tmp.AddUsers(1, 2, 20, SpecialAttribMask.Rating); // lbid=2  lbsize=1
            tmp.AddUsers(99, 4, 20, SpecialAttribMask.Rating, 5000, 10); // lbid=5  lbsize=99
            tmp.AddUsers(2, 5, 20, SpecialAttribMask.Rating, 5092, 1);
            tmp.AddUsers(4, 5, 20, SpecialAttribMask.Null); // lbid=6  lbsize=4

            for (int j = 6; j < lbinfos.Length - 1; j++)
            {
                tmp.AddUsers(100, j, 60, SpecialAttribMask.Rating);
            }

            AlreadyPopulated = true;
        }
    }

    public static void PupulateLDForEstimateR(uint title)
    {
        StatsPoster tmp = new StatsPoster(title, new LeaderboardInfo[] { new LeaderboardInfo(1, "", 0, 0, 0), new LeaderboardInfo(2, "", 0, 0, 0), new LeaderboardInfo(3, "", 0, 0, 0) });
        tmp.createLB();

        tmp.AddUsers(100, 0, 60, SpecialAttribMask.Rating, 5, 5); //64 attributes populated .
        tmp.AddUsers(100, 1, 10, SpecialAttribMask.Rating, 1, 7);
    }


    public static void PupulateLDForRead(uint title)
    {
        //populate 10 leaderboards with 100 users each.

        //attribute 1 to 21 type int.
        //21 to 41 type long 
        // greater then 41 type double.

        StatsPoster tmp = new StatsPoster(
            title,
            new LeaderboardInfo[]{
                new LeaderboardInfo( 1  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 2  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 3  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 4  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 5  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 6  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 7  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 8  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 9  , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 10 , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 11 , "" , 0 , 0 , 0 ),
                new LeaderboardInfo( 12 , "" , 0 , 0 , 0 )
           }
        );

        tmp.createLB();

        for (int i = 0; i < 10; i++)
        {
            Global.RO.Info("Loading leaderboard " + (i + 1) + " with 102 users");
            // 15 attributes populated .
            tmp.AddUsers(120, i, 1, SpecialAttribMask.Rating); //64 attributes populated .
            tmp.AddUsers(120, i, 64, SpecialAttribMask.Null);

        }

        tmp.AddUsers(120, 10, 15, SpecialAttribMask.Rating);
        tmp.AddUsers(20, 11, 15, SpecialAttribMask.Rating);
    }

    public class StatsPoster
    {
        protected uint TitleID;
        protected LeaderboardInfo[] LBids = null;
        protected int Userbase = 5000;

        public object[] GetAttributes(uint Attcount, int spattmask, long Urating)
        {
            object[] tmp = new object[Attcount * 2];
            ushort addattr = 1;

            for (uint index = 0; index < (Attcount * 2); index += 2)
            {
                if ((spattmask & SpecialAttribMask.Rating) == SpecialAttribMask.Rating)
                {
                    tmp[index] = SpecialAttrib.Rating;
                    tmp[index + 1] = Urating;
                    spattmask = 0;

                }
                else
                {
                    if (addattr >= 1 && addattr < 21)
                    {
                        tmp[index] = (short)addattr;
                        tmp[index + 1] = (int)DataGen.GetRandomVal();
                        addattr++;
                    }
                    else if (addattr >= 21 && addattr < 41)
                    {
                        tmp[index] = (short)addattr;
                        tmp[index + 1] = (long)DataGen.GetRandomVal();
                        addattr++;
                    }
                    else if (addattr >= 41)
                    {
                        tmp[index] = (short)addattr;
                        tmp[index + 1] = (double)DataGen.GetRandomVal();
                        addattr++;
                    }
                }
            }

            return tmp;
        }

        //SpecialAttribMask.Rating

        public void AddUsers(int count, int lbindex, uint Attcount, int spattmask)
        {
            AddUsers(count, lbindex, Attcount, spattmask, Userbase, 1);
        }

        public void AddUsers(int count, int lbindex, uint Attcount, int spattmask, long RatingStart, int ratdiff)
        {
            //VerifyFlags.Player
            AddUsers(count, lbindex, Attcount, spattmask, RatingStart, ratdiff, VerifyFlags.Player);
        }

        public void AddUsers(int count, int lbindex, uint Attcount, int spattmask, long RatingStart, int ratdiff, int verifyFlag)
        {
            int NoofReq = count < 100 ? 1 : count / 100;
            StatsPostReq[] temp = new StatsPostReq[NoofReq];

            for (int cnt = 0; cnt < NoofReq; cnt++)
            {
                RequestBuilder _Req = null;
                _Req = new RequestBuilder();

                int NoOfUsers = 0;
                if (count > 100)
                {
                    NoOfUsers = 100;
                    count = count - 100;
                }
                else
                {
                    NoOfUsers = count;
                }

                ulong[] users = new ulong[NoOfUsers];
                for (int i = 0; i < NoOfUsers; i++)
                {
                    users[i] = (ulong)(Userbase + (long)(i + (NoOfUsers * cnt)));
                    object[] attributes = GetAttributes(Attcount, spattmask, (RatingStart + (long)(i * ratdiff + (NoOfUsers * cnt * ratdiff))));
                    StatsPlayerReplace _data = new StatsPlayerReplace((int)LBids[lbindex]._uiLbId, (ulong)users[i], 0, attributes);
                    _Req.AddProcs(_data.Proc);

                }

                _Req.Builder(TitleID, users, true, false);

                temp[cnt] = _Req.GetPostData();
            }

            g_Statobj.TManager.ExecuteAndVerify(temp, verifyFlag);
        }

        public StatsPoster(uint title, LeaderboardInfo[] lbids)
        {
            TitleID = title;
            LBids = lbids;
        }

        public void createLB()
        {
            // change this code to work with new LB server
            if (LBids != null)
            {
                DBHelper db = new DBHelper(g_Statobj.TManager.Im_Stats, true);
                db.ConfigureTitle((int)TitleID, LBids);
            }
        }
    } // StatsPoster
} // EnumLoader
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\BillingAccounts.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;


namespace LMATests
{   
    public class BillingAccount
    {
        public XeUser user;
        public bool isIdle = true;
        public string owner = "";
        public AuthContext ctx;
    }

    /// <summary>
    /// This is a Singleton class to create and then re-use billing accounts for the fuzzing tests
    /// of the LMA test suite.
    /// </summary>
    class BillingAccounts
    {
        private static BillingAccounts m_instance;          //singleton instance passed back to clients
        private static object m_syncRoot = new object();    //object used to lock cricical sections

        private BillingAccount[] m_GoldAccounts;
        private BillingAccount[] m_SilverAccounts;

        private BillingAccounts() 
        {
            //create 1 gold account
            m_GoldAccounts = new BillingAccount[1];
            for (int i = 0; i < m_GoldAccounts.Length; i++)
            {
                m_GoldAccounts[i] = new BillingAccount();
                m_GoldAccounts[i].user = new XeUser(true);//XbosUser.XenonGoldUser();
                m_GoldAccounts[i].user.CreateAsGold = true;
                //m_GoldAccounts[i].user.MachinePuid = 0xfb00000000000001;
                m_GoldAccounts[i].user.m_request.Slot.authDataFlags |= 0x20;      //  Mark XeUser as LMA account
                if (m_GoldAccounts[i].user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + m_GoldAccounts[i].user.GetDumpString());

                m_GoldAccounts[i].isIdle = true;
            }
            //create 1 silver account
            m_SilverAccounts = new BillingAccount[1];
            for (int i = 0; i < m_GoldAccounts.Length; i++)
            {
                m_SilverAccounts[i] = new BillingAccount();
                m_SilverAccounts[i].user = new XeUser(true);//XbosUser.XenonSilverUser();
                m_SilverAccounts[i].user.CreateAsGold = false;
                //m_GoldAccounts[i].user.MachinePuid = 0xfb00000000000001;
                m_SilverAccounts[i].user.m_request.Slot.authDataFlags |= 0x20;      //  Mark XeUser as LMA account
                if (m_SilverAccounts[i].user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + m_SilverAccounts[i].user.GetDumpString());

                m_SilverAccounts[i].isIdle = true;
            }
        }

        /// <summary>
        /// Returns the singleton instance of BillingAccounts
        /// </summary>
        public static BillingAccounts Instance
        {
            get
            {
                if (m_instance == null)
                {
                    lock (m_syncRoot)   //enter critical section
                    {
                        if (m_instance == null)     //double check that it is still NULL before creating again
                        {
                            m_instance = new BillingAccounts();
                        }
                    }
                }
                return m_instance;
            }
        }

        public XeUser GetSilverAccount(string TestName)
        {
            XeUser user = null;

            //  Search for an available account
            int index;
            for (index = 0; index < m_SilverAccounts.Length; index++)
            {
                if ( m_SilverAccounts[index].isIdle )
                    break;  //we found an account so break out
            }
            if (index < m_SilverAccounts.Length) //  Make sure that we found an account in the array
            {
                lock (m_syncRoot) //lock the array to check out account
                {
                    //  check that the account is still available
                    if (!m_SilverAccounts[index].isIdle)
                    {
                        //someone took the account search for another one
                        for (index = 0; index < m_SilverAccounts.Length; index++)
                        {
                            if (m_SilverAccounts[index].isIdle)
                                break;  //we found an account so break out
                        }
                    }
                    if (index < m_SilverAccounts.Length)
                    {
                        //  We were able to find an account so let's pass it back
                        m_SilverAccounts[index].isIdle = false;
                        m_SilverAccounts[index].owner = TestName;
                        user = m_SilverAccounts[index].user;
                    }
                }
            }
            return user;
        }

        public XeUser GetGoldAccount(string TestName)
        {
            XeUser user = null;

            //  Search for an available account
            int index;
            for (index = 0; index < m_GoldAccounts.Length; index++)
            {
                if (m_GoldAccounts[index].isIdle)
                    break;  //we found an account so break out
            }
            if (index < m_GoldAccounts.Length) //  Make sure that we found an account in the array
            {
                lock (m_syncRoot) //lock the array to check out account
                {
                    //  check that the account is still available
                    if (!m_GoldAccounts[index].isIdle)
                    {
                        //someone took the account search for another one
                        for (index = 0; index < m_GoldAccounts.Length; index++)
                        {
                            if (m_GoldAccounts[index].isIdle)
                                break;  //we found an account so break out
                        }
                    }
                    if (index < m_GoldAccounts.Length)
                    {
                        //  We were able to find an account so let's pass it back
                        m_GoldAccounts[index].isIdle = false;
                        m_GoldAccounts[index].owner = TestName;
                        user = m_GoldAccounts[index].user;

                    }
                }
            }
            return user;
        }

        public void ReturnAccount(ulong UserPuid)
        {
            //  Search for the Puid and then mark it as idle
            int index;
            for (index = 0; index < m_SilverAccounts.Length; index++)
            {
                if (m_SilverAccounts[index].user.UserPuid == UserPuid)
                {
                    m_SilverAccounts[index].isIdle = true;
                    m_SilverAccounts[index].owner = "";
                    return;
                }
            }

            for (index = 0; index < m_GoldAccounts.Length; index++)
            {
                if (m_GoldAccounts[index].user.UserPuid == UserPuid)
                {
                    m_GoldAccounts[index].isIdle = true;
                    m_GoldAccounts[index].owner = "";
                    return;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\FuncCron.cs ===
using System;

using System.Collections;
using System.Text;
using System.Timers;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Comps;
using ServerTestFramework.LiveService.Cron;
using ServerTestFramework.Database;
using xonline.common.config;

namespace LMATests
{
    /// <summary>
    /// Functional tests for the cron service.
    /// </summary>
    [TestGroup, Owner("External"), TestFrequency("DoNotRun"), Description("Limited Machine Account Security Testing for GFWL Arcade  cagood")]
    public class FuncCron : TestNode
    {
        [TestCase]
        class AddJob: CronTestBase
        {
            protected override void Execute()
            {
                // Create and submit a job that will fail
                int nonce = rand.Next();

                args["seconds"] = 10;
                args["nonce"] = nonce;
                
                XrlAddJobRequest request = new XrlAddJobRequest();
                request.argsXml = BuildArgsXml();
                request.assembly = "CronTest.dll";
                request.className = "XBOX.Online.Plugins.CronTimingTest";
                request.name = "Failing job";
                request.titleId = CompsGlobal.SmokeTitleId;
               
                request.ManualPopulateSlot();
                request.Slot.authDataFlags |= 0x20;             //  LMA flag
                request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                try
                {
                    request.ExecuteSafe();
                }
                catch (Exception)
                {
                    if (request.httpStatus != System.Net.HttpStatusCode.NotFound)
                        throw new UnexpectedTestResultException("Expected error 404 for LMA blocked API but recieved this error instead:\n" + request.GetDumpString());
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                    return;
 
                }
                
                ResultCode = TEST_RESULTS.FAILED;            
            }
        }

        [TestCase]
        class TimeWarp : CronTestBase
        {
            protected override void Execute()
            {
                XrlTimeWarp request = new XrlTimeWarp();
                request.ManualPopulateSlot();
                request.Slot.authDataFlags |= 0x20;             //  LMA flag
                request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                try
                {
                    request.ExecuteSafe();
                }
                catch (Exception)
                {
                    if (request.httpStatus != System.Net.HttpStatusCode.NotFound)
                        throw new UnexpectedTestResultException("Expected error 404 for LMA blocked API but recieved this error instead:\n" + request.GetDumpString());
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                    return;

                }
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
        [TestCase]
        class RemoveJob : CronTestBase
        {
            protected override void Execute()
            {

                XrlRemoveJobRequest request = new XrlRemoveJobRequest();
                request.ManualPopulateSlot();
                request.Slot.authDataFlags |= 0x20;             //  LMA flag
                request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                try
                {
                    request.ExecuteSafe();
                }
                catch (Exception)
                {
                    if (request.httpStatus != System.Net.HttpStatusCode.NotFound)
                        throw new UnexpectedTestResultException("Expected error 404 for LMA blocked API but recieved this error instead:\n" + request.GetDumpString());
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                    return;

                }
                ResultCode = TEST_RESULTS.FAILED;
            }

        }

        [TestCase]
        class GetJob: CronTestBase
        {
            protected override void Execute()
            {

                XrlGetJobRequest request = new XrlGetJobRequest();
                request.ManualPopulateSlot();
                request.Slot.authDataFlags |= 0x20;             //  LMA flag
                request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                try
                {
                    request.ExecuteSafe();
                }
                catch (Exception)
                {
                    if (request.httpStatus != System.Net.HttpStatusCode.NotFound)
                        throw new UnexpectedTestResultException("Expected error 404 for LMA blocked API but recieved this error instead:\n" + request.GetDumpString());
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                    return;

                }

                ResultCode = TEST_RESULTS.FAILED;
            }

            private uint GetBEnabled(ulong jobId)
            {
                Npdb npdb = new Npdb();
                npdb.ConnectToServer();
                return npdb.GetCronJobBEnabled(jobId);
            }
        }
        [TestCase]
        class FindJobs: CronTestBase
        {
            protected override void Execute()
            {

                XrlFindJobsRequest request = new XrlFindJobsRequest();
                request.ManualPopulateSlot();
                request.Slot.authDataFlags |= 0x20;             //  LMA flag
                request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                try
                {
                    request.ExecuteSafe();
                }
                catch (Exception)
                {
                    if (request.httpStatus != System.Net.HttpStatusCode.NotFound)
                        throw new UnexpectedTestResultException("Expected error 404 for LMA blocked API but recieved this error instead:\n" + request.GetDumpString());
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                    return;

                }

                ResultCode = TEST_RESULTS.FAILED;
            }

        }
    
        [TestCase]
        class Ping : CronTestBase
        {
            protected override void Execute()
            {

                XrlPing request = new XrlPing();
                request.ManualPopulateSlot();
                request.Slot.authDataFlags |= 0x20;             //  LMA flag
                request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                try
                {
                    request.ExecuteSafe();
                }
                catch (Exception)
                {
                    if (request.httpStatus != System.Net.HttpStatusCode.NotFound)
                        throw new UnexpectedTestResultException("Expected error 404 for LMA blocked API but recieved this error instead:\n" + request.GetDumpString());
                    else
                        ResultCode = TEST_RESULTS.PASSED;
                    return;

                }

                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        #region base classes
        public class XrlPing : XRLPayload
        {
            public long offsetSeconds = 0;

            protected override string GetServiceName()
            {
                return "/cron/ping.ashx";
            }

            public override bool Execute()
            {
                return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int));
            }
        }
        abstract class CronTestBase : TestBase
        {
            protected Random rand;
            protected Hashtable args;

            public const uint PLUGINTEST_ATTR_ID                      = 0x00000000;
            public const uint PLUGINTEST_ATTR_NONCE                   = 0x00000001;
            public const uint PLUGINTEST_ATTR_START                   = 0x00000002;
            public const uint PLUGINTEST_ATTR_END                     = 0x00000003;
            public const uint PLUGINTEST_ACTION_TIMING_TEST           = 0x00000001;

            public CronTestBase()
            {
                rand = new Random();
                args = new Hashtable();
            }
    
            public string BuildArgsXml()
            {
                StringBuilder builder = new StringBuilder();
                builder.Append("<PluginContext>\n");

                foreach(string key in args.Keys) 
                {
                    object o = args[key];
                    builder.Append("\t<attribute name=\"");
                    builder.Append(key);
                    builder.Append("\" type=\"");
                    builder.Append(o.GetType().FullName);
                    builder.Append("\">");
                    builder.Append(o.ToString());
                    builder.Append("</attribute>\n");
                }
                builder.Append("</PluginContext>");

                string str = builder.ToString();

                //FuncCron.report.Debug("Built argsXML: " + str);    
                
                return str;
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\LMATests\Billing.cs ===
/* Written by: cagood
 * Limited Machine Account Verfication testing
 * 
 * LMA allowed API's covered in file:  
 * XeContentDetails
 * XeContentrefreshLicense
 * XeOfferingVerifyToken
 * XeOfferPurchase
 * XeOfferPurchaseGamertag
 * XeSubscriptionDetails
 * XeSubscriptionEnumerate
 * 
 * 
 * LMA disabled API's covered in file:
 * XeEnumerateGenres
 * XeEnumerateTitlesByFilter
 * XeGetPointsPurchaseStatus
 * XeGetTitleDetails
 * XeAcknowledgeLicenseDelivery
 * XeBannerGetList
 * XeContentAvailable
 * XeContentEnumerate2
 * XeContentHistoryEnumerate
 * XeContentReferral
 * XeContentUpdateAccessTimes
 * XeAcquireVideoContentURL
 * XeOfferPurchaseMusic
 * OfferingDetailsNoUser
 * OfferingEnumerate
 * XeWmdrmCreateCertificate
 * XeAcquireVideoLicense
 * XeOfferPurchaseVideo
 * OfferingPurchase
 * VerifyNickname
 * ContentReferral
 * OfferingCancel
 * OfferingDetails
 * TransferMachineLicense
 * AssetConsume
 * AssetEnumerate
 * XeMigrateXbox1User
 * 
 */

using System;
using System.Collections.Generic;
using System.Text;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.Billing.DRM;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using ServerTestFramework.LiveService.FakeSG;
using System.Globalization;
using ServerTestFramework.LiveService.Wmis;
using System.Threading;

using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.Wmis;

using XeXbos;

using ServerTestFramework.Utilities.FclFuzzer;

namespace LMATests
{
    [TestGroup, Owner("External"), TestFrequency("DoNotRun"), Description("Limited Machine Account Security Testing for GFWL Arcade  cagood")]
    public class LMABilling:TestNode
    {
        private const uint _hiddenDemoGenre = 701000000; // the demo titles hidden genre
        private const uint _defaultGenre = 187010100; // xbos test genre
        private const uint _defaultParentGenre = 187010000;
        private const uint _fightingGenre = 106000000;    // Fighting genre
        private const uint _defaultTitle = 0x6034A470;
        private const ulong _defaultOffer = 0x6034A47031B2D0DF;

        // have some users ready
        [TestGroupSetup]
        public void Setup()
        {
            XbosGenre.InitGenres();
            //BulkTitleOffers();
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        #region LMA Allowed functions (Functional and Fuzzing tests)
        //////////////////////////
        //  LMA Allowed functions

        #region XeContentDetails
        [TestCase]
        public class P_XeContentDetails : TestBase
        {
            #region Constructors and Enum for fuzzing

            //This value will be used to help the test know which parameter to fuzz
            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                userPuid,
                countryID,
                languageID,
                offers,
                offerIDs,
                offerID,
                paymentType,
                tierRequired,
                ratingSystem,
            }

            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeContentDetails() { }
            public P_XeContentDetails(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            #endregion

            public readonly uint _SchemaVersion = WireData.MakeSchemaVersion(2, 0);
            public readonly bool _UseHttpAuth = false;
            private const uint _defaultTitle = 0x2D5A7E21;

            public void CallAPI(XRLXeContentDetails request, ref XRLXeContentDetailsResponse response, ulong offerID, bool gold, bool grantLicense)
            {
                XeUser user;
                BillingAccounts Accounts = BillingAccounts.Instance;
                if (gold)
                {
                    //user = XbosUser.XenonGoldUser();
                    user = Accounts.GetGoldAccount("XeContentDetails");
                    if (user == null)
                        throw new UnexpectedTestResultException("Unable to secure re-usable account for test, please check or lower threads to number of accounts created in list");

                }
                else
                {
                    //user = XbosUser.XenonSilverUser();
                    user = Accounts.GetSilverAccount("XeContentDetails");
                    if (user == null)
                        throw new UnexpectedTestResultException("Unable to secure re-usable account for test, please check or lower threads to number of accounts created in list");

                }

                //  This try block was added to make sure we free the user account
                try
                {
                    //  This is the code that marks the request from a PC LMA account
                    request.ManualPopulateSlot();
                    request.Slot.authDataFlags |= 0x20;             //  LMA flag
                    request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                    request.Slot.userPuid0 = user.UserPuid;

                    //  Parameters for the API 
                    request.UserPuid = user.UserPuid;
                    request.OfferId = offerID;
                    
                    // schema version and use HttpAuth
                    request.SchemaVersion = _SchemaVersion;
                    request.UseHttpAuth = _UseHttpAuth;
                    if (_SchemaVersion >= WireData.MakeSchemaVersion(2, 0))
                    {
                        request.OfferIDs = new ulong[] { request.OfferId };
                    }

                    #region Parameter Fuzzing Switch Statements

                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userPuid:
                                //Console.WriteLine("***OriginalValue: " + request.UserPuid.ToString());
                                FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                //Console.WriteLine("***FuzzedValue: " + request.UserPuid.ToString());
                                break;

                            case FuzzParameter.countryID:
                                //Console.WriteLine("***OriginalValue: " + request.CountryId.ToString());
                                FclFuzzer.Fuzz("CountryId", ref request.CountryId);
                                //Console.WriteLine("***FuzzedValue: "+request.CountryId.ToString());
                                break;

                            case FuzzParameter.languageID:
                                //Console.WriteLine("***OriginalValue: " + request.LanguageId.ToString());
                                FclFuzzer.Fuzz("", "LanguageId", ref request.LanguageId);
                                //Console.WriteLine("***FuzzedValue: " + request.LanguageId.ToString());
                                break;

                            case FuzzParameter.offers:
                                //Console.WriteLine("***OriginalValue: " + request.Offers.ToString());
                                FclFuzzer.Fuzz("", "Offers", ref request.Offers);
                                //Console.WriteLine("***FuzzedValue: " + request.Offers.ToString());
                                break;

                            case FuzzParameter.offerIDs:
                                //Console.WriteLine("***OriginalValue: " + request.OfferIDs[0].ToString());
                                FclFuzzer.FuzzArray("", "OfferIDs", ref request.OfferIDs);
                                //Console.WriteLine("***OriginalValue: " + request.OfferIDs[0].ToString());
                                break;

                            case FuzzParameter.offerID:
                                //Console.WriteLine("***OriginalValue: " + request.OfferId.ToString());
                                FclFuzzer.Fuzz("", "OfferId", ref request.OfferId);
                                //Console.WriteLine("***FuzzedValue:   " + request.OfferId.ToString());
                                break;

                            case FuzzParameter.paymentType:
                                //Console.WriteLine("***OriginalValue: " + request.PaymentType.ToString());
                                FclFuzzer.Fuzz("", "PaymentType", ref request.PaymentType);
                                //Console.WriteLine("***FuzzedValue: " + request.PaymentType.ToString());
                                break;

                            case FuzzParameter.tierRequired:
                                //Console.WriteLine("***OriginalValue: " + request.TierRequired.ToString());
                                FclFuzzer.Fuzz("TierRequired", ref request.TierRequired);
                                //Console.WriteLine("***FuzzedValue: " + request.TierRequired.ToString());
                                break;

                            case FuzzParameter.ratingSystem:
                                //Console.WriteLine("***OriginalValue: " + request.RatingSystem.ToString());
                                FclFuzzer.Fuzz("RatingSystem", ref request.RatingSystem);
                                //Console.WriteLine("***FuzzedValue: " + request.RatingSystem.ToString());
                                break;

                            case FuzzParameter.RandomFuzz:
                                Random randomNum = new Random();
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "UserPuid", ref request.UserPuid);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("CountryId", ref request.CountryId);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "LanguageId", ref request.LanguageId);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "Offers", ref request.Offers);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.FuzzArray("", "OfferIDs", ref request.OfferIDs);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "OfferId", ref request.OfferId);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("", "PaymentType", ref request.PaymentType);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("TierRequired", ref request.TierRequired);
                                if (randomNum.Next(2) == 1)
                                    FclFuzzer.Fuzz("RatingSystem", ref request.RatingSystem);
                                break;
                            default:

                                break;
                        }
                    }
                    #endregion

                    if (!request.Execute(out response) && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException("XRLXeContentDetails failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK && !LMATests.m_EnableFuzzTesting)
                        throw new UnexpectedTestResultException(String.Format("XRLXeContentDetails returned XErr=0x{0:x}", request.XErr));
                    //XeXbos.Functional.XeContentDetails.PrintResponseObject(request, response);
                }
                finally
                {
                    Accounts.ReturnAccount(user.UserPuid);
                }
            }

            protected override void Execute()
            {
                // Create a title with a content item.
                uint titleID = _defaultTitle; //((XeXbos.Functional.XeContentDetails)this.Parent).GetNextTitleId(this);
                ulong offerID = ((ulong)titleID << 32) + (ulong)RandomEx.GlobalRandGen.Next(1, int.MaxValue);
                XbosOffer offer = XeXbos.Functional.XeContentDetails.CreateTitleOffers(titleID, offerID);

                XRLXeContentDetails request = new XRLXeContentDetails();
                XRLXeContentDetailsResponse response = new XRLXeContentDetailsResponse();

                //((XeXbos.Functional.XeContentDetails)Parent).CallAPI(request, ref response, offerID, false);
                CallAPI(request, ref response, offerID, true, false);

                if (!LMATests.m_EnableFuzzTesting)
                {
                    XeXbos.Functional.XeContentDetails.CompareResponse(request, response, offer);
                }

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #region XeContentDetails Fuzzing Tests
        //*******************************************
        //  Stress Fuzzing tests for all parameters
        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_userPuid : FuncToStressAdapter
        {
            public Billing_XeContentDetails_userPuid()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.userPuid))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_countryID : FuncToStressAdapter
        {
            public Billing_XeContentDetails_countryID()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.countryID))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_languageID : FuncToStressAdapter
        {
            public Billing_XeContentDetails_languageID()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.languageID))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_offers : FuncToStressAdapter
        {
            public Billing_XeContentDetails_offers()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.offers))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_offerIDs : FuncToStressAdapter
        {
            public Billing_XeContentDetails_offerIDs()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.offerIDs))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_offerID : FuncToStressAdapter
        {
            public Billing_XeContentDetails_offerID()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.offerID))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_paymentType : FuncToStressAdapter
        {
            public Billing_XeContentDetails_paymentType()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.paymentType))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_tierRequired : FuncToStressAdapter
        {
            public Billing_XeContentDetails_tierRequired()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.tierRequired))
            { }
        }

        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_ratingSystem : FuncToStressAdapter
        {
            public Billing_XeContentDetails_ratingSystem()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.ratingSystem))
            { }
        }
        [StressTest(TargetTPS = 1)]
        public class Billing_XeContentDetails_RandomFuzz : FuncToStressAdapter
        {
            public Billing_XeContentDetails_RandomFuzz()
                : base(new P_XeContentDetails(P_XeContentDetails.FuzzParameter.RandomFuzz))
            { }
        }
        //*********************************************
        #endregion

        #endregion

        #region XeContentRefreshLicense
        /* CURRENT TEST STATUS - Non functional
         * This test case is not working due to 2 problems
         * 1- GetConsoleIdFromMachineId() is failing because we are using made up MachineID's and could not get an answer of how
         * to work around this
         * 2- The current hard coded offer (and all offers except for PPV videos) are 1 use only licenses.  As we are re-using accounts
         * it just kicks out of the API to tell us that the user has used that license the maximum ammount of times.  The possible solution
         * is to create a new offer or license each time we run this test just like the XeContentDetails test works
        */
        [TestCase]
        class P_XeContentRefreshLicense : TestBase
        {

            #region Constructors and Enum values
            //*************************************************************
            //  This variable and constructor will allow us to tell the test
            //  which parameter we want it to fuzz
            public static FuzzParameter m_ParmToFuzz = FuzzParameter.None;

            public P_XeContentRefreshLicense() { }
            public P_XeContentRefreshLicense(FuzzParameter paramToFuzz)
            {
                m_ParmToFuzz = paramToFuzz;
            }

            //This value will be used to help the test know which parameter to fuzz
            public enum FuzzParameter
            {
                None = 0,
                RandomFuzz,
                userId,
                machineId,
                licenseLength,
                license,
            }
            //**************************************************************
            #endregion

            override protected void Execute()
            {
                //XeUser user = XbosUser.XenonSilverUser();
                BillingAccounts Accounts = BillingAccounts.Instance;
                XeUser user = Accounts.GetSilverAccount("XeContentRefreshLicense");
                if (user == null)
                    throw new UnexpectedTestResultException("Unable to secure re-usable account for test, please check or lower threads to number of accounts created in list");

                // I've added this try so that I can properly free up the account
                try
                {
                    user.AddPoints_500();
                    XbosOffer.OfferPurchase(XeXbos.Functional.XeXbosUtils.OFFER_ID, user);

                    ContentLicense license = new ContentLicense();
                    license.signature.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);   // make the live signature type
                    license.body.ContentId = new byte[] { 0x49, 0xA4, 0x30, 0x28, 0xF0, 0xD5, 0x6A, 0x4B, 0xC7, 0x55, 0xC1, 0x4B, 0x36, 0x3E, 0x42, 0xB8, 0xC8, 0x44, 0xFC, 0x11 }; // the correct content id

                    XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                    XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

                    //  This is the code that marks the request from a PC LMA account
                    request.ManualPopulateSlot();
                    request.Slot.authDataFlags |= 0x20;             //  LMA flag
                    request.Slot.machinePuid = 0xfb00000000000001;  //  PC Machine ID (starts with 0xfb)
                    request.Slot.userPuid0 = user.UserPuid;

                    //  Parameters for the API 
                    request.UserId = user.UserPuid;
                    request.MachineId = 0xfb00000000000001; //This was changed from user.MachinePuid becuase a security
                                                            //check on the SG was catching that the numbers didn't match
                    request.License = license.ToArray();

                    #region Parameter Fuzzing Switch Statements
                    if (LMATests.m_EnableFuzzTesting)
                    {
                        switch (m_ParmToFuzz)
                        {
                            case FuzzParameter.userId:
                                //Console.WriteLine("***OriginalValue: " + request.UserPuid.ToString());
                                FclFuzzer.Fuzz("", "UserId", ref request.UserId);
                                //Console.WriteLine("***FuzzedValue: " + request.UserPuid.ToString());
                                break;

                            case FuzzParameter.machineId:
                                //Console.WriteLine("***OriginalValue: " + request.CountryId.ToString());
                                FclFuzzer.Fuzz("", "MachineId", ref request.MachineId);
                                //this is so that we can get around the security check that the slot and request MachineId don't match
                                request.Slot.machinePuid = request.MachineId;
                                //Console.WriteLine("***FuzzedValue: "+request.CountryId.ToString());
                                break;

                            case FuzzParameter.licenseLength:
                                //Console.WriteLine("***OriginalValue: " + request.LanguageId.ToString());
                                FclFuzzer.Fuzz("", "LicenseLength", r