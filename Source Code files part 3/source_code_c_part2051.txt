udienceUriProvider>();
            Leet.Identity.PartnerAuth.AuthenticationManager.RegisterWithIocContainer(Container.Instance);

            // Register for Profile capabilities.
            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize(Global.ServiceName);
            ProfileProvider.RegisterWithIocContainer(Container.Instance, Global.ServiceName);

            Container.Instance.AddService<IBILog, BILog>(); // to log business intelligence data

            // Register Rewards implementation.
            CSubmitGameResult.RegisterInterfaces(Container.Instance);

            // Initialize perfcounters
            StorageClientPerfCounters.Counters =
                PerformanceCounters.GetPerformanceCounters(typeof(StorageClientPerfCounters), Global.ServiceName);

            Logging.TraceInformation(
                "{0}: {1}",
                Global.ServiceName,
                "Service Application Started.");
        }

        /// <summary>
        /// Application OnEnd event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_End(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application BeginRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_BeginRequest(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            // Proxies must treat the response as private & must not transform or cache the response.
            HttpContext.Current.Response.Headers["Cache-Control"] = "private, no-transform, no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\GameStateService.cs ===
﻿// <copyright file="GameStateService.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for GameStateService class.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using Common.AzureStorage;
    using GameStateAzureStorage;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Leet.Core.BI;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationSender;
    using NotificationService;
    using PassThruGameLogicModule;
    using SessionCommon;
    using SessionMaintenance;

    /// <summary>
    /// Game state service class which handles state related requests.
    /// </summary>
    public partial class GameStateService
    {
        /// <summary>
        /// Maxiumum length of the game data supported.
        /// </summary>
        private const int MaxGameDataLength = 1024 * 1024; // 1MB

        /// <summary>
        /// This field is used to store the reference to a IGameStateStorage implementation.
        /// </summary>
        private static IGameStateStorage stateStorage;

        /// <summary>
        /// This field is used to store the reference to a ISessionStorage implementation.
        /// </summary>
        private static ISessionStorage sessionStorage;

        /// <summary>
        /// This field is used to store the reference to a IGameLogicModule implementation.
        /// </summary>
        private static IGameLogicModule gameLogicModule;

        /// <summary>
        /// This field is used to store the reference to a INotificationRequest implementation.
        /// </summary>
        private static INotificationRequest notificationRequest;

        /// <summary>
        /// Initializes static members of the GameStateService class.
        /// </summary>
        static GameStateService()
        {
            StorageAccountInfo tableAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            StorageAccountInfo blobAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureBlobStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            // NOTE: HACK!!! Use a Factory pattern to assign an implementation and remove dependency
            // on GameStateAzureStorage/SessionAzureStorage/PassThruGameLogicModule.
            GameStateService.stateStorage = new GameStateAzureStorage(blobAccount, ServiceConfigs.ProxyAddress);

            GameStateService.sessionStorage =
                new SessionAzureStorage.SessionAzureStorage(tableAccount, ServiceConfigs.ProxyAddress);
       
            GameStateService.gameLogicModule = new PassThruGameLogicModule(stateStorage, sessionStorage);

            GameStateService.notificationRequest =
                new NotificationRequestUtils(ServiceConfigs.NotificationRequestQueueConnectionString);
        }

        /// <summary>
        /// Ends a particular passthrough game.
        /// </summary>
        /// <param name="sessionID">SessionID to end.</param>
        /// <param name="gameID">GameID to end.</param>
        /// <param name="gameResults">The win/loss/tie results of the game.</param>
        /// <param name="identity">The identity of the user submitting the game results.</param>
        /// <param name="platformType">Platform type, used currently only for BI logging</param>
        public void PostGameEndInternal(string sessionID, string gameID, GameResults gameResults, IdentityToken identity, string platformType)
        {
            // log business intelligence data, need to log before any validations
            try
            {
                ulong partnerXuid;
                UInt64.TryParse(identity.Token, out partnerXuid);
                uint uintGameID;
                UInt32.TryParse(gameID, out uintGameID);  
                BILogging.LogBIData(
                    OriginatorIDType.Partner,
                    partnerXuid,
                    platformType,
                    uintGameID,
                    Global.ServiceName,
                    "PostGameEnd");
            }
            catch (Exception ex)
            {
                // None of this should throw, but take no chance
                Logging.TraceWarning(
                    "{0}: {1} {2}",
                    "SessionManagementService",
                    "Unexpected exception caught while writing BI data",
                    ex.ToString());
            }

            if (!gameLogicModule.GetModuleInfo().IsPassThruModule)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.PostGameEndNotAllowedForNonPassthruGames,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    sessionID,
                    gameID);
            }

            uint gameIDAsUint = 0;
            try
            {
                gameIDAsUint = UInt32.Parse(gameID);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatWhilePostingGameResults,
                    HttpStatusCode.BadRequest,
                    ex,
                    false,
                    gameID);
            }

            OpaqueSessionStorageObject storageObject;
            SessionState sessionState = GameStateService.sessionStorage.QuerySession(sessionID, gameIDAsUint, out storageObject);
            GameStateService.ValidateSessionNotComplete(sessionState);

            SeatInfo actorSeat = GameStateService.GetPlayerSeat(sessionState, identity);
            if (actorSeat == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNotAllowedToSubmitResultsForSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    identity.ToString(),
                    sessionID,
                    gameID);
            }

            // Make sure that each submitted GameResult has the same GameID/Variant as the session.
            if (gameResults.Results != null)
            {
                ICollection<GameResult> resultCollection = gameResults.Results.Values;
                foreach (GameResult result in resultCollection)
                {
                    if (result.GameId != sessionState.GameID || result.Variant != sessionState.Variant)
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.BadGameIDOrVariantSubmittedInGameResult,
                            HttpStatusCode.BadRequest,
                            null,
                            false,
                            result.GameId.ToString(),
                            result.Variant.ToString(),
                            sessionState.GameID.ToString(),
                            sessionState.Variant.ToString());
                    }
                }
            }

            // Set the isCompleted flag.
            ModuleModifiableState moduleModifiableState = new ModuleModifiableState();
            moduleModifiableState.LastModified = DateTime.UtcNow;
            moduleModifiableState.IsComplete = true;
            sessionStorage.ModifySession(storageObject, moduleModifiableState, identity);

            // Send Win/Loss/Tie notifications.
            NotificationSender notificationSender = new NotificationSender(GameStateService.notificationRequest);
            if (gameResults.WinningSeatIndexes != null)
            {
                notificationSender.SendYouWinNotification(sessionState, gameResults.WinningSeatIndexes);
            }

            if (gameResults.LosingSeatIndexes != null)
            {
                notificationSender.SendYouLoseNotification(sessionState, gameResults.LosingSeatIndexes);
            }

            if (gameResults.TierSeatIndexes != null)
            {
                notificationSender.SendGameTieNotification(sessionState, gameResults.TierSeatIndexes);
            }

            if (gameResults.GameOverSeatIndexes != null)
            {
                notificationSender.SendGameOverNotification(sessionState, gameResults.GameOverSeatIndexes);
            }

            // Delete "Your Turn" notification for all the players in this session.
            foreach (SeatInfo seat in sessionState.Seats)
            {
                notificationSender.DeleteYourTurnNotification(sessionState, seat.Profile);
            }

            // Submit results to Rewards.
            if (gameResults.Results != null)
            {
                ISubmitGameResult submitGameResult = Container.Instance.GetComponent<ISubmitGameResult>();
                IList<CompositeGameResult> compositeGameResults = new List<CompositeGameResult>();

                // Submit rewards for each person in the session
                foreach (var seat in sessionState.Seats)
                {
                    if (gameResults.Results.ContainsKey(seat.Index))
                    {
                        CompositeGameResult newGameResult = new CompositeGameResult()
                                                                {
                                                                    GameResult = gameResults.Results[seat.Index],
                                                                    Locale = seat.Locale,
                                                                    PlatformType = ((uint)seat.PlatformType).ToString(),
                                                                    Xuid = ulong.Parse(seat.Profile.Token)
                                                                };
                        compositeGameResults.Add(newGameResult);
                    }
                }

                // If we have some results, submit to rewards
                if (compositeGameResults.Count != 0)
                {
                    try
                    {
                        Logging.TraceVerbose("{0}: Submitting CompositeGameResults to Rewards.", this.ComponentName);

                        submitGameResult.SubmitBatch(
                        compositeGameResults, GameResultSubmissionEnum.MultiplayerServiceSubmission);
                    }
                    catch (RewardsDataAccessValidationException ex)
                    {
                        throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.ErrorWhileTryingToValidateCompositeGameResults,
                        HttpStatusCode.BadRequest,
                        ex,
                        false,
                        sessionID,
                        gameID);
                    }
                    catch (RewardsDataAccessOperationException ex)
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.RewardsErrorWhileProcessingGameResults,
                            HttpStatusCode.InternalServerError,
                            ex,
                            true,
                            sessionID,
                            gameID);
                    }
                }
            }
        }

        /// <summary>
        /// Submit a game action.
        /// </summary>
        /// <param name="sessionID">SessionID for which to submit a game action.</param>
        /// <param name="gameID">GameID for which to submit a game action.</param>
        /// <param name="action">Game action to be submitted.</param>
        /// <param name="identity">The identity of the user submitting the game action.</param>
        public void PostGameActionInternal(string sessionID, string gameID, GameAction action, IdentityToken identity)
        {
            uint gameIDAsUint = 0;
            try
            {
                gameIDAsUint = UInt32.Parse(gameID);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatWhilePostingGameAction,
                    HttpStatusCode.BadRequest,
                    ex,
                    false,
                    gameID);
            }

            OpaqueSessionStorageObject storageObject;
            SessionState sessionState = GameStateService.sessionStorage.QuerySession(sessionID, gameIDAsUint, out storageObject);
            GameStateService.ValidateSessionNotComplete(sessionState);

            SeatInfo actorSeat, activeSeat;
            GameStateService.GetActiveSeatAndActorSeat(sessionState, identity, out activeSeat, out actorSeat);
                
            if (actorSeat == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNotAllowedToSubmitActionToSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    identity.ToString(),
                    sessionID,
                    gameID);
            }

            switch (action.ActionType)
            {
                case GameActionType.UserNudge:
                    if (activeSeat != null)
                    {
                        // Only send user nudge if the seat was not user nudged before.
                        if (!sessionState.WasActiveSeatUserNudged)
                        {
                            NotificationSender notificationSender =
                                new NotificationSender(GameStateService.notificationRequest);
                            notificationSender.SendUserNudgeNotification(sessionState, activeSeat.Index, identity);

                            // Set the WasActiveSeatUserNudged flag.
                            ModuleModifiableState moduleModifiableState = new ModuleModifiableState();
                            moduleModifiableState.WasActiveSeatUserNudged = true;
                            sessionStorage.ModifySession(storageObject, moduleModifiableState, identity);
                        }
                    }
                    else
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.CannotNudgeEmptyActiveSeat,
                            HttpStatusCode.Forbidden,
                            null,
                            false,
                            sessionID,
                            gameID);
                    }

                    break;

                default:
                    break;
            }

            gameLogicModule.OnSubmitGameAction(sessionState, action, actorSeat.Index, storageObject);
        }

        /// <summary>
        /// Get the full game state for a particular game session.
        /// </summary>
        /// <param name="sessionID">SessionID for which to get full game state.</param>
        /// <param name="gameID">GameID for which to get full game state.</param>
        /// <param name="identity">The identity of the user querying for full game state.</param>
        /// <returns>The full game state for the game session.</returns>
        public FullGameState GetGameStateInternal(string sessionID, string gameID, IdentityToken identity)
        {
            uint gameIDAsUint = 0;
            try
            {
                gameIDAsUint = UInt32.Parse(gameID);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormat,
                    HttpStatusCode.BadRequest,
                    ex,
                    false,
                    ex.ToString());
            }

            SeatInfo actorSeat;
            SessionState sessionState = SessionManagementService.QuerySessionAndDeleteNotifications(sessionID, gameIDAsUint, identity, out actorSeat);
            return gameLogicModule.OnGetGameState(sessionState, actorSeat.Index);
        }

        /// <summary>
        /// Set modifyable parts of the game state.
        /// </summary>
        /// <param name="sessionID">SessionID for which to set the game state.</param>
        /// <param name="gameID">GameID for which to set the game state.</param>
        /// <param name="state">Game state parts to be set.</param>
        /// <param name="identity">The identity of the user setting the state.</param>
        public void SetGameStateInternal(string sessionID, string gameID, ModifiableGameState state, IdentityToken identity)
        {
            if (!gameLogicModule.GetModuleInfo().IsPassThruModule)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.SetGameStateNotAllowedForNonPassthruGames,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    sessionID,
                    gameID);
            }

            if (state.GameData == null || state.GameData.Length > GameStateService.MaxGameDataLength)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.GameDataIsNullOrTooLong,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    GameStateService.MaxGameDataLength.ToString(),
                    sessionID ?? string.Empty,
                    gameID ?? string.Empty);
            }

            uint gameIDAsUint = 0;
            try
            {
                gameIDAsUint = UInt32.Parse(gameID);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatWhileSettingGameState,
                    HttpStatusCode.BadRequest,
                    ex,
                    false,
                    gameID);
            }

            OpaqueSessionStorageObject storageObject;
            SessionState sessionState = sessionStorage.QuerySession(sessionID, gameIDAsUint, out storageObject);
            GameStateService.ValidateSessionNotComplete(sessionState);

            // Make sure that the active seat index is valid.
            int totalSeats = sessionState.Seats.Length + sessionState.SeatsAvailable;
            if (state.ActiveSeatIndex < 0 || state.ActiveSeatIndex >= totalSeats)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidActiveSeatIndex,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    state.ActiveSeatIndex.ToString(),
                    totalSeats.ToString());
            }

            // It is OK to have this code here rather than passthru game logic module, because PutGameState is only allowed for passthru games.
            SeatInfo activeSeat = null;
            SeatInfo newActiveSeat = null;
            SeatInfo ownerSeat = null;
            bool actorFound = false;
            foreach (var seat in sessionState.Seats)
            {
                // Is this the actor's seat?
                if (seat.Profile.Equals(identity))
                {
                    actorFound = true;
                }

                // Is this seat the active user's seat?
                if (seat.Index == sessionState.State.ActiveSeatIndex)
                {
                    activeSeat = seat;
                }

                // Is this seat the new active user's seat?
                if (seat.Index == state.ActiveSeatIndex)
                {
                    newActiveSeat = seat;
                }

                // Is this seat the session owner's seat?
                if (seat.Index == sessionState.OwnerSeatIndex)
                {
                    ownerSeat = seat;
                }

                // We have found both all the interesting data, so break.
                if (activeSeat != null && newActiveSeat != null && ownerSeat != null && actorFound)
                {
                    break;
                }
            }

            // It is OK to have this code here rather than passthru game logic module, because PutGameState is only allowed for passthru games.
            // We have the following cases here:
            // 0. The actor is not in the session, throw a forbidden exception.
            // 1. We have an invalid owner, assign the next owner.
            // 2. We have a valid owner and a valid active seat and someone other than the active user is making the game state change, throw an error.
            // 3. We have an invalid active user, and some one other than the owner is modifying the game state, throw an error.
            // 4. None of the above are true, everything is OK.
            if (!actorFound)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNotAllowedToSetStateInThisSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    identity.ToString(),
                    sessionID,
                    gameID.ToString());
            }

            if (ownerSeat == null)
            {
                ownerSeat = PassThruGameLogicModule.AssignOwner(sessionState, GameStateService.sessionStorage);
                sessionState = sessionStorage.QuerySession(sessionID, gameIDAsUint, out storageObject); // We need to do this to refresh the storage object.

                if (ownerSeat == null)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.NoOwnerFoundForTheSession,
                        HttpStatusCode.InternalServerError,
                        null,
                        false,
                        sessionID,
                        gameID);
                }
            }

            if (activeSeat != null && !activeSeat.Profile.Equals(identity))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNotAllowedToModifyGameStateForTheSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionID,
                    gameID);
            }
            else if (activeSeat == null && !ownerSeat.Profile.Equals(identity))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.OnlySessionOwnerCanModifyGameState,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionID,
                    gameID);
            }

            // Save the game data first, so that this operation can be retried.
            using (MemoryStream saveStream = new MemoryStream(state.GameData))
            {
                stateStorage.ProvisionStorage(sessionID, gameIDAsUint);
                stateStorage.Save(sessionID, gameIDAsUint, PassThruGameLogicModule.DefaultFileName, saveStream);
            }

            ModuleModifiableState moduleModifiableState = new ModuleModifiableState();
            moduleModifiableState.ActiveSeatIndex = state.ActiveSeatIndex;
            moduleModifiableState.SequenceNumber = sessionState.State.SequenceNumber + 1;
            moduleModifiableState.LastModified = DateTime.UtcNow;

            // Reset the nudges and warnings.
            moduleModifiableState.IsInactivityWarningSent = false;
            moduleModifiableState.NumberOfNudgesSent = 0;
            moduleModifiableState.WasActiveSeatUserNudged = false;

            sessionState = sessionStorage.ModifySession(storageObject, moduleModifiableState, identity);

            // Send Notifications.
            NotificationSender notificationSender = new NotificationSender(GameStateService.notificationRequest);

            // If the seat being made active is occupied, send a "Your Turn" notification.
            if (newActiveSeat != null)
            {
                notificationSender.SendYourTurnNotification(sessionState, identity);
            }

            if (sessionState.State.IsComplete == true)
            {
                notificationSender.SendGameOverNotification(sessionState);
            }

            // Delete YourTurn/Nudge/Warning notifications
            notificationSender.DeleteNudgeNotification(sessionState, identity);
            notificationSender.DeleteYourTurnNotification(sessionState, identity);
        }

        /// <summary>
        /// Checks if the session is complete, if it is complete, throws an exception.
        /// </summary>
        /// <param name="sessionState">The session state to validate.</param>
        private static void ValidateSessionNotComplete(SessionState sessionState)
        {
            if (sessionState.State.IsComplete)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.OperationNotAllowedForCompleteSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionState.SessionID,
                    sessionState.GameID.ToString());
            }
        }

        /// <summary>
        /// Finds the seat of a player.
        /// </summary>
        /// <param name="sessionState">Session state to look into.</param>
        /// <param name="identity">Identity of the player.</param>
        /// <returns>The player's SeatInfo.</returns>
        private static SeatInfo GetPlayerSeat(SessionState sessionState, IdentityToken identity)
        {
            SeatInfo playerSeat = null;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Profile.Equals(identity))
                {
                    playerSeat = seat;
                    break;
                }
            }

            return playerSeat;
        }

        /// <summary>
        /// Finds the active seat and the actor's seat.
        /// </summary>
        /// <param name="sessionState">Session state to look into.</param>
        /// <param name="actorIdentity">Identity of the actor.</param>
        /// <param name="activeSeat">The active seat, null if not found.</param>
        /// <param name="actorSeat">The actor's seat, null if not found.</param>
        private static void GetActiveSeatAndActorSeat(SessionState sessionState, IdentityToken actorIdentity, out SeatInfo activeSeat, out SeatInfo actorSeat)
        {
            activeSeat = null;
            actorSeat = null;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Index == sessionState.State.ActiveSeatIndex)
                {
                    activeSeat = seat;
                }

                if (seat.Profile.Equals(actorIdentity))
                {
                    actorSeat = seat;
                }

                if (activeSeat != null && actorSeat != null)
                {
                    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\ServiceConfigs.cs ===
//-------------------------------------------------------------------
// <copyright file="ServiceConfigs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Session Management Service related Configurations. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/21/2008">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.SessionManagementService
{
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class ServiceConfigs
    {
        /// <summary>
        /// The interface of the database. 
        /// </summary>
        private const string QueueDatabaseInterface = "lest_AsyncNotification_db"; 

        /// <summary>
        /// Gets the Azure storage account
        /// </summary>
        public static string AzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SessionFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token
        /// </summary>
        public static string AzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SessionFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the Azure table storage access endpoint.
        /// </summary>
        public static string AzureTableStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureTableStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure blob storage access endpoint. 
        /// </summary>
        public static string AzureBlobStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureBlobStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure queue storage access point. 
        /// </summary>
        public static string AzureQueueStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureQueueStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the proxy settings in the configuration. 
        /// </summary>
        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }

        /// <summary>
        /// Gets the connection string to notification request queue. 
        /// </summary>
        public static string NotificationRequestQueueConnectionString
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetConnectionString(QueueDatabaseInterface); 
            }
        }

        /// <summary>
        /// Gets the subject of the STS certificate used to sign the Partner Tokens.
        /// </summary>
        public static string StsCertificateSubject
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.StsCertificateSubject);
            }
        }

        /// <summary>
        /// Gets the maximum sessions allowed to be created per user.
        /// </summary>
        public static int MaxCreateSessionsAllowedPerUser
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.SessionFE_MaxCreateSessionsAllowedPerUser);
            }
        }

        /// <summary>
        /// Initialize the settings. 
        /// </summary>
        public static void Initialize()
        {
            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider(Global.ServiceName, "LEET");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\IGameStateService.cs ===
﻿// <copyright file="IGameStateService.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-07-23</date>
// <summary>Contains the WCF interface for the game state service.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using Microsoft.ServiceModel.Web;
    using SessionCommon;

    /// <summary>
    /// The WCF interface for the game state service.
    /// </summary>
    [ServiceContract]
    public interface IGameStateService
    {
        /// <summary>
        /// Gets the game state for the given session for a particular game in Xml format.
        /// </summary>
        /// <param name="sessionID">SessionID for which to get the game state.</param>
        /// <param name="gameID">GameID for which to get the game state.</param>
        /// <returns>The Full GameState for a session.</returns>
        [WebHelp(Comment = "Gets the game state for the given session for a particular game in Xml format.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GameState/{sessionID}/{gameID}", Method = "GET")]
        FullGameState GetGameStateInXml(string sessionID, string gameID);

        /// <summary>
        /// Sets the game state for the given session for a particular game.
        /// </summary>
        /// <param name="sessionID">SessionID for which to set the game state.</param>
        /// <param name="gameID">GameID for which to set the game state.</param>
        /// <param name="modGameState">The GameState to be put.</param>
        [WebHelp(Comment = "Sets the game state for the given session for a particular game.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GameState/{sessionID}/{gameID}", Method = "PUT")]
        void PutGameState(string sessionID, string gameID, ModifiableGameState modGameState);

        /// <summary>
        /// Ends a particular passthrough game.
        /// </summary>
        /// <param name="sessionID">SessionID to end.</param>
        /// <param name="gameID">GameID to end.</param>
        /// <param name="gameResults">The win/loss/tie results of the game.</param>
        [WebHelp(Comment = "Ends a particular passthrough game.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GameState/{sessionID}/{gameID}", Method = "POST")]
        void PostGameEnd(string sessionID, string gameID, GameResults gameResults);

        /// <summary>
        /// Submits a new game action for a particular game session.
        /// </summary>
        /// <param name="sessionID">SessionID for which to submit a new game action.</param>
        /// <param name="gameID">GameID for which to submit a new game action.</param>
        /// <param name="gameAction">The GameAction to be submitted.</param>
        [WebHelp(Comment = "Submits a new game action for a particular game session.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GameAction/{sessionID}/{gameID}", Method = "POST")]
        void PostGameAction(string sessionID, string gameID, GameAction gameAction);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\ProfileHelper.cs ===
﻿// <copyright file="ProfileHelper.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-12</date>
// <summary>Contains the class definition for ProfileHelper class.</summary>

namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using System.Net;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Identity.PartnerAuth;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;
    using LIVEN.Common.Diagnostics; 
    using SessionCommon;

    /// <summary>
    /// Helper class to mediate between the profile provider and the MP session service.
    /// </summary>
    public class ProfileHelper
    {
        /// <summary>
        /// Populates the seat info with profile information.
        /// </summary>
        /// <param name="seatInfo">The seat info to be populated.</param>
        /// <param name="actorIdentity">The identity of the actor on whose behalf this call is going to be made.</param>
        /// <param name="locale">The locale for which to populate the profile.</param>
        public static void PopulateProfile(SeatInfo seatInfo, IdentityToken actorIdentity, string locale)
        {
            if (actorIdentity.ServiceType == IdentityServiceType.XUID && seatInfo.Profile.ServiceType == IdentityServiceType.XUID)
            {
                ulong actorXuid;
                try
                {
                    actorXuid = ulong.Parse(actorIdentity.Token);
                }
                catch (Exception ex)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.IdentityTokenDoesNotHaveValidXuid,
                        HttpStatusCode.InternalServerError,
                        ex,
                        false,
                        actorIdentity.Token);
                }

                IUserIdentity actorUserIdentity = new UserIdentity(actorXuid) { IsAuthenticated = true };

                try
                {
                    bool partialResults;
                    IReadOnlyFriendInfo[] friendsInfoList = null;
                    IProfileProvider profileProvider = Container.Instance.GetComponent<IProfileProvider>();
                    ulong targetXuid = ulong.Parse(seatInfo.Profile.Token);
                    Profile playerProfile = profileProvider.GetProfile(
                                                                actorUserIdentity,
                                                                targetXuid,
                                                                locale,
                                                                (long)ProfileSections.XboxLiveProperties,
                                                                out friendsInfoList,
                                                                out partialResults);

                    seatInfo.DisplayName = (string)playerProfile.ProfileProperties[ProfileProperty.GamerTag];
                    seatInfo.DisplayPicURL = (string)playerProfile.ProfileProperties[ProfileProperty.GamerPicUrl];
                    seatInfo.DisplayPicSmallURL = (string)playerProfile.ProfileProperties[ProfileProperty.SmallGamerPicUrl];
                }
                catch (Exception ex)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.ErrorWhileTryingToPopulateProfile,
                        HttpStatusCode.InternalServerError,
                        ex,
                        true,
                        seatInfo.Profile.PublicToken);
                }
            }
            else
            {
                throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.DontKnowHowToPopulateProfileForNonXuidIdentityTokens,
                        HttpStatusCode.InternalServerError,
                        null,
                        false,
                        seatInfo.Profile.ServiceType.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\IdentityHelper.cs ===
﻿// <copyright file="IdentityHelper.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-12-21</date>
// <summary>Contains the class definition for IdentityHelper class.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System.Globalization;
    using System.Net;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Identity.PartnerAuth;
    using LIVEN.Common.Diagnostics;
    using SessionCommon;

    /// <summary>
    /// Helper class to map identity from HTTP headers to IdentityTokens.
    /// </summary>
    public class IdentityHelper
    {
        /// <summary>
        /// Gets the IdentityToken for the current user.
        /// </summary>
        /// <param name="gameID">The GameID parameter in the API requesting identity.</param>
        /// <returns>The IdentityToken for the current user.</returns>
        public static IdentityToken GetIdentity(string gameID)
        {
            // Check if the user is authenticated.
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();
            if (!authManager.IsAuthenticated)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserIsNotAuthenticated,
                    HttpStatusCode.Unauthorized,
                    null,
                    false);
            }

            // Get the User Identity Object
            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserAuthenticatedButNoCurrentUserFound,
                    HttpStatusCode.Unauthorized,
                    null,
                    false);
            }

            // We should be able to cast because callerIdentity is a PartnerIdentity in our case.
            if (!(callerIdentity is PartnerIdentity))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.CurrentUserDoesNotHaveAPartnerIdentity,
                    HttpStatusCode.InternalServerError,
                    null,
                    false);
            }

            PartnerIdentity partnerIdentity = (PartnerIdentity)callerIdentity;

            if (string.IsNullOrEmpty(partnerIdentity.TitleId))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.PartnerTokenTitleIDIsNullOrEmpty,
                    HttpStatusCode.Unauthorized,
                    null,
                    false,
                    partnerIdentity.TitleId);
            }

            uint titleIDAsUint;
            if (!uint.TryParse(partnerIdentity.TitleId, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out titleIDAsUint))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidTitleIDFormat,
                    HttpStatusCode.Unauthorized,
                    null,
                    false,
                    partnerIdentity.TitleId);
            }

            // Make sure that the TitleID in the partner token matches the GameID.
            if (!string.IsNullOrEmpty(gameID))
            {
                uint gameIDAsUint;
                if (!uint.TryParse(gameID, out gameIDAsUint))
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidGameIDFormatWhileGettingIdentity,
                        HttpStatusCode.Unauthorized,
                        null,
                        false,
                        gameID);
                }

                if (gameIDAsUint != titleIDAsUint)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.GameIDDoesNotMatchPartnerTokenTitleID,
                        HttpStatusCode.Unauthorized,
                        null,
                        false,
                        gameIDAsUint.ToString(),
                        titleIDAsUint.ToString());
                }
            }
            else
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.GameIDIsNullOrEmpty,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    gameID);
            }

            if (callerIdentity.Xuid == 0)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileTryingToGetXuid,
                    HttpStatusCode.Unauthorized,
                    null,
                    false);
            }

            if (string.IsNullOrEmpty(callerIdentity.Gamertag))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileTryingToGetGamerTag,
                    HttpStatusCode.Unauthorized,
                    null,
                    false);
            }

            return new IdentityToken(callerIdentity.Xuid, callerIdentity.Gamertag);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\ISessionManagementService.cs ===
﻿// <copyright file="ISessionManagementService.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-07-23</date>
// <summary>Contains the WCF interface for the session management service.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using Microsoft.ServiceModel.Web;
    using SessionCommon;

    /// <summary>
    /// The WCF interface for the session management service.
    /// </summary>
    [ServiceContract]
    public interface ISessionManagementService
    {
        /// <summary>
        /// Creates a new Game Session for the game responding in Xml format.
        /// </summary>
        /// <param name="gameID">GameID for which the session is created.</param>
        /// <param name="creationData">Data used for creating the session.</param>
        /// <returns>The SessionData for the new session created.</returns>
        [WebHelp(Comment = "Create a new session.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "game/{gameID}", Method = "POST")]
        SessionState CreateSessionInXml(string gameID, CreationData creationData);

        /// <summary>
        /// Join a session while expecting Xml request/response.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to join.</param>
        /// <param name="joinData">The join data.</param>
        /// <returns>The session state.</returns>
        [WebHelp(Comment = "Join a session.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "session/{sessionID}", Method = "POST")]
        SessionState JoinSessionInXml(string sessionID, JoinData joinData);

        /// <summary>
        /// Reject an invitation so the invitation notification could be deleted. 
        /// GameId is required because it doesn't make sense to lookup the session state for this. 
        /// </summary>
        /// <param name="gameIDString">GameID string from the invitation. </param>
        /// <param name="sessionID">SessionID of the session from invitation.</param>
        [WebHelp(Comment = "Reject invitation.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "invite/{sessionID}/{gameIDString}", Method = "DELETE")]
        void RejectInvitation(string gameIDString, string sessionID);

        /// <summary>
        /// Leave a session.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to leave.</param>
        /// <param name="gameID">GameID of the session to leave.</param>
        [WebHelp(Comment = "Leave a session.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "session/{sessionID}/{gameID}", Method = "DELETE")]
        void LeaveSession(string sessionID, string gameID);

        /// <summary>
        /// Modify a session.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to modify.</param>
        /// <param name="gameID">GameID of the session to modify.</param>
        /// <param name="modificationData">The modification data.</param>
        [WebHelp(Comment = "Modify a session.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "session/{sessionID}/{gameID}", Method = "PUT")]
        void ModifySession(string sessionID, string gameID, ModificationData modificationData);

        /// <summary>
        /// View the details of a session in Xml format.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to view.</param>
        /// <param name="gameID">GameID of the session to view.</param>
        /// <returns>The session state.</returns>
        [WebHelp(Comment = "View the details of a session.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "session/{sessionID}/{gameID}", Method = "GET")]
        SessionState ViewSessionInXml(string sessionID, string gameID);

        /// <summary>
        /// View the summary of sessions that a user is involved in formatted in Xml.
        /// </summary>
        /// <param name="gameID">GameID for which to retrieve session information.</param>
        /// <param name="variant">Game variant for which to retrieve session information.</param>
        /// <param name="lastSessionID">Last Session for which information was already retrieved, sessions retrieved will be sessionIDs after this.</param>
        /// <param name="maxSessions">Maximum number of session to retrieve.</param>
        /// <param name="showSessionType">What kind of sessions to show, defaults to all sessions.</param>
        /// <returns>The session entries for the user.</returns>
        [WebHelp(Comment = "View the summary of sessions that a user is involved in.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "game?game={gameID}&variant={variant}&lastSession={lastSessionID}&max={maxSessions}&showSessionType={showSessionType}", Method = "GET")]
        SessionEntry[] ViewSessionSummariesInXml(string gameID, string variant, string lastSessionID, string maxSessions, string showSessionType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\SessionManagementService.cs ===
﻿// <copyright file="SessionManagementService.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionManagementService class.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using Common.AzureStorage;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using GameStateAzureStorage;
    using Leet.Core.BI;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationSender;
    using NotificationService;
    using PassThruGameLogicModule;
    using SessionCommon;
    using SessionMaintenance;

    /// <summary>
    /// Session service class which handles all session related requests.
    /// </summary>
    public partial class SessionManagementService
    {
        /// <summary>
        /// Maximum value of maxSessions allowed.
        /// </summary>
        public const int MaxSessionsLimit = 1000;

        /// <summary>
        /// Maximum number of players allowed to be in a session at one time.
        /// </summary>
        public const int MaxAllowedPlayersInSession = 16;

        /// <summary>
        /// Maximum allowed length of the SessionParameters field.
        /// </summary>
        private const int MaxSessionParameterLength = 64 * 1024; // 64K

        /// <summary>
        /// Maximum allowed system nudges before a warning.
        /// </summary>
        private const int MaxAllowedSystemNudges = 25;

        /// <summary>
        /// This field is used to store the reference to a ISessionStorage implementation.
        /// </summary>
        private static ISessionStorage sessionStorage;

        /// <summary>
        /// This field is used to store the reference to a IGameStateStorage implementation.
        /// </summary>
        private static IGameStateStorage stateStorage;

        /// <summary>
        /// This field is used to store the reference to a IGameLogicModule implementation.
        /// </summary>
        private static IGameLogicModule gameLogicModule;

        /// <summary>
        /// This field has the reference to the INotificationRequest implementation.
        /// </summary>
        private static INotificationRequest notificationRequest;

        /// <summary>
        /// This field has the reference to the IGameMetadataClient implementation.
        /// </summary>
        private static IGameMetadataClient gameMetadataClient;

        /// <summary>
        /// Initializes static members of the SessionManagementService class.
        /// </summary>
        static SessionManagementService()
        {
            StorageAccountInfo account = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            StorageAccountInfo blobAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureBlobStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            // NOTE: HACK!!! Use a Factory pattern to assign an implementation and remove dependency
            // on SessionAzureStorage/NotificationRequestUtils etc.
            SessionManagementService.sessionStorage =
                new SessionAzureStorage.SessionAzureStorage(account, ServiceConfigs.ProxyAddress);

            SessionManagementService.stateStorage = new GameStateAzureStorage(blobAccount, ServiceConfigs.ProxyAddress);
            SessionManagementService.gameLogicModule = new PassThruGameLogicModule(stateStorage, sessionStorage);

            SessionManagementService.notificationRequest =
                new NotificationRequestUtils(ServiceConfigs.NotificationRequestQueueConnectionString);

            SessionManagementService.gameMetadataClient = Container.Instance.GetComponent<IGameMetadataClient>();
        }

        /// <summary>
        /// Create a new session.
        /// </summary>
        /// <param name="gameID">GameID for which to create a new session.</param>
        /// <param name="creationData">The creation data.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="locale">The user locale.</param>
        /// <param name="platformType">The user platform type.</param>
        /// <returns>The session state.</returns>
        public SessionState CreateSessionInternal(string gameID, CreationData creationData, IdentityToken identity, string locale, PlatformType platformType)
        {
            SessionManagementService.ValidateCreateSessionParameters(gameID, creationData, locale);

            SessionState sessionState = null;
            try
            {
                sessionState = new SessionState(creationData, identity, locale, platformType);
                sessionStorage.AddSession(sessionState, ServiceConfigs.MaxCreateSessionsAllowedPerUser);
            }
            catch (LIVEnException)
            {
                throw;
            }
            catch (Exception ex)
            {
                string creationDataStr = string.Empty;
                try
                {
                    using (MemoryStream stream = new MemoryStream())
                    {
                        DataContractSerializer ser = new DataContractSerializer(typeof(CreationData));
                        ser.WriteObject(stream, creationData);
                        Encoding encoding = new UTF8Encoding();
                        creationDataStr = encoding.GetString(stream.ToArray());
                    }
                }
                catch (Exception)
                {
                    // Ignore any exceptions
                }

                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileCreatingSession,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    gameID,
                    creationDataStr);
            }

            // Fire a call into the game logic module.
            SessionManagementService.gameLogicModule.OnCreateSession(sessionState, creationData);

            // Populate the profile/ActorSeat information for players & obfuscate identities as necessary.
            SessionManagementService.PopulatePlayerProfiles(sessionState, identity, locale);
            SessionManagementService.PopulateActorSeatAndObfuscateIdentities(sessionState, identity, true);

            return sessionState;
        }

        /// <summary>
        /// Add the current user to the sesssion.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to join.</param>
        /// <param name="joinData">Join data.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="locale">The user locale.</param>
        /// <param name="platformType">The user platfrom type.</param>
        /// <returns>The session state.</returns>
        public SessionState JoinSessionInternal(string sessionID, JoinData joinData, IdentityToken identity, string locale, PlatformType platformType)
        {
            // log business intelligence data, need to log before any validations
            try
            {
                ulong partnerXuid;
                UInt64.TryParse(identity.Token, out partnerXuid);
                BILogging.LogBIData(
                    OriginatorIDType.Partner,
                    partnerXuid,
                    ((uint) platformType).ToString(),
                    joinData.GameID,
                    Global.ServiceName,
                    "JoinSession");
            }
            catch (Exception ex)
            {
                // None of this should throw, but take no chance
               Logging.TraceWarning(
                   "{0}: {1} {2}",
                    "SessionManagementService",
                    "Unexpected exception caught while writing BI data",
                    ex.ToString());
            }

            ValidateJoinSessionParameters(sessionID, joinData);
            SessionState sessionState = sessionStorage.AddPlayer(sessionID, joinData, identity, locale, platformType);
            SessionManagementService.gameLogicModule.OnJoinSession(sessionState, joinData);

            NotificationSender notificationSender = new NotificationSender(SessionManagementService.notificationRequest);
            notificationSender.DeleteInvitationNotification(sessionState.GameID, sessionState.SessionID, identity); // Delete any invites received for this session.

            // Send a "Your Turn" notification if it is the user's turn.
            int? userSeatIndex = null;
            IdentityToken ownerIdentity = notificationSender.SystemIdentity;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Profile.Equals(identity))
                {
                    userSeatIndex = seat.Index;
                }

                if (seat.Index == sessionState.OwnerSeatIndex)
                {
                     ownerIdentity = seat.Profile;
                }

                // We have the info that we need, break.
                if (userSeatIndex.HasValue && !ownerIdentity.Equals(notificationSender.SystemIdentity))
                {
                    break;
                }
            }

            if (userSeatIndex.Value == sessionState.State.ActiveSeatIndex)
            {
                notificationSender.SendYourTurnNotification(sessionState, ownerIdentity);
            }

            // Populate the profile/ActorSeat information for players & obfuscate identities as necessary.
            SessionManagementService.PopulatePlayerProfiles(sessionState, identity, locale);
            SessionManagementService.PopulateActorSeatAndObfuscateIdentities(sessionState, identity, true);

            return sessionState;
        }

        /// <summary>
        /// Reject an invitation. 
        /// </summary>
        /// <param name="gameIDString">The game Id in string format. </param>
        /// <param name="sessionId">The session Id. </param>
        /// <param name="identity">The identity of the user who is rejecting. </param>
        public void RejectInvitationInternal(string gameIDString, string sessionId, IdentityToken identity)
        {
            uint gameId;
            bool isGameIDUint = uint.TryParse(gameIDString, out gameId);
            if (!isGameIDUint)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormat,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    gameIDString);
            }

            NotificationSender notificationSender = new NotificationSender(SessionManagementService.notificationRequest);
            notificationSender.DeleteInvitationNotification(gameId, sessionId, identity);
        }

        /// <summary>
        /// Leave a session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to leave.</param>
        /// <param name="gameID">The gameID of the session to leave.</param>
        /// <param name="identity">The user identity.</param>
        public void LeaveSessionInternal(string sessionID, string gameID, IdentityToken identity)
        {
            uint game;
            try
            {
                game = Convert.ToUInt32(gameID);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatOnLeave,
                    HttpStatusCode.BadRequest,
                    ex,
                    false,
                    sessionID,
                    gameID);
            }

            SeatInfo leavingPlayerSeat;
            bool ownerLeft;
            SessionState newSessionState = sessionStorage.RemovePlayer(sessionID, game, identity, out leavingPlayerSeat, out ownerLeft);

            if (leavingPlayerSeat != null)
            {
                SessionManagementService.gameLogicModule.OnLeaveSession(newSessionState, ownerLeft, leavingPlayerSeat);
                SessionUtils.ApplyLeavePolicyAndManageNotifications(
                    newSessionState, leavingPlayerSeat, SessionManagementService.notificationRequest, SessionManagementService.sessionStorage);
            }
        }

        /// <summary>
        /// Modify a session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to modify.</param>
        /// <param name="gameID">The gameID of the session to modify.</param>
        /// <param name="modificationData">The modification data.</param>
        /// <param name="identity">The user identity.</param>
        public void ModifySessionInternal(
                    string sessionID,
                    string gameID,
                    ModificationData modificationData,
                    IdentityToken identity)
        {
            uint gameIDAsUint = SessionManagementService.ValidateModifySessionParameters(sessionID, gameID, modificationData);

            SessionState newSessionState = sessionStorage.ModifySession(sessionID, gameIDAsUint, modificationData, identity);
            SessionManagementService.gameLogicModule.OnModifySession(newSessionState, modificationData);
        }

        /// <summary>
        /// View the details of a session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to view.</param>
        /// <param name="gameID">The gameID of the session to view.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="obfuscateIdentity">Should this method obfuscate identity of the players in a session?</param>
        /// <param name="locale">The locale to be used for viewing session.</param>
        /// <returns>The state of the session.</returns>
        public SessionState ViewSessionInternal(string sessionID, string gameID, IdentityToken identity, bool obfuscateIdentity, string locale)
        {
            uint game;
            try
            {
                game = Convert.ToUInt32(gameID);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatOnView,
                    HttpStatusCode.BadRequest,
                    ex,
                    false,
                    sessionID,
                    gameID);
            }

            SeatInfo actorSeat;
            SessionState sessionState = SessionManagementService.QuerySessionAndDeleteNotifications(sessionID, game, identity, out actorSeat);

            // Populate the profile/ActorSeat information for players & obfuscate identities as necessary.
            SessionManagementService.PopulatePlayerProfiles(sessionState, identity, locale);
            SessionManagementService.PopulateActorSeatAndObfuscateIdentities(sessionState, identity, obfuscateIdentity);

            return sessionState;
        }

        /// <summary>
        /// View the sessions in which the user is participating.
        /// </summary>
        /// <param name="identity">The user identity.</param>
        /// <param name="gameID">GameID for which to retrieve session information.</param>
        /// <param name="variant">Game variant for which to retrieve session information.</param>
        /// <param name="lastSessionID">Last Session for which information was already retrieved, sessions retrieved will be sessionIDs after this.</param>
        /// <param name="maxSessions">Maximum number of session to retrieve.</param>
        /// <param name="showSessionType">What kind of sessions to show, defaults to all sessions.</param>
        /// <returns>Array of session entries.</returns>
        public SessionEntry[] ViewSessionSummariesInternal(IdentityToken identity, string gameID, string variant, string lastSessionID, string maxSessions, string showSessionType)
        {
            SessionQueryParameters sessionQueryParams = ValidateSessionQueryParameters(
                                                            gameID,
                                                            variant,
                                                            lastSessionID,
                                                            maxSessions,
                                                            showSessionType);

            return sessionStorage.QuerySessions(identity, sessionQueryParams);
        }

        /// <summary>
        /// Queries the details of a single session and deletes the notifications related that session for the actor if the session is complete.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to be queried.</param>
        /// <param name="gameID">GameID of the session to be queried.</param>
        /// <param name="actorIdentity">Identity of the actor(user) querying the session.</param>
        /// <param name="actorSeat">The seat of the actor.</param>
        /// <returns>The state of the session.</returns>
        internal static SessionState QuerySessionAndDeleteNotifications(string sessionID, uint gameID, IdentityToken actorIdentity, out SeatInfo actorSeat)
        {
            OpaqueSessionStorageObject storageObject;
            SessionState sessionState = sessionStorage.QuerySession(sessionID, gameID, out storageObject);

            actorSeat = null;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Profile.Equals(actorIdentity))
                {
                    actorSeat = seat;
                    break;
                }
            }

            if (actorSeat == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNotAllowedToGetStateInSession,
                    HttpStatusCode.Forbidden);
            }

            // If the game is over, delete all notifications
            if (sessionState.State.IsComplete && !actorSeat.NotificationsCleaned)
            {
                // Delete all notifications received for this session.
                NotificationSender notificationSender = new NotificationSender(SessionManagementService.notificationRequest);
                notificationSender.DeleteAllNotificationsForSession(sessionState, actorIdentity);

                // Mark the notifications as being deleted for the user.
                actorSeat.NotificationsCleaned = true;
                sessionStorage.ModifySession(storageObject, sessionState.Seats);
            }

            return sessionState;
        }

        /// <summary>
        /// Validate the create session parameters.
        /// </summary>
        /// <param name="gameID"> The gameID to validate</param>
        /// <param name="creationData">The creationData to validate.</param>
        /// <param name="locale">The locale for creating the session.</param>
        private static void ValidateCreateSessionParameters(string gameID, CreationData creationData, string locale)
        {
            // Validate GameID.
            uint gameIDAsUint;
            bool isGameIDUint = uint.TryParse(gameID, out gameIDAsUint);

            if (!isGameIDUint)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatOnCreate,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    gameID);
            }

            // Check if the gameIDs are consistent
            if (creationData.GameID != gameIDAsUint)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.GameIDInconsistentInInputParameters,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    gameID,
                    creationData.GameID.ToString());
            }

            // Validate SessionParameters.
            if (creationData.SessionParameters != null && creationData.SessionParameters.Length > SessionManagementService.MaxSessionParameterLength)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.SessionParametersTooLongInCreateSession,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    creationData.SessionParameters.Length.ToString(),
                    SessionManagementService.MaxSessionParameterLength.ToString());
            }

            // Validate InactivityWarning.
            SessionManagementService.ValidateInactivityWarning(creationData.InactivityWarning);

            // Validate total seats.
            SessionManagementService.ValidateSeats(creationData.TotalSeatsAvailable);

            // Validate the gameID & Variant using the Game Metadata System
            Dictionary<uint, GameVariantComposite> metadataDictionary =
                SessionManagementService.gameMetadataClient.GetGameVariants(creationData.GameID);
            if (metadataDictionary.Count == 0 || !metadataDictionary.ContainsKey((uint)creationData.Variant))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.GameIDOrVariantIsNotInGMS,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    creationData.GameID.ToString(),
                    creationData.Variant.ToString());
            }
            else
            {
                // Check if this is a valid LIVE multiplayer game.
                GameMetadataComposite gameMetadata =
                    SessionManagementService.gameMetadataClient.GetGameMetadata(creationData.GameID, locale);

                if (!gameMetadata.UsesLiveMultiplayerServices)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.ThisGameIDIsNotALIVEMultiplayerGame,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        creationData.GameID.ToString());
                }
            }
        }

        /// <summary>
        /// Validates the inactivity warning behavior
        /// </summary>
        /// <param name="inactivityWarningBehavior">The inactivity warning behavior to be validated.</param>
        private static void ValidateInactivityWarning(InactivityWarningBehavior inactivityWarningBehavior)
        {
            if (inactivityWarningBehavior == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InactivityWarningIsNull,
                    HttpStatusCode.BadRequest,
                    null,
                    false);
            }

            if (inactivityWarningBehavior.MaxNumberOfNudges < 0 || inactivityWarningBehavior.MaxNumberOfNudges > SessionManagementService.MaxAllowedSystemNudges)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.MaxNumberOfNudgesIsNotBetweenAllowedLimits,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    SessionManagementService.MaxAllowedSystemNudges.ToString(),
                    inactivityWarningBehavior.MaxNumberOfNudges.ToString());
            }

            if (inactivityWarningBehavior.Interval < 0)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.IntervalIsNegative,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    inactivityWarningBehavior.Interval.ToString());
            }

            // In case we have an action defined, the behavior must have a greater than zero Interval.
            if (inactivityWarningBehavior.Action != InactivityWarningAction.None)
            {
                if (inactivityWarningBehavior.Interval < 1)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.IntervalIsInvalid,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        inactivityWarningBehavior.Interval.ToString());
                }
            }
        }

        /// <summary>
        /// Validate totalSeatsAvailable. 
        /// </summary>
        /// <param name="totalSeatsAvailable">Total seats available.</param>
        private static void ValidateSeats(int totalSeatsAvailable)
        {
            if (totalSeatsAvailable < 2 || totalSeatsAvailable > MaxAllowedPlayersInSession)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidTotalSeatsAvailable,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    MaxAllowedPlayersInSession.ToString(),
                    totalSeatsAvailable.ToString());
            }
        }

        /// <summary>
        /// Validate the ModifySession parameters.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to validate.</param>
        /// <param name="gameID">The gameID of the session to validate.</param>
        /// <param name="modificationData">The modification data to validate.</param>
        /// <returns>The gameID as uint.</returns>
        private static uint ValidateModifySessionParameters(string sessionID, string gameID, ModificationData modificationData)
        {
            // Validate GameID.
            uint gameIDAsUint;
            bool isGameIDUint = uint.TryParse(gameID, out gameIDAsUint);

            if (!isGameIDUint)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.InvalidGameIDFormatOnModify,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    sessionID,
                    gameID);
            }

            // Validate total seats.
            SessionManagementService.ValidateSeats(modificationData.TotalSeatsAvailable);

            // Validate SessionParameters.
            if (modificationData.SessionParameters != null && modificationData.SessionParameters.Length > SessionManagementService.MaxSessionParameterLength)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.SessionParametersTooLongInModifySession,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    modificationData.SessionParameters.Length.ToString(),
                    SessionManagementService.MaxSessionParameterLength.ToString());
            }

            // Validate InactivityWarning.
            SessionManagementService.ValidateInactivityWarning(modificationData.InactivityWarning);

            return gameIDAsUint;
        }

        /// <summary>
        /// Validates parameters for a QuerySession call.
        /// These are the valid combinations of query parameters:
        /// 1. No parameters.
        /// 2. GameID only.
        /// 3. GameID and Variant.
        /// 4. ShowSessionType only, along with any of the above combinations.
        /// 5. MaxSessions only, along with any of the above combinations.
        /// 6. LastSessionID and LastGameID, along with any of the above combinations.
        /// </summary>
        /// <param name="gameID">GameID for which to retrieve session information.</param>
        /// <param name="variant">Game variant for which to retrieve session information.</param>
        /// <param name="lastSessionID">Last Session for which information was already retrieved, sessions retrieved will be sessionIDs after this.</param>
        /// <param name="maxSessions">Maximum number of session to retrieve.</param>
        /// <param name="showSessionType">What kind of sessions to show, defaults to all sessions.</param>
        /// <returns>A SessionQueryParameters object based on passed in arguments.</returns>
        private static SessionQueryParameters ValidateSessionQueryParameters(
            string gameID, string variant, string lastSessionID, string maxSessions, string showSessionType)
        {
            SessionQueryParameters sessionQueryParams = new SessionQueryParameters();

            // Populate session query parameters
            if (!string.IsNullOrEmpty(gameID))
            {
                uint gameIDAsUint;
                if (!uint.TryParse(gameID, out gameIDAsUint))
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidGameIDFormatOnValidateQueryParams,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        gameID);
                }
                else
                {
                    sessionQueryParams.GameID = gameIDAsUint;
                }
            }

            if (!string.IsNullOrEmpty(variant))
            {
                int variantAsInt;
                if (!int.TryParse(variant, out variantAsInt))
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidVariantFormatOnValidateQueryParams,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        variant);
                }
                else
                {
                    // You can use the variant only if GameID is specified.
                    if (!sessionQueryParams.GameID.HasValue)
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.VariantCanBeSpecifiedOnlyIfGameIDIsSpecified,
                            HttpStatusCode.BadRequest,
                            null,
                            false,
                            gameID,
                            variant);
                    }

                    sessionQueryParams.Variant = variantAsInt;
                }
            }

            if (!string.IsNullOrEmpty(lastSessionID))
            {
                    sessionQueryParams.LastSessionID = lastSessionID;
            }

            if (!string.IsNullOrEmpty(maxSessions))
            {
                int maxSessionsAsInt;
                if (!int.TryParse(maxSessions, out maxSessionsAsInt) || maxSessionsAsInt <= 0 || maxSessionsAsInt > SessionManagementService.MaxSessionsLimit)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidMaxSessionsParam,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        SessionManagementService.MaxSessionsLimit.ToString(),
                        maxSessions);
                }
                else
                {
                    sessionQueryParams.MaxSessions = maxSessionsAsInt;
                }
            }

            if (!string.IsNullOrEmpty(showSessionType))
            {
                ShowSessionType sessionType;
                try
                {
                    sessionType = (ShowSessionType) Enum.Parse(typeof(ShowSessionType), showSessionType, true);
                    if (!Enum.IsDefined(typeof(ShowSessionType), sessionType))
                    {
                        throw new ArgumentException("ShowSessionType parameter is not an underlying value of the ShowSessionType enumeration");
                    }
                    else
                    {
                        sessionQueryParams.ShowSessionType = sessionType;
                    }
                }
                catch (ArgumentException ex)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidShowSessionTypeParam,
                        HttpStatusCode.BadRequest,
                        ex,
                        false,
                        showSessionType);
                }
            }

            return sessionQueryParams;
        }

        /// <summary>
        /// Validate JoinSession parameters.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to join.</param>
        /// <param name="joinData">Join data.</param>
        private static void ValidateJoinSessionParameters(string sessionID, JoinData joinData)
        {
            // Validate SeatIndex.
            if (joinData.SeatIndex < 0)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.NegativeSeatIndexNotAllowed,
                    HttpStatusCode.BadRequest,
                    null,
                    false,
                    joinData.SeatIndex.ToString());
            }
        }

        /// <summary>
        /// Populate the SeatInfo with the players' profile information.
        /// </summary>
        /// <param name="sessionState"> The session state that needs to be populated with profile information.</param>
        /// <param name="actorIdentity">The actor's identity.</param>
        /// <param name="locale">The locale for which to populate the profiles.</param>
        private static void PopulatePlayerProfiles(SessionState sessionState, IdentityToken actorIdentity, string locale)
        {
            foreach (var seat in sessionState.Seats)
            {
                try
                {
                    ProfileHelper.PopulateProfile(seat, actorIdentity, locale);
                }
                catch (LIVEnException)
                {
                    // Ignore any LIVEnExceptions while trying to get profile information.
                }
            }
        }

        /// <summary>
        /// Populate the ActorSeat field and obfuscate identities.
        /// </summary>
        /// <param name="sessionState"> The session state that needs to be populated and obfuscated.</param>
        /// <param name="actorIdentity">The actor's identity</param>
        /// <param name="obfuscateIdentities">Should the identities be obfuscated?</param>
        private static void PopulateActorSeatAndObfuscateIdentities(SessionState sessionState, IdentityToken actorIdentity, bool obfuscateIdentities)
        {
            // Set the ActorSeat and obfuscate the identity of the players in the session.
            foreach (var seat in sessionState.Seats)
            {
                // Set the ActorSeat.
                if (seat.Profile.Equals(actorIdentity))
                {
                    sessionState.ActorSeat = seat.Index;
                }

                if (obfuscateIdentities)
                {
                    IdentityToken publicIdentity = new IdentityToken(
                                                        seat.Profile.ServiceType,
                                                        null,                       // Removing private token.
                                                        seat.Profile.PublicToken);
                    seat.Profile = publicIdentity;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\SessionServiceAudienceUriProvider.cs ===
﻿// <copyright file="SessionServiceAudienceUriProvider.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-25</date>
// <summary>Contains the class definition for SessionServiceAudienceUriProvider class.</summary>

namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;

    /// <summary>
    /// Class which provides the session service Audience URI.
    /// </summary>
    public class SessionServiceAudienceUriProvider : IAudienceUriProvider
    {
        /// <summary>
        /// Gets the list of allowed Audience URIs for the session service.
        /// </summary>
        public string[] AudienceUriList
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return new string[] { configSettings.GetSetting(Settings.SessionFE_AudienceUri) };
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\Properties\AssemblyInfo.cs ===
﻿// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-07-09</date>
// <summary>Contains the assembly information for SessionManagementService.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionManagementService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("cbbf8d99-a418-4fea-9776-915c0faaede0")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\Sessions.svc.cs ===
﻿// <copyright file="Sessions.svc.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the partial class definition for SessionManagementService class.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Core.Utils;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using SessionCommon;

    /// <summary>
    /// Session service class which handles all session related requests.
    /// </summary>
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class SessionManagementService : ISessionManagementService
    {
        /// <summary>
        /// Component Name.
        /// </summary>
        private const string ComponentName = "SessionManagementService";

        /// <summary>
        /// Gets the locale for the current user.
        /// </summary>
        private string Locale
        {
            get
            {
                string locale = WebOperationContext.Current.IncomingRequest.Headers["X-Locale"];
                
                if (string.IsNullOrEmpty(locale))
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidLocaleHeader,
                        HttpStatusCode.BadRequest,
                        null,
                        false);
                }

                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
                return localeHelper.GetSupportedLocale(locale);
            }
        }

        /// <summary>
        /// Gets the Platform type for the current user.
        /// </summary>
        private PlatformType ClientPlatform
        {
            get
            {
                string clientPlatform = WebOperationContext.Current.IncomingRequest.Headers["X-Platform-Type"];
                try
                {
                    CustomHeaderValidator.ValidatePlatformTypeHttpHeader(clientPlatform);
                }
                catch (ArgumentException ex)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidPlatformTypeHeader,
                        HttpStatusCode.BadRequest,
                        ex,
                        false,
                        clientPlatform ?? String.Empty);
                }
                
                return (PlatformType)uint.Parse(clientPlatform);
            }
        }

        /// <summary>
        /// Creates a new Game Session for the game responding in Xml format.
        /// </summary>
        /// <param name="gameID">GameID for which the session is created.</param>
        /// <param name="creationData">Data used for creating the session.</param>
        /// <returns>The SessionData for the new session created.</returns>
        public SessionState CreateSessionInXml(string gameID, CreationData creationData)
        {
            const string MethodName = "CreateSessionInXml";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            SessionState sessionState = null;
            try
            {
                IdentityToken identity = IdentityHelper.GetIdentity(gameID);
                sessionState = this.CreateSessionInternal(gameID, creationData, identity, this.Locale, this.ClientPlatform);
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
            return sessionState;
        }

        /// <summary>
        /// Join a session while expecting Xml request/response.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to join.</param>
        /// <param name="joinData">The join data.</param>
        /// <returns>The session state.</returns>
        public SessionState JoinSessionInXml(string sessionID, JoinData joinData)
        {
            const string MethodName = "JoinSessionInXml";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            SessionState sessionState = null;
            try
            {
                if (joinData == null)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.NullJoinDataBadJoinSessionRequest,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        sessionID);
                }

                sessionState = this.JoinSessionInternal(
                    sessionID,
                    joinData,
                    IdentityHelper.GetIdentity(joinData.GameID.ToString()),
                    this.Locale,
                    this.ClientPlatform);
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
            return sessionState;
        }

        /// <summary>
        /// Reject an invitation so the invitation notification could be deleted. 
        /// GameId is required because it doesn't make sense to lookup the session state for this. 
        /// </summary>
        /// <param name="gameIDString">GameID string from the invitation. </param>
        /// <param name="sessionID">SessionID of the session from invitation.</param>
        public void RejectInvitation(string gameIDString, string sessionID)
        {
            const string MethodName = "RejectInvitation";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            try
            {
                this.RejectInvitationInternal(
                    gameIDString, sessionID, IdentityHelper.GetIdentity(gameIDString));
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
        }

        /// <summary>
        /// Leave a session.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to leave.</param>
        /// <param name="gameID">GameID of the session to leave.</param>
        public void LeaveSession(string sessionID, string gameID)
        {
            const string MethodName = "LeaveSession";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            try
            {
                this.LeaveSessionInternal(
                    sessionID, gameID, IdentityHelper.GetIdentity(gameID));
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
        }

        /// <summary>
        /// Modify a session.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to modify.</param>
        /// <param name="gameID">GameID of the session to modify.</param>
        /// <param name="modificationData">The modification data.</param>
        public void ModifySession(string sessionID, string gameID, ModificationData modificationData)
        {
            const string MethodName = "ModifySession";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            try
            {
                IdentityToken identity = IdentityHelper.GetIdentity(gameID);
                this.ModifySessionInternal(sessionID, gameID, modificationData, identity);
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
        }

        /// <summary>
        /// View the details of a session in Xml format.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to view.</param>
        /// <param name="gameID">GameID of the session to view.</param>
        /// <returns>The session state.</returns>
        public SessionState ViewSessionInXml(string sessionID, string gameID)
        {
            const string MethodName = "ViewSessionInXml";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            SessionState sessionState = null;
            try
            {
                sessionState = this.ViewSessionInternal(
                    sessionID, gameID, IdentityHelper.GetIdentity(gameID), true, this.Locale);
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
            return sessionState;
        }

        /// <summary>
        /// View the summary of sessions that a user is involved in formatted in Xml.
        /// </summary>
        /// <param name="gameID">GameID for which to retrieve session information.</param>
        /// <param name="variant">Game variant for which to retrieve session information.</param>
        /// <param name="lastSessionID">Last Session for which information was already retrieved, sessions retrieved will be sessionIDs after this.</param>
        /// <param name="maxSessions">Maximum number of session to retrieve.</param>
        /// <param name="showSessionType">What kind of sessions to show, defaults to all sessions.</param>
        /// <returns>The session entries for the user.</returns>
        public SessionEntry[] ViewSessionSummariesInXml(string gameID, string variant, string lastSessionID, string maxSessions, string showSessionType)
        {
            const string MethodName = "ViewSessionSummariesInXml";
            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Entered method: ", MethodName);

            SessionEntry[] sessionEntries = null;
            try
            {
                sessionEntries = this.ViewSessionSummariesInternal(
                    IdentityHelper.GetIdentity(gameID),
                    gameID,
                    variant,
                    lastSessionID,
                    maxSessions,
                    showSessionType);
            }
            catch (Exception ex)
            {
                SessionManagementService.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", ComponentName, "Exiting method: ", MethodName);
            return sessionEntries;
        }

        /// <summary>
        /// Handle any unexpected exceptions.
        /// </summary>
        /// <param name="methodName">The method in which exception was caught.</param>
        /// <param name="exception">The unexpected exception.</param>
        private static void HandleException(string methodName, Exception exception)
        {
            LIVEnException livEnException = exception as LIVEnException;

            Logging.TraceException(
                exception,
                "{0}: {1} {2}",
                ComponentName,
                "Exception caught in method: ",
                methodName);

            if (livEnException == null)
            {
                livEnException =
                    new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.UnexpectedExceptionInSessionService,
                        HttpStatusCode.InternalServerError,
                        exception,
                        true,
                        methodName);
            }

            livEnException.ThrowWebProtocolException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService.Test\Properties\AssemblyInfo.cs ===
﻿// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-08</date>
// <summary>Contains the class definition for SessionManagementService class.</summary>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionManagementService.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("beedc1ea-8ff8-46e6-a828-ced23a7373a0")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeDispatcher\SystemNudgeDispatcher.cs ===
﻿// <copyright file="SystemNudgeDispatcher.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-18</date>
// <summary>Contains the class definition for SystemNudgeDispatcher class.</summary>

namespace AsyncMultiplayer.SystemNudgeDispatcher
{
    using System;
    using System.Configuration;
    using System.Diagnostics;
    using System.Net;
    using System.Threading;
    using Common.AzureStorage;
    using EventBasedService.Common;
    using GameMetadata.Client;
    using Gds.DataAccess.Rewards;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using SessionAzureStorage;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class dispatches processsing system nudges for a portion of active sessions.
    /// </summary>
    public class SystemNudgeDispatcher : IEventServicePlugin
    {
        /// <summary>
        /// A reference to the parent service.
        /// </summary>
        private IEventService parentService;

        /// <summary>
        /// The event which tells the hosting service that the dispatcher has stopped.
        /// </summary>
        private ManualResetEvent dispatcherStopped;

        /// <summary>
        /// The event which tells the dispatcher that the service hosting it is stopping.
        /// </summary>
        private ManualResetEvent serviceStopping;

        /// <summary>
        /// The thread pool waiter utility object.
        /// </summary>
        private ThreadPoolWait threadPoolWaiter;

        /// <summary>
        /// Gets the componenet name of System nudger dispatcher.
        /// </summary>
        public static string ComponentName
        {
            get;
            private set;
        }

        /// <summary>
        /// Initializes this instance of the SystemNudgeDispatcher class.
        /// </summary>
        /// <param name="parentService">A reference to the parent service.</param>
        /// <param name="stoppingEvent">Event which tells the dispatcher that the service hosting it is stopping.</param>
        /// <param name="doneEvent">Event which tells the hosting service that the dispatcher has stopped.</param>
        /// <param name="description">The description of the plugin. </param>
        /// <param name="componentName">The service component name.</param>
        public void Initialize(IEventService parentService, ManualResetEvent stoppingEvent, ManualResetEvent doneEvent, EventServicePluginDescription description, string componentName)
        {
            this.parentService = parentService;
            this.serviceStopping = stoppingEvent;
            this.dispatcherStopped = doneEvent;
            SystemNudgeDispatcher.ComponentName = componentName;
            this.threadPoolWaiter = new ThreadPoolWait();

            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider(ComponentName, "LEET");

            // Register interfaces required by Rewards.
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            string useFakeClientVal = ConfigurationManager.AppSettings["UseFakeRewardsandGMSClient"];
            if (string.IsNullOrEmpty(useFakeClientVal))
            {
                useFakeClientVal = "false";
            }

            if (Boolean.Parse(useFakeClientVal.Trim().ToLower()))
            {
                Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
                Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
                Container.Instance.AddService<ISubmitGameResult, CSubmitGameResult>();
                Container.Instance.AddService<IIdempotencyFilter, InMemoryBasicIdempotencyFilter>();
            }
            else
            {
                GameMetadataClient.RegisterContainerServices();
                CSubmitGameResult.RegisterInterfaces(Container.Instance);
            }

            // Initialize event system.
            SessionMaintenanceEvents.Initialize(ComponentName);
            SessionServiceEvents.Initialize(ComponentName);

            // Initialize perfcounters
            StorageClientPerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(typeof(StorageClientPerfCounters), ComponentName);
            SystemNudgePerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(typeof(SystemNudgePerfCounters), ComponentName);
        }

        /// <summary>
        /// This is the execution entry point for the dispatcher.
        /// It is designed to be run in it's own thread.
        /// </summary>
        /// <param name="state">The state object passed in, not used in this implementation.</param>
        public void DoWork(object state)
        {
            this.dispatcherStopped.Reset();

            Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Starting System Nudge dispatcher.");

            // We switch this to false because HttpWebRequest does not handle 100-continue header well in a multithreaded scenario.
            // Seeing hangs/deadlocks with it being true.
            ServicePointManager.Expect100Continue = false;

            TimeSpan timeBetweenPasses = new TimeSpan(0, 0, ServiceConfigs.MinutesToWaitBetweenPasses, 0);

            DateTime startingDateTime;
            DateTime endingDateTime;

            while (!this.parentService.IsServiceStopping())
            {
                Stopwatch stopWatch = new Stopwatch();
                try
                {
                    stopWatch.Start();
                    SystemNudgeDispatcher.LogPoolThreadStats("ThreadPool stats before starting a pass ");

                    // Find out what portion of the session index will be processed by
                    // this instance of the system nudge service.
                    SystemNudgeDispatcher.GetProcessingStartAndEndTimes(out startingDateTime, out endingDateTime);

                    DateTime nextDateTime = new DateTime(startingDateTime.Ticks);
                    string nextPartition = nextDateTime.ToString(SessionIndexAzureTableEntity.GetPartitionKeyFormat());
                    while (endingDateTime.CompareTo(nextDateTime) < 0 && !this.parentService.IsServiceStopping())
                    {
                        this.EnqueueForProcessing(nextPartition);
                        nextDateTime = nextDateTime.AddMinutes(-1);
                        nextPartition = nextDateTime.ToString(SessionIndexAzureTableEntity.GetPartitionKeyFormat());

                        // NOTE: Semaphores would be a better option of managing the max number of tasks in the queue (Bug# 3954).
                        // Keep an eye on the maximum number of tasks running and sleep if it is > MaxTasksToEnqueue
                        while (this.threadPoolWaiter.RemainingWorkItems > ServiceConfigs.MaxTasksToEnqueue)
                        {
                            Thread.Sleep(100);
                        }
                    }

                    if (!this.parentService.IsServiceStopping())
                    {
                        SystemNudgeDispatcher.LogPoolThreadStats("ThreadPool stats after a complete pass  ");
                        Logging.TraceInformation(
                            "{0}: {1}",
                            ComponentName,
                            "Sleeping after a complete pass.");
                    }
                    else
                    {
                        SystemNudgeDispatcher.LogPoolThreadStats("ThreadPool stats after a terminated pass");
                        Logging.TraceInformation(
                            "{0}: {1}",
                            ComponentName,
                            "Service stopping, terminating pass.");
                    }
                }
                finally
                {
                    stopWatch.Stop();
                    SystemNudgePerfCounters.Counters.SafeIncrementBy(SystemNudgePerfCounters.SystemNudgeRunDuration, stopWatch.ElapsedTicks);
                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.SystemNudgeRunDurationBase);
                }

                // Sleep until the next pass of processing sessions begins, wake up if "service stopping' event is fired.
                bool awakenedDueToServiceStopping = this.serviceStopping.WaitOne(timeBetweenPasses);

                if (awakenedDueToServiceStopping)
                {
                    SystemNudgeDispatcher.LogPoolThreadStats("ThreadPool stats after a terminated pass");
                    Logging.TraceInformation(
                        "{0}: {1}",
                        ComponentName,
                        "Awakened due to service shutting down, waiting for worker threads to exit");

                    // This will wait till are worker threads are done, any timeouts
                    // should be handled by the dispatcher thread's parent.
                    this.threadPoolWaiter.WaitOne();
                }
                else
                {
                    Logging.TraceInformation(
                        "{0}: {1}",
                        ComponentName,
                        "Awakened at the start of a new pass.");
                }
            }

            Logging.TraceInformation(
                "{0}: {1}",
                ComponentName,
                "Stopping System Nudge dispatcher.");

            // All done
            this.dispatcherStopped.Set();
        }

        /// <summary>
        /// Enqueue system nudge processing of sessions in a partition.
        /// </summary>
        /// <param name="partitionKey">Partition key of the partition to process.</param>
        protected void EnqueueForProcessing(string partitionKey)
        {
            // We should use an approach that uses IO threads rather than
            // worker threads for processing, because most of the processing is IO related.
            // But we cannot since the version of the Azure client library that we use does not support Async access.
            SystemNudgeProcessor processor = new SystemNudgeProcessor(partitionKey, this.threadPoolWaiter, this.parentService);
            this.threadPoolWaiter.QueueWorkItem();
            ThreadPool.QueueUserWorkItem(new WaitCallback(processor.ProcessSessions));
            SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionsEnqueued);
            SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionsEnqueuedPerSecond);
        }

        /// <summary>
        /// Find out what portion of the session index will be processed by
        /// this instance of the system nudge service.
        /// </summary>
        /// <param name="startingDateTime">The DateTime value of the partition that this service instance should start processing.</param>
        /// <param name="endingDateTime">The DateTime value of the last partition that this service instance should process.</param>
        private static void GetProcessingStartAndEndTimes(out DateTime startingDateTime, out DateTime endingDateTime)
        {
            // BUG: The different services instances could run with gaps/overlaps 
            // due to instances hitting this point at different times, thus causing
            // some sessions to be processed twice/not at all during a processing cycle.
            // This is not an issue if one one instance of the service is used.
            DateTime rightNow = DateTime.UtcNow;
            startingDateTime = rightNow.Subtract(new TimeSpan(int.Parse(ServiceConfigs.StartingDay), 0, 0, 0));
            endingDateTime = startingDateTime.AddDays(-1 * int.Parse(ServiceConfigs.DaysToProcess));
        }

        /// <summary>
        /// Log the information about thread pool worker threads.
        /// </summary>
        /// <param name="prefixMessage">Message prefix to be included in the log.</param>
        private static void LogPoolThreadStats(string prefixMessage)
        {
            int maxThreads, maxIOThreads, availableThreads, availableIOThreads, minThreads, minIOThreads;

            ThreadPool.GetMaxThreads(out maxThreads, out maxIOThreads);
            ThreadPool.GetAvailableThreads(out availableThreads, out availableIOThreads);
            ThreadPool.GetMinThreads(out minThreads, out minIOThreads);

            string message = string.Format(
                                    "{0}: MaxThreads: {1}, MinThreads: {2}, AvailableThreads: {3}, ThreadsInUse: {4} AvailableIOThreads: {5}",
                                    prefixMessage, 
                                    maxThreads,
                                    minThreads,
                                    availableThreads,
                                    maxThreads - availableThreads,
                                    availableIOThreads);

            Logging.TraceInformation(
                "{0}: {1}",
                ComponentName,
                message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeDispatcher\ServiceConfigs.cs ===
﻿// <copyright file="ServiceConfigs.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-18</date>
// <summary>Contains the class definition for ServiceConfigs class.</summary>

namespace AsyncMultiplayer.SystemNudgeDispatcher
{
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class ServiceConfigs
    {
        /// <summary>
        /// The interface of the database. 
        /// </summary>
        private const string QueueDatabaseInterface = "lest_AsyncNotification_db"; 

        /// <summary>
        /// Gets the Azure storage account.
        /// </summary>
        public static string AzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SessionFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token.
        /// </summary>
        public static string AzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SessionFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the Azure table storage access endpoint.
        /// </summary>
        public static string AzureTableStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureTableStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure blob storage access endpoint.
        /// </summary>
        public static string AzureBlobStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureBlobStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure queue storage access point.
        /// </summary>
        public static string AzureQueueStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureQueueStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the proxy settings in the configuration.
        /// </summary>
        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }

        /// <summary>
        /// Gets the connection string to notification request queue. 
        /// </summary>
        public static string NotificationRequestQueueConnectionString
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetConnectionString(QueueDatabaseInterface);
            }
        }

        /// <summary>
        /// Gets the starting day for this system nudge service instance in the configuration.
        /// Day 0 is today, day 1 is yesterday etc.
        /// </summary>
        public static string StartingDay
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SystemNudgeService_StartingDay);
            }
        }

        /// <summary>
        /// Gets the days to process for this system nudge service instance in the configuration.
        /// </summary>
        public static string DaysToProcess
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SystemNudgeService_DaysToProcess);
            }
        }

        /// <summary>
        /// Gets the number of minutes to wait before starting a new pass of checking for system nudges.
        /// </summary>
        public static int MinutesToWaitBetweenPasses
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                string minutes = configSettings.GetSetting(Settings.SystemNudgeService_MinutesToWaitBetweenPasses);
                return int.Parse(minutes);
            }
        }

        /// <summary>
        /// Gets the maximum tasks to enqueue.
        /// This number changes the maximum number of partitions that are enqueued for processing at one time.
        /// </summary>
        public static int MaxTasksToEnqueue
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                string maxTasks = configSettings.GetSetting(Settings.SystemNudgeService_MaxTasksToEnqueue);
                return int.Parse(maxTasks);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the nudge service should be run in test mode.
        /// In Test mode InactivityWarning.Interval is interpreted as seconds instead of days.
        /// </summary>
        public static bool RunInTestMode
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetBoolSetting(Settings.SystemNudgeService_RunInTestMode);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionStorage.Test\Properties\AssemblyInfo.cs ===
﻿// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains tassembly information for the SessionStorage.Test assembly.</summary>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionStorage.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5cdb5cb7-260a-4381-9842-ee96930ea8f5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionStorage.Test\SessionStorageTests.cs ===
﻿// <copyright file="SessionStorageTests.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionStorageTests class.</summary>
namespace AsyncMultiplayer.SessionStorage.Test
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using AsyncMultiplayer.SessionCommon;
    using Common.AzureStorage;
    using Common.UnitTestUtilities;
    using GameStateAzureStorage;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using LIVEN.Common.Diagnostics; 
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using NotificationService;
    using SessionAzureStorage;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Tests the ISessionStorage Implementation and SessionAzureGarbageCollector.
    /// </summary>
    [TestClass]
    public class SessionStorageTests
    {
        /// <summary>
        /// Used to store the installation state for perf counters.
        /// </summary>
        private static readonly IDictionary SavedState = new Hashtable();

        /// <summary>
        /// The reference to an implementation of ISessionStorage to be tested.
        /// </summary>
        private readonly ISessionStorage sessionStorage;

        /// <summary>
        /// The reference to SessionAzureGarbageCollector which is to be tested.
        /// </summary>
        private readonly SessionAzureGarbageCollector sessionGarbageCollector;

        /// <summary>
        /// The creation data to be used for creation of test sessions.
        /// </summary>
        private readonly CreationData creationData;

        /// <summary>
        /// The identity of the player1.
        /// </summary>
        private readonly IdentityToken testPlayer1Identity;

        /// <summary>
        /// The identity of player2.
        /// </summary>
        private readonly IdentityToken testPlayer2Identity;

        /// <summary>
        /// The modification data to be used for modifiction of test sessions.
        /// </summary>
        private readonly ModificationData modificationData;

        /// <summary>
        /// Locale to be used for all users.
        /// </summary>
        private readonly string locale;

        /// <summary>
        /// Platform type to be used for all users.
        /// </summary>
        private readonly PlatformType platformType;

        /// <summary>
        /// Number of seconds to wait after a warning to delete.
        /// </summary>
        private const uint SecsToWaitAfterWarning = 10;

        /// <summary>
        /// Maximum sessions allowed to be created per user.
        /// </summary>
        private const int MaxCreateSessionsAllowedPerUser = int.MaxValue;

        /// <summary>
        /// The instance of the tets context used by the test cases in this class.
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        /// Initializes a new instance of the SessionStorageTests class.
        /// </summary>
        public SessionStorageTests()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            StorageAccountInfo account = StorageAccountInfo.GetDefaultTableStorageAccountFromConfiguration();
            this.sessionStorage = new SessionAzureStorage(account);

            // Initialize the garbage collector
            this.sessionGarbageCollector = new SessionAzureGarbageCollector(
                                                    account,
                                                    null,
                                                    new NotificationAzureStorage(),
                                                    new GameStateAzureStorage(StorageAccountInfo.GetDefaultBlobStorageAccountFromConfiguration()),
                                                    SecsToWaitAfterWarning);

            // Initialize creationData
            this.creationData = new CreationData();
            this.creationData.GameID = 7777;
            this.creationData.CanRemoveEmptySeats = true;
            this.creationData.DisplayName = "TestSession";
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.TotalSeatsAvailable = 3;
            this.creationData.SessionParameters = new byte[] { 1, 2, 3 };
            this.creationData.Variant = 0;

            // Initalize testPlayer1Identity
            string token1 = "2600292641994140";
            string publicToken1 = "testPlayer1";
            this.testPlayer1Identity = new IdentityToken(IdentityServiceType.XUID, token1, publicToken1);

            // Initalize testPlayer2Identity
            string token2 = "3600292641994140";
            string publicToken2 = "testPlayer2";
            this.testPlayer2Identity = new IdentityToken(IdentityServiceType.XUID, token2, publicToken2);

            // Initialize modificationData
            this.modificationData = new ModificationData();
            this.modificationData.CanRemoveEmptySeats = false;
            this.modificationData.DisplayName = "Modified Session";
            this.modificationData.InactivityWarning = new InactivityWarningBehavior();
            this.modificationData.InactivityWarning.Action = InactivityWarningAction.None;
            this.modificationData.InactivityWarning.Interval = 30;
            this.modificationData.InactivityWarning.MaxNumberOfNudges = 2;
            this.modificationData.SessionParameters = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            this.modificationData.TotalSeatsAvailable = 5;

            // Initialize locale & platformType
            this.locale = "en-US";
            this.platformType = PlatformType.Mobile;

            // Initialize event system.
            SessionServiceEvents.Initialize("SessionStorageTests");

            // Initialize perfcounters
            StorageClientPerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(
                                                    typeof(StorageClientPerfCounters), "SessionStorageTests");
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        /// <value>The test context.</value>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        /// <summary>
        /// Initilize the test class.
        /// </summary>
        /// <param name="context">The TestContext for this test class.</param>
        [ClassInitialize]
        public static void TestClassInitialize(TestContext context)
        {
            // Install the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Install(typeof(StorageClientPerfCounters).Assembly, SavedState);

            // Register required interfaces
            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider("SessionStorageTests", "LEET");
        }

        /// <summary>
        /// Cleanup after the run.
        /// </summary>
        [ClassCleanup]
        public static void TestClassCleanup()
        {
            // Uninstall the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Uninstall(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Test AddSession.
        /// </summary>
        [TestMethod]
        public void TestAddSession()
        {
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);
            Console.WriteLine("\n Added Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test AddSession when a new user calls it.
        /// </summary>
        [TestMethod]
        public void TestAddSessionNewUser()
        {
            ulong uniqueXuid = (ulong)DateTime.UtcNow.Ticks;
            IdentityToken newUser = new IdentityToken(uniqueXuid, "newUser" + uniqueXuid);
            SessionState sessionState = new SessionState(this.creationData, newUser, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);
            Console.WriteLine("\n Added Session with SessionID: {0} for user: {1}", sessionState.SessionID, newUser.ToString());
        }

        /// <summary>
        /// Test AddSession and hit the maxCreateSessionsAllowedPerUser limit.
        /// </summary>
        [TestMethod]
        public void TestAddSessionHitCreateLimit()
        {
            int lowMaxCreateSessionsAllowedPerUser = 2;
            ulong uniqueXuid = (ulong)DateTime.UtcNow.Ticks;
            IdentityToken newUser = new IdentityToken(uniqueXuid, "newUser" + uniqueXuid);

            SessionState sessionState = new SessionState(this.creationData, newUser, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, lowMaxCreateSessionsAllowedPerUser);

            SessionState sessionState2 = new SessionState(this.creationData, newUser, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState2, lowMaxCreateSessionsAllowedPerUser);

            SessionState sessionState3 = new SessionState(this.creationData, newUser, this.locale, this.platformType);
            UnitTestHelper.TestException(
                delegate { this.sessionStorage.AddSession(sessionState3, lowMaxCreateSessionsAllowedPerUser); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.TooManySessionsCreatedByTheUser));

            Console.WriteLine("\n Hit maxCreateSessionsAllowedPerUser: {0} for user: {1}", lowMaxCreateSessionsAllowedPerUser, newUser.ToString());
        }

        /// <summary>
        /// Test DeleteSession - just warning the active user.
        /// </summary>
        [TestMethod]
        public void TestDeleteSessionWarnActiveUser()
        {
            // First Create a new session and then try to delete it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID.ToString(), joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Simulate a move
            OpaqueSessionStorageObject storageObject;
            this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            ModuleModifiableState modifiableState = new ModuleModifiableState() { ActiveSeatIndex = 1, SequenceNumber = 1, LastModified = DateTime.UtcNow };
            SessionState sessionStateAfterMove = this.sessionStorage.ModifySession(storageObject, modifiableState, this.testPlayer1Identity);

            int warnedSeatIndex;
            SessionState warnedSessionState;

            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionStateAfterMove);
            bool sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntity.PartitionKey, sessionIndexEntity.RowKey, out warnedSeatIndex, out warnedSessionState, true);
            Assert.IsFalse(sessionDeleted, "Session was unexpectedly deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedSeatIndex == 1, "Wrong seat was warned, expected: 1. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);

            Assert.IsTrue(
                warnedSessionState != null,
                "Session state of warned session was null. SessionID: {0} GameID: {1}, warned seat: {2}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex);

            Assert.IsTrue(
                warnedSessionState.SessionID.Equals(sessionState.SessionID),
                "SessionID of warned session was unexpected. ExpectedSessionID: {0} ExpectedGameID: {1}, warned seat: {2} ActualSessionID: {3}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex,
                warnedSessionState.SessionID);

            Assert.IsTrue(
                warnedSessionState.GameID == sessionState.GameID,
                "GameID of warned session was unexpected. SessionID: {0} ExpectedGameID: {1}, warned seat: {2} ActualGameID: {3}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex,
                warnedSessionState.GameID);

            bool warnedPlayerIsCorrect = SessionStorageTests.WasCorrectPlayerWarned(warnedSessionState, warnedSeatIndex, this.testPlayer2Identity);
            Assert.IsTrue(
                warnedPlayerIsCorrect, "Expected player was not warned. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);

            Console.WriteLine("\n Set warned flag for the session with SessionID: {0}, GameID: {1}", sessionState.SessionID, sessionState.GameID);
        }

        /// <summary>
        /// Test DeleteSession - just warning the owner, as there is no active user.
        /// </summary>
        [TestMethod]
        public void TestDeleteSessionWarnOwner()
        {
            // First Create a new session and then try to delete it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            // Make active user as an empty seat.
            OpaqueSessionStorageObject storageObject;
            this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            ModuleModifiableState modifiableState = new ModuleModifiableState() { ActiveSeatIndex = 1, SequenceNumber = 1, LastModified = DateTime.UtcNow };
            SessionState sessionStateAfterMove = this.sessionStorage.ModifySession(storageObject, modifiableState, this.testPlayer1Identity);

            int warnedSeatIndex;
            SessionState warnedSessionState;
            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionStateAfterMove);
            bool sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntity.PartitionKey, sessionIndexEntity.RowKey, out warnedSeatIndex, out warnedSessionState, true);
            Assert.IsFalse(sessionDeleted, "Session was unexpectedly deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedSeatIndex == 0, "Wrong seat was warned, expected: 0. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);

            Assert.IsTrue(
                warnedSessionState != null,
                "Session state of warned session was null. SessionID: {0} GameID: {1}, warned seat: {2}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex);

            Assert.IsTrue(
                warnedSessionState.SessionID.Equals(sessionState.SessionID),
                "SessionID of warned session was unexpected. ExpectedSessionID: {0} ExpectedGameID: {1}, warned seat: {2} ActualSessionID: {3}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex,
                warnedSessionState.SessionID);

            Assert.IsTrue(
                warnedSessionState.GameID == sessionState.GameID,
                "GameID of warned session was unexpected. SessionID: {0} ExpectedGameID: {1}, warned seat: {2} ActualGameID: {3}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex,
                warnedSessionState.GameID);

            bool warnedPlayerIsCorrect = SessionStorageTests.WasCorrectPlayerWarned(warnedSessionState, warnedSeatIndex, this.testPlayer1Identity);
            Assert.IsTrue(
                warnedPlayerIsCorrect, "Expected player was not warned. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);

            Console.WriteLine("\n Set warned flag for the session with SessionID: {0}, GameID: {1}", sessionState.SessionID, sessionState.GameID);
        }

        /// <summary>
        /// Test DeleteSession - just delete it immediately because there is no active user/owner.
        /// </summary>
        [TestMethod]
        public void TestDeleteSessionImmediate()
        {
            // First Create a new session and then try to delete it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            // Leave immediately, so that the session is deleted.
            SeatInfo leavingPlayerSeat;
            bool hasOwnerLeft;
            this.sessionStorage.RemovePlayer(sessionState.SessionID, sessionState.GameID, this.testPlayer1Identity, out leavingPlayerSeat, out hasOwnerLeft);
            Assert.IsTrue(
                leavingPlayerSeat.Index == 0, "Unexpected seat index left, expected value: 0. SessionID: {0} GameID: {1} LeavingSeatIndex: {2}", sessionState.SessionID, sessionState.GameID, leavingPlayerSeat.Index);
            Assert.IsTrue(hasOwnerLeft, "Owner has not left as expected, SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID, leavingPlayerSeat.Index);

            int warnedSeatIndex;
            SessionState warnedSessionState;
            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionState);
            bool sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntity.PartitionKey, sessionIndexEntity.RowKey, out warnedSeatIndex, out warnedSessionState, true);
            Assert.IsTrue(sessionDeleted, "Session was not deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedSeatIndex == -1, "No seat was expected to be warned: 0. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);
            Assert.IsTrue(
                warnedSessionState == null,
                "Session state of warned session was NOT null. SessionID: {0} GameID: {1}, warned seat: {2}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex);

            Console.WriteLine("\n Deleted the session with SessionID: {0}, GameID: {1}", sessionState.SessionID, sessionState.GameID);
        }

        /// <summary>
        /// Test DeleteSession - send a warning and don't delete it in a second pass.
        /// </summary>
        [TestMethod]
        public void TestDeleteSessionWarnButNoDelete()
        {
            // First Create a new session and then try to delete it twice.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID.ToString(), joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Simulate a move
            OpaqueSessionStorageObject storageObject;
            this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            ModuleModifiableState modifiableState = new ModuleModifiableState() { ActiveSeatIndex = 1, SequenceNumber = 1, LastModified = DateTime.UtcNow };
            SessionState sessionStateAfterMove = this.sessionStorage.ModifySession(storageObject, modifiableState, this.testPlayer1Identity);

            int warnedSeatIndex;
            SessionState warnedSessionState;
            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionStateAfterMove);
            bool sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntity.PartitionKey, sessionIndexEntity.RowKey, out warnedSeatIndex, out warnedSessionState, true);
            Assert.IsFalse(sessionDeleted, "Session was unexpectedly deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedSeatIndex == 1, "Wrong seat was warned, expected: 1. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);

            int warnedAgainSeatIndex;
            SessionState warnedAgainSessionState;
            SessionState sessionStateAfterWarn = this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            SessionIndexAzureTableEntity sessionIndexEntityAfterWarn = new SessionIndexAzureTableEntity(sessionStateAfterWarn);
            sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntityAfterWarn.PartitionKey, sessionIndexEntityAfterWarn.RowKey, out warnedAgainSeatIndex, out warnedAgainSessionState, true);
            Assert.IsTrue(!sessionDeleted, "Session was unexpectedly deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedAgainSeatIndex == -1, "A seat was unexpectedly warned. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedAgainSeatIndex);
            Assert.IsTrue(
                warnedAgainSessionState == null,
                "Session state of warned session was NOT null as expected. SessionID: {0} GameID: {1}, warned seat: {2}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedAgainSeatIndex);

            Console.WriteLine("\n Warned but did not delete session with SessionID: {0}, GameID: {1}", sessionState.SessionID, sessionState.GameID);
        }

        /// <summary>
        /// Test DeleteSession - send a warning and delete it in a second pass.
        /// </summary>
        [TestMethod]
        public void TestDeleteSessionAfterWarn()
        {
            // First Create a new session and then try to delete it twice.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID.ToString(), joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Simulate a move
            OpaqueSessionStorageObject storageObject;
            this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            ModuleModifiableState modifiableState = new ModuleModifiableState() { ActiveSeatIndex = 1, SequenceNumber = 1, LastModified = DateTime.UtcNow };
            SessionState sessionStateAfterMove = this.sessionStorage.ModifySession(storageObject, modifiableState, this.testPlayer1Identity);

            int warnedSeatIndex;
            SessionState warnedSessionState;
            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionStateAfterMove);
            bool sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntity.PartitionKey, sessionIndexEntity.RowKey, out warnedSeatIndex, out warnedSessionState, true);
            Assert.IsFalse(sessionDeleted, "Session was unexpectedly deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedSeatIndex == 1, "Wrong seat was warned, expected: 1. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);

            // Sleep so that after the interval, the session can be garbage collected.
            Thread.Sleep(((int)SecsToWaitAfterWarning + 1) * 1000);

            int warnedAgainSeatIndex;
            SessionState warnedAgainSessionState;
            SessionState sessionStateAfterWarn = this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            SessionIndexAzureTableEntity sessionIndexEntityAfterWarn = new SessionIndexAzureTableEntity(sessionStateAfterWarn);
            sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntityAfterWarn.PartitionKey, sessionIndexEntityAfterWarn.RowKey, out warnedAgainSeatIndex, out warnedAgainSessionState, true);
            Assert.IsTrue(sessionDeleted, "Session was NOT deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(
                warnedAgainSeatIndex == -1, "A seat was unexpectedly warned. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedAgainSeatIndex);
            Assert.IsTrue(
                warnedAgainSessionState == null,
                "Session state of warned session was NOT null as expected. SessionID: {0} GameID: {1}, warned seat: {2}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedAgainSeatIndex);

            Console.WriteLine("\n Deleted session with SessionID: {0}, GameID: {1}", sessionState.SessionID, sessionState.GameID);
        }

        /// <summary>
        /// Test DeleteSession - test that a completed session is deleted on first pass.
        /// </summary>
        [TestMethod]
        public void TestDeleteSessionForCompletedSession()
        {
            // First Create a new session and then try to delete it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID.ToString(), joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Simulate game end
            OpaqueSessionStorageObject storageObject;
            this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            ModuleModifiableState modifiableState = new ModuleModifiableState() { ActiveSeatIndex = 1, SequenceNumber = 1, LastModified = DateTime.UtcNow, IsComplete = true };
            SessionState sessionStateAfterMove = this.sessionStorage.ModifySession(storageObject, modifiableState, this.testPlayer1Identity);

            int warnedSeatIndex;
            SessionState warnedSessionState;
            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionStateAfterMove);
            bool sessionDeleted = this.sessionGarbageCollector.DeleteSession(
                sessionState.SessionID, sessionState.GameID, sessionIndexEntity.PartitionKey, sessionIndexEntity.RowKey, out warnedSeatIndex, out warnedSessionState, true);
            Assert.IsTrue(sessionDeleted, "Session was NOT deleted. SessionID: {0} GameID: {1}", sessionState.SessionID, sessionState.GameID);
            Assert.IsTrue(warnedSeatIndex == -1, "A seat was unexpectedly warned. SessionID: {0} GameID: {1}, warned seat: {2}", sessionState.SessionID, sessionState.GameID, warnedSeatIndex);
            Assert.IsTrue(
                warnedSessionState == null,
                "Session state of warned session was NOT null as expected. SessionID: {0} GameID: {1}, warned seat: {2}",
                sessionState.SessionID,
                sessionState.GameID,
                warnedSeatIndex);

            Console.WriteLine("\n Deleted session with SessionID: {0}, GameID: {1}", sessionState.SessionID, sessionState.GameID);
        }

        /// <summary>
        /// Test QuerySession not found.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionNotFound()
        {
            string notPresentSessionID = Guid.NewGuid().ToString();
            SessionState sessionStateQueried;

            // Try to query a session that does not exist.
            UnitTestHelper.TestException(
                delegate
                    {
                        OpaqueSessionStorageObject storageObject;
                        sessionStateQueried = this.sessionStorage.QuerySession(notPresentSessionID, this.creationData.GameID, out storageObject);
                    },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.SessionNotFoundInAzureStore));

            Console.WriteLine("\n As expected the Session was not found.");
        }

        /// <summary>
        /// Test QuerySession.
        /// </summary>
        [TestMethod]
        public void TestQuerySession()
        {
            // First Create a new session and then query it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);
            OpaqueSessionStorageObject storageObject;
            SessionState sessionStateQueried = this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);
            Console.WriteLine("\n SessionState on query has the following SessionID: " + sessionStateQueried.GetHashCode());
        }

        /// <summary>
        /// Test QuerySessions with no parameters.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionsNoParams()
        {
            // First create a new session and then get all sessions for the user.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);
            SessionQueryParameters queryParameters = new SessionQueryParameters();
            SessionEntry[] sessionEntriesQueried = this.sessionStorage.QuerySessions(this.testPlayer1Identity, queryParameters);

            Console.WriteLine("\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            Assert.IsTrue(
                sessionEntriesQueried.Length >= 1, "Unexpected number of SessionEntries retrieved: {0}, should be >= 1.", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine("SessionEntry {0} has SessionID: {1} and GameID: {2}", (i + 1), sessionEntriesQueried[i].SessionID, sessionEntriesQueried[i].GameID);
            }
        }

        /// <summary>
        /// Test QuerySessions with GameID parameter.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionsGameIDParam()
        {
            // First create two sessions, one with a different gameID, then query sessions based on GameID. Only the sessions with specific GameID should be retrieved.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);
            Console.WriteLine("\n Added Session with SessionID: " + sessionState.SessionID);

            CreationData creationDataWithDifferentGameID = new CreationData();
            creationDataWithDifferentGameID.GameID = 1234;
            creationDataWithDifferentGameID.CanRemoveEmptySeats = true;
            creationDataWithDifferentGameID.DisplayName = "Session with a different GameID";
            creationDataWithDifferentGameID.InactivityWarning = new InactivityWarningBehavior();
            creationDataWithDifferentGameID.TotalSeatsAvailable = 3;
            creationDataWithDifferentGameID.SessionParameters = new byte[] { 1, 2, 3 };
            creationDataWithDifferentGameID.Variant = 0;
            SessionState sessionStateDifferentGameID = new SessionState(creationDataWithDifferentGameID, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionStateDifferentGameID, MaxCreateSessionsAllowedPerUser);

            SessionQueryParameters queryParameters = new SessionQueryParameters() { GameID = creationDataWithDifferentGameID.GameID };
            SessionEntry[] sessionEntriesQueried = this.sessionStorage.QuerySessions(this.testPlayer1Identity, queryParameters);

            Console.WriteLine("\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            Assert.IsTrue(
                sessionEntriesQueried.Length >= 1, "Unexpected number of SessionEntries retrieved: {0}, should be >= 1.", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Assert.IsTrue(
                    sessionEntriesQueried[i].GameID == creationDataWithDifferentGameID.GameID,
                    "Retrieved session has an unexpected GameID: " + sessionEntriesQueried[i].GameID);

                Console.WriteLine("SessionEntry {0} has SessionID: {1} and GameID: {2}", (i + 1), sessionEntriesQueried[i].SessionID, sessionEntriesQueried[i].GameID);
            }
        }

        /// <summary>
        /// Test QuerySessions with GameID and Variant parameter.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionsVariantParam()
        {
            // First create 3 sessions, one with a different GameID, one with a different Variant, then query sessions based on GameID and Variant.
            // Only the sessions with specfic GameID & Variant should be retrieved.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            CreationData creationDataWithDifferentGameID = new CreationData();
            creationDataWithDifferentGameID.GameID = 1234;
            creationDataWithDifferentGameID.CanRemoveEmptySeats = true;
            creationDataWithDifferentGameID.DisplayName = "Session with a different GameID";
            creationDataWithDifferentGameID.InactivityWarning = new InactivityWarningBehavior();
            creationDataWithDifferentGameID.TotalSeatsAvailable = 3;
            creationDataWithDifferentGameID.SessionParameters = new byte[] { 1, 2, 3 };
            creationDataWithDifferentGameID.Variant = this.creationData.Variant + 1;
            SessionState sessionStateDifferentGameID = new SessionState(creationDataWithDifferentGameID, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionStateDifferentGameID, MaxCreateSessionsAllowedPerUser);

            CreationData creationDataWithADifferentVariant = new CreationData();
            creationDataWithADifferentVariant.GameID = this.creationData.GameID;
            creationDataWithADifferentVariant.CanRemoveEmptySeats = true;
            creationDataWithADifferentVariant.DisplayName = "Session with a different Variant";
            creationDataWithADifferentVariant.InactivityWarning = new InactivityWarningBehavior();
            creationDataWithADifferentVariant.TotalSeatsAvailable = 3;
            creationDataWithADifferentVariant.SessionParameters = new byte[] { 1, 2, 3 };
            creationDataWithADifferentVariant.Variant = this.creationData.Variant + 1;
            SessionState sessionStateWithADifferentVariant = new SessionState(creationDataWithADifferentVariant, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionStateWithADifferentVariant, MaxCreateSessionsAllowedPerUser);

            SessionQueryParameters queryParameters = new SessionQueryParameters()
                                                         {
                                                             GameID = creationDataWithADifferentVariant.GameID,
                                                             Variant = creationDataWithADifferentVariant.Variant
                                                         };
            SessionEntry[] sessionEntriesQueried = this.sessionStorage.QuerySessions(this.testPlayer1Identity, queryParameters);

            Console.WriteLine("\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            Assert.IsTrue(
                sessionEntriesQueried.Length >= 1, "Unexpected number of SessionEntries retrieved: {0}, should be >= 1.", sessionEntriesQueried.Length);

            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Assert.IsTrue(
                    sessionEntriesQueried[i].GameID == creationDataWithADifferentVariant.GameID,
                    "Retrieved session has an unexpected GameID: " + sessionEntriesQueried[i].GameID);

                Assert.IsTrue(
                    sessionEntriesQueried[i].Variant == creationDataWithADifferentVariant.Variant,
                    "Retrieved session has an unexpected Variant: " + sessionEntriesQueried[i].Variant);

                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2} and Variant: {3}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID,
                    sessionEntriesQueried[i].Variant);
            }
        }

        /// <summary>
        /// Test QuerySessions with ShowSessionType parameter.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionsSessionTypeParam()
        {
            // First create 2 sessions, one active, another inactive, then query sessions based on ShowSessionType.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            SessionState sessionStateInActive = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionStateInActive, MaxCreateSessionsAllowedPerUser);

            // Set the IsComplete flag, making the session inactive.
            ModuleModifiableState moduleModifiableState = new ModuleModifiableState() { IsComplete = true };
            OpaqueSessionStorageObject storageObject;
            this.sessionStorage.QuerySession(sessionStateInActive.SessionID, sessionStateInActive.GameID, out storageObject);
            this.sessionStorage.ModifySession(storageObject, moduleModifiableState, this.testPlayer1Identity);

            SessionQueryParameters queryParameters = new SessionQueryParameters() { ShowSessionType = ShowSessionType.Active };
            SessionEntry[] sessionEntriesQueried = this.sessionStorage.QuerySessions(this.testPlayer1Identity, queryParameters);

            Console.WriteLine("\n\n Number of Active SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            Assert.IsTrue(
                sessionEntriesQueried.Length >= 1, "Unexpected number of Active SessionEntries retrieved: {0}, should be >= 1.", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Assert.IsTrue(!sessionEntriesQueried[i].IsComplete, "Retrieved session is not active, IsComplete is true.");

                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2} and IsComplete: {3}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID,
                    sessionEntriesQueried[i].IsComplete);
            }

            queryParameters = new SessionQueryParameters() { ShowSessionType = ShowSessionType.InActive };
            sessionEntriesQueried = this.sessionStorage.QuerySessions(this.testPlayer1Identity, queryParameters);

            Console.WriteLine("\n\nNumber of InActive SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            Assert.IsTrue(
                sessionEntriesQueried.Length >= 1, "Unexpected number of SessionEntries retrieved: {0}, should be >= 1.", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Assert.IsTrue(sessionEntriesQueried[i].IsComplete, "Retrieved session is active, IsComplete is false.");

                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2} and IsComplete: {3}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID,
                    sessionEntriesQueried[i].IsComplete);
            }
        }

        /// <summary>
        /// Test QuerySessions with LastSessionID parameter.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionsLastSessionIDParam()
        {
            // Create a user that will be used only for this test.
            Random random = new Random();
            ulong newToken = (ulong)random.Next(1, int.MaxValue);
            IdentityToken uniqueTestPlayer = new IdentityToken(IdentityServiceType.XUID, newToken.ToString(), "testPlayerUnique");
            Console.WriteLine("Running test with user: {0}", uniqueTestPlayer.ToString());

            // First create 6 sessions, then query sessions using LastSessionID/GameID and maxSessions.
            SortedList<string, SessionState> sessionStatesSortedBySessionID = new SortedList<string, SessionState>();
            SessionState sessionState1 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState1, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState1.SessionID, sessionState1);

            SessionState sessionState2 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState2, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState2.SessionID, sessionState2);

            SessionState sessionState3 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState3, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState3.SessionID, sessionState3);

            SessionState sessionState4 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState4, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState4.SessionID, sessionState4);

            SessionState sessionState5 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState5, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState5.SessionID, sessionState5);

            SessionState sessionState6 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState6, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState6.SessionID, sessionState6);

            // Get the sorted list of session states.
            IList<SessionState> sortedSessionStates = sessionStatesSortedBySessionID.Values;

            SessionQueryParameters queryParameters = new SessionQueryParameters() { MaxSessions = 3 };
            SessionEntry[] sessionEntriesQueried = this.sessionStorage.QuerySessions(uniqueTestPlayer, queryParameters);

            Assert.IsTrue(
                sessionEntriesQueried.Length == 3, "Retrieved number of SessionEntries are not equal to 3, number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);

            Console.WriteLine("\n\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID);

                if (i == 2)
                {
                    Assert.IsTrue(
                        sessionEntriesQueried[i].SessionID.Equals(sortedSessionStates[2].SessionID) && (sortedSessionStates[2].GameID == sessionState3.GameID),
                        "Last sessionEntry retrieved does not have the expected SessionID: {0} and GameID: {1}, it has instead SessionID: {2} and GameID: {3}",
                        sortedSessionStates[2].SessionID,
                        sortedSessionStates[2].GameID,
                        sessionEntriesQueried[i].SessionID,
                        sessionEntriesQueried[i].GameID);
                }
            }

            queryParameters = new SessionQueryParameters() { GameID = this.creationData.GameID, LastSessionID = sessionEntriesQueried[2].SessionID, MaxSessions = 3 };
            sessionEntriesQueried = this.sessionStorage.QuerySessions(uniqueTestPlayer, queryParameters);

            Assert.IsTrue(
                sessionEntriesQueried.Length == 3, "Retrieved number of SessionEntries are not equal to 3, number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);

            Console.WriteLine("\n\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID);

                if (i == 0)
                {
                    Assert.IsTrue(
                        sessionEntriesQueried[i].SessionID.Equals(sortedSessionStates[3].SessionID) && (sessionEntriesQueried[i].GameID == sortedSessionStates[3].GameID),
                        "First sessionEntry retrieved does not have the expected SessionID: {0} and GameID: {1}, it has instead SessionID: {2} and GameID: {3}",
                        sortedSessionStates[3].SessionID,
                        sortedSessionStates[3].GameID,
                        sessionEntriesQueried[i].SessionID,
                        sessionEntriesQueried[i].GameID);
                }
            }
        }

        /// <summary>
        /// Test QuerySessions with all parameters parameter.
        /// </summary>
        [TestMethod]
        public void TestQuerySessionsAllParam()
        {
            // Create a user that will be used only for this test.
            Random random = new Random();
            ulong newToken = (ulong)random.Next(1, int.MaxValue);
            IdentityToken uniqueTestPlayer = new IdentityToken(IdentityServiceType.XUID, newToken.ToString(), "testPlayerUniqueAllParams");
            Console.WriteLine("Running test with user: {0}", uniqueTestPlayer.ToString());

            // First create 6 sessions, then query sessions using all params.
            SortedList<string, SessionState> sessionStatesSortedBySessionID = new SortedList<string, SessionState>();
            SessionState sessionState1 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState1, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState1.SessionID, sessionState1);

            SessionState sessionState2 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState2, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState2.SessionID, sessionState2);

            SessionState sessionState3 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState3, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState3.SessionID, sessionState3);

            SessionState sessionState4 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState4, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState4.SessionID, sessionState4);

            SessionState sessionState5 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState5, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState5.SessionID, sessionState5);

            SessionState sessionState6 = new SessionState(this.creationData, uniqueTestPlayer, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState6, MaxCreateSessionsAllowedPerUser);
            sessionStatesSortedBySessionID.Add(sessionState6.SessionID, sessionState6);

            // Get the sorted list of session states.
            IList<SessionState> sortedSessionStates = sessionStatesSortedBySessionID.Values;

            SessionQueryParameters queryParameters = new SessionQueryParameters()
                                                         {
                                                             GameID = this.creationData.GameID,
                                                             Variant = this.creationData.Variant,
                                                             ShowSessionType = ShowSessionType.Active,
                                                             MaxSessions = 3
                                                         };
            SessionEntry[] sessionEntriesQueried = this.sessionStorage.QuerySessions(uniqueTestPlayer, queryParameters);

            Assert.IsTrue(
                sessionEntriesQueried.Length == 3, "Retrieved number of SessionEntries are not equal to 3, number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);

            Console.WriteLine("\n\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2} and Variant: {3} and IsComplete: {4}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID,
                    sessionEntriesQueried[i].Variant,
                    sessionEntriesQueried[i].IsComplete);

                Assert.IsTrue(
                    sessionEntriesQueried[i].GameID == this.creationData.GameID,
                    "Unexpected GameID: {0} retrieved, expected value: {1}.",
                    sessionEntriesQueried[i].GameID,
                    this.creationData.GameID);

                Assert.IsTrue(
                    sessionEntriesQueried[i].Variant == this.creationData.Variant,
                    "Unexpected Variant: {0} retrieved, expected value: {1}.",
                    sessionEntriesQueried[i].Variant,
                    this.creationData.Variant);

                Assert.IsTrue(!sessionEntriesQueried[i].IsComplete, "Retrieved session is not active, IsComplete is true.");

                if (i == 2)
                {
                    Assert.IsTrue(
                        sessionEntriesQueried[i].SessionID.Equals(sortedSessionStates[2].SessionID) && (sortedSessionStates[2].GameID == sessionState3.GameID),
                        "Last sessionEntry retrieved does not have the expected SessionID: {0} and GameID: {1}, it has instead SessionID: {2} and GameID: {3}",
                        sortedSessionStates[2].SessionID,
                        sortedSessionStates[2].GameID,
                        sessionEntriesQueried[i].SessionID,
                        sessionEntriesQueried[i].GameID);
                }
            }

            queryParameters = new SessionQueryParameters()
                                    {
                                        GameID = this.creationData.GameID,
                                        Variant = this.creationData.Variant,
                                        ShowSessionType = ShowSessionType.Active,
                                        LastSessionID = sessionEntriesQueried[2].SessionID,
                                        MaxSessions = 3
                                    };
            sessionEntriesQueried = this.sessionStorage.QuerySessions(uniqueTestPlayer, queryParameters);

            Assert.IsTrue(
                sessionEntriesQueried.Length == 3, "Retrieved number of SessionEntries are not equal to 3, number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);

            Console.WriteLine("\n\n Number of SessionEntries retrieved: {0}", sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine(
                    "SessionEntry {0} has SessionID: {1} and GameID: {2} and Variant: {3} and IsComplete: {4}",
                    (i + 1),
                    sessionEntriesQueried[i].SessionID,
                    sessionEntriesQueried[i].GameID,
                    sessionEntriesQueried[i].Variant,
                    sessionEntriesQueried[i].IsComplete);

                Assert.IsTrue(
                    sessionEntriesQueried[i].GameID == this.creationData.GameID,
                    "Unexpected GameID: {0} retrieved, expected value: {1}.",
                    sessionEntriesQueried[i].GameID,
                    this.creationData.GameID);

                Assert.IsTrue(
                    sessionEntriesQueried[i].Variant == this.creationData.Variant,
                    "Unexpected Variant: {0} retrieved, expected value: {1}.",
                    sessionEntriesQueried[i].Variant,
                    this.creationData.Variant);

                Assert.IsTrue(!sessionEntriesQueried[i].IsComplete, "Retrieved session is not active, IsComplete is true.");

                if (i == 0)
                {
                    Assert.IsTrue(
                        sessionEntriesQueried[i].SessionID.Equals(sortedSessionStates[3].SessionID) && (sessionEntriesQueried[i].GameID == sortedSessionStates[3].GameID),
                        "First sessionEntry retrieved does not have the expected SessionID: {0} and GameID: {1}, it has instead SessionID: {2} and GameID: {3}",
                        sortedSessionStates[3].SessionID,
                        sortedSessionStates[3].GameID,
                        sessionEntriesQueried[i].SessionID,
                        sessionEntriesQueried[i].GameID);
                }
            }
        }

        /// <summary>
        /// Test ModifySession.
        /// </summary>
        [TestMethod]
        public void TestModifySession()
        {
            // First Create a new session and then modify it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            SessionState newSessionState = 
                this.sessionStorage.ModifySession(
               sessionState.SessionID,
               sessionState.GameID,
               this.modificationData,
               this.testPlayer1Identity);
            Assert.IsTrue(newSessionState.SeatsAvailable == 5);
            Console.WriteLine("\n Modified Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test ModifySession.
        /// </summary>
        [TestMethod]
        public void TestModifySessionOverload()
        {
            // First create a new session and then modify the game state for that session.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            OpaqueSessionStorageObject storageObject;
            SessionState queriedState = this.sessionStorage.QuerySession(
                sessionStateAfterJoin.SessionID,
                sessionStateAfterJoin.GameID,
                out storageObject);

            DateTime testTime = DateTime.UtcNow.AddDays(10);
            ModuleModifiableState moduleModifiableState = new ModuleModifiableState();
            moduleModifiableState.ActiveSeatIndex = 1;
            moduleModifiableState.IsClosed = true;
            moduleModifiableState.IsComplete = true;
            moduleModifiableState.LastModified = testTime;
            moduleModifiableState.OwnerSeatIndex = 1;
            moduleModifiableState.SequenceNumber = 1000;
            
            // Set the nudges and warnings.
            moduleModifiableState.IsInactivityWarningSent = true;
            moduleModifiableState.NumberOfNudgesSent = 1;

            SessionState newSessionState = this.sessionStorage.ModifySession(storageObject, moduleModifiableState, this.testPlayer1Identity);

            Assert.IsTrue(
                newSessionState.State.ActiveSeatIndex == 1,
                "Session with SessionID: " + newSessionState.SessionID + " does not have the expected active user.");

            Assert.IsTrue(
                newSessionState.IsClosed == true,
                "Session with SessionID " + newSessionState.SessionID + " is not 'Closed' as expected.");

            Assert.IsTrue(
                newSessionState.State.IsComplete == true,
                "Session with SessionID " + newSessionState.SessionID + " is not 'Complete' as expected.");

            Assert.IsTrue(
                DateTime.Equals(newSessionState.State.LastModified.Date, testTime.Date),
                "Session with SessionID " + newSessionState.SessionID + " has unexpected last modified datetime.");

            Assert.IsTrue(
                newSessionState.OwnerSeatIndex == 1,
                "Session with SessionID " + newSessionState.SessionID + " has unexpected owner.");

            Assert.IsTrue(
                newSessionState.State.SequenceNumber == 1000,
                "Session with SessionID " + newSessionState.SessionID + " has unexpected sequence number.");

            Assert.IsTrue(
                newSessionState.IsInactivityWarningSent,
                "Session with SessionID " + newSessionState.SessionID + " has unexpected IsInactivityWarningSent flag.");

             Assert.IsTrue(
                newSessionState.NumberOfNudgesSent == 1,
                "Session with SessionID " + newSessionState.SessionID + " has unexpected number of nudges.");

            Console.WriteLine("\n Modified GameState of the Session with SessionID: " + newSessionState.SessionID);
        }

        /// <summary>
        /// Test ModifySession.
        /// </summary>
        [TestMethod]
        public void TestModifySessionNudges()
        {
            // First create a new session and then modify the session state for that session.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            this.sessionStorage.ModifySession(sessionState.SessionID, this.creationData.GameID, true);

            OpaqueSessionStorageObject storageObject;
            SessionState newSessionState = this.sessionStorage.QuerySession(
                sessionState.SessionID,
                this.creationData.GameID,
                out storageObject);

            Assert.IsTrue(
                newSessionState.NumberOfNudgesSent == 1,
                "Session with SessionID: " + newSessionState.SessionID + " does not have the expected number of nudges.");

            Console.WriteLine("\n Modified GameState of the Session with SessionID: " + newSessionState.SessionID);
        }

        /// <summary>
        /// Test AddPlayer.
        /// </summary>
        [TestMethod]
        public void TestAddPlayer()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID.ToString(), joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);
            Console.WriteLine("\n Added Player sucessfully to Session with SessionID: " + sessionStateAfterJoin.SessionID);
        }

        /// <summary>
        /// Test AddPlayer, adding player again scenario.
        /// </summary>
        [TestMethod]
        public void TestAddPlayerAgain()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);

            SessionState sessionStateAfterSecondJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterSecondJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterSecondJoin.Seats.Length == 2);

            Console.WriteLine("\n Added Player again successfully to Session with SessionID: " + sessionStateAfterSecondJoin.SessionID);
        }

        /// <summary>
        /// Test RemovePlayer.
        /// </summary>
        [TestMethod]
        public void TestRemovePlayer()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = new SessionState(this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionStorage.AddSession(sessionState, MaxCreateSessionsAllowedPerUser);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionStorage.AddPlayer(sessionState.SessionID.ToString(), joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);

            // Now Remove the just added player.
            SeatInfo leavingPlayerSeat;
            bool ownerLeft;
            this.sessionStorage.RemovePlayer(sessionState.SessionID, sessionState.GameID, this.testPlayer2Identity, out leavingPlayerSeat, out ownerLeft);
            Assert.IsTrue(leavingPlayerSeat.Index == 1);
            Assert.IsFalse(ownerLeft);

            OpaqueSessionStorageObject storageObject;
            SessionState sessionStateAfterRemove =
                this.sessionStorage.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);

            Console.WriteLine("\n Number of players after removing a player to the session is " +
                sessionStateAfterRemove.Seats.Length + " and expected is 1.");
            Assert.IsTrue(sessionStateAfterRemove.Seats.Length == 1);

            Console.WriteLine("\n Removed Player sucessfully from Session with SessionID: " + sessionStateAfterRemove.SessionID);
        }

        /// <summary>
        /// Was the correct player warned?
        /// </summary>
        /// <param name="warnedSessionState">The session state of the warned session.</param>
        /// <param name="warnedSeatIndex">The seat that was warned.</param>
        /// <param name="expectedPlayerIdentity">The expected identity of the player.</param>
        /// <returns>Whether the correct player was warned.</returns>
        private static bool WasCorrectPlayerWarned(SessionState warnedSessionState, int warnedSeatIndex, IdentityToken expectedPlayerIdentity)
        {
            bool warnedPlayerIsCorrect = false;
            foreach (var seat in warnedSessionState.Seats)
            {
                if (seat.Index == warnedSeatIndex)
                {
                    if (seat.Profile.Equals(expectedPlayerIdentity))
                    {
                        warnedPlayerIsCorrect = true;
                    }

                    break;
                }
            }

            return warnedPlayerIsCorrect;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService.Test\SessionManagementServiceTests.cs ===
﻿// <copyright file="SessionManagementServiceTests.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-08</date>
// <summary>Contains the class definition for SessionManagementServiceTests class.</summary>
namespace AsyncMultiplayer.SessionManagementServiceTests.Test
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Text;
    using System.Xml.Serialization;
    using AsyncMultiplayer.SessionCommon;
    using AsyncMultiplayer.SessionManagementService;
    using Common.AzureStorage;
    using Common.UnitTestUtilities;
    using GameMetadata.Client;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Profile;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using NotificationService;
    using SessionAzureStorage;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Tests the SessionManagementService.
    /// </summary>
    [TestClass]
    public class SessionManagementServiceTests
    {
        /// <summary>
        /// Used to store the installation state for perf counters.
        /// </summary>
        private static readonly IDictionary SavedState = new Hashtable();

        /// <summary>
        /// The session management class to be tested.
        /// </summary>
        private readonly SessionManagementService sessionService;

        /// <summary>
        /// The game state class to be tested.
        /// </summary>
        private readonly GameStateService gameStateService;

        /// <summary>
        /// The gameID to be used for creation of test sessions.
        /// </summary>
        private readonly string gameID;

        /// <summary>
        /// The creation data to be used for creation of test sessions.
        /// </summary>
        private readonly CreationData creationData;

        /// <summary>
        /// The identity of the player1.
        /// </summary>
        private readonly IdentityToken testPlayer1Identity;

        /// <summary>
        /// The identity of player2.
        /// </summary>
        private readonly IdentityToken testPlayer2Identity;

        /// <summary>
        /// The identity of player3.
        /// </summary>
        private readonly IdentityToken testPlayer3Identity;

        /// <summary>
        /// The modification data to be used for modifiction of test sessions.
        /// </summary>
        private readonly ModificationData modificationData;

        /// <summary>
        /// Locale to be used for all users.
        /// </summary>
        private readonly string locale;

        /// <summary>
        /// Platform type to be used for all users.
        /// </summary>
        private readonly PlatformType platformType;

        /// <summary>
        /// The instance of the tets context used by the test cases in this class.
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        /// Initializes a new instance of the SessionManagementServiceTests class.
        /// </summary>
        public SessionManagementServiceTests()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            ServiceConfigs.Initialize();

            // Register Fake IGameMetadataService.
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();

            // Register Fake IProfileProvider.
            Container.Instance.AddService<IProfileProvider, FakeProfileProvider>();

            // Register interfaces used by rewards.
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
            Container.Instance.AddService<ISubmitGameResult, CSubmitGameResult>();
            Container.Instance.AddService<IIdempotencyFilter, InMemoryBasicIdempotencyFilter>();

            this.sessionService = new SessionManagementService();
            this.gameID = "7777";

            // Initialize creationData
            this.creationData = new CreationData();
            this.creationData.GameID = UInt32.Parse(this.gameID);
            this.creationData.CanRemoveEmptySeats = true;
            this.creationData.DisplayName = "TestSession";
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.TotalSeatsAvailable = 3;
            this.creationData.SessionParameters = new byte[] { 1, 2, 3 };
            this.creationData.Variant = 0;
            this.creationData.LeavePolicy = SessionLeavePolicy.LeavingUserLoses;

            // Initalize testPlayer1Identity
            ulong xuid1 = 2600292642023854;
            string gamerTag1 = "testPlayer1";
            this.testPlayer1Identity = new IdentityToken(xuid1, gamerTag1);

            // Initalize testPlayer2Identity
            ulong xuid2 = 3600292642023854;
            string gamerTag2 = "testPlayer2";
            this.testPlayer2Identity = new IdentityToken(xuid2, gamerTag2);

            // Initalize testPlayer2Identity
            ulong xuid3 = 3600292642023851;
            string gamerTag3 = "testPlayer3";
            this.testPlayer3Identity = new IdentityToken(xuid3, gamerTag3);

            // Initialize locale & platformType
            this.locale = "en-US";
            this.platformType = PlatformType.Mobile;

            // Initialize modificationData
            this.modificationData = new ModificationData();
            this.modificationData.CanRemoveEmptySeats = false;
            this.modificationData.DisplayName = "Modified Session";
            this.modificationData.InactivityWarning = new InactivityWarningBehavior();
            this.modificationData.InactivityWarning.Action = InactivityWarningAction.None;
            this.modificationData.InactivityWarning.Interval = 30;
            this.modificationData.InactivityWarning.MaxNumberOfNudges = 2;
            this.modificationData.SessionParameters = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            this.modificationData.TotalSeatsAvailable = 5;

            this.gameStateService = new GameStateService();

            // Initialize event system.
            SessionServiceEvents.Initialize("SessionManagementServiceTests");
            SessionMaintenanceEvents.Initialize("SessionManagementServiceTests");

            // Initialize perfcounters
            StorageClientPerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(
                                                    typeof(StorageClientPerfCounters), "SessionManagementServiceTests");
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        /// <value>The test context.</value>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        /// <summary>
        /// Initilize the test class.
        /// </summary>
        /// <param name="context">The TestContext for this test class.</param>
        [ClassInitialize]
        public static void TestClassInitialize(TestContext context)
        {
            // Install the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Install(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Cleanup after the run.
        /// </summary>
        [ClassCleanup]
        public static void TestClassCleanup()
        {
            // Uninstall the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Uninstall(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Gets the last modified DateTime and last modified by SeatInfo for a session.
        /// </summary>
        /// <param name="player">The user for which to get the data.</param>
        /// <param name="sessionID">The session for which to get the data.</param>
        /// <param name="gameID">The game for which to get the data.</param>
        /// <param name="lastModified">When was the session last modified?</param>
        /// <param name="lastModifiedBy">Who was the last seat to modify the session?</param>
        /// <param name="sessionService">The instance of the session service to use.</param>
        /// <returns>The session entry for the session.</returns>
        public static SessionEntry GetLastModifiedDataForSession(
            IdentityToken player, string sessionID, uint gameID, out DateTime lastModified, out SeatInfo lastModifiedBy, SessionManagementService sessionService)
        {
            const int MaxSessions = SessionManagementService.MaxSessionsLimit;
            lastModified = DateTime.MinValue;
            lastModifiedBy = null;
            SessionEntry sessionEntry = null;

            bool sessionFound = false;
            bool sessionsRemaining = true;
            while (sessionFound == false && sessionsRemaining)
            {
                SessionEntry[] sessionEntries = sessionService.ViewSessionSummariesInternal(
                    player, null, null, null, MaxSessions.ToString(), null);

                if (sessionEntries.Length < MaxSessions)
                {
                    sessionsRemaining = false;
                }

                foreach (var entry in sessionEntries)
                {
                    if (entry.SessionID.Equals(sessionID) && entry.GameID == gameID)
                    {
                        lastModified = entry.LastModified;
                        lastModifiedBy = entry.LastModifiedBy;
                        sessionFound = true;
                        sessionEntry = entry;
                        break;
                    }
                }
            }

            Assert.IsTrue(
                sessionFound,
                "Could not find a session with sessionID: {0}, gameID: {1} for user: {2}",
                sessionID,
                gameID.ToString(),
                player.ToString());

            return sessionEntry;
        }

        /// <summary>
        /// Test CreateSession.
        /// </summary>
        [TestMethod]
        public void TestCreateSession()
        {
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            FullGameState fullGameState = this.gameStateService.GetGameStateInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity);

            Assert.IsTrue(fullGameState.GameData != null, "The game state data for the newly created session is null");

            Assert.IsTrue(
                this.creationData.SessionParameters.Length == fullGameState.GameData.Length,
                "The game state data for the newly created session has different size than SessionParameters");

            bool areSessionParamsAndGameDataIdentical = true;
            for (int i = 0; i < this.creationData.SessionParameters.Length; i++)
            {
                if (this.creationData.SessionParameters[i] != fullGameState.GameData[i])
                {
                    areSessionParamsAndGameDataIdentical = false;
                    break;
                }
            }

            Assert.IsTrue(areSessionParamsAndGameDataIdentical, "SessionParameters set and the initial game data are not identical");

            Console.WriteLine("\n Added Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test CreateSession with no SessionParameters.
        /// </summary>
        [TestMethod]
        public void TestCreateSessionNoSessionParameters()
        {
            CreationData creationDataWithNoSessionParameters = new CreationData();
            creationDataWithNoSessionParameters.GameID = UInt32.Parse(this.gameID);
            creationDataWithNoSessionParameters.CanRemoveEmptySeats = true;
            creationDataWithNoSessionParameters.DisplayName = "TestSessionWithNoSessionParameters";
            creationDataWithNoSessionParameters.InactivityWarning = new InactivityWarningBehavior();
            creationDataWithNoSessionParameters.TotalSeatsAvailable = 3;
            creationDataWithNoSessionParameters.SessionParameters = null;
            creationDataWithNoSessionParameters.Variant = 0;

            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, creationDataWithNoSessionParameters, this.testPlayer1Identity, this.locale, this.platformType);

            FullGameState fullGameState = this.gameStateService.GetGameStateInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity);

            Assert.IsTrue(fullGameState.GameData != null, "The game state data for the newly created session is null");

            Assert.IsTrue(
                fullGameState.GameData.Length == 0,
                "The game state data for the newly created session has non-zero length");

            Console.WriteLine("\n Added Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test ViewSession.
        /// </summary>
        [TestMethod]
        public void TestViewSession()
        {
            // First Create a new session and then query it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            SessionState sessionStateQueried = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, this.gameID, this.testPlayer1Identity, true, this.locale);

            Assert.IsTrue(sessionStateQueried.ActorSeat.HasValue, "ActorSeat is not set.");
            Assert.IsTrue(sessionStateQueried.ActorSeat == 0, "Actor seat should be zero.");
            Assert.IsTrue(
                sessionStateQueried.Seats[0].Profile.PublicToken.Equals(this.testPlayer1Identity.PublicToken),
                "Identities in SeatInfo are not the same.");
            Console.WriteLine("\n SessionState on query have the following SessionID: " + sessionStateQueried.GetHashCode());
        }

        /// <summary>
        /// Test ViewSession on a completed session.
        /// </summary>
        [TestMethod]
        public void TestViewSessionCompleted()
        {
            // First create a new session
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = sessionState.GameID;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            // Add more players to the session.
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Check the notifications cleaned flag before the session is complete.
            SessionState sessionStatePreCompleted = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, this.gameID, this.testPlayer1Identity, true, this.locale);

            foreach (var seat in sessionStatePreCompleted.Seats)
            {
                Assert.IsFalse(seat.NotificationsCleaned, "Player: " + seat.Profile.PublicToken + " notifications are already marked as deleted!");
            }

            GameResults gameResults = new GameResults
            {
                WinningSeatIndexes = new int[] { 0, 1, 2 },
                LosingSeatIndexes = new int[] { 3, 4, 5 },
                TierSeatIndexes = new int[] { 6, 7 },
                GameOverSeatIndexes = new int[] { 8 },
                Results = new Dictionary<int, GameResult>()
            };

            // Populate GameResult for all players.
            gameResults.Results[0] = new GameResult()
            {
                GameId = uint.Parse(this.gameID),
                GameResultId = Guid.NewGuid(),
                Outcome = GameResultOutcome.Win.ToString(),
                Score = 10,
                Time = 5,
                TimeStamp = DateTime.UtcNow,
                Variant = (uint)this.creationData.Variant
            };
            gameResults.Results[1] = new GameResult()
            {
                GameId = uint.Parse(this.gameID),
                GameResultId = Guid.NewGuid(),
                Outcome = GameResultOutcome.Loss.ToString(),
                Score = 3,
                Time = 1,
                TimeStamp = DateTime.UtcNow,
                Variant = (uint)this.creationData.Variant
            };

            // Fire a GameEnd.
            this.gameStateService.PostGameEndInternal(sessionState.SessionID, sessionState.GameID.ToString(), gameResults, this.testPlayer1Identity, string.Empty);

            // Check the notifications cleaned flag after the session is complete.
            SessionState sessionStateCompleted = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, this.gameID, this.testPlayer1Identity, false, this.locale);

            foreach (var seat in sessionStateCompleted.Seats)
            {
                if (seat.Profile.Equals(this.testPlayer1Identity))
                {
                    Assert.IsTrue(seat.NotificationsCleaned, "Player: " + seat.Profile.PublicToken + " notifications are not marked as deleted!");
                }
                else
                {
                    Assert.IsFalse(seat.NotificationsCleaned, "Player: " + seat.Profile.PublicToken + " notifications are marked as deleted!");
                }
            }
        }

        /// <summary>
        /// Test GetGameState forbidden.
        /// </summary>
        [TestMethod]
        public void TestViewSessionForbidden()
        {
            // First create a new session and then view it using a different user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Try to view session with a user who is not in the session.
            UnitTestHelper.TestException(
                delegate
                {
                    this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity, true, this.locale);
                },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.UserNotAllowedToGetStateInSession));

            Console.WriteLine("\n As expected, forbidden from viewing Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test ViewSession with identities non-obfuscated.
        /// </summary>
        [TestMethod]
        public void TestViewSessionNonObfuscated()
        {
            // First Create a new session and then query it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            SessionState sessionStateQueried = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, this.gameID, this.testPlayer1Identity, false, this.locale);

            Assert.IsTrue(sessionStateQueried.ActorSeat.HasValue, "ActorSeat is not set.");
            Assert.IsTrue(sessionStateQueried.ActorSeat == 0, "Actor seat should be zero.");
            Assert.IsTrue(sessionStateQueried.Seats[0].Profile.Equals(this.testPlayer1Identity), "Identities in SeatInfo are not the same.");
            Console.WriteLine("\n SessionState on query have the following SessionID: " + sessionStateQueried.GetHashCode());
        }

        /// <summary>
        /// Test ViewSessionSummaries.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummaries()
        {
            // First Create a new session and then query all sessions for the user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            SessionEntry[] sessionEntriesQueried = this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, sessionState.GameID.ToString(), null, null, null, null);

            Console.WriteLine("\n Number of SessionEntries retrieved: " + sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine("SessionEntry " + (i + 1) + " has SessionID: " + sessionEntriesQueried[i].SessionID);
            }
        }

        /// <summary>
        /// Test ViewSessionSummaries with gameID and sessionType.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesGameIDAndSessionType()
        {
            // First create a 2 sessions and set one of the sessions as completed.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionToBeCompleted = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            GameResults gameResults = new GameResults();
            this.gameStateService.PostGameEndInternal(sessionToBeCompleted.SessionID, sessionToBeCompleted.GameID.ToString(), gameResults, this.testPlayer1Identity, string.Empty);

            SessionEntry[] sessionEntriesQueried = this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, this.gameID, null, null, null, "Active");

            Console.WriteLine("\n Number of SessionEntries retrieved: " + sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine("SessionEntry " + (i + 1) + " has SessionID: " + sessionEntriesQueried[i].SessionID);
                Assert.IsFalse(sessionEntriesQueried[i].IsComplete, "Session retrieved is NOT active, SessionID:" + sessionEntriesQueried[i].SessionID);
            }
        }

        /// <summary>
        /// Test ViewSessionSummaries with gameID, variant and sessionType.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesGameIDVariantAndSessionType()
        {
            // First create 3 sessions with one having a different variant and set one of the sessions as completed.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionToBeCompleted = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            GameResults gameResults = new GameResults();
            this.gameStateService.PostGameEndInternal(sessionToBeCompleted.SessionID, sessionToBeCompleted.GameID.ToString(), gameResults, this.testPlayer1Identity, string.Empty);

            CreationData creationDataWithDifferentVariant = new CreationData();
            creationDataWithDifferentVariant.GameID = UInt32.Parse(this.gameID);
            creationDataWithDifferentVariant.CanRemoveEmptySeats = true;
            creationDataWithDifferentVariant.InactivityWarning = new InactivityWarningBehavior();
            creationDataWithDifferentVariant.TotalSeatsAvailable = 3;
            creationDataWithDifferentVariant.SessionParameters = null;
            creationDataWithDifferentVariant.Variant = this.creationData.Variant + 1;

            SessionState sessionWithADifferentVariant = this.sessionService.CreateSessionInternal(
                this.gameID, creationDataWithDifferentVariant, this.testPlayer1Identity, this.locale, this.platformType);

            SessionEntry[] sessionEntriesQueried = this.sessionService.ViewSessionSummariesInternal(
                this.testPlayer1Identity, this.gameID, creationDataWithDifferentVariant.Variant.ToString(), null, null, "Active");

            Console.WriteLine("\n Number of SessionEntries retrieved: " + sessionEntriesQueried.Length);
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine("SessionEntry " + (i + 1) + " has SessionID: " + sessionEntriesQueried[i].SessionID);
                Assert.IsTrue(sessionEntriesQueried[i].Variant == creationDataWithDifferentVariant.Variant, "Session retrieved does not have the expected variant, SessionID:" + sessionEntriesQueried[i].SessionID + " variant: " + sessionEntriesQueried[i].Variant);
                Assert.IsFalse(sessionEntriesQueried[i].IsComplete, "Session retrieved is NOT active, SessionID:" + sessionEntriesQueried[i].SessionID);
            }
        }

        /// <summary>
        /// Test ViewSessionSummaries using maxSessions parameter.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesMaxSessionsParam()
        {
            // First create 3 sessions with one having a different variant and set one of the sessions as completed.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState2 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState3 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState4 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState5 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionEntry[] sessionEntriesQueried = this.sessionService.ViewSessionSummariesInternal(
                this.testPlayer1Identity, this.gameID, null, null, "3", "Active");

            Assert.IsTrue(sessionEntriesQueried.Length == 3);

            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine("SessionEntry " + (i + 1) + " has SessionID: " + sessionEntriesQueried[i].SessionID);
                Assert.IsFalse(sessionEntriesQueried[i].IsComplete, "Session retrieved is NOT active, SessionID:" + sessionEntriesQueried[i].SessionID);
            }
        }

        /// <summary>
        /// Test ViewSessionSummaries using lastSessionID and maxSessions parameters.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesLastSessionIDMaxSessionsParam()
        {
            // First create 3 sessions with one having a different variant and set one of the sessions as completed.
            SessionState sessionState1 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState2 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState3 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState4 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionState sessionState5 = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            SessionEntry[] sessionEntriesQueried = this.sessionService.ViewSessionSummariesInternal(
                this.testPlayer1Identity, this.gameID, null, null, "3", "Active");

            Assert.IsTrue(sessionEntriesQueried.Length == 3);

            string lastSessionID = null;
            string lastGameID = null;
            for (int i = 0; i < sessionEntriesQueried.Length; i++)
            {
                Console.WriteLine("SessionEntry " + (i + 1) + " has SessionID: " + sessionEntriesQueried[i].SessionID);
                Assert.IsFalse(sessionEntriesQueried[i].IsComplete, "Session retrieved is NOT active, SessionID:" + sessionEntriesQueried[i].SessionID);

                if (i == sessionEntriesQueried.Length - 1)
                {
                    lastSessionID = sessionEntriesQueried[i].SessionID;
                    lastGameID = sessionEntriesQueried[i].GameID.ToString();
                }
            }

            SessionEntry[] sessionEntriesQueriedAgain = this.sessionService.ViewSessionSummariesInternal(
                this.testPlayer1Identity, this.gameID, null, lastSessionID, "2", "Active");

            Assert.IsTrue(sessionEntriesQueriedAgain.Length == 2);

            for (int i = 0; i < sessionEntriesQueriedAgain.Length; i++)
            {
                Console.WriteLine("SessionEntry " + (i + 1) + " has SessionID: " + sessionEntriesQueriedAgain[i].SessionID);
                Assert.IsTrue(sessionEntriesQueriedAgain[i].GameID >= uint.Parse(lastGameID), "GameID of retrieved session is not >= lastGameID, SessionID:" + sessionEntriesQueriedAgain[i].SessionID);
                Assert.IsTrue(sessionEntriesQueriedAgain[i].SessionID.CompareTo(lastSessionID) >= 0, "SessionID of retrieved session is not >= lastSessionID, SessionID:" + sessionEntriesQueriedAgain[i].SessionID);
                Assert.IsFalse(sessionEntriesQueriedAgain[i].IsComplete, "Session retrieved is NOT active, SessionID:" + sessionEntriesQueriedAgain[i].SessionID);
            }
        }

        /// <summary>
        /// Test ViewSessionSummaries with bad maxSessions parameters.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesBadMaxSessionsParam()
        {
            // First Create a new session and then query sessions with an invalid GameID for the user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Try to query the session with invalid maxSessions.
            UnitTestHelper.TestException(
                delegate { this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, this.creationData.GameID.ToString(), null, null, "BadMaxSessions", null); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.InvalidMaxSessionsParam));

            UnitTestHelper.TestException(
                delegate { this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, this.creationData.GameID.ToString(), null, null, (SessionManagementService.MaxSessionsLimit + 1).ToString(), null); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.InvalidMaxSessionsParam));

            UnitTestHelper.TestException(
                delegate { this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, this.creationData.GameID.ToString(), null, null, "0", null); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.InvalidMaxSessionsParam));

            Console.WriteLine("\n As expected, could not query with an invalid maxSessions.");
        }

        /// <summary>
        /// Test ViewSessionSummaries with a bad GameID parameters.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesBadGameIDParam()
        {
            // First Create a new session and then query sessions with an invalid GameID for the user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Try to query the session with invalid gameID.
            UnitTestHelper.TestException(
                delegate { this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, "InvalidGameID", null, null, null, null); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.InvalidGameIDFormatOnValidateQueryParams));

            Console.WriteLine("\n As expected, could not query with an invalid GameID.");
        }

        /// <summary>
        /// Test ViewSessionSummaries with a bad Variant parameters.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesBadVariantParam()
        {
            // First Create a new session and then query sessions with an invalid variant for the user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Try to query the session with invalid variant.
            UnitTestHelper.TestException(
                delegate { this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, this.creationData.GameID.ToString(), "InvalidVariant", null, null, null); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.InvalidVariantFormatOnValidateQueryParams));

            Console.WriteLine("\n As expected, could not query with an invalid variant.");
        }

        /// <summary>
        /// Test ViewSessionSummaries with Variant but no GameID parameters.
        /// </summary>
        [TestMethod]
        public void TestViewSessionSummariesWithVariantNoGameIDParam()
        {
            // First Create a new session and then query sessions with an invalid combination of parameters for the user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Try to query the session with Variant but no GameID.
            UnitTestHelper.TestException(
                delegate { this.sessionService.ViewSessionSummariesInternal(this.testPlayer1Identity, null, this.creationData.Variant.ToString(), null, null, null); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.VariantCanBeSpecifiedOnlyIfGameIDIsSpecified));

            Console.WriteLine("\n As expected, could not query with only Variant and without a GameID.");
        }

        /// <summary>
        /// Test ModifySession.
        /// </summary>
        [TestMethod]
        public void TestModifySession()
        {
            // First Create a new session and then modify it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            this.sessionService.ModifySessionInternal(
               sessionState.SessionID,
               sessionState.GameID.ToString(),
               this.modificationData,
               this.testPlayer1Identity);

            Console.WriteLine("\n Modified Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test JoinSession.
        /// </summary>
        [TestMethod]
        public void TestJoinSession()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            DateTime lastModified;
            SeatInfo lastModifiedBy;
            SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModified, out lastModifiedBy, this.sessionService);
            Assert.IsTrue(lastModifiedBy.Index == 0, "Session was not last modified by seat index 0 as expected");

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);
            Console.WriteLine("\n Added Player sucessfully to Session with SessionID: " + sessionStateAfterJoin.SessionID);
        }

        /// <summary>
        /// Test JoinSession again.
        /// </summary>
        [TestMethod]
        public void TestJoinSessionAgain()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            DateTime lastModified;
            SeatInfo lastModifiedBy;
            SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModified, out lastModifiedBy, this.sessionService);
            Assert.IsTrue(lastModifiedBy.Index == 0, "Session was not last modified by seat index 0 as expected");

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);

            SessionState sessionStateAfterSecondJoin =
                    this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterSecondJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterSecondJoin.Seats.Length == 2);

            Console.WriteLine("\n Added Player again successfully to Session with SessionID: " + sessionStateAfterSecondJoin.SessionID);
        }

        /// <summary>
        /// Test JoinSession when the session is empty.
        /// </summary>
        [TestMethod]
        public void TestJoinSessionEmpty()
        {
            // Create a session and immediately leave.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);
            SessionState sessionStateAfterJoin = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, joinData.GameID.ToString(), this.testPlayer2Identity, false, this.locale);

            // Verify that player 2 is now the owner of the session.
            SeatInfo ownerSeat = null;
            foreach (SeatInfo seat in sessionStateAfterJoin.Seats)
            {
                if (seat.Index == sessionStateAfterJoin.OwnerSeatIndex)
                {
                    ownerSeat = seat;
                    break;
                }
            }

            Assert.IsTrue(ownerSeat != null, "There is no owner for the session, SessionID:", sessionStateAfterJoin.SessionID);
            Assert.IsTrue(ownerSeat.Profile.Equals(this.testPlayer2Identity), "Player 2 is not the new owner of the session, SessionID:", sessionStateAfterJoin.SessionID);

            Console.WriteLine("\n Added Player successfully to Session with SessionID: " + sessionStateAfterJoin.SessionID);
        }

        /// <summary>
        /// Test JoinSession when the session is full.
        /// </summary>
        [TestMethod]
        public void TestJoinSessionFull()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            joinData.SeatIndex = 2;
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer3Identity, this.locale, this.platformType);

            joinData.SeatIndex = 0;

            // Try join a full session.
            UnitTestHelper.TestException(
                delegate { this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, new IdentityToken(4, "test4"), this.locale, this.platformType); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.NoMoreSeatsInSession));

            Console.WriteLine("\n As expected, could not join a full session: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test RejectInvitation.
        /// </summary>
        [TestMethod]
        public void TestRejectInvitation()
        {
            // First Create a new session and then send an invite for the session.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Send an invite to player 2.
            InvitationNotification notification = new InvitationNotification
                                                        {
                                                            GameId = sessionState.GameID,
                                                            SessionId = sessionState.SessionID
                                                        };

            List<IdentityToken> playersToBeNotified = new List<IdentityToken>();
            playersToBeNotified.Add(this.testPlayer2Identity);

            // Note: The notification service internal does not process this invite if the gamertag for the recipient is not valid.
            this.SendCreateInviteNotificationRequest(notification, this.testPlayer1Identity, playersToBeNotified);
            Console.WriteLine("\n Invitation Notification sent for session: {0}", sessionState.SessionID);

            // Player 2 now rejects the invitation.
            this.sessionService.RejectInvitationInternal(sessionState.GameID.ToString(), sessionState.SessionID, this.testPlayer2Identity);
            Console.WriteLine("\n Invitation Notification deleted for session: {0}", sessionState.SessionID);
        }

        /// <summary>
        /// Test LeaveSession.
        /// </summary>
        [TestMethod]
        public void TestLeaveSession()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);
            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);

            // Now Remove the just added player.
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity);

            SessionState sessionStateAfterRemove =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity, true, this.locale);

            Console.WriteLine("\n Number of players after removing a player to the session is " +
                sessionStateAfterRemove.Seats.Length + " and expected is 1.");
            Assert.IsTrue(sessionStateAfterRemove.Seats.Length == 1);
            Console.WriteLine("\n Removed Player sucessfully from Session with SessionID: " + sessionStateAfterRemove.SessionID);
        }

        /// <summary>
        /// Test LeaveSession with opponents win option.
        /// </summary>
        [TestMethod]
        public void TestLeaveSessionOpponentsWin()
        {
            // Initialize creationData
            CreationData opponentsWinCreationData = new CreationData();
            opponentsWinCreationData.GameID = UInt32.Parse(this.gameID);
            opponentsWinCreationData.CanRemoveEmptySeats = true;
            opponentsWinCreationData.DisplayName = "TestSession with different policy";
            opponentsWinCreationData.InactivityWarning = new InactivityWarningBehavior();
            opponentsWinCreationData.TotalSeatsAvailable = 3;
            opponentsWinCreationData.SessionParameters = new byte[] { 1, 2, 3 };
            opponentsWinCreationData.Variant = 0;
            opponentsWinCreationData.LeavePolicy = SessionLeavePolicy.LeavingUserLosesOpponentsWin;

            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, opponentsWinCreationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);
            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);

            // Now Remove the just added player.
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity);

            SessionState sessionStateAfterRemove =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity, true, this.locale);

            Console.WriteLine("\n Number of players after removing a player to the session is " +
                sessionStateAfterRemove.Seats.Length + " and expected is 1.");
            Assert.IsTrue(sessionStateAfterRemove.Seats.Length == 1);
            Assert.IsTrue(sessionStateAfterRemove.State.IsComplete, "Session is not complete as expected!");
            Assert.IsTrue(sessionStateAfterRemove.State.LastModified > sessionStateAfterJoin.State.LastModified);

            DateTime lastModified;
            SeatInfo lastModifiedBy;
            SessionEntry sessionEntryAfterLeave = GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModified, out lastModifiedBy, this.sessionService);
            Assert.IsTrue(sessionEntryAfterLeave.IsComplete);
            Assert.IsTrue(sessionEntryAfterLeave.LastModified > sessionStateAfterJoin.State.LastModified);

            Console.WriteLine("\n Removed Player successfully from Session with SessionID: " + sessionStateAfterRemove.SessionID);
        }

        /// <summary>
        /// Test LeaveSession again.
        /// </summary>
        [TestMethod]
        public void TestLeaveSessionAgain()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);
            Console.WriteLine("\n Number of players after adding a player to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);

            // Now Remove the just added player.
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity);

            SessionState sessionStateAfterRemove =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity, true, this.locale);

            Console.WriteLine("\n Number of players after removing a player to the session is " +
                sessionStateAfterRemove.Seats.Length + " and expected is 1.");
            Assert.IsTrue(sessionStateAfterRemove.Seats.Length == 1);

            // Try to leave again.
            UnitTestHelper.TestException(
                delegate { this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.PlayerIsNotInSession));

            SessionState sessionStateAfterLeaveAgain =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity, true, this.locale);

            Console.WriteLine("\n Number of players after removing a player to the session is " +
                sessionStateAfterLeaveAgain.Seats.Length + " and expected is 1.");
            Assert.IsTrue(sessionStateAfterLeaveAgain.Seats.Length == 1);

            Console.WriteLine("\n Removed Player successfully from Session with SessionID: " + sessionStateAfterLeaveAgain.SessionID);
        }

        /// <summary>
        /// Test owner leaves session scenario.
        /// </summary>
        [TestMethod]
        public void TestLeaveSessionOwner()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            joinData.SeatIndex = 2;
            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer3Identity, this.locale, this.platformType);
            Console.WriteLine("\n Number of players after adding 2 players to the session is " +
                sessionStateAfterJoin.Seats.Length + " and expected is 3.");
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 3);

            // Now the session owner leaves.
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity);

            SessionState sessionStateAfterRemove =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity, true, this.locale);

            Console.WriteLine("\n Number of players after removing a player to the session is " +
                sessionStateAfterRemove.Seats.Length + " and expected is 2.");
            Assert.IsTrue(sessionStateAfterRemove.Seats.Length == 2);
            Console.WriteLine("\n Removed Owner sucessfully from Session with SessionID: " + sessionStateAfterRemove.SessionID);
        }

        /// <summary>
        /// Test the scenario in which the session owner leaves and another user joins at the same seat.
        /// </summary>
        [TestMethod]
        public void TestLeaveSessionOwnerAndUserJoinsAtTheSameSeat()
        {
            // First Create a new session and then add another player to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Now the session owner leaves.
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity);

            SessionState sessionStateAfterRemove =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity, true, this.locale);

            joinData.SeatIndex = 0;
            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionStateAfterRemove.SessionID, joinData, this.testPlayer3Identity, this.locale, this.platformType);
            Assert.IsTrue(sessionStateAfterJoin.Seats.Length == 2);
            foreach (var seat in sessionStateAfterJoin.Seats)
            {
                if (seat.Profile.PublicToken.Equals(this.testPlayer2Identity.PublicToken))
                {
                    Assert.IsTrue(seat.Index == 1, "The player is sitting on an unexpected seat index: " + seat.Index);
                }
                else if (seat.Profile.PublicToken.Equals(this.testPlayer3Identity.PublicToken))
                {
                    Assert.IsTrue(seat.Index == 0, "The player is sitting on an unexpected seat index: " + seat.Index);
                }
                else
                {
                    Assert.Fail("There is an unexpected user in the session: " + seat.Profile.PublicToken + " at index: " + seat.Index);
                }
            }

            Console.WriteLine("\n Removed Owner successfully and seated another user at the same seat in Session with SessionID: " + sessionStateAfterRemove.SessionID);
        }

        /// <summary>
        /// Test all players leave session scenario.
        /// </summary>
        [TestMethod]
        public void TestLeaveSessionAllPlayers()
        {
            // First Create a new session and then add players to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);
            joinData.SeatIndex = 2;
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer3Identity, this.locale, this.platformType);

            // All players leave the session.
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity);
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer2Identity);
            this.sessionService.LeaveSessionInternal(sessionState.SessionID, this.gameID, this.testPlayer3Identity);

            Console.WriteLine("\nAll players successfully left the Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SetGameState.
        /// </summary>
        [TestMethod]
        public void TestSetGameState()
        {
            // First Create a new session and then set game state for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            DateTime lastModifiedAfterJoin;
            SeatInfo lastModifiedByAfterJoin;
            SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModifiedAfterJoin, out lastModifiedByAfterJoin, this.sessionService);
            Assert.IsTrue(lastModifiedByAfterJoin.Index == 0, "Session was not last modified by seat index 0 as expected");

            ModifiableGameState modifiableGameState = new ModifiableGameState();
            modifiableGameState.ActiveSeatIndex = 1;
            modifiableGameState.GameData = new byte[] { 55, 56, 57, 58, 59 };

            this.gameStateService.SetGameStateInternal(
                sessionStateAfterJoin.SessionID,
                sessionStateAfterJoin.GameID.ToString(),
                modifiableGameState,
                this.testPlayer1Identity);

            SessionState newSessionState = this.sessionService.ViewSessionInternal(
                sessionStateAfterJoin.SessionID,
                sessionStateAfterJoin.GameID.ToString(),
                this.testPlayer1Identity,
                true,
                this.locale);

            Assert.IsTrue(
                newSessionState.State.LastModified > sessionStateAfterJoin.State.LastModified,
                "After set game state, the game state last modified DateTime in ticks is: {0} which is not greater than the modification time when player 2 joined: {1}",
                newSessionState.State.LastModified.Ticks,
                sessionStateAfterJoin.State.LastModified.Ticks);
            Assert.IsTrue(
                newSessionState.State.ActiveSeatIndex == 1,
                "Session with SessionID: " + newSessionState.SessionID + " does not have the expected active user.");
            Assert.IsTrue(
                newSessionState.State.SequenceNumber == 1,
                "Session with SessionID " + newSessionState.SessionID + " has unexpected sequence number.");

            DateTime lastModifiedAfterSetGameState;
            SeatInfo lastModifiedByAfterSetGameState;
            SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModifiedAfterSetGameState, out lastModifiedByAfterSetGameState, this.sessionService);
            Assert.IsTrue(
                 lastModifiedAfterSetGameState > lastModifiedAfterJoin,
                "After set game state, the session last modified DateTime in ticks is: {0} which is not greater than the modification time when player 2 joined: {1}",
                lastModifiedAfterSetGameState.Ticks,
                lastModifiedAfterJoin.Ticks);
            Assert.IsTrue(lastModifiedByAfterSetGameState.Index == 0, "Session was not last modified by seat index 0 as expected");

            Console.WriteLine("\n Modified GameState of the Session with SessionID: " + newSessionState.SessionID);
        }

        /// <summary>
        /// Test assigning empty seat to the active seat.
        /// </summary>
        [TestMethod]
        public void TestAssigningEmptySeatToActiveSeat()
        {
            // First Create a new session and then set game state for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            ModifiableGameState modifiableGameState = new ModifiableGameState();
            modifiableGameState.ActiveSeatIndex = 1;
            modifiableGameState.GameData = new byte[] { 55, 56, 57, 58, 59 };

            this.gameStateService.SetGameStateInternal(
                sessionState.SessionID,
                sessionState.GameID.ToString(),
                modifiableGameState,
                this.testPlayer1Identity);

            SessionState newSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID,
                sessionState.GameID.ToString(),
                this.testPlayer1Identity,
                true,
                this.locale);

            Assert.IsTrue(
                newSessionState.State.ActiveSeatIndex == 1,
                "Session with SessionID: " + newSessionState.SessionID + " does not have the expected active user.");
            Assert.IsTrue(
                newSessionState.State.SequenceNumber == 1,
                "Session with SessionID " + newSessionState.SessionID + " has unexpected sequence number.");

            Console.WriteLine("\n Modified GameState of the Session with SessionID and assigned an empty seat to the active seat: " + newSessionState.SessionID);
        }

        /// <summary>
        /// Test GetGameState.
        /// </summary>
        [TestMethod]
        public void TestGetGameState()
        {
            // First Create a new session and then get game state for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            ModifiableGameState modifiableGameState = new ModifiableGameState();
            modifiableGameState.ActiveSeatIndex = 1;
            modifiableGameState.GameData = new byte[] { 55, 56, 57, 58, 59 };

            this.gameStateService.SetGameStateInternal(
                sessionStateAfterJoin.SessionID,
                sessionStateAfterJoin.GameID.ToString(),
                modifiableGameState,
                this.testPlayer1Identity);

            FullGameState newGameState = this.gameStateService.GetGameStateInternal(
                sessionStateAfterJoin.SessionID,
                sessionStateAfterJoin.GameID.ToString(),
                this.testPlayer2Identity);

            Assert.IsTrue(
                newGameState.GameStateInfo.ActiveSeatIndex == 1,
                "GameState for SessionID: " + sessionStateAfterJoin.SessionID + " does not have the expected active user.");
            Assert.IsTrue(
                newGameState.GameData.Length == modifiableGameState.GameData.Length,
                "GameState for SessionID " + newGameState.GameStateInfo.SessionID + " has a different length than expected.");
            Assert.IsTrue(
                newGameState.GameStateInfo.SequenceNumber == 1,
                "Session with SessionID " + newGameState.GameStateInfo.SessionID + " has unexpected sequence number.");

            for (int i = 0; i < newGameState.GameData.Length; i++)
            {
                Assert.IsTrue(
                    newGameState.GameData[i] == modifiableGameState.GameData[i],
                    "GameState for SessionID " + newGameState.GameStateInfo.SessionID + " has different data than what was saved.");
            }

            Console.WriteLine("\n Sucess in getting GameState of the Session with SessionID: " + newGameState.GameStateInfo.SessionID);
        }

        /// <summary>
        /// Test get game state on a completed session.
        /// </summary>
        [TestMethod]
        public void TestGetGameStateCompleted()
        {
            // First create a new session
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = sessionState.GameID;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            // Add more players to the session.
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Check the notifications cleaned flag before the session is complete.
            this.gameStateService.GetGameStateInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity);

            StorageAccountInfo account = new StorageAccountInfo(
                                            new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                                            null,
                                            ServiceConfigs.AzureStorageAccount,
                                            ServiceConfigs.AzureStorageToken,
                                            false);
            ISessionStorage sessionStorage = new SessionAzureStorage(account);

            OpaqueSessionStorageObject storageObject;
            SessionState sessionStatePreCompleted = sessionStorage.QuerySession(sessionState.SessionID, uint.Parse(this.gameID), out storageObject);

            foreach (var seat in sessionStatePreCompleted.Seats)
            {
                Assert.IsFalse(seat.NotificationsCleaned, "Player: " + seat.Profile.PublicToken + " notifications are already marked as deleted!");
            }

            GameResults gameResults = new GameResults
            {
                WinningSeatIndexes = new int[] { 0, 1, 2 },
                LosingSeatIndexes = new int[] { 3, 4, 5 },
                TierSeatIndexes = new int[] { 6, 7 },
                GameOverSeatIndexes = new int[] { 8 },
                Results = new Dictionary<int, GameResult>()
            };

            // Populate GameResult for all players.
            gameResults.Results[0] = new GameResult()
            {
                GameId = uint.Parse(this.gameID),
                GameResultId = Guid.NewGuid(),
                Outcome = GameResultOutcome.Win.ToString(),
                Score = 10,
                Time = 5,
                TimeStamp = DateTime.UtcNow,
                Variant = (uint)this.creationData.Variant
            };
            gameResults.Results[1] = new GameResult()
            {
                GameId = uint.Parse(this.gameID),
                GameResultId = Guid.NewGuid(),
                Outcome = GameResultOutcome.Loss.ToString(),
                Score = 3,
                Time = 1,
                TimeStamp = DateTime.UtcNow,
                Variant = (uint)this.creationData.Variant
            };

            // Fire a GameEnd.
            this.gameStateService.PostGameEndInternal(sessionState.SessionID, sessionState.GameID.ToString(), gameResults, this.testPlayer1Identity, string.Empty);

            // Check the notifications cleaned flag after the session is complete.
            this.gameStateService.GetGameStateInternal(sessionState.SessionID, this.gameID, this.testPlayer1Identity);

            // Check the notifications cleaned flag after the session is complete.
            SessionState sessionStateCompleted = sessionStorage.QuerySession(sessionState.SessionID, uint.Parse(this.gameID), out storageObject);
            foreach (var seat in sessionStateCompleted.Seats)
            {
                if (seat.Profile.Equals(this.testPlayer1Identity))
                {
                    Assert.IsTrue(seat.NotificationsCleaned, "Player: " + seat.Profile.PublicToken + " notifications are not marked as deleted!");
                }
                else
                {
                    Assert.IsFalse(seat.NotificationsCleaned, "Player: " + seat.Profile.PublicToken + " notifications are marked as deleted!");
                }
            }
        }

        /// <summary>
        /// Test GetGameState.
        /// </summary>
        [TestMethod]
        public void TestGetGameStateForbidden()
        {
            // First create a new session and then get game state for it using a differenet user.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            // Try to get the game state with a user who is not in the session.
            UnitTestHelper.TestException(
                delegate
                {
                    FullGameState newGameState = this.gameStateService.GetGameStateInternal(
                                                    sessionState.SessionID,
                                                    sessionState.GameID.ToString(),
                                                    this.testPlayer2Identity);
                },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.UserNotAllowedToGetStateInSession));

            Console.WriteLine("\n As expected, forbidden from getting GameState of the Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test GetGameState BadRequest.
        /// </summary>
        [TestMethod]
        public void TestGetGameStateBadRequest()
        {
            // First Create a new session and then get game state for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                 this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            ModifiableGameState modifiableGameState = new ModifiableGameState();
            modifiableGameState.ActiveSeatIndex = 1;
            modifiableGameState.GameData = new byte[] { 55, 56, 57, 58, 59 };

            this.gameStateService.SetGameStateInternal(
                sessionStateAfterJoin.SessionID,
                sessionStateAfterJoin.GameID.ToString(),
                modifiableGameState,
                this.testPlayer1Identity);

            FullGameState newGameState;

            // Try to query the session with invalid gameID.
            UnitTestHelper.TestException(
                delegate { newGameState = this.gameStateService.GetGameStateInternal(sessionStateAfterJoin.SessionID, "InvalidGameID", this.testPlayer2Identity); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.InvalidGameIDFormat));

            Console.WriteLine("\n As expected, could not query with an invalid GameID on SessionID:" + sessionState.SessionID);
        }

        /// <summary>
        /// Test user nudge PostGameAction.
        /// </summary>
        [TestMethod]
        public void TestPostGameActionNudge()
        {
            // First Create a new session and post game action for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Now Player 2 nudges the active player.
            GameAction action = new GameAction
                                    {
                                        ActionData = null,
                                        ActionTime = DateTime.UtcNow,
                                        ActionType = GameActionType.UserNudge
                                    };
            this.gameStateService.PostGameActionInternal(sessionStateAfterJoin.SessionID, joinData.GameID.ToString(), action, this.testPlayer2Identity);

            // Check if the WasActiveSeatUserNudged flag is set when user is nudged and reset when a move is made.
            SessionState sessionStateAfterNudge =
                this.sessionService.ViewSessionInternal(sessionStateAfterJoin.SessionID, joinData.GameID.ToString(), this.testPlayer2Identity, true, this.locale);
            Assert.IsTrue(sessionStateAfterNudge.WasActiveSeatUserNudged);

            ModifiableGameState gameState = new ModifiableGameState() { ActiveSeatIndex = 1, GameData = new byte[] { 4, 5, 6 } };
            this.gameStateService.SetGameStateInternal(sessionStateAfterJoin.SessionID, joinData.GameID.ToString(), gameState, this.testPlayer1Identity);

            SessionState sessionStateAfterMove =
                this.sessionService.ViewSessionInternal(sessionStateAfterJoin.SessionID, joinData.GameID.ToString(), this.testPlayer2Identity, true, this.locale);
            Assert.IsFalse(sessionStateAfterMove.WasActiveSeatUserNudged);
        }

        /// <summary>
        /// Test user nudging when active seat is empty.
        /// </summary>
        [TestMethod]
        public void TestPostGameActionNudgeActiveSeatEmpty()
        {
            // First Create a new session and post game action for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            ModifiableGameState modData = new ModifiableGameState
                                              {
                                                  ActiveSeatIndex = 1,
                                                  GameData = new byte[] { 1, 2, 3 }
                                              };
            this.gameStateService.SetGameStateInternal(sessionState.SessionID, sessionState.GameID.ToString(), modData, this.testPlayer1Identity);

            // Now Player 1 nudges when active seat is empty.
            GameAction action = new GameAction
                                    {
                                        ActionData = null,
                                        ActionTime = DateTime.UtcNow,
                                        ActionType = GameActionType.UserNudge
                                    };

            UnitTestHelper.TestException(
                delegate { this.gameStateService.PostGameActionInternal(sessionState.SessionID, sessionState.GameID.ToString(), action, this.testPlayer1Identity); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.CannotNudgeEmptyActiveSeat));

            Console.WriteLine("\n As expected, could not nudge when the active seat is empty.");
        }

        /// <summary>
        /// Test game specific PostGameAction.
        /// </summary>
        [TestMethod]
        public void TestPostGameActionGameSpecific()
        {
            // First Create a new session and post game action for it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, this.creationData, this.testPlayer1Identity, this.locale, this.platformType);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            SessionState sessionStateAfterJoin =
                this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);

            // Now Player 2 posts a game action.
            GameAction action = new GameAction
            {
                ActionData = new byte[] { 0 },
                ActionTime = DateTime.UtcNow,
                ActionType = GameActionType.GameSpecific
            };

            // Try to post a game specific  game action for the passthru module.
            UnitTestHelper.TestException(
                delegate { this.gameStateService.PostGameActionInternal(sessionStateAfterJoin.SessionID, joinData.GameID.ToString(), action, this.testPlayer2Identity); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.OnSubmitGameActionNotImplementedInPassthru));
        }

        /// <summary>
        /// Test PostGameEnd.
        /// </summary>
        [TestMethod]
        public void TestPostGameEnd()
        {
            // Initialize gameEndCreationData
            CreationData gameEndCreationData = new CreationData();
            gameEndCreationData.GameID = UInt32.Parse(this.gameID);
            gameEndCreationData.CanRemoveEmptySeats = true;
            gameEndCreationData.DisplayName = "TestSession";
            gameEndCreationData.InactivityWarning = new InactivityWarningBehavior();
            gameEndCreationData.TotalSeatsAvailable = 9;
            gameEndCreationData.SessionParameters = new byte[] { 1, 2, 3 };
            gameEndCreationData.Variant = 0;

            // First Create a new session and add players to it.
            SessionState sessionState = this.sessionService.CreateSessionInternal(
                this.gameID, gameEndCreationData, this.testPlayer1Identity, this.locale, this.platformType);

            Console.WriteLine("Created session with SessionID: " + sessionState.SessionID);

            JoinData joinData = new JoinData();
            joinData = new JoinData();
            joinData.GameID = gameEndCreationData.GameID;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = sessionState.SessionID;

            string token4 = "4600292642023851";
            string publicToken4 = "testPlayer4";
            IdentityToken testPlayer4Identity = new IdentityToken(IdentityServiceType.XUID, token4, publicToken4);

            string token5 = "5600292642023851";
            string publicToken5 = "testPlayer5";
            IdentityToken testPlayer5Identity = new IdentityToken(IdentityServiceType.XUID, token5, publicToken5);

            string token6 = "6600292642023851";
            string publicToken6 = "testPlayer6";
            IdentityToken testPlayer6Identity = new IdentityToken(IdentityServiceType.XUID, token6, publicToken6);

            string token7 = "7600292642023851";
            string publicToken7 = "testPlayer7";
            IdentityToken testPlayer7Identity = new IdentityToken(IdentityServiceType.XUID, token7, publicToken7);

            string token8 = "8600292642023851";
            string publicToken8 = "testPlayer8";
            IdentityToken testPlayer8Identity = new IdentityToken(IdentityServiceType.XUID, token8, publicToken8);

            string token9 = "9600292642023851";
            string publicToken9 = "testPlayer9";
            IdentityToken testPlayer9Identity = new IdentityToken(IdentityServiceType.XUID, token9, publicToken9);

            // Add more players to the session.
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer2Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, this.testPlayer3Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, testPlayer4Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, testPlayer5Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, testPlayer6Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, testPlayer7Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, testPlayer8Identity, this.locale, this.platformType);
            this.sessionService.JoinSessionInternal(sessionState.SessionID, joinData, testPlayer9Identity, this.locale, this.platformType);

            DateTime lastModifiedAfterJoin;
            SeatInfo lastModifiedByAfterJoin;
            SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModifiedAfterJoin, out lastModifiedByAfterJoin, this.sessionService);
            Assert.IsTrue(lastModifiedByAfterJoin.Index == 0, "Session was not last modified by seat index 0 as expected");

            Console.WriteLine("Added players to the session with SessionID: " + sessionState.SessionID);

            GameResults gameResults = new GameResults
                                          {
                                              WinningSeatIndexes = new int[] { 0, 1, 2 },
                                              LosingSeatIndexes = new int[] { 3, 4, 5 },
                                              TierSeatIndexes = new int[] { 6, 7 },
                                              GameOverSeatIndexes = new int[] { 8 },
                                              Results = new Dictionary<int, GameResult>()
                                          };

            // Populate GameResult for all players.
            gameResults.Results[0] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Win.ToString(),
                                             Score = 10,
                                             Time = 5,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[1] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Win.ToString(),
                                             Score = 10,
                                             Time = 5,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[2] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Win.ToString(),
                                             Score = 10,
                                             Time = 5,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[3] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Loss.ToString(),
                                             Score = 1,
                                             Time = 1,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[4] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Loss.ToString(),
                                             Score = 1,
                                             Time = 1,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[5] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Loss.ToString(),
                                             Score = 1,
                                             Time = 1,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[6] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Tie.ToString(),
                                             Score = 5,
                                             Time = 2,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[7] = new GameResult()
                                         {
                                             GameId = uint.Parse(this.gameID),
                                             GameResultId = Guid.NewGuid(),
                                             Outcome = GameResultOutcome.Tie.ToString(),
                                             Score = 5,
                                             Time = 2,
                                             TimeStamp = DateTime.UtcNow,
                                             Variant = (uint)this.creationData.Variant
                                         };
            gameResults.Results[8] = new GameResult()
                                        {
                                            GameId = uint.Parse(this.gameID),
                                            GameResultId = Guid.NewGuid(),
                                            Outcome = GameResultOutcome.None.ToString(),
                                            Score = 3,
                                            Time = 3,
                                            TimeStamp = DateTime.UtcNow,
                                            Variant = (uint)this.creationData.Variant
                                        };

            // Fire a GameEnd.
            this.gameStateService.PostGameEndInternal(sessionState.SessionID, joinData.GameID.ToString(), gameResults, this.testPlayer2Identity, string.Empty);

            // Get the session state and verify.
            SessionState newSessionState = this.sessionService.ViewSessionInternal(sessionState.SessionID, joinData.GameID.ToString(), this.testPlayer1Identity, true, this.locale);
            Assert.IsTrue(newSessionState.State.IsComplete, "Error: The session does not have the isComplete flag set, SessionID: " + newSessionState.SessionID);

            DateTime lastModifiedAfterPostGameEnd;
            SeatInfo lastModifiedByAfterPostGameEnd;
            SessionEntry sessionEntryAfterGameEnded = SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer1Identity, sessionState.SessionID, sessionState.GameID, out lastModifiedAfterPostGameEnd, out lastModifiedByAfterPostGameEnd, this.sessionService);
            Assert.IsTrue(
                 lastModifiedAfterPostGameEnd > lastModifiedAfterJoin,
                "After post game end, the session last modified DateTime in ticks is: {0} which is not greater than the modification time when all players joined: {1}",
                lastModifiedAfterPostGameEnd.Ticks,
                lastModifiedAfterJoin.Ticks);
            Assert.IsTrue(lastModifiedByAfterPostGameEnd.Index == 1, "Session was not last modified by seat index 1 (player 2) as expected");
            Assert.IsTrue(sessionEntryAfterGameEnded.IsComplete, "Session entry is NOT complete!");

            Console.WriteLine("Ended the session with SessionID: " + newSessionState.SessionID);
        }

        /// <summary>
        /// Send a create invitation notification request to the queue. The notification will be sent 
        /// to a list of recipients.
        /// </summary>
        /// <param name="notification">The notification.</param>
        /// <param name="senderIdentity">The identity of the sender.</param>
        /// <param name="recipients">The identities of a list of recipients.</param>
        internal void SendCreateInviteNotificationRequest(Notification notification, IdentityToken senderIdentity, List<IdentityToken> recipients)
        {
            NotificationRequest request = new NotificationRequest();
            XmlSerializer serializer = new XmlSerializer(typeof(UserInfo));
            using (MemoryStream stream = new MemoryStream())
            {
                UserInfo userInfo = new UserInfo(ulong.Parse(senderIdentity.Token)) { GamerTag = senderIdentity.PublicToken };
                serializer.Serialize(stream, userInfo);
                byte[] userInfoArray = stream.ToArray();
                Encoding encoding = new UTF8Encoding();
                request.From = encoding.GetString(userInfoArray);
            }

            StringBuilder toStringBuilder = new StringBuilder();
            foreach (var receiverIdentity in recipients)
            {
                // Invites expect emailAddresses or GamerTags in the To field.
                toStringBuilder.Append("gamertag:");
                toStringBuilder.Append(receiverIdentity.PublicToken);
                toStringBuilder.Append(";");
            }

            request.To = toStringBuilder.ToString();
            request.RequestLocale = this.locale;
            request.Action = NotificationRequest.ActionType.Create;
            request.Command = request.Action.ToString() + notification.Type.ToString();
            request.GameId = notification.GameId;
            request.SessionId = notification.SessionId;
            request.RequestDataType = (int)notification.Type;
            request.RequestData = Notification.SerializeToString(notification);
            request.RequestLocale = this.locale;

            INotificationRequest notificationRequest =
                new NotificationRequestUtils(ConfigurationManager.ConnectionStrings["lest_AsyncNotification_db"].ConnectionString);
            notificationRequest.SendNotificationRequest(request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeDispatcher\SystemNudgePerfCounters.cs ===
﻿// <copyright file="SystemNudgePerfCounters.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-06-02</date>
// <summary>Contains the class definition for SystemNudgePerfCounters class.</summary>

namespace AsyncMultiplayer.SystemNudgeDispatcher
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class is used to define the performance counters for the system nudge service.
    /// </summary>
    [SuppressMessage("Microsoft.StyleCop.CSharp.MaintainabilityRules", "SA1401:FieldsMustBePrivate", Justification = "Public fields required by the performance counter framework.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented", Justification = "Fields are self documenting.")]
    [PerformanceCategory(CategoryName = "SystemNudgePerfCounters")]
    public sealed class SystemNudgePerfCounters
    {
        [PerformanceCounter(CounterName = "Partitions Enqueued For Processing", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of partitions enqueued for processing so far.")]
        public static int PartitionsEnqueued;

        [PerformanceCounter(CounterName = "Partitions Enqueued For Processing Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of partitions enqueued for processing per second.")]
        public static int PartitionsEnqueuedPerSecond;

        [PerformanceCounter(CounterName = "Partition Queue Length", CounterType = PerformanceCounterType.NumberOfItems32, CounterDescription = "Number of partitions currently in the queue.")]
        public static int PartitionQueueLength;

        [PerformanceCounter(CounterName = "Partitions Processing", CounterType = PerformanceCounterType.NumberOfItems32, CounterDescription = "Number of partitions currently processing.")]
        public static int PartitionsProcessing;

        [PerformanceCounter(CounterName = "PartitionsProcessed", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of partitions processed successfully so far.")]
        public static int PartitionsProcessed;

        [PerformanceCounter(CounterName = "Partitions Processed Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of partitions processed successfully per second.")]
        public static int PartitionsProcessedPerSecond;

        [PerformanceCounter(CounterName = "Partition Processing Errors", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of partition processing errors so far.")]
        public static int PartitionProcessingErrors;

        [PerformanceCounter(CounterName = "Partition Processing Errors Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of partition processing errors per second.")]
        public static int PartitionProcessingErrorsPerSecond;

        [PerformanceCounter(CounterName = "Partition Processing Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of processing a partition.", BasePropertyName = "Partition Processing Duration Base")]
        public static int PartitionProcessingDuration;

        [PerformanceCounter(CounterName = "Partition Processing Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of processing a partition base.")]
        public static int PartitionProcessingDurationBase;

        [PerformanceCounter(CounterName = "Sessions Processed", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of sessions processed successfully so far.")]
        public static int SessionsProcessed;

        [PerformanceCounter(CounterName = "Sessions Processed Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of sessions processed successfully per second.")]
        public static int SessionsProcessedPerSecond;

        [PerformanceCounter(CounterName = "Session Processing Errors", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of session processing errors so far.")]
        public static int SessionProcessingErrors;

        [PerformanceCounter(CounterName = "Session Processing Errors Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of session processing errors per second.")]
        public static int SessionProcessingErrorsPerSecond;

        [PerformanceCounter(CounterName = "Session Processing Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of processing a session.", BasePropertyName = "Session Processing Duration Base")]
        public static int SessionProcessingDuration;

        [PerformanceCounter(CounterName = "Session Processing Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of processing a session base.")]
        public static int SessionProcessingDurationBase;

        [PerformanceCounter(CounterName = "System Nudge Run Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of a system nudge run.", BasePropertyName = "System Nudge Run Duration Base")]
        public static int SystemNudgeRunDuration;

        [PerformanceCounter(CounterName = "System Nudge Run Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of a system nudge run base.")]
        public static int SystemNudgeRunDurationBase;

        /// <summary>
        /// Prevents a default instance of the SystemNudgePerfCounters class from being created.
        /// </summary>
        private SystemNudgePerfCounters()
        {
        }

        /// <summary>
        /// Gets the name of the performance counters.
        /// </summary>
        public static string Name
        {
            get
            {
                return "SystemNudgePerfCounters";
            }
        }

        /// <summary>
        /// Gets or sets the collection of perf counters for the system nudge service.
        /// </summary>
        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeDispatcher\SystemNudgeProcessor.cs ===
﻿// <copyright file="SystemNudgeProcessor.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-18</date>
// <summary>Contains the class definition for SystemNudgeProcessor class.</summary>

namespace AsyncMultiplayer.SystemNudgeDispatcher
{
    using System;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using Common.AzureStorage;
    using EventBasedService.Common;
    using GameStateAzureStorage;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationService;
    using PassThruGameLogicModule;
    using SessionAzureStorage;
    using SessionCommon;
    using SessionMaintenance;

    /// <summary>
    /// This class processes system nudges for a portion of the active sessions.
    /// </summary>
    public class SystemNudgeProcessor
    {
        /// <summary>
        /// Component name of System nudger processor.
        /// </summary>
        public const string ComponentName = "SystemNudgeProcessor";

        /// <summary>
        /// The partition key for the partition to process for system nudges.
        /// </summary>
        private readonly string partitionKey;

        /// <summary>
        /// The thread pool waiter utility object.
        /// </summary>
        private readonly ThreadPoolWait threadPoolWaiter;

        /// <summary>
        /// Used to signal the thread to stop processing.
        /// </summary>
        private readonly IEventService containingService;

        /// <summary>
        /// Initializes a new instance of the SystemNudgeProcessor class.
        /// </summary>
        /// <param name="partitionKey">Partition to process for system nudges.</param>
        /// <param name="waiter">Used to signal the dispatcher thread that the worker thread is done.</param>
        /// <param name="parentService">Used to signal the thread to stop processing.</param>
        public SystemNudgeProcessor(string partitionKey, ThreadPoolWait waiter, IEventService parentService)
        {
            this.partitionKey = partitionKey;
            this.threadPoolWaiter = waiter;
            this.containingService = parentService;
        }

        /// <summary>
        /// Process sessions for sending system nudges.
        /// </summary>
        /// <param name="stateInfo">State passed by the caller thread.</param>
        public void ProcessSessions(object stateInfo)
        {
            Stopwatch stopWatch = new Stopwatch();
            stopWatch.Start();

            try
            {
                try
                {
                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionsProcessing);

                    this.SendSystemNudges();

                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionsProcessed);
                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionsProcessedPerSecond);
                }
                catch (Exception ex)
                {
                    throw new LIVEnException(
                        SessionMaintenanceEvents.Events,
                        SessionMaintenanceEvents.UnhandledExceptionInProcessSessionsThread,
                        HttpStatusCode.InternalServerError,
                        ex,
                        true,
                        this.partitionKey);
                }
            }
            catch (LIVEnException)
            {
                // Ignore any exceptions thrown by the thread,
                // since we do not want the exception to kill the whole process.
                SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionProcessingErrors);
                SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionProcessingErrorsPerSecond);
            }
            finally
            {
                this.threadPoolWaiter.DoneWorkItem();
                SystemNudgePerfCounters.Counters.SafeDecrement(SystemNudgePerfCounters.PartitionsProcessing);

                stopWatch.Stop();
                SystemNudgePerfCounters.Counters.SafeIncrementBy(SystemNudgePerfCounters.PartitionProcessingDuration, stopWatch.ElapsedTicks);
                SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionProcessingDurationBase);
            }
        }

        /// <summary>
        /// Send system nudges.
        /// </summary>
        public void SendSystemNudges()
        {
            // Check if we need to stop as soon as the thread starts running after being enqueued.
            if (this.containingService.IsServiceStopping())
            {
                return;
            }

            StorageAccountInfo account = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            ISessionStorage sessionStorage = new SessionAzureStorage(account, ServiceConfigs.ProxyAddress);
            INotificationRequest notificationRequest = new NotificationRequestUtils(ServiceConfigs.NotificationRequestQueueConnectionString);
            IGameStateStorage stateStorage = new GameStateAzureStorage(account, ServiceConfigs.ProxyAddress);
            IGameLogicModule gameLogicModule = new PassThruGameLogicModule(stateStorage, sessionStorage);

            SessionIndexDataServiceContext sessionContext = new SessionIndexDataServiceContext(account);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = ServiceConfigs.ProxyAddress;

            // Iterate over all sessions in the partition.
            // Using the enumerator rather than foreach in order to catch WebExceptions while enumerating.
            IEnumerable<SessionIndexAzureTableEntity> result = GetSessionIndexEntityList(sessionContext, this.partitionKey);
            IEnumerator<SessionIndexAzureTableEntity> sessionIndexEnumerator = result.GetEnumerator();
            for (var i = 0; i < result.Count(); i++)
            {
                Stopwatch stopWatch = new Stopwatch();
                stopWatch.Start();
                try
                {
                    try
                    {
                        // Check if we need to stop before before Azure query.
                        if (this.containingService.IsServiceStopping())
                        {
                            break;
                        }

                        sessionIndexEnumerator.MoveNext();
                        SessionIndexAzureTableEntity sessionIndexEntity = sessionIndexEnumerator.Current;

                        // Check if we need to stop before before Azure query.
                        if (this.containingService.IsServiceStopping())
                        {
                            break;
                        }

                        // For this session index, get the corresponding session.
                        OpaqueSessionStorageObject storageObject;
                        SessionState sessionState = sessionStorage.QuerySession(
                                                        sessionIndexEntity.SessionID,
                                                        (uint)sessionIndexEntity.GameID,
                                                        out storageObject);

                        // Check if we need to stop before before Azure query.
                        if (this.containingService.IsServiceStopping())
                        {
                            break;
                        }

                        if (!sessionState.State.IsComplete)
                        {
                            // Send nudges and warnings for the session.
                            NudgeAndWarningManager nudgeManager = new NudgeAndWarningManager(
                                sessionStorage,
                                notificationRequest,
                                gameLogicModule,
                                ServiceConfigs.RunInTestMode);
                            nudgeManager.SendNudgesAndWarnings(sessionState);
                        }

                        SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.SessionsProcessed);
                        SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.SessionsProcessedPerSecond);
                    }
                    catch (WebException webException)
                    {
                        throw new LIVEnException(
                            SessionMaintenanceEvents.Events,
                            SessionMaintenanceEvents.WebExceptionInSendSystemNudges,
                            HttpStatusCode.InternalServerError,
                            webException,
                            true,
                            this.partitionKey);
                    }
                }
                catch (LIVEnException)
                {
                    // Ignore any LIVE En exceptions.
                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.SessionProcessingErrors);
                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.SessionProcessingErrorsPerSecond);
                }
                finally
                {
                    stopWatch.Stop();
                    SystemNudgePerfCounters.Counters.SafeIncrementBy(SystemNudgePerfCounters.SessionProcessingDuration, stopWatch.ElapsedTicks);
                    SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.SessionProcessingDurationBase);
                }
            }
        }

        /// <summary>
        /// Gets a list of session index Azure Table entities based on the criteria supplied.
        /// </summary>
        /// <param name="sessionIndexContext">The data service context for the query.</param>
        /// <param name="partitionKey">Partition key for the session index table.</param>
        /// <returns>The session index Azure Table entities based on the criteria supplied.</returns>
        private static IEnumerable<SessionIndexAzureTableEntity> GetSessionIndexEntityList(
            SessionIndexDataServiceContext sessionIndexContext, string partitionKey)
        {
            var query = from c in sessionIndexContext.SessionIndexTable
                        where c.PartitionKey.Equals(partitionKey)
                        select c;

            TableStorageDataServiceQuery<SessionIndexAzureTableEntity> sessionIndexQuery =
                new TableStorageDataServiceQuery<SessionIndexAzureTableEntity>(
                    query as DataServiceQuery<SessionIndexAzureTableEntity>,
                    sessionIndexContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionIndexAzureTableEntity> res = sessionIndexQuery.ExecuteAllWithRetries();
            return res;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\TestGame\App.xaml.cs ===
﻿//--------------------------------------------------------------------------------------------------------
// <copyright description="Simple Silverlight game of Tic-Tac-Toe" file="App.xaml.cs" company="Microsoft">
// Copyright   .  All rights reserved.
// </copyright>
// <summary>Main application to launch the game page</summary>
//--------------------------------------------------------------------------------------------------------
namespace TicTacToe
{
    using System;
    using System.Windows;

    /// <summary>
    /// Silverlight Application
    /// </summary>
    public partial class App
    {
        /// <summary>
        /// Initializes a new instance of the App class
        /// </summary>
        public App()
        {
            this.Startup += this.Application_Startup;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        /// <summary>
        /// Instantiate the Page object which contains the client logic
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void Application_Startup(object sender, StartupEventArgs e)
        {
            this.RootVisual = new Page();
        }

        /// <summary>
        /// Traps any unhandled exceptions
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. For production applications this error handling should be replaced with something that will
                // report the error to the website and stop the application.
                e.Handled = true;

                try
                {
                    string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                    errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                    System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight 2 Application " + errorMsg + "\");");
                }
                catch
                {
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\TestGame\GameSession.cs ===
﻿//---------------------------------------------------------------------------------------------------------
// <copyright description="Simple Silverlight game of Tic-Tac-Toe" file="GameSession.cs" company="Microsoft">
// Copyright   .  All rights reserved.
// </copyright>
// <summary>The GameSession class</summary>
//---------------------------------------------------------------------------------------------------------
namespace TicTacToe
{
    /// <summary>
    /// The GameSession class
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.SessionManagementService")]
    public partial class GameSession
    {
        /// <summary>
        /// The timestamp when this session was last changed
        /// </summary>
        private System.DateTime lastChangedField;

        /// <summary>
        /// The string GUID identifying this session
        /// </summary>
        private string sessionIDField;

        /// <summary>
        /// The string list of users involved in the game
        /// </summary>
        private string userListField;

        /// <summary>
        /// Gets or sets the last changed field
        /// </summary>
        public string LastChanged
        {
            get
            {
                return this.lastChangedField.ToString();
            }

            set
            {
                 bool success = System.DateTime.TryParse(value, out this.lastChangedField);
            }
        }

        /// <summary>
        /// Gets or sets the session ID field
        /// </summary>
        public string SessionID
        {
            get
            {
                return this.sessionIDField;
            }

            set
            {
                this.sessionIDField = value;
            }
        }

        /// <summary>
        /// Gets or sets the user list field
        /// </summary>
        public string UserList
        {
            get
            {
                return this.userListField;
            }

            set
            {
                this.userListField = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeDispatcher\ThreadPoolWait.cs ===
﻿// <copyright file="ThreadPoolWait.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-20</date>
// <summary>Contains the class definition for ThreadPoolWait class.</summary>

namespace AsyncMultiplayer.SystemNudgeDispatcher
{
    using System;
    using System.Threading;

    /// <summary>
    /// This class allows a thread to wait on multiple threads.
    /// It is intended to be used by a dispatcher to wait on thread pool threads.
    /// Adapted from: http://msdn.microsoft.com/en-us/magazine/cc163914.aspx
    /// </summary>
    public class ThreadPoolWait
    {
        /// <summary>
        /// The event which tells the dispatcher that the worker threads are done.
        /// </summary>
        private readonly ManualResetEvent workersDone;

        /// <summary>
        /// The value of remaining work items.
        /// </summary>
        private int remainingWorkItems;

        /// <summary>
        /// Initializes a new instance of the ThreadPoolWait class.
        /// </summary>
        public ThreadPoolWait()
        {
            this.workersDone = new ManualResetEvent(false);
            this.remainingWorkItems = 0;
        }

        /// <summary>
        /// Gets the value of remaining work items.
        /// </summary>
        public int RemainingWorkItems
        {
            get
            {
                return this.remainingWorkItems;
            }
        }

        /// <summary>
        /// Informs the logic that a work item has been queued.
        /// </summary>
        public void QueueWorkItem()
        {
            // Increment the remaining work items.
            lock (this.workersDone)
            {
                this.remainingWorkItems++;
            }

            SystemNudgePerfCounters.Counters.SafeIncrement(SystemNudgePerfCounters.PartitionQueueLength);
        }

        /// <summary>
        /// Informs the logic that a work item has been done.
        /// </summary>
        public void DoneWorkItem()
        {
            lock (this.workersDone)
            {
                this.remainingWorkItems--;
                if (this.remainingWorkItems == 0)
                {
                    this.workersDone.Set();
                }
            }

            SystemNudgePerfCounters.Counters.SafeDecrement(SystemNudgePerfCounters.PartitionQueueLength);
        }

        /// <summary>
        /// Waits till all threads being waited on exit.
        /// </summary>
        /// <returns>true if all waited on threads are done. If all threadsare not done, WaitOne never returns.</returns>
        public bool WaitOne()
        {
            bool received = this.workersDone.WaitOne();
            lock (this.workersDone)
            {
                if (received)
                {
                    this.remainingWorkItems = 0;
                    this.workersDone.Reset();
                }
            }

            return received;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeTest\SystemNudgeTest.cs ===
﻿// <copyright file="SystemNudgeTest.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-19</date>
// <summary>Contains the class definition for SystemNudgeTest class.</summary>

namespace AsyncMultiplayer.SystemNudgeTest
{
    using System;
    using System.Collections;
    using System.Threading;
    using Common.AzureStorage;
    using EventBasedService.Common;
    using SystemNudgeDispatcher;
    using Leet.Core.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class runs SystemNudgeDispatcher in a new thread to prove out the concept 
    /// </summary>
    public class SystemNudgeTest : IEventService
    {
        /// <summary>
        /// Used to store the installation state for perf counters.
        /// </summary>
        private static readonly IDictionary SavedState = new Hashtable();

        /// <summary>
        /// Indicates wther the service is stopping.
        /// </summary>
        private bool isServiceStopping;

        /// <summary>
        /// Gets the name of the program.
        /// </summary>
        public static string ProgramName
        {
            get
            {
                return "SystemNudgeTest";
            }
        }

        /// <summary>
        /// The main method of the process.
        /// </summary>
        /// <param name="args">Command line parameters passed to the command,
        /// arg1: the number of minutes after which the program should terminate.</param>
        public static void Main(string[] args)
        {
            Console.WriteLine(SystemNudgeTest.ProgramName + ": Starting.");

            Leet.Core.IoCCo.Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Leet.Core.IoCCo.Container.Instance.AddService<ILogging, Logging>();

            if (args.Length > 0)
            {
                SystemNudgeTest nudgeTest = new SystemNudgeTest();
                ManualResetEvent serviceStopping = new ManualResetEvent(false);
                ManualResetEvent dispatcherStopped = new ManualResetEvent(false);
                SystemNudgeDispatcher dispatcher = new SystemNudgeDispatcher();
                EventServicePluginDescription pluginDescription = new EventServicePluginDescription(
                                                                        "System Nudge Plugin",
                                                                        typeof(SystemNudgeDispatcher).AssemblyQualifiedName,
                                                                        string.Empty);

                // Install the required perf counters.
                PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
                perfCountersInstaller.Install(typeof(StorageClientPerfCounters).Assembly, SystemNudgeTest.SavedState);
                PerformanceCountersInstaller nudgePerfCountersInstaller = new PerformanceCountersInstaller();
                IDictionary nudgeInstallerSavedState = new Hashtable();
                nudgePerfCountersInstaller.Install(typeof(SystemNudgePerfCounters).Assembly, nudgeInstallerSavedState);

                dispatcher.Initialize(nudgeTest, serviceStopping, dispatcherStopped, pluginDescription, ProgramName);

                // Create a new thread for the dispatcher.
                Thread dispatcherThread = new Thread(dispatcher.DoWork);
                Console.WriteLine(SystemNudgeTest.ProgramName + ": Starting system nudge dispatcher thread.");
                dispatcherThread.Start();

                int numberOfMinutesToRun;
                if (!int.TryParse(args[0], out numberOfMinutesToRun))
                {
                    SystemNudgeTest.DisplayUsage();
                }

                // Sleep, giving the dispatcher some time to run.
                Console.WriteLine(SystemNudgeTest.ProgramName + ": Sleeping for " + numberOfMinutesToRun + " minutes, giving dispatcher thread time to run.");
                Thread.Sleep(numberOfMinutesToRun * 60 * 1000);
                Console.WriteLine(SystemNudgeTest.ProgramName + ": Awake after sleeping.");

                // Stop the dispatcher
                Console.WriteLine(SystemNudgeTest.ProgramName + ": Signalling the dispatcher to stop execution.");
                nudgeTest.isServiceStopping = true;
                serviceStopping.Set();

                // Wait for the dispatcher to stop.
                Console.WriteLine(SystemNudgeTest.ProgramName + ": Waiting for dispatcher to stop.");
                bool receivedSignal = dispatcherStopped.WaitOne(60 * 1000);

                if (receivedSignal)
                {
                    Console.WriteLine(SystemNudgeTest.ProgramName + ": Dispatcher signalled that it has stopped.");
                }
                else
                {
                    Console.WriteLine(SystemNudgeTest.ProgramName + ": Timed out while waiting for the Dispatcher to stop.");
                }

                // Uninstall the perf counters.
                PerformanceCountersInstaller perfCountersUnInstaller = new PerformanceCountersInstaller();
                perfCountersUnInstaller.Uninstall(typeof(StorageClientPerfCounters).Assembly, SavedState);
                PerformanceCountersInstaller nudgePerfCountersUnInstaller = new PerformanceCountersInstaller();
                nudgePerfCountersUnInstaller.Uninstall(typeof(SystemNudgePerfCounters).Assembly, nudgeInstallerSavedState);
            }
            else
            {
                SystemNudgeTest.DisplayUsage();
            }

            Console.WriteLine(SystemNudgeTest.ProgramName + ": Stopping.");
        }

        /// <summary>
        /// Check if the service is stopping.
        /// </summary>
        /// <returns>bool to indicate if the service is stopping</returns>
        public bool IsServiceStopping()
        {
            return this.isServiceStopping;
        }

        /// <summary>
        /// Display the usage of the program.
        /// </summary>
        private static void DisplayUsage()
        {
            Console.WriteLine("Usage: " + SystemNudgeTest.ProgramName + " <number of minutes to run>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeDispatcher\Properties\AssemblyInfo.cs ===
﻿// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-18</date>
// <summary>Contains the assembly information for the GameStateAzureStorage assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SystemNudgeDispatcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("40059204-969c-4798-8906-81143695d215")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SystemNudgeTest\Properties\AssemblyInfo.cs ===
﻿// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-18</date>
// <summary>Contains the assembly information for the SystemNudgeTest assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SystemNudgeTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("DCAAA4F9-ED75-40a9-B7A6-57C5AB46A0C4")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\TestGame\Page.xaml.cs ===
﻿//---------------------------------------------------------------------------------------------------------
// <copyright description="Simple Silverlight game of Tic-Tac-Toe" file="Page.xaml.cs" company="Microsoft">
// Copyright   .  All rights reserved.
// </copyright>
// <summary>Logic to play and handle user interaction and the webservice calls</summary>
//---------------------------------------------------------------------------------------------------------
namespace TicTacToe
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Text.RegularExpressions;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Input;
    using System.Windows.Markup;
    using System.Windows.Shapes;
    using System.Xml.Linq;

    /// <summary>
    /// The page that will display the game
    /// </summary>
    public partial class Page
    {
        #region Class variables
        /// <summary>
        /// Hardcoded URL for the Session Management REST service
        /// </summary>
        private const string SESSIONMANAMGENT_SERVICE_URL = "http://mpzoneweb.redmond.corp.microsoft.com:1001/GameSessions.svc";

        /// <summary>
        /// Hardcoded URL for the Game State / logic REST service
        /// </summary>
        private const string GAMESTATE_SERVICE_URL = "http://mpzoneweb.redmond.corp.microsoft.com:2001/GameState.svc";

        /// <summary>
        /// The REST client to extract/post requests against the Session Management service
        /// </summary>
        private WebClient restSessionClient;

        /// <summary>
        /// The REST client to extract/post requests against the Game State service
        /// </summary>
        private WebClient restGameStateClient;

        /// <summary>
        /// Flag to indicate if the game is over
        /// </summary>
        private bool gameOver;

        /// <summary>
        /// The line that displaying the winning move is made
        /// </summary>
        private Line winningLine;

        /// <summary>
        /// The total number of moves made since the game was started
        /// </summary>
        private int numMoves;
        #endregion

        /// <summary>
        /// Initializes a new instance of the Page class
        /// </summary>
        public Page()
        {
            // An empty board of TTT
            this.StrBoard = "---------";

            // The session ID should be populated by the OnPageLoaded callback once the first GetGameState call is successful.
            this.CurrentSessionID = String.Empty;

            InitializeComponent();
            Loaded += this.OnPageLoaded;
        }

        /// <summary>
        /// Finalizes an instance of the Page class
        /// </summary>
         ~Page()
        {
             // TODO: The webservice help says we should close the client proxy but it doesn't expose this method (just an async version)
        }

        /// <summary>
        /// Gets or sets the string representation of the T-T-T board
        /// </summary>
        public string StrBoard { get; set; }

        /// <summary>
        /// Gets or sets the session GUID for the current game
        /// </summary>
        public string CurrentSessionID { get; set; }

        /// <summary>
        /// Initiate the main objects used for the game
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void OnPageLoaded(object sender, RoutedEventArgs e)
        {
            // To support REST calls, we have to use the WebClient object or HttpWeb* objects
            this.restSessionClient = new WebClient();
            this.restSessionClient.AllowReadStreamBuffering = true; // complete the full download of the response text before triggering the callback
            this.restSessionClient.DownloadStringCompleted += this.OnSessionListRetrieved;
            this.restSessionClient.UploadStringCompleted += this.OnSessionCreated;

            // Get the active sessions list using the REST call for this user
            this.restSessionClient.DownloadStringAsync(
                new Uri(SESSIONMANAMGENT_SERVICE_URL + "/GameSessions/" + tbUsername.Text, UriKind.Absolute));

            // The board state and game moves are made using this REST client
            this.restGameStateClient = new WebClient();
            this.restGameStateClient.AllowReadStreamBuffering = true; // complete the full download of the response text before triggering the callback
            this.restGameStateClient.DownloadStringCompleted += this.OnGameStateRetrieved;
            this.restGameStateClient.UploadStringCompleted += this.OnGameMoveSubmitted;
        }

        /// <summary>
        /// Triggered when a new game session for the current user (identified as tbUsername) is submitted
        /// </summary>
        /// <param name="sender">Sender object</param>
        /// <param name="e">Event arguments</param>
        private void OnSessionCreated(object sender, UploadStringCompletedEventArgs e)
        {
            if (e.Error == null)
            {
                // Get the active sessions list using the REST call for this user
                this.restSessionClient.DownloadStringAsync(
                    new Uri(SESSIONMANAMGENT_SERVICE_URL + "/GameSessions/" + tbUsername.Text, UriKind.Absolute));
            }
        }

        /// <summary>
        /// Triggered by the webclient when the download is completed
        /// </summary>
        /// <param name="sender">Sender object</param>
        /// <param name="e">Event arguments</param>
        private void OnSessionListRetrieved(object sender, DownloadStringCompletedEventArgs e)
        {
            if (e.Error == null)
            {
                // Extract the session information from the response
                XDocument doc = XDocument.Parse(e.Result);
                XNamespace asyncSessionManagementNS = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.SessionManagementService";
                IEnumerable<GameSession> gameSessionList = (from xml in doc.Descendants(asyncSessionManagementNS + "GameSession")
                                                            let timestamp = xml.Element(asyncSessionManagementNS + "LastChanged").Value
                                                            orderby timestamp descending
                                                            select new GameSession
                                                           {
                                                               SessionID = xml.Element(asyncSessionManagementNS + "SessionID").Value.ToString(),
                                                               LastChanged = timestamp.ToString(),
                                                               UserList = null
                                                           });

                // Update the UI with the new list
                datagridSessions.DataContext = gameSessionList;
            }
        }

        /// <summary>
        /// Triggered when a game move has been submitted
        /// </summary>
        /// <param name="sender">Sender object</param>
        /// <param name="e">Event arguments</param>
        private void OnGameMoveSubmitted(object sender, UploadStringCompletedEventArgs e)
        {
            if (e.Error == null)
            {
                // Get the current board state as recorded by the trusted service
                this.restGameStateClient.DownloadStringAsync(
                    new Uri(GAMESTATE_SERVICE_URL + "/GameState/" + this.CurrentSessionID, UriKind.Absolute));

                tbDebugOutput.Text = e.Result.ToString();
            }
        }

        /// <summary>
        /// Triggered by the webclient when the download is completed
        /// </summary>
        /// <param name="sender">Sender object</param>
        /// <param name="e">Event arguments</param>
        private void OnGameStateRetrieved(object sender, DownloadStringCompletedEventArgs e)
        {
            if (e.Error == null)
            {
                // Reset the game
                this.ResetGame();

                // Extract the session information from the response
                XDocument doc = XDocument.Parse(e.Result);
                XNamespace asyncGameStateNS = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.GameStateService";
                IEnumerable<GameState> gameState = (from xml in doc.Descendants(asyncGameStateNS + "GameState")
                                                    select new GameState
                                                    {
                                                        SequenceNumber = Byte.Parse(xml.Element(asyncGameStateNS + "SequenceNumber").Value.ToString()),
                                                        SessionID = xml.Element(asyncGameStateNS + "SessionID").Value.ToString(),
                                                        State = xml.Element(asyncGameStateNS + "State").Value.ToString()
                                                    });

                // HACKY: Parse the result and extract the board state
                string gameStateXML = gameState.ElementAt(0).State;
                this.StrBoard = gameStateXML.Substring(26, 9);
                tbDebugOutput.Text = String.Format("Board state: {0}", this.StrBoard);

                // The sequence number indicates the total move count for this game
                this.numMoves = gameState.ElementAt(0).SequenceNumber;

                // Display the new board
                this.DrawBoard();
            }
        }

        #region User interaction event handlers
        /// <summary>
        /// Triggered when the user makes a new move (left-click the mouse button)
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void OnMoveMade(object sender, MouseButtonEventArgs e)
        {
            if (this.gameOver)
            {
                return;
            }

            // The position index we just clicked
            int position = (3 * int.Parse(((Rectangle)sender).Name[2].ToString())) + int.Parse(((Rectangle)sender).Name[1].ToString());

            // The client posts his move information to the game logic service
            string nextMoveURI = String.Format(GAMESTATE_SERVICE_URL + "/GameMove/{0}/{1}", this.CurrentSessionID, this.numMoves + 1);
            string moveString = String.Format(
                "<GameMove xmlns='http://schemas.datacontract.org/2004/07/AsyncMultiplayer.GameStateService'><MoveString><![CDATA[<Role>X</Role><Piece>{0}</Piece>]]></MoveString></GameMove>",
                position);

            // Create a new session request against the web service
            this.restGameStateClient.Headers[HttpRequestHeader.ContentType] = "text/xml";
            this.restGameStateClient.UploadStringAsync(new Uri(nextMoveURI, UriKind.Absolute), moveString);

            // Display the index corresponding to the new position for the X
            tbDebugOutput.Text = String.Format("Last played position: {0}", position);
        }

        /// <summary>
        /// Triggered when the user chooses a different game session to resume
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (e.AddedItems.Count > 0)
            {
                GameSession selectedSession = e.AddedItems[0] as GameSession;
                if (selectedSession != null)
                {
                    string strSessionID = selectedSession.SessionID.ToString();
                    this.CurrentSessionID = strSessionID;

                    // Reset the game and download the game state for the new session
                    // Get the current board state as recorded by the web service
                    this.restGameStateClient.DownloadStringAsync(
                        new Uri(GAMESTATE_SERVICE_URL + "/GameState/" + strSessionID, UriKind.Absolute));

                    // Display the selected session ID in the debug window
                    tbDebugOutput.Text = String.Format("Selected session: {0}", this.CurrentSessionID);
                }
            }
        }

        /// <summary>
        /// Triggered when user a presses the New Game button
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void OnNewGameButtonButtonClick(object sender, RoutedEventArgs e)
        {
            // Create a new session request against the web service
            this.restSessionClient.Headers[HttpRequestHeader.ContentType] = "text/xml";
            this.restSessionClient.UploadStringAsync(
                new Uri(SESSIONMANAMGENT_SERVICE_URL + "/GameSession/" + tbUsername.Text, UriKind.Absolute),
                String.Empty);
        }

        /// <summary>
        /// Triggered when a user clicks the Restart button
        /// </summary>
        /// <param name="sender">Parent object that triggered this event</param>
        /// <param name="e">Event arguments</param>
        private void OnRestartButtonClick(object sender, RoutedEventArgs e)
        {
            foreach (var x in LayoutRoot.Children)
            {
                if (x.GetType().ToString() == "System.Windows.Controls.Image" && x.GetValue(NameProperty).ToString() != "XamlBoard")
                {
                    x.Visibility = Visibility.Collapsed;
                }
            }

            foreach (var x in LayoutRoot.Children)
            {
                if (x.GetType().ToString() == "System.Windows.Shapes.Line")
                {
                    LayoutRoot.Children.Remove(x);
                    break;
                }
            }

            // Reset the game
            this.ResetGame();
        }
        #endregion

        /// <summary>
        /// Resets the internal varialbles to track the game state
        /// </summary>
        private void ResetGame()
        {
            this.WhosMove.Text = "Play!";
            this.gameOver = false;
            this.numMoves = 0;
            this.StrBoard = "---------";
        }

        /// <summary>
        /// Displays the images for the current board state
        /// </summary>
        private void DrawBoard()
        {
            // Remove the previous winning line if present
            LayoutBoard.Children.Remove(this.winningLine);

            // Reset the board and display the state as recorded by the service
            for (int i = 0; i < 9; i++)
            {
                string strXY = String.Format("{0}{1}", i % 3, i / 3);

                ((Image)LayoutRoot.FindName("Cross" + strXY)).Visibility = Visibility.Collapsed;
                ((Image)LayoutRoot.FindName("Ellipse" + strXY)).Visibility = Visibility.Collapsed;

                if (this.StrBoard[i] == 'X')
                {
                    ((Image)LayoutRoot.FindName("Cross" + strXY)).Visibility = Visibility.Visible;
                }
                else if (this.StrBoard[i] == 'O')
                {
                    ((Image)LayoutRoot.FindName("Ellipse" + strXY)).Visibility = Visibility.Visible;
                }
            }

            // Check if the AI or the user made a winning move 
            this.IsThereAWinner();
        }

        /// <summary>
        /// Simple check to see if there are three X's or O's in a row
        /// </summary>
        /// <returns>Returns true if there are three X's or O's in a row</returns>
        private bool IsThereAWinner()
        {
            const string WinningPattern =
                @"^(?<char>[XO])\k<char>\k<char>|^(?<char>[XO])...\k<char>...\k<char>|^(?<char>[XO])..\k<char>..\k<char>|" +
                @"^...(?<char>[XO])\k<char>\k<char>|^..(?<char>[XO]).\k<char>.\k<char>|^.(?<char>[XO])..\k<char>..\k<char>|" +
                @"^..(?<char>[XO])..\k<char>..\k<char>|^......(?<char>[XO])\k<char>\k<char>";

            if (Regex.IsMatch(this.StrBoard, WinningPattern))
            {
                this.DrawWinningLine();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Draw the winning line by creating a new XAML string and adding it to the layout
        /// </summary>
        private void DrawWinningLine()
        {
            Grid p = (Grid)LayoutBoard;

            string temp = string.Empty;

            const int halfWidthOfASquare = 55/2;
            int[] topLeftCoord = { 145, halfWidthOfASquare};
            int[] topRightCoord = { 255, halfWidthOfASquare};
            int[] topMiddleCoord = { topLeftCoord[0] + ((topRightCoord[0] - topLeftCoord[0]) / 2), halfWidthOfASquare};


            int[] bottomLeftCoord = { topLeftCoord[0], (int)p.ActualHeight - halfWidthOfASquare};
            int[] bottomRightCoord = { topRightCoord[0], (int)p.ActualHeight - halfWidthOfASquare};
            int[] bottomMiddleCoord = { bottomLeftCoord[0] + ((bottomRightCoord[0] - bottomLeftCoord[0]) / 2), (int)p.ActualHeight - halfWidthOfASquare};

            int[] middleLeftCoord = {topLeftCoord[0], topLeftCoord[1] + ((bottomLeftCoord[1] - topLeftCoord[1])/2)};
            int[] middleRightCoord = {topRightCoord[0], topLeftCoord[1] + ((bottomLeftCoord[1] - topLeftCoord[1]) / 2) };


            const string XAML = @"<Line " +
                             "xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation' " +
                             "xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml' " +
                             "x:name='winningLine' " +
                             "Stroke='Black' " +
                             "Grid.RowSpan='3' " +
                             "Grid.ColumnSpan='3' " +
                             "StrokeThickness='5' " +
                             "X1='[X1]' Y1='[Y1]' " +
                             "X2='[X2]' Y2='[Y2]' " +
                             "StrokeStartLineCap='Round' StrokeEndLineCap='Round' />";

            if (Regex.IsMatch(this.StrBoard, @"^(?<char>[XO])..\k<char>..\k<char>"))
            {
                temp = XAML.Replace("[X1]", topLeftCoord[0] + "");
                temp = temp.Replace("[X2]", bottomLeftCoord[0] + "");
                temp = temp.Replace("[Y1]", topLeftCoord[1] + "");
                temp = temp.Replace("[Y2]", bottomLeftCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^(?<char>[XO])...\k<char>...\k<char>"))
            {
                temp = XAML.Replace("[X1]", topLeftCoord[0] + "");
                temp = temp.Replace("[X2]", bottomRightCoord[0] + "");
                temp = temp.Replace("[Y1]", topLeftCoord[1] + "");
                temp = temp.Replace("[Y2]", bottomRightCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^(?<char>[XO])\k<char>\k<char>"))
            {
                temp = XAML.Replace("[X1]", topLeftCoord[0] + "");
                temp = temp.Replace("[X2]", topRightCoord[0] + "");
                temp = temp.Replace("[Y1]", topLeftCoord[1] + "");
                temp = temp.Replace("[Y2]", topRightCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^.(?<char>[XO])..\k<char>..\k<char>"))
            {
                temp = XAML.Replace("[X1]", topMiddleCoord[0] + "");
                temp = temp.Replace("[X2]", bottomMiddleCoord[0] + "");
                temp = temp.Replace("[Y1]", topMiddleCoord[1] + "");
                temp = temp.Replace("[Y2]", bottomMiddleCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^..(?<char>[XO])..\k<char>..\k<char>"))
            {
                temp = XAML.Replace("[X1]", topRightCoord[0] + "");
                temp = temp.Replace("[X2]", bottomRightCoord[0] + "");
                temp = temp.Replace("[Y1]", topRightCoord[1] + "");
                temp = temp.Replace("[Y2]", bottomRightCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^...(?<char>[XO])\k<char>\k<char>"))
            {
                temp = XAML.Replace("[X1]", middleLeftCoord[0] + "");
                temp = temp.Replace("[X2]", middleRightCoord[0] + "");
                temp = temp.Replace("[Y1]", middleRightCoord[1] + "");
                temp = temp.Replace("[Y2]", middleLeftCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^......(?<char>[XO])\k<char>\k<char>"))
            {
                temp = XAML.Replace("[X1]", bottomLeftCoord[0] + "");
                temp = temp.Replace("[X2]", bottomRightCoord[0] + "");
                temp = temp.Replace("[Y1]", bottomLeftCoord[1] + "");
                temp = temp.Replace("[Y2]", bottomRightCoord[1] + "");
            }
            else if (Regex.IsMatch(this.StrBoard, @"^..(?<char>[XO]).\k<char>.\k<char>"))
            {
                temp = XAML.Replace("[X1]", topRightCoord[0] + "");
                temp = temp.Replace("[X2]", bottomLeftCoord[0] + "");
                temp = temp.Replace("[Y1]", topRightCoord[1] + "");
                temp = temp.Replace("[Y2]", bottomLeftCoord[1] + "");
            }

            if (temp != string.Empty)
            {
                this.gameOver = true;
                this.StrBoard = "---------";
                this.winningLine = (Line)XamlReader.Load(temp);
                LayoutBoard.Children.Add(this.winningLine);


                this.WhosMove.Text = "Game Over!";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\AdapterStream.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;
using System.ServiceModel;
using AsyncResult = Microsoft.ServiceModel.Web.AsyncResult;
using System.Text;

namespace System.IO
{
    public sealed class AdapterStream : Stream
    {
        static AsyncCallback onWriterInvokeCompleted = null;

        Action<Stream> writer;
        object thisLock = new object();
        PendingIOQueue readQueue;
        PendingIOQueue writeQueue;
        bool noMoreData;
        bool wasWriterInvoked;
        Exception writerException;

        public AdapterStream(Action<Stream> writer)
            : base()
        {
            if (writer == null)
            {
                throw new ArgumentNullException("writer");
            }
            this.writer = writer;
            this.readQueue = new PendingIOQueue();
            this.writeQueue = new PendingIOQueue();
        }

        public AdapterStream(Action<TextWriter> writer, Encoding encoding)
            : this(new TextWriterAction(writer, encoding).WriteToStream)
        {
        }

        public override bool CanRead
        {
            get
            {
                return true;
            }
        }
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }
        public override long Length
        {
            get
            {
                throw new NotSupportedException();
            }
        }
        public override long Position 
        {
            get
            {
                throw new NotSupportedException();
            }
            set
            {
                throw new NotSupportedException();
            }
        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if (offset >= buffer.Length)
            {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (offset + count > buffer.Length)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            ReadAsyncResult ar = new ReadAsyncResult(callback, state);
            bool shouldInvokeWriter;
            if (!TryCompleteReadRequest(buffer, offset, count, ar, out shouldInvokeWriter))
            {
                if (shouldInvokeWriter)
                {
                    InvokeWriter();
                }
            }
            return ar;
        }
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            throw new NotSupportedException();
        }
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (disposing)
                {
                    lock (this.thisLock)
                    {
                        this.readQueue.Clear();
                        this.writeQueue.Clear();
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }
        public override int EndRead(IAsyncResult asyncResult)
        {
            return ReadAsyncResult.End(asyncResult);
        }
        public override void EndWrite(IAsyncResult asyncResult)
        {
            throw new NotSupportedException();
        }
        public override void Flush()
        {
            throw new NotSupportedException();
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if (offset >= buffer.Length)
            {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (offset + count > buffer.Length)
            {
                throw new ArgumentOutOfRangeException("count");
            }

            ReadSyncResult readResult = new ReadSyncResult();
            bool shouldInvokeWriter;
            if (!TryCompleteReadRequest(buffer, offset, count, readResult, out shouldInvokeWriter))
            {
                if (shouldInvokeWriter)
                {
                    InvokeWriter();
                }
            }
            return readResult.WaitFor();
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException();
        }

        bool TryCompleteReadRequest(byte[] buffer, int offset, int count, IIORequestEventsHandler handler,
            out bool shouldInvokeWriter)
        {
            int numOfBytesRead = 0;
            shouldInvokeWriter = false;

            lock (this.thisLock)
            {
                while ((count > 0) && this.writeQueue.HasPendingRequests)
                {
                    if (this.writeQueue.Head.Buffer == null)
                    {
                        // This is a pending flush request, we just need to complete it
                        this.writeQueue.Dequeue().Complete(0);
                    }
                    else if (this.writeQueue.Head.Count <= count)
                    {
                        int bytesToCopy = this.writeQueue.Head.Count;
                        Buffer.BlockCopy(this.writeQueue.Head.Buffer, this.writeQueue.Head.Offset,
                            buffer, offset, bytesToCopy);
                        numOfBytesRead += bytesToCopy;
                        offset += bytesToCopy;
                        count -= bytesToCopy;
                        this.writeQueue.Dequeue().Complete(bytesToCopy);
                    }
                    else
                    {
                        Buffer.BlockCopy(this.writeQueue.Head.Buffer, this.writeQueue.Head.Offset,
                            buffer, offset, count);
                        numOfBytesRead += count;
                        this.writeQueue.Head.Progress(count);
                        handler.OnCompletion(true, numOfBytesRead);
                        return true;
                    }
                }

                if ((this.noMoreData) || (numOfBytesRead > 0))
                {
                    if (this.writerException != null)
                    {
                        handler.OnException(this.writerException);
                        this.writerException = null;
                    }
                    else
                    {
                        // Clearing the queue from leading flush request :
                        while (this.writeQueue.HasPendingRequests && (this.writeQueue.Head.Buffer == null))
                        {
                            this.writeQueue.Dequeue().Complete(0);
                        }

                        handler.OnCompletion(true, numOfBytesRead);
                    }
                    return true;
                }
                else
                {
                    this.readQueue.Enqueue(buffer, offset, count, handler);
                    if (!this.wasWriterInvoked)
                    {
                        this.wasWriterInvoked = true;
                        shouldInvokeWriter = true;
                    }
                    return false;
                }
            }
        }
        bool TryCompleteWriteRequest(byte[] buffer, int offset, int count, IIORequestEventsHandler handler)
        {
            int numOfBytesWritten = 0;

            lock (this.thisLock)
            {
                while ((count > 0) && this.readQueue.HasPendingRequests)
                {
                    if (this.readQueue.Head.Count < count)
                    {
                        int bytesToCopy = this.readQueue.Head.Count;
                        Buffer.BlockCopy(buffer, offset, this.readQueue.Head.Buffer, this.readQueue.Head.Offset, 
                            bytesToCopy);
                        numOfBytesWritten += bytesToCopy;
                        offset += bytesToCopy;
                        count -= bytesToCopy;
                        this.readQueue.Dequeue().Complete(bytesToCopy);
                    }
                    else
                    {
                        Buffer.BlockCopy(buffer, offset, this.readQueue.Head.Buffer, this.readQueue.Head.Offset, 
                            count);
                        this.readQueue.Dequeue().Complete(count);
                        handler.OnCompletion(true, numOfBytesWritten + count);
                        return true;
                    }
                }

                if (count > 0)
                {
                    this.writeQueue.Enqueue(buffer, offset, count, handler);
                    return false;
                }
                else
                {
                    handler.OnCompletion(true, numOfBytesWritten);
                    return true;
                }
            }
        }
        bool TryCompleteFlushRequest(IIORequestEventsHandler handler)
        {
            lock (this.thisLock)
            {
                if (this.writeQueue.HasPendingRequests)
                {
                    this.writeQueue.Enqueue(null, 0, 0, handler);
                    return false;
                }
                else
                {
                    handler.OnCompletion(true, 0);
                    return true;
                }
            }
        }
        void InvokeWriter()
        {
            bool writerWasInvoked = false;
            try
            {
                SourceStream srcStream = new SourceStream(this);
                if (onWriterInvokeCompleted == null)
                {
                    onWriterInvokeCompleted = new AsyncCallback(OnWriterInvokeCompleted);
                }
                IAsyncResult invokeResult = this.writer.BeginInvoke(srcStream,
                    onWriterInvokeCompleted, srcStream);
                if (invokeResult.CompletedSynchronously)
                {
                    this.writer.EndInvoke(invokeResult);
                    CompleteWriterInvocation(srcStream);
                }

                writerWasInvoked = true;
            }
            finally
            {
                // If something went wrong, let's reset the state :
                if (!writerWasInvoked)
                    this.wasWriterInvoked = false;
            }
        }

        void CompleteWriterInvocation(SourceStream srcStream)
        {
            srcStream.Close();
            lock (this.thisLock)
            {
                this.noMoreData = true;
                while (this.readQueue.HasPendingRequests)
                {
                    if (this.writerException != null)
                    {
                        this.readQueue.Dequeue().CompleteWithException(srcStream.Owner.writerException);
                        this.writerException = null;
                    }
                    else
                    {
                        this.readQueue.Dequeue().Complete(0);
                    }
                }
            }

        }

        static void OnWriterInvokeCompleted(IAsyncResult ar)
        {
            if (ar.CompletedSynchronously)
            {
                return;
            }

            SourceStream srcStream = (SourceStream)ar.AsyncState;

            try
            {
                srcStream.Owner.writer.EndInvoke(ar);
            }
            catch (Exception exception)
            {
                srcStream.Owner.writerException = exception;
            }
            srcStream.Owner.CompleteWriterInvocation(srcStream);
        }

        interface IIORequestEventsHandler
        {
            void OnEnquing();
            void OnCompletion(bool completedSynchronously, int numOfBytesTransferred);
            void OnException(Exception exception);
        }

        class PendingIORequest
        {
            byte[] buffer;
            int offset;
            int count;
            int numOfBytesTransferred;
            IIORequestEventsHandler handler;

            public byte[] Buffer
            {
                get
                {
                    return this.buffer;
                }
            }
            public int Offset
            {
                get
                {
                    return this.offset;
                }
            }
            public int Count
            {
                get
                {
                    return this.count;
                }
            }

            public PendingIORequest(byte[] buffer, int offset, int count, IIORequestEventsHandler handler)
            {
                this.buffer = buffer;
                this.offset = offset;
                this.count = count;
                this.numOfBytesTransferred = 0;
                this.handler = handler;
            }

            public void Progress(int numOfBytesTransferred)
            {
                Debug.Assert(numOfBytesTransferred <= this.count, "Can't progress more then expected by count");
                this.count -= numOfBytesTransferred;
                this.offset += numOfBytesTransferred;
                this.numOfBytesTransferred += numOfBytesTransferred;
            }
            public void Complete(int numOfBytesTransferred)
            {
                Debug.Assert(numOfBytesTransferred <= this.count, "Can't progress more then expected by count");
                this.numOfBytesTransferred += numOfBytesTransferred;
                this.handler.OnCompletion(false, this.numOfBytesTransferred);
            }
            public void CompleteWithException(Exception exception)
            {
                this.handler.OnException(exception);
            }
        }
        class PendingIOQueue
        {
            bool hasPendingRequests;
            PendingIORequest nextRequest;
            Queue<PendingIORequest> pendingRequests;

            public bool HasPendingRequests
            {
                get
                {
                    return this.hasPendingRequests;
                }
            }
            public PendingIORequest Head
            {
                get
                {
                    Debug.Assert(this.hasPendingRequests, "Can't peek into an empty queue");
                    return this.nextRequest;
                }
            }

            public void Enqueue(byte[] buffer, int offset, int count, IIORequestEventsHandler eventsHandler)
            {
                eventsHandler.OnEnquing();

                if (this.hasPendingRequests)
                {
                    if (this.pendingRequests == null)
                    {
                        this.pendingRequests = new Queue<PendingIORequest>();
                    }
                    this.pendingRequests.Enqueue(new PendingIORequest(buffer, offset, count, eventsHandler));
                }
                else
                {
                    this.nextRequest = new PendingIORequest(buffer, offset, count, eventsHandler);
                    this.hasPendingRequests = true;
                }
            }
            public PendingIORequest Dequeue()
            {
                Debug.Assert(this.hasPendingRequests, "Can't dequeue from an empty queue");

                PendingIORequest result = this.nextRequest;
                if ((this.pendingRequests != null) && (this.pendingRequests.Count > 0))
                {
                    this.nextRequest = this.pendingRequests.Dequeue();
                }
                else
                {
                    this.hasPendingRequests = false;
                }
                return result;
            }
            public void Clear()
            {
                if (this.hasPendingRequests)
                {
                    this.nextRequest.Complete(0);
                    this.hasPendingRequests = false;
                }
                if (this.pendingRequests != null)
                {
                    while (this.pendingRequests.Count > 0)
                    {
                        this.pendingRequests.Dequeue().Complete(0);
                    }
                }
            }
        }

        class ReadSyncResult : IIORequestEventsHandler, IDisposable
        {
            Exception exception;
            int numOfBytesRead;
            ManualResetEvent completionEvent;

            public void OnEnquing()
            {
                this.completionEvent = new ManualResetEvent(false);
            }
            public void OnCompletion(bool completedSynchronously, int numOfBytesTransferred)
            {
                this.numOfBytesRead = numOfBytesTransferred;
                if (this.completionEvent != null)
                {
                    this.completionEvent.Set();
                }
            }
            public void OnException(Exception exception)
            {
                this.exception = exception;
                if (this.completionEvent != null)
                {
                    this.completionEvent.Set();
                }
            }

            public int WaitFor()
            {
                if (this.completionEvent != null)
                {
                    this.completionEvent.WaitOne();
                }
                if (this.exception != null)
                {
                    throw this.exception;
                }
                return this.numOfBytesRead;
            }

            public void Dispose()
            {
                if (this.completionEvent != null)
                {
                    this.completionEvent.Close();
                }
            }
        }
        class ReadAsyncResult : AsyncResult, IIORequestEventsHandler
        {
            int numOfBytesRead;

            public ReadAsyncResult(AsyncCallback callback, object state)
                : base(callback, state)
            {
            }

            public static int End(IAsyncResult result)
            {
                return AsyncResult.End<ReadAsyncResult>(result).numOfBytesRead;
            }

            public void OnEnquing()
            {
            }
            public void OnCompletion(bool completedSynchronously, int numOfBytesTransferred)
            {
                this.numOfBytesRead = numOfBytesTransferred;
                base.Complete(completedSynchronously);
            }
            public void OnException(Exception exception)
            {
                base.Complete(false, exception);
            }
        }
        class WriteSyncResult : IIORequestEventsHandler, IDisposable
        {
            Exception exception;
            ManualResetEvent completionEvent;

            public void OnEnquing()
            {
                this.completionEvent = new ManualResetEvent(false);
            }
            public void OnCompletion(bool completedSynchronously, int numOfBytesTransferred)
            {
                if (this.completionEvent != null)
                {
                    this.completionEvent.Set();
                }
            }
            public void OnException(Exception exception)
            {
                this.exception = exception;
                if (this.completionEvent != null)
                {
                    this.completionEvent.Set();
                }
            }

            public void WaitFor()
            {
                if (this.completionEvent != null)
                {
                    this.completionEvent.WaitOne();
                }
                if (this.exception != null)
                {
                    throw this.exception;
                }
            }

            public void Dispose()
            {
                if (this.completionEvent != null)
                {
                    this.completionEvent.Close();
                }
            }
        }
        class WriteAsyncResult : AsyncResult, IIORequestEventsHandler
        {
            public WriteAsyncResult(AsyncCallback callback, object state)
                : base(callback, state)
            {
            }

            public static void End(IAsyncResult result)
            {
                AsyncResult.End<WriteAsyncResult>(result);
            }

            public void OnEnquing()
            {
            }
            public void OnCompletion(bool completedSynchronously, int numOfBytesTransferred)
            {
                base.Complete(completedSynchronously);
            }
            public void OnException(Exception exception)
            {
                base.Complete(false, exception);
            }
        }

        class SourceStream : Stream
        {
            AdapterStream owner;

            public SourceStream(AdapterStream owner)
                : base()
            {
                this.owner = owner;
            }

            public override bool CanRead
            {
                get
                {
                    return false;
                }
            }
            public override bool CanSeek
            {
                get
                {
                    return false;
                }
            }
            public override bool CanWrite
            {
                get
                {
                    return true;
                }
            }
            public override long Length
            {
                get
                {
                    throw new NotSupportedException();
                }
            }
            public override long Position 
            {
                get
                {
                    throw new NotSupportedException();
                    
                }
                set
                {
                    throw new NotSupportedException();
                }
            }

            internal AdapterStream Owner
            {
                get
                {
                    return this.owner;
                }
            }

            public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
            {
                throw new NotSupportedException();
            }
            public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
            {
                if (buffer == null)
                {
                    throw new ArgumentNullException("buffer");
                }
                if (offset >= buffer.Length)
                {
                    throw new ArgumentOutOfRangeException("offset");
                }
                if (offset + count > buffer.Length)
                {
                    throw new ArgumentOutOfRangeException("count");
                }

                WriteAsyncResult ar = new WriteAsyncResult(callback, state);
                this.owner.TryCompleteWriteRequest(buffer, offset, count, ar);
                return ar;
            }
           
            public override int EndRead(IAsyncResult asyncResult)
            {
                throw new NotSupportedException();
            }
            public override void EndWrite(IAsyncResult asyncResult)
            {
                WriteAsyncResult.End(asyncResult);
            }
            public override void Flush()
            {
                WriteSyncResult writeResult = new WriteSyncResult();
                this.owner.TryCompleteFlushRequest(writeResult);
                writeResult.WaitFor();
            }
            public override int Read(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }
            public override long Seek(long offset, SeekOrigin origin)
            {
                throw new NotSupportedException();
            }
            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }
            public override void Write(byte[] buffer, int offset, int count)
            {
                if (buffer == null)
                {
                    throw new ArgumentNullException("buffer");
                }
                if (offset >= buffer.Length)
                {
                    throw new ArgumentOutOfRangeException("offset");
                }
                if (offset + count > buffer.Length)
                {
                    throw new ArgumentOutOfRangeException("count");
                }

                WriteSyncResult writeResult = new WriteSyncResult();
                this.owner.TryCompleteWriteRequest(buffer, offset, count, writeResult);
                writeResult.WaitFor();
            }
        }

        class TextWriterAction
        {
            Action<TextWriter> writer;
            Encoding encoding;
            
            public TextWriterAction(Action<TextWriter> writer, Encoding encoding)
            {
                this.writer = writer;
                this.encoding = encoding;
            }

            public void WriteToStream(Stream s)
            {
                if (this.writer != null)
                {
                    using (TextWriter textWriter = new StreamWriter(s, encoding))
                    {
                        this.writer(textWriter);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\TestGame\Properties\AssemblyInfo.cs ===
﻿//--------------------------------------------------------------------------------------------------------
// <copyright description="Simple Silverlight game of Tic-Tac-Toe" file="AssemblyInfo.cs" company="Microsoft">
// Copyright   .  All rights reserved.
// </copyright>
// <summary>Assembly Info</summary>
//--------------------------------------------------------------------------------------------------------
using System.Reflection;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TicTacToe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TicTacToe")]
[assembly: AssemblyCopyright("Copyright ©  2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\TestGame\GameState.cs ===
﻿//---------------------------------------------------------------------------------------------------------
// <copyright description="Simple Silverlight game of Tic-Tac-Toe" file="GameState.cs" company="Microsoft">
// Copyright   .  All rights reserved.
// </copyright>
// <summary>The GameState object</summary>
//---------------------------------------------------------------------------------------------------------
namespace TicTacToe
{
    /// <summary>
    /// The GameState object
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.GameStateService")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.GameStateService", IsNullable = false)]
    public partial class GameState
    {
        /// <summary>
        /// The current move number since the game start (first move is 0)
        /// </summary>
        private byte sequenceNumberField;
        
        /// <summary>
        /// The string GUID identifying this game session
        /// </summary>
        private string sessionIDField;

        /// <summary>
        /// The current state of the game board/play
        /// </summary>
        private string stateField;

        /// <summary>
        /// Gets or sets the sequence number representing the move count since the start of the game
        /// </summary>
        public byte SequenceNumber
        {
            get
            {
                return this.sequenceNumberField;
            }

            set
            {
                this.sequenceNumberField = value;
            }
        }

        /// <summary>
        /// Gets or sets the string GUID identifying this game session
        /// </summary>
        public string SessionID
        {
            get
            {
                return this.sessionIDField;
            }

            set
            {
                this.sessionIDField = value;
            }
        }

        /// <summary>
        /// Gets or sets the current state of the game board/play
        /// </summary>
        public string State
        {
            get
            {
                return this.stateField;
            }

            set
            {
                this.stateField = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\AssemblyAttributes.cs ===
//----------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//----------------------------------------------------------------

using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyCopyright("\x00a9 Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyDescription("Microsoft WCF REST Service Development API")]
[assembly: AssemblyProduct("Microsoft (R) WCF REST Starter Kit CodePlex Preview 2")]
[assembly: AssemblyTitle("Microsoft.ServiceModel.Web.dll")]

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0.0")]

[assembly: CLSCompliant(true)]
[assembly: ComVisible(false)]

[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityCritical(SecurityCriticalScope.Explicit)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, Execution = true)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\AsyncResult.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System.Threading;
    using System.ServiceModel.Diagnostics;
    using System.Diagnostics;
    using System;


    abstract class AsyncResult : IAsyncResult
    {
        AsyncCallback callback;
        object state;
        bool completedSynchronously;
        bool endCalled;
        Exception exception;
        bool isCompleted;
        ManualResetEvent manualResetEvent;
        object thisLock;

        protected AsyncResult(AsyncCallback callback, object state)
        {
            this.callback = callback;
            this.state = state;
            this.thisLock = new object();
        }

        public object AsyncState
        {
            get
            {
                return state;
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
            {
                if (manualResetEvent != null)
                {
                    return manualResetEvent;
                }

                lock (ThisLock)
                {
                    if (manualResetEvent == null)
                    {
                        manualResetEvent = new ManualResetEvent(isCompleted);
                    }
                }

                return manualResetEvent;
            }
        }

        public bool CompletedSynchronously
        {
            get
            {
                return completedSynchronously;
            }
        }

        public bool HasCallback
        {
            get
            {
                return this.callback != null;
            }
        }

        public bool IsCompleted
        {
            get
            {
                return isCompleted;
            }
        }

        object ThisLock
        {
            get
            {
                return this.thisLock;
            }
        }

        protected void Complete(bool completedSynchronously)
        {
            if (isCompleted)
            {
                // It's a bug to call Complete twice.
                Debug.Assert(false, "AsyncResult complete called twice for the same operation.");
                throw new SystemException("operation is already completed");
            }

            this.completedSynchronously = completedSynchronously;

            if (completedSynchronously)
            {
                // If we completedSynchronously, then there's no chance that the manualResetEvent was created so
                // we don't need to worry about a race
                Debug.Assert(this.manualResetEvent == null, "No ManualResetEvent should be created for a synchronous AsyncResult.");
                this.isCompleted = true;
            }
            else
            {
                lock (ThisLock)
                {
                    this.isCompleted = true;
                    if (this.manualResetEvent != null)
                    {
                        this.manualResetEvent.Set();
                    }
                }
            }

            if (callback != null)
            {
                try
                {
                    callback(this);
                }
                catch (Exception e)
                {
                    throw new SystemException("Callback threw an exception", e);
                }
            }
        }

        protected void Complete(bool completedSynchronously, Exception exception)
        {
            this.exception = exception;
            Complete(completedSynchronously);
        }

        protected static TAsyncResult End<TAsyncResult>(IAsyncResult result)
            where TAsyncResult : AsyncResult
        {
            if (result == null)
            {
                throw new ArgumentNullException("result");
            }

            TAsyncResult asyncResult = result as TAsyncResult;

            if (asyncResult == null)
            {
                throw new ArgumentException("result", "bad async result");
            }

            if (asyncResult.endCalled)
            {
                throw new InvalidOperationException("Async operation has already ended");
            }
            asyncResult.endCalled = true;

            if (!asyncResult.isCompleted)
            {
                asyncResult.AsyncWaitHandle.WaitOne();
            }

            if (asyncResult.manualResetEvent != null)
            {
                asyncResult.manualResetEvent.Close();
            }

            if (asyncResult.exception != null)
            {
                throw asyncResult.exception;
            }

            return asyncResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\CurrentPrincipalRequestInterceptor.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.Security.Principal;
using System.IdentityModel.Policy;

namespace Microsoft.ServiceModel.Web
{
    public class CurrentPrincipalRequestInterceptor : RequestInterceptor
    {
        public CurrentPrincipalRequestInterceptor()
            : base(true)
        {
        }

        public override void ProcessRequest(ref RequestContext requestContext)
        {
            if (requestContext == null || requestContext.RequestMessage == null)
            {
                return;
            }
            Message message = requestContext.RequestMessage;
            if (message.Properties.Security == null)
            {
                // check if there is an IPrincipal in HttpContext.Current
                if (HttpContext.Current != null)
                {
                    IPrincipal currentUser = HttpContext.Current.User;
                    if (currentUser != null)
                    {
                        List<IAuthorizationPolicy> policies = new List<IAuthorizationPolicy>();
                        policies.Add(new PrincipalAuthorizationPolicy(currentUser));
                        ServiceSecurityContext securityContext = new ServiceSecurityContext(policies.AsReadOnly());
                        message.Properties.Security = new SecurityMessageProperty() { ServiceSecurityContext = securityContext };
                    }
                }
            }
        }

        class PrincipalAuthorizationPolicy : IAuthorizationPolicy
        {
            string id = Guid.NewGuid().ToString();
            IPrincipal user;

            public PrincipalAuthorizationPolicy(IPrincipal user)
            {
                this.user = user;
            }


            public ClaimSet Issuer
            {
                get { return ClaimSet.System; }
            }

            public string Id
            {
                get { return this.id; }
            }

            public bool Evaluate(EvaluationContext evaluationContext, ref object state)
            {
                evaluationContext.AddClaimSet(this, new DefaultClaimSet(Claim.CreateNameClaim(user.Identity.Name)));
                evaluationContext.Properties["Identities"] = new List<IIdentity>(new IIdentity[] { user.Identity });
                evaluationContext.Properties["Principal"] = user;
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\CachingParameterInspector.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Web;
using System.ServiceModel.Syndication;
using System.IO;
using System.Runtime.Serialization;
using System.Web.Configuration;
using System.Web.UI;
using System.Web.Caching;

namespace Microsoft.ServiceModel.Web
{
    class CachingParameterInspector : IParameterInspector
    {
        OutputCacheProfile cacheProfile;

        public CachingParameterInspector(OutputCacheProfile cacheProfile)
        {
            this.cacheProfile = cacheProfile;
        }

        bool ShouldCacheOnServer(OutputCacheLocation location)
        {
            return (location == OutputCacheLocation.Any || location == OutputCacheLocation.Server || location == OutputCacheLocation.ServerAndClient);
        }

        internal static SqlCacheDependency[] CreateSqlDependencies(string sqlDependency)
        {
            string[] dbTablePairs = sqlDependency.Split(',');
            List<SqlCacheDependency> dependencies = new List<SqlCacheDependency>();
            foreach (string dbTablePair in dbTablePairs)
            {
                string db = null;
                string table = null;
                int separator = dbTablePair.IndexOf(':');
                if (separator > 0)
                {
                    db = dbTablePair.Substring(0, separator);
                    table = dbTablePair.Substring(separator + 1);
                }
                else
                {
                    db = null;
                    table = dbTablePair;
                }
                dependencies.Add(new SqlCacheDependency(db, table));
            }
            return dependencies.ToArray();
        }

        public void AfterCall(string operationName, object[] outputs, object returnValue, object correlationState)
        {
            switch (this.cacheProfile.Location)
            {
                case OutputCacheLocation.Any:
                    HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.Public);
                    break;
                case OutputCacheLocation.Client:
                    HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.Private);
                    break;
                case OutputCacheLocation.Downstream:
                    HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.Public);
                    break;
                case OutputCacheLocation.None:
                    HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.NoCache);
                    break;
                case OutputCacheLocation.Server:
                    HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.ServerAndNoCache);
                    break;
                case OutputCacheLocation.ServerAndClient:
                    HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.ServerAndPrivate);
                    break;
                default:
                    throw new NotSupportedException();
            }
            if (cacheProfile.Duration > 0)
            {
                TimeSpan age = TimeSpan.FromSeconds(cacheProfile.Duration);
                HttpContext.Current.Response.Cache.SetExpires(DateTime.Now + age);
                if (ShouldCacheOnServer(this.cacheProfile.Location))
                {
                    HttpContext.Current.Response.Cache.SetMaxAge(age);
                    HttpContext.Current.Response.Cache.SetValidUntilExpires(true);
                }
            }
            if (cacheProfile.NoStore)
            {
                HttpContext.Current.Response.Cache.SetNoStore();
            }
            if (ShouldCacheOnServer(this.cacheProfile.Location) && !string.IsNullOrEmpty(cacheProfile.SqlDependency))
            {
                if (string.Equals(cacheProfile.SqlDependency, "CommandNotification", StringComparison.OrdinalIgnoreCase))
                {
                    throw new NotSupportedException("CommandNotification is not supported as a valid sql dependency currently");
                }
                else
                {
                    HttpContext.Current.Response.AddCacheDependency(CreateSqlDependencies(cacheProfile.SqlDependency));
                    HttpContext.Current.Response.Cache.SetValidUntilExpires(true);
                }
            }
            if (!string.IsNullOrEmpty(cacheProfile.VaryByParam))
            {
                string[] parameters = cacheProfile.VaryByParam.Split(',');
                foreach (string parameter in parameters)
                {
                    HttpContext.Current.Response.Cache.VaryByParams[parameter] = true;
                }
            }
            if (!string.IsNullOrEmpty(cacheProfile.VaryByHeader))
            {
                string[] headers = cacheProfile.VaryByHeader.Split(',');
                foreach (string header in headers)
                {
                    HttpContext.Current.Response.Cache.VaryByHeaders[header] = true;
                }
            }
            if (!string.IsNullOrEmpty(cacheProfile.VaryByCustom))
            {
                HttpContext.Current.Response.Cache.SetVaryByCustom(cacheProfile.VaryByCustom);
            }
        }

        public object BeforeCall(string operationName, object[] inputs)
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\HelpExampleGenerator.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Globalization;
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.IO;
using System.Net;
using System.Runtime;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Syndication;
using System.ServiceModel.Web;
using System.Text;
using System.Web;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace Microsoft.ServiceModel.Web
{
    class HelpExampleGenerator
    {
        const int MaxDepthLevel = 256;
        public const string XmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
        public const string XmlNamespacePrefix = "xmlns";
        public const string XmlSchemaInstanceNamespace = "http://www.w3.org/2001/XMLSchema-instance";
        public const string XmlSchemaInstanceNil = "nil";
        public const string XmlSchemaInstanceType = "type";

        static Dictionary<Type, Action<XmlSchemaObject, HelpExampleGeneratorContext>> XmlObjectHandler = new Dictionary<Type, Action<XmlSchemaObject, HelpExampleGeneratorContext>>
        {                
            { typeof(XmlSchemaComplexContent), ContentHandler },
            { typeof(XmlSchemaSimpleContent), ContentHandler },
            { typeof(XmlSchemaSimpleTypeRestriction), SimpleTypeRestrictionHandler },                
            { typeof(XmlSchemaChoice), ChoiceHandler },
            // Nothing to do, inheritance is resolved by Schema compilation process                
            { typeof(XmlSchemaComplexContentExtension), EmptyHandler },
            { typeof(XmlSchemaSimpleContentExtension), EmptyHandler },
            // No need to generate XML for these objects
            { typeof(XmlSchemaAny), EmptyHandler },
            { typeof(XmlSchemaAnyAttribute), EmptyHandler },
            { typeof(XmlSchemaAnnotated), EmptyHandler },
            { typeof(XmlSchema), EmptyHandler },
            // The following schema objects are not handled            
            { typeof(XmlSchemaAttributeGroup), ErrorHandler },
            { typeof(XmlSchemaAttributeGroupRef), ErrorHandler },
            { typeof(XmlSchemaComplexContentRestriction), ErrorHandler },
            { typeof(XmlSchemaSimpleContentRestriction), ErrorHandler },
            // Enumerations are supported by the GenerateContentForSimpleType
            { typeof(XmlSchemaEnumerationFacet), EmptyHandler },
            { typeof(XmlSchemaMaxExclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaMaxInclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaMinExclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaMinInclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaNumericFacet), ErrorHandler },
            { typeof(XmlSchemaFractionDigitsFacet), ErrorHandler },
            { typeof(XmlSchemaLengthFacet), ErrorHandler },
            { typeof(XmlSchemaMaxLengthFacet), ErrorHandler },
            { typeof(XmlSchemaMinLengthFacet), ErrorHandler },
            { typeof(XmlSchemaTotalDigitsFacet), ErrorHandler },
            { typeof(XmlSchemaPatternFacet), ErrorHandler },
            { typeof(XmlSchemaWhiteSpaceFacet), ErrorHandler },
            { typeof(XmlSchemaGroup), ErrorHandler },
            { typeof(XmlSchemaIdentityConstraint), ErrorHandler },
            { typeof(XmlSchemaKey), ErrorHandler },
            { typeof(XmlSchemaKeyref), ErrorHandler },
            { typeof(XmlSchemaUnique), ErrorHandler },
            { typeof(XmlSchemaNotation), ErrorHandler },
            { typeof(XmlSchemaAll), ErrorHandler },
            { typeof(XmlSchemaGroupRef), ErrorHandler },
            { typeof(XmlSchemaSimpleTypeUnion), ErrorHandler },
            { typeof(XmlSchemaSimpleTypeList), ErrorHandler },
            { typeof(XmlSchemaXPath), ErrorHandler },
            { typeof(XmlSchemaAttribute), XmlAttributeHandler },
            { typeof(XmlSchemaElement), XmlElementHandler },
            { typeof(XmlSchemaComplexType), XmlComplexTypeHandler },
            { typeof(XmlSchemaSequence), XmlSequenceHandler },
            { typeof(XmlSchemaSimpleType), XmlSimpleTypeHandler },
        };
        static Dictionary<Type, Action<XmlSchemaObject, HelpExampleGeneratorContext>> JsonObjectHandler = new Dictionary<Type, Action<XmlSchemaObject, HelpExampleGeneratorContext>>
        {                
            { typeof(XmlSchemaComplexContent), ContentHandler },
            { typeof(XmlSchemaSimpleContent), ContentHandler },
            { typeof(XmlSchemaSimpleTypeRestriction), SimpleTypeRestrictionHandler },                
            { typeof(XmlSchemaChoice), ChoiceHandler },
            // Nothing to do, inheritance is resolved by Schema compilation process                
            { typeof(XmlSchemaComplexContentExtension), EmptyHandler },
            { typeof(XmlSchemaSimpleContentExtension), EmptyHandler },
            // No need to generate XML for these objects
            { typeof(XmlSchemaAny), EmptyHandler },
            { typeof(XmlSchemaAnyAttribute), EmptyHandler },
            { typeof(XmlSchemaAnnotated), EmptyHandler },
            { typeof(XmlSchema), EmptyHandler },
            // The following schema objects are not handled            
            { typeof(XmlSchemaAttributeGroup), ErrorHandler },
            { typeof(XmlSchemaAttributeGroupRef), ErrorHandler },
            { typeof(XmlSchemaComplexContentRestriction), ErrorHandler },
            { typeof(XmlSchemaSimpleContentRestriction), ErrorHandler },
            // Enumerations are supported by the GenerateContentForSimpleType
            { typeof(XmlSchemaEnumerationFacet), EmptyHandler },
            { typeof(XmlSchemaMaxExclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaMaxInclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaMinExclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaMinInclusiveFacet), ErrorHandler },
            { typeof(XmlSchemaNumericFacet), ErrorHandler },
            { typeof(XmlSchemaFractionDigitsFacet), ErrorHandler },
            { typeof(XmlSchemaLengthFacet), ErrorHandler },
            { typeof(XmlSchemaMaxLengthFacet), ErrorHandler },
            { typeof(XmlSchemaMinLengthFacet), ErrorHandler },
            { typeof(XmlSchemaTotalDigitsFacet), ErrorHandler },
            { typeof(XmlSchemaPatternFacet), ErrorHandler },
            { typeof(XmlSchemaWhiteSpaceFacet), ErrorHandler },
            { typeof(XmlSchemaGroup), ErrorHandler },
            { typeof(XmlSchemaIdentityConstraint), ErrorHandler },
            { typeof(XmlSchemaKey), ErrorHandler },
            { typeof(XmlSchemaKeyref), ErrorHandler },
            { typeof(XmlSchemaUnique), ErrorHandler },
            { typeof(XmlSchemaNotation), ErrorHandler },
            { typeof(XmlSchemaAll), ErrorHandler },
            { typeof(XmlSchemaGroupRef), ErrorHandler },
            { typeof(XmlSchemaSimpleTypeUnion), ErrorHandler },
            { typeof(XmlSchemaSimpleTypeList), ErrorHandler },
            { typeof(XmlSchemaXPath), ErrorHandler },
            { typeof(XmlSchemaElement), JsonElementHandler },
            { typeof(XmlSchemaComplexType), JsonComplexTypeHandler },
            { typeof(XmlSchemaSequence), JsonSequenceHandler },
            { typeof(XmlSchemaSimpleType), JsonSimpleTypeHandler },
        };

        public static void GenerateJsonSample(XmlSchemaSet schemaSet, XmlQualifiedName name, XmlWriter writer, IDictionary<XmlQualifiedName, Type> knownTypes)
        {
            HelpExampleGeneratorContext context = new HelpExampleGeneratorContext
            {
                currentDepthLevel = 0,
                elementDepth = new Dictionary<XmlSchemaElement, int>(),
                knownTypes = knownTypes,
                objectHandler = JsonObjectHandler,
                schemaSet = schemaSet,
                overrideElementName = "root",
                writer = writer,
            };

            if (!schemaSet.IsCompiled)
            {
                schemaSet.Compile();
            }
            InvokeHandler(schemaSet.GlobalElements[name], context);
        }

        public static void GenerateXmlSample(XmlSchemaSet schemaSet, XmlQualifiedName name, XmlWriter writer)
        {
            HelpExampleGeneratorContext context = new HelpExampleGeneratorContext
            {
                currentDepthLevel = 0,
                elementDepth = new Dictionary<XmlSchemaElement, int>(),
                knownTypes = null,
                objectHandler = XmlObjectHandler,
                schemaSet = schemaSet,
                overrideElementName = null,
                writer = writer,
            };

            if (!schemaSet.IsCompiled)
            {
                schemaSet.Compile();
            }

            InvokeHandler(schemaSet.GlobalElements[name], context);
        }

        [System.Diagnostics.DebuggerStepThrough]
        static void InvokeHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            if (++context.currentDepthLevel < MaxDepthLevel)
            {
                Action<XmlSchemaObject, HelpExampleGeneratorContext> action;
                Type objectType = schemaObject.GetType();
                if (context.objectHandler.TryGetValue(objectType, out action))
                {
                    action(schemaObject, context);
                }
                else if (objectType.Name != "EmptyParticle")
                {
                    throw new InvalidOperationException(String.Format("Handler for type {0} not found.", schemaObject.GetType().Name));
                }
                --context.currentDepthLevel;
            }
            else
            {
                throw new InvalidOperationException(String.Format("Max depth level reached at {0}.", schemaObject.GetType().Name));
            }
        }

        static void XmlAttributeHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaAttribute attribute = (XmlSchemaAttribute)schemaObject;
            string content = GenerateContentForXmlSimpleType(attribute.AttributeSchemaType);
            if (String.IsNullOrEmpty(content))
            {
                context.writer.WriteAttributeString("i", XmlSchemaInstanceNil, XmlSchemaInstanceNamespace, "true");
            }
            else
            {
                context.writer.WriteAttributeString(attribute.QualifiedName.Name, attribute.QualifiedName.Namespace, content);
            }
        }

        static void ChoiceHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaChoice choice = (XmlSchemaChoice)schemaObject;
            InvokeHandler(choice.Items[0], context);
        }

        static void ContentHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaContentModel model = (XmlSchemaContentModel)schemaObject;
            InvokeHandler(model.Content, context);
        }

        static void SimpleTypeRestrictionHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)schemaObject;
            foreach (XmlSchemaObject facet in restriction.Facets)
            {
                InvokeHandler(facet, context);
            }
        }

        static void ErrorHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            throw new InvalidOperationException(String.Format("Schema object {0} not supported.", schemaObject.GetType().Name));
        }

        static void EmptyHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
        }

        static void XmlElementHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaElement element = (XmlSchemaElement)schemaObject;
            XmlSchemaElement contentElement = GenerateValidElementsComment(element, context);
            context.writer.WriteStartElement(element.QualifiedName.Name, element.QualifiedName.Namespace);
            if (contentElement != element)
            {
                string value = contentElement.QualifiedName.Name;
                if (contentElement.QualifiedName.Namespace != element.QualifiedName.Namespace && !String.IsNullOrEmpty(contentElement.QualifiedName.Namespace))
                {
                    string prefix = context.writer.LookupPrefix(contentElement.QualifiedName.Namespace);
                    if (prefix == null)
                    {
                        prefix = string.Concat("d", context.currentDepthLevel.ToString(System.Globalization.NumberFormatInfo.InvariantInfo));
                        context.writer.WriteAttributeString(XmlNamespacePrefix, prefix, null, contentElement.QualifiedName.Namespace);
                    }
                    value = String.Format(CultureInfo.InvariantCulture, "{0}:{1}", prefix, contentElement.QualifiedName.Name);
                }
                context.writer.WriteAttributeString("i", XmlSchemaInstanceType, XmlSchemaInstanceNamespace, value);
            }
            foreach (XmlSchemaObject constraint in contentElement.Constraints)
            {
                InvokeHandler(constraint, context);
            }
            InvokeHandler(contentElement.ElementSchemaType, context);
            context.writer.WriteEndElement();
        }

        static void XmlComplexTypeHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaComplexType complexType = (XmlSchemaComplexType)schemaObject;
            foreach (XmlSchemaObject attribute in complexType.AttributeUses.Values)
            {
                InvokeHandler(attribute, context);
            }
            if (complexType.ContentModel != null)
            {
                InvokeHandler(complexType.ContentModel, context);
            }
            InvokeHandler(complexType.ContentTypeParticle, context);
            if (complexType.IsMixed)
            {
                context.writer.WriteString("This element contains text.");
            }
        }

        static void XmlSequenceHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaSequence sequence = (XmlSchemaSequence)schemaObject;
            foreach (XmlSchemaObject innerObject in sequence.Items)
            {
                XmlSchemaElement element = innerObject as XmlSchemaElement;
                for (int count = 0; count < 2 && element.MaxOccurs > count; ++count)
                {
                    if (element != null && IsObject(element))
                    {

                        int instances = 0;
                        context.elementDepth.TryGetValue(element, out instances);
                        context.elementDepth[element] = ++instances;
                        if (instances < 3)
                        {
                            InvokeHandler(innerObject, context);
                        }
                        else
                        {
                            context.writer.WriteStartElement(element.QualifiedName.Name, element.QualifiedName.Namespace);
                            context.writer.WriteAttributeString("i", XmlSchemaInstanceNil, XmlSchemaInstanceNamespace, "true");
                            context.writer.WriteEndElement();
                        }
                        --context.elementDepth[element];
                    }
                    else
                    {
                        InvokeHandler(innerObject, context);
                    }
                }
            }
        }

        static void XmlSimpleTypeHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaSimpleType simpleType = (XmlSchemaSimpleType)schemaObject;
            if (simpleType.QualifiedName.Namespace != "http://schemas.microsoft.com/2003/10/Serialization/"
                && simpleType.QualifiedName.Namespace != XmlSchemaNamespace
                && simpleType.QualifiedName.Name != "guid")
            {
                InvokeHandler(simpleType.Content, context);
            }
            string content = GenerateContentForXmlSimpleType(simpleType);
            if (String.IsNullOrEmpty(content))
            {
                context.writer.WriteAttributeString("i", XmlSchemaInstanceNil, XmlSchemaInstanceNamespace, "true");
            }
            else
            {
                context.writer.WriteString(content);
            }
        }

        static string GenerateContentForXmlSimpleType(XmlSchemaSimpleType simpleType)
        {
            if (simpleType.Content != null && simpleType.Content is XmlSchemaSimpleTypeRestriction)
            {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
                foreach (XmlSchemaObject facet in restriction.Facets)
                {
                    if (facet is XmlSchemaEnumerationFacet)
                    {
                        XmlSchemaEnumerationFacet enumeration = (XmlSchemaEnumerationFacet)facet;
                        return enumeration.Value;
                    }
                }
            }

            if (simpleType.QualifiedName.Name == "dateTime")
            {
                DateTime dateTime = DateTime.Parse("1999-05-31T11:20:00", CultureInfo.InvariantCulture);
                return dateTime.ToString("s", CultureInfo.InvariantCulture);
            }
            else if (simpleType.QualifiedName.Name == "char")
            {
                return "97";
            }

            return GetConstantValue(simpleType.QualifiedName.Name);
        }

        static void JsonElementHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaElement element = (XmlSchemaElement)schemaObject;
            XmlSchemaElement contentElement = GetDerivedTypes(element, context).FirstOrDefault();
            if (contentElement == null)
            {
                contentElement = element;
            }

            if (context.overrideElementName != null)
            {
                context.writer.WriteStartElement(null, context.overrideElementName, null);
                context.overrideElementName = null;
            }
            else
            {
                context.writer.WriteStartElement(null, element.Name, null);
            }

            if (IsArrayElementType(element))
            {
                context.writer.WriteAttributeString("type", "array");
                context.overrideElementName = "item";
            }
            else if (IsObject(element))
            {
                if (contentElement != element)
                {
                    Type derivedType = null;
                    context.knownTypes.TryGetValue(contentElement.QualifiedName, out derivedType);
                    if (derivedType != null)
                    {
                        context.writer.WriteStartAttribute(null, "__type", null);
                        context.writer.WriteString(String.Format(CultureInfo.InvariantCulture, "{0}:#{1}", derivedType.Name, derivedType.Namespace));
                        context.writer.WriteEndAttribute();
                    }
                }
                context.writer.WriteAttributeString("type", "object");
            }
            InvokeHandler(contentElement.ElementSchemaType, context);
            context.overrideElementName = null;
            context.writer.WriteEndElement();
        }

        static void JsonComplexTypeHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaComplexType complexType = (XmlSchemaComplexType)schemaObject;
            if (complexType.ContentModel != null)
            {
                InvokeHandler(complexType.ContentModel, context);
            }
            InvokeHandler(complexType.ContentTypeParticle, context);
        }

        static void JsonSequenceHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaSequence sequence = (XmlSchemaSequence)schemaObject;
            foreach (XmlSchemaObject innerObject in sequence.Items)
            {
                XmlSchemaElement element = innerObject as XmlSchemaElement;
                if (element != null && IsObject(element))
                {
                    int instances = 0;
                    context.elementDepth.TryGetValue(element, out instances);
                    context.elementDepth[element] = ++instances;
                    if (instances < 3)
                    {
                        InvokeHandler(innerObject, context);
                    }
                    else
                    {
                        if (context.overrideElementName != null)
                        {
                            context.writer.WriteStartElement(context.overrideElementName);
                            context.overrideElementName = null;
                        }
                        else
                        {
                            context.writer.WriteStartElement(element.QualifiedName.Name);
                        }
                        context.writer.WriteAttributeString("type", "null");
                        context.writer.WriteEndElement();
                    }
                    --context.elementDepth[element];
                }
                else
                {
                    InvokeHandler(innerObject, context);
                }
            }
        }

        static void JsonSimpleTypeHandler(XmlSchemaObject schemaObject, HelpExampleGeneratorContext context)
        {
            XmlSchemaSimpleType simpleType = (XmlSchemaSimpleType)schemaObject;
            // Enumerations return 0
            if (simpleType.Content != null && simpleType.Content is XmlSchemaSimpleTypeRestriction)
            {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
                foreach (XmlSchemaObject facet in restriction.Facets)
                {
                    if (facet is XmlSchemaEnumerationFacet)
                    {
                        context.writer.WriteAttributeString(string.Empty, "type", string.Empty, "number");
                        context.writer.WriteString("0");
                        return;
                    }
                }
            }

            string value = GetConstantValue(simpleType.QualifiedName.Name);

            if (simpleType.QualifiedName.Name == "base64Binary")
            {
                char[] base64stream = value.ToCharArray();
                context.writer.WriteAttributeString(string.Empty, "type", string.Empty, "array");
                for (int i = 0; i < base64stream.Length; i++)
                {
                    context.writer.WriteStartElement("item", string.Empty);
                    context.writer.WriteAttributeString(string.Empty, "type", string.Empty, "number");
                    context.writer.WriteValue((int)base64stream[i]);
                    context.writer.WriteEndElement();
                }
            }
            else if (simpleType.QualifiedName.Name == "dateTime")
            {
                DateTime dateTime = DateTime.Parse("1999-05-31T11:20:00", CultureInfo.InvariantCulture);
                context.writer.WriteString("/Date(");
                context.writer.WriteValue((dateTime.ToUniversalTime().Ticks - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).Ticks) / 10000);

                switch (dateTime.Kind)
                {
                    case DateTimeKind.Unspecified:
                    case DateTimeKind.Local:
                        TimeSpan ts = TimeZone.CurrentTimeZone.GetUtcOffset(dateTime.ToLocalTime());
                        if (ts.Ticks < 0)
                        {
                            context.writer.WriteString("-");
                        }
                        else
                        {
                            context.writer.WriteString("+");
                        }
                        int hours = Math.Abs(ts.Hours);
                        context.writer.WriteString((hours < 10) ? "0" + hours : hours.ToString(CultureInfo.InvariantCulture));
                        int minutes = Math.Abs(ts.Minutes);
                        context.writer.WriteString((minutes < 10) ? "0" + minutes : minutes.ToString(CultureInfo.InvariantCulture));
                        break;
                    case DateTimeKind.Utc:
                        break;
                }
                context.writer.WriteString(")/");
            }
            else if (simpleType.QualifiedName.Name == "char")
            {
                context.writer.WriteString(XmlConvert.ToString('a'));
            }
            else if (!String.IsNullOrEmpty(value))
            {
                if (simpleType.QualifiedName.Name == "integer" ||
                    simpleType.QualifiedName.Name == "int" ||
                    simpleType.QualifiedName.Name == "long" ||
                    simpleType.QualifiedName.Name == "unsignedLong" ||
                    simpleType.QualifiedName.Name == "unsignedInt" ||
                    simpleType.QualifiedName.Name == "short" ||
                    simpleType.QualifiedName.Name == "unsignedShort" ||
                    simpleType.QualifiedName.Name == "byte" ||
                    simpleType.QualifiedName.Name == "unsignedByte" ||
                    simpleType.QualifiedName.Name == "decimal" ||
                    simpleType.QualifiedName.Name == "float" ||
                    simpleType.QualifiedName.Name == "double" ||
                    simpleType.QualifiedName.Name == "negativeInteger" ||
                    simpleType.QualifiedName.Name == "nonPositiveInteger" ||
                    simpleType.QualifiedName.Name == "positiveInteger" ||
                    simpleType.QualifiedName.Name == "nonNegativeInteger")
                {
                    context.writer.WriteAttributeString("type", "number");
                }
                else if (simpleType.QualifiedName.Name == "boolean")
                {
                    context.writer.WriteAttributeString("type", "boolean");
                }
                context.writer.WriteString(value);
            }
            else
            {
                context.writer.WriteAttributeString("type", "null");
            }
        }

        static string GetConstantValue(string typeName)
        {
            if (typeName == "base64Binary")
            {
                return "QmFzZSA2NCBTdHJlYW0=";
            }
            else if (typeName == "string" ||
                typeName == "normalizedString" ||
                typeName == "token" ||
                typeName == "NMTOKEN" ||
                typeName == "NMTOKENS")
            {
                return "String content";
            }
            else if (typeName == "hexBinary")
            {
                return "GpM7";
            }
            else if (typeName == "integer" || typeName == "int")
            {
                return "2147483647";
            }
            else if (typeName == "positiveInteger" || typeName == "nonNegativeInteger")
            {
                return "+2147483647";
            }
            else if (typeName == "long")
            {
                return "9223372036854775807";
            }
            else if (typeName == "unsignedLong")
            {
                return "18446744073709551615";
            }
            else if (typeName == "unsignedInt")
            {
                return "4294967295";
            }
            else if (typeName == "short")
            {
                return "32767";
            }
            else if (typeName == "unsignedShort")
            {
                return "65535";
            }
            else if (typeName == "byte")
            {
                return "127";
            }
            else if (typeName == "unsignedByte")
            {
                return "255";
            }
            else if (typeName == "decimal")
            {
                return "12678967.543233";
            }
            else if (typeName == "float")
            {
                return "1.26743237E+15";
            }
            else if (typeName == "double")
            {
                return "1.26743233E+15";
            }
            else if (typeName == "negativeInteger" || typeName == "nonPositiveInteger")
            {
                return "-12678967543233";
            }
            else if (typeName == "boolean")
            {
                return "true";
            }
            else if (typeName == "duration")
            {
                return "P428DT10H30M12.3S";
            }
            else if (typeName == "date")
            {
                return "1999-05-31";
            }
            else if (typeName == "time")
            {
                return "13:20:00.000, 13:20:00.000-05:00";
            }
            else if (typeName == "gYear")
            {
                return "1999";
            }
            else if (typeName == "gYearMonth")
            {
                return "1999-02";
            }
            else if (typeName == "gMonth")
            {
                return "--05";
            }
            else if (typeName == "gMonthDay")
            {
                return "--05-31";
            }
            else if (typeName == "gDay")
            {
                return "---31";
            }
            else if (typeName == "Name")
            {
                return "Name";
            }
            else if (typeName == "QName" || typeName == "NOTATION")
            {
                return "namespace:Name";
            }
            else if (typeName == "NCName" ||
                typeName == "ID" ||
                typeName == "IDREF" ||
                typeName == "IDREFS" ||
                typeName == "ENTITY" ||
                typeName == "ENTITY" ||
                typeName == "ID")
            {
                return "NCNameString";
            }
            else if (typeName == "anyURI")
            {
                return "http://www.example.com/";
            }
            else if (typeName == "language")
            {
                return "en-US";
            }
            else if (typeName == "guid")
            {
                return "1627aea5-8e0a-4371-9022-9b504344e724";
            }
            return null;
        }

        static XmlSchemaElement GenerateValidElementsComment(XmlSchemaElement element, HelpExampleGeneratorContext context)
        {
            XmlSchemaElement firstNonAbstractElement = element;
            StringBuilder validTypes = new StringBuilder();
            foreach (XmlSchemaElement derivedElement in GetDerivedTypes(element, context))
            {
                if (firstNonAbstractElement == element)
                {
                    firstNonAbstractElement = derivedElement;
                }
                if (validTypes.Length > 0)
                {
                    validTypes.AppendFormat(", {0}", derivedElement.Name);
                }
                else
                {
                    validTypes.AppendFormat(String.Format("Valid elements of type: {0}", derivedElement.Name));
                }
            }
            if (validTypes.Length > 0)
            {
                context.writer.WriteComment(validTypes.ToString());
            }
            return firstNonAbstractElement;
        }

        static IEnumerable<XmlSchemaElement> GetDerivedTypes(XmlSchemaElement element, HelpExampleGeneratorContext context)
        {
            if (element.ElementSchemaType is XmlSchemaComplexType)
            {
                foreach (XmlSchemaElement derivedElement in context.schemaSet.GlobalElements.Values.OfType<XmlSchemaElement>().Where(e =>
                    e.IsAbstract == false &&
                    e.ElementSchemaType != element.ElementSchemaType &&
                    e.ElementSchemaType is XmlSchemaComplexType &&
                    DerivesFrom((XmlSchemaComplexType)element.ElementSchemaType, (XmlSchemaComplexType)e.ElementSchemaType)))
                {
                    yield return derivedElement;
                }
            }
        }

        static bool DerivesFrom(XmlSchemaComplexType parent, XmlSchemaComplexType child)
        {
            if (parent == child)
            {
                return true;
            }
            else if (child.BaseXmlSchemaType is XmlSchemaComplexType)
            {
                return DerivesFrom(parent, (XmlSchemaComplexType)child.BaseXmlSchemaType);
            }
            else
            {
                return false;
            }
        }

        static bool IsArrayElementType(XmlSchemaElement element)
        {
            if (element.ElementSchemaType is XmlSchemaComplexType)
            {
                XmlSchemaComplexType complexType = element.ElementSchemaType as XmlSchemaComplexType;
                if (complexType.ContentTypeParticle != null && complexType.ContentTypeParticle is XmlSchemaSequence)
                {
                    XmlSchemaSequence sequence = complexType.ContentTypeParticle as XmlSchemaSequence;
                    if (sequence.Items.Count > 0)
                    {
                        XmlSchemaElement firstElement = sequence.Items[0] as XmlSchemaElement;
                        if (firstElement != null && firstElement.MaxOccurs > 1)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        static bool IsObject(XmlSchemaElement element)
        {
            return element.ElementSchemaType is XmlSchemaComplexType;
        }

        class HelpExampleGeneratorContext
        {
            public string overrideElementName;
            public int currentDepthLevel;
            public IDictionary<XmlQualifiedName, Type> knownTypes;
            public XmlSchemaSet schemaSet;
            public IDictionary<XmlSchemaElement, int> elementDepth;
            public XmlWriter writer;
            public Dictionary<Type, Action<XmlSchemaObject, HelpExampleGeneratorContext>> objectHandler;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\RequestInterceptorBindingElement.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.Diagnostics;

namespace Microsoft.ServiceModel.Web
{
    public class RequestInterceptorBindingElement : BindingElement
    {
        Collection<RequestInterceptor> interceptors;

        public RequestInterceptorBindingElement(Collection<RequestInterceptor> interceptors)
        {
            this.interceptors = new Collection<RequestInterceptor>(interceptors);
        }

        RequestInterceptorBindingElement(RequestInterceptorBindingElement src)
        {
            this.interceptors = new Collection<RequestInterceptor>(src.interceptors);
        }

        public Collection<RequestInterceptor> Interceptors
        {
            get { return this.interceptors; }
        }

        public override BindingElement Clone()
        {
            return new RequestInterceptorBindingElement(this);
        }

        public override T GetProperty<T>(BindingContext context)
        {
            return context.GetInnerProperty<T>();
        }

        public override bool CanBuildChannelFactory<TChannel>(BindingContext context)
        {
            return false;
        }

        public override IChannelListener<TChannel> BuildChannelListener<TChannel>(BindingContext context)
        {
            if (!CanBuildChannelListener<TChannel>(context))
            {
                throw new NotSupportedException();
            }
            if (typeof(TChannel) == typeof(IReplyChannel))
            {
                return (IChannelListener<TChannel>)(object)new RequestInterceptorReplyChannelListener(context, this.interceptors);
            }
            else
            {
                return (IChannelListener<TChannel>)(object)new RequestInterceptorReplySessionChannelListener(context, this.interceptors);
            }
        }

        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context)
        {
            throw new NotSupportedException();
        }

        public override bool CanBuildChannelListener<TChannel>(BindingContext context)
        {
            return (context.CanBuildInnerChannelListener<IReplyChannel>()
                || (context.CanBuildInnerChannelListener<IReplySessionChannel>()));
        }
    }

    abstract class RequestInterceptorReplyChannelListenerBase<TChannel> : ChannelListenerBase<TChannel>
        where TChannel : class, IReplyChannel
    {
        IChannelListener<TChannel> inner;
        Collection<RequestInterceptor> interceptors;

        public RequestInterceptorReplyChannelListenerBase(IChannelListener<TChannel> inner, Collection<RequestInterceptor> interceptors)
        {
            this.inner = inner;
            this.interceptors = (interceptors != null) ? new Collection<RequestInterceptor>(interceptors) : new Collection<RequestInterceptor>();
        }

        protected override TChannel OnAcceptChannel(TimeSpan timeout)
        {
            return WrapInner(inner.AcceptChannel(timeout));
        }

        protected override IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginAcceptChannel(timeout, callback, state);
        }

        protected override TChannel OnEndAcceptChannel(IAsyncResult result)
        {
            return WrapInner(inner.EndAcceptChannel(result));
        }

        protected override IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginWaitForChannel(timeout, callback, state);
        }

        protected override bool OnEndWaitForChannel(IAsyncResult result)
        {
            return inner.EndWaitForChannel(result);
        }

        protected override bool OnWaitForChannel(TimeSpan timeout)
        {
            return inner.WaitForChannel(timeout);
        }

        TChannel WrapInner(TChannel inner)
        {
            if (inner == null) return null;
            return CreateChannel(inner, this.interceptors);
        }

        protected abstract TChannel CreateChannel(TChannel inner, Collection<RequestInterceptor> interceptors);

        public override Uri Uri
        {
            get { return inner.Uri; }
        }

        protected override void OnAbort()
        {
            inner.Abort();
        }

        public override T GetProperty<T>()
        {
            return inner.GetProperty<T>();
        }

        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginClose(timeout, callback, state);
        }

        protected override IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginOpen(timeout, callback, state);
        }

        protected override void OnClose(TimeSpan timeout)
        {
            inner.Close(timeout);
        }

        protected override void OnEndClose(IAsyncResult result)
        {
            inner.EndClose(result);
        }

        protected override void OnEndOpen(IAsyncResult result)
        {
            inner.EndOpen(result);
        }

        protected override void OnOpen(TimeSpan timeout)
        {
            inner.Open(timeout);
        }
    }

    class RequestInterceptorReplyChannelListener : RequestInterceptorReplyChannelListenerBase<IReplyChannel>
    {
        public RequestInterceptorReplyChannelListener(BindingContext c, Collection<RequestInterceptor> interceptors)
            : base(c.BuildInnerChannelListener<IReplyChannel>(), new Collection<RequestInterceptor>(interceptors))
        {
        }

        protected override IReplyChannel CreateChannel(IReplyChannel inner, Collection<RequestInterceptor> interceptors)
        {
            return new RequestInterceptorReplyChannel(this, inner, interceptors);
        }
    }

    class RequestInterceptorReplySessionChannelListener : RequestInterceptorReplyChannelListenerBase<IReplySessionChannel>
    {
        public RequestInterceptorReplySessionChannelListener(BindingContext c, Collection<RequestInterceptor> interceptors)
            : base(c.BuildInnerChannelListener<IReplySessionChannel>(), new Collection<RequestInterceptor>(interceptors))
        {
        }

        protected override IReplySessionChannel CreateChannel(IReplySessionChannel inner, Collection<RequestInterceptor> interceptors)
        {
            return new RequestInterceptorReplySessionChannel(this, inner, interceptors);
        }
    }

    abstract class RequestInterceptorReplyChannelBase<TChannel> : ChannelBase, IReplyChannel
        where TChannel : IReplyChannel
    {
        TChannel inner;
        Collection<RequestInterceptor> interceptors;

        public RequestInterceptorReplyChannelBase(ChannelManagerBase channelManager, TChannel inner, Collection<RequestInterceptor> interceptors)
            : base(channelManager)
        {
            this.inner = inner;
            this.interceptors = interceptors;
        }

        public IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return this.BeginTryReceiveRequest(timeout, callback, state);
        }

        public IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state)
        {
            return this.BeginReceiveRequest(this.DefaultReceiveTimeout, callback, state);
        }

        public IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return new TryReceiveRequestAsyncResult(timeout, this, callback, state);
        }

        public IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginWaitForRequest(timeout, callback, state);
        }

        public RequestContext EndReceiveRequest(IAsyncResult result)
        {
            RequestContext context;
            if (!TryReceiveRequestAsyncResult.End(result, out context))
            {
                throw new TimeoutException();
            }
            return context;
        }

        public bool EndTryReceiveRequest(IAsyncResult result, out RequestContext context)
        {
            return TryReceiveRequestAsyncResult.End(result, out context);
        }

        public bool EndWaitForRequest(IAsyncResult result)
        {
            return this.inner.EndWaitForRequest(result);
        }

        public EndpointAddress LocalAddress
        {
            get { return inner.LocalAddress; }
        }

        public RequestContext ReceiveRequest(TimeSpan timeout)
        {
            RequestContext result;
            if (!this.TryReceiveRequest(timeout, out result))
            {
                throw new TimeoutException();
            }
            return result;
        }

        RequestContext WrapInner(RequestContext requestContext)
        {
            if (requestContext == null) return null;
            for (int i = 0; i < this.interceptors.Count; ++i)
            {
                this.interceptors[i].ProcessRequest(ref requestContext);
                if (requestContext == null)
                {
                    return null;
                }
            }
            return requestContext;
        }

        IAsyncResult BeginWrapInner(RequestContext requestContext, AsyncCallback callback, object state)
        {
            return new WrapInnerAsyncResult(requestContext, this.interceptors, callback, state);
        }

        RequestContext EndWrapInner(IAsyncResult result)
        {
            return WrapInnerAsyncResult.End(result);
        }

        public RequestContext ReceiveRequest()
        {
            return this.ReceiveRequest(this.DefaultReceiveTimeout);
        }

        public bool TryReceiveRequest(TimeSpan timeout, out RequestContext context)
        {
            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
            while (true)
            {
                if (inner.TryReceiveRequest(timeoutHelper.RemainingTime(), out context))
                {
                    if (context == null) return true;
                    context = WrapInner(context);
                    // if the message was discarded by the interceptors, read the next message
                    if (context == null) continue;
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        public bool WaitForRequest(TimeSpan timeout)
        {
            return inner.WaitForRequest(timeout);
        }

        protected override void OnAbort()
        {
            inner.Abort();
        }

        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginClose(timeout, callback, state);
        }

        protected override IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state)
        {
            return inner.BeginOpen(timeout, callback, state);
        }

        protected override void OnClose(TimeSpan timeout)
        {
            inner.Close(timeout);
        }

        protected override void OnEndClose(IAsyncResult result)
        {
            inner.EndClose(result);
        }

        protected override void OnEndOpen(IAsyncResult result)
        {
            inner.EndOpen(result);
        }

        protected override void OnOpen(TimeSpan timeout)
        {
            inner.Open(timeout);
        }

        public override T GetProperty<T>()
        {
            return this.inner.GetProperty<T>();
        }

        class TryReceiveRequestAsyncResult : AsyncResult
        {
            TimeoutHelper timeoutHelper;
            RequestContext context;
            RequestInterceptorReplyChannelBase<TChannel> channel;
            bool timedout;

            public TryReceiveRequestAsyncResult(TimeSpan timeout, RequestInterceptorReplyChannelBase<TChannel> channel, AsyncCallback callback, object state)
                : base(callback, state)
            {
                this.timeoutHelper = new TimeoutHelper(timeout);
                this.channel = channel;
                IAsyncResult result = this.channel.inner.BeginTryReceiveRequest(timeoutHelper.RemainingTime(), this.InnerTryReceiveCallback, null);
                if (!result.CompletedSynchronously)
                {
                    return;
                }
                if (OnWrapInnerRequest(result))
                {
                    Complete(true);
                }
            }

            void InnerTryReceiveCallback(IAsyncResult result)
            {
                if (result.CompletedSynchronously) return;
                bool completeSelf = false;
                Exception completionException = null;
                try
                {
                    if (OnWrapInnerRequest(result))
                    {
                        completeSelf = true;
                    }
                }
                catch (Exception e)
                {
                    completeSelf = true;
                    completionException = e;
                }
                if (completeSelf)
                {
                    Complete(false, completionException);
                }
            }

            void WrapInnerCallback(IAsyncResult result)
            {
                if (result.CompletedSynchronously) return;
                bool completeSelf = false;
                Exception completionException = null;
                try
                {
                    this.context = this.channel.EndWrapInner(result);
                    if (this.context != null)
                    {
                        completeSelf = true;
                    }
                    else
                    {
                        IAsyncResult newResult = this.channel.inner.BeginTryReceiveRequest(this.timeoutHelper.RemainingTime(), this.InnerTryReceiveCallback, null);
                        if (!newResult.CompletedSynchronously)
                        {
                            return;
                        }
                        completeSelf = this.OnWrapInnerRequest(newResult);
                    }
                }
                catch (Exception e)
                {
                    completeSelf = true;
                    completionException = e;
                }
                if (completeSelf)
                {
                    Complete(false, completionException);
                }
            }

            bool OnWrapInnerRequest(IAsyncResult result)
            {
                while (true)
                {
                    RequestContext innerContext;
                    if (!this.channel.inner.EndTryReceiveRequest(result, out innerContext))
                    {
                        timedout = true;
                        return true;
                    }
                    if (innerContext == null)
                    {
                        this.context = null;
                        return true;
                    }
                    IAsyncResult wrapResult = this.channel.BeginWrapInner(innerContext, this.WrapInnerCallback, null);
                    if (!wrapResult.CompletedSynchronously)
                    {
                        return false;
                    }
                    this.context = this.channel.EndWrapInner(wrapResult);
                    if (this.context != null)
                    {
                        return true;
                    }
                    result = this.channel.inner.BeginTryReceiveRequest(this.timeoutHelper.RemainingTime(), this.InnerTryReceiveCallback, null);
                    if (!result.CompletedSynchronously)
                    {
                        return false;
                    }
                }
            }

            public static bool End(IAsyncResult result, out RequestContext context)
            {
                AsyncResult.End<TryReceiveRequestAsyncResult>(result);
                TryReceiveRequestAsyncResult typedResult = (TryReceiveRequestAsyncResult) result;
                context = typedResult.context;
                return !typedResult.timedout;
            }
        }

        class WrapInnerAsyncResult : AsyncResult
        {
            RequestContext context;
            Collection<RequestInterceptor> interceptors;
            int index;

            public WrapInnerAsyncResult(RequestContext context, Collection<RequestInterceptor> interceptors, AsyncCallback callback, object state)
                : base(callback, state)
            {
                this.context = context;
                this.interceptors = interceptors;
                if (this.RunInterceptors())
                {
                    Complete(true);
                }
            }

            bool RunInterceptors()
            {
                while (this.index < this.interceptors.Count)
                {
                    RequestInterceptor interceptor = this.interceptors[this.index];
                    if (interceptor.IsSynchronous)
                    {
                        interceptor.ProcessRequest(ref this.context);
                    }
                    else
                    {
                        IAsyncResult result = interceptor.BeginProcessRequest(this.context, this.ProcessRequestCallback, null);
                        if (!result.CompletedSynchronously) return false;
                        this.context = interceptor.EndProcessRequest(result);
                    }
                    if (this.context == null) return true;
                    ++this.index;
                }
                return true;
            }

            void ProcessRequestCallback(IAsyncResult result)
            {
                if (result.CompletedSynchronously) return;
                bool completeSelf = false;
                Exception completionException = null;
                try
                {
                    this.context = this.interceptors[this.index].EndProcessRequest(result);
                    if (this.context == null)
                    {
                        completeSelf = true;
                    }
                    else
                    {
                        ++this.index;
                        completeSelf = this.RunInterceptors();
                    }
                }
                catch (Exception e)
                {
                    completeSelf = true;
                    completionException = e;
                }
                if (completeSelf)
                {
                    Complete(false, completionException);
                }
            }

            public static RequestContext End(IAsyncResult result)
            {
                AsyncResult.End<WrapInnerAsyncResult>(result);
                WrapInnerAsyncResult typedResult = (WrapInnerAsyncResult)result;
                return typedResult.context;
            }
        }
    }

    class RequestInterceptorReplyChannel : RequestInterceptorReplyChannelBase<IReplyChannel>
    {
        public RequestInterceptorReplyChannel(ChannelManagerBase cmb, IReplyChannel inner, Collection<RequestInterceptor> interceptors)
            : base(cmb, inner, interceptors)
        {
        }
    }

    class RequestInterceptorReplySessionChannel : RequestInterceptorReplyChannelBase<IReplySessionChannel>, IReplySessionChannel
    {
        IReplySessionChannel inner;

        public RequestInterceptorReplySessionChannel(ChannelManagerBase cmb, IReplySessionChannel inner, Collection<RequestInterceptor> interceptors)
            : base(cmb, inner, interceptors)
        {
            this.inner = inner;
        }

        public IInputSession Session
        {
            get { return inner.Session; }
        }
    }

    struct TimeoutHelper
    {
        internal static TimeSpan Infinite { get { return TimeSpan.MaxValue; } }

        DateTime deadline;
        bool deadlineSet;

        TimeSpan originalTimeout;

        internal void SetDeadline()
        {
            this.deadline = DateTime.UtcNow + this.originalTimeout;
            this.deadlineSet = true;
        }

        internal TimeoutHelper(TimeSpan timeout)
        {
            if (timeout < TimeSpan.Zero)
            {
                throw new ArgumentOutOfRangeException("timeout", "Timeout is negative");
            }

            this.originalTimeout = timeout;
            this.deadline = DateTime.MaxValue;
            this.deadlineSet = (timeout == TimeSpan.MaxValue);
        }

        public TimeSpan OriginalTimeout
        {
            get { return this.originalTimeout; }
        }

        public TimeSpan RemainingTime()
        {
            if (!this.deadlineSet)
            {
                this.SetDeadline();
                return this.originalTimeout;
            }
            else if (this.deadline == DateTime.MaxValue)
            {
                return TimeSpan.MaxValue;
            }
            else
            {
                TimeSpan remaining = this.deadline - DateTime.UtcNow;
                if (remaining <= TimeSpan.Zero)
                {
                    return TimeSpan.Zero;
                }
                else
                {
                    return remaining;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\FormsPostDispatchMessageFormatter.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.ServiceModel.Description;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.Collections.Specialized;
using System.Xml;
using System.ServiceModel.Web;
using System.Reflection;

namespace Microsoft.ServiceModel.Web
{
    class FormsPostDispatchMessageFormatter : IDispatchMessageFormatter
    {
        IDispatchMessageFormatter inner;
        OperationDescription od;
        int nvcIndex = -1;
        QueryStringConverter queryStringConverter;

        public FormsPostDispatchMessageFormatter(OperationDescription od, IDispatchMessageFormatter inner, QueryStringConverter queryStringConverter)
        {
            this.inner = inner;
            this.od = od;
            this.queryStringConverter = queryStringConverter;
            MessageDescription request = null;
            foreach (MessageDescription message in od.Messages)
            {
                if (message.Direction == MessageDirection.Input)
                {
                    request = message;
                    break;
                }
            }
            if (request != null && request.MessageType == null)
            {
                for (int i = 0; i < request.Body.Parts.Count; ++i)
                {
                    if (request.Body.Parts[i].Type == typeof(NameValueCollection))
                    {
                        this.nvcIndex = i;
                        break;
                    }
                }
            }
        }

        public void DeserializeRequest(Message message, object[] parameters)
        {
            if (message == null)
            {
                return;
            }
            if (this.nvcIndex >= 0 && string.Equals(WebOperationContext.Current.IncomingRequest.ContentType, "application/x-www-form-urlencoded", StringComparison.OrdinalIgnoreCase))
            {
                using (XmlDictionaryReader r = message.GetReaderAtBodyContents())
                {
                    r.ReadStartElement("Binary");
                    byte[] buffer = r.ReadContentAsBase64();
                    string queryString = new UTF8Encoding().GetString(buffer);
                    NameValueCollection nvc = HttpUtility.ParseQueryString(queryString);
                    parameters[this.nvcIndex] = nvc;
                }
                // bind the uri template parameters
                UriTemplateMatch match = message.Properties["UriTemplateMatchResults"] as UriTemplateMatch;
                ParameterInfo[] paramInfos = this.od.SyncMethod.GetParameters();
                var binder = CreateParameterBinder(match);
                object[] values = (from p in paramInfos where p.ParameterType != typeof(NameValueCollection)
                                   select binder(p)).ToArray<Object>();
                int index = 0;
                for (int i = 0; i < paramInfos.Length; ++i)
                {
                    if (i != this.nvcIndex)
                    {
                        parameters[i] = values[index];
                        ++index;
                    }
                }
            }
            else
            {
                inner.DeserializeRequest(message, parameters);
            }
        }

        public Message SerializeReply(MessageVersion messageVersion, object[] parameters, object result)
        {
            throw new NotSupportedException();
        }

        Func<ParameterInfo, object> CreateParameterBinder(UriTemplateMatch match)
        {
            return delegate(ParameterInfo pi)
            {
                string value = match.BoundVariables[pi.Name];
                if (!string.IsNullOrEmpty(value))
                {
                    return this.queryStringConverter.ConvertStringToValue(value, pi.ParameterType);
                }
                else 
                {
                    return pi.RawDefaultValue;
                }
            };
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\HelpPageInvoker.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;
using System.ServiceModel.Syndication;
using System.Threading;
using System.ServiceModel.Web;
using System.Xml;
using System.Runtime.Serialization;
using System.Xml.Schema;
using System.Xml.Linq;
using System.IO;
using System.Net;
using System.Runtime.Serialization.Json;
using System.Xml.Serialization;
using System.Collections.Specialized;

namespace Microsoft.ServiceModel.Web
{
    class HelpPageInvoker : IOperationInvoker
    {
        public const string OperationName = "HelpPageInvoke";

        public const string AllOperationsTemplate = "help";
        public const string OperationRequestSchemaTemplate = "help/{operation}/request/schema";
        public const string OperationRequestExampleTemplate = "help/{operation}/request/example";
        public const string OperationResponseSchemaTemplate = "help/{operation}/response/schema";
        public const string OperationResponseExampleTemplate = "help/{operation}/response/example";

        string feedId = "urn:uuid:" + Guid.NewGuid().ToString();
        DateTime startupTime = DateTime.UtcNow;

        public ContractDescription Description { get; set; }

        public Uri BaseUri { get; set; }

        public WebHttpBehavior Behavior { get; set; }

        public IDispatchOperationSelector GetHelpPageOperationSelector()
        {
            return new HelpPageOperationSelector(this.BaseUri);
        }

        void GetWebGetAndInvoke(OperationDescription od, out WebGetAttribute get, out WebInvokeAttribute invoke)
        {
            get = od.Behaviors.Find<WebGetAttribute>();
            invoke = od.Behaviors.Find<WebInvokeAttribute>();
            if (get == null && invoke == null)
            {
                // default is POST
                invoke = new WebInvokeAttribute();
            }
        }

        //[WebGet(UriTemplate="help")]
        public Atom10FeedFormatter GetFeed()
        {
            List<SyndicationItem> items = new List<SyndicationItem>();
            foreach (OperationDescription od in this.Description.Operations)
            {
                WebGetAttribute get;
                WebInvokeAttribute invoke;
                GetWebGetAndInvoke(od, out get, out invoke);    
                string method = GetMethod(get, invoke);
                string requestFormat = null;
                if (invoke != null)
                {
                    requestFormat = GetRequestFormat(invoke, od);
                }
                string responseFormat = GetResponseFormat(get, invoke, od);
                string uriTemplate = GetUriTemplate(get, invoke, od);
                WebMessageBodyStyle bodyStyle = GetBodyStyle(get, invoke);

                string requestSchemaLink = null;
                string responseSchemaLink = null;
                string requestExampleLink = null;
                string responseExampleLink = null;

                if (bodyStyle == WebMessageBodyStyle.Bare)
                {
                    UriTemplate responseSchemaTemplate = new UriTemplate(OperationResponseSchemaTemplate);
                    responseSchemaLink = responseSchemaTemplate.BindByPosition(this.BaseUri, od.Name).AbsoluteUri;

                    UriTemplate responseExampleTemplate = new UriTemplate(OperationResponseExampleTemplate);
                    responseExampleLink = responseExampleTemplate.BindByPosition(this.BaseUri, od.Name).AbsoluteUri;
                    if (invoke != null)
                    {
                        UriTemplate requestSchemaTemplate = new UriTemplate(OperationRequestSchemaTemplate);
                        requestSchemaLink = requestSchemaTemplate.BindByPosition(this.BaseUri, od.Name).AbsoluteUri;

                        UriTemplate requestExampleTemplate = new UriTemplate(OperationRequestExampleTemplate);
                        requestExampleLink = requestExampleTemplate.BindByPosition(this.BaseUri, od.Name).AbsoluteUri;
                    }
                }

                uriTemplate = String.Format("{0}/{1}", this.BaseUri.AbsoluteUri, uriTemplate);
                uriTemplate = HttpUtility.HtmlEncode(uriTemplate);

                string xhtmlDescription = String.Format("<div xmlns=\"http://www.w3.org/1999/xhtml\"><table border=\"5\"><tr><td>UriTemplate</td><td>{0}</td></tr><tr><td>Method</td><td>{1}</td></tr>", uriTemplate, method);
                if (!string.IsNullOrEmpty(requestFormat))
                {
                    xhtmlDescription += String.Format("<tr><td>Request Format</td><td>{0}</td></tr>", requestFormat);
                }
                if (requestSchemaLink != null)
                {
                    xhtmlDescription += String.Format("<tr><td>Request Schema</td><td><a href=\"{0}\">{0}</a></td></tr>", HttpUtility.HtmlEncode(requestSchemaLink));
                }
                if (requestExampleLink != null)
                {
                    xhtmlDescription += String.Format("<tr><td>Request Example</td><td><a href=\"{0}\">{0}</a></td></tr>", HttpUtility.HtmlEncode(requestExampleLink));
                }
                xhtmlDescription += String.Format("<tr><td>Response Format</td><td>{0}</td></tr>", responseFormat);
                if (responseSchemaLink != null)
                {
                    xhtmlDescription += String.Format("<tr><td>Response Schema</td><td><a href=\"{0}\">{0}</a></td></tr>", HttpUtility.HtmlEncode(responseSchemaLink));
                }
                if (responseExampleLink != null)
                {
                    xhtmlDescription += String.Format("<tr><td>Response Example</td><td><a href=\"{0}\">{0}</a></td></tr>", HttpUtility.HtmlEncode(responseExampleLink));
                }
                WebHelpAttribute help = od.Behaviors.Find<WebHelpAttribute>();
                if (help != null && !string.IsNullOrEmpty(help.Comment))
                {
                    xhtmlDescription += String.Format("<tr><td>Description</td><td>{0}</td></tr>", help.Comment);
                }
                xhtmlDescription += "</table></div>";
                SyndicationItem item = new SyndicationItem()
                {
                    Id = "http://tmpuri.org/" + od.Name,
                    Content = new TextSyndicationContent(xhtmlDescription, TextSyndicationContentKind.XHtml),
                    LastUpdatedTime = DateTime.UtcNow,
                    Title = new TextSyndicationContent(String.Format("{0}: {1}", Description.Name, od.Name)),
                };
                items.Add(item);
            }

            SyndicationFeed feed = new SyndicationFeed()
            {
                Title = new TextSyndicationContent("Service help page"),
                Id = feedId,
                LastUpdatedTime = DateTime.UtcNow,
                Items = items
            };
            WebOperationContext.Current.OutgoingResponse.ContentType = "application/atom+xml";
            return feed.GetAtom10Formatter();
        }

        static bool IsUntypedMessage(MessageDescription message)
        {
            if (message == null)
            {
                return false;
            }
            return (message.Body.ReturnValue != null && message.Body.Parts.Count == 0 && message.Body.ReturnValue.Type == typeof(Message)) ||
                (message.Body.ReturnValue == null && message.Body.Parts.Count == 1 && message.Body.Parts[0].Type == typeof(Message));
        }

        private string GetUriTemplate(WebGetAttribute get, WebInvokeAttribute invoke, OperationDescription od)
        {
            if (get != null)
            {
                if (get.UriTemplate != null)
                {
                    return get.UriTemplate;
                }
                else
                {
                    StringBuilder sb = new StringBuilder(od.Name);
                    if (!IsUntypedMessage(od.Messages[0]))
                    {
                        sb.Append("?");
                        foreach (MessagePartDescription mpd in od.Messages[0].Body.Parts)
                        {
                            string parameterName = mpd.Name;
                            sb.Append(parameterName);
                            sb.Append("={");
                            sb.Append(parameterName);
                            sb.Append("}&");
                        }
                        sb.Remove(sb.Length - 1, 1);
                    }
                    return sb.ToString();
                }
            }
            if (invoke.UriTemplate != null)
            {
                return invoke.UriTemplate;
            }
            else
            {
                return od.Name;
            }
        }

        private string GetResponseFormat(WebGetAttribute get, WebInvokeAttribute invoke, OperationDescription od)
        {
            if (IsResponseStream(od))
            {
                return "binary";
            }
            if (get != null && get.IsResponseFormatSetExplicitly) return get.ResponseFormat.ToString();
            if (invoke != null && invoke.IsResponseFormatSetExplicitly) return invoke.ResponseFormat.ToString();
            return this.Behavior.DefaultOutgoingResponseFormat.ToString();
        }

        private string GetRequestFormat(WebInvokeAttribute invoke, OperationDescription od)
        {
            if (IsRequestStream(od))
            {
                return "binary";
            }
            return "xml or json";
        }

        private bool IsResponseStream(OperationDescription od)
        {
            foreach (MessageDescription message in od.Messages)
            {
                if (message.Direction == MessageDirection.Output)
                {
                    if (message.Body.ReturnValue != null && message.Body.Parts.Count == 0)
                    {
                        return (message.Body.ReturnValue != null && message.Body.ReturnValue.Type == typeof(Stream));
                    }
                }
            }
            return false;
        }

        private bool IsRequestStream(OperationDescription od)
        {
            foreach (MessageDescription message in od.Messages)
            {
                if (message.Direction == MessageDirection.Input)
                {
                    if (message.Body.Parts.Count == 1)
                    {
                        return (message.Body.Parts[0].Type == typeof(Stream));
                    }
                }
            }
            return false;
        }

        private string GetMethod(WebGetAttribute get, WebInvokeAttribute invoke)
        {
            if (get != null) return "GET";
            if (invoke != null && !string.IsNullOrEmpty(invoke.Method)) return invoke.Method;
            return "POST";

        }

        Type GetRequestBodyType(OperationDescription od, out bool isXmlSerializerType)
        {
            isXmlSerializerType = (od.Behaviors.Find<XmlSerializerOperationBehavior>() != null);
            if (od.Behaviors.Find<WebGetAttribute>() != null)
            {
                return null;
            }
            WebInvokeAttribute invoke = od.Behaviors.Find<WebInvokeAttribute>();
            if (invoke == null) invoke = new WebInvokeAttribute();
            List<string> uriParameters = new List<string>();
            if (invoke.UriTemplate != null)
            {
                UriTemplate template = new UriTemplate(invoke.UriTemplate);
                foreach (string pathVariable in template.PathSegmentVariableNames)
                {
                    uriParameters.Add(pathVariable);
                }
                foreach (string queryVariable in template.QueryValueVariableNames)
                {
                    uriParameters.Add(queryVariable);
                }
            }
            if (od.Messages[0].MessageType != null) return null;
            List<Type> bodyParts = new List<Type>();
            foreach (MessagePartDescription messagePart in od.Messages[0].Body.Parts)
            {
                bool isUriPart = false;
                foreach (string var in uriParameters)
                {
                    if (String.Equals(var, messagePart.Name, StringComparison.OrdinalIgnoreCase))
                    {
                        isUriPart = true;
                        break;
                    }
                }
                if (isUriPart)
                {
                    continue;
                }
                bodyParts.Add(messagePart.Type);
            }
            if ((bodyParts.Count == 0) || (bodyParts.Count > 1))
            {
                return null;
            }
            return bodyParts[0];
        }

        Type GetResponseBodyType(OperationDescription od, out bool isXmlSerializerType)
        {
            isXmlSerializerType = (od.Behaviors.Find<XmlSerializerOperationBehavior>() != null);
            if (od.Messages[1].MessageType != null) return null;
            if (od.Messages[1].Body.Parts.Count > 0) return null;
            return (od.Messages[1].Body.ReturnValue.Type);
        }

        Message CreateTextMessage(string message)
        {
            Message result = Message.CreateMessage(MessageVersion.None, null, new TextBodyWriter(message));
            result.Properties[WebBodyFormatMessageProperty.Name] = new WebBodyFormatMessageProperty(WebContentFormat.Raw);
            WebOperationContext.Current.OutgoingResponse.ContentType = "text/plain";
            return result;
        }

        bool IsBodySpecial(Type body, string direction, out Message message)
        {
            message = null;
            if (body == null || body == typeof(void))
            {
                message = CreateTextMessage(String.Format("The {0} body is empty.", direction));
            }
            else if (body == typeof(Stream))
            {
                message = CreateTextMessage(String.Format("The {0} body is a byte stream. See the service documentation for allowed content types.", direction));
            }
            else if (typeof(Atom10FeedFormatter).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is an Atom 1.0 syndication feed. See http://tools.ietf.org/html/rfc4287 for more details.", direction));
            }
            else if (typeof(Atom10ItemFormatter).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is an Atom 1.0 syndication entry. See http://tools.ietf.org/html/rfc4287 for more details.", direction));
            }
            else if (typeof(AtomPub10ServiceDocumentFormatter).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is an Atom Pub service document. See http://www.rfc-editor.org/rfc/rfc5023.txt for more details.", direction));
            }
            else if (typeof(AtomPub10CategoriesDocumentFormatter).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is an Atom Pub categories document. See http://www.rfc-editor.org/rfc/rfc5023.txt for more details.", direction));
            }
            else if (typeof(Rss20FeedFormatter).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is an RSS 2.0 syndication feed. See http://validator.w3.org/feed/docs/rss2.html for more details.", direction));
            }
            else if (typeof(NameValueCollection).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is a HTML Forms data.", direction));
            }
            else if (typeof(XElement).IsAssignableFrom(body) || typeof(XmlElement).IsAssignableFrom(body))
            {
                message = CreateTextMessage(String.Format("The {0} body is arbitrary XML. See the service documentation for conformant XML documents.", direction));
            }
            return (message != null);
        }

        Message CreateSchema(Type body, bool isXmlSerializerType)
        {
            System.Collections.IEnumerable schemas;
            if (isXmlSerializerType)
            {
                XmlReflectionImporter importer = new XmlReflectionImporter();
                XmlTypeMapping typeMapping = importer.ImportTypeMapping(body);
                XmlSchemas s = new XmlSchemas();
                XmlSchemaExporter exporter = new XmlSchemaExporter(s);
                exporter.ExportTypeMapping(typeMapping);
                schemas = s.GetSchemas(null);
            }
            else
            {
                XsdDataContractExporter exporter = new XsdDataContractExporter();
                exporter.Export(body);
                schemas = exporter.Schemas.Schemas();
            }
            using (MemoryStream stream = new MemoryStream())
            {
                XmlWriterSettings xws = new XmlWriterSettings() { Indent = true };
                using (XmlWriter w = XmlWriter.Create(stream, xws))
                {
                    w.WriteStartElement("Schemas");
                    foreach (XmlSchema schema in schemas)
                    {
                        if (schema.TargetNamespace != "http://www.w3.org/2001/XMLSchema")
                        {
                            schema.Write(w);
                        }
                    }
                }
                stream.Seek(0, SeekOrigin.Begin);
                using (XmlReader reader = XmlReader.Create(stream))
                {
                    return Message.CreateMessage(MessageVersion.None, null, XElement.Load(reader, LoadOptions.PreserveWhitespace));
                }
            }
        }

        WebMessageBodyStyle GetBodyStyle(WebGetAttribute get, WebInvokeAttribute invoke)
        {
            if (get != null)
            {
                return get.BodyStyle;
            }
            return invoke.BodyStyle;
        }

        //[WebGet(UriTemplate = "help/{operation}/request/schema")]
        public Message GetRequestXmlSchema(string operation)
        {
            foreach (OperationDescription od in this.Description.Operations)
            {
                if (od.Name == operation)
                {
                    
                    bool isXmlSerializerType;
                    Type body = GetRequestBodyType(od, out isXmlSerializerType);
                    Message result;
                    if (IsBodySpecial(body, "request", out result))
                    {
                        return result;
                    }
                    try
                    {
                        return CreateSchema(body, isXmlSerializerType);
                    }
                    catch (Exception e)
                    {
                        return CreateTextMessage(String.Format("Could not generate schema for request. Failed with error: {0}", e.Message));
                    }
                }
            }
            return null;
        }

        Message CreateExample(Type type, OperationDescription od, bool generateJson)
        {
            bool usesXmlSerializer = od.Behaviors.Contains(typeof(XmlSerializerOperationBehavior));
            XmlQualifiedName name;
            XmlSchemaSet schemaSet = new XmlSchemaSet();
            IDictionary<XmlQualifiedName, Type> knownTypes = new Dictionary<XmlQualifiedName, Type>();
            if (usesXmlSerializer)
            {
                XmlReflectionImporter importer = new XmlReflectionImporter();
                XmlTypeMapping typeMapping = importer.ImportTypeMapping(type);
                name = new XmlQualifiedName(typeMapping.ElementName, typeMapping.Namespace);
                XmlSchemas schemas = new XmlSchemas();
                XmlSchemaExporter exporter = new XmlSchemaExporter(schemas);
                exporter.ExportTypeMapping(typeMapping);
                foreach (XmlSchema schema in schemas)
                {
                    schemaSet.Add(schema);
                }
            }
            else
            {
                XsdDataContractExporter exporter = new XsdDataContractExporter();
                List<Type> listTypes = new List<Type>(od.KnownTypes);
                listTypes.Add(type);
                exporter.Export(listTypes);
                if (!exporter.CanExport(type))
                {
                    throw new NotSupportedException(String.Format("Example generation is not supported for type '{0}'", type));
                }
                name = exporter.GetRootElementName(type);
                foreach (Type knownType in od.KnownTypes)
                {
                    XmlQualifiedName knownTypeName = exporter.GetSchemaTypeName(knownType);
                    if (!knownTypes.ContainsKey(knownTypeName))
                    {
                        knownTypes.Add(knownTypeName, knownType);
                    }
                }

                foreach (XmlSchema schema in exporter.Schemas.Schemas())
                {
                    schemaSet.Add(schema);
                }
            }
            schemaSet.Compile();

            XmlWriterSettings settings = new XmlWriterSettings
            {
                CloseOutput = false,
                Indent = true,
            };

            if (generateJson)
            {
                var jsonExample = new XDocument();
                using (XmlWriter writer = XmlWriter.Create(jsonExample.CreateWriter(), settings))
                {
                    HelpExampleGenerator.GenerateJsonSample(schemaSet, name, writer, knownTypes);
                }
                var reader = jsonExample.CreateReader();
                reader.MoveToContent();
                var message = Message.CreateMessage(MessageVersion.None, (string)null, reader);
                WebOperationContext.Current.OutgoingResponse.ContentType = "text/plain";
                message.Properties[WebBodyFormatMessageProperty.Name] = new WebBodyFormatMessageProperty(WebContentFormat.Json);
                return message;
            }
            else
            {
                var xmlExample = new XDocument();
                using (XmlWriter writer = XmlWriter.Create(xmlExample.CreateWriter(), settings))
                {
                    HelpExampleGenerator.GenerateXmlSample(schemaSet, name, writer);
                }
                var reader = xmlExample.CreateReader();
                reader.MoveToContent();
                var message = Message.CreateMessage(MessageVersion.None, (string)null, reader);
                message.Properties[WebBodyFormatMessageProperty.Name] = new WebBodyFormatMessageProperty(WebContentFormat.Xml);
                WebOperationContext.Current.OutgoingResponse.ContentType = "text/xml";
                return message;
            }
        }

        //[WebGet(UriTemplate = "help{operation}/request/example")]
        public Message GetRequestExample(string operation)
        {
            foreach (OperationDescription od in this.Description.Operations)
            {
                if (od.Name == operation)
                {
                    bool isXmlSerializerType;
                    Type body = GetRequestBodyType(od, out isXmlSerializerType);
                    Message result;
                    if (IsBodySpecial(body, "request", out result))
                    {
                        return result;
                    }

                    WebInvokeAttribute invoke = od.Behaviors.Find<WebInvokeAttribute>();
                    bool generateJson = false;
                    if (GetResponseFormat(null, invoke, od) == "Json")
                    {
                        generateJson = true;
                    }
                    try
                    {
                        return CreateExample(body, od, generateJson);
                    }
                    catch (Exception e)
                    {
                        return CreateTextMessage(String.Format("Could not generate example for request. Failed with error: {0}", e.Message));
                    }
                }
            }
            return null;
        }

        //[WebGet(UriTemplate = "help/{operation}/response/schema")]
        public Message GetResponseXmlSchema(string operation)
        {
            foreach (OperationDescription od in this.Description.Operations)
            {
                if (od.Name == operation)
                {
                    bool isXmlSerializerType;
                    Type body = GetResponseBodyType(od, out isXmlSerializerType);
                    Message result;
                    if (IsBodySpecial(body, "response", out result))
                    {
                        return result;
                    }
                    try
                    {
                        return CreateSchema(body, isXmlSerializerType);
                    }
                    catch (Exception e)
                    {
                        return CreateTextMessage(String.Format("Could not generate schema for response. Failed with error: {0}", e.Message));
                    }
                }
            }
            return null;
        }

        //[WebGet(UriTemplate = "help{operation}/response/example")]
        public Message GetResponseExample(string operation)
        {
            foreach (OperationDescription od in this.Description.Operations)
            {
                if (od.Name == operation)
                {
                    bool isXmlSerializerType;
                    Type body = GetResponseBodyType(od, out isXmlSerializerType);
                    Message result;
                    if (IsBodySpecial(body, "response", out result))
                    {
                        return result;
                    }
                    bool generateJson = false;
                    if (GetResponseFormat(od.Behaviors.Find<WebGetAttribute>(), od.Behaviors.Find<WebInvokeAttribute>(), od) == "Json")
                    {
                        generateJson = true;
                    }
                    try
                    {
                        return CreateExample(body, od, generateJson);
                    }
                    catch (Exception e)
                    {
                        return CreateTextMessage(String.Format("Could not generate example for response. Failed with error: {0}", e.Message));
                    }
                }
            }
            return null;
        }

        string GetDefaultInvokeMethod()
        {
            return "POST";
        }

        WebMessageFormat GetDefaultResponseFormat()
        {
            return WebMessageFormat.Xml;
        }

        string GetDefaultGetTemplate(OperationDescription od)
        {
            return null;
        }

        void CacheValidationCallback(HttpContext context, object state, ref HttpValidationStatus result)
        {
            if (((DateTime)state) == this.startupTime)
            {
                result = HttpValidationStatus.Valid;
            }
            else
            {
                result = HttpValidationStatus.Invalid;
            }
        }

        void CacheResult()
        {
            if (HttpContext.Current != null)
            {
                HttpContext.Current.Response.Cache.SetCacheability(HttpCacheability.Public);
                HttpContext.Current.Response.Cache.SetMaxAge(TimeSpan.MaxValue);
                HttpContext.Current.Response.Cache.AddValidationCallback(new HttpCacheValidateHandler(this.CacheValidationCallback), this.startupTime);
                HttpContext.Current.Response.Cache.SetValidUntilExpires(true);
            }
        }

        #region IOperationInvoker Members

        public object[] AllocateInputs()
        {
            return new object[] { null };
        }

        public object Invoke(object instance, object[] inputs, out object[] outputs)
        {
            outputs = null;
            Message result = null;
            try
            {
                UriTemplateMatch match = (UriTemplateMatch)OperationContext.Current.IncomingMessageProperties["HelpPageMatch"];
                string operation = (string)match.Data;
                if (operation == "GetFeed")
                {
                    Atom10FeedFormatter feed = GetFeed();
                    WebOperationContext.Current.OutgoingResponse.ContentType = "application/atom+xml";
                    result = Message.CreateMessage(MessageVersion.None, null, feed);
                }
                else if (operation == "GetRequestSchema")
                {
                    result = GetRequestXmlSchema(match.BoundVariables["operation"]);
                }
                else if (operation == "GetRequestExample")
                {
                    result = GetRequestExample(match.BoundVariables["operation"]);
                }
                else if (operation == "GetResponseSchema")
                {
                    result = GetResponseXmlSchema(match.BoundVariables["operation"]);
                }
                else if (operation == "GetResponseExample")
                {
                    result = GetResponseExample(match.BoundVariables["operation"]);
                }
                else
                {
                    WebOperationContext.Current.OutgoingResponse.SetStatusAsNotFound();
                    result = Message.CreateMessage(MessageVersion.None, null);
                }
                if (result != null)
                {
                    CacheResult();
                }
                else
                {
                    WebOperationContext.Current.OutgoingResponse.SetStatusAsNotFound();
                }
            }
            catch (Exception e)
            {
                WebOperationContext.Current.OutgoingResponse.StatusCode = HttpStatusCode.InternalServerError;
                WebOperationContext.Current.OutgoingResponse.StatusDescription = e.Message;
            }
            return result;
        }

        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state)
        {
            throw new NotSupportedException();
        }

        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result)
        {
            throw new NotSupportedException();
        }

        public bool IsSynchronous
        {
            get { return true; }
        }

        #endregion

        class TextBodyWriter : BodyWriter
        {
            byte[] messageBytes;

            public TextBodyWriter(string message)
                : base(true)
            {
                this.messageBytes = Encoding.UTF8.GetBytes(message);
            }

            protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
            {
                writer.WriteStartElement("Binary");
                writer.WriteBase64(this.messageBytes, 0, this.messageBytes.Length);
                writer.WriteEndElement();
            }
        }

        class HelpPageOperationSelector : IDispatchOperationSelector
        {
            UriTemplateTable table;

            public HelpPageOperationSelector(Uri baseUri)
            {
                List<KeyValuePair<UriTemplate, object>> templateList = new List<KeyValuePair<UriTemplate, object>>();
                templateList.Add(new KeyValuePair<UriTemplate, object>(new UriTemplate(HelpPageInvoker.AllOperationsTemplate), "GetFeed"));
                templateList.Add(new KeyValuePair<UriTemplate, object>(new UriTemplate(HelpPageInvoker.OperationRequestExampleTemplate), "GetRequestExample"));
                templateList.Add(new KeyValuePair<UriTemplate, object>(new UriTemplate(HelpPageInvoker.OperationRequestSchemaTemplate), "GetRequestSchema"));
                templateList.Add(new KeyValuePair<UriTemplate, object>(new UriTemplate(HelpPageInvoker.OperationResponseExampleTemplate), "GetResponseExample"));
                templateList.Add(new KeyValuePair<UriTemplate, object>(new UriTemplate(HelpPageInvoker.OperationResponseSchemaTemplate), "GetResponseSchema"));
                table = new UriTemplateTable(baseUri, templateList);
                table.MakeReadOnly(false);
            }

            public string SelectOperation(ref Message message)
            {
                if (message == null)
                {
                    return string.Empty;
                }
                object o;
                if (!message.Properties.TryGetValue(HttpRequestMessageProperty.Name, out o))
                {
                    return string.Empty;
                }
                HttpRequestMessageProperty prop = (HttpRequestMessageProperty)o;
                if (prop.Method != "GET")
                {
                    return string.Empty;
                }

                UriTemplateMatch match = table.MatchSingle(message.Properties.Via);
                if (match == null)
                {
                    return string.Empty;
                }
                message.Properties["HelpPageMatch"] = match;
                return HelpPageInvoker.OperationName;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\ExtensionHelpers.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Web;
using System.ServiceModel.Syndication;
using System.Security.Cryptography;
using System.IO;
using System.Xml;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Xml.Linq;
using System.Xml.Serialization;
using System.Collections.Specialized;
using System.Net;

namespace Microsoft.ServiceModel.Web
{
    public static class WebOperationContextExtensions
    {
        public static Uri GetRequestUri(this IncomingWebRequestContext context)
        {
            return context.UriTemplateMatch.RequestUri;
        }

        public static void ThrowIfEtagMissingOrStale(this IncomingWebRequestContext context, string expectedEtag)
        {
            string incomingEtag = context.Headers[HttpRequestHeader.IfMatch];
            if (string.IsNullOrEmpty(incomingEtag))
            {
                throw new WebProtocolException(HttpStatusCode.BadRequest, "The If-Match header was not specified for the request", null);
            }
            if (!string.Equals(incomingEtag, expectedEtag, StringComparison.Ordinal))
            {
                throw new WebProtocolException(HttpStatusCode.Conflict, String.Format("The resource has an Etag different from '{0}'. Please get the latest copy of the resource.", incomingEtag), null);
            }
        }
        public static Uri GetBaseUri(this IncomingWebRequestContext context)
        {
            return context.UriTemplateMatch.BaseUri;
        }

        public static NameValueCollection GetQueryParameters(this IncomingWebRequestContext context)
        {
            return context.UriTemplateMatch.QueryParameters;
        }

        public static Uri BindTemplateToRequestUri(this WebOperationContext context, UriTemplate template, params string[] values)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }
            if (template == null)
            {
                throw new ArgumentNullException("template");
            }
            return template.BindByPosition(context.IncomingRequest.UriTemplateMatch.BaseUri, values);
        }

        public static string SetHashEtag<T>(this OutgoingWebResponseContext context, T entityToHash)
        {
            string etag = null;
            using (MemoryStream stream = new MemoryStream())
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(T));
                using (XmlWriter writer = XmlWriter.Create(stream))
                {
                    serializer.WriteObject(writer, entityToHash);
                }
                stream.Seek(0, SeekOrigin.Begin);
                using (SHA1 hasher = new SHA1Managed())
                {
                    byte[] hash = hasher.ComputeHash(stream);
                    etag = Convert.ToBase64String(hash);
                }
            }
            context.ETag = etag;
            return etag;
        }

        public static string SetHashEtag<T>(this OutgoingWebResponseContext context, XmlObjectSerializer serializer, T entityToHash)
        {
            string etag = null;
            using (MemoryStream stream = new MemoryStream())
            {
                using (XmlWriter writer = XmlWriter.Create(stream))
                {
                    serializer.WriteObject(writer, entityToHash);
                }
                stream.Seek(0, SeekOrigin.Begin);
                using (SHA1 hasher = new SHA1Managed())
                {
                    byte[] hash = hasher.ComputeHash(stream);
                    etag = Convert.ToBase64String(hash);
                }
            }
            context.ETag = etag;
            return etag;
        }

        public static string SetHashEtag<T>(this OutgoingWebResponseContext context, XmlSerializer serializer, T entityToHash)
        {
            string etag = null;
            using (MemoryStream stream = new MemoryStream())
            {
                using (XmlWriter writer = XmlWriter.Create(stream))
                {
                    serializer.Serialize(stream, entityToHash);
                }
                stream.Seek(0, SeekOrigin.Begin);
                using (SHA1 hasher = new SHA1Managed())
                {
                    byte[] hash = hasher.ComputeHash(stream);
                    etag = Convert.ToBase64String(hash);
                }
            }
            context.ETag = etag;
            return etag;
        }

        public static string SetHashEtag<T>(this OutgoingWebResponseContext context, BinaryFormatter formatter, T entityToHash)
        {
            string etag = null;
            using (MemoryStream stream = new MemoryStream())
            {
                formatter.Serialize(stream, entityToHash);
                stream.Seek(0, SeekOrigin.Begin);
                using (SHA1 hasher = new SHA1Managed())
                {
                    byte[] hash = hasher.ComputeHash(stream);
                    etag = Convert.ToBase64String(hash);
                }
            }
            context.ETag = etag;
            return etag;
        }
    }

    public static class SyndicationExtensions
    {
        public static void AddSelfLink(this SyndicationFeed feed, Uri uri)
        {
            if (feed == null)
            {
                throw new ArgumentNullException("feed");
            }
            if (uri == null)
            {
                throw new ArgumentNullException("uri");
            }
            feed.Links.Add(SyndicationLink.CreateSelfLink(uri, ContentTypes.Atom));
        }

        public static void AddEditLink(this SyndicationItem entry, Uri uri)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }
            if (uri == null)
            {
                throw new ArgumentNullException("uri");
            }
            entry.Links.Add(new SyndicationLink(uri, "edit", "Edit Atom entry", ContentTypes.AtomEntry, 0));
        }

        public static void AddEditMediaLink(this SyndicationItem entry, Uri uri, string contentType, long contentLength)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }
            if (uri == null)
            {
                throw new ArgumentNullException("uri");
            }
            entry.Links.Add(new SyndicationLink(uri, "edit-media", "Edit media item", contentType, contentLength));
        }

        public static void AddNextPageLink(this SyndicationFeed feed, Uri uri)
        {
            if (feed == null)
            {
                throw new ArgumentNullException("feed");
            }
            if (uri == null)
            {
                throw new ArgumentNullException("uri");
            }
            feed.Links.Add(new SyndicationLink(uri, "next", "Next entries", ContentTypes.Atom, 0));
        }

        public static void AddPreviousPageLink(this SyndicationFeed feed, Uri uri)
        {
            if (feed == null)
            {
                throw new ArgumentNullException("feed");
            }
            if (uri == null)
            {
                throw new ArgumentNullException("uri");
            }
            feed.Links.Add(new SyndicationLink(uri, "previous", "Previous entries", ContentTypes.Atom, 0));
        }
    }

    public static class SerializationExtensions
    {
        public static TObject ToObject<TObject>(this XElement xml)
        {
            using (XmlReader reader = xml.CreateReader())
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(TObject));
                return (TObject)serializer.ReadObject(reader);
            }
        }

        public static TObject ToObject<TObject>(this XElement xml, XmlObjectSerializer serializer)
        {
            using (XmlReader reader = xml.CreateReader())
            {
                return (TObject)serializer.ReadObject(reader);
            }
        }

        public static TObject ToObject<TObject>(this XElement xml, XmlSerializer serializer)
        {
            using (XmlReader reader = xml.CreateReader())
            {
                return (TObject)serializer.Deserialize(reader);
            }
        }

        public static XElement ToXml<TObject>(TObject obj)
        {
            using (MemoryStream ms = new MemoryStream())
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(TObject));
                serializer.WriteObject(ms, obj);
                ms.Seek(0, SeekOrigin.Begin);
                using (XmlReader reader = XmlReader.Create(ms))
                {
                    return XElement.Load(reader);
                }
            }
        }

        public static XElement ToXml<TObject>(TObject obj, XmlObjectSerializer serializer)
        {
            using (MemoryStream ms = new MemoryStream())
            {
                serializer.WriteObject(ms, obj);
                ms.Seek(0, SeekOrigin.Begin);
                using (XmlReader reader = XmlReader.Create(ms))
                {
                    return XElement.Load(reader);
                }
            }
        }

        public static XElement ToXml<TObject>(TObject obj, XmlSerializer serializer)
        {
            using (MemoryStream ms = new MemoryStream())
            {
                serializer.Serialize(ms, obj);
                ms.Seek(0, SeekOrigin.Begin);
                using (XmlReader reader = XmlReader.Create(ms))
                {
                    return XElement.Load(reader);
                }
            }
        }
    }

    public static class ContentTypes
    {
        public const string Atom = "application/atom+xml";
        public const string AtomEntry = "application/atom+xml;type=entry";
        public const string AtomServiceDocument = "application/atomsvc+xml";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\ResponseWebFormatPropertyAttacher.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Diagnostics;
    using System.ServiceModel;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel.Dispatcher;
    using System.ServiceModel.Channels;
    using System.Xml;
    using System.ServiceModel.Security;
    using System.ServiceModel.Web;
    
    class ResponseWebFormatPropertyAttacher : IParameterInspector
    {
        public const string PropertyName = "ResponseWebFormat";

        public WebMessageFormat Format { get; set; }

        public void AfterCall(string operationName, object[] outputs, object returnValue, object correlationState)
        {
        }

        public object BeforeCall(string operationName, object[] inputs)
        {
            OperationContext.Current.IncomingMessageProperties[PropertyName] = this.Format;
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\RequestInterceptor.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;

namespace Microsoft.ServiceModel.Web
{
    delegate void Process(ref RequestContext context);

    public abstract class RequestInterceptor
    {
        Process process;

        protected RequestInterceptor(bool isSynchronous)
        {
            this.IsSynchronous = isSynchronous;
            process = this.ProcessRequest;
        }

        public bool IsSynchronous { get; private set; }

        public abstract void ProcessRequest(ref RequestContext requestContext);

        public virtual IAsyncResult BeginProcessRequest(RequestContext context, AsyncCallback callback, object state)
        {
            return this.process.BeginInvoke(ref context, callback, state);
        }

        public virtual RequestContext EndProcessRequest(IAsyncResult result)
        {
            RequestContext context = null;
            this.process.EndInvoke(ref context, result);
            return context;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebErrorHandler.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Diagnostics;
    using System.ServiceModel;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel.Dispatcher;
    using System.ServiceModel.Channels;
    using System.Xml;
    using System.ServiceModel.Security;
    using System.ServiceModel.Web;
    using System.Web;
    
    class WebErrorHandler : IErrorHandler
    {
        public bool EnableAspNetCustomErrors { get; set; }

        public bool IncludeExceptionDetailInFaults { get; set; }

        public bool HandleError(Exception error)
        {
            return true;
        }

        public void ProvideFault(Exception error, MessageVersion version, ref Message fault)
        {
            WebProtocolException webError = error as WebProtocolException;
            string errorMessage = (this.IncludeExceptionDetailInFaults) ? error.Message : "The server encountered an error processing the request. Please see the server logs for more details.";
            if (webError == null)
            {
                if (error is SecurityAccessDeniedException) webError = new WebProtocolException(HttpStatusCode.Unauthorized, errorMessage, error);
                else if (error is ServerTooBusyException) webError = new WebProtocolException(HttpStatusCode.ServiceUnavailable, errorMessage, error);
                else if (error is FaultException)
                {
                    FaultException fe = error as FaultException;
                    if (fe.Code.IsSenderFault)
                    {
                        if (fe.Code.SubCode.Name == "FailedAuthentication")
                        {
                            webError = new WebProtocolException(HttpStatusCode.Unauthorized, fe.Reason.Translations[0].Text, fe);
                        }
                        else
                        {
                            webError = new WebProtocolException(HttpStatusCode.BadRequest, fe.Reason.Translations[0].Text, fe);
                        }
                    }
                    else
                    {
                        webError = new WebProtocolException(HttpStatusCode.InternalServerError, fe.Reason.Translations[0].Text, fe);
                    }
                }
                else
                {
                    webError = new WebProtocolException(HttpStatusCode.InternalServerError, errorMessage, error);
                }
            }
            if (version == MessageVersion.None)
            {
                WebMessageFormat format = WebMessageFormat.Xml;
                object dummy;
                if (OperationContext.Current.IncomingMessageProperties.TryGetValue(ResponseWebFormatPropertyAttacher.PropertyName, out dummy))
                {
                    format = (WebMessageFormat) dummy;
                }
                fault = Message.CreateMessage(MessageVersion.None, null, new ErrorBodyWriter() { Error = webError, Format = format });
                HttpResponseMessageProperty prop = new HttpResponseMessageProperty();
                prop.StatusCode = webError.StatusCode;
                prop.StatusDescription = webError.StatusDescription;
                if (format == WebMessageFormat.Json)
                {
                    prop.Headers[HttpResponseHeader.ContentType] = "application/json";
                }
                else if (webError.IsDetailXhtml)
                {
                    prop.Headers[HttpResponseHeader.ContentType] = "text/html";
                }
                fault.Properties[HttpResponseMessageProperty.Name] = prop;
                WebBodyFormatMessageProperty formatProp = new WebBodyFormatMessageProperty((format == WebMessageFormat.Json) ? WebContentFormat.Json : WebContentFormat.Xml);
                fault.Properties[WebBodyFormatMessageProperty.Name] = formatProp;
            }
            if (this.EnableAspNetCustomErrors && HttpContext.Current != null)
            {
                HttpContext.Current.AddError(error);
            }
        }

        class ErrorBodyWriter : BodyWriter
        {
            public ErrorBodyWriter()
                : base(true)
            {
            }

            public WebProtocolException Error { get; set; }

            public WebMessageFormat Format { get; set; }

            protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
            {
                Error.WriteDetail(writer, this.Format);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebServiceHost2Factory.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System.Web;
    using System.Web.Hosting;
    using System.IO;
    using System.ServiceModel.Web;
    using System.ServiceModel.Diagnostics;
    using System.ServiceModel.Activation;
    using System.Web.Compilation;
    using System.Reflection;
    using System;
    using System.ServiceModel;
    using System.Collections.ObjectModel;

    public class WebServiceHost2Factory : ServiceHostFactory
    {
        protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            return new WebServiceHost2(serviceType, true, baseAddresses);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebHttpBehavior2.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System.Threading;
    using System.ServiceModel.Diagnostics;
    using System.Diagnostics;
    using System;
    using System.ServiceModel.Description;
    using System.ServiceModel.Dispatcher;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Web;
    using System.Xml;
    using System.Text;
    using System.Web;
    using System.Collections.Specialized;
    using System.Security;
    using System.Security.Principal;
    using System.Web.Configuration;

    public class WebHttpBehavior2 : WebHttpBehavior
    {
        public WebHttpBehavior2()
            : base()
        {
            this.EnableAutomaticHelpPage = true;
            this.HelpPageLink = HelpPageInvoker.AllOperationsTemplate;
        }

        public bool EnableAutomaticHelpPage { get; set; }

        public string HelpPageLink { get; set; }

        public bool EnableAspNetCustomErrors { get; set; }

        protected override IDispatchMessageFormatter GetRequestDispatchFormatter(OperationDescription operationDescription, ServiceEndpoint endpoint)
        {
            IDispatchMessageFormatter inner = base.GetRequestDispatchFormatter(operationDescription, endpoint);
            return new FormsPostDispatchMessageFormatter(operationDescription, inner, this.GetQueryStringConverter(operationDescription));
        }

        public override void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)
        {
            base.ApplyDispatchBehavior(endpoint, endpointDispatcher);
            if (this.EnableAutomaticHelpPage)
            {
                HelpPageInvoker invoker = new HelpPageInvoker() { Description = endpoint.Contract, BaseUri = endpoint.ListenUri, Behavior = this };
                endpointDispatcher.DispatchRuntime.OperationSelector = new WrappedOperationSelector(invoker.GetHelpPageOperationSelector(), endpointDispatcher.DispatchRuntime.OperationSelector);
                // add the help page operation
                DispatchOperation helpPageOperation = new DispatchOperation(endpointDispatcher.DispatchRuntime, HelpPageInvoker.OperationName, "help", null);
                helpPageOperation.DeserializeRequest = false;
                helpPageOperation.SerializeReply = false;
                helpPageOperation.Invoker = invoker;
                endpointDispatcher.DispatchRuntime.Operations.Add(helpPageOperation);
            }
            endpointDispatcher.DispatchRuntime.Operations.Remove(endpointDispatcher.DispatchRuntime.UnhandledDispatchOperation);
            endpointDispatcher.DispatchRuntime.UnhandledDispatchOperation = new DispatchOperation(endpointDispatcher.DispatchRuntime, "*", "*", "*");
            endpointDispatcher.DispatchRuntime.UnhandledDispatchOperation.DeserializeRequest = false;
            endpointDispatcher.DispatchRuntime.UnhandledDispatchOperation.SerializeReply = false;
            endpointDispatcher.DispatchRuntime.UnhandledDispatchOperation.Invoker = new UnhandledOperationInvoker() { BaseUri = endpoint.ListenUri, HelpPageLink = this.HelpPageLink };
        }

        protected override void AddServerErrorHandlers(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)
        {
            foreach (OperationDescription od in endpoint.Contract.Operations)
            {
                WebMessageFormat outgoingFormat = WebMessageFormat.Xml;
                WebGetAttribute getAttr = od.Behaviors.Find<WebGetAttribute>();
                if (getAttr != null)
                {
                    outgoingFormat = (getAttr.IsResponseFormatSetExplicitly) ? getAttr.ResponseFormat : base.DefaultOutgoingResponseFormat;
                }
                else
                {
                    WebInvokeAttribute invokeAttr = od.Behaviors.Find<WebInvokeAttribute>();
                    if (invokeAttr != null)
                    {
                        outgoingFormat = (invokeAttr.IsResponseFormatSetExplicitly) ? invokeAttr.ResponseFormat : base.DefaultOutgoingResponseFormat;
                    }
                }
                endpointDispatcher.DispatchRuntime.Operations[od.Name].ParameterInspectors.Add(new ResponseWebFormatPropertyAttacher() { Format =  outgoingFormat });
            }
            endpointDispatcher.ChannelDispatcher.ErrorHandlers.Add(new WebErrorHandler() { EnableAspNetCustomErrors = this.EnableAspNetCustomErrors, IncludeExceptionDetailInFaults = endpointDispatcher.DispatchRuntime.ChannelDispatcher.IncludeExceptionDetailInFaults });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebCacheAttribute.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;
using System.Web.UI;
using System.Web.Configuration;
using System.ServiceModel.Web;
using System.Web.Caching;

namespace Microsoft.ServiceModel.Web
{
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class WebCacheAttribute : Attribute, IOperationBehavior
    {
        public WebCacheAttribute()
        {
            this.Location = OutputCacheLocation.Any;
        }

        public int Duration { get; set; }

        public OutputCacheLocation Location { get; set; }

        public bool NoStore { get; set; }

        public string SqlDependency { get; set; }

        public string VaryByHeader { get; set; }

        public string VaryByParam { get; set; }

        public string VaryByCustom { get; set; }

        public string CacheProfileName { get; set; }

        internal OutputCacheProfile CacheProfile { get; set; }

        
        public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation)
        {
            throw new NotSupportedException();
        }

        public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
        {
            if (this.CacheProfile == null)
            {
                this.CacheProfile = new OutputCacheProfile("temp");
                this.CacheProfile.Duration = this.Duration;
                this.CacheProfile.NoStore = this.NoStore;
                this.CacheProfile.SqlDependency = this.SqlDependency;
                this.CacheProfile.Location = this.Location;
                this.CacheProfile.VaryByCustom = this.VaryByCustom;
                this.CacheProfile.VaryByHeader = this.VaryByHeader;
                this.CacheProfile.VaryByParam = this.VaryByParam;
            }
            dispatchOperation.ParameterInspectors.Add(new CachingParameterInspector(this.CacheProfile));
        }

        public void Validate(OperationDescription operationDescription)
        {
            if (!ServiceHostingEnvironment.AspNetCompatibilityEnabled)
            {
                throw new NotSupportedException("WebCacheAttribute is supported only in AspNetCompatibility mode.");
            }
            if (operationDescription.Behaviors.Find<WebGetAttribute>() == null)
            {
                throw new InvalidOperationException("The WebCacheAttribute can only be used with GET operations.");
            }
            if (!string.IsNullOrEmpty(this.CacheProfileName))
            {
                OutputCacheProfile cacheProfile = null;
                OutputCacheSettingsSection cacheSettings = (OutputCacheSettingsSection)WebConfigurationManager.GetSection("system.web/caching/outputCacheSettings");
                if (cacheSettings == null)
                {
                    throw new InvalidOperationException(String.Format("Cache profile with name '{0}' is not configured.", this.CacheProfileName));
                }
                cacheProfile = cacheSettings.OutputCacheProfiles[this.CacheProfileName];
                if (cacheProfile == null)
                {
                    throw new InvalidOperationException(String.Format("Cache profile with name '{0}' is not configured.", this.CacheProfileName));
                }
                if (!cacheProfile.Enabled)
                {
                    throw new InvalidOperationException(String.Format("Cache profile with name '{0}' is disabled.", this.CacheProfileName));
                }
                this.CacheProfile = cacheProfile;
            }
            if (string.Equals(this.SqlDependency, "CommandNotification", StringComparison.OrdinalIgnoreCase))
            {
                throw new NotSupportedException("CommandNotification is not supported as a valid sql dependency currently");
            }
            // validate that the dependency has been properly configured in sql
            if (!string.IsNullOrEmpty(this.SqlDependency))
            {
                foreach (SqlCacheDependency dependency in CachingParameterInspector.CreateSqlDependencies(this.SqlDependency))
                {
                    dependency.Dispose();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebHelpAttribute.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;

namespace Microsoft.ServiceModel.Web
{
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class WebHelpAttribute : Attribute, IOperationBehavior
    {
        public string Comment { get; set; }

        public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation)
        {
        }

        public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
        {
        }

        public void Validate(OperationDescription operationDescription)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebServiceHost2.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System.Threading;
    using System.ServiceModel.Diagnostics;
    using System.Diagnostics;
    using System;
    using System.Collections.ObjectModel;
    using System.ServiceModel.Description;
    using System.ServiceModel.Dispatcher;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Web;
    using System.Xml;
    using System.Text;
    using System.Web;
    using System.Collections.Generic;
    using System.ServiceModel;
    using System.Web.Security;

    public class WebServiceHost2 : WebServiceHost
    {
        Collection<RequestInterceptor> interceptors = new Collection<RequestInterceptor>();

        public WebServiceHost2(object singletonInstance, params Uri[] baseAddresses)
            : base(singletonInstance, baseAddresses)
        {
            this.EnableAutomaticHelpPage = true;
            this.HelpPageLink = HelpPageInvoker.AllOperationsTemplate;
            this.PrincipalPermissionMode = PrincipalPermissionMode.UseAspNetRoles;
            this.Interceptors.Add(new CurrentPrincipalRequestInterceptor());
            this.TransferMode = TransferMode.Buffered;
        }

        public WebServiceHost2(Type serviceType, bool dummy, params Uri[] baseAddresses)
            : base(serviceType, baseAddresses)
        {
            this.EnableAutomaticHelpPage = true;
            this.HelpPageLink = HelpPageInvoker.AllOperationsTemplate;
            this.PrincipalPermissionMode = PrincipalPermissionMode.UseAspNetRoles;
            this.Interceptors.Add(new CurrentPrincipalRequestInterceptor());
            this.TransferMode = TransferMode.Buffered;
        }

        #region WebServiceHost settings

        public TransferMode TransferMode { get; set; }

        public Collection<RequestInterceptor> Interceptors { get { return this.interceptors; } }

        public long MaxMessageSize { get; set; }

        public XmlDictionaryReaderQuotas ReaderQuotas { get; set; }

        public int MaxConcurrentCalls { get; set; }

        public bool EnableAutomaticHelpPage { get; set; }

        public string HelpPageLink { get; set; }

        public bool EnableAspNetCustomErrors { get; set; }

        public PrincipalPermissionMode PrincipalPermissionMode { get; set; }

        #endregion

        protected override void OnOpening()
        {
            base.OnOpening();
            foreach (var ep in this.Description.Endpoints)
            {
                if (ep.Behaviors.Find<WebHttpBehavior>() != null)
                {
                    ep.Behaviors.Remove<WebHttpBehavior>();
                    ep.Behaviors.Add(new WebHttpBehavior2() { EnableAspNetCustomErrors = this.EnableAspNetCustomErrors, EnableAutomaticHelpPage = this.EnableAutomaticHelpPage, HelpPageLink = this.HelpPageLink });
                }

                CustomBinding binding = new CustomBinding(ep.Binding);
                if (this.MaxMessageSize != 0)
                {
                    binding.Elements.Find<TransportBindingElement>().MaxReceivedMessageSize = this.MaxMessageSize;
                }
                if (this.TransferMode != TransferMode.Buffered)
                {
                    binding.Elements.Find<HttpTransportBindingElement>().TransferMode = this.TransferMode;
                }
                if (this.ReaderQuotas != null)
                {
                    this.ReaderQuotas.CopyTo(binding.Elements.Find<TextMessageEncodingBindingElement>().ReaderQuotas);
                }
                if (this.Interceptors.Count > 0)
                {
                    binding.Elements.Insert(0, new RequestInterceptorBindingElement(this.Interceptors));
                }
                ep.Binding =  binding;
            }
            if (this.MaxConcurrentCalls != 0)
            {
                ServiceThrottlingBehavior throttlingBehavior = this.Description.Behaviors.Find<ServiceThrottlingBehavior>();
                if (throttlingBehavior == null)
                {
                    throttlingBehavior = new ServiceThrottlingBehavior();
                    this.Description.Behaviors.Add(throttlingBehavior);
                }
                throttlingBehavior.MaxConcurrentCalls = this.MaxConcurrentCalls;
            }
            ServiceAuthorizationBehavior authz = this.Description.Behaviors.Find<ServiceAuthorizationBehavior>();
            authz.PrincipalPermissionMode = this.PrincipalPermissionMode;
            if (authz.PrincipalPermissionMode == PrincipalPermissionMode.UseAspNetRoles && authz.RoleProvider == null && Roles.Enabled)
            {
                authz.RoleProvider = Roles.Provider;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WebProtocolException.cs ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace Microsoft.ServiceModel.Web
{
    using System.Threading;
    using System.ServiceModel.Diagnostics;
    using System.Diagnostics;
    using System;
    using System.ServiceModel;
    using System.Net;
    using System.Xml.Linq;
    using System.Xml;
    using System.Runtime.Serialization;
    using System.IO;
    using System.Globalization;
    using System.ServiceModel.Web;
using System.Runtime.Serialization.Json;

    public class WebProtocolException : CommunicationException
    {
        DetailWriter detailWriter;

        public WebProtocolException(HttpStatusCode statusCode) : this(statusCode, GetDefaultStatusDescription(statusCode), null) { }

        public WebProtocolException(HttpStatusCode statusCode, string message, Exception innerException) : this(statusCode, message, message, innerException) { }

        public WebProtocolException(HttpStatusCode statusCode, string statusDescription, XElement detail, bool isDetailXhtml, Exception innerException)
        {
            this.StatusCode = statusCode;
            this.StatusDescription = statusDescription;
            this.IsDetailXhtml = isDetailXhtml;
            this.detailWriter = new XElementDetailWriter() { Element = detail };
        }

        public WebProtocolException(HttpStatusCode statusCode, string statusDescription, string detail, Exception innerException)
            : base(statusDescription, innerException)
        {
            this.StatusCode = statusCode;
            this.StatusDescription = statusDescription;
            this.IsDetailXhtml = true;
            this.detailWriter = new StringDetailWriter() { Detail = detail, StatusCode = statusCode };
        }

        public WebProtocolException(HttpStatusCode statusCode, string statusDescription, object dataContractDetail, Exception innerException) :
            this(statusCode, statusDescription, dataContractDetail, null, innerException)
        {
        }

        public WebProtocolException(HttpStatusCode statusCode, string statusDescription, object dataContractDetail, Func<WebMessageFormat, XmlObjectSerializer> serializerFactory, Exception innerException)
            : base(statusDescription, innerException)
        {
            this.StatusCode = statusCode;
            this.StatusDescription = statusDescription;
            if (dataContractDetail != null)
            {
                if (serializerFactory == null) 
                {
                    serializerFactory = ((format) => (format == WebMessageFormat.Json) ? (XmlObjectSerializer) (new DataContractJsonSerializer(dataContractDetail.GetType())) : (XmlObjectSerializer) (new DataContractSerializer(dataContractDetail.GetType())));
                }
            }
            this.detailWriter = new DataContractDetailWriter() { Detail = dataContractDetail, SerializerFactory = serializerFactory };
        }

        protected WebProtocolException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public HttpStatusCode StatusCode { get; private set; }

        public string StatusDescription { get; private set; }

        public bool IsDetailXhtml { get; private set; }

        internal protected virtual void WriteDetail(XmlWriter writer, WebMessageFormat format)
        {
            this.detailWriter.WriteDetail(writer, format);
        }

        static string GetDefaultStatusDescription(HttpStatusCode statusCode)
        {
            return statusCode.ToString();
        }

        abstract class DetailWriter
        {
            public abstract void WriteDetail(XmlWriter writer, WebMessageFormat format);
        }

        class XElementDetailWriter : DetailWriter
        {
            public XElement Element { get; set; }

            public override void WriteDetail(XmlWriter writer, WebMessageFormat format)
            {
                if (this.Element != null)
                {
                    this.Element.WriteTo(writer);
                }
            }
        }

        class DataContractDetailWriter : DetailWriter
        {
            public object Detail { get; set; }
            public Func<WebMessageFormat, XmlObjectSerializer> SerializerFactory { get; set; }

            public override void WriteDetail(XmlWriter writer, WebMessageFormat format)
            {
                if (this.Detail != null)
                {
                    this.SerializerFactory(format).WriteObject(writer, this.Detail);
                }
            }
        }

        class StringDetailWriter : DetailWriter
        {
            const string xhtmlFormat = "<?xml version=\"1.0\" encoding=\"utf-8\"?><html xmlns=\"http://www.w3.org/1999/xhtml\" version=\"-//W3C//DTD XHTML 2.0//EN\" xml:lang=\"en\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd\"><HEAD><TITLE>Request Error</TITLE></HEAD><BODY><DIV id=\"content\"><P class=\"heading1\"><B>Error Status Code:</B> '{0}'</P><P><B>Details: </B>{1}</P><!-- Padding xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx--></DIV></BODY></html>";

            public string Detail { get; set; }
            public HttpStatusCode StatusCode { get; set; }

            public override void WriteDetail(XmlWriter writer, WebMessageFormat format)
            {
                if (format == WebMessageFormat.Xml)
                {
                    if (this.Detail != null)
                    {
                        string html = String.Format(CultureInfo.InvariantCulture, xhtmlFormat, this.StatusCode.ToString(), this.Detail);
                        XElement element = XElement.Load(new StringReader(html));
                        element.WriteTo(writer);
                    }
                }
                else
                {
                    new DataContractJsonSerializer(typeof(JsonErrorData)).WriteObject(writer, new JsonErrorData() { Detail = this.Detail });
                }
            }

            [DataContract]
            class JsonErrorData
            {
                [DataMember]
                public string Detail { get; set; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\UnhandledOperationInvoker.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;
using System.ServiceModel.Syndication;
using System.Threading;
using System.ServiceModel.Web;
using System.Xml;
using System.Runtime.Serialization;
using System.Xml.Schema;
using System.Xml.Linq;
using System.IO;
using System.Net;
using System.Runtime.Serialization.Json;
using System.Globalization;

namespace Microsoft.ServiceModel.Web
{
    class UnhandledOperationInvoker : IOperationInvoker
    {
        public Uri BaseUri { get; set; }

        public string HelpPageLink { get; set; }

        public object[] AllocateInputs()
        {
            return new object[] { null };
        }

        public object Invoke(object instance, object[] inputs, out object[] outputs)
        {
            Message message = inputs[0] as Message;
            // We might be here because we desire a redirect...
            Uri newLocation = null;
            Uri to = message.Headers.To;
            if (message.Properties.ContainsKey("WebHttpRedirect"))
            {
                newLocation = message.Properties["WebHttpRedirect"] as Uri;
            }
            if (newLocation != null && to != null)
            {
                // ...redirect
                Message redirectResult = Message.CreateMessage(MessageVersion.None, null);
                HttpResponseMessageProperty redirectResp = new HttpResponseMessageProperty();
                redirectResp.StatusCode = HttpStatusCode.TemporaryRedirect;
                redirectResp.Headers.Add(HttpResponseHeader.Location, newLocation.AbsoluteUri);
                redirectResp.Headers.Add(HttpResponseHeader.ContentType, "text/html");
                redirectResult.Properties.Add(HttpResponseMessageProperty.Name, redirectResp);
                outputs = null;
                return redirectResult;
            }
            // otherwise we are here to issue either a 404 or a 405
            bool uriMatched = false;
            if (message.Properties.ContainsKey("UriMatched"))
            {
                uriMatched = (bool)message.Properties["UriMatched"];
            }
            Uri helpPageUri;
            if (!Uri.TryCreate(this.HelpPageLink, UriKind.Absolute, out helpPageUri))
            {
                helpPageUri = new Uri(string.Format(CultureInfo.InvariantCulture, "{0}/{1}",  this.BaseUri.AbsoluteUri, this.HelpPageLink));
            }
            Message result = Message.CreateMessage(MessageVersion.None, null, new ErrorPageBodyWriter() { UriMatched = uriMatched, HelpPageUri = helpPageUri });
            HttpResponseMessageProperty resp = new HttpResponseMessageProperty();
            if (uriMatched)
            {
                resp.StatusCode = HttpStatusCode.MethodNotAllowed;
            }
            else
            {
                resp.StatusCode = HttpStatusCode.NotFound;
            }
            resp.Headers.Add(HttpResponseHeader.ContentType, "text/html");
            result.Properties.Add(HttpResponseMessageProperty.Name, resp);
            outputs = null;
            return result;
        }

        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state)
        {
            throw new NotSupportedException();
        }

        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result)
        {
            throw new NotSupportedException();
        }

        public bool IsSynchronous
        {
            get { return true; }
        }

        class ErrorPageBodyWriter : BodyWriter
        {
            const string xhtmlFormat = "<?xml version=\"1.0\" encoding=\"utf-8\"?><html xmlns=\"http://www.w3.org/1999/xhtml\" version=\"-//W3C//DTD XHTML 2.0//EN\" xml:lang=\"en\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd\"><HEAD><TITLE>Request Error</TITLE></HEAD><BODY><DIV id=\"content\"><P class=\"heading1\"><B>Error Description:</B> '{0}'</P><P><B>This may be because an invalid URI or HTTP method was specified. Please see the <A HREF=\"{1}\">service help page</A> for constructing valid requests to the service.</B></P><!-- Padding xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx--></DIV></BODY></html>";

            public ErrorPageBodyWriter()
                : base(true)
            {
            }

            public bool UriMatched { get; set; }

            public Uri HelpPageUri { get; set; }

            protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
            {
                string helpPage;
                if (this.UriMatched)
                {
                    helpPage = String.Format(xhtmlFormat, "HTTP Method not allowed", this.HelpPageUri.AbsoluteUri);
                }
                else
                {
                    helpPage = String.Format(xhtmlFormat, "Resource does not exist", this.HelpPageUri.AbsoluteUri);
                }
                XElement xml = XElement.Load(new StringReader(helpPage));
                xml.WriteTo(writer);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\WrappedOperationSelector.cs ===
﻿//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Web;
using System.IdentityModel.Claims;
using System.ServiceModel.Security;
using System.Collections.ObjectModel;
using System.ServiceModel.Dispatcher;

namespace Microsoft.ServiceModel.Web
{
    class WrappedOperationSelector : IDispatchOperationSelector
    {
        IDispatchOperationSelector[] selectors;

        public WrappedOperationSelector(params IDispatchOperationSelector[] selectors)
        {
            if (selectors != null)
            {
                this.selectors = new IDispatchOperationSelector[selectors.Length];
                for (int i = 0; i < selectors.Length; ++i)
                {
                    this.selectors[i] = selectors[i];
                }
            }
            else
            {
                this.selectors = new IDispatchOperationSelector[] { };
            }
        }
     
        public string SelectOperation(ref Message message)
        {
            for (int i = 0; i < this.selectors.Length; ++i)
            {
                string name = this.selectors[i].SelectOperation(ref message);
                if (!string.IsNullOrEmpty(name))
                {
                    return name;
                }
            }
            return string.Empty;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\SpecializedServices\AtomPubServiceHost.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.ServiceModel.Syndication;
using Microsoft.ServiceModel.Web;
using System.Linq;
using System.Net;
using System.Xml.Linq;
using System.Xml;
using System.IO;
using System.Globalization;
using System.ComponentModel;
using System.Reflection;
using System.ServiceModel.Description;

namespace Microsoft.ServiceModel.Web.SpecializedServices
{
    public class AtomPubServiceHost : WebServiceHost2
    {
        public AtomPubServiceHost(object singletonInstance, params Uri[] baseAddresses)
            : base(singletonInstance, baseAddresses)
        {
            if (!(singletonInstance is AtomPubServiceBase))
            {
                throw new ArgumentException(String.Format("singletonInstance must derive from '{0}'", typeof(AtomPubServiceBase)));
            }
        }

        public AtomPubServiceHost(Type serviceType, params Uri[] baseAddresses)
            : base(serviceType, false, baseAddresses)
        {
            if (!typeof(AtomPubServiceBase).IsAssignableFrom(serviceType))
            {
                throw new ArgumentException(String.Format("serviceType must derive from '{0}'", typeof(AtomPubServiceBase)));
            }
        }

        protected override void OnOpening()
        {
            base.OnOpening();
            // Add any WebCache and WebHelp attributes specified on the derived class to the service description
            CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "GetEntries", new string[] { "GetFeed" });
            CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "GetServiceDocument", new string[] { "GetDocument" });
            CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "GetEntry", new string[] { "GetAtomEntry" });
            CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "GetMedia", new string[] { "GetMediaItem" });
        }

        internal static void CopyAttributeBehaviors(ServiceDescription description, Type[] behaviorTypes, string derivedMethodName, string[] operationNames)
        {
            Type serviceType = description.ServiceType;
            MethodInfo getEntriesMethod = serviceType.GetMethod(derivedMethodName, BindingFlags.FlattenHierarchy | BindingFlags.Instance | BindingFlags.NonPublic);
            foreach (Type behaviorType in behaviorTypes)
            {
                object[] attrs = getEntriesMethod.GetCustomAttributes(behaviorType, true);
                if (attrs != null && attrs.Length > 0)
                {
                    IOperationBehavior attrAsBehavior = (IOperationBehavior)attrs[0];
                    foreach (ServiceEndpoint endpoint in description.Endpoints)
                    {
                        foreach (OperationDescription od in endpoint.Contract.Operations)
                        {
                            if (operationNames.Contains(od.Name))
                            {
                                od.Behaviors.Remove(behaviorType);
                                od.Behaviors.Add(attrAsBehavior);
                            }
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\SpecializedServices\CollectionServiceHost.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.ServiceModel.Syndication;
using Microsoft.ServiceModel.Web;
using System.Linq;
using System.Net;
using System.Xml.Linq;
using System.Xml;
using System.IO;
using System.Globalization;
using System.ComponentModel;
using System.Reflection;
using System.ServiceModel.Description;

namespace Microsoft.ServiceModel.Web.SpecializedServices
{
    public class CollectionServiceHost : WebServiceHost2
    {
        public CollectionServiceHost(object singletonInstance, params Uri[] baseAddresses)
            : base(singletonInstance, baseAddresses)
        {
        }

        public CollectionServiceHost(Type serviceType, params Uri[] baseAddresses)
            : base(serviceType, false, baseAddresses)
        {
        }

        protected override void OnOpening()
        {
            base.OnOpening();
            // Add any WebCache and WebHelp attributes specified on the derived class to the service description
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "OnGetItems", new string[] { "GetItemsInXml", "GetItemsInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "OnGetItem", new string[] { "GetItemInXml", "GetItemInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebHelpAttribute) }, "OnAddItem", new string[] { "AddItemInXml", "AddItemInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebHelpAttribute) }, "OnUpdateItem", new string[] { "UpdateItemInXml", "UpdateItemInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebHelpAttribute) }, "OnDeleteItem", new string[] { "DeleteItem" });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\SpecializedServices\AtomPubServiceBase.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.ServiceModel.Syndication;
using Microsoft.ServiceModel.Web;
using System.Linq;
using System.Net;
using System.Xml.Linq;
using System.Xml;
using System.IO;
using System.Globalization;
using System.ComponentModel;

namespace Microsoft.ServiceModel.Web.SpecializedServices
{
    #region Base class for AtomPub service - implements REST interface and has utility methods
    public abstract class AtomPubServiceBase
    {
        // URI template definitions for how clients can access the items.
        /// <summary>
        /// The URI template to get the Atom feed representing the collection. The URL is of the form http://<url-for-svc-file>/collection1
        /// </summary>
        public const string AllEntriesTemplate = "{collection}";
        /// <summary>
        /// The URI template to get the Atom feed representing the partial collection. The URL is of the form http://<url-for-svc-file>/collection1?startIndex=0&maxItems=100
        /// </summary>
        public const string PagedEntriesTemplate = "{collection}?page={pageNumber}";
        /// <summary>
        /// The URI template to manipulate a particular Atom Entry. The URL is of the form http://<url-for-svc-file>/collection1/item1
        /// </summary>
        public const string EntryTemplate = "{collection}/{id}";
        /// <summary>
        /// The URI template to manipulate a media item. The URL is of the form http://<url-for-svc-file>/collection1/media/item1
        /// </summary>
        public const string MediaItemTemplate = "{collection}/media/{id}";
        /// <summary>
        /// the URI template for the service document describing the collection. The URL is of the form http://<url-for-svc-file>/
        /// </summary>
        public const string DocumentTemplate = "";

        /// <summary>
        /// Specifies the maximum number of entries that are returned in the feed at a single time. If this is less than int.MaxValue, then the feed will
        /// contain a link to the next set of entries.
        /// </summary>
        protected virtual int GetMaximumEntriesInFeed(string collection)
        {
            return int.MaxValue;
        }

        /// <summary>
        /// Returns the items in the collection in the specified range. 
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="id">id of the entry</param>
        /// <returns></returns>
        protected abstract IEnumerable<SyndicationItem> GetEntries(string collection, int startIndex, int maxEntries, out bool hasMoreEntries);

        /// <summary>
        /// Gets the SyndicationItem corresponding to the id. Return null if it does not exist
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="id">id of the entry</param>
        /// <returns></returns>
        protected abstract SyndicationItem GetEntry(string collection, string id);

        /// <summary>
        /// Gets the SyndicationItem corresponding to the id. Return null if it does not exist.
        /// Set the contentType of the media item.
        /// </summary>
        /// <param name="collection">collection name</param> 
        /// <param name="id">id of the entry</param>
        /// <param name="contentType">content type of the item</param>
        /// <returns></returns>
        protected abstract Stream GetMedia(string collection, string id, out string contentType);

        /// <summary>
        /// Add the media item (represented by the stream, contentType and description) to the collection
        /// Return the id of the media item and the Atom entry representing it. If the item could not be added return null.
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="stream">request entity body</param>
        /// <param name="contentType">content type of request</param>
        /// <param name="description">description, as provided in the Slug header</param>
        /// <param name="location">Uri for the media entry</param>
        /// <returns></returns>
        protected abstract SyndicationItem AddMedia(string collection, Stream stream, string contentType, string description, out Uri location);

        /// <summary>
        /// Add the Atom entry to the collection. Return its id and the actual entry that was added to the collection. 
        /// If the item could not be added return null.
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="entry">entry to be added</param>
        /// <param name="location">URI for the added entry</param>
        /// <returns></returns>
        protected abstract SyndicationItem AddEntry(string collection, SyndicationItem entry, out Uri location);

        /// <summary>
        /// Update the Atom entry specified by the id. If none exists, return null. Return the updated Atom entry. Return null if the entry does not exist.
        /// This method must be idempotent.
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="id">id of the entry</param>
        /// <param name="entry">Entry to put</param>
        /// <returns></returns>
        protected abstract SyndicationItem PutEntry(string collection, string id, SyndicationItem entry);

        /// <summary>
        /// Update the media item specified by the id. Return false if no such item exists.
        /// This method must be idempotent.
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="id">id of the item</param>
        /// <param name="stream">new value for the media item</param>
        /// <param name="contentType">content type of the new value</param>
        /// <param name="description">description, as specifued in the Slug header</param>
        /// <returns></returns>
        protected abstract bool PutMedia(string collection, string id, Stream stream, string contentType, string description);

        /// <summary>
        /// Delete the Atom entry with the specified id. Return false if no such entry exists.
        /// This method should be idempotent.
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="id">id of the entry</param>
        /// <returns></returns>
        protected abstract bool DeleteEntry(string collection, string id);

        /// <summary>
        /// Delete the media item with the specified id. Return false if no such item exists.
        /// This method should be idempotent.
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <param name="id">id of the entry</param>
        /// <returns></returns>
        protected abstract bool DeleteMedia(string collection, string id);

        /// <summary>
        /// Create a feed container object (containing no entries) for the input collection
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <returns></returns>
        protected abstract SyndicationFeed CreateFeed(string collection);

        /// <summary>
        /// Return true if the collection name is a valid collection, false otherwise
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <returns></returns>
        protected abstract bool IsValidCollection(string collection);

        /// <summary>
        /// Return the service document describing the collections hosted by the service
        /// </summary>
        /// <returns></returns>
        protected abstract ServiceDocument GetServiceDocument();

        /// <summary>
        /// Return the content types of items that can be added to the collection
        /// </summary>
        /// <param name="collection">collection name</param>
        /// <returns></returns>
        protected abstract IEnumerable<string> GetAllowedContentTypes(string collection);

        /// <summary>
        /// Return true if an item of the specified content type can be added to the collection
        /// </summary>
        protected virtual bool IsContentTypeAllowed(string collection, string contentType)
        {
            // Default content type matching logic does basic string equality. Modify the logic if needed
            foreach (string allowedContentType in this.GetAllowedContentTypes(collection))
            {
                if (allowedContentType == "*/*") return true;
                if (contentType.StartsWith(allowedContentType, StringComparison.Ordinal)) return true;
                if (allowedContentType.EndsWith("/*", StringComparison.Ordinal))
                {
                    // this case handles allowed content types like image/*
                    string prefix = allowedContentType.Substring(0, allowedContentType.Length - 1);
                    if (contentType.StartsWith(prefix, StringComparison.Ordinal)) return true;
                }
            }
            return false;
        }

        #region helper methods that set status codes, create the correct links and call the application methods
        static readonly UriTemplate allEntriesTemplate = new UriTemplate(AllEntriesTemplate);
        static readonly UriTemplate entryTemplate = new UriTemplate(EntryTemplate);
        static readonly UriTemplate mediaItemTemplate = new UriTemplate(MediaItemTemplate);
        static readonly UriTemplate pagedEntriesTemplate = new UriTemplate(PagedEntriesTemplate);

        static Uri GetEntryUri(string collection, string id)
        {
            return entryTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection, id);
        }

        static Uri GetMediaItemUri(string collection, string id)
        {
            return mediaItemTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection, id);
        }

        protected static Uri GetAllEntriesUri(string collection)
        {
            return allEntriesTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection);
        }

        static void SetAtomServiceDocumentContentType()
        {
            // NOTE: the official content type of a service document is application/atomsvc+xml but text/xml is set in the template to render in the browsers
            WebOperationContext.Current.OutgoingResponse.ContentType = "text/xml";
        }

        static void SetAtomContentType()
        {
            WebOperationContext.Current.OutgoingResponse.ContentType = ContentTypes.Atom;
        }

        static void SetAtomEntryContentType()
        {
            WebOperationContext.Current.OutgoingResponse.ContentType = ContentTypes.AtomEntry;
        }

        static string GetDescriptionFromSlugHeader()
        {
            return WebOperationContext.Current.IncomingRequest.Headers["Slug"];
        }

        static SyndicationLink CreateEditLink(string collection, string id)
        {
            return new SyndicationLink(GetEntryUri(collection, id), "edit", "Edit Atom entry", ContentTypes.AtomEntry, 0);
        }

        static SyndicationLink CreateEditMediaLink(string collection, string id, string contentType)
        {
            return new SyndicationLink(GetMediaItemUri(collection, id), "edit-media", "Edit media item", contentType, 0);
        }

        static SyndicationLink GetPreviousPageLink(string collection, int pageNumber)
        {
            Uri feedUri;
            if (pageNumber == 0)
            {
                feedUri = allEntriesTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection);
            }
            else
            {
                feedUri = pagedEntriesTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection, pageNumber.ToString(CultureInfo.InvariantCulture));
            }
            return new SyndicationLink(feedUri, "previous", "Previous entries", ContentTypes.Atom, 0);
        }

        static SyndicationLink GetNextPageLink(string collection, int pageNumber)
        {
            Uri feedUri = pagedEntriesTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection, pageNumber.ToString(CultureInfo.InvariantCulture));
            return new SyndicationLink(feedUri, "next", "Next entries", ContentTypes.Atom, 0);
        }

        static SyndicationLink GetSelfLink(string collection, int pageNumber)
        {
            Uri feedUri;
            if (pageNumber == 0)
            {
                feedUri = allEntriesTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection);
            }
            else
            {
                feedUri = pagedEntriesTemplate.BindByPosition(WebOperationContext.Current.IncomingRequest.UriTemplateMatch.BaseUri, collection, pageNumber.ToString(CultureInfo.InvariantCulture));
            }
            return SyndicationLink.CreateSelfLink(feedUri, ContentTypes.Atom);
        }

        protected static void ConfigureMediaEntry(string collection, SyndicationItem entry, string id, string contentType, out Uri location)
        {
            location = GetEntryUri(collection, id);
            Uri mediaUri = GetMediaItemUri(collection, id);
            entry.Content = new UrlSyndicationContent(mediaUri, contentType);
            entry.Links.Add(CreateEditMediaLink(collection, id, contentType));
            entry.Links.Add(CreateEditLink(collection, id));
            entry.Links.Add(SyndicationLink.CreateMediaEnclosureLink(mediaUri, contentType, 0));
        }

        protected static void ConfigureAtomEntry(string collection, SyndicationItem entry, string id, out Uri location)
        {
            location = GetEntryUri(collection, id);
            entry.Links.Add(CreateEditLink(collection, id));
        }

        #endregion

        // The service interface allows GET, POST, PUT and DELETE HTTP methods using the Atom Publishing Protocol. 
        #region interfaces for exposing the resource over Atom Publishing Protocol.

        public AtomPub10ServiceDocumentFormatter GetDocument()
        {
            ServiceDocument serviceDocument = GetServiceDocument();
            SetAtomServiceDocumentContentType();
            return (AtomPub10ServiceDocumentFormatter)serviceDocument.GetFormatter();
        }

        public Atom10FeedFormatter GetFeed(string collection)
        {
            if (!IsValidCollection(collection))
            {
                WebOperationContext.Current.OutgoingResponse.SetStatusAsNotFound();
                return null;
            }

            UriTemplateMatch match = WebOperationContext.Current.IncomingRequest.UriTemplateMatch;
            int pageNumber = 0;

            // check if the query string has a pageNumber
            string pageQueryParam = match.QueryParameters["page"];
            if (!string.IsNullOrEmpty(pageQueryParam))
            {
                if (!int.TryParse(pageQueryParam, out pageNumber))
                {
                    throw new WebProtocolException(HttpStatusCode.BadRequest);
                }
            }
            int startIndex = pageNumber * this.GetMaximumEntriesInFeed(collection);
            bool hasMoreEntries;
            IEnumerable<SyndicationItem> entries = GetEntries(collection, startIndex, this.GetMaximumEntriesInFeed(collection), out hasMoreEntries);
            if (entries == null) entries = new List<SyndicationItem>();
            SyndicationFeed feed = CreateFeed(collection);
            feed.Items = entries;
            feed.Links.Add(GetSelfLink(collection, pageNumber));
            // add links to the previous page and next page if paging is enabled.
            if (pageNumber > 0)
            {
                feed.Links.Add(GetPreviousPageLink(collection, pageNumber - 1));
            }
            if (hasMoreEntries)
            {
                feed.Links.Add(GetNextPageLink(collection, pageNumber + 1));
            }
            SetAtomContentType();
            return feed.GetAtom10Formatter();
        }

        public Atom10ItemFormatter AddEntry(string collection, Stream stream)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            string description = GetDescriptionFromSlugHeader();
            string contentType = WebOperationContext.Current.IncomingRequest.ContentType;
            if (!IsContentTypeAllowed(collection, contentType))
            {
                throw new WebProtocolException(HttpStatusCode.UnsupportedMediaType);
            }
            SyndicationItem newEntry;
            Uri location;
            if (contentType.StartsWith("application/atom+xml", StringComparison.Ordinal))
            {
                // an Atom entry is being posted
                using (XmlReader reader = XmlReader.Create(stream, new XmlReaderSettings() { IgnoreWhitespace = true, IgnoreComments = true }))
                {
                    SyndicationItem entry = SyndicationItem.Load(reader);
                    newEntry = this.AddEntry(collection, entry, out location);
                }
            }
            else
            {
                newEntry = this.AddMedia(collection, stream, contentType, description, out location);
            }
            if (newEntry == null)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError);
            }
            WebOperationContext.Current.OutgoingResponse.SetStatusAsCreated(location);
            SetAtomEntryContentType();
            return newEntry.GetAtom10Formatter();
        }

        public Atom10ItemFormatter GetAtomEntry(string collection, string id)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            SyndicationItem entry = GetEntry(collection, id);
            if (entry == null)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            SetAtomEntryContentType();
            return entry.GetAtom10Formatter();
        }

        public Atom10ItemFormatter PutEntry(string collection, string id, Stream body)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            SyndicationItem newEntry;
            using (XmlReader reader = XmlReader.Create(body, new XmlReaderSettings() { IgnoreWhitespace = true, IgnoreComments = true }))
            {
                newEntry = SyndicationItem.Load(reader);
            }
            SyndicationItem updatedEntry = PutEntry(collection, id, newEntry);
            if (updatedEntry == null)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);    
            }
            SetAtomEntryContentType();
            return updatedEntry.GetAtom10Formatter();
        }

        public void DeleteAtomEntry(string collection, string id)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            bool wasDeleted = DeleteEntry(collection, id);
            if (!wasDeleted)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
        }

        public Stream GetMediaItem(string collection, string id)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            string contentType;
            Stream stream = GetMedia(collection, id, out contentType);
            if (stream == null)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            WebOperationContext.Current.OutgoingResponse.ContentType = contentType;
            return stream;
        }

        public void PutMediaItem(string collection, string id, Stream s)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            bool updatedItem = PutMedia(collection, id, s, WebOperationContext.Current.IncomingRequest.ContentType, GetDescriptionFromSlugHeader());
            if (!updatedItem)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
        }

        public void DeleteMediaItem(string collection, string id)
        {
            if (!IsValidCollection(collection))
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            bool deletedItem = DeleteMedia(collection, id);
            if (!deletedItem)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
        }
        #endregion
    }

    #endregion

    #region HTTP REST interface for AtomPub service
    [ServiceContract]
    public interface IAtomPubService
    {
        [WebGet(UriTemplate = AtomPubServiceBase.DocumentTemplate)]
        [OperationContract]
        AtomPub10ServiceDocumentFormatter GetDocument();

        [WebGet(UriTemplate = AtomPubServiceBase.AllEntriesTemplate)]
        [OperationContract]
        Atom10FeedFormatter GetFeed(string collection);

        [WebInvoke(UriTemplate = AtomPubServiceBase.AllEntriesTemplate)]
        [OperationContract]
        Atom10ItemFormatter AddEntry(string collection, Stream stream);

        [WebGet(UriTemplate = AtomPubServiceBase.EntryTemplate)]
        [OperationContract]
        Atom10ItemFormatter GetAtomEntry(string collection, string id);

        [WebInvoke(Method = "PUT", UriTemplate = AtomPubServiceBase.EntryTemplate)]
        [OperationContract]
        Atom10ItemFormatter PutEntry(string collection, string id, Stream body);

        [WebInvoke(Method = "DELETE", UriTemplate = AtomPubServiceBase.EntryTemplate)]
        [OperationContract]
        void DeleteAtomEntry(string collection, string id);

        [WebGet(UriTemplate = AtomPubServiceBase.MediaItemTemplate)]
        [OperationContract]
        Stream GetMediaItem(string collection, string id);

        [WebInvoke(Method = "PUT", UriTemplate = AtomPubServiceBase.MediaItemTemplate)]
        [OperationContract]
        void PutMediaItem(string collection, string id, Stream s);

        [WebInvoke(Method = "DELETE", UriTemplate = AtomPubServiceBase.MediaItemTemplate)]
        [OperationContract]
        void DeleteMediaItem(string collection, string id);
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\SpecializedServices\CollectionServiceBase.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.Linq;
using System.Net;


namespace Microsoft.ServiceModel.Web.SpecializedServices
{
    #region Base class for collection service - implements REST interface and contains helper methods
    public abstract class CollectionServiceBase<TItem> where TItem : class
    {
        // URI template definitions for how clients can access the items using XML or JSON. Modify if needed
        // The URI template to get all the items in XML format or add an item in XML format. The URL is of the form http://<url-for-svc-file>/
        public const string XmlItemsTemplate = "";
        // The URI template to manipulate a particular item in XML format. The URL is of the form http://<url-for-svc-file>/item1
        public const string XmlItemTemplate = "{id}";
        // The URI template to get all the items in JSON format or add an item in JSON format. The URL is of the form http://<url-for-svc-file>/?format=json
        public const string JsonItemsTemplate = "?format=json";
        // The URI template to manipulate a particular item in JSON format. The URL is of the form http://<url-for-svc-file>/item1?format=json
        public const string JsonItemTemplate = "{id}?format=json";

        // Return an enumeration of the (id, item) pairs. Return null if no items are present
        protected abstract IEnumerable<KeyValuePair<string, TItem>> OnGetItems();

        // Get the item with the specified id. 
        // A null return value will result in a NotFound
        protected abstract TItem OnGetItem(string id);

        // Add the item to the enumeration and return its id. Return null if adding the item failed
        // A null return value will result in a response status code of InternalServerError (500), unless the method explicitly sets the status code to a different error
        protected abstract TItem OnAddItem(TItem initialValue, out string id);

        // Update the item with the id specified. 
        // a null return value will result in a response status code of NotFound (404) if the item does not exist; 
        protected abstract TItem OnUpdateItem(string id, TItem newValue);

        // Delete the item with the specified id, if it exists. Return false if the item does not exist.
        // A return value of false will result in a response status code of NotFound (404) unless the method explicitly sets the status code to a different error.
        protected abstract bool OnDeleteItem(string id);

        #region helper methods that set status codes, create the correct links and call the application methods
        static readonly UriTemplate xmlItems = new UriTemplate(XmlItemsTemplate);
        static readonly UriTemplate xmlItem = new UriTemplate(XmlItemTemplate);
        static readonly UriTemplate jsonItems = new UriTemplate(JsonItemsTemplate);
        static readonly UriTemplate jsonItem = new UriTemplate(JsonItemTemplate);

        static Uri GetItemLink(string id, UriTemplate template)
        {
            return template.BindByPosition(WebOperationContext.Current.IncomingRequest.GetBaseUri(), id);
        }

        ItemInfoList<TItem> HandleGetItems(UriTemplate template)
        {
            IEnumerable<KeyValuePair<string, TItem>> items = OnGetItems();
            if (items == null) items = new List<KeyValuePair<string, TItem>>();
            return new ItemInfoList<TItem>(items.Select<KeyValuePair<string, TItem>, ItemInfo<TItem>>((pair) => new ItemInfo<TItem>()
            {
                Item = pair.Value,
                EditLink = GetItemLink(pair.Key, template)
            }));
        }

        TItem HandleGetItem(string id)
        {
            TItem item = OnGetItem(id);
            if (item == null)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            return item;
        }

        ItemInfo<TItem> HandleAddItem(TItem initialValue, UriTemplate template)
        {
            string id;
            TItem createdItem = OnAddItem(initialValue, out id);
            if (createdItem == null)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError);
            }
            WebOperationContext.Current.OutgoingResponse.SetStatusAsCreated(GetItemLink(id, template));
            return new ItemInfo<TItem>() { Item = createdItem, EditLink = GetItemLink(id, template) };
        }

        TItem HandleUpdateItem(string id, TItem newValue)
        {
            TItem updatedItem = OnUpdateItem(id, newValue);
            if (updatedItem == null)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            return updatedItem;
        }

        void HandleDeleteItem(string id)
        {
            bool wasDeleted = OnDeleteItem(id);
            if (!wasDeleted)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
        }
        #endregion

        // The service interface allows GET, POST, PUT and DELETE HTTP methods on the the collection resource in both XML and JSON formats. 
        // Modify the interface, if needed, to 
        //    1. Restrict support to just XML or just JSON
        //    2. Restrict the HTTP methods allowed on the resource
        #region JSON and XML interfaces for exposing the resource over HTTP.

        #region HTTP methods using XML format
        public ItemInfoList<TItem> GetItemsInXml()
        {
            return HandleGetItems(xmlItem);
        }

        public TItem GetItemInXml(string id)
        {
            return HandleGetItem(id);
        }

        public ItemInfo<TItem> AddItemInXml(TItem initialValue)
        {
            return HandleAddItem(initialValue, xmlItem);
        }

        public TItem UpdateItemInXml(string id, TItem newValue)
        {
            return HandleUpdateItem(id, newValue);
        }

        #endregion

        #region HTTP methods using JSON format

        public ItemInfoList<TItem> GetItemsInJson()
        {
            return HandleGetItems(jsonItem);
        }

        public TItem GetItemInJson(string id)
        {
            return HandleGetItem(id);
        }

        public ItemInfo<TItem> AddItemInJson(TItem initialValue)
        {
            return HandleAddItem(initialValue, jsonItem);
        }

        public TItem UpdateItemInJson(string id, TItem newValue)
        {
            return HandleUpdateItem(id, newValue);
        }

        #endregion

        public void DeleteItem(string id)
        {
            HandleDeleteItem(id);
        }

        #endregion
    }
    #endregion

    #region Types used in the Collection REST interface for encapsulating the item and its link
    [DataContract(Name = "ItemInfo", Namespace="")]
    public class ItemInfo<TItem> where TItem : class
    {
        [DataMember]
        public TItem Item { get; set; }
        [DataMember]
        public Uri EditLink { get; set; }
    }

    [CollectionDataContract(Name = "ItemInfoList", Namespace="")]
    public class ItemInfoList<TItem> : List<ItemInfo<TItem>> where TItem : class
    {
        public ItemInfoList()
            : base()
        {
        }

        public ItemInfoList(IEnumerable<ItemInfo<TItem>> items)
            : base(items)
        {
        }
    }
    #endregion 

    #region HTTP REST interface for the collection service
    [ServiceContract]
    public interface ICollectionService<TItem> where TItem : class
    {
        #region XML format APIs
        [WebHelp(Comment = "Returns the items in the collection in XML format, along with URI links to each item.")]
        [WebGet(UriTemplate = CollectionServiceBase<TItem>.XmlItemsTemplate)]
        [OperationContract]
        ItemInfoList<TItem> GetItemsInXml();

        [WebHelp(Comment = "Returns the item with the specified id in XML format.")]
        [WebGet(UriTemplate = CollectionServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        TItem GetItemInXml(string id);

        [WebHelp(Comment = "Adds the incoming item, in XML format, to the collection and returns the item along with a link to edit it.")]
        [WebInvoke(Method = "POST", UriTemplate = CollectionServiceBase<TItem>.XmlItemsTemplate)]
        [OperationContract]
        ItemInfo<TItem> AddItemInXml(TItem initialValue);

        [WebHelp(Comment = "Edits the item specified by its id, based on the incoming XML and returns the updated item in XML format.")]
        [WebInvoke(Method = "PUT", UriTemplate = CollectionServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        TItem UpdateItemInXml(string id, TItem newValue);
        #endregion

        #region JSON format APIs
        [WebHelp(Comment = "Returns the items in the collection in JSON format, along with URI links to each item.")]
        [WebGet(UriTemplate = CollectionServiceBase<TItem>.JsonItemsTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        ItemInfoList<TItem> GetItemsInJson();

        [WebHelp(Comment = "Returns the item with the specified id in JSON format.")]
        [WebGet(UriTemplate = CollectionServiceBase<TItem>.JsonItemTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        TItem GetItemInJson(string id);

        [WebHelp(Comment = "Adds the incoming item, in JSON format, to the collection and returns the item along with a link to edit it.")]
        [WebInvoke(Method = "POST", UriTemplate = CollectionServiceBase<TItem>.JsonItemsTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        ItemInfo<TItem> AddItemInJson(TItem initialValue);

        [WebHelp(Comment = "Edits the item specified by its id, based on the incoming JSON and returns the updated item in JSON format.")]
        [WebInvoke(Method = "PUT", UriTemplate = CollectionServiceBase<TItem>.JsonItemTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        TItem UpdateItemInJson(string id, TItem newValue);
        #endregion

        [WebHelp(Comment="Deletes the item with the specified id.")]
        [WebInvoke(Method = "DELETE", UriTemplate = CollectionServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        void DeleteItem(string id);
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\SpecializedServices\SingletonServiceHost.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.ServiceModel.Syndication;
using Microsoft.ServiceModel.Web;
using System.Linq;
using System.Net;
using System.Xml.Linq;
using System.Xml;
using System.IO;
using System.Globalization;
using System.ComponentModel;
using System.Reflection;
using System.ServiceModel.Description;

namespace Microsoft.ServiceModel.Web.SpecializedServices
{
    public class SingletonServiceHost : WebServiceHost2
    {
        public SingletonServiceHost(object singletonInstance, params Uri[] baseAddresses)
            : base(singletonInstance, baseAddresses)
        {
        }

        public SingletonServiceHost(Type serviceType, params Uri[] baseAddresses)
            : base(serviceType, false, baseAddresses)
        {
        }

        protected override void OnOpening()
        {
            base.OnOpening();
            // Add any WebCache and WebHelp attributes specified on the derived class to the service description
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebCacheAttribute), typeof(WebHelpAttribute) }, "OnGetItem", new string[] { "GetItemInXml", "GetItemInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebHelpAttribute) }, "OnAddItem", new string[] { "AddItemInXml", "AddItemInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebHelpAttribute) }, "OnUpdateItem", new string[] { "UpdateItemInXml", "UpdateItemInJson" });
            AtomPubServiceHost.CopyAttributeBehaviors(this.Description, new Type[] { typeof(WebHelpAttribute) }, "OnDeleteItem", new string[] { "DeleteItem" });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\Common\WCF_REST_StarterKit\Microsoft.ServiceModel.Web\SpecializedServices\SingletonServiceBase.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.Linq;
using System.Net;
using Microsoft.ServiceModel.Web;


namespace Microsoft.ServiceModel.Web.SpecializedServices
{
    #region Singleton service base class - implements the REST interface and has helper functions
    public abstract class SingletonServiceBase<TItem> where TItem : class
    {
        // URI template definitions for how clients can access the resource using XML or JSON.
        // The URI template to manipulate the resource in its XML format. The URL is of the form http://<url-for-svc-file>/
        public const string XmlItemTemplate = "";
        // The URI template to manipulate the resource in its JSON format. The URL is of the form http://<url-for-svc-file>/?json
        public const string JsonItemTemplate = "?format=json";

        // Get the item
        // A null return value will result in a NotFound
        protected abstract TItem OnGetItem();

        // Add the item. Return null if adding the item failed
        // A null return value will result in a response status code of InternalServerError (500)
        protected abstract TItem OnAddItem(TItem initialValue, out bool wasItemCreated);

        // Update the item. 
        // a null return value will result in a response status code of NotFound (404) if the item does not exist; 
        protected abstract TItem OnUpdateItem(TItem newValue, out bool wasItemCreated);

        // Delete the item, if it exists. Return false if the item does not exist.
        // A return value of false will result in a response status code of NotFound (404) unless the method explicitly sets the status code to a different error.
        protected abstract bool OnDeleteItem();

        #region helper methods that call the application methods and set the status codes accordingly
        
        static readonly UriTemplate xmlTemplate = new UriTemplate(XmlItemTemplate);
        static readonly UriTemplate jsonTemplate = new UriTemplate(JsonItemTemplate);

        TItem HandleGet(UriTemplate template)
        {
            TItem result = OnGetItem();
            if (result == null)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
            return result;
        }

        TItem HandleAdd(TItem initialValue, UriTemplate template)
        {
            bool wasResourceCreated;
            TItem result = OnAddItem(initialValue, out wasResourceCreated);
            if (result == null)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError);
            }
            if (wasResourceCreated)
            {
                Uri location = WebOperationContext.Current.BindTemplateToRequestUri(template);
                WebOperationContext.Current.OutgoingResponse.SetStatusAsCreated(location);
            }
            return result;
        }

        TItem HandleUpdate(TItem newValue, UriTemplate template)
        {
            bool wasResourceCreated;
            TItem result = OnUpdateItem(newValue, out wasResourceCreated);
            if (result == null)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError);
            }
            if (wasResourceCreated)
            {
                Uri location = WebOperationContext.Current.BindTemplateToRequestUri(template);
                WebOperationContext.Current.OutgoingResponse.SetStatusAsCreated(location);
            }
            return result;
        }

        void HandleDelete()
        {
            if (!OnDeleteItem())
            {
                throw new WebProtocolException(HttpStatusCode.NotFound);
            }
        }

        #endregion

        // The service interface allows GET, POST, PUT and DELETE HTTP methods on the resource in both XML and JSON formats. 
        // Modify the interface, if needed, to 
        //    1. Restrict support to just XML or just JSON
        //    2. Restrict the HTTP methods allowed on the resource
        #region JSON and XML interfaces for exposing the resource over HTTP.

        #region HTTP methods using XML format
        public TItem GetItemInXml()
        {
            return HandleGet(xmlTemplate);
        }

        public TItem AddItemInXml(TItem initialValue)
        {
            return HandleAdd(initialValue, xmlTemplate);
        }

        public TItem UpdateItemInXml(TItem newValue)
        {
            return HandleUpdate(newValue, xmlTemplate);
        }
        #endregion

        #region HTTP methods using JSON format

        public TItem GetItemInJson()
        {
            return HandleGet(jsonTemplate);
        }

        public TItem AddItemInJson(TItem initialValue)
        {
            return HandleAdd(initialValue, jsonTemplate);
        }

        public TItem UpdateItemInJson(TItem newValue)
        {
            return HandleUpdate(newValue, jsonTemplate);
        }
        #endregion

        public void DeleteItem()
        {
            HandleDelete();
        }

        #endregion
    }
    #endregion

    #region HTTP REST Interface for singleton service
    [ServiceContract]
    public interface ISingletonService<TItem> where TItem : class
    {
        #region XML format APIs
        [WebHelp(Comment = "Returns the item in XML format.")]
        [WebGet(UriTemplate = SingletonServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        TItem GetItemInXml();

        [WebHelp(Comment = "Initializes the item based on the incoming XML.")]
        [WebInvoke(Method = "POST", UriTemplate = SingletonServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        TItem AddItemInXml(TItem initialValue);

        [WebHelp(Comment = "Edits the item based on the incoming XML and returns the updated item in XML format.")]
        [WebInvoke(Method = "PUT", UriTemplate = SingletonServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        TItem UpdateItemInXml(TItem newValue);
        #endregion

        #region JSON format APIs
        [WebHelp(Comment = "Returns the item in JSON format.")]
        [WebGet(UriTemplate = SingletonServiceBase<TItem>.JsonItemTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        TItem GetItemInJson();

        [WebHelp(Comment = "Initializes the item based on the incoming JSON.")]
        [WebInvoke(Method = "POST", UriTemplate = SingletonServiceBase<TItem>.JsonItemTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        TItem AddItemInJson(TItem initialValue);

        [WebHelp(Comment = "Edits the item based on the incoming JSON and returns the updated item in JSON format.")]
        [WebInvoke(Method = "PUT", UriTemplate = SingletonServiceBase<TItem>.JsonItemTemplate, ResponseFormat = WebMessageFormat.Json)]
        [OperationContract]
        TItem UpdateItemInJson(TItem newValue);
        #endregion

        [WebHelp(Comment="Deletes the item.")]
        [WebInvoke(Method = "DELETE", UriTemplate = SingletonServiceBase<TItem>.XmlItemTemplate)]
        [OperationContract]
        void DeleteItem();
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\BadgeAlbum\App.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;

    public partial class App : Application
    {
        public static bool IsLoaded;

        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            string badgeAlbumLocation = null;
            if (e.InitParams.ContainsKey("BadgeAlbumLocation"))
            {
                badgeAlbumLocation = e.InitParams["BadgeAlbumLocation"];
            }

            this.RootVisual = new Page(badgeAlbumLocation ?? "BadgeAlbum.xml");
        }

        private void Application_Exit(object sender, EventArgs e)
        {
        }

        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;

                try
                {
                    string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                    errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                    System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight 2 Application " + errorMsg + "\");");
                }
                catch (Exception)
                {
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\BadgeAlbum\BadgeEffect.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Effects;

    public class BadgeEffect : ShaderEffect
    {
        #region Constructors
        public BadgeEffect(string effectName)
        {
            string effectPS = String.Format("/BadgeAlbum;component/{0}.ps", effectName);
            _pixelShader.UriSource = new Uri(effectPS, UriKind.Relative);

            this.PixelShader = _pixelShader;

            // Update each DependencyProperty that's registered with a shader register.  This
            // is needed to ensure the shader gets sent the proper default value.
            UpdateShaderValue(InputProperty);
            UpdateShaderValue(ColorFilterProperty);
        }
        #endregion

        #region Dependency Properties
        public Brush Input
        {
            get { return (Brush)GetValue(InputProperty); }
            set { SetValue(InputProperty, value); }
        }

        // Brush-valued properties turn into sampler-property in the shader.
        // This helper sets "ImplicitInput" as the default, meaning the default
        // sampler is whatever the rendering of the element it's being applied to is.
        public static readonly DependencyProperty InputProperty =
            BadgeEffect.RegisterPixelShaderSamplerProperty("Input", typeof(BadgeEffect), 0);

        public Color ColorFilter
        {
            get { return (Color)GetValue(ColorFilterProperty); }
            set { SetValue(ColorFilterProperty, value); }
        }

        // Scalar-valued properties turn into shader constants with the register
        // number sent into PixelShaderConstantCallback().
        public static readonly DependencyProperty ColorFilterProperty =
            DependencyProperty.Register("ColorFilter", typeof(Color), typeof(BadgeEffect),
                    new PropertyMetadata(Colors.Yellow, PixelShaderConstantCallback(0)));
        #endregion

        #region Member Data
        private static PixelShader _pixelShader = new PixelShader();
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\BadgeAlbum\ImageControl.xaml.cs ===
﻿namespace NGGamePlayer.BadgeAlbum
{
    using System;
    using System.Windows.Browser;
    using System.Windows.Controls;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Animation;
    using System.Windows.Media.Imaging;

    public partial class ImageControl : UserControl
    {
        private enum MyStates { Normal, Started1, Started2, Reverse1, Reverse2 };

        private int _angle;
        private ImageSource badgeImage;
        private MyStates _myState = MyStates.Normal;

        public string TargetURL { get; set; }

        public ImageControl(int duration, string badgeImage, string badgeText, string badgeAwardDate, int index)
        {
            // Required to initialize variables
            InitializeComponent();

            this.badgeImage = new BitmapImage(new Uri(badgeImage, UriKind.RelativeOrAbsolute));
            _myState = MyStates.Normal;

            // Limit the size of the badge to 90x90
            this.image.MaxHeight = 90;
            this.image.MaxWidth = 90;

            // Set up the control but hide it from view
            this.image.Opacity = 0;
            this.image.Source = this.badgeImage;

            // Setting unique names to UI pieces for later automation
            this.image.Name = "badgeAlbumImage" + index;
            this.txtBadgeDescription.Name = "badgeAlbumDescription" + index;
            this.Name = "badgeAlbumBadge" + index;


            // Based on the badge award date, we will toggle animation and the shader effect
            if (badgeAwardDate == String.Empty)
            {
                this.image.Effect = new BadgeEffect("MonochromeEffect");
                this.txtBadgeDescription.Text = badgeText;
            }
            else
            {
                // Storyboard animation and event handlers
                txtBadgeDescription.MouseLeftButtonDown += new MouseButtonEventHandler(txtBadgeDescription_MouseLeftButtonDown);
                MyKeyFrame.KeyTime = KeyTime.FromTimeSpan(new TimeSpan(0, 0, 0, 0, duration));

                this.txtBadgeDescription.Text = String.Format("WELL DONE!\n{0}", badgeAwardDate);
                this.txtBadgeDescription.Foreground = new SolidColorBrush(Colors.Orange);
            }
        }

        void txtBadgeDescription_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            HtmlPage.Window.Navigate(new Uri(TargetURL, UriKind.RelativeOrAbsolute));
        }

        public int Angle
        {
            get { return _angle; }
            set
            {
                _angle = value;
                MyAngle.Angle = value;
            }
        }

        private void Reverse2()
        {
            _myState = MyStates.Reverse2;
            this.image.Source = this.badgeImage;
            MyKeyFrame.Value = 1;
            Storyboard1.Begin();
        }

        private void Reverse1()
        {
            _myState = MyStates.Reverse1;
            MyKeyFrame.Value = 0;
            Storyboard1.Begin();
        }

        private void Start1()
        {
            _myState = MyStates.Started1;
            MyKeyFrame.Value = 0;
            Storyboard1.Begin();
        }

        private void Start2()
        {
            _myState = MyStates.Started2;
            this.image.Source = null;
            MyKeyFrame.Value = 1;
            Storyboard1.Begin();
        }

        private void LayoutRoot_MouseEnter(object sender, MouseEventArgs e)
        {
            Canvas.SetZIndex(this, Canvas.GetZIndex(this) + 4);
            if (!App.IsLoaded)
            {
                _myState = MyStates.Started2;
                this.image.Source = null;
            }
            else
            {
                switch (_myState)
                {
                    case MyStates.Normal:
                    case MyStates.Reverse2:
                        Start1();
                        break;
                    default:
                        Start2();
                        break;
                }
            }
        }

        private void LayoutRoot_MouseLeave(object sender, MouseEventArgs e)
        {
            Canvas.SetZIndex(this, Canvas.GetZIndex(this) - 4);
            switch (_myState)
            {
                case MyStates.Started2:
                    Reverse1();
                    break;
                case MyStates.Started1:
                    Reverse2();
                    break;
            }
        }

        public void Start()
        {
            this.image.Opacity = 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\BadgeAlbum\Page.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Input;
    using System.Windows.Threading;
    using System.Xml.Linq;
    using NGGamePlayer.BadgeAlbum;

    public partial class Page : UserControl
    {
        /// <summary>
        /// The test-specific URL at which we can extract the BadgeAlbum.xml file
        /// </summary>
        private string _badgeAlbumLocation;

        /// <summary>
        /// Root visual
        /// </summary>
        /// <param name="badgeAlbumLocation">XML input describing the menu</param>
        public Page(string badgeAlbumLocation)
        {
            InitializeComponent();
            _badgeAlbumLocation = badgeAlbumLocation;

            this.Loaded += new RoutedEventHandler(Page_Loaded);
            this.MouseEnter += new MouseEventHandler(Page_MouseEnter);
        }

        void Page_MouseEnter(object sender, MouseEventArgs e)
        {
            Debug.WriteLine("Page_MouseEnter");
            App.IsLoaded = true;
        }

        void Page_Loaded(object sender, RoutedEventArgs e)
        {
            WebClient wc = new WebClient();
            wc.DownloadStringCompleted += wc_DownloadStringCompleted;
            wc.DownloadStringAsync(new Uri(_badgeAlbumLocation, UriKind.RelativeOrAbsolute));
        }

        void wc_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
        {
            if (e.Error == null)
            {
                XElement root = XElement.Parse(e.Result);

                // MenuItems
                var q = from mi in root.Elements("BadgeItem")
                        select new
                           {
                               left = double.Parse(mi.Attribute("Left").Value),
                               top = double.Parse(mi.Attribute("Top").Value),
                               angle = int.Parse(mi.Attribute("Angle").Value),
                               badgeImage = mi.Attribute("badgeImage").Value,
                               badgeDescription = mi.Attribute("badgeDescription").Value,
                               badgeAwardDate = mi.Attribute("badgeAwardDate").Value,
                               targetURL = mi.Attribute("targetURL").Value
                           };

                int duration = int.Parse(root.Attribute("Duration").Value) / 2;
                int index = 0;

                foreach (var item in q)
                {
                    // Create a new user control to display this badge
                    var img = new ImageControl(duration, item.badgeImage, item.badgeDescription, item.badgeAwardDate, index);
                    index++;
                    img.TargetURL = item.targetURL;
                    img.Angle = item.angle;

                    MyCanvas.Children.Add(img);
                    Canvas.SetLeft(img, item.left);
                    Canvas.SetTop(img, item.top);
                }

                DispatcherTimer t = new DispatcherTimer();
                t.Interval = new TimeSpan(0, 0, 0, 0, 100);
                t.Tick += new EventHandler(t_Tick);
                t.Start();
            }
            else
            {
                MessageBox.Show(e.Error.InnerException.Message);
            }
        }

        void t_Tick(object sender, EventArgs e)
        {
            Debug.WriteLine("Page_Tick");
            var t = sender as DispatcherTimer;
            t.Stop();

            foreach (ImageControl img in MyCanvas.Children)
            {
                img.Start();
            }

            App.IsLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\FriendPickerParameters.cs ===
﻿namespace NGGamePlayer
{
    internal class FriendPickerParameters
    {
        public uint TitleId { get; set; }

        public uint TitleVersion { get; set; }

        public string SessionId { get; set; }

        public int NumSeatsAvailable { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\BadgeAlbum\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("MyGameInfo")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("03ae3a66-831a-4f59-ba78-1877c654d3be")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\App.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Documents;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Animation;
    using System.Windows.Shapes;

    public partial class App : Application
    {
        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            this.RootVisual = new FriendPicker();
        }

        private void Application_Exit(object sender, EventArgs e)
        {
        }

        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;
                Deployment.Current.Dispatcher.BeginInvoke(delegate { this.ReportErrorToDOM(e); });
            }
        }

        private void ReportErrorToDOM(ApplicationUnhandledExceptionEventArgs e)
        {
            try
            {
                string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight Application " + errorMsg + "\");");
            }
            catch (Exception)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\FriendPicker.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Windows;
    using System.Windows.Browser;
    using System.Windows.Controls;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Xml;
    using System.Xml.Linq;

    using AsyncMultiplayer.NotificationService;
    using Leet.Silverlight.RESTProxy.NotificationProxy;
    using Leet.Silverlight.RESTProxy.ProfileProxy;
    using Leet.Silverlight.RESTProxy.WebAuthProxy;
    using Leet.UserGameData.DataContracts;
    using NGGamePlayer.Comparers;
    using NGGamePlayer.Resources;
    using SLUtilities;

    public partial class FriendPicker : UserControl
    {
        private const uint ProfileSectionFlags =
            (uint)(ProfileSections.XboxLiveProperties | ProfileSections.Friends);

        // This is part of the notification DCR to support sending invitations to gamertags
        // Currently, notifications sent to a gamertag do not necessary send an email but do
        // create a notification for the recipient.
        private const string GamertagPrefix = "gamertag:";

        // Image to use for email friends
        private const string DefaultEmailGamerPic = "Resources/defaultGamerPic.png";

        // TODO: Remove this and update references when strings move to a resx (soon!)
        private string defaultEmailString = GamePlayerAppResources.FriendPickerEmailInvitation;
        private string numberOfAvailableSeats = GamePlayerAppResources.FriendPickerNumAvailableSeats;

        private Uri profileServiceUri = new Uri(PageVariables.GetServiceURI("g_profileServiceUrl"));
        private Uri stsServiceUri = new Uri(PageVariables.GetServiceURI("g_stsServiceUrl"));
        private Uri notificationServiceUri = new Uri(PageVariables.GetServiceURI("g_notificationFrontEndUrl"));

        private IWebAuthProxy webAuthProxy = null;
        private IProfileProxy profileProxy = null;
        private INotificationProxy notificationProxy = null;

        /// <summary>
        /// The authorization, locale and platform type headers are populated by the WebAuthProxy
        /// </summary>
        private WebHeaderCollection colWebHeaders = null;

        private List<string> selectedEmailFriends = null;
        private List<Profile> selectedFriendProfiles = null;

        // This delegate is set whenever a "Retry" button is available in the Modal Dialog to specify what
        // function to call when that button is pressed.
        private RetryDelegate retryCallback = null;
        private bool closeButtonReturnResult = false;

        public FriendPicker()
            : this(
                null,
                null,
                null)
        {
        }

        // This constructor is intended to be called for test use only.
        internal FriendPicker(IProfileProxy pp, IWebAuthProxy wap, INotificationProxy np)
        {
            InitializeComponent();
            this.Loaded += this.Page_OnLoaded;

            if (wap == null)
            {
                this.webAuthProxy = new WebAuthProxy(this.stsServiceUri);
            }
            else
            {
                this.webAuthProxy = wap;
            }

            this.webAuthProxy.OnWebAuthRequestCompleted += this.OnWebAuthRequestCompleted;

            // Only set the ProfileProxy if one was passed in, otherwise we need the return value
            // from the WebAuthProxy to create a profile proxy instance.
            if (pp == null)
            {
                if (wap != null)
                {
                    throw new ArgumentException(
                        "The WebAuthProxy cannot be mocked when going against a real ProfileProxy.");
                }
            }
            else
            {
                this.profileProxy = pp;
            }

            if (np == null)
            {
                if (wap != null)
                {
                    throw new ArgumentException(
                        "The WebAuthProxy cannot be mocked when going against a real NotificationProxy.");
                }
            }
            else
            {
                this.notificationProxy = np;
            }

            this.selectedEmailFriends = new List<string>();
            this.selectedFriendProfiles = new List<Profile>();
        }

        private delegate void RetryDelegate();

        internal ModalDialog DialogBox { get; set; }

        // The input parameters are supplied by the game through a javascript page variable.
        // The Friend Picker assumes that the parameters are valid.
        internal FriendPickerParameters FriendPickerParameters { get; set; }

        internal bool InvitationLimitWarningShown { get; set; }

        internal XmlSerializableList<Profile> Friends { get; set; }

        internal void EmailInviteButton_OnClick(object sender, RoutedEventArgs e)
        {
            this.AddEmailFriend();
        }

        internal void CancelButton_OnClick(object sender, RoutedEventArgs e)
        {
            this.CloseFriendPicker();
        }

        internal void OnPostInviteCompleted(object sender, NotificationProxyEventArgs<string> e)
        {
            this.HideBusyDialog();

            if (e.Error == null)
            {
                this.closeButtonReturnResult = true;
                this.DialogBox.Show(
                    DialogButtons.Close,
                    GamePlayerAppResources.FriendPickerInvitationsSent);
            }
            else
            {
                this.retryCallback = this.SendInvitations;
                this.DialogBox.Show(
                    DialogButtons.Cancel | DialogButtons.Retry,
                    GamePlayerAppResources.FriendPickerSendInvitationsError);
            }
        }

        internal void OnGetProfileCompleted(object sender, ProfileProxyEventArgs<Leet.UserGameData.DataContracts.Profile> e)
        {
            // Hide the loading screen.
            this.HideBusyDialog();

            if (e.Error == null)
            {
                Profile userProfile = e.Result;
                this.Friends = userProfile.Friends;
                this.Friends.Sort(new ProfileGamerTagComparer());
                this.FriendsListBox.ItemsSource = this.Friends;

                // If the friend count is zero then show the overlay w/ appropriate text.
                if (this.Friends.Count == 0)
                {
                    this.EmptyFriendsBlock.Visibility = Visibility.Visible;
                }
            }
            else
            {
                this.retryCallback = this.GetUserProfile;
                this.DialogBox.Show(
                    DialogButtons.Close | DialogButtons.Retry,
                    GamePlayerAppResources.FriendPickerGenericError);
            }
        }

        internal void SendInvitesButton_OnClick(object sender, RoutedEventArgs e)
        {
            if (SelectedFriendsListBox.Items.Count > 0)
            {
                this.SendInvitations();
            }
            else
            {
                this.DialogBox.Show(
                    DialogButtons.OK,
                    GamePlayerAppResources.FriendPickerNoFriendsSelected);
            }
        }

        internal void ClearInviteListButton_OnClick(object sender, RoutedEventArgs e)
        {
            if (this.selectedFriendProfiles.Count > 0)
            {
                this.Friends.AddRange(this.selectedFriendProfiles);
                this.SortFriendsList();
                this.RefreshFriendsList();
                this.selectedFriendProfiles.Clear();
            }

            this.selectedEmailFriends.Clear();
            this.SelectedFriendsListBox.Items.Clear();
            this.UpdateSeatsLabel();
            this.EmptySelectedFriendsBlock.Visibility = Visibility.Visible;
        }

        private void DialogBox_OnHide(object sender, ModalDialogHideEventArgs eventArgs)
        {
            switch (eventArgs.ButtonPressed)
            {
                case DialogButtonPressed.Close:
                    this.CloseFriendPicker(this.closeButtonReturnResult);
                    break;

                case DialogButtonPressed.Retry:
                    if (this.retryCallback != null)
                    {
                        this.retryCallback();
                    }
                    else
                    {
                        throw new InvalidOperationException("Attempted to retry with no callback specified.");
                    }

                    break;

                case DialogButtonPressed.Cancel:
                case DialogButtonPressed.OK:
                case DialogButtonPressed.None:
                default:
                    // Do nothing: the dialog box has already been hidden.
                    break;
            }

            this.retryCallback = null;
        }

        private void Page_OnLoaded(object sender, RoutedEventArgs e)
        {
            this.DialogBox = new ModalDialog();
            this.DialogBox.OnHide += new ModalDialog.HideEventHandler(this.DialogBox_OnHide);

            if (this.PopulateFriendPickerParameters())
            {
                this.InvitationLimitWarningShown = false;
                this.closeButtonReturnResult = false;

                // Set the text for UI labels, doing this programmatically to a) suppress warnings about the XAML,
                // and b) make this more easily unit testable.
                this.FriendPickerTitle.Text = GamePlayerAppResources.FriendPickerTitle;
                this.EmailAddressInput.Text = this.defaultEmailString;
                this.SeatsLabel.Text = String.Format(
                    this.numberOfAvailableSeats,
                    this.FriendPickerParameters.NumSeatsAvailable,
                    this.FriendPickerParameters.NumSeatsAvailable);
                this.EmptyFriendLabel.Text = GamePlayerAppResources.FriendPickerNoFriends;
                this.ClearInviteListButton.Content = GamePlayerAppResources.FriendPickerClearAll;
                this.SelectedFriendLabel.Text = GamePlayerAppResources.FriendPickerSelectFriends;
                this.CancelButton.Content = GamePlayerAppResources.FriendPickerCancel;
                this.SendInvitesButton.Content = GamePlayerAppResources.FriendPickerSendInvites;

                // Set the modal dialog button text; doing this here so it's more easily localizable
                // The styles for the control need to be defined in App.xaml but that breaks test pages.
                // TODO: Investigate if there's a cleaner way for getting these strings set; ideally
                // it would happen in the xaml for the modal dialog, unfortunately that didn't seem
                // straightforward due to the note above.
                this.DialogBox.OKButton.Content = GamePlayerAppResources.FriendPickerModalOK;
                this.DialogBox.RetryButton.Content = GamePlayerAppResources.FriendPickerModalRetry;
                this.DialogBox.CloseButton.Content = GamePlayerAppResources.FriendPickerModalClose;
                this.DialogBox.CancelButton.Content = GamePlayerAppResources.FriendPickerModalCancel;

                // TODO: Add a Title ID verification helper method beyond a non-zero check.
                if (this.FriendPickerParameters.TitleId != 0)
                {
                    this.ShowBusyIndicator(GamePlayerAppResources.FriendPickerLoading);

                    this.webAuthProxy.GetUserTokenHTTP(
                        this.FriendPickerParameters.TitleId,
                        this.FriendPickerParameters.TitleVersion);
                }
                else
                {
                    this.DialogBox.Show(
                        DialogButtons.Close,
                        GamePlayerAppResources.FriendPickerGenericError);
                }
            }
            else
            {
                DebugTextLogger.Log("One or more of the input parameters in friendPickerArgs was invalid.");

                this.DialogBox.Show(
                    DialogButtons.Close,
                    GamePlayerAppResources.FriendPickerGenericError);
            }
        }

        private void ShowBusyIndicator(object busyContent)
        {
            this.BusyDialog.BusyContent = busyContent;
            this.BusyDialog.IsBusy = true;

            // Disable the address input; for some reason only this is clickable when the busy indicator is up.
            this.EmailAddressInput.IsEnabled = false;
        }

        private void HideBusyDialog()
        {
            this.BusyDialog.IsBusy = false;

            // Re-enable the address input.
            this.EmailAddressInput.IsEnabled = true;
        }

        private void OnWebAuthRequestCompleted(object sender, WebAuthProxyEventArgs e)
        {
            // WebAuthProxy should return a non-empty, non-null result to use as the authorization token
            if (e.Error == null)
            {
                this.colWebHeaders = e.Result;

                // If the ProfileProxy or NotificationProxy are null that means we're using the real service,
                // which requires a user token, so the they are instantiated here.
                if (this.profileProxy == null)
                {
                    this.profileProxy = new ProfileProxy(this.profileServiceUri, this.colWebHeaders, null);
                }

                if (this.notificationProxy == null)
                {
                    this.notificationProxy = new NotificationProxy(this.notificationServiceUri, this.colWebHeaders, null);
                }

                // Wire up the events for the proxies now that we know they've been instantiated.
                this.profileProxy.OnGetProfileCompleted +=
                    new EventHandler<ProfileProxyEventArgs<Profile>>(this.OnGetProfileCompleted);
                this.notificationProxy.OnPostInviteCompleted +=
                    new EventHandler<NotificationProxyEventArgs<string>>(this.OnPostInviteCompleted);

                this.GetUserProfile();
            }
            else
            {
                this.HideBusyDialog();
                this.DialogBox.Show(
                    DialogButtons.Close,
                    GamePlayerAppResources.FriendPickerGenericError);
            }
        }

        private void GetUserProfile()
        {
            this.profileProxy.GetProfileAsync(ProfileSectionFlags);
        }

        private void FriendsListBox_OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            int selectedIndex = FriendsListBox.SelectedIndex;
            if (selectedIndex >= 0)
            {
                Profile selectedFriend = (Profile)FriendsListBox.SelectedItem;
                this.selectedFriendProfiles.Add(selectedFriend);
                this.Friends.Remove(selectedFriend);

                this.SelectedFriendsListBox.Items.Add(FriendsListBox.Items[selectedIndex]);

                this.RefreshFriendsList();

                // There is now going to be at least one friend in the SelectedFriendsListBox so
                // hide the overlay.
                this.EmptySelectedFriendsBlock.Visibility = Visibility.Collapsed;
                this.UpdateSeatsLabel();

                // For some reason the email input box gets focus after selecting from this list.
                this.SendInvitesButton.Focus();
            }
        }

        private void SelectedFriendsListBox_OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            this.RemoveFriendFromSelectedList();
        }

        private void RemoveFriendFromSelectedList()
        {
            int selectedIndex = SelectedFriendsListBox.SelectedIndex;
            if (selectedIndex >= 0)
            {
                Profile selectedFriend = (Profile)SelectedFriendsListBox.SelectedItem;
                string selectedFriendGamertag = selectedFriend.ProfileProperties[ProfileProperty.GamerTag].ToString();

                // Check whether the friend is an email address before adding it to the Friends list.
                if (!CommonUtilities.IsValidEmailAddress(selectedFriendGamertag))
                {
                    this.Friends.Add(selectedFriend);
                    this.selectedFriendProfiles.Remove(selectedFriend);

                    // Sort the Friends list
                    this.SortFriendsList();
                    this.RefreshFriendsList();
                }
                else
                {
                    // Remove the email address from our internal list
                    this.selectedEmailFriends.Remove(selectedFriendGamertag.ToLower());
                }

                this.SelectedFriendsListBox.Items.Remove(selectedFriend);

                if (this.SelectedFriendsListBox.Items.Count == 0)
                {
                    this.EmptySelectedFriendsBlock.Visibility = Visibility.Visible;
                }

                this.UpdateSeatsLabel();
            }
        }

        private void SortFriendsList()
        {
            this.Friends.Sort(new ProfileGamerTagComparer());
        }

        private void EmailAddressInput_OnKeyUp(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                this.AddEmailFriend();
            }
        }

        private void EmailAddressInput_OnGotFocus(object sender, RoutedEventArgs e)
        {
            // Only clear out the text when the input box gets focus if it's the default string.
            if (String.Compare(this.EmailAddressInput.Text, this.defaultEmailString) == 0)
            {
                this.EmailAddressInput.Text = string.Empty;
            }
        }

        private void EmailAddressInput_OnLostFocus(object sender, RoutedEventArgs e)
        {
            // Set the default text back if the user leaves the input box and it's empty.
            if (String.IsNullOrEmpty(this.EmailAddressInput.Text))
            {
                this.EmailAddressInput.Text = this.defaultEmailString;
            }
        }

        private bool PopulateFriendPickerParameters()
        {
            // Get eventArgs from the page
            string paramXML = HtmlPage.Window.Eval("friendPickerArgs").ToString();

            // Track whether we have valid parameters.
            bool paramsLoaded = false;

            if (!string.IsNullOrEmpty(paramXML))
            {
                paramsLoaded = true;
            }

            XDocument inputParameters = null;

            try
            {
                inputParameters = XDocument.Parse(paramXML);
            }
            catch (XmlException)
            {
                DebugTextLogger.Log("Supplied friendPickerArgs was invalid or malformed XML.");

                this.DialogBox.Show(
                    DialogButtons.Close,
                    GamePlayerAppResources.FriendPickerGenericError);
            }

            if (inputParameters != null)
            {
                try
                {
                    var parameters = from XElem in inputParameters.Descendants("FriendPickerParams")
                                     select new FriendPickerParameters
                                     {
                                         TitleId = uint.Parse(XElem.Element("titleId").Value),
                                         TitleVersion = uint.Parse(XElem.Element("titleVersion").Value),
                                         SessionId = XElem.Element("sessionId").Value,
                                         NumSeatsAvailable = int.Parse(XElem.Element("numSeatsAvailable").Value),
                                     };

                    this.FriendPickerParameters = parameters.First<FriendPickerParameters>();
                }
                catch (InvalidOperationException)
                {
                    DebugTextLogger.Log("The XML contained no elements");
                    this.DialogBox.Show(
                        DialogButtons.Close,
                        GamePlayerAppResources.FriendPickerGenericError);
                }
                catch (FormatException)
                {
                    string logText = String.Format(
                        "One or more of the input parameters in friendPickerArgs was invalid.\r\nfriendPickerArgs:\r\n{0}",
                        paramXML);
                    DebugTextLogger.Log(logText);

                    this.DialogBox.Show(
                        DialogButtons.Close,
                        GamePlayerAppResources.FriendPickerGenericError);
                }
            }

            // If any of the parameters were invalid then the Linq to XML calls would except,
            // and this.FriendPickerParameters would never have been set.
            paramsLoaded = this.FriendPickerParameters != null;

            return paramsLoaded;
        }

        private void CloseFriendPicker()
        {
            this.CloseFriendPicker(false);
        }

        private void CloseFriendPicker(bool invitesSent)
        {
            string returnXml = String.Format(
                "<FriendPickerReturnValue><invitationsSent>{0}</invitationsSent></FriendPickerReturnValue>",
                invitesSent.ToString());
            PageVariables.SendEvent("FriendPickerReturn", returnXml);
        }

        private void RefreshFriendsList()
        {
            this.FriendsListBox.ItemsSource = null;
            this.FriendsListBox.ItemsSource = this.Friends;
        }

        private void AddEmailFriend()
        {
            string friendEmailAddress = this.EmailAddressInput.Text;

            if (CommonUtilities.IsValidEmailAddress(friendEmailAddress))
            {
                bool emailExists = false;

                // Do a case insensitive check
                emailExists = this.selectedEmailFriends.Contains(friendEmailAddress.ToLower());

                if (!emailExists)
                {
                    Profile emailFriend = new Profile();
                    emailFriend.ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>();
                    emailFriend.ProfileProperties[ProfileProperty.GamerTag] = friendEmailAddress;
                    emailFriend.ProfileProperties[ProfileProperty.GamerPicUrl] = DefaultEmailGamerPic;

                    this.SelectedFriendsListBox.Items.Add(emailFriend);

                    // Add the email address to the internal list which is used to send the invitations
                    // Store a ToLower version of the email address in the internal list for quick comparisons
                    this.selectedEmailFriends.Add(friendEmailAddress.ToLower());

                    this.EmailAddressInput.Text = string.Empty;

                    // There is now going to be at least one friend in the SelectedFriendsListBox so
                    // hide the overlay.
                    this.EmptySelectedFriendsBlock.Visibility = Visibility.Collapsed;
                    this.UpdateSeatsLabel();
                }
            }
            else
            {
                this.DialogBox.Show(
                    DialogButtons.OK,
                    GamePlayerAppResources.FriendPickerInvalidEmail);
            }
        }

        private void SendInvitations()
        {
            StringBuilder recipients = new StringBuilder();

            // Add the email addresses to the string.
            foreach (string email in this.selectedEmailFriends)
            {
                recipients.Append(email);
                recipients.Append(";");
            }

            // Add the gamertags to the string.
            foreach (Profile p in this.selectedFriendProfiles)
            {
                recipients.Append(GamertagPrefix);
                recipients.Append(p.ProfileProperties[ProfileProperty.GamerTag].ToString());
                recipients.Append(";");
            }

            InviteRequest emailInvites = new InviteRequest();
            emailInvites.GameId = this.FriendPickerParameters.TitleId;
            emailInvites.Recipients = recipients.ToString();
            emailInvites.SessionId = this.FriendPickerParameters.SessionId;

            // TODO: Investigate what the "Data" property is and whether or not it's needed.
            emailInvites.Data = "Friend Picker Invitation";

            this.ShowBusyIndicator(GamePlayerAppResources.FriendPickerSendingInvites);

            this.notificationProxy.PostInviteAsync(emailInvites);
        }

        // This method manages the Available Seats label based on the number of seats available
        // (passed into the Friend Picker) and the number of items in the SelectedFriendsList.
        private void UpdateSeatsLabel()
        {
            int totalOccupiedSeats = this.SelectedFriendsListBox.Items.Count;
            int remainingSeats = this.FriendPickerParameters.NumSeatsAvailable - totalOccupiedSeats;

            this.SeatsLabel.Text = String.Format(
                this.numberOfAvailableSeats,
                remainingSeats,
                this.FriendPickerParameters.NumSeatsAvailable);

            if (remainingSeats < 0)
            {
                // TODO: Remove the hard coded color reference
                this.SeatsLabel.Foreground = new SolidColorBrush(Colors.Red);

                // Only show the invitation warning once per Friend Picker "session"
                if (!this.InvitationLimitWarningShown)
                {
                    string dialogTextTempLine1 = string.Format(
                        GamePlayerAppResources.FriendPickerOverLimit,
                        this.FriendPickerParameters.NumSeatsAvailable);

                    string dialogTextTempLine2 = GamePlayerAppResources.FriendPickerStartMoreGames;
                    
                    string dialogText = String.Format(
                            "{0}{1}{2}{3}",
                            dialogTextTempLine1,
                            Environment.NewLine,
                            Environment.NewLine,
                            dialogTextTempLine2);

                    this.InvitationLimitWarningShown = true;
                    this.DialogBox.Show(
                        DialogButtons.OK,
                        dialogText);
                }
            }
            else
            {
                // TODO: Remove the hard coded color reference
                this.SeatsLabel.Foreground = new SolidColorBrush(Colors.Black);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\Comparers\ProfileGamerTagComparer.cs ===
﻿namespace NGGamePlayer.Comparers
{
    using System;
    using System.Collections.Generic;

    using Leet.UserGameData.DataContracts;

    public class ProfileGamerTagComparer : IComparer<Profile>
    {
        #region IComparer<Profile> Members

        public int Compare(Profile x, Profile y)
        {
            return String.Compare(
                x.ProfileProperties[ProfileProperty.GamerTag].ToString(),
                y.ProfileProperties[ProfileProperty.GamerTag].ToString());
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FriendPicker")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: InternalsVisibleTo("SilverlightTests")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0aad68ac-0cdc-410d-b592-427a2995a785")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\ModalDialogHideEventArgs.cs ===
﻿namespace NGGamePlayer
{
    using System;

    public class ModalDialogHideEventArgs : EventArgs
    {
        public ModalDialogHideEventArgs(DialogButtonPressed buttonPressed)
        {
            this.ButtonPressed = buttonPressed;
        }

        public DialogButtonPressed ButtonPressed { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\MyGameInfo\Page.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;
    using System.Windows.Controls;
    using SLUtilities;

    public partial class Page : UserControl
    {
        private static Uri gameSessionService = new Uri(PageVariables.GetServiceURI("g_gameSessionServiceUrl"));
        private GameLogicBridge glb = null;

        public Page()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(Page_Loaded);
        }

        void Page_Loaded(object sender, RoutedEventArgs e)
        {
            DebugTextLogger.Initialize(this.DebugTextBox, this.DebugTextScroller, true);
            DebugTextLogger.Log("MyGameInfo plugin loaded");

            // Hook up the Silverlight <--> Javscript interop callbacks for this plugin with the game object
            // If the GameLogicBridge fails to instantiate then we won't get any information from the game itself
            this.glb = new GameLogicBridge();
            if (this.glb != null)
            {
                // Hook up the Silverlight <--> Javscript interop callbacks for this plugin with the hosting object
                glb.onLoadBroadcast += glb_onLoadBroadcast;
                glb.onDataBroadcast += glb_onDataBroadcast;
                glb.onRestartGame += glb_onRestartGame;

                glb.onPropertyWrite += glb_onPropertyWrite;
                glb.onPropertyReturn += glb_onPropertyReturn;
                glb.onPropertyRead += glb_onPropertyRead;

                glb.onScoreSubmit += glb_onScoreSubmit;
                glb.onScoreBroadcast += glb_onScoreBroadcast;
                glb.onUpdateScore += glb_onUpdateScore;

                glb.onPauseOn += glb_onPauseOn;
                glb.onPauseOff += glb_onPauseOff;

                glb.onMuteOn += glb_onMuteOn;
                glb.onMuteOff += glb_onMuteOff;

                glb.onGameStart += glb_onGameStart;
                glb.onGameReady += glb_onGameReady;
                glb.onGameMenu += glb_onGameMenu;
                glb.onGameLog += glb_onGameLog;
                glb.onGameError += glb_onGameError;
                glb.onGameEnd += glb_onGameEnd;
                glb.onGameContinue += glb_onGameContinue;
                glb.onGameBreak += glb_onGameBreak;

                glb.onCustomReturn += glb_onCustomReturn;
                glb.onCustomEvent += glb_onCustomEvent;

                glb.onSessionReady += glb_onSessionReady;
                glb.onSessionStart += glb_onSessionStart;

                glb.onFriendPickerEvent += glb_onFriendPickerEvent;
                glb.onFriendPickerReturn += glb_onFriendPickerReturn;
            }

            // The MyGameInfo has a debug text view for development purposes; when deploying to prod
            // this will not be displayed. Currently this is only displayed when leet_GamePlayerEnableAPILogging
            // is set to true.
            if ((Application.Current.Resources["showDebugUI"] != null) && 
                (Application.Current.Resources["showDebugUI"].ToString() == "true"))
            {
                LayoutRoot.Visibility = Visibility.Visible;
            }
        }

        void glb_onUpdateScore(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onUpdateScore");
        }

        void glb_onSessionStart(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onSessionStart");
        }

        void glb_onSessionReady(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onSessionReady");
        }

        void glb_onCustomEvent(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_OnCustomEvent");
        }

        void glb_onCustomReturn(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onCustomReturn");
        }

        void glb_onDataBroadcast(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onDataBroadcast");
        }

        void glb_onGameBreak(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameBreak");
        }

        void glb_onGameContinue(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameContinue");
        }

        void glb_onGameEnd(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameEnd");
        }

        void glb_onGameError(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameError");
        }

        void glb_onGameLog(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameLog");
        }

        void glb_onGameMenu(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameMenu");
        }

        void glb_onGameReady(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameReady");
        }

        void glb_onGameStart(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onGameStart");
        }

        void glb_onLoadBroadcast(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onLoadBroadcast");
        }

        void glb_onMuteOff(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onMuteOff");
        }

        void glb_onMuteOn(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onMuteOn");
        }

        void glb_onPauseOff(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onPauseOff");
        }

        void glb_onPauseOn(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onPauseOn");
        }

        void glb_onPropertyRead(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onPropertyRead");
        }

        void glb_onPropertyReturn(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onPropertyReturn");
        }

        void glb_onPropertyWrite(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onPropertyWrite");
        }

        void glb_onRestartGame(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onRestartGame");
        }

        void glb_onScoreBroadcast(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onScoreBroadcast");
        }

        void glb_onScoreSubmit(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onScoreSubmit");
        }

        void glb_onFriendPickerEvent(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onFriendPickerEvent");
        }

        void glb_onFriendPickerReturn(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("glb_onFriendPickerReturn");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\ModalDialog.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;
    using System.Windows.Controls;

    [Flags]
    public enum DialogButtons
    {
        None = 0x0,
        OK = 0x1,
        Retry = 0x2,
        Cancel = 0x4,
        Close = 0x8,
    }

    public enum DialogButtonPressed
    {
        OK,
        Close,
        Retry,
        Cancel,
        None,
    }

    public partial class ModalDialog : ChildWindow
    {
        public ModalDialog()
        {
            InitializeComponent();
        }

        public delegate void HideEventHandler(object sender, ModalDialogHideEventArgs eventArgs);

        public event HideEventHandler OnHide;

        internal bool IsVisible { get; set; }

        public void Show(string dialogText)
        {
            this.Show(DialogButtons.None, dialogText);
        }

        public void Show(DialogButtons buttons, string dialogText)
        {
            // Hide the buttons/etc. so that only the ones that have been explicitly called are shown.
            this.CancelButton.Visibility = Visibility.Collapsed;
            this.CloseButton.Visibility = Visibility.Collapsed;
            this.OKButton.Visibility = Visibility.Collapsed;
            this.RetryButton.Visibility = Visibility.Collapsed;

            // Hide the close button in the title bar
            this.HasCloseButton = false;

            base.Show();
            this.IsVisible = true;

            // TODO: Replace the DialogText TextBox with an object that can receive "Content"
            this.DialogText.Text = dialogText;

            if ((buttons & DialogButtons.Cancel) == DialogButtons.Cancel)
            {
                this.CancelButton.Visibility = Visibility.Visible;
            }

            if ((buttons & DialogButtons.Close) == DialogButtons.Close)
            {
                this.CloseButton.Visibility = Visibility.Visible;
            }

            if ((buttons & DialogButtons.OK) == DialogButtons.OK)
            {
                this.OKButton.Visibility = Visibility.Visible;
            }

            if ((buttons & DialogButtons.Retry) == DialogButtons.Retry)
            {
                this.RetryButton.Visibility = Visibility.Visible;
            }
        }

        public void Hide()
        {
            this.Hide(DialogButtonPressed.None);
        }

        public void Hide(DialogButtonPressed buttonPressed)
        {
            this.OnHide(this, new ModalDialogHideEventArgs(buttonPressed));

            this.IsVisible = false;
            this.Close();
        }

        internal void CancelButton_OnClick(object sender, RoutedEventArgs e)
        {
            this.Hide(DialogButtonPressed.Cancel);
        }

        internal void CloseButton_OnClick(object sender, RoutedEventArgs e)
        {
            this.Hide(DialogButtonPressed.Close);
        }

        internal void OKButton_OnClick(object sender, RoutedEventArgs e)
        {
            this.Hide(DialogButtonPressed.OK);
        }

        internal void RetryButton_OnClick(object sender, RoutedEventArgs e)
        {
            this.Hide(DialogButtonPressed.Retry);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\FriendPicker\Converters\ProfilePropertyConverter.cs ===
﻿namespace NGGamePlayer.Converters
{
    using System;
    using System.Windows.Data;
    using Leet.UserGameData.DataContracts;

    public class ProfilePropertyConverter : IValueConverter
    {
        #region IValueConverter Members

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is Profile)
            {
                Profile profile = value as Profile;

                // Verify that the specified enum type (specified in parameter) is valid
                if (Enum.IsDefined(typeof(ProfileProperty), parameter))
                {
                    ProfileProperty propertyToReturn =
                        (ProfileProperty)Enum.Parse(typeof(ProfileProperty), parameter.ToString(), true);

                    if (profile.ProfileProperties.ContainsKey(propertyToReturn))
                    {
                        return profile.ProfileProperties[propertyToReturn];
                    }
                }
            }
            
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\MyGameInfo\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("MyGameInfo")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c8c4f454-8ee5-4947-896a-686bcddff379")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\MyGameInfo\App.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;

    public partial class App : Application
    {
        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            this.RootVisual = new Page();

            if (e.InitParams != null)
            {
                foreach (var param in e.InitParams)
                {
                    this.Resources.Add(param.Key, param.Value);
                }
            }
        }

        private void Application_Exit(object sender, EventArgs e)
        {
        }

        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {

                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;
                Deployment.Current.Dispatcher.BeginInvoke(delegate { ReportErrorToDOM(e); });
            }
        }

        private void ReportErrorToDOM(ApplicationUnhandledExceptionEventArgs e)
        {
            try
            {
                string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight 2 Application " + errorMsg + "\");");
            }
            catch (Exception)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SLUtilities\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SLUtilities")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("068a5b6c-9ca7-43f3-9512-4125ba63a07d")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\GameEngine.cs ===
﻿namespace NGGamePlayer
{
    using System;

    /// <summary>
    /// Hooks up the Silverlight plugin so it can act on the events returned by the GamePlayer
    /// </summary>
    public class GameEngine
    {
        private GameLogicBridge GLB { get; set; }

        public GameEngine()
        {
            GameLogicBridge glb = new GameLogicBridge();
            this.GLB = glb;

            glb.onGameStart += new EventHandler<GameEventArgs>(glb_onGameStart);
            glb.onGameBreak += new EventHandler<GameEventArgs>(glb_onGameBreak);
            glb.onGameContinue += new EventHandler<GameEventArgs>(glb_onGameContinue);
            glb.onGameEnd += new EventHandler<GameEventArgs>(glb_onGameEnd);
            glb.onScoreSubmit += new EventHandler<GameEventArgs>(onScoreSubmit);
        }

        void glb_onGameStart(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("GameStart event received");
        }

        void glb_onGameBreak(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("GameBreak event received");
        }

        void glb_onGameContinue(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("GameContinue event received");
        }

        void glb_onGameEnd(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("GameEnd event received");
        }

        void onScoreSubmit(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("ScoreSubmit event received");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SLUtilities\PageVariables.cs ===
﻿namespace SLUtilities
{
    using System;
    using System.Windows.Browser;

    /// <summary>
    /// Utility class to access the global javascript, query string or cookie variables for the current page
    /// </summary>
    public class PageVariables
    {
        // The game ID or titleID should be present in the page URL
        public static uint GetTitleId()
        {
            return GetTitleId("/Game/");
        }
        
        public static uint GetTitleId(string gameSubstring)
        {
            uint titleId = 0;
            const string titleIDHexFormat = "FFFFFFFF";

            try
            {
                // Extract the URL of the page
                string parentURL = HtmlPage.Document.DocumentUri.AbsoluteUri;
                if (!string.IsNullOrEmpty(parentURL))
                {
                    // Check if the URL contains the "/Game/" substring
                    int indexOfGameSubstring = parentURL.IndexOf(gameSubstring, StringComparison.OrdinalIgnoreCase);
                    if (indexOfGameSubstring != 0)
                    {
                        string szTitleId = parentURL.Substring(indexOfGameSubstring + gameSubstring.Length, titleIDHexFormat.Length);
                        titleId = Convert.ToUInt32(szTitleId, 16);
                    }
                }
            }
            catch (Exception)
            {
                // If we fail to parse a valid titleID from the URL, we will default to 0 as the title ID
                // The assumption is that a title ID of 0 is invalid
                titleId = 0;
            }

            return titleId;
        }

        // The title version is supplied as a query string parameter
        public static uint GetTitleVersion()
        {
            const uint titleVersion = 0;
            return titleVersion;
        }

        public static string GetProfileName()
        {
            const string authCookieName = "XBXGt";

            // TODO: Remove this hacky way to show that we're logged in by checking for the presence of the authorization cookie
            string[] cookies = HtmlPage.Document.Cookies.Split(';');
            foreach (string cookie in cookies)
            {
                string[] keyValue = cookie.Split('=');
                if (keyValue != null &&
                    !string.IsNullOrEmpty(keyValue[0]) &&
                    (keyValue[0].Contains(authCookieName) == true))
                {
                    return keyValue[1];
                }
            }

            return string.Empty;
        }

        // Get the service URI as defined in a javascript variable on the hosted page
        public static string GetServiceURI(string jsVariableName)
        {
            // Extract the URI from the page using the Silverlight/JS interop function
            String varName = String.Format("window.top.{0}", jsVariableName);
            object JSserviceURI = HtmlPage.Window.Eval(varName);
            return JSserviceURI.ToString();
        }

        // Calls the appropriate JavaScript method in the GamePlayer
        public static void SendEvent(string eventName, string eventParams)
        {
            try
            {
                HtmlPage.Window.Invoke(eventName, eventParams);
            }
            catch (InvalidOperationException)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SLUtilities\CommonUtilities.cs ===
﻿namespace SLUtilities
{
    using System;
    using System.Text.RegularExpressions;

    public class CommonUtilities
    {
        public static bool IsValidEmailAddress(string emailAddress)
        {
            // This regular expression checks for, at minimum, a string that matches the pattern x@y.z
            string strRegex = @"^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}" +
                  @"\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\" +
                  @".)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$";
            Regex re = new Regex(strRegex);

            if (re.IsMatch(emailAddress))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\App.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;

    public partial class App : Application
    {
        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();

            // The host object, which represents the host Silverlight plug-in.
            // The settings object which represents the browser
            System.Windows.Interop.SilverlightHost host = Application.Current.Host;
            System.Windows.Interop.Settings settings = host.Settings;

            // Limiting the frame rate to 10fps because the game performance suffers considerably as we approach 24fps.
            // The avatar team is addressing a fix in the FPSManager which starves the browser of rendering cycles because 
            // of the avatar initialization
            settings.MaxFrameRate = 10;
        }

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            this.RootVisual = new Page();
        }

        private void Application_Exit(object sender, EventArgs e)
        {
        }

        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;
                Deployment.Current.Dispatcher.BeginInvoke(delegate { this.ReportErrorToDOM(e); });
            }
        }

        private void ReportErrorToDOM(ApplicationUnhandledExceptionEventArgs e)
        {
            try
            {
                string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight 2 Application " + errorMsg + "\");");
            }
            catch (Exception)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\GameVariant.cs ===
﻿namespace NGGamePlayer
{
    using System.Collections.Generic;

    public class GameVariant
    {
        public uint ID { get; set; }

        public string FriendlyName { get; set; }

        public List<VariantProperty> Properties { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SLUtilities\GameLogicBridge.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows.Browser;

    public class GameEventArgs : EventArgs
    {
        public GameEventArgs(string parameter)
        {
            this.Parameter = parameter;
        }
        public string Parameter { get; private set; }
    }

    public class GameLogicBridge
    {
        private const string ScriptableObjectName = "SL_Events";

        private const string CustomEvent = "CustomEvent";
        private const string CustomReturn = "CustomReturn";
        private const string DataBroadcast = "DataBroadcast";
        private const string GameBreak = "GameBreak";
        private const string GameContinue = "GameContinue";
        private const string GameEnd = "GameEnd";
        private const string GameError = "GameError";
        private const string GameLog = "GameLog";
        private const string GameMenu = "GameMenu";
        private const string GameReady = "GameReady";
        private const string GameStart = "GameStart";
        private const string LoadBroadcast = "LoadBroadcast";
        private const string MuteOff = "MuteOff";
        private const string MuteOn = "MuteOn";
        private const string PauseOff = "PauseOff";
        private const string PauseOn = "PauseOn";
        private const string PropertyRead = "PropertyRead";
        private const string PropertyReturn = "PropertyReturn";
        private const string PropertyWrite = "PropertyWrite";
        private const string RestartGame = "RestartGame";
        private const string ScoreBroadcast = "ScoreBroadcast";
        private const string ScoreSubmit = "ScoreSubmit";
        private const string SessionReady = "SessionReady";
        private const string SessionStart = "SessionStart";
        private const string UpdateScore = "UpdateScore";

        private const string FriendPickerEvent = "FriendPickerEvent";
        private const string FriendPickerReturn = "FriendPickerReturn";

        /// <summary>
        /// This object is retrieved and invoked in jscript like the following:
        ///     var SLPlugin = window.parent.document.getElementById("SLP");
        ///    SLPlugin.Content.SL_GLB.Dispatcher(functionName, parameterString);
        /// </summary>
        public GameLogicBridge()
        {
            HtmlPage.RegisterScriptableObject(GameLogicBridge.ScriptableObjectName, this);
        }

        public event EventHandler<GameEventArgs> onLoadBroadcast;
        public event EventHandler<GameEventArgs> onDataBroadcast;
        public event EventHandler<GameEventArgs> onRestartGame;

        public event EventHandler<GameEventArgs> onCustomEvent;
        public event EventHandler<GameEventArgs> onCustomReturn;

        public event EventHandler<GameEventArgs> onSessionReady;
        public event EventHandler<GameEventArgs> onSessionStart;
        public event EventHandler<GameEventArgs> onScoreBroadcast;
        public event EventHandler<GameEventArgs> onScoreSubmit;
        public event EventHandler<GameEventArgs> onUpdateScore;

        public event EventHandler<GameEventArgs> onPropertyRead;
        public event EventHandler<GameEventArgs> onPropertyWrite;
        public event EventHandler<GameEventArgs> onPropertyReturn;

        public event EventHandler<GameEventArgs> onGameContinue;
        public event EventHandler<GameEventArgs> onGameMenu;
        public event EventHandler<GameEventArgs> onGameStart;
        public event EventHandler<GameEventArgs> onGameError;
        public event EventHandler<GameEventArgs> onGameLog;
        public event EventHandler<GameEventArgs> onGameBreak;
        public event EventHandler<GameEventArgs> onGameEnd;
        public event EventHandler<GameEventArgs> onGameReady;

        public event EventHandler<GameEventArgs> onMuteOn;
        public event EventHandler<GameEventArgs> onMuteOff;

        public event EventHandler<GameEventArgs> onPauseOn;
        public event EventHandler<GameEventArgs> onPauseOff;

        public event EventHandler<GameEventArgs> onFriendPickerEvent;
        public event EventHandler<GameEventArgs> onFriendPickerReturn;

        [ScriptableMember]
        public void Dispatcher(string functionName, string parameterString)
        {
            EventHandler<GameEventArgs> tmpHandler =  null;

            if (String.Compare(GameLogicBridge.CustomEvent, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onCustomEvent;
            if (String.Compare(GameLogicBridge.CustomReturn, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onCustomReturn;
            if (String.Compare(GameLogicBridge.DataBroadcast, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onDataBroadcast;
            if (String.Compare(GameLogicBridge.GameBreak, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameBreak;
            if (String.Compare(GameLogicBridge.GameContinue, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameContinue;
            if (String.Compare(GameLogicBridge.GameEnd, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameEnd;
            if (String.Compare(GameLogicBridge.GameError, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameError;
            if (String.Compare(GameLogicBridge.GameLog, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameLog;
            if (String.Compare(GameLogicBridge.GameMenu, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameMenu;
            if (String.Compare(GameLogicBridge.GameReady, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameReady;
            if (String.Compare(GameLogicBridge.GameStart, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onGameStart;
            if (String.Compare(GameLogicBridge.LoadBroadcast, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onLoadBroadcast;
            if (String.Compare(GameLogicBridge.MuteOff, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onMuteOff;
            if (String.Compare(GameLogicBridge.MuteOn, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onMuteOn;
            if (String.Compare(GameLogicBridge.PauseOff, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onPauseOff;
            if (String.Compare(GameLogicBridge.PauseOn, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onPauseOn;
            if (String.Compare(GameLogicBridge.PropertyRead, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onPropertyRead;
            if (String.Compare(GameLogicBridge.PropertyReturn, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onPropertyReturn;
            if (String.Compare(GameLogicBridge.PropertyWrite, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onPropertyWrite;
            if (String.Compare(GameLogicBridge.RestartGame, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onRestartGame;
            if (String.Compare(GameLogicBridge.ScoreBroadcast, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onScoreBroadcast;
            if (String.Compare(GameLogicBridge.ScoreSubmit, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onScoreSubmit;
            if (String.Compare(GameLogicBridge.SessionReady, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onSessionReady;
            if (String.Compare(GameLogicBridge.SessionStart, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onSessionStart;
            if (String.Compare(GameLogicBridge.UpdateScore, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onUpdateScore;
            if (String.Compare(GameLogicBridge.FriendPickerEvent, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onFriendPickerEvent;
            if (String.Compare(GameLogicBridge.FriendPickerReturn, functionName, StringComparison.OrdinalIgnoreCase) == 0)
                tmpHandler = this.onFriendPickerReturn;
            if (tmpHandler != null)
            {
                tmpHandler(this, new GameEventArgs(parameterString));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SLUtilities\DebugTextLogger.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Windows;
    using System.Windows.Browser;
    using System.Windows.Controls;

    public static class DebugTextLogger
    {
        private static TextBox DebugTextBox { get; set; }
        private static ScrollViewer DebugScrollViewer { get; set; }
        private static bool IsDebugMode { get; set; }

        public static void Initialize(TextBox debugTb, ScrollViewer debugSv, bool isDebugMode)
        {
            // Used the passed in UIElements to display the debug output
            DebugTextBox = debugTb;
            DebugScrollViewer = debugSv;
            IsDebugMode = isDebugMode;

            if (DebugTextBox != null && DebugScrollViewer != null && IsDebugMode == true)
            {
                if (IsDebugMode)
                {
                    DebugTextBox.Visibility = Visibility.Visible;
                    DebugScrollViewer.Visibility = Visibility.Visible;
                }
                else
                {
                    DebugTextBox.Visibility = Visibility.Collapsed;
                    DebugScrollViewer.Visibility = Visibility.Collapsed;
                }
            }
        }

        public static void Log(string message)
        {
            if (DebugTextLogger.IsDebugMode)
            {
                // TODO: We should check that the ASP page is loaded and that the WriteAPILog JS function is present
                HtmlPage.Window.Invoke("WriteAPILog", message);

                // Check if we've supplied UIElements for debug output
                if (DebugTextBox != null && DebugScrollViewer != null)
                {
                    DebugTextBox.Text += String.Format("{0}\n", message);
                    if (DebugScrollViewer.ScrollableHeight > 0)
                    {
                        DebugScrollViewer.UpdateLayout();
                        DebugScrollViewer.ScrollToVerticalOffset(double.MaxValue);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\VariantProperty.cs ===
﻿namespace NGGamePlayer
{
    public class VariantProperty
    {
        public string ID { get; set; }

        public string FriendlyName { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\Converters\BooleanToVisibilityConverter.cs ===
﻿namespace NGGamePlayer.Converters
{
    using System;
    using System.Globalization;
    using System.Windows;
    using System.Windows.Data;

    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool)
            {
                return ((bool)value == false) ? Visibility.Collapsed : Visibility.Visible;
            }

            throw new InvalidOperationException();
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "XboxLive.PDLC.Service")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses", Scope = "type", Target = "XboxLive.PDLC.Service.AppServiceHostFactory")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "XboxLive.PDLC.Service.Global.#Application_BeginRequest(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "XboxLive.PDLC.Service.Global.#Application_End(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "XboxLive.PDLC.Service.Global.#Application_Error(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "XboxLive.PDLC.Service.Global.#Application_EndRequest(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "XboxLive.PDLC.Service.Global.#Application_Start(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetContext()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetContextInternal(Leet.Identity.PartnerAuth.PartnerIdentity)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetPartnerIdentity(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetUserAccountInfo(System.UInt64,System.Byte&,System.Boolean&,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#HandleLiveCacheException(System.String,System.UInt64,System.Exception)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#MOPageAddPointsUrl")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#MOPageTouUrl")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#MOPageSetupBillingUrl")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#Purchase(XboxLive.PDLC.Service.Contracts.PurchaseRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#ResolveUserAccountLocale(System.UInt64)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#VerifyToken(System.String,System.UInt32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#XblMarketplaceCatalogUrl")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetLocaleFromHeader()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetPlatformTypeFromHeader()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetPlatformTypeFromHeader()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetReceipts(XboxLive.PDLC.Service.Contracts.ReceiptRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#AvatarMarketplaceUrl")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#ConsumeAssets(XboxLive.PDLC.Service.Contracts.ConsumeRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetAssets(System.UInt32,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetPointsBalanceInternal(Leet.Identity.PartnerAuth.PartnerIdentity)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetPointsBalance()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#GetUserAccountInfo(System.UInt64,System.Int32&,System.Boolean&,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#LogBIData(Leet.Identity.PartnerAuth.PartnerIdentity,System.String,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#LogBIData(Leet.Identity.PartnerAuth.PartnerIdentity,System.String,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#PurchaseInternal(Leet.Identity.PartnerAuth.PartnerIdentity,XboxLive.PDLC.Service.Contracts.PurchaseRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#PurchaseAudienceUri")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1309:UseOrdinalStringComparison", MessageId = "System.String.Compare(System.String,System.String,System.StringComparison)", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#Purchase(XboxLive.PDLC.Service.Contracts.PurchaseRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#PurchaseInternal(Leet.Identity.PartnerAuth.PartnerIdentity,XboxLive.PDLC.Service.Contracts.PurchaseRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#VerifyTokenInternal(Leet.Identity.PartnerAuth.PartnerIdentity,System.String,System.UInt32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "XboxLive.PDLC.Service.PdlcService.#ValidateCommonHeaders(System.String)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SocialInfo")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: InternalsVisibleTo("SilverlightTests")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("16e10430-91ad-4647-9c76-4f66224b39aa")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\Page.xaml.cs ===
﻿namespace NGGamePlayer
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;
    using System.Windows.Media;
    using System.Windows.Media.Imaging;
    using System.Xml.Linq;
    using Gds;
    using Gds.Contracts;
    using Leet.Silverlight.RESTProxy.WebAuthProxy;
    using Microsoft.XboxLive.Avatars.Control;
    using Resources;
    using SLUtilities;

    /// <summary>
    /// This is the friends leaderboard control that shows the lifetime score of the player versus his friends. The leaderboard is currently limited to 5 players, 
    /// possibly including the player. Initially the leaderboard  will be retrieved from the rewards service at the start of a game and then further calls will 
    /// not be necessary given the short time that a Rush game may take
    /// NOTE: If we need to update track the leaderboard changes for a game that might span a long time (e.g. hours), we might want to periodically retrieve the leaderboard updates from the service
    /// </summary>
    public partial class Page : UserControl
    {
        // Store the default starting width/height of the control for resizing purposes
        private const int DefaultWidth = 200;
        private const int DefaultHeight = 480;

        // Image used when we don't have a profile pic for the user
        private const string FallbackGamerPic = "Resources/XBOXFallbackPic.jpg";

        // IMPORTANT: The RPSAuth cookies is appended to the HTTP web requests only if it's within the same domain.
        //            For development, our domain is really the localhost (which we faked as www.dev.xbox.com) in our HOSTS file
        //            For the RPSAuth cookie to be appended to all outgoing requests, we need to the rewards service in the same domain 
        private static Uri gameResultService = null;
        private static Uri gameDataService = null;
        private static Uri gameStatisticsService = null;
        private static Uri stsService = null;

        // Avatar URLs
        private string avatarBodyBaseURL = PageVariables.GetServiceURI("g_avatarBodyBaseUrl");
        private string avatarAssetUrlFormat = PageVariables.GetServiceURI("g_avatarAssetUrl");
        private string avatarNonStockAssetUrlFormat = PageVariables.GetServiceURI("g_avatarNonStockAssetUrl");
        private string avatarManifestServiceUrlFormat = PageVariables.GetServiceURI("g_avatarManifestUrl");

        // The Silverlight to Javascript interop bridge
        private GameLogicBridge glb = null;

        // The REST proxy we use to obtain an STS token on behalf of the user so we can make calls into the rewards service
        private IWebAuthProxy webAuthProxy = null;

        // The REST proxy we will use to submit the scores and retrieve the leaderboard from the rewards webservice
        private IRewardsProxy rewardsProxy = null;

        // The max number of friends is 1000 but the UDS service may return only a subset of the 1000 list
        // All leaderboard lists should start at rank 1 but may be truncated. Caller is responsible for 
        // checking whether requested ResponseResults == TotalNumberOfRows returned.
        private uint maxResponseResults = 60;
        private string dataGroup = "lifetime";

        // These indexes are used to track which variant/property is selected via the "selector" controls.
        private int variantIndex = -1;
        private int propertyIndex = -1;

        // The default property will be BestScore. A game can override the default by supplying the property
        // as part of the SessionReady event
        private string propertyID = "BestScore";

        // Extract these values through SLUtilities::JavascriptVariables class
        private uint gameID;
        private uint gameVersion;

        // Record the last score since this is not returned by the Statistics service call
        private long lastScore = 0;

        public Page()
            : this(null, null, 0)
        {
        }

        internal Page(
            IWebAuthProxy wap,
            IRewardsProxy rp,
            uint titleId)
        {
            InitializeComponent();

            this.SignedInUserPageIndex = -1;

            this.webAuthProxy = wap;
            this.rewardsProxy = rp;

            if ((rp != null) && (wap == null))
            {
                throw new InvalidOperationException(
                    "The rewards proxy cannot be mocked against a live web authentication proxy.");
            }

            Loaded += this.Page_Loaded;

            // Initialize the debug engine for trace output
            DebugTextLogger.Initialize(null, null, true);

            // Hook up the Silverlight <--> Javscript interop callbacks for this plugin with the game object
            // If the GameLogicBridge fails to instantiate then we won't get any information from the game itself
            // NOTE: As the Javascript bridge calls this plugin, we instantiate GLB even though there may be no
            //       JS events to monitor
            this.glb = new GameLogicBridge();

            // Retrieve the titleID either from the constructor parameter (test-only) or from the URL (production).
            this.gameID = titleId != 0 ? titleId : PageVariables.GetTitleId();

            // The avatar displayed during loading and key events during gameplay
            this.AvatarControl = new AvatarControl(
                this.avatarAssetUrlFormat,
                this.avatarNonStockAssetUrlFormat,
                this.avatarManifestServiceUrlFormat);

            this.AvatarControl.AvatarLoadingFinished += this.OnAvatarLoadingCompleted;
            this.AvatarControl.NotifyIncreaseQuota += this.OnAvatarNotifyIncreaseQuota;

            // Hook up each leaderboard button to the same event handler
            ButtonPlayer1.Click += this.ButtonPlayer_Click;
            ButtonPlayer2.Click += this.ButtonPlayer_Click;
            ButtonPlayer3.Click += this.ButtonPlayer_Click;
            ButtonPlayer4.Click += this.ButtonPlayer_Click;
            ButtonPlayer5.Click += this.ButtonPlayer_Click;
            ButtonPlayer6.Click += this.ButtonPlayer_Click;
            ButtonPlayer7.Click += this.ButtonPlayer_Click;
            ButtonPlayer8.Click += this.ButtonPlayer_Click;
            ButtonPlayer9.Click += this.ButtonPlayer_Click;

            // Listen for the leaderboard property information from the loaded game
            this.glb.onSessionReady += this.OnSessionReady;
        }

        // The currently signed in users Gamertag
        internal string CurrentGamertag { get; set; }

        // A tracking variable, primarily for test, that tracks the state of the STS call
        internal bool StsError { get; set; }

        // Renders a 3D avatar
        internal AvatarControl AvatarControl { get; set; }

        // Store a collection of the variants and their associated properties, keyed by variant ID
        internal List<GameVariant> Variants { get; set; }

        // Tracking variables for the 3D avatar
        internal bool AvatarLoaded { get; set; }

        // Internal storage of the leaderboard data and pagination support
        internal List<LeaderboardItem> FriendList { get; set; }

        internal PagedCollectionView FriendPCV { get; set; }

        // Remember the rank so we can highlight the leaderboard item
        internal uint SignedInUserRank { get; set; }

        // Store the PCV page where we can find the current user's leaderboard stats (-1 indicates not present)
        internal int SignedInUserPageIndex { get; set; }

        /// <summary>
        /// This event handler will only display the selected button plus its details and hide the rest of the buttons
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        internal void ButtonPlayer_Click(object sender, RoutedEventArgs e)
        {
            // The sender is a button
            Button senderButton = (Button)sender;

            // The datacontext is a GDS.Contract.LeaderboardItem
            LeaderboardItem rankedUser = (LeaderboardItem)senderButton.DataContext;
            this.ShowDetails(rankedUser);
        }

        /// <summary>
        /// Navigate the leaderboard to the page with the entry for the signed-in user
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        internal void ButtonJumpToMyPage_Click(object sender, RoutedEventArgs e)
        {
            this.FriendPCV.MoveToPage(this.SignedInUserPageIndex);
        }

        internal void DetailsCloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.HideDetails();
        }

        /// <summary>
        /// Shows the leaderboard buttons and binds them to the correct LeaderboardItem object
        /// </summary>
        internal void ShowCurrentLeaderboardItems()
        {
            int viewCount = this.FriendPCV.Count;

            // Hide all the leaderboard buttons since we only display the number needed for this page
            // Clear the previous UI binding because under the debugger it throws warnings when the binding
            // is unresolved.
            foreach (Button element in CanvasPlayers.Children)
            {
                element.Visibility = Visibility.Collapsed;
                element.ClearValue(DataContextProperty);
                element.Style = PlayerTile;
            }

            // For some reason, binding a PagedCollectionView to a button explicitly using {Binding [0]}
            // does not work
            for (int i = 0; i < viewCount; i++)
            {
                Button buttonLeaderboardItem = (Button)CanvasPlayers.Children[i];
                LeaderboardItem leaderboardItem = (LeaderboardItem)this.FriendPCV[i];

                buttonLeaderboardItem.Visibility = Visibility.Visible;
                buttonLeaderboardItem.DataContext = leaderboardItem;

                // Highlight the only current signed-in user in the ranked list
                if (leaderboardItem.Rank == this.SignedInUserRank)
                {
                    buttonLeaderboardItem.Style = HighlightedPlayerTile;
                }
            }

            // Check whether we have more than one page of leaderboard entries
            if (this.FriendPCV.ItemCount > this.FriendPCV.PageSize)
            {
                // Hook up the pagination support and display the navigation controls
                LeaderboardNavigation.Visibility = Visibility.Visible;
                DataPagerNavigator.Source = this.FriendPCV;

                // If the user isn't in the leaderboard hide the JumpToMyPage button
                if (this.SignedInUserPageIndex == -1)
                {
                    this.ButtonJumpToMyPage.Visibility = Visibility.Collapsed;
                }
            }
            else
            {
                // If there's only one page to display in the PCV then we can hide the navigation controls
                LeaderboardNavigation.Visibility = Visibility.Collapsed;
            }

            // Hide the subtitle text since we're not displaying any error message and
            // we don't need to highlight that the user should sign-in to get the full experience
            LeaderboardTitleSubText.Visibility = Visibility.Collapsed;

            // Check if we have unique variant name otherwise hide the UI control
            if (GameVariantName.Text == GamePlayerAppResources.DefaultVariantTitle)
            {
                GameVariantName.Visibility = Visibility.Collapsed;
            }
            else
            {
                GameVariantName.Visibility = Visibility.Visible;
            }

            this.ShowLeaderboardAnimation();
        }

        /// <summary>
        /// Listens for the default leaderboard properties supplied by the game
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        internal void OnSessionReady(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("SocialInfo::glb_onSessionReady called");

            try
            {
                // Extract the score and time from the last game session
                XElement root = XElement.Parse(e.Parameter);

                // Simple security check that the gameID matches the one supplied in the URL
                uint xmlGameID = uint.Parse(root.Element("GameID").Value);
                if (xmlGameID == this.gameID)
                {
                    // Leaderboard property items
                    var variantList = from GameVariant in root.Elements("GameVariant")
                                      select new
                                      {
                                          GameVariantId = int.Parse(GameVariant.Attribute("id").Value),
                                          GameVariantName = GameVariant.Element("FriendlyName").Value,
                                          PropertyItems = from item in GameVariant.Elements("LeaderboardProperty")
                                                          select new
                                                          {
                                                              PropertyId = item.Attribute("id").Value,
                                                              PropertyName = item.Value
                                                          }
                                      };

                    int variantCount = variantList.Count();
                    if (variantCount == 0)
                    {
                        throw new ArgumentException("No variants were specified in the SessionReadyParams");
                    }

                    this.Variants = new List<GameVariant>(variantCount);

                    // Populate the internal collection of variants
                    foreach (var variant in variantList)
                    {
                        GameVariant gameVariant = new GameVariant();
                        gameVariant.ID = (uint)variant.GameVariantId;
                        gameVariant.FriendlyName = variant.GameVariantName;

                        gameVariant.Properties = new List<VariantProperty>(variant.PropertyItems.Count());

                        // Verify that each variant has at least one property, if the count is zero then throw for cert.
                        if (variant.PropertyItems.Count() == 0)
                        {
                            DebugTextLogger.Log(String.Format("There are no leaderboard properties for variant \"{0}\"", variant.GameVariantName));
                            throw new ArgumentException(String.Format("No leaderboard properties were passed in for variant \"{0}\"", variant.GameVariantName));
                        }

                        foreach (var property in variant.PropertyItems)
                        {
                            gameVariant.Properties.Add(new VariantProperty()
                            {
                                ID = property.PropertyId,
                                FriendlyName = property.PropertyName,
                            });
                        }

                        this.Variants.Add(gameVariant);
                    }

                    // We use the "first" variant and property passed to us as the default
                    if (this.Variants.Count > 0)
                    {
                        this.variantIndex = 0;
                        this.propertyIndex = 0;
                    }
                }
                else
                {
                    DebugTextLogger.Log("WARNING: GameID for the page and onSessionReady differ");
                }
            }
            catch (Exception ex)
            {
                DebugTextLogger.Log("Error parsing the SessionReady information " + ex.Message);
            }
            finally
            {
                // Get the currently signed in user's profile name
                this.CurrentGamertag = PageVariables.GetProfileName();
                if (!string.IsNullOrEmpty(this.CurrentGamertag))
                {
                    // Display the refresh link
                    this.RefreshLink.Visibility = Visibility.Visible;

                    this.SetSubtitleText(GamePlayerAppResources.GenericLeaderboardSubTitle);

                    // The URL should contain the title ID.
                    if (this.gameID != 0)
                    {
                        this.gameVersion = PageVariables.GetTitleVersion();

                        if (this.webAuthProxy == null)
                        {
                            // We are signed in so extract the auth token required for the leaderboard service calls
                            this.webAuthProxy = new WebAuthProxy(stsService);
                        }

                        // Display the busy progress bar
                        busyProgressBar.IsBusy = true;

                        this.webAuthProxy.OnWebAuthRequestCompleted += this.OnWebAuthRequestCompleted;
                        this.webAuthProxy.GetUserTokenHTTP(this.gameID, this.gameVersion);
                    }
                    else
                    {
                        this.ShowError("[DEV] No leaderboard information found for this game");
                        DebugTextLogger.Log("SocialInfo: unexpected title ID = 0");
                    }
                }
                else
                {
                    DebugTextLogger.Log("SocialInfo: XBXGt cookie not found");
                }
            }
        }

        internal void RefreshLink_OnClick(object sender, RoutedEventArgs e)
        {
            this.RefreshLeaderboard();
        }

        internal void VariantPreviousButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.variantIndex > 0)
            {
                this.variantIndex--;
            }
            else
            {
                this.variantIndex = this.Variants.Count - 1;
            }

            this.propertyIndex = 0;
            this.RefreshLeaderboard();
        }

        internal void VariantNextButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.variantIndex < this.Variants.Count - 1)
            {
                this.variantIndex++;
            }
            else
            {
                this.variantIndex = 0;
            }

            this.propertyIndex = 0;
            this.RefreshLeaderboard();
        }

        internal void PropertyPreviousButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.propertyIndex > 0)
            {
                this.propertyIndex--;
            }
            else
            {
                this.propertyIndex = this.Variants[this.variantIndex].Properties.Count - 1;
            }

            this.RefreshLeaderboard();
        }

        internal void PropertyNextButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.propertyIndex < this.Variants[this.variantIndex].Properties.Count - 1)
            {
                this.propertyIndex++;
            }
            else
            {
                this.propertyIndex = 0;
            }

            this.RefreshLeaderboard();
        }

        private void GetServiceUrls(bool isProduction)
        {
            if (isProduction)
            {
                // NOTE: Extracting the service URL through JS seems like it might pose an injection attack point
                gameResultService = new Uri(PageVariables.GetServiceURI("g_rewardsServiceUrl"));
                gameDataService = new Uri(PageVariables.GetServiceURI("g_userdataServiceUrl"));
                gameStatisticsService = new Uri(PageVariables.GetServiceURI("g_statisticsServiceUrl"));

                // The STS service is passed through its own JS variable
                stsService = new Uri(PageVariables.GetServiceURI("g_stsServiceUrl"));
            }
        }

        private void Page_Loaded(object sender, RoutedEventArgs e)
        {
            DebugTextLogger.Log("SocialInfo plugin loaded");

            // Set the text for UI labels, doing this programmatically to a) suppress warnings about the XAML,
            // and b) make this more easily unit testable.
            this.LeaderboardTitle.Text = GamePlayerAppResources.LeaderboardTitle;
            this.LeaderboardTitleSubText.Text = GamePlayerAppResources.LeaderboardTitleSubText;
            this.GameVariantName.Text = GamePlayerAppResources.DefaultVariantTitle;
            this.GameLeaderboardProperty.Text = GamePlayerAppResources.DefaultLeaderboardPropertyTitle;
            this.ButtonJumpToMyPage.Content = GamePlayerAppResources.JumpToMyPageTitle;
            this.DVBestScoreTitle.Text = GamePlayerAppResources.BestScoreTitle;
            this.DVAverageScoreTitle.Text = GamePlayerAppResources.AverageScoreTitle;
            this.DVCumulativeScoreTitle.Text = GamePlayerAppResources.CumulativeScoreTitle;
            this.DVBestTimeTitle.Text = GamePlayerAppResources.BestTimeTitle;
            this.DVAverageTimeTitle.Text = GamePlayerAppResources.AverageTimeTitle;
            this.DVCumulativeTimeTitle.Text = GamePlayerAppResources.CumulativeTimeTitle;
            this.DVWinsTitle.Text = GamePlayerAppResources.WinsTitle;
            this.DVLossesTitle.Text = GamePlayerAppResources.LossesTitle;
            this.DVGamesPlayedTitle.Text = GamePlayerAppResources.GamesPlayedTitle;
            this.DVLastPlayedTitle.Text = GamePlayerAppResources.LastPlayedTitle;
            this.busyProgressBar.BusyContent = GamePlayerAppResources.PleaseWaitTitle;

            // Extract the URL strings for the services we requires
            this.GetServiceUrls(true);

            // Display the fallback values
            this.DisplayDefaultLoadingImage();
        }

        // Assuming we signed in successfully
        private void OnWebAuthRequestCompleted(object sender, WebAuthProxyEventArgs e)
        {
            // WebAuthProxy should return a non-empty, non-null result to use as the authorization token
            if (e.Error == null)
            {
                this.StsError = false;
                DebugTextLogger.Log("Found an authorization token!!!");

                // If this.rewardsProxy is not null it means that an implementation was passed to it in the,
                // the constructor; otherwise it hasn't been set yet so try to wire one up from the STS token.
                if (this.rewardsProxy == null)
                {
                    // Instantiate the proxy so we can get data from the service
                    this.rewardsProxy = new RewardsProxy(
                        Page.gameResultService,
                        Page.gameDataService,
                        Page.gameStatisticsService,
                        e.Result,
                        null); // no cookie container
                }

                // Monitor the end-game score submit event so we can send the result to the rewards service
                this.glb.onScoreSubmit += this.OnScoreSubmit;

                this.RefreshLeaderboard();
            }
            else
            {
                // Failed to extract the auth token
                DebugTextLogger.Log("Failed to extract the authorization token");
                this.busyProgressBar.IsBusy = false;
                this.StsError = true;

                this.ShowError(GamePlayerAppResources.LeaderboardSTSError);
            }

            // NOTE: Good practice to uncouple the event handler when you're done
            ((IWebAuthProxy)sender).OnWebAuthRequestCompleted -= this.OnWebAuthRequestCompleted;
        }

        private void RefreshLeaderboard()
        {
            // Ensure that the details view is hidden and the associated logic is executed
            // The details view is hidden on every refresh.
            this.HideDetails();

            if (this.rewardsProxy != null)
            {
                if (this.StsError == false)
                {
                    // This is the default variant if one is not supplied.
                    uint variantID = 0;

                    // If the variant is negative it means we weren't passed any values by the game so stick with the defaults.
                    if (this.variantIndex >= 0)
                    {
                        GameVariant variant = this.Variants[this.variantIndex];
                        variantID = variant.ID;

                        if (this.propertyIndex >= 0)
                        {
                            this.propertyID = variant.Properties[this.propertyIndex].ID;
                        }
                    }

                    this.busyProgressBar.IsBusy = true;

                    // Retrieve the friends leaderboard for the current user
                    this.rewardsProxy.OnGetLeaderboardCompleted += this.OnGetLeaderboardCompleted;
                    this.rewardsProxy.GetLeaderboardAsync(
                        this.gameID,
                        variantID,
                        this.propertyID,
                        this.dataGroup,
                        this.maxResponseResults);
                }
                else
                {
                    // We got an STS error, try again to get the user token.
                    // If this succeeds the OnWebAuthRequestCompleted callback will refresh the leaderboard.
                    this.webAuthProxy.OnWebAuthRequestCompleted += this.OnWebAuthRequestCompleted;
                    this.webAuthProxy.GetUserTokenHTTP(this.gameID, this.gameVersion);
                }
            }
        }

        private void RefreshLeaderboardSelector()
        {
            // Update the state of the variant/property selector buttons if necessary
            // this.variants == null means we weren't passed any session ready params so we only show the
            // default variant and property.
            if (this.Variants == null)
            {
                // Show the leaderboard selector, but hide the variant selector and property buttons
                this.LeaderboardSelector.Visibility = Visibility.Visible;
                this.GameVariantName.Visibility = Visibility.Collapsed;

                this.VariantNextButton.Visibility = Visibility.Collapsed;
                this.VariantPreviousButton.Visibility = Visibility.Collapsed;
                this.PropertyNextButton.Visibility = Visibility.Collapsed;
                this.PropertyPreviousButton.Visibility = Visibility.Collapsed;
            }
            else if (this.variantIndex >= 0)
            {
                GameVariant currentVariant = this.Variants[this.variantIndex];

                this.LeaderboardSelector.Visibility = Visibility.Visible;
                this.GameVariantName.Text = currentVariant.FriendlyName;
                this.GameLeaderboardProperty.Text = currentVariant.Properties[this.propertyIndex].FriendlyName;

                // Show the variant selector buttons if there was more than one variant.
                if (this.Variants.Count > 1)
                {
                    this.VariantNextButton.Visibility = Visibility.Visible;
                    this.VariantPreviousButton.Visibility = Visibility.Visible;
                }
                else
                {
                    this.VariantNextButton.Visibility = Visibility.Collapsed;
                    this.VariantPreviousButton.Visibility = Visibility.Collapsed;
                }

                // Show the property selector buttons if there was more than one property for this variant.
                if (currentVariant.Properties.Count > 1)
                {
                    this.PropertyNextButton.Visibility = Visibility.Visible;
                    this.PropertyPreviousButton.Visibility = Visibility.Visible;
                }
                else
                {
                    this.PropertyNextButton.Visibility = Visibility.Collapsed;
                    this.PropertyPreviousButton.Visibility = Visibility.Collapsed;
                }
            }
        }

        /// <summary>
        /// This display the preset leaderboard information if the service is unavailable or the data retrieval is still in progress.
        /// </summary>
        private void DisplayDefaultLoadingImage()
        {
            // Display some information about the leaderboard
            LeaderboardTitleSubText.Visibility = Visibility.Visible;

            // Hide the player grid and show the signed out panel
            this.GridPlayers.Visibility = Visibility.Collapsed;
            this.DefaultImagePanel.Visibility = Visibility.Visible;
        }

        /// <summary>
        /// Display animation where the leaderboard entries are "destroyed" and then reconstituted
        /// </summary>
        private void ShowLeaderboardAnimation()
        {
            // Show the animation creating the leaderboard
            VisualStateManager.GoToState(this, "LeaderboardUnloading", false);
            VisualStateManager.GoToState(this, "LeaderboardLoading", false);
        }

        private void ShowDetails(LeaderboardItem rankedUser)
        {
            DebugTextLogger.Log("SocialInfo::ButtonPlayer_Click called");

            // Hide all the player grid and show the details panel
            GridPlayers.Visibility = Visibility.Collapsed;
            GridStatistics.Visibility = Visibility.Visible;

            this.DisplayUserStats(rankedUser);
        }

        private void HideDetails()
        {
            // Display the player grid and hide the details pane
            this.LeaderboardSelector.Visibility = Visibility.Visible;
            this.GridStatistics.Visibility = Visibility.Collapsed;

            if ((this.FriendList != null) && (this.FriendList.Count > 0))
            {
                this.GridPlayers.Visibility = Visibility.Visible;
            }

            // Hide the busy indicator and the statistics
            busyProgressBar.IsBusy = false;

            this.AvatarLoaded = false;
        }

        /// <summary>
        /// GetUserStats binds the detailed stats of the player to XAML UI components
        /// </summary>
        /// <param name="selectedUser">User clicked in the ranked leaderboard</param>
        private void DisplayUserStats(LeaderboardItem selectedUser)
        {
            DebugTextLogger.Log("SocialInfo::OnGetUserStatsCompleted called");

            // Reset the state of the stats detail view
            this.DVBestScore.Visibility = Visibility.Collapsed;
            this.DVAverageScore.Visibility = Visibility.Collapsed;
            this.DVCumulativeScore.Visibility = Visibility.Collapsed;
            this.DVWins.Visibility = Visibility.Collapsed;
            this.DVBestTime.Visibility = Visibility.Collapsed;
            this.DVAverageTime.Visibility = Visibility.Collapsed;
            this.DVGamesPlayed.Visibility = Visibility.Collapsed;
            this.DVLastPlayed.Visibility = Visibility.Collapsed;

            if (selectedUser != null)
            {
                // Hide the Leaderboard selector
                this.LeaderboardSelector.Visibility = Visibility.Collapsed;

                this.DetailsGamertagLabel.Text = selectedUser.User.GamerTag;
                this.DetailsRank.Text = selectedUser.Rank.ToString();

                this.DisplayAvatar();

                // Since we supplied the variant field to the GetUserStats called.
                // We should only receive one StatisticSet for this game variant.
                foreach (Entry stat in selectedUser.Statistics)
                {
                    // According to Savas, an untracked stat (for each game) will not be returned
                    // from the service.
                    switch (stat.Name)
                    {
                        case "BestScore":
                            this.DVBestScore.Visibility = Visibility.Visible;
                            this.DVBestScoreLabel.Text = stat.Value;
                            break;

                        case "AverageScore":
                            this.DVAverageScore.Visibility = Visibility.Visible;
                            this.DVAverageScoreLabel.Text = stat.Value;
                            break;

                        case "CumulativeScore":
                            this.DVCumulativeScore.Visibility = Visibility.Visible;
                            this.DVCumulativeScoreLabel.Text = stat.Value;
                            break;

                        case "BestTime":
                            this.DVBestTime.Visibility = Visibility.Visible;
                            this.DVBestTimeLabel.Text = stat.Value;
                            break;

                        case "AverageTime":
                            this.DVAverageTime.Visibility = Visibility.Visible;
                            this.DVAverageTimeLabel.Text = stat.Value;
                            break;

                        case "CumulativeTime":
                            this.DVCumulativeTime.Visibility = Visibility.Visible;
                            this.DVCumulativeTimeLabel.Text = stat.Value;
                            break;

                        case "Wins":
                            this.DVWins.Visibility = Visibility.Visible;
                            this.DVWinsLabel.Text = stat.Value;
                            break;

                        case "Losses":
                            this.DVLosses.Visibility = Visibility.Visible;
                            this.DVLossesLabel.Text = stat.Value;
                            break;

                        case "GamesPlayed":
                            this.DVGamesPlayed.Visibility = Visibility.Visible;
                            this.DVGamesPlayedLabel.Text = stat.Value;
                            break;

                        case "LastPlayedDateTime":
                            // Storing this in a DateTime since we get a string back from the service
                            // that might not be correctly formatted for each culture, also this gives
                            // us more formatting flexibility.
                            DateTime lastPlayed = DateTime.Parse(stat.Value);

                            this.DVLastPlayed.Visibility = Visibility.Visible;
                            this.DVLastPlayedLabel.Text = String.Format(
                                "{0}{1}{2}",
                                lastPlayed.ToShortDateString(),
                                Environment.NewLine,
                                lastPlayed.ToShortTimeString());
                            break;

                        default:
                            break;
                    }
                }
            }
        }

        private void DisplayAvatar()
        {
            if (!String.IsNullOrEmpty(this.DetailsGamertagLabel.Text))
            {
                // Hide the avatar until it's completely downloaded
                this.avatarCanvas.Visibility = Visibility.Collapsed;

                // Download the appropriate 3D avatar
                this.AvatarControl.LoadAvatar(this.DetailsGamertagLabel.Text);

                // According to the Avatar team, adding the control to the canvas here is the right solution
                // instead of waiting on the result of the loading callback
                // Make sure that the avatarCanvas is empty before attempting to add the avatar control.
                this.avatarCanvas.Children.Clear();
                this.avatarCanvas.Children.Add(this.AvatarControl);
            }
        }

        private void OnAvatarLoadingCompleted(object sender, AvatarLoadingEventArgs e)
        {
            // If the 3D Avatar loaded successfully show it.
            if (e.Error == null)
            {
                // Set up the rendering of the 3D avatar.
                this.AvatarControl.Width = Double.NaN;
                this.AvatarControl.HorizontalAlignment = HorizontalAlignment.Stretch;
                this.AvatarControl.Height = Double.NaN;
                this.AvatarControl.VerticalAlignment = VerticalAlignment.Stretch;
                this.AvatarControl.Antialiasing = AntialiasingMode.Quincunx;
                this.AvatarControl.IsMirrorVisible = false;

                // Add the avatar to the display
                this.AvatarControl.CameraLookAt(AvatarPose.Body);
                this.AvatarControl.IsHitTestVisible = false;

                Guid animationGenericCelebration = new Guid(0x00400000, 0x0008, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
                this.AvatarControl.PlayAvatarAnimation(animationGenericCelebration, true);

                this.AvatarLoaded = true;
            }
            else
            {
                Image avatarImage = new Image();
                avatarImage.Width = 120;
                avatarImage.HorizontalAlignment = HorizontalAlignment.Center;
                avatarImage.VerticalAlignment = VerticalAlignment.Bottom;

                // TODO: Get the avatar URL, probably from a JS page variable so it can be "environmentally aware"
                string avatarURL = this.avatarBodyBaseURL.Replace("{gamertag}", this.DetailsGamertagLabel.Text);
                avatarImage.Source = new BitmapImage(new Uri(avatarURL));

                // Since we've already added the 3D AvatarControl to the canvas but something failed, 
                // we remove the existing children controls and use our fallback image as a replacement
                this.avatarCanvas.Children.Clear();
                this.avatarCanvas.Children.Add(avatarImage);

                this.AvatarLoaded = false;
            }

            // Display the avatar canvas now that it has something to show.
            this.avatarCanvas.Visibility = Visibility.Visible;
        }

        private void OnAvatarNotifyIncreaseQuota(object sender, EventArgs e)
        {
            // DO NOTHING AS OF NOW!
            DebugTextLogger.Log("SocialInfo::OnAvatarNotifyIncreaseQuota called");
        }

        /// <summary>
        /// This callback is triggered when we get a response from the UDS leaderboard service
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnGetLeaderboardCompleted(object sender, RewardsProxyEventArgs<LeaderboardResult> e)
        {
            DebugTextLogger.Log("SocialInfo::OnGetLeaderboardCompleted called");

            // Hide the busy indicator irrespective of error conditions
            busyProgressBar.IsBusy = false;

            if (e.Error == null)
            {
                // Hide the default image and details page but show the leaderboard player grid
                DefaultImagePanel.Visibility = Visibility.Collapsed;
                GridStatistics.Visibility = Visibility.Collapsed;
                GridPlayers.Visibility = Visibility.Visible;

                // Check whether we have some entries to display
                if ((e.Result != null) && (e.Result.Leaderboard != null) && (e.Result.Leaderboard.Count > 0))
                {
                    // Remember the leaderboard list since we're only retrieving it once per session
                    this.FriendList = e.Result.Leaderboard.ToList();

                    // Override the names if emtpy
                    foreach (LeaderboardItem item in this.FriendList)
                    {
                        // If a gamertag is present, use it by overwriting the WLID name when displaying it in the UI
                        if (!String.IsNullOrEmpty(item.User.GamerTag))
                        {
                            item.User.DisplayName = item.User.GamerTag;
                        }

                        // If the PictureUrl is not absolute, use the default fallback picture
                        Uri pictureUri;
                        if (!Uri.TryCreate(item.User.PictureUrl, UriKind.Absolute, out pictureUri))
                        {
                            item.User.PictureUrl = Page.FallbackGamerPic;
                        }
                    }

                    // Hook up the data pager to the friend list retrieved from the web service
                    this.FriendPCV = new PagedCollectionView(this.FriendList) { PageSize = CanvasPlayers.Children.Count };
                    this.FriendPCV.PageChanged += this.OnPageChanged;

                    // Find the the current player's index in the list
                    IEnumerable<LeaderboardItem> signedInUser = from item in this.FriendList
                                                                where (String.Compare(item.User.GamerTag, this.CurrentGamertag, StringComparison.OrdinalIgnoreCase) == 0)
                                                                select item;
                    if (signedInUser.Count() > 0)
                    {
                        // The friends list starts at rank 1; use it as the index into the list and display that page.
                        // Pages are 0-indexed. So for page size = n, entries 1...n are on page 1; n+1 ... 2n are on page 2, etc.
                        this.SignedInUserRank = signedInUser.First().Rank;
                        this.SignedInUserPageIndex = (int)(this.SignedInUserRank - 1) / this.FriendPCV.PageSize;

                        this.FriendPCV.MoveToPage(this.SignedInUserPageIndex);
                    }
                    else
                    {
                        this.SignedInUserPageIndex = -1;
                        this.FriendPCV.MoveToFirstPage();
                    }

                    // Updates the variant/property selector with the proper UI text for the selected variant and property.
                    this.RefreshLeaderboardSelector();

                    // Display the leaderboard
                    this.ShowCurrentLeaderboardItems();
                }
                else
                {
                    // Even though there are no entries in this leaderboard variant, we still display the selector
                    // in case there are other variants
                    this.RefreshLeaderboardSelector();

                    // Weird case: we got 0 entries in the leaderboard, default to our image
                    this.DisplayDefaultLoadingImage();
                    this.SetSubtitleText(GamePlayerAppResources.PlayFirst);
                }
            }
            else
            {
                busyProgressBar.IsBusy = false;
                this.ShowError(GamePlayerAppResources.GenericLeaderboardErrorTitle);
            }

            // NOTE: Good practice to uncouple the event handler when you're done
            ((IRewardsProxy)sender).OnGetLeaderboardCompleted -= this.OnGetLeaderboardCompleted;
        }

        /// <summary>
        /// If the user selects a different page, manually update the UI
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnPageChanged(object sender, EventArgs e)
        {
            this.ShowCurrentLeaderboardItems();
        }

        private void ShowError(string errorMsg)
        {
            // TODO: Refactor away from hard coded red text to allow for skinning.
            LeaderboardTitleSubText.Visibility = Visibility.Visible;
            LeaderboardTitleSubText.Foreground = new SolidColorBrush(Colors.Red);
            LeaderboardTitleSubText.Text = errorMsg;
        }

        private void SetSubtitleText(string text)
        {
            // TODO: Refactor away from hard coded red text to allow for skinning.
            LeaderboardTitleSubText.Visibility = Visibility.Visible;
            LeaderboardTitleSubText.Foreground = new SolidColorBrush(Colors.White);
            LeaderboardTitleSubText.Text = text;
        }

        /// <summary>
        /// This function will be called through the JS layer when a ScoreSubmit event is triggered
        /// </summary>
        /// <param name="sender">Parent object</param>
        /// <param name="e">GameEventArgs object</param>
        private void OnScoreSubmit(object sender, GameEventArgs e)
        {
            DebugTextLogger.Log("SocialInfo::glb_onScoreSubmit called");

            try
            {
                // Extract the score and time from the last game session
                XElement root = XElement.Parse(e.Parameter);

                uint xmlGameID = uint.Parse(root.Element("gameID").Value);
                uint xmlGameVariant = uint.Parse(root.Element("gameVariant").Value);

                // Simple security check that the gameID matches the one supplied in the URL
                if (xmlGameID == this.gameID)
                {
                    this.lastScore = long.Parse(root.Element("score").Value);
                    long lastTime = long.Parse(root.Element("time").Value);
                    if (this.lastScore >= 0 && lastTime > 0)
                    {
                        GameResult gameResult = new GameResult
                                                    {
                                                        GameResultId = Guid.NewGuid(),
                                                        GameId = xmlGameID,
                                                        Variant = xmlGameVariant,
                                                        Score = this.lastScore,
                                                        Time = lastTime,
                                                        TimeStamp = DateTime.Now
                                                    };

                        // Call the rewards services and submit our game result
                        DebugTextLogger.Log("SocialInfo::PostGameResultAsync called");

                        // Display the busy indicator
                        busyProgressBar.IsBusy = true;

                        this.rewardsProxy.OnPostGameResultCompleted += this.OnPostGameResultCompleted;
                        this.rewardsProxy.PostGameResultAsync(gameResult);
                    }
                    else
                    {
                        DebugTextLogger.Log("Blocked posting zero score and time to the rewards service");
                    }
                }
                else
                {
                    DebugTextLogger.Log("WARNING: GameID for the page and onScoreSubmit submission differ");
                }
            }
            catch
            {
                DebugTextLogger.Log("Error parsing the score submit information");
            }
        }

        /// <summary>
        /// Async event handler triggered when the PostGameResultAsync call is completed
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnPostGameResultCompleted(object sender, RewardsProxyEventArgs<string> e)
        {
            DebugTextLogger.Log("SocialInfo::OnPostGameResultCompleted called");

            // Hide the busy indicator irrespective of result
            busyProgressBar.IsBusy = false;

            // This event handler doesn't return any usable information to display. If posting the game result failed,
            // we don't inform the user and the user is not credited with the last score or time.
            // NOTE: This could annoy users when they do not see there achievements notification when we hit an error
            if (e.Error == null)
            {
                // Re-retrieve the friends' leaderboard for the current user with the new variant
                this.RefreshLeaderboard();
            }
            else
            {
                DebugTextLogger.Log(e.Error.ToString());
            }

            // NOTE: Good practice to uncouple the event handler when you're done
            ((IRewardsProxy)sender).OnPostGameResultCompleted -= this.OnPostGameResultCompleted;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\Global.asax.cs ===
//-------------------------------------------------------------------
// <copyright file="Global.asax.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC Service Global application
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    using System;
    using System.Web;
    using Leet.Core.BI;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.Providers;
    using Leet.Utils;
    using Leet.Live.Xblm;

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class Global : System.Web.HttpApplication
    {
        /// <summary>
        /// Component Name.
        /// </summary>
        public const string ComponentName = "PdlcService";

        /// <summary>
        /// The name used in the NPDB configuration. 
        /// </summary>
        private const string ServiceConfigName = "pdlc_service";

        /// <summary>
        /// Application OnStart event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();

            ConfigurationSelector.RegisterProvider(ServiceConfigName, "LEET");

            // register BI logging to log business intelligence data
            Container.Instance.AddService<IBILog, BILog>();

            // Register locale helper
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            // Register Partner token Auth
            Container.Instance.AddEmulatableService<IAudienceUriProvider, AudienceUriProvider>();
            Leet.Identity.PartnerAuth.AuthenticationManager.RegisterWithIocContainer(Container.Instance);

            // Register LiveCache Client.
            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize(ServiceConfigName);

            Container.Instance.AddEmulatableService<IXblmFastAccess, XblmFastAccess>();

            Logging.TraceInformation("{0}: {1}", ComponentName, "Service Application Started.");

            Logging.WriteEvent(new PdlcServiceStartupEvent());
        }

        /// <summary>
        /// Application OnEnd event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_End(object sender, EventArgs e)
        {
            Logging.WriteEvent(new PdlcServiceShutdownEvent());
        }

        /// <summary>
        /// Application BeginRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_BeginRequest(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            HttpContext.Current.Response.Headers["Cache-Control"] = "no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }

        /// <summary>
        /// Application error handler. 
        /// </summary>
        /// <param name="sender">Sender object. </param>
        /// <param name="e">The event arguments. </param>
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            Logging.TraceException(ex, ComponentName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\NGGamePlayer\SocialInfo\Converters\IndexKeyToStatisticValueConverter.cs ===
﻿namespace NGGamePlayer.Converters
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Windows.Data;
    using Gds.Contracts;

    /// <summary>
    /// This converter is used in the mini-profile display to show the best score, etc for a player
    /// </summary>
    public class IndexKeyToStatisticValueConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is IList<Entry>)
            {
                // Loop over the key value pairs
                IList<Entry> playerStats = value as IList<Entry>;
                foreach (Entry x in playerStats)
                {
                    if (String.Compare(x.Name, parameter.ToString(), StringComparison.InvariantCultureIgnoreCase) == 0)
                    {
                        // Makes the commas appear after converting to a number
                        return String.Format("{0:n0}", ulong.Parse(x.Value));
                    }
                }
            }

            // If we reach this point, we have encountered an error. Since we cannot handle exceptions in Converters,
            // we will just display an empty string
            return String.Empty;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\AudienceUriProvider.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="AudienceUriProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Audience Uri Provider for PDLC service
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/28/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    using System;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;

    /// <summary>
    /// Class which provides the session service Audience URI.
    /// </summary>
    public class AudienceUriProvider : IAudienceUriProvider
    {
        /// <summary>
        /// Gets the list of allowed Audience URIs for PDLC service.
        /// </summary>
        public string[] AudienceUriList
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return new string[] { configSettings.GetSetting(Settings.Pdlc_AudienceUri), configSettings.GetSetting(Settings.Pdlc_PurchaseAudienceUri) };
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\Properties\AssemblyInfo.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PdlcService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly:System.CLSCompliant(false)]
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("117a30dd-9c12-44c1-9e4e-a07d8f8ef4d0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\Asset.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Asset.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Asset representing consumables.
    /// </summary>
    [DataContract(Name = "Asset", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class Asset
    {
        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [DataMember(Name = "AssetId", Order = 1, IsRequired = true)]
        public uint AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [DataMember(Name = "Quantity", Order = 2, IsRequired = true)]
        public int Quantity { get; set; }
    }

   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\PdlcServiceHostFactory.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="PdlcServiceHostFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Pdlc service host factory for multiple HTTP binding support.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    using System;
    using Leet.Utils;
    using XboxLive.PDLC.Service.Contracts;

    /// <summary>
    /// Pdlc service host factory for multiple HTTP binding support.
    /// </summary>
    internal class AppServiceHostFactory : MultipleHTTPSecureBindingsServiceHostFactory<IPdlcService>
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\GamerContext.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GamerContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// GamerContext for enumerating offers from XBL marketplace catalog.
    /// </summary>
    [DataContract(Name = "GamerContext", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class GamerContext
    {
        /// <summary>
        /// Gets or sets the time when the context expires.
        /// </summary>
        [DataMember(Name = "Expires", Order = 1, IsRequired = true)]
        public DateTime Expires { get; set; }

        /// <summary>
        /// Gets or sets the XBL Marketplace Catalog URL. 
        /// </summary>
        [DataMember(Name = "XblMarketplaceCatalogUrl", Order = 2, IsRequired = true)]
        public string XblMarketplaceCatalogUrl { get; set; }

        /// <summary>
        /// Gets or sets the URL to Mobile Optimized page for adding points. 
        /// </summary>
        [DataMember(Name = "MOPageAddPointsUrl", Order = 3, IsRequired = true)]
        public string MOPageAddPointsUrl { get; set; }

        /// <summary>
        /// Gets or sets the URL to Mobile Optimized page for setting up account billing info.
        /// </summary>
        [DataMember(Name = "MOPageSetupBillingUrl", Order = 4, IsRequired = true)]
        public string MOPageSetupBillingUrl { get; set; }

        /// <summary>
        /// Gets or sets the URL to Mobile Optimized page for Terms Of Use (TOU).
        /// </summary>
        [DataMember(Name = "MOPageTouUrl", Order = 5, IsRequired = true)]
        public string MOPageTouUrl { get; set; }

        /// <summary>
        /// Gets or sets the legal locale of the user. 
        /// </summary>
        [DataMember(Name = "LegalLocale", Order = 6, IsRequired = true)]
        public string LegalLocale { get; set; }

        /// <summary>
        /// Gets or sets the UserType of the user. 
        /// </summary>
        [DataMember(Name = "UserType", Order = 7, IsRequired = true)]
        public int UserType { get; set; }

        /// <summary>
        /// Gets or sets the current balance of Microsoft Points.
        /// </summary>
        [DataMember(Name = "PointsBalance", Order = 8, IsRequired = true)]
        public uint PointsBalance { get; set; } 

        /// <summary>
        /// Gets or sets the AvatarBodyType of the user. 
        /// </summary>
        [DataMember(Name = "AvatarBodyType", Order = 9, IsRequired = false)]
        public int AvatarBodyType { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the gamer i spermitted to purchase PDLC.
        /// </summary>
        [DataMember(Name = "CanPurchasePDLC", Order = 10, IsRequired = false)]
        public bool CanPurchasePDLC { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the gamer's account is lightweight.
        /// </summary>
        [DataMember(Name = "IsLightweightAccount", Order = 11, IsRequired = false)]
        public bool IsLightweightAccount { get; set; }

        /// <summary>
        /// Gets or sets the avatar marketplace URL.
        /// </summary>
        [DataMember(Name = "AvatarMarketplaceUrl", Order = 12, IsRequired = false)]
        public string AvatarMarketplaceUrl { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\PdlcService.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="PdlcService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service internal implementation.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="11/02/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Globalization;
    using System.Linq;
    using System.Net;
    using System.ServiceModel.Activation;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Identity.PartnerAuth;
    using Leet.Live.Livecache.Account;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic;
    using Leet.Live.Livecache.Logic.Exceptions;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Utils;
    using Microsoft.ServiceModel.Web;
    using XboxLive.PDLC.Service.Contracts;
    using xonline.common.billing;
    using xonline.common.offer;
    using xonline.common.protocol;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;

    /// <summary>
    /// PDLC service internal implementation.
    /// </summary>
    public partial class PdlcService
    {
        /// <summary>
        /// Gets the life in hours of a GamerContext.
        /// </summary>
        public static int GamerContextExpiresInHours
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.Pdlc_GamerContextExpiresInHours);
            }
        }

        /// <summary>
        /// Gets the URL to XBL Marketplace Catalog. 
        /// </summary>
        public static string XblMarketplaceCatalogUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_XblMarketplaceCatalogUrl);
            }
        }

        /// <summary>
        /// Gets the URL to Avatar Marketplace Catalog. 
        /// </summary>
        public static string AvatarMarketplaceUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_AvatarMarketplaceUrl);
            }
        }

        /// <summary>
        /// Gets the URL to Mobile Optimized page for adding points. 
        /// </summary>
        public static string MOPageAddPointsUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_MOPageAddPointsUrl);
            }
        }

        /// <summary>
        /// Gets the URL to Mobile Optimized page for setting up billing info.
        /// </summary>
        public static string MOPageSetupBillingUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_MOPageSetupBillingUrl);
            }
        }

        /// <summary>
        /// Gets the URL to Mobile Optimized page for Terms Of Use.
        /// </summary>
        public static string MOPageTouUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_MOPageTouUrl);
            }
        }

        /// <summary>
        /// Gets the string listing all PDLC supported media type Ids: MUST be integers with two digits (zero padded left)
        /// </summary>
        public static string SupportedMediaTypeIds
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_SupportedMediaTypeIds);
            }
        }

        /// <summary>
        /// Gets the PurchaseAudienceURI string from LiveN NPDB
        /// </summary>
        public static string PurchaseAudienceUri
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.Pdlc_PurchaseAudienceUri);
            }
        }

        /// <summary>
        /// Get the legal locale of the specified user.
        /// </summary>
        /// <param name="xuid">XUID of the user to get legal locale for.</param>
        /// <returns>the legal locale string.</returns>
        private string ResolveUserAccountLocale(ulong xuid)
        {
            ILcAccountCreation accountCreation = Container.Instance.GetComponent<ILcAccountCreation>();

            XeGetAccountInfoRequest accountInfoRequest = new XeGetAccountInfoRequest { userPuid = xuid, machinePuid = 0 };
            XeGetAccountInfoResponse accountInfoResponse = accountCreation.GetAccountInfo(accountInfoRequest);

            string userLocale = string.Empty;
            XboxLiveLocaleHelper.TryGetSupportedLocale((ushort)accountInfoResponse.countryId, accountInfoResponse.languageId, out userLocale);

            return userLocale;
        }

        /// <summary>
        /// Get the legal locale of the specified user.
        /// </summary>
        /// <param name="xuid">XUID of the user.</param>
        /// <param name="emsUserType">EMS user type.</param>
        /// <param name="isLightAcct">boolean indicating whether the account is lightweight or not.</param>
        /// <param name="premiumContent">boolean indicating whether the account can purchase premium content or not.</param>
        private void GetUserAccountInfo(ulong xuid, out int emsUserType, out bool isLightAcct, out bool premiumContent)
        {
            uint[] privileges = null;
            byte parentalControlGroup;
            byte accountType;
            uint tier = 0;
            DateTime lastActivity;
            bool isProvisioned;
            bool isFreeGamertagChangeEligible;
            bool isParentallyControlled;

            IAccountCreationDataAccess accountCreationAccess = Container.Instance.GetComponent<IAccountCreationDataAccess>();
            accountCreationAccess.GetUserWebInfo(xuid, ServiceTypeEnum.XboxLive, out tier, out privileges, out lastActivity, out parentalControlGroup, out isLightAcct, out isProvisioned, out accountType, out isFreeGamertagChangeEligible, out isParentallyControlled);

            premiumContent = false;
            if (LivePrivilegeSet.Test(privileges, (int)XOn.XPRIVILEGE_PURCHASE_CONTENT))
            {
                premiumContent = true;
            }

            // Convert user tier to EMS user type: logic from xonline's private\common\marketplace\user\User.cs
            if ((tier == (uint)TierEnum.Gold) || (tier == (uint)TierEnum.FamilyGold))
            {
                emsUserType = (int)CatalogUserTypeEnum.XboxLiveGoldUser;
            }
            else
            {
                // default to silver so that the calling gamer can at least browse XBL Marketplace catalog (open to public)
                emsUserType = (int)CatalogUserTypeEnum.XboxLiveSilverUser;
            }
        }

        /// <summary>
        /// Get a PDLC context for browsing/purchasing XBL marketplace catatlog items.
        /// </summary>
        /// <param name="identity">identity of the user.</param>
        /// <returns>GamerContext of the calling gamer.</returns>
        private GamerContext GetContextInternal(PartnerIdentity identity)
        {
            GamerContext context = new GamerContext();

            try
            {
                // Get the URLs from Liven NPDB
                context.XblMarketplaceCatalogUrl = PdlcService.XblMarketplaceCatalogUrl;
                context.MOPageAddPointsUrl = PdlcService.MOPageAddPointsUrl;
                context.MOPageSetupBillingUrl = PdlcService.MOPageSetupBillingUrl;
                context.MOPageTouUrl = PdlcService.MOPageTouUrl;
                context.AvatarMarketplaceUrl = PdlcService.AvatarMarketplaceUrl;

                // Find the legal locale of the gamer (TBD: Do we return empty for unsupported legal locales?)
                context.LegalLocale = this.ResolveUserAccountLocale(identity.Xuid);
                if (string.IsNullOrEmpty(context.LegalLocale))
                {
                    throw new WebProtocolException(
                        HttpStatusCode.InternalServerError,
                        null,
                        new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_LEGAL_LOCALE_NOT_SUPPORTED, "CountryID and LanguageID not supported"),
                        null);
                }

                // Get user and account type
                int emsUserType;
                bool isLightAcct;
                bool premiumContent;
                this.GetUserAccountInfo(identity.Xuid, out emsUserType, out isLightAcct, out premiumContent);
                context.UserType = emsUserType;
                context.IsLightweightAccount = isLightAcct;
                context.CanPurchasePDLC = premiumContent;

                // Get Avatar body type
                ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
                IGamerProfile profile = settingsDataAccess.GetGamerProfile(identity.Xuid, identity.Xuid);
                context.AvatarBodyType = (int)profile.AvatarBodyType;

                // Get points balance
                IBillingOfferingDataAccess bo = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
                context.PointsBalance = bo.GetPointsBalance(identity.Xuid);

                // Set up time to live
                context.Expires = DateTime.UtcNow.AddHours(GamerContextExpiresInHours);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (ConfigurationErrorsException ex)
            {
                Logging.TraceException(ex, "Exception caught when calling Liven NPDB config settings for GetContext.");

                // log a system event to notify operations
                Logging.WriteEvent(
                    new LivenNpdbExceptionEvent(),
                    ex,
                    "LivenNpdbExceptionEvent happened for (xuid={0})",
                    identity.Xuid);

                // Send error message to client
                throw new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_LIVEN_NPDB_EXCEPTION, "Exception when getting settings from LiveN NPDB."),
                    Ex.IncludeExceptionDetailInErrorMessage ? ex : null);
            }
            catch (Exception ex)
            {
                Ex.HandleLiveCacheException("GetContext", identity.Xuid, ex);
            }

            return context;
        }

        /// <summary>
        /// Get the PointsBalance for the current user.
        /// </summary>
        /// <param name="identity">identity of the user.</param>
        /// <returns>Current Points Balance.</returns>
        private uint GetPointsBalanceInternal(PartnerIdentity identity)
        {
            uint pointsBalance = 0;
            try
            {
                // Get points balance
                IBillingOfferingDataAccess bo = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
                pointsBalance = bo.GetPointsBalance(identity.Xuid);
            }
            catch (Exception ex)
            {
                Ex.HandleLiveCacheException("GetPointsBalance", identity.Xuid, ex);
            }

            return pointsBalance;
        }

        /// <summary>
        /// Purchase an offer from XBL marketplace catalog.
        /// </summary>
        /// <param name="identity">identity of the user.</param>
        /// <param name="request">The purchase request including purchase details.</param>
        /// <returns>The receipt for the purcahsed item.</returns>
        private PurchaseReceipt PurchaseInternal(PartnerIdentity identity, PurchaseRequest request)
        {
            PurchaseReceipt receipt = null;

            try
            {
                HResult hr = HResult.S_OK;
                IBillingOfferingDataAccess bo = Container.Instance.GetComponent<IBillingOfferingDataAccess>();

                // 1. Submit the purchase request to XBL marketplace
                if (request.PaymentType == (uint)PaymentTypeEnum.Points)
                {
                    hr = bo.PurchaseMediaOfferWithPoints(identity.Xuid, request.OfferId, request.PointsPrice, request.MediaTypeId, request.StoreId, request.TransactionId);
                }
                else if (request.PaymentType == (uint)PaymentTypeEnum.Token)
                {
                    // For token payment type, we need to check if the offer is a points bundle.
                    hr = bo.PurchaseMediaOfferWithToken(identity.Xuid, request.OfferId, request.PointsPrice, request.MediaTypeId, request.StoreId, request.BillingToken, request.TransactionId);
                }

                if (HResult.Succeeded(hr) == false)
                {
                    switch (hr)
                    {
                        // offer errors to be handled by client
                        case HResult.XONLINE_E_OFFERING_INVALID_OFFER_ID:
                        case HResult.XOFF_E_OFFER_EXPIRED:
                        case HResult.XONLINE_E_GEO_DENIED:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "Invalid offerId:" + request.OfferId + ", or User cannot purchase offer due to geofencing."),
                                null);

                        // Token errors to be handled by client
                        case HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED:
                        case HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE:
                        case HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "Invalid token."),
                                null);

                        // Offer has been purchased already or reached maximum allowed
                        case HResult.XONLINE_E_OFFERING_ALREADY_OWN_MAX:
                        case HResult.XONLINE_E_OFFERING_LICENSE_AVAILABLE:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "Offer already purchased or reached maximum allowed."),
                                null);

                        // There is not sufficient points balance to support this transaction
                        case HResult.XONLINE_E_DMP_E_INSUFFICIENT_BALANCE:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "Insufficient Microsoft Points balance for the purchase."),
                                null);

                        // Input price does not match the offer price
                        case HResult.XONLINE_E_OFFERING_PRICE_CHANGED:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "Input price does not match the offer price."),
                                null);

                        // The user has a pending purchase transaction already.  Please wait and try again later.
                        case HResult.XONLINE_E_PURCHASE_PENDING:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "The user has a pending purchase transaction already.  Please wait and try again later."),
                                null);

                        // The transcation GUID has been used by a different request.
                        case HResult.XONLINE_E_TRACKED_API_DUPLICATE_TRACKING_GUID:
                            throw new WebProtocolException(
                                HttpStatusCode.BadRequest,
                                null,
                                new PdlcServiceErrorMessage(hr, "Transaction id has already been used by a different request. Please try again with a new GUID."),
                                null);

                        default:
                        {
                            // Internal server errors
                            Logging.TraceError(
                                "LiveCache Purchase call failed: hr={0}, for offer={1}, mediatype={2}, store={3}, xuid={4}",
                                hr,
                                request.OfferId,
                                request.MediaTypeId,
                                request.StoreId,
                                identity.Xuid);

                            Logging.WriteEvent(
                                new PdlcServiceUnknownErrorEvent(), 
                                "LiveCache Purchase call failed: hr={0}, for offer={1}, mediatype={2}, store={3}, xuid={4}",
                                hr,
                                request.OfferId,
                                request.MediaTypeId,
                                request.StoreId,
                                identity.Xuid);

                            throw new WebProtocolException(
                                HttpStatusCode.InternalServerError,
                                null,
                                new PdlcServiceErrorMessage(hr, "Failed to purchase offer:" + request.OfferId),
                                null);
                        }
                    }
                }

                // Purchase media offer succeeded: Try to create a purchase receipt.
                uint titleId = uint.Parse(identity.TitleId, NumberStyles.HexNumber, CultureInfo.InvariantCulture); // We've already validated title Id in Partner token
                try
                {
                    // 2. Get the purchase history for this transaction
                    string locale = this.ResolveUserAccountLocale(identity.Xuid);
                    PurchaseHistoryRequest historyRequest = PurchaseHistoryRequest.CreatePurchaseHistoryRequest(
                        identity.Xuid,
                        locale,
                        0, //pass titleId as 0 since we have the transaction id and all we need is receipt for that transaction Id
                        (MediaTypes)request.MediaTypeId,
                        DateTime.MinValue.ToUniversalTime(),
                        request.TransactionId,
                        request.StoreId,
                        1, 
                        1,
                        PurchaseHistoryRequest.OrderDirection.Ascending);

                    PurchaseHistoryResponse historyResponse = bo.GetPurchaseHistory(historyRequest);
                    if ((historyResponse != null) &&
                        (historyResponse.PurchaseHistoryEntries != null) &&
                        (historyResponse.PurchaseHistoryEntries.Count != 0))
                    {
                        IList<string> downloadUrlList = null;
                        XboxLive.PDLC.Service.Contracts.Asset assetBalance = null;
                        PurchaseHistoryEntry entry = historyResponse.PurchaseHistoryEntries[0];

                        // 3. Get media instance URLs for the purchased item
                        if ((entry.MediaInstances != null) && (entry.MediaInstances.Count != 0))
                        {
                            // do a batch query for MediaInstanceUrl
                            var mediaInstanceIds = entry.MediaInstances.Select(i => i.InstanceId).ToArray();
                            try
                            {
                                downloadUrlList = bo.GetMediaInstanceUrls(mediaInstanceIds)
                                    .Where(miu => (miu.urls != null) && (miu.urls.Count() != 0))
                                    .Select(miu => miu.urls[0].url).ToList();
                            }
                            catch (ArgumentNullException)
                            {
                                // malformed offer: log a warning and continue with empty MediaInstances
                                Logging.TraceWarning("ArgumentNullException caught when retrieving MediaInstanceUrls for offer:{0}", request.OfferId);
                            }
                        }

                        // 4. call EnumerateAsset to get current balance for the purchased asset
                        if (request.MediaTypeId == (int)MediaTypes.MobileConsumable)
                        {
                            EnumerateAssetsRequest assetsRequest = new EnumerateAssetsRequest
                            {
                                Locale = locale,
                                TitleId = titleId,
                                Xuid = identity.Xuid
                            };

                            EnumerateAssetsResponse assetsResponse = bo.EnumerateAssets(assetsRequest);
                            if (assetsResponse.Assets != null)
                            {
                                EnumerateAssetsResponse.Asset asset = assetsResponse.Assets.FirstOrDefault(a => a.AssetId == request.AssetId);
                                if (asset != null)
                                {
                                    assetBalance = new XboxLive.PDLC.Service.Contracts.Asset
                                    {
                                        AssetId = asset.AssetId,
                                        Quantity = asset.Quantity
                                    };
                                }
                            }
                        }

                        // 5. Create a receipt for this purchase
                        receipt = new PurchaseReceipt()
                        {
                            OfferId = entry.OfferId,
                            PurchaseDate = entry.TheOffer.PurchaseDate.ToUniversalTime(),
                            Title = entry.Title,
                            TransactionId = request.TransactionId,
                            PurchasingPartnerId = identity.Xuid,
                            MediaInstanceURLs = downloadUrlList,
                            AssetBalance = assetBalance
                        };
                    }
                    else
                    {
                        // No purchase history for current purchase transaction
                        throw new WebProtocolException(
                                HttpStatusCode.InternalServerError,
                                null,
                                new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_NO_PURCHASE_ENTRY_FOR_TRANSACTION, "No purchase history found for transaction:" + request.TransactionId),
                                null);
                    }
                }
                catch (LivecacheResponseException ex)
                {
                    // Log an error for livecache exception
                    Logging.TraceException(ex, "Livecache call hit an exception, hr = {0}", ex.HResult);

                    // log a system event to notify operations
                    Logging.WriteEvent(
                        new LiveServiceResponseErrorEvent(),
                        ex,
                        "LivecacheResponseException happened for (xuid={0}, titleId = {1}, offerid = {2}, transactionId = {3})",
                        identity.Xuid,
                        titleId,
                        request.OfferId,
                        request.TransactionId);

                    // Send error message to client
                    throw new WebProtocolException(
                        HttpStatusCode.InternalServerError,
                        null,
                        new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_PURCHASE_SUCCEEDED_RECEIPT_UNAVAILABLE, "Purchase succeeded but failed to create a receipt."),
                        Ex.IncludeExceptionDetailInErrorMessage ? ex : null);
                }
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (ConfigurationErrorsException ex)
            {
                Logging.TraceException(ex, "Exception caught when calling Liven NPDB config settings for Purchase.");

                // log a system event to notify operations
                Logging.WriteEvent(
                    new LivenNpdbExceptionEvent(),
                    ex,
                    "LivenNpdbExceptionEvent happened for (xuid={0})",
                    identity.Xuid);

                // Send error message to client
                throw new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_LIVEN_NPDB_EXCEPTION, "Exception when getting settings from LiveN NPDB."),
                    Ex.IncludeExceptionDetailInErrorMessage ? ex : null);
            }
            catch (Exception ex)
            {
                Ex.HandleLiveCacheException("Purchase", identity.Xuid, ex);
            }

            return receipt;
        }

        /// <summary>
        /// Get the offer info behind a 5x5 token.
        /// </summary>
        /// <param name="identity">identity of the user.</param>
        /// <param name="billingToken">The 5x5 token string.</param>
        /// <param name="storeId">The store id for which the token is issued.</param>
        /// <returns>The offer info behind the token.</returns>
        private TokenOffer VerifyTokenInternal(PartnerIdentity identity, string billingToken, uint storeId)
        {
            TokenOffer tokenOffer = null;
            try
            {
                HResult hr = HResult.S_OK;
                ushort offerCatalogType;
                Guid emsOfferId;
                Guid mediaId;
                uint mediaType;
                ulong xboxOfferId;
                uint xboxOfferType;
                IBillingOfferingDataAccess bo = Container.Instance.GetComponent<IBillingOfferingDataAccess>();

                hr = bo.VerifyToken(identity.Xuid, billingToken, storeId, out offerCatalogType, out emsOfferId, out mediaId, out mediaType, out xboxOfferId, out xboxOfferType);
                if (HResult.Succeeded(hr) == false)
                {
                    if ((hr == HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED) || 
                        (hr == HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE) ||
                        (hr == HResult.XOFF_E_OFFER_EXPIRED) ||
                        (hr == HResult.XONLINE_E_OFFERING_INVALID_OFFER_ID) ||
                        (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER))
                    {
                        throw new WebProtocolException(
                            HttpStatusCode.BadRequest,
                            null,
                            new PdlcServiceErrorMessage(hr, "Token invalid, used, expired or not avaible at this time or region."),
                            null);
                    }
                    else
                    {
                        Logging.TraceError("LiveCache VerifyToken() call failed: hr={0}, for store={1}, xuid={2}", hr, storeId, identity.Xuid);

                        throw new WebProtocolException(
                            HttpStatusCode.InternalServerError,
                            null,
                            new PdlcServiceErrorMessage(hr, "VerifyToken() failed."),
                            null);
                    }
                }

                if (offerCatalogType == (ushort)OfferCatalogTypeEnum.Ems)
                {
                    tokenOffer = new TokenOffer
                    {
                        EmsOffer = new EmsOfferInfo { MediaId = mediaId, MediaType = (int)mediaType, OfferId = emsOfferId },
                    };
                }
                else if (offerCatalogType == (ushort)OfferCatalogTypeEnum.Xbox)
                {
                    tokenOffer = new TokenOffer
                    {
                        XboxOffer = new XboxOfferInfo { OfferId = xboxOfferId, OfferTypeId = (int)xboxOfferType },
                    };
                }
                else
                {
                    // Unknown offer catalog type: This shouldn't happen
                    Logging.TraceWarning("LiveCache VerifyToken() returned unknown offerCatalogType: {0}", offerCatalogType);

                    Logging.WriteEvent(new PdlcServiceUnknownErrorEvent(), "LiveCache VerifyToken() returned unknown offerCatalogType: {0}", offerCatalogType);

                    throw new WebProtocolException(
                            HttpStatusCode.InternalServerError,
                            null,
                            new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_UNSPECIFIED_ERROR, "Unknown offer catalog type."),
                            null);
                }
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Ex.HandleLiveCacheException("VerifyToken", identity.Xuid, ex);
            }

            return tokenOffer;
        }

        /// <summary>
        /// Consume the specified Assets.
        /// </summary>
        /// <param name="identity">identity of the user.</param>
        /// <param name="request">The request body contains transactionId, the list of assets and quantity to consume.</param>
        private void ConsumeAssetsInternal(PartnerIdentity identity, ConsumeRequest request)
        {
            try
            {
                HResult hr = HResult.S_OK;
                IBillingOfferingDataAccess bo = Container.Instance.GetComponent<IBillingOfferingDataAccess>();

                xonline.common.protocol.Asset[] assets = request.AssetsToConsume.Select(
                    a => new xonline.common.protocol.Asset
                    {
                        assetID = a.AssetId,
                        quantity = (int)a.Quantity,
                    }).ToArray();

                bo.AssetConsume(identity.Xuid, request.TitleId, request.TransactionId, assets);
            }
            catch (LivecacheResponseException ex)
            {
                if (ex.HResult == HResult.XONLINE_E_OFFERING_INVALID_CONSUME_ITEMS)
                {
                    throw new WebProtocolException(
                        HttpStatusCode.BadRequest,
                        null,
                        new PdlcServiceErrorMessage(ex.HResult, "At least one asset to consume is invalid."),
                        null);
                }
                else if (ex.HResult == HResult.XONLINE_E_TRACKED_API_DUPLICATE_TRACKING_GUID)
                {
                    throw new WebProtocolException(
                        HttpStatusCode.BadRequest,
                        null,
                        new PdlcServiceErrorMessage(ex.HResult, "Transaction id has already been used by a different request. Please try again with a new GUID."),
                        null);
                }
                else
                {
                    Logging.TraceError("LiveCache AssetConsume() call failed: hr={0}, for titleId={1}, transactionId={2}, xuid={3}", ex.HResult, request.TitleId, request.TransactionId, identity.Xuid);

                    Logging.WriteEvent(new LiveServiceResponseErrorEvent(), ex);

                    throw new WebProtocolException(
                        HttpStatusCode.InternalServerError,
                        null,
                        new PdlcServiceErrorMessage(ex.HResult, "ConsumeAssets() failed."),
                        null);
                }
            }
            catch (Exception ex)
            {
                Ex.HandleLiveCacheException("ConsumeAssets", identity.Xuid, ex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService\Pdlc.svc.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Pdlc.svc.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Text;
    using System.Web;
    using System.Xml;
    using Leet.Core.BI;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Identity.PartnerAuth;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Exceptions;
    using Microsoft.ServiceModel.Web;
    using XboxLive.PDLC.Service.Contracts;
    
    /// <summary>
    /// PDLC service class implementing IPdlcService service contract.
    /// </summary>
    [ServiceBehavior(IncludeExceptionDetailInFaults = false, InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple),
    AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class PdlcService : IPdlcService
    {
        /// <summary>
        /// Initializes a new instance of the PdlcService class.
        /// </summary>
        public PdlcService()
        {
        }

        /// <summary>
        /// Get a PDLC context for browsing/purchasing XBL marketplace catatlog items.
        /// </summary>
        /// <returns>GamerContext of the calling gamer.</returns>
        public GamerContext GetContext()
        {
            GamerContext context = null;
            try
            {
                // check common request headers
                this.ValidateCommonHeaders();

                // Get caller identity
                PartnerIdentity identity = this.GetPartnerIdentity();

                // Log BI data
                this.LogBIData(identity, "GetContext", string.Empty);

                // Get the context for the gamer
                context = this.GetContextInternal(identity);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Ex.HandleException("GetContext", ex);
            }

            return context;
        }

        /// <summary>
        /// Get the PointsBalance for the current user.
        /// </summary>
        /// <returns>Current Points Balance.</returns>
        public uint GetPointsBalance()
        {
            uint pointsBalance = 0;

            try
            {
                // check common request headers
                this.ValidateCommonHeaders();

                // Get caller identity
                PartnerIdentity identity = this.GetPartnerIdentity();

                // Log BI data
                this.LogBIData(identity, "GetPointsBalance", string.Empty);

                // Get the points balance for the gamer
                pointsBalance = GetPointsBalanceInternal(identity);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Ex.HandleException("GetPointsBalance", ex);
            }

            return pointsBalance;
        }

        /// <summary>
        /// Purchase an offer from XBL marketplace catalog.
        /// </summary>
        /// <param name="request">The purchase request including purchase details.</param>
        /// <returns>The receipt for the purcahsed item.</returns>
        public PurchaseReceipt Purchase(PurchaseRequest request)
        {
            PurchaseReceipt receipt = null;
            try
            {
                // check common request headers
                this.ValidateCommonHeaders();

                // Get caller identity
                PartnerIdentity identity = this.GetPartnerIdentity();

                // Verify that AudienceUri in the auth token is targeted for Purchase
                IList<Uri> audienceUris;
                if (TokenClaimsHelper.TryGetAudienceUris(out audienceUris))
                {
                    string audienceUriFromToken = audienceUris[0].AbsoluteUri;
                    if (string.Compare(audienceUriFromToken, PurchaseAudienceUri, StringComparison.InvariantCultureIgnoreCase) != 0)
                    {
                        RejectInput("Authentication Token is not for purchase: AudienceUri=" + audienceUriFromToken);
                    }
                }
                else
                {
                    RejectInput("Authentication Token does not have an audience Uri.");
                }

                // Validate client input.
                if (request == null)
                {
                    RejectInput("PurchaseRequest is null.");
                }

                // check if TransactionId is missing
                if (request.TransactionId == Guid.Empty)
                {
                    RejectInput("The TransactionId is missing or empty.");
                }

                // check if OfferId is missing
                if (request.OfferId == Guid.Empty)
                {
                    RejectInput("The OfferId is missing or empty.");
                }

                // check if mediaTypeId is valid & supported
                if (Enum.IsDefined(typeof(MediaTypes), request.MediaTypeId) == false)
                {
                    RejectInput("The MediaTypeId is invalid.");
                }

                if (SupportedMediaTypeIds.IndexOf(request.MediaTypeId.ToString("D2", CultureInfo.InvariantCulture), StringComparison.OrdinalIgnoreCase) == -1)
                {
                    RejectInput("The MediaTypeId is not supported.");
                }

                // Check if asset id is present for Mobile Consumable
                if ((request.MediaTypeId == (int)MediaTypes.MobileConsumable) && (request.AssetId == 0))
                {
                    RejectInput("The AssetId cannot be 0 if MediaTypeId is MobileConsumable.");
                }

                // Check if asset id is present for other media types
                if ((request.MediaTypeId != (int)MediaTypes.MobileConsumable) && (request.AssetId != 0))
                {
                    RejectInput("The AssetId should not be passed in if MediaTypeId is not MobileConsumable.");
                }

                // check if PaymentType is valid
                if ((request.PaymentType != (uint)xonline.common.offer.PaymentTypeEnum.Points) &&
                    (request.PaymentType != (uint)xonline.common.offer.PaymentTypeEnum.Token))
                {
                    RejectInput("The PaymentType must be either Points (4) or Token (2).");
                }

                // check if 5x5 token string is provided for PaymentType of Token: reject if not present
                if ((request.PaymentType == (uint)xonline.common.offer.PaymentTypeEnum.Token) &&
                    (string.IsNullOrEmpty(request.BillingToken) == true))
                {
                    RejectInput("The BillingToken is missing for payment type of Token.");
                }

                // check if 5x5 token string is provided for PaymentType of Points: reject if present
                if ((request.PaymentType == (uint)xonline.common.offer.PaymentTypeEnum.Points) &&
                    (string.IsNullOrEmpty(request.BillingToken) == false))
                {
                    RejectInput("The BillingToken is present for payment type of Points.");
                }

                if ((request.StoreId != (uint)PurchaseHistoryRequest.MarketplaceStore.Mobile) &&
                    (request.StoreId != (uint)PurchaseHistoryRequest.MarketplaceStore.Xbox))
                {
                    RejectInput("The store id is not supported:" + request.StoreId);
                }

                // Log BI data
                this.LogBIData(identity, "Purchase", request.OfferId.ToString());

                // Call internal helper to do the purchase
                receipt = PurchaseInternal(identity, request);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Ex.HandleException("Purchase", ex);
            }

            return receipt;
        }

        /// <summary>
        /// Get the offer behind a 5x5 token.
        /// </summary>
        /// <param name="billingToken">The 5x5 token string.</param>
        /// <param name="storeId">The store id for which the token is issued.</param>
        /// <returns>The offer info behind the token.</returns>
        public TokenOffer VerifyToken(string billingToken, uint storeId)
        {
            TokenOffer tokenOffer = null;
            try
            {
                // check common request headers
                this.ValidateCommonHeaders();

                // Get caller identity
                PartnerIdentity identity = this.GetPartnerIdentity();

                // Validate client input.
                if (string.IsNullOrEmpty(billingToken))
                {
                    RejectInput("billingToken is null or empty.");
                }

                if ((storeId != (uint)PurchaseHistoryRequest.MarketplaceStore.Mobile) &&
                    (storeId != (uint)PurchaseHistoryRequest.MarketplaceStore.Xbox))
                {
                    RejectInput("The store id is not supported:" + storeId);
                }

                // Log BI data
                this.LogBIData(identity, "VerifyToken", string.Empty);

                // call internal helper to verify the token
                tokenOffer = VerifyTokenInternal(identity, billingToken, storeId);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Ex.HandleException("VerifyToken", ex);
            }

            return tokenOffer;
        }

        /// <summary>
        /// Get the receipts Purchases.
        /// </summary>
        /// <param name="request">The request specifying title id and filtering for receipts to return.</param>
        /// <returns>PurchaseReceipts Serialized to String using the DataContract Serializer. If ReceiptRequest.SignReceipts is true then includes the W3C enveloped xml signature</returns>
        public XmlElement GetReceipts(ReceiptRequest request)
        {
            // verify identity and get the identity object
            PartnerIdentity identity = this.GetPartnerIdentity();
            this.ValidateCommonHeaders();

            // Verify that the auth token carries a titleId and it is in the right hex format
            uint tokenTitleId;
            if (!TokenClaimsHelper.TryGetTokenTitleID(out tokenTitleId))
            {
                RejectInput(HttpStatusCode.Unauthorized, "Authentication Token does not have a title Id", PdlcErrors.PDLC_E_TITLE_ID_MISSING_IN_PARTNER_TOKEN);
            }

            // Verify request parameters
            if (request == null)
            {
                RejectInput("ReceiptRequest cannot be null");
            }

            // request titleid must match the authentication token titleid
            if (request.TitleId != tokenTitleId)
            {
                RejectInput("ReceiptRequest.Titleid does not match titleid in the authentication token");
            }

            //check for negative values
            if (request.MediaTypeId < 0)
            {
                RejectInput("The MediaTypeId is invalid.", PdlcErrors.PDLC_E_INVALID_PARAMETER);
            }

            // If MediaTypeId is 0 then we are ok. This is not a required parameter. We will default later on to valid values
            if (request.MediaTypeId > 0)
            {
                // If mediaTypeId greater than 0 then check if it is valid & supported
                if (Enum.IsDefined(typeof(MediaTypes), request.MediaTypeId) == false)
                {
                    RejectInput("The MediaTypeId is invalid.", PdlcErrors.PDLC_E_INVALID_PARAMETER);
                }

                if (SupportedMediaTypeIds.IndexOf(request.MediaTypeId.ToString("D2", CultureInfo.InvariantCulture), StringComparison.OrdinalIgnoreCase) == -1)
                {
                    RejectInput("The MediaTypeId is not supported.");
                }
            }

            // Log BI data
            this.LogBIData(identity, "GetReceipts", string.Empty);

            // call live cache to get the recipts
            XmlDocument receiptsResponse = null;
            try
            {
                receiptsResponse = ReceiptsHelper.GetPurchaseReceipts(request, identity.LivePuid, ResolveUserAccountLocale(identity.LivePuid), identity.PartnerID);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (LeetLivecacheConfigException ex)
            {
                Ex.HandleException("GetReceipts", PdlcErrors.PDLC_E_XBL_SERVICE_UNAVAILABLE, new LiveServiceConfigErrorEvent(), ex);
            }
            catch (LeetLivecacheResponseException ex)
            {
                Ex.HandleException("GetReceipts", PdlcErrors.PDLC_E_XBL_SERVICE_UNAVAILABLE, new LiveServiceResponseErrorEvent(), ex);
            }
            catch (Exception ex)
            {
                Ex.HandleException("GetReceipts", ex);
            }

            Debug.Assert(receiptsResponse != null, "XmlDocument receiptsResponse must not be null to return its DocumentElement.");
            return receiptsResponse.DocumentElement;
        }

        /// <summary>
        /// Get the assets owned by the gamer.
        /// </summary>
        /// <param name="titleId">The title ID the Assets belong to.</param>
        /// <param name="signAssets">Boolean indicating whether to sign the returned assets.</param>
        /// <returns>A string contains a list of Assets if unsigned, or SAML formated list of Assets with signature.</returns>
        public XmlElement GetAssets(uint titleId, bool signAssets)
        {
            // verify identity and get the identity object
            PartnerIdentity identity = this.GetPartnerIdentity();
            this.ValidateCommonHeaders();

            // Verify that the auth token carries a titleId and it is in the right hex format
            uint tokenTitleId;
            if (!TokenClaimsHelper.TryGetTokenTitleID(out tokenTitleId))
            {
                RejectInput(HttpStatusCode.Unauthorized, "Authentication Token does not have a title Id", PdlcErrors.PDLC_E_TITLE_ID_MISSING_IN_PARTNER_TOKEN);
            }

            // request titleid must match the authentication token titleid
            if (titleId != tokenTitleId)
            {
                RejectInput("title id sent in the request does not match title id in the authentication token");
            }

            // Log BI data
            this.LogBIData(identity, "GetAssets", string.Empty);

            // call live cache to get the assets
            XmlDocument assetsResponse = null;
            try
            {
                assetsResponse = 
                    GetAssetsHelper.GetAssets(titleId, identity.LivePuid, ResolveUserAccountLocale(identity.LivePuid), signAssets);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (LeetLivecacheConfigException ex)
            {
                Ex.HandleException("GetAssets", PdlcErrors.PDLC_E_XBL_SERVICE_UNAVAILABLE, new LiveServiceConfigErrorEvent(), ex);
            }
            catch (LeetLivecacheResponseException ex)
            {
                Ex.HandleException("GetAssets", PdlcErrors.PDLC_E_XBL_SERVICE_UNAVAILABLE, new LiveServiceResponseErrorEvent(), ex);
            }
            catch (Exception ex)
            {
                Ex.HandleException("GetAssets", ex);
            }

            Debug.Assert(assetsResponse != null, "XmlDocument, assetsResponse, cannot be null.");
            return assetsResponse.DocumentElement;
        }

        /// <summary>
        /// Consume the specified Assets.
        /// </summary>
        /// <param name="request">The request body contains transactionId, the list of assets and quantity to consume.</param>
        public void ConsumeAssets(ConsumeRequest request)
        {
            try
            {
                // check common request headers
                this.ValidateCommonHeaders();

                // Get caller identity
                PartnerIdentity identity = this.GetPartnerIdentity();

                // Validate client input.
                if (request == null)
                {
                    RejectInput("ConsumeRequest is null.");
                }

                // check if TransactionId is missing
                if (request.TransactionId == Guid.Empty)
                {
                    RejectInput("The TransactionId is missing or empty.");
                }

                // check if TitleId is missing
                if (request.TitleId == 0)
                {
                    RejectInput("The title Id is zero or missing.");
                }

                // check if TitleId matches the one in partner token
                uint titleId = uint.Parse(identity.TitleId, NumberStyles.HexNumber, CultureInfo.InvariantCulture); // We've already validated title Id in Partner token
                if (request.TitleId != titleId)
                {
                    RejectInput("title id sent in the request does not match title id in the authentication token");
                }

                // check if AssetsToConsume is missing or empty
                if ((request.AssetsToConsume == null) || (request.AssetsToConsume.Length == 0))
                {
                    RejectInput("The assets to consume is missing or empty.");
                }

                // Log BI data
                this.LogBIData(identity, "ConsumeAssets", string.Empty);

                // call internal helper to consume assets
                ConsumeAssetsInternal(identity, request);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Ex.HandleException("ConsumeAssets", ex);
            }
        }
    
        /// <summary>
        /// A helper method to throw bad request exception. 
        /// </summary>
        /// <param name="msg">The reason of the reject. </param>
        private static void RejectInput(string msg)
        {
            RejectInput(HttpStatusCode.BadRequest, msg, PdlcErrors.PDLC_E_INVALID_PARAMETER);
        }

        /// <summary>
        /// A helper method to throw bad request exception. 
        /// </summary>
        /// <param name="msg">The reason of the reject. </param>
        /// <param name="livenErrorCode">The Error Code. </param>
        private static void RejectInput(string msg, uint livenErrorCode)
        {
            RejectInput(HttpStatusCode.BadRequest, msg, livenErrorCode);
        }

        /// <summary>
        /// A helper method to throw specific WebProtocolExceptions. 
        /// </summary>
        /// <param name="httpStatusCode">The HTTP response code to return. </param>
        /// <param name="msg">The reason of the reject. </param>
        /// <param name="livenErrorCode">The error code. </param>
        private static void RejectInput(HttpStatusCode httpStatusCode, string msg, uint livenErrorCode)
        {
            throw new WebProtocolException(
                httpStatusCode,
                msg,
                new PdlcServiceErrorMessage(livenErrorCode, msg),
                null);
        }

        /// <summary>
        /// Gets the PartnerIdentity for the current user.
        /// </summary>
        /// <returns>The PartnerIdentity for the current user. </returns>
        private PartnerIdentity GetPartnerIdentity()
        {
            // Check if the user is authenticated.
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();
            if (!authManager.IsAuthenticated)
            {
                throw new WebProtocolException(
                    HttpStatusCode.Unauthorized,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_USER_NOT_AUTHENTICATED, "User not authenticated"),
                    null);
            }

            // Get the User Identity Object which should be a PartnerIdentity object
            IUserIdentity callerIdentity = authManager.CurrentUser;
            PartnerIdentity partnerIdentity = callerIdentity as PartnerIdentity;

            if (callerIdentity == null)
            {
                throw new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_USER_NOT_AUTHENTICATED, "User does not appear to have a valid partner identity."),
                    null);
            }

            // check the title id that comes in the partner token
            if (string.IsNullOrEmpty(partnerIdentity.TitleId))
            {
                throw new WebProtocolException(
                    HttpStatusCode.Unauthorized,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_TITLE_ID_MISSING_IN_PARTNER_TOKEN, "The partner token does not contain a title id."),
                    null);
            }

            uint titleIdFromToken;
            if (!uint.TryParse(partnerIdentity.TitleId, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out titleIdFromToken))
            {
                throw new WebProtocolException(
                    HttpStatusCode.Unauthorized, 
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_TITLE_ID_WRONG_FORMAT_IN_PARTNER_TOKEN, "The partner token does not contain a well-formed title id."),
                    null);
            }

            return partnerIdentity;
        }

        /// <summary>
        /// A helper method to check common request headers. 
        /// </summary>
        private void ValidateCommonHeaders()
        {
            IncomingWebRequestContext request = WebOperationContext.Current.IncomingRequest;
            string platformString = request.Headers[CustomWebHeaderNames.XPlatformType];

            // no platform type info from client: reject request.
            if(string.IsNullOrEmpty(platformString))
            {
                PdlcService.RejectInput("X-Platform-Type header is missing or empty");
            }
            else
            {
                UInt16 platformTypeHeader = 0;
                if (!UInt16.TryParse(platformString, out platformTypeHeader) 
                    || platformTypeHeader != (UInt16)Leet.Core.Platforms.PlatformType.Mobile)
                {
                    // X-PlatformType is limited to  Mobile which is 5
                    PdlcService.RejectInput("X-Platform-Type header is limited to  Mobile");
                }
            }
        }

        /// <summary>
        /// A helper method to log Business Intelligence data for API calls. 
        /// </summary>
        /// <param name="identity">The partner identity of the calling client. </param>
        /// <param name="apiName">The name of the API called. </param>
        /// <param name="apiData">API-specific data to log. </param>
        private void LogBIData(PartnerIdentity identity, string apiName, string apiData)
        {
            // log business intelligence data, need to log before any validations
            try
            {
                IncomingWebRequestContext request = WebOperationContext.Current.IncomingRequest;
                string platformType = request.Headers[CustomWebHeaderNames.XPlatformType];
                uint titleId = uint.Parse(identity.TitleId, NumberStyles.HexNumber, CultureInfo.InvariantCulture); // We've already validated title Id in Partner token
                BILogging.LogBIData(
                    OriginatorIDType.Partner,
                    identity.PartnerID,
                    platformType,
                    titleId,
                    Global.ComponentName,
                    apiName,
                    apiData);
            }
            catch (Exception ex)
            {
                // Swallow all exceptions if BI logging fails for any reason
                Logging.TraceWarning(
                    "Exception caught while writing BI data for API call: {0}; Exception: {1}",
                    apiName,
                    ex.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\ConsumeRequest.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="ConsumeRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/28/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// The assets to consume in a ConsumeAssets transaction.
    /// </summary>
    [DataContract(Name = "ConsumeRequest", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class ConsumeRequest
    {
        /// <summary>
        /// Gets or sets the TitleId to get receipts for. 
        /// </summary>
        [DataMember(Name = "TitleId", Order = 1, IsRequired = true)]
        public uint TitleId { get; set; }

        /// <summary>
        /// Gets or sets the TransactionId of the request. 
        /// </summary>
        [DataMember(Name = "TransactionId", Order = 2, IsRequired = true)]
        public Guid TransactionId { get; set; }

        /// <summary>
        /// Gets or sets the list of Assets to consume. 
        /// </summary>
        [DataMember(Name = "AssetsToConsume", Order = 3, IsRequired = true)]
        public Asset[] AssetsToConsume { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\IPdlcService.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="IPdlcService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service contract
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Xml;
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// PDLC service constract.
    /// </summary>
    [ServiceContract(Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public interface IPdlcService
    {
        /// <summary>
        /// Get a PDLC context for browsing/purchasing XBL marketplace catatlog items.
        /// </summary>
        /// <returns>A context for the calling gamer.</returns>
        [WebHelp(Comment = "Get a PDLC user context for browsing/purchasing XBL marketplace catatlog items.")]
        [WebGet(UriTemplate = "v1/context", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        GamerContext GetContext();

        /// <summary>
        /// Get the PointsBalance for the current user.
        /// </summary>
        /// <returns>Current Points Balance.</returns>
        [WebHelp(Comment = "Get the PointsBalance for the current user.")]
        [WebGet(UriTemplate = "v1/pointsbalance", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        uint GetPointsBalance();

        /// <summary>
        /// Purchase an offer from XBL marketplace catalog.
        /// </summary>
        /// <param name="request">The purchase request including purchase details.</param>
        /// <returns>The receipt for the purcahsed item.</returns>
        [WebHelp(Comment = "Purchase an offer from XBL marketplace catalog.")]
        [WebInvoke(UriTemplate = "v1/purchase", Method = "POST", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        PurchaseReceipt Purchase(PurchaseRequest request);

        /// <summary>
        /// Get the offer behind a 5x5 token.
        /// </summary>
        /// <param name="billingToken">The 5x5 token string.</param>
        /// <param name="storeId">The store id for which the token is issued.</param>
        /// <returns>The offer info behind the token.</returns>
        [WebHelp(Comment = "Get the offer behind a 5x5 token.")]
        [WebGet(UriTemplate = "v1/verifytoken?billingToken={billingToken}&storeId={storeId}", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        TokenOffer VerifyToken(string billingToken, uint storeId);

        /// <summary>
        /// Get the receipts for past purchases.
        /// </summary>
        /// <param name="request">The request specifying title id and filtering for receipts to return.</param>
        /// <returns>PurchaseReceipts. If ReceiptRequest.SignReceipts is true then includes the xml signature</returns>
        [WebHelp(Comment = "Get the receipts for past purchases.")]
        [WebInvoke(UriTemplate = "v1/receipts", Method = "POST", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        XmlElement GetReceipts(ReceiptRequest request); 

        /// <summary>
        /// Get the assets owned by the gamer.
        /// </summary>
        /// <param name="titleId">The title ID the Assets belong to.</param>
        /// <param name="signAssets">Boolean indicating whether to sign the returned assets.</param>
        /// <returns>A string contains a list of Assets if unsigned, or SAML formated list of Assets with signature.</returns>
        [WebHelp(Comment = "Get the assets owned by the gamer.")]
        [WebGet(UriTemplate = "v1/assets?titleId={titleId}&signAssets={signAssets}", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        XmlElement GetAssets(uint titleId, bool signAssets);

        /// <summary>
        /// Consume the specified Assets.
        /// </summary>
        /// <param name="request">The request body contains transactionId, the list of assets and quantity to consume.</param>
        [WebHelp(Comment = "Consume the specified Assets.")]
        [WebInvoke(UriTemplate = "v1/assets", Method = "POST", RequestFormat = WebMessageFormat.Xml, ResponseFormat = WebMessageFormat.Xml)]
        [OperationContract]
        void ConsumeAssets(ConsumeRequest request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\PurchaseRequest.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="PurchaseRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Request to purchase an offer(acquired from XBL marketplace catalog).
    /// </summary>
    [DataContract(Name = "PurchaseRequest", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class PurchaseRequest
    {
        /// <summary>
        /// Gets or sets the TransactionId of the purchase.
        /// </summary>
        [DataMember(Name = "TransactionId", Order = 1, IsRequired = true)]
        public Guid TransactionId { get; set; }

        /// <summary>
        /// Gets or sets the OfferId of the item.
        /// </summary>
        [DataMember(Name = "OfferId", Order = 2, IsRequired = true)]
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the Price of the item, in Microsoft Points.
        /// </summary>
        [DataMember(Name = "PointsPrice", Order = 3, IsRequired = true)]
        public uint PointsPrice { get; set; }

        /// <summary>
        /// Gets or sets the MediaTypeId of the item.
        /// </summary>
        [DataMember(Name = "MediaTypeId", Order = 4, IsRequired = true)]
        public int MediaTypeId { get; set; }

        /// <summary>
        /// Gets or sets the StoreId of the item.
        /// </summary>
        [DataMember(Name = "StoreId", Order = 5, IsRequired = true)]
        public uint StoreId { get; set; }

        /// <summary>
        /// Gets or sets the payment type. 
        /// </summary>
        [DataMember(Name = "PaymentType", Order = 6, IsRequired = true)]
        public uint PaymentType { get; set; } 

        /// <summary>
        /// Gets or sets the AssetId of the item (for consumables).
        /// </summary>
        [DataMember(Name = "AssetId", Order = 7, IsRequired = false)]
        public uint AssetId { get; set; }

        /// <summary>
        /// Gets or sets the 5x5 billing Token. 
        /// </summary>
        [DataMember(Name = "BillingToken", Order = 8, IsRequired = false)]
        public string BillingToken { get; set; } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\PurchaseReceipt.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="PurchaseReceipt.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Xml;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Receipt for the purchased item.
    /// </summary>
    [DataContract(Name = "PurchaseReceipt", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class PurchaseReceipt
    {
        /// <summary>
        /// Gets or sets the TransactionId of the matching purchase.
        /// </summary>
        [DataMember(Name = "TransactionId", Order = 1, IsRequired = true)]
        public Guid TransactionId { get; set; }

        /// <summary>
        /// Gets or sets the OfferId of the purchased item.
        /// </summary>
        [DataMember(Name = "OfferId", Order = 2, IsRequired = true)]
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the PurchasingPartnerId.
        /// </summary>
        [DataMember(Name = "PurchasingPartnerId", Order = 3, IsRequired = true)]
        public ulong PurchasingPartnerId { get; set; }

        /// <summary>
        /// Gets or sets the Title of the purchased item.
        /// </summary>
        [DataMember(Name = "Title", Order = 4, IsRequired = true)]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the PurchaseDate of the purchased item.
        /// </summary>
        [DataMember(Name = "PurchaseDate", Order = 5, IsRequired = true)]
        public DateTime PurchaseDate { get; set; }

        /// <summary>
        /// Gets or sets the MediaInstanceURLs of the offer
        /// </summary>
        [DataMember(Name = "MediaInstanceURLs", Order = 6, IsRequired = true)]
        public IList<string> MediaInstanceURLs { get; set; }

        /// <summary>
        /// Gets or sets the balance of the Asset purchased (consumables only).
        /// </summary>
        [DataMember(Name = "AssetBalance", Order = 7, IsRequired = false)]
        public Asset AssetBalance { get; set; }
    }

    [DataContract(Name = "PurchaseReceipts", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class PurchaseReceipts
    {
        [DataMember(Name = "TotalItems", Order = 1, IsRequired = true)]
        public UInt32 TotalItems;

        [DataMember(Name = "ReceiptsPage", Order = 2, IsRequired = true)]
        public PurchaseReceipt[] ReceiptsPage;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\MediaAssets.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Asset.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

using System;
using System.Runtime.Serialization;
using System.Collections.Generic;

namespace XboxLive.PDLC.Service.Contracts
{
    /// <summary>
    /// Asset with their download Urls
    /// </summary>
    [DataContract(Name = "MediaAsset", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class MediaAsset : Asset
    {
        [DataMember(Name = "MediaInstanceURLs", IsRequired = true)]
        public IList<String> MediaInstanceUrls { get; set; }
    }

    /// <summary>
    /// List of Media Assets
    /// </summary>
    [DataContract(Name = "MediaAssets", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class MediaAssets
    {
        [DataMember(Name = "MediaAssetsList")]
        public IList<MediaAsset> mediaAssets { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\ReceiptRequest.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="ReceiptRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/28/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Request to get receipts for the specified purchases. 
    /// </summary>
    [DataContract(Name = "ReceiptRequest", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class ReceiptRequest
    {
        /// <summary>
        /// PageNumber
        /// </summary>
        [DataMember(Name = "PageNumber", Order = 1, IsRequired = true)]
        public uint PageNumber { get; set; }

        /// <summary>
        /// PageSize
        /// </summary>
        [DataMember(Name = "PageSize", Order = 2, IsRequired = true)]
        public uint PageSize { get; set; }
 
        /// <summary>
        /// Gets or sets the TitleId to get receipts for. 
        /// </summary>
        [DataMember(Name = "TitleId", Order = 3, IsRequired = true)]
        public uint TitleId { get; set; }

        /// <summary>
        /// Gets or Sets the StoreId to get receipts for
        /// </summary>
        [DataMember(Name = "StoreId", Order = 4, IsRequired = false)]
        public uint StoreId { get; set; }

        /// <summary>
        /// Gets or sets the TransactionIds to get receipts for. 
        /// </summary>
        [DataMember(Name = "TransactionIds", Order = 5, IsRequired = false)]
        public Guid[] TransactionIds { get; set; }

        /// <summary>
        /// Gets or sets the MediaTypeId of the item. 
        /// </summary>
        [DataMember(Name = "MediaTypeId", Order = 6, IsRequired = false)]
        public int MediaTypeId { get; set; }

        /// <summary>
        /// Gets or sets the start date since which receipts are requested. 
        /// </summary>
        [DataMember(Name = "StartDate", Order = 7, IsRequired = false)]
        public String StartDate { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the requested receipts should be signed. 
        /// </summary>
        [DataMember(Name = "SignReceipts", Order = 8, IsRequired = false)]
        public bool SignReceipts { get; set; }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\Properties\AssemblyInfo.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PdlcService.Contracts")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("BA084ED2-ED08-4cb6-8F17-CEA35A1DE52A")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Contracts\TokenOffer.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="TokenOffer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace XboxLive.PDLC.Service.Contracts
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// The XBOX offer behind a 5x5 token.
    /// </summary>
    [DataContract(Name = "XboxOfferInfo", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class XboxOfferInfo
    {
        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [DataMember(Name = "offerId", Order = 1, IsRequired = true)]
        public ulong OfferId { get; set; }

        /// <summary>
        /// Gets or sets the Xbox Offer type.
        /// </summary>
        [DataMember(Name = "offerTypeId", Order = 2, IsRequired = true)]
        public int OfferTypeId { get; set; }
    }

    /// <summary>
    /// The EMS offer behind a 5x5 token.
    /// </summary>
    [DataContract(Name = "EmsOfferInfo", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class EmsOfferInfo
    {
        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [DataMember(Name = "offerId", Order = 1, IsRequired = true)]
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [DataMember(Name = "mediaId", Order = 2, IsRequired = true)]
        public Guid MediaId { get; set; }

        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [DataMember(Name = "mediaType", Order = 3, IsRequired = true)]
        public int MediaType { get; set; }
    }

    /// <summary>
    /// The offer behind a 5x5 token could be an XBox Offer or EMS Offer.
    /// </summary>
    [DataContract(Name = "TokenOffer", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class TokenOffer
    {
        /// <summary>
        /// Gets or sets the XboxOffer behind the token.
        /// </summary>
        [DataMember(Name = "XboxOffer", Order = 1, IsRequired = false)]
        public XboxOfferInfo XboxOffer { get; set; }

        /// <summary>
        /// Gets or sets the EmsOffer of the offer behind the token.
        /// </summary>
        [DataMember(Name = "EmsOffer", Order = 2, IsRequired = false)]
        public EmsOfferInfo EmsOffer { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PdlcService.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("F0441C68-6B0E-4dce-8B63-B46BC22174BB")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Test\GetAssetsTests.cs ===
﻿using System;
using System.Xml;
using System.Runtime.Serialization;
using System.Net;
using System.Web;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using XboxLive.PDLC.Service.Contracts;
using XboxLive.PDLC.Service;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using xonline.common.webplatform.livecache;
using xonline.common.protocol;
using Leet.Live.Xblm;
namespace PdlcService.Test
{
    public class GetAssetsTests
    {
        static FASTAccessMock fastMock;
        static GetAssetsTests()
        {
            fastMock = new FASTAccessMock();
            Container.Instance.AddServiceWithInstance<ILogging>(new LoggingMock());
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(new ConfigurationProviderMock());
            //Container.Instance.AddServiceWithInstance<IXblmFastAccess>(new XblmFastAccess());
            Container.Instance.AddServiceWithInstance<IXblmFastAccess>(fastMock);
            ILcBillingOffering lcBillingMock = new LcBillingOfferingMock();
            Container.Instance.AddServiceWithInstance<ILcBillingOffering>(lcBillingMock);
            IBillingOfferingDataAccess bdMock = new BillingOfferingDataAccessMock();
            Container.Instance.AddServiceWithInstance<IBillingOfferingDataAccess>(bdMock);
        }

        public static void GetAssetsWebRequest()
        {
            HttpWebRequest webrequest = (HttpWebRequest)HttpWebRequest.Create("https://pdlc.dev.xboxlive.com/Pdlc.svc/v1/assets?titleId=&signAssets=true");
            webrequest.Method = "GET";
            //webrequest.ContentType = "application/xml";
            String partnerAuthHeader = File.ReadAllText(@"TestFiles\longValidPartnerToken.txt");
            webrequest.Headers.Add("X-PartnerAuthorization", partnerAuthHeader);
            webrequest.Headers.Add("X-Platform-Type", "2");
            webrequest.Headers.Add("X-Locale", "en-us");
            WebResponse response = webrequest.GetResponse();
            String responseString = ReadResponseStream(response);
            Console.WriteLine(responseString);
            bool verified = VerifySignature(responseString);
        }


        public static void GetAssetsCorrectActualFASTCall()
        {
            uint titleId = 1627389952;
            XmlDocument doc = GetAssetsHelper.GetAssets(titleId, 1161890046, "en-US", false);
            DataContractSerializer sz = new DataContractSerializer(typeof(MediaAssets));
            MediaAssets mAssets = sz.ReadObject(new XmlTextReader(new StringReader(doc.OuterXml))) as MediaAssets;
            foreach (var mAsset in mAssets.mediaAssets)
            {
                Console.WriteLine(mAsset.AssetId);
            }
        }

        public static void GetAssetsCorrectFASTXml()
        {
            uint titleId = 1161890046;
            fastMock.ReaderToReturn = new System.Xml.XmlTextReader(System.IO.File.OpenRead("assetsFAST.xml"));
            XmlDocument doc = GetAssetsHelper.GetAssets(titleId, 1161890046, "en-US", false);
            DataContractSerializer sz = new DataContractSerializer(typeof(MediaAssets));
            MediaAssets mAssets = sz.ReadObject(new XmlTextReader(new StringReader(doc.OuterXml))) as MediaAssets;
            foreach (var mAsset in mAssets.mediaAssets)
            {
                Console.WriteLine(mAsset.AssetId);
            }
        }

        public static void Profile(Int32 runs)
        {
            uint titleId = 1161890046;
            for (; runs > 0; runs--)
            {
                fastMock.ReaderToReturn = new System.Xml.XmlTextReader(System.IO.File.OpenRead("assetsFAST.xml"));
                XmlDocument doc = GetAssetsHelper.GetAssets(titleId, 1161890046, "en-US", true);
                DataContractSerializer sz = new DataContractSerializer(typeof(MediaAssets));
                MediaAssets mAssets = sz.ReadObject(new XmlTextReader(new StringReader(doc.OuterXml))) as MediaAssets;
            }
        }

        public static void GetAssetsNullFASTXml()
        {
            uint titleId = 1161890046;
            XmlDocument doc = GetAssetsHelper.GetAssets(titleId, 12345678, "en-US", true);
            DataContractSerializer sz = new DataContractSerializer(typeof(MediaAssets));
            MediaAssets mAssets = sz.ReadObject(new XmlTextReader(new StringReader(doc.OuterXml))) as MediaAssets;
        }

        public static void GetAssetsFASTThrowException()
        {
            uint titleId = 1161890046;
            fastMock.ThrowException = true;
            XmlDocument doc = GetAssetsHelper.GetAssets(titleId, 12345678, "en-US", true);
            DataContractSerializer sz = new DataContractSerializer(typeof(MediaAssets));
            MediaAssets mAssets = sz.ReadObject(new XmlTextReader(new StringReader(doc.OuterXml))) as MediaAssets;
            fastMock.ThrowException = false;
        }

        private static bool VerifySignature(String signedXmlString)
        { 
            XmlDocument doc = new XmlDocument();
            doc.PreserveWhitespace = true;
            doc.LoadXml(signedXmlString);

            SignedXml signedNode = new SignedXml(doc);

            XmlNodeList nodeList = doc.GetElementsByTagName("Signature");
            if ((nodeList == null) || (nodeList.Count != 1))
            {
                throw new Exception("The response xml document does not contain 'Signature' node.");
            }
            signedNode.LoadXml((XmlElement)nodeList[0]);

            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            string certificateSubjectName = config.GetSetting(Settings.PDLCResponseSigningCertSubjectName);
            return signedNode.CheckSignature(GetCertificateBySubjectName(certificateSubjectName), true);

        }

        private static X509Certificate2 GetCertificateBySubjectName(String certSubjectName)
        {
            X509Certificate2Collection matches;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);

            try
            {
                // Find the certificate that matches the subject
                matches = store.Certificates.Find(X509FindType.FindBySubjectName, certSubjectName, false);
            }
            finally
            {
                store.Close();
            }


            if (matches == null || matches.Count == 0)
            {
                return null;
            }

            return matches[0];
        }

        private static String ReadResponseStream(WebResponse response)
        {
            String responseString = String.Empty;
            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                responseString = sr.ReadToEnd().Trim();
            }

            return responseString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Test\Mocks.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Xml;
using xonline.common.webplatform.livecache;
using xonline.common.protocol;
using Leet.Core.Diagnostics;
using Leet.Core.Configuration;
using Leet.Live.Xblm;
using Leet.Live.Livecache.DataAccess;

namespace PdlcService.Test
{
    public class LcBillingOfferingMock : ILcBillingOffering
    {
        public String PurchaseHistoryResponse;
        public LiveCacheWebSvcResponse PurchaseHistory(ulong livePuid, xonline.common.protocol.LivecacheWebSvcRequest request)
        {
            LiveCacheWebSvcResponse response = new LiveCacheWebSvcResponse();
            response.response = PurchaseHistoryResponse;
            return response;
        }


        #region ILcBillingOffering Members
        public AssetConsumeResponse AssetConsume(ulong livePuid, AssetConsumeRequest request)
        {
            throw new NotImplementedException();
        }

        public AssetEnumerateResponse AssetEnumerate(ulong livePuid, AssetEnumerateRequest request)
        {
            AssetEnumerateResponse aResponse = new AssetEnumerateResponse();
            aResponse.package.assets = new Asset[10];
            aResponse.package.cAssets = 10;
            aResponse.package.cTotalAssets = 100;
            aResponse.package.dtAssets = DateTime.UtcNow;
            
            UInt16 assetIdBase = 1016;
            for (Int32 count = 0; count < 10; count++)
            {
                Asset asset = new Asset();
                asset.assetID = assetIdBase++;
                asset.quantity = 10 + count;
                aResponse.package.assets[count] = asset;
            }

            return aResponse;
        }

        public void AddPaymentInstrument(xonline.common.protocol.AddPaymentInstrumentRequest request, out string paymentInstrumentID)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.LiveCacheWebSvcResponse CachedPurchaseHistory(ulong livePuid, xonline.common.protocol.LivecacheWebSvcRequest request)
        {
            throw new NotImplementedException();
        }

        public uint CancelOffer(xonline.common.protocol.OfferingCancelRequest request)
        {
            throw new NotImplementedException();
        }

        public uint ChangeSubscriptionPaymentInstrument(xonline.common.protocol.ChangeSubscriptionPaymentInstrumentRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.ContentEnumerateResponse EnumerateContent(xonline.common.protocol.ContentEnumerateRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.BasicSubscriptionInfo[] EnumerateSubscriptionOffers(xonline.common.protocol.SubscriptionEnumerateRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.FindMediaInstanceUrlsResponse FindMediaInstanceUrls(xonline.common.protocol.FindMediaInstanceUrlsRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.XeGetPointsBalanceResponse GetCachedPointsBalance(xonline.common.protocol.XeGetPointsBalanceRequest request)
        {
            throw new NotImplementedException();
        }

        public uint GetContentOfferDetails(xonline.common.protocol.ContentDetailsRequest request, out xonline.common.protocol.ContentDetailsResponse response)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.GetPaymentInstrumentsResponse GetPaymentInstruments(xonline.common.protocol.GetPaymentInstrumentsRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.XeGetPointsBalanceResponse GetPointsBalance(xonline.common.protocol.XeGetPointsBalanceRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.SubscriptionDetailsResponse GetSubscriptionOfferDetails(xonline.common.protocol.SubscriptionDetailsRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.XeGetUserSubscriptionDetailsResponse GetUserSubscriptionDetails(xonline.common.protocol.XeGetUserSubscriptionDetailsRequest request)
        {
            throw new NotImplementedException();
        }

        public uint OfferingVerifyToken(ulong livePuid, xonline.common.protocol.XeOfferingVerifyTokenRequest request, out xonline.common.protocol.XeOfferingVerifyTokenResponse tokenInfo)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.PreviewProductPurchaseResponse PreviewProductPurchase(xonline.common.protocol.PreviewProductPurchaseRequest request)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseGamerTag(xonline.common.protocol.XeOfferPurchaseGamertagRequest request, IAccountAuthDataProvider authDataProvider)
        {
            throw new NotImplementedException();
        }



        public uint PurchaseMediaOffers(xonline.common.protocol.PurchaseMediaOffersRequest request)
        {
            throw new NotImplementedException();
        }

        public uint PurchasePoints(xonline.common.protocol.XeOfferPurchaseRequest request)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseSubscription(xonline.common.protocol.XeOfferPurchaseRequest request)
        {
            throw new NotImplementedException();
        }

        public void RemovePaymentInstrument(xonline.common.protocol.RemovePaymentInstrumentRequest request)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.LiveCacheWebSvcResponse SubscriptionOfferEnumerate(ulong livePuid, xonline.common.protocol.LivecacheWebSvcRequest request)
        {
            throw new NotImplementedException();
        }

        public uint UpdatePaymentInstrument(xonline.common.protocol.UpdatePaymentInstrumentRequest request)
        {
            throw new NotImplementedException();
        }

        public uint VerifyParentCreditCard(xonline.common.protocol.VerifyParentCreditCardRequest request)
        {
            throw new NotImplementedException();
        }

        public uint VerifyToken(xonline.common.protocol.XeVerifyTokenRequest request, out xonline.common.protocol.XeVerifyTokenResponse response)
        {
            throw new NotImplementedException();
        }

        public PreviewMergeSubscriptionResponse PreviewMergeSubscription(PreviewMergeSubscriptionRequest request)
        {
            throw new NotImplementedException();
        }

        public LiveCacheWebSvcResponse TransferPointsBalance(ulong primaryUserPuid, ulong dependentUserPuid, int pointstoTransfer)
        {
            throw new NotImplementedException();
        }

        public LiveCacheWebSvcResponse GetDependentPointsBalance(ulong primaryUserPuid, ulong dependentUserPuid)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region ILcBillingOffering Members


        public void AddPaymentInstrumentEx(AddPaymentInstrumentRequestEx request, out string paymentInstrumentID)
        {
            throw new NotImplementedException();
        }

        public GetKeyResponse GetKey(GetKeyRequest request)
        {
            throw new NotImplementedException();
        }

        public GetMediaLicenseResponse GetMediaLicense(GetMediaLicenseRequest request)
        {
            throw new NotImplementedException();
        }

        public LiveCacheWebSvcResponse GetUserSubscriptions(ulong livePuid, LivecacheWebSvcRequest request)
        {
            throw new NotImplementedException();
        }

        #endregion
    }

    public class BillingOfferingDataAccessMock : IBillingOfferingDataAccess
    {
        public String PurchaseHistoryResponse;
        #region IBillingOfferingDataAccess Members

        public PurchaseHistoryResponse GetPurchaseHistory(PurchaseHistoryRequest request)
        {
            var phr = new PurchaseHistoryResponse();
            List<PurchaseHistoryEntry> ple = new List<PurchaseHistoryEntry>();
            for (int count = 0; count < 10; count++ )
            {
                var phe = new PurchaseHistoryEntry();
                phe.Title = "title" + count;
                phe.OfferId = Guid.NewGuid();
                phe.TheOffer = new PurchaseHistoryEntry.Offer();
                phe.TheOffer.PurchaseDate = DateTime.UtcNow.AddDays(count*-1.0);
                phe.MediaInstances = new List<IMediaInstance>();
                for(int countInner = 0; countInner < count  + 1; countInner++)
                {
                    var mi = new PurchaseHistoryEntry.MediaInstance {InstanceId = Guid.NewGuid()};
                    phe.MediaInstances.Add(mi);
                }

                ple.Add(phe);
            }
            phr.PurchaseHistoryEntries = new ReadOnlyCollection<PurchaseHistoryEntry>(ple);

            return phr;
        }

        public uint GetPointsBalance(ulong livePuid)
        {
            throw new NotImplementedException();
        }

        public ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseGamertag(XeOfferPurchaseGamertagRequest purchaseReq)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseMediaOfferWithPoints(ulong xuid, Guid offerId, uint points, int mediaTypeId, uint storeId, Guid transactionId)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseMediaOfferWithToken(ulong xuid, Guid offerId, uint points, int mediaTypeId, uint storeId, string token, Guid transactionId)
        {
            throw new NotImplementedException();
        }

        public MediaInstanceUrl[] GetMediaInstanceUrls(Guid[] mediaInstanceId)
        {
            int length = mediaInstanceId.Length;
            var mUrlArray = new MediaInstanceUrl[length];
            for(int count = 0; count < length; count++)
            {
                mUrlArray[count] = new MediaInstanceUrl{urls = new TypedMediaUrl[]{new TypedMediaUrl{url = "http://msn.com/" + count.ToString()},
                                                                                   new TypedMediaUrl{url = "http://msn2.com/" + count.ToString()},
                                                                                   new TypedMediaUrl{url = "http://msn3.com/" + count.ToString()},
                                                                                   new TypedMediaUrl{url = "http://msn4.com/" + count.ToString()}
                }};
            }
            return mUrlArray;
        }

        public uint VerifyToken(ulong livePuid, string token, uint storeId, out ushort offerCatalogType, out Guid emsOfferId, out Guid mediaId, out uint mediaType, out ulong xboxOfferId, out uint xboxOfferType)
        {
            throw new NotImplementedException();
        }

        public void AssetConsume(ulong livePuid, uint titleId, Guid trackingGuid, Asset[] assetsToConsume)
        {
            throw new NotImplementedException();
        }

        public EnumerateAssetsResponse EnumerateAssets(EnumerateAssetsRequest request)
        {
            EnumerateAssetsResponse response = new EnumerateAssetsResponse();
            response.TitleId = request.TitleId;
            response.Assets = new List<EnumerateAssetsResponse.Asset>();
            UInt16 assetIdBase = 1000;

            for (int count = 0; count < 20; count++)
            {
                response.Assets.Add(new EnumerateAssetsResponse.Asset { AssetId = assetIdBase + (uint)count, Quantity = count });
            }

            return response;

        }

        #endregion
    }

    public class LoggingMock : ILogging
    {
        #region ILogging Members

        public void RegisterMetadata(string name, Func<string> value)
        {
            throw new NotImplementedException();
        }

        public void LogEvent(BaseEvent evt)
        {
            throw new NotImplementedException();
        }

        public void LogEvent(BaseEvent evt, string formattedMessage, params object[] args)
        {
        }

        public void LogEvent(BaseEvent evt, Exception ex)
        {
        }

        public void LogEvent(BaseEvent evt, Exception ex, string formattedMessage, params object[] args)
        {
        }

        public void LogTrace(System.Diagnostics.TraceLevel traceLevel, string formattedMessage, params object[] args)
        {
        }

        public void LogTrace(System.Diagnostics.TraceLevel traceLevel, Exception ex)
        {
        }

        public void LogTrace(System.Diagnostics.TraceLevel traceLevel, Exception ex, string formattedMessage, params object[] args)
        {
        }

        public void LogTransaction(string transactionId, string transactionType, string action)
        {
        }

        public void LogTransaction(string transactionId, string transactionType, string action, string formattedMessage, params object[] args)
        {
        }

        #endregion
    }

    class ConfigurationProviderMock : IConfigurationProvider
    {
        public Dictionary<String, String> SettingsDictionary = new Dictionary<String, String>();
        public Dictionary<String, String[]> multiSettingsDict = new Dictionary<String, String[]>();
        public ConfigurationProviderMock()
        {
            this.SettingsDictionary.Add(Settings.StsCertificateSubject, "sts.test.xboxlive.com");
            this.SettingsDictionary.Add(Settings.PDLCResponseSigningCertSubjectName, "sts.test.xboxlive.com");
            this.SettingsDictionary.Add(Settings.Pdlc_InternalXblMarketplaceCatalogUrl, "http://marketplace-origin.xboxlive.com/MarketplaceCatalog");
            this.SettingsDictionary.Add(Settings.Pdlc_XblmNameSpace, "http://marketplace.xboxlive.com/resource/product/v1");
            this.SettingsDictionary.Add(Settings.Pdlc_XblmVersionProductPath, "v1/product/");
            this.SettingsDictionary.Add(Settings.Pdlc_GetPurchaseHistoryMaskingTitle, "584D07D1");

            this.multiSettingsDict.Add(MultiSettings.Pdlc_GetPurchaseHistoryMaskedTitles, new String[] { "4D5308EC", "4D53139A" });
        }

        #region IConfigurationProvider Members

        public event SettingChangedEventHandler SettingChanged;

        public event MultiSettingChangedEventHandler MultiSettingChanged;

        public string GetSetting(string settingName)
        {
            String settingValue = String.Empty;
            this.SettingsDictionary.TryGetValue(settingName, out settingValue);

            return settingValue;
        }

        public bool GetBoolSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public int GetIntSetting(string settingName)
        {
            switch (settingName)
            {
                case (Settings.StsAddedTokenExpirationMinutes):
                    {
                        return 10;
                    }
                default:
                    {
                        throw new ArgumentException("settingName", "settingName");
                    }
            }
        }

        public long GetLongSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public double GetDoubleSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public string[] GetMultiSetting(string settingName)
        {
            String[] settingValue = null;
            this.multiSettingsDict.TryGetValue(settingName, out settingValue);
            return settingValue;
        }

        public string GetConnectionString(string interfaceName)
        {
            throw new NotImplementedException();
        }

        public string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
        {
            throw new NotImplementedException();
        }

        public string Environment
        {
            get { throw new NotImplementedException(); }
        }

        public string ComponentName
        {
            get { throw new NotImplementedException(); }
        }

        public string Server
        {
            get { throw new NotImplementedException(); }
        }

        public IInterfaceInfo GetSingleInterface(string interfaceName)
        {
            throw new NotImplementedException();
        }

        public IInterfaceInfo GetInterface(string computerName, string interfaceName)
        {
            throw new NotImplementedException();
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
        {
            throw new NotImplementedException();
        }

        public string GetSingleServerForInterface(string interfaceName)
        {
            throw new NotImplementedException();
        }

        #endregion

        public bool DummyMethod()
        {
            if (SettingChanged.GetInvocationList().Length > 0 && MultiSettingChanged.GetInvocationList().Length > 0)
            {
                return true;
            }

            return false;
        }
    }

    public class FASTAccessMock : IXblmFastAccess
    {
        public XmlTextReader ReaderToReturn;
        public bool ThrowException = false;
        #region IFASTAssetsAccess Members

        public XblmAssetsResponse QueryAssets(uint titleId, string locale, string productTypes, string store)
        {
            if (ThrowException)
            {
                throw new ArgumentException("titleId");
            }
            return new XblmAssetsResponse(System.Net.HttpStatusCode.OK, ReaderToReturn);
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Test\Program.cs ===
﻿namespace PdlcService.Test
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    
    using XboxLive.PDLC.Service.Contracts;

    /// <summary>
    /// Class to test PDLC service APIs.
    /// </summary>
    public class Program
    {
        static string partnerToken = @"<?xml version=""1.0"" encoding=""utf-16""?><saml:Assertion MajorVersion=""1"" MinorVersion=""1"" AssertionID=""SamlSecurityToken-f2dde48f-0145-44c6-8565-6fa4511055e8"" Issuer=""http://sts.xboxlive.com"" IssueInstant=""2010-12-07T01:59:23.3532682Z"" xmlns:saml=""urn:oasis:names:tc:SAML:1.0:assertion""><saml:Conditions NotBefore=""2010-12-07T01:59:23.3532682Z"" NotOnOrAfter=""2012-12-08T05:59:23.3532682Z""><saml:AudienceRestrictionCondition><saml:Audience>http://xboxlive.com/pdlc/purchase</saml:Audience></saml:AudienceRestrictionCondition></saml:Conditions><saml:AttributeStatement><saml:Subject><saml:NameIdentifier Format=""/xboxlive/nameFormat"" NameQualifier=""Microsoft-NameQualifier-domain"">XboxLive Partner security ticket</saml:NameIdentifier></saml:Subject><saml:Attribute AttributeName=""TitleID"" AttributeNamespace=""http://xboxlive.com/claims""><saml:AttributeValue>4D5308E2</saml:AttributeValue></saml:Attribute><saml:Attribute AttributeName=""TitleVersion"" AttributeNamespace=""http://xboxlive.com/claims""><saml:AttributeValue>1</saml:AttributeValue></saml:Attribute><saml:Attribute AttributeName=""PartnerID0"" AttributeNamespace=""http://xboxlive.com/claims""><saml:AttributeValue>2600292641993623</saml:AttributeValue></saml:Attribute><saml:Attribute AttributeName=""Gamertag0"" AttributeNamespace=""http://xboxlive.com/claims""><saml:AttributeValue>mpdev2</saml:AttributeValue></saml:Attribute></saml:AttributeStatement><Signature xmlns=""http://www.w3.org/2000/09/xmldsig#""><SignedInfo><CanonicalizationMethod Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#"" /><SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1"" /><Reference URI=""#SamlSecurityToken-f2dde48f-0145-44c6-8565-6fa4511055e8""><Transforms><Transform Algorithm=""http://www.w3.org/2000/09/xmldsig#enveloped-signature"" /><Transform Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#"" /></Transforms><DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1"" /><DigestValue>npjwbsimcxDxqPCQDYLNsoihX/8=</DigestValue></Reference></SignedInfo><SignatureValue>AM9m9qlwHe/37jkDx0ip8Jgl/D0jU66nGHM/ZsQzEB0j/ri+5/NVocYljJDSBYEHECLJpRGE/yXxTz7O7D9s1YwJ2ot8/FqpX7BqIKBk6aqMvxoKNW7lV7pzPxxjmTHxGhP369MVQ8Gqg17BRperD7H2hNWqy7ORGzbViL+fCFY=</SignatureValue><KeyInfo><X509Data><X509Certificate>MIICJzCCAZSgAwIBAgIQ7YujYuC55LtHk8DFyxqDQDAJBgUrDgMCHQUAMCAxHjAcBgNVBAMTFXN0cy50ZXN0Lnhib3hsaXZlLmNvbTAeFw0wOTA3MTMxNTU3MzdaFw0zOTEyMzEyMzU5NTlaMCAxHjAcBgNVBAMTFXN0cy50ZXN0Lnhib3hsaXZlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAgz0fPGlZa73r2TWmQsQy72aTiKdkAcuW18TyPUL3326CF03eiP3MDUR51U8flfssgt7+2lkuTYALTnCCG4n4XuRVu8JHGdAsGjSmfUpY+EGjxo6A3DuCDJF3Aa0uXzt72OShgF2IcX3+PMJnqryiMXyiPxi6/I1FEZ+i2FWdSYsCAwEAAaNqMGgwEwYDVR0lBAwwCgYIKwYBBQUHAwEwUQYDVR0BBEowSIAQodN354CzBxTNqhzW0A3gWqEiMCAxHjAcBgNVBAMTFXN0cy50ZXN0Lnhib3hsaXZlLmNvbYIQ7YujYuC55LtHk8DFyxqDQDAJBgUrDgMCHQUAA4GBAEeUyfLsUMQ1o3v9KmC4GV+9N0WMbmnv5iPusd0BiqtfNp0xcWUbwm1ea5Gw65nTmF5YJKmDN3VEIH4LyTgwTPHLP1QFq4XHY97GXYieeYLJluW+TQTk8rn2rPrYre9yWQDvkijCwERT8F6zV59RKHMAuv36b0oCtSqMCH6hxTRZ</X509Certificate></X509Data></KeyInfo></Signature></saml:Assertion>";

        

        /// <summary>
        /// Main entry.
        /// </summary>
        public static void Main()
        {
            Console.WriteLine("Enter q to end or enter any key to run the test");
            while (Console.ReadKey().KeyChar != 'q')
            {
                Console.WriteLine("Running the test...\n");
                try
                {
                    //TestGetContext();
                    //TestGetPointsBalance();
                    //TestPurchase();
                    //TestVerifyToken();
                    //TestConsumeAssets();

                    GetReceiptsTests.TestGetReceipts();
                    //GetReceiptsTests.TestGetReceiptsMasking();
                    //GetAssetsTests.GetAssetsCorrectActualFASTCall();
                    //GetReceiptsTests.GetReceiptsWebrequestLocaleValidationFailed();
                    //GetReceiptsTests.GetReceiptsWebrequestPlatformTypeValidationFailed();
                    //GetReceiptsTests.GetReceiptsWebrequestPlatformTypeValidationFailed2();
                    //GetReceiptsTests.GetReceiptsWebrequestNoBody();
                    //GetReceiptsTests.GetReceiptsWebrequest();
                    //GetAssetsTests.GetAssetsWebRequest();
                    //GetAssetsTests.GetAssetsCorrectFASTXml();
                    //GetAssetsTests.GetAssetsNullFASTXml();
                    //GetAssetsTests.GetAssetsFASTThrowException();
                    //GetAssetsTests.Profile(1);
                }
                catch(Exception e)
                {
                    Console.WriteLine(e.ToString());
                }

                Console.WriteLine("Enter q to end or enter enykey to run the test");
            }
        }

        /// <summary>
        /// Test method for GetContext API.
        /// </summary>
        public static void TestGetContext()
        {
            // initialize the WebRequest request
            string url = "https://pdlc.dev.xboxlive.com/pdlc.svc/v1/context";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "application/xml";
            request.Method = "GET";
            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type", "5");
            request.Headers.Add("X-PartnerAuthorization", " XBL1.0 x=" + partnerToken);

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }

        /// <summary>
        /// Test method for GetPointsBalance API.
        /// </summary>
        public static void TestGetPointsBalance()
        {
            // initialize the WebRequest request
            string url = "https://pdlc.dev.xboxlive.com/pdlc.svc/v1/pointsbalance";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "application/xml";
            request.Method = "GET";
            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type", "5");
            request.Headers.Add("X-PartnerAuthorization", " XBL1.0 x=" + partnerToken);

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }

        /// <summary>
        /// Test method for Purchase API.
        /// </summary>
        public static void TestPurchase()
        {
            // initialize the WebRequest request
            string url = "https://pdlc.dev.xboxlive.com/pdlc.svc/v1/purchase";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "application/xml";
            request.Method = "POST";
            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type", "5");
            request.Headers.Add("X-PartnerAuthorization", " XBL1.0 x=" + partnerToken);

            // initialize the request body
            PurchaseRequest requestBody = new PurchaseRequest();
            requestBody.TransactionId = Guid.NewGuid();
            requestBody.OfferId = new Guid("61002001-0000-4000-8000-0000584107f6");
            requestBody.PointsPrice = 250;
            requestBody.MediaTypeId = 60;
            requestBody.StoreId = 5;
            requestBody.AssetId = 60002001;
            requestBody.PaymentType = 4;
            //requestBody.BillingToken = "MOBIL-GAME1-00TOK-PURCH-00900";

            Stream stream = request.GetRequestStream();
            DataContractSerializer dcs = new DataContractSerializer(typeof(PurchaseRequest));
            dcs.WriteObject(stream, requestBody);
            stream.Close();

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }

        /// <summary>
        /// Test method for VerifyToken API.
        /// </summary>
        public static void TestVerifyToken()
        {
            string billingToken = "MOBIL-GAME1-00TOK-PURCH-00900";
            uint storeId = 5;
            string urlTemplate = "https://pdlc.dev.xboxlive.com/pdlc.svc/v1/verifytoken?billingToken={0}&storeId={1}";
            string url = string.Format(urlTemplate, billingToken, storeId);
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "application/xml";
            request.Method = "GET";
            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type", "5");
            request.Headers.Add("X-PartnerAuthorization", " XBL1.0 x=" + partnerToken);

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }

        /// <summary>
        /// Test method for ConsumeAssets API.
        /// </summary>
        public static void TestConsumeAssets()
        {
            // initialize the WebRequest request
            string url = "https://pdlc.dev.xboxlive.com/pdlc.svc/v1/assets";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "application/xml";
            request.Method = "POST";
            request.Headers.Add("X-Locale", "en-US");
            request.Headers.Add("X-Platform-Type", "5");
            request.Headers.Add("X-PartnerAuthorization", " XBL1.0 x=" + partnerToken);

            // initialize the request body
            ConsumeRequest requestBody = new ConsumeRequest();
            requestBody.TransactionId = Guid.NewGuid();
            requestBody.TitleId = 0x62000000;
            requestBody.AssetsToConsume = new Asset[] 
            { 
                new Asset { AssetId = 1, Quantity = 100}, 
                new Asset { AssetId = 2, Quantity = 100},
            };

            Stream stream = request.GetRequestStream();
            DataContractSerializer dcs = new DataContractSerializer(typeof(ConsumeRequest));
            dcs.WriteObject(stream, requestBody);
            stream.Close();

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "XboxLive.PDLC.Service")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "1#", Scope = "member", Target = "XboxLive.PDLC.Service.ReceiptsHelper.#ValidateGetReceiptsInput(XboxLive.PDLC.Service.Contracts.ReceiptRequest,System.String&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "0#", Scope = "member", Target = "XboxLive.PDLC.Service.RequestValidation.#ValidateHeaders(System.String&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId = "System.Xml.XmlNode", Scope = "member", Target = "XboxLive.PDLC.Service.ReceiptsHelper.#GetPurchaseReceipts(XboxLive.PDLC.Service.Contracts.ReceiptRequest,System.UInt64,System.String,System.UInt64)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "XboxLive.PDLC.Service.GetAssetsHelper.#GetAssets(System.UInt32,System.UInt64,System.String,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId = "System.Xml.XmlNode", Scope = "member", Target = "XboxLive.PDLC.Service.GetAssetsHelper.#GetAssets(System.UInt32,System.UInt64,System.String,System.Boolean)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcService.Test\GetReceiptsTests.cs ===
﻿using System;
using System.Xml;
using System.Runtime.Serialization;
using System.Net;
using System.Web;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using XboxLive.PDLC.Service.Contracts;
using XboxLive.PDLC.Service;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;

namespace PdlcService.Test
{
    public class GetReceiptsTests
    {
        static LcBillingOfferingMock mock;
        static BillingOfferingDataAccessMock bdMock;
        static GetReceiptsTests()
        {
            Container.Instance.AddServiceWithInstance<ILogging>(new LoggingMock());
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(new ConfigurationProviderMock());
            mock = new LcBillingOfferingMock();
            bdMock = new BillingOfferingDataAccessMock();
            Container.Instance.AddServiceWithInstance<IBillingOfferingDataAccess>(bdMock);
        }

        public static void TestGetReceipts()
        {
            mock.PurchaseHistoryResponse = File.ReadAllText(@"TestFiles\SampleHistoryResponse.xml");
            ReceiptRequest rr = new ReceiptRequest()
            {
                MediaTypeId = 1,
                PageNumber = 1,
                PageSize = 10,
                SignReceipts = true,
                StartDate = DateTime.Now.ToString("d"),
                TitleId = 0
     
            };

            rr.TransactionIds = new Guid[]{Guid.NewGuid()};

            XmlDocument signed = ReceiptsHelper.GetPurchaseReceipts(rr, 1234567, "en-us", 123456);

        }

        public static void TestGetReceiptsMasking()
        {
            mock.PurchaseHistoryResponse = File.ReadAllText(@"TestFiles\SampleHistoryResponse.xml");
            ReceiptRequest rr = new ReceiptRequest()
            {
                MediaTypeId = 1,
                PageNumber = 1,
                PageSize = 10,
                SignReceipts = true,
                StartDate = DateTime.Now.ToString("d"),
                TitleId = 1297290138

            };

            rr.TransactionIds = new Guid[] { Guid.NewGuid() };

            XmlDocument signed = ReceiptsHelper.GetPurchaseReceipts(rr, 1234567, "en-us", 123456);

        }

        public static void GetReceiptsWebrequest()
        {
            try
            {
                HttpWebRequest webrequest = (HttpWebRequest)HttpWebRequest.Create("https://pdlc.dev.xboxlive.com/Pdlc.svc/v1/receipts");
                webrequest.Method = "POST";
                webrequest.ContentType = "application/xml";
                String partnerAuthHeader = File.ReadAllText(@"TestFiles\longValidPartnerToken.txt");
                webrequest.Headers.Add("X-PartnerAuthorization", partnerAuthHeader);
                webrequest.Headers.Add("X-Platform-Type", "2");
                webrequest.Headers.Add("X-Locale", "en-us");

                ReceiptRequest request = new ReceiptRequest()
                {
                    MediaTypeId = 60,
                    PageNumber = 1,
                    PageSize = 100,
                    SignReceipts = true,
                    //StartDate = DateTime.Now,
                    TitleId = 1644167168,
                };

                String requestBody = SerializeReceiptRequest(request);
                if (!string.IsNullOrEmpty(requestBody))
                {
                    byte[] buffer = Encoding.ASCII.GetBytes(requestBody);
                    webrequest.ContentLength = buffer.Length;
                    Stream st = webrequest.GetRequestStream();
                    st.Write(buffer, 0, buffer.Length);
                    st.Close();
                }

                WebResponse response = webrequest.GetResponse();
                Console.WriteLine(ReadResponseStream(response));
            }
            catch (System.Net.WebException we)
            {
                Console.WriteLine(ReadResponseStream(we.Response));
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }

        public static void GetReceiptsWebrequestNoBody()
        {
            try
            {
                HttpWebRequest webrequest = (HttpWebRequest)HttpWebRequest.Create("https://pdlc.dev.xboxlive.com/Pdlc.svc/v1/receipts");
                webrequest.Method = "POST";
                webrequest.ContentType = "application/xml";
                String partnerAuthHeader = File.ReadAllText(@"TestFiles\longValidPartnerToken.txt");
                webrequest.Headers.Add("X-PartnerAuthorization", partnerAuthHeader);
                webrequest.Headers.Add("X-Platform-Type", "2");
                webrequest.Headers.Add("X-Locale", "en-us");

                webrequest.ContentLength = 0;
              

                WebResponse response = webrequest.GetResponse();
                Console.WriteLine(ReadResponseStream(response));
            }
            catch (System.Net.WebException we)
            {
                Console.WriteLine(ReadResponseStream(we.Response));
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());

            }
        }

        public static void GetReceiptsWebrequestPlatformTypeValidationFailed()
        {
            try
            {
                HttpWebRequest webrequest = (HttpWebRequest)HttpWebRequest.Create("https://pdlc.dev.xboxlive.com/Pdlc.svc/v1/receipts");
                webrequest.Method = "POST";
                webrequest.ContentType = "application/xml";
                String partnerAuthHeader = File.ReadAllText(@"TestFiles\longValidPartnerToken.txt");
                webrequest.Headers.Add("X-PartnerAuthorization", partnerAuthHeader);
                webrequest.Headers.Add("X-Locale", "en-us");

                ReceiptRequest request = new ReceiptRequest()
                {
                    MediaTypeId = 47,
                    PageNumber = 1,
                    PageSize = 100,
                    SignReceipts = true,
                    StartDate = DateTime.Now.ToString("d"),
                    TitleId = 123456,
                };

                String requestBody = SerializeReceiptRequest(request);
                if (!string.IsNullOrEmpty(requestBody))
                {
                    byte[] buffer = Encoding.ASCII.GetBytes(requestBody);
                    webrequest.ContentLength = buffer.Length;
                    Stream st = webrequest.GetRequestStream();
                    st.Write(buffer, 0, buffer.Length);
                    st.Close();
                }

                WebResponse response = webrequest.GetResponse();
                Console.WriteLine(ReadResponseStream(response));
            }
            catch (System.Net.WebException we)
            {
                Console.WriteLine(ReadResponseStream(we.Response));
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());

            }
        }

        public static void GetReceiptsWebrequestPlatformTypeValidationFailed2()
        {
            try
            {
                HttpWebRequest webrequest = (HttpWebRequest)HttpWebRequest.Create("https://pdlc.dev.xboxlive.com/Pdlc.svc/v1/receipts");
                webrequest.Method = "POST";
                webrequest.ContentType = "application/xml";
                String partnerAuthHeader = File.ReadAllText(@"TestFiles\longValidPartnerToken.txt");
                webrequest.Headers.Add("X-PartnerAuthorization", partnerAuthHeader);
                webrequest.Headers.Add("X-Platform-Type", "blah");
                webrequest.Headers.Add("X-Locale", "en-us");

                ReceiptRequest request = new ReceiptRequest()
                {
                    MediaTypeId = 47,
                    PageNumber = 1,
                    PageSize = 100,
                    SignReceipts = true,
                    StartDate = DateTime.Now.ToString("d"),
                    TitleId = 123456,
                };

                String requestBody = SerializeReceiptRequest(request);
                if (!string.IsNullOrEmpty(requestBody))
                {
                    byte[] buffer = Encoding.ASCII.GetBytes(requestBody);
                    webrequest.ContentLength = buffer.Length;
                    Stream st = webrequest.GetRequestStream();
                    st.Write(buffer, 0, buffer.Length);
                    st.Close();
                }

                WebResponse response = webrequest.GetResponse();
                Console.WriteLine(ReadResponseStream(response));
            }
            catch (System.Net.WebException we)
            {
                Console.WriteLine(ReadResponseStream(we.Response));
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());

            }
        }
        
        public static void GetReceiptsWebrequestLocaleValidationFailed()
        {
            try
            {
                HttpWebRequest webrequest = (HttpWebRequest)HttpWebRequest.Create("https://pdlc.dev.xboxlive.com/Pdlc.svc/v1/receipts");
                webrequest.Method = "POST";
                webrequest.ContentType = "application/xml";
                String partnerAuthHeader = File.ReadAllText(@"TestFiles\longValidPartnerToken.txt");
                webrequest.Headers.Add("X-PartnerAuthorization", partnerAuthHeader);
                webrequest.Headers.Add("X-Platform-Type", "2");
                
                ReceiptRequest request = new ReceiptRequest()
                {
                    MediaTypeId = 47,
                    PageNumber = 1,
                    PageSize = 100,
                    SignReceipts = true,
                    StartDate = DateTime.Now.ToString("d"),
                    TitleId = 123456,
                };

                String requestBody = SerializeReceiptRequest(request);
                if (!string.IsNullOrEmpty(requestBody))
                {
                    byte[] buffer = Encoding.ASCII.GetBytes(requestBody);
                    webrequest.ContentLength = buffer.Length;
                    Stream st = webrequest.GetRequestStream();
                    st.Write(buffer, 0, buffer.Length);
                    st.Close();
                }

                WebResponse response = webrequest.GetResponse();
                Console.WriteLine(ReadResponseStream(response));
            }
            catch (System.Net.WebException we)
            {
                Console.WriteLine(ReadResponseStream(we.Response));
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());

            }
        }

        private static String ReadResponseStream(WebResponse response)
        {
            String responseString = String.Empty;
            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                responseString = sr.ReadToEnd().Trim();
            }

            return responseString;
        }

        private static String SerializeReceiptRequest(ReceiptRequest purchaseReceipts)
        {
            DataContractSerializer sz = new DataContractSerializer(typeof(ReceiptRequest));

            StringBuilder sb = new StringBuilder();
            StringWriter wr = new StringWriter(sb);
            XmlTextWriter xw = new XmlTextWriter(wr);
            sz.WriteObject(xw, purchaseReceipts);
            wr.Close();
            xw.Close();

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\Diagnostics\Ex.cs ===
﻿using System;
using System.Net;
using Leet.Core.Diagnostics;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Utils;
using Microsoft.ServiceModel.Web;
using xonline.common.webplatform.livecache;

    
namespace XboxLive.PDLC.Service
{
    public static class Ex
    {
        /// <summary>
        /// Gets a value indicating whether to include exception details in response.
        /// </summary>
        public static bool IncludeExceptionDetailInErrorMessage
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetBoolSetting(Settings.IncludeExceptionDetailInErrorMessage);
            }
        }

        /// <summary>
        /// Helper function throws a WebProtocolException to the client.
        /// </summary>
        /// <param name="methodName">Name of the API where exception is thrown.</param>
        /// <param name="ex">exception object.</param>
        public static void HandleException(string methodName, Exception ex)
        {
            HandleException(methodName, PdlcErrors.PDLC_E_UNSPECIFIED_ERROR, ex);
        }


        /// <summary>
        /// Helper function throws a WebProtocolException to the client.
        /// </summary>
        /// <param name="methodName">Name of the API where exception is thrown.</param>
        /// <param name="errorCode">The error code.</param>
        /// <param name="ex">exception object.</param>
        public static void HandleException(string methodName, uint errorCode, Exception ex)
        {
            HandleException(methodName, errorCode, new PdlcServiceUnknownErrorEvent(), ex);
        }

        /// <summary>
        /// Helper function throws a WebProtocolException to the client.
        /// </summary>
        /// <param name="methodName">Name of the API where exception is thrown.</param>
        /// <param name="errorCode">The error code.</param>
        /// <param name="evt">BaseEvent type</param>
        /// <param name="ex">exception object.</param>
        public static void HandleException(string methodName, uint errorCode, BaseEvent evt, Exception ex)
        {
            Logging.TraceException(ex, "Exception caught in method: {0}", methodName);
            
            if (evt != null)
            {
                Logging.WriteEvent(evt, ex);
            }

            WebProtocolException wpex = ex as WebProtocolException;
            if (wpex == null)
            {
                wpex = new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    "Internal server error",
                    new PdlcServiceErrorMessage(errorCode, "Internal server error"),
                    IncludeExceptionDetailInErrorMessage ? ex : null);
            }

            throw wpex;

            throw wpex;
        }


        /// <summary>
        /// Helper function throws a WebProtocolException to the client.
        /// </summary>
        /// <param name="methodName">Name of the API where exception is thrown.</param>
        /// <param name="xuid">XUID of the caller.</param>
        /// <param name="ex">exception object.</param>
        public static void HandleLiveCacheException(string methodName, ulong xuid, Exception ex)
        {
            Logging.TraceException(ex, "Exception caught when calling livecache in method:{0}", methodName);

            if (ex is ServiceUnavailableException)
            {
                // log a system event to notify operations
                Logging.WriteEvent(
                    new LiveServiceUnavailableEvent(),
                    ex,
                    "ServiceUnavailableException happened for (xuid={0})",
                    xuid);

                // Send error message to client
                throw new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_XBL_SERVICE_UNAVAILABLE, "XBL service unavailable."),
                    IncludeExceptionDetailInErrorMessage ? ex : null);
            }
            else if (ex is LivecacheUserThrottledException)
            {
                // log a system event to notify operations
                Logging.WriteEvent(
                    new LiveServiceThrottledEvent(),
                    ex,
                    "LivecacheUserThrottledException happened for (xuid={0})",
                    xuid);

                // Send error message to client
                throw new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_XBL_CALLS_THROTTLED, "XBL calls throttled."),
                    IncludeExceptionDetailInErrorMessage ? ex : null);
            }
            else
            {
                Logging.WriteEvent(new PdlcServiceUnknownErrorEvent(), ex);
                // Send error message to client
                throw new WebProtocolException(
                    HttpStatusCode.InternalServerError,
                    null,
                    new PdlcServiceErrorMessage(PdlcErrors.PDLC_E_UNSPECIFIED_ERROR, "Internal server error"),
                    IncludeExceptionDetailInErrorMessage ? ex : null);
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\GetAssetsHelper.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Asset.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC service data contracts
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.Serialization;
using System.IO;
using System.Collections.Generic;
using System.Xml.Linq;
using System.Linq;
using System.Net;
using System.Text;
using System.Xml;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Utils;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache.DataAccess;
using XboxLive.PDLC.Service.Contracts;
using Leet.Live.Xblm;
using xonline.common.protocol;

namespace XboxLive.PDLC.Service
{
    /// <summary>
    /// Helper class that contains methods to query assets for a user
    /// </summary>
    public static class GetAssetsHelper
    {
        /// <summary>
        /// Gets assets for the gamer xuid
        /// </summary>
        /// <param name="titleId">title id</param>
        /// <param name="livePuid">xuid of the user</param>
        /// <param name="locale">user locale</param>
        /// <param name="maxResults">Max results to return. 0 defaults to 100</param>
        /// <param name="signResponse">true if the response needs to be signed as per W3C XMl signature standards. false otherwise</param>
        /// <returns>XmlDocument wrapping serialized MediaAssets object</returns>
        public static XmlDocument GetAssets(uint titleId,
            ulong livePuid,
            string locale,
            bool signResponse)
        {
            MediaAssets mediaAssets = new MediaAssets(); //container for the response

            // call 1: CAll livecache to enumerate assets for the gamer
            IBillingOfferingDataAccess billingOffering = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
            EnumerateAssetsRequest assetsRequest = new EnumerateAssetsRequest();
            assetsRequest.TitleId = titleId;
            assetsRequest.Xuid = livePuid;
            assetsRequest.Locale = locale;

            EnumerateAssetsResponse assetsResponse = billingOffering.EnumerateAssets(assetsRequest);
           

            //if no response was received from livecache we dont go do anything furthur.
            if (assetsResponse != null &&
                assetsResponse.Assets != null &&
                assetsResponse.Assets.Count > 0)
            {
                //call 2: Call FAST to get all the assets for the title id. This is needed to query for media instance urls for each asset
                //since the above call does not give us that
                IXblmFastAccess fastAssetsAccess = Container.Instance.GetComponent<IXblmFastAccess>();
                XblmAssetsResponse responseFromFAST = null;
                try
                {
                    String mediaTypes = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.Pdlc_GetAssetsMediaTypeIds);
                    String storeIds = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.Pdlc_GetAssetsStoreIds);
                    responseFromFAST = fastAssetsAccess.QueryAssets(titleId, locale, mediaTypes, storeIds);
                }
                catch (Exception ex)
                {
                    //failed call to FAST. We will ignore, log event and trace
                    responseFromFAST = null;
                    Logging.WriteEvent(
                        new XblmMarketplaceAccessErrorEvent(), ex, "Error querying Xblm Marketplace catalog for titleID {0})", titleId);
                    Logging.TraceException(ex, "Error querying Xblm Marketplace catalog for titleID {0}", titleId);
                }


                //if FAST call is successful, join assets from the above 2 calls to get the media instance Urls download urls for each asset that the user owns
                if (responseFromFAST != null && responseFromFAST.StatusCode == HttpStatusCode.OK)
                {
                    //we will create a hash of the asset ids owned by the user 
                    //we will then go once through the FAST response XML and check if an asset is owned by the user by joining with the keys in the hash
                    //because of the hash table we will need only close to O(1) check 
                    Dictionary<UInt32, MediaAsset> mediaAssetsHash = new Dictionary<uint, MediaAsset>();
                    foreach (EnumerateAssetsResponse.Asset asset in assetsResponse.Assets)
                    {
                        mediaAssetsHash.Add(asset.AssetId, new MediaAsset { AssetId = asset.AssetId, Quantity = asset.Quantity });
                    }

                    //String mediaInstanceUrl = String.Empty;
                    MediaAsset mediaAsset = null;
                    List<Guid> mediaInstanceIdList = new List<Guid>();  //this will have all the media instance ids when the query runs


                    // this LINQ query will do the actual join on assetId in one pass
                    IEnumerable<MediaAsset> query = from el in IterateFASTResponse(responseFromFAST.Response)
                                                    where (ProcessXElement(el, mediaAssetsHash, ref mediaAsset, ref mediaInstanceIdList))
                                                    select (mediaAsset);

                    mediaAssets.mediaAssets = new List<MediaAsset>(query);

                    if (mediaInstanceIdList != null && mediaInstanceIdList.Count > 0)
                    {
                        //make one call to get media instance urls for all the media instance id for all assets
                        FillMediaInstanceUrlsFromMediaInstanceIds(mediaAssets, mediaInstanceIdList);
                    }
                }
                else
                {
                    //FAST was not successful to we just return reponse from the live cache
                    IEnumerable<MediaAsset> query = from asset in assetsResponse.Assets
                                                    select new MediaAsset { AssetId = asset.AssetId, Quantity = asset.Quantity };
                    mediaAssets.mediaAssets = new List<MediaAsset>(query);
                }
            }

            //Serialze the assets
            XmlDocument mediaAssetsDocument = SerializeMediaAssets(mediaAssets);

            // sign the xml if signResponse is true
            if (signResponse)
            {
                IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
                string certificateSubjectName = config.GetSetting(Settings.PDLCResponseSigningCertSubjectName);
                XmlDocument envelopedXml = null;
                XmlSignature.GetSignedXml(mediaAssetsDocument, certificateSubjectName, out envelopedXml);
                return envelopedXml;
            }

            return mediaAssetsDocument;
        }

        //Checks of the XElement from FAST response has asset id that user owns
        private static bool ProcessXElement(XElement element, Dictionary<UInt32, MediaAsset> hash, ref MediaAsset mediaAsset, ref List<Guid> mediaInstanceIdList)
        {
            XName mediaInstanceIdXName = XName.Get("productInstanceId", XblmSettings.XblmNameSpace);
            XName assetIdXName = XName.Get("assetId", XblmSettings.XblmNameSpace);
            
            XElement mediaInstanceIdElement = element.Element(mediaInstanceIdXName);
            XElement assetIdELement = element.Element(assetIdXName);

            if (mediaInstanceIdElement != null && assetIdELement != null)
            {   
                uint assetId = uint.Parse(assetIdELement.Value, System.Globalization.CultureInfo.CurrentUICulture);
                if (!hash.ContainsKey(assetId)) //this takes only O(1)  
                {
                    return false;
                }
                mediaInstanceIdList.Add(new Guid(mediaInstanceIdElement.Value));
                mediaAsset = hash[assetId];
                hash.Remove(assetId); //remove the assetId from the has so that we dont see the assetId again.
                return true;
            }
            return false;
        }
     
        // Creates an iterator from XmlTextReader
        private static IEnumerable<System.Xml.Linq.XElement> IterateFASTResponse(XmlReader xwr)
        {
            xwr.MoveToContent();
            while (xwr.Read())
            {
                if (xwr.NodeType == XmlNodeType.Element && xwr.Name == "productInstance")
                {
                    var nextElement = System.Xml.Linq.XElement.ReadFrom(xwr) as System.Xml.Linq.XElement;
                    yield return nextElement;
                }
            }
        }

        /// <summary>
        /// Queries LiveCache wrapper for Media Instance Urls for a list of IMedisInstance
        /// </summary>
        /// <param name="mediaInstanceIdList">The list of media instance Ids to get download URLs.</param>
        private static void FillMediaInstanceUrlsFromMediaInstanceIds(MediaAssets mediaAssets, List<Guid> mediaInstanceIdList)
        {
            if (mediaInstanceIdList != null && mediaInstanceIdList.Count > 0)
            {
                try
                {
                    //query live cache again to get Media Instance Urls from Media Instance Id
                    Guid[] mediaInstanceIdArray = mediaInstanceIdList.ToArray();
                    IBillingOfferingDataAccess billingOffering = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
                    IEnumerable<List<String>> query = from mediaInstanceUrl in billingOffering.GetMediaInstanceUrls(mediaInstanceIdArray)
                                                      select (GetUrlsFromTypedMediaUrlsObject(mediaInstanceUrl.urls));

                    List<List<String>> listOfUrlList = new List<List<string>>(query);

                    if (query != null)
                    {
                        for (int count = 0; count < listOfUrlList.Count; count++)
                        {
                            mediaAssets.mediaAssets[count].MediaInstanceUrls = listOfUrlList[count].ToList();
                        }
                    }

                }
                catch (Exception ex)
                {
                    Logging.WriteEvent(new PdlcServiceUnknownErrorEvent(), ex);
                }
            }

        }

        private static List<String> GetUrlsFromTypedMediaUrlsObject(TypedMediaUrl[] typedMediaUrlArray)
        {
            if (typedMediaUrlArray != null)
            {
                var query = from ty in typedMediaUrlArray
                            select ty.url;

                return new List<String>(query);
            }
            else
            {
                return new List<string>();
            }
        }

        //Serializes MediaAssets to XmlDocument
        private static XmlDocument SerializeMediaAssets(MediaAssets mediaAssets)
        {
            Debug.Assert(mediaAssets != null);

            //serialize MediaAssets into a stream
            DataContractSerializer sz = new DataContractSerializer(typeof(MediaAssets));
            MemoryStream stream = new MemoryStream();
            XmlTextWriter xw = new XmlTextWriter(stream, Encoding.Unicode);
            sz.WriteObject(xw, mediaAssets);
            xw.Flush();

            //load the stream in the XmlDocument
            stream.Position = 0;
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.PreserveWhitespace = true;
            xmlDocument.Load(stream);

            xw.Close(); //this should also close the enclosing stream
            return xmlDocument;
        }
    
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\ReceiptsHelper.cs ===
﻿
namespace XboxLive.PDLC.Service
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Xml;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.Account;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Utils;
    using XboxLive.PDLC.Service.Contracts;
    using xonline.common.protocol;

    /// <summary>
    /// Helper class for Receipts
    /// </summary>
    public static class ReceiptsHelper
    {
        static IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

        /// <summary>
        /// Converts a GetReceipts resquest to a LiveCache billing wrapper request and queries live cache billing for purchase receipts for a user(livePuid)
        /// </summary>
        /// <param name="receiptsRequest">Request from client.</param>
        /// <param name="livePuid">The calling gamer's XBL xuid.</param>
        /// <param name="locale">The calling gamer's legal locale.</param>
        /// <param name="partnerId">The calling gamer's PartnerId.</param>
        /// <returns>PurchaseReceipts Serialized to xml wrapped by an XmlDocument . If ReceiptRequest.SignReceipts is true then includes the xml signature</returns>
        /// <exception cref="ArgumentNullException">if receiptsRequest Object is null or locale is null or empty</exception>
        public static XmlDocument GetPurchaseReceipts(
            ReceiptRequest receiptsRequest, 
            ulong livePuid, 
            string locale,
            ulong partnerId)
        {
            if (receiptsRequest == null)
            {
                throw new ArgumentNullException("receiptsRequest");
            }

            if (string.IsNullOrEmpty(locale))
            {
                throw new ArgumentNullException("locale");
            }
                        
            PurchaseReceipts pagedReceipts = new PurchaseReceipts();
            
            //check if we need to mask the incoming titleId
            uint resolvedTitleId = receiptsRequest.TitleId;
            if (IsTitleIdToBeMasked(receiptsRequest.TitleId))
            {
                uint.TryParse(config.GetSetting(Settings.Pdlc_GetPurchaseHistoryMaskingTitle), 
                    System.Globalization.NumberStyles.HexNumber, 
                    System.Globalization.CultureInfo.CurrentUICulture,
                    out resolvedTitleId); //mask the titleId with console marketplace titleId

                Debug.Assert(resolvedTitleId > 0); //making sure that the masking titleId is not well formed and the TryParse fails
            }

            // create a purchase history request object
            PurchaseHistoryRequest phRequest = new PurchaseHistoryRequest()
            {
                StartDate = (String.IsNullOrEmpty(receiptsRequest.StartDate))? DateTime.MinValue.ToUniversalTime() 
                                                                                : DateTime.Parse(receiptsRequest.StartDate),
                Direction = PurchaseHistoryRequest.OrderDirection.Descending,
                LivePuid = livePuid,
                Locale = locale,
                MediaType = receiptsRequest.MediaTypeId == 0 ? (MediaTypes.MobilePdlc) : (MediaTypes)receiptsRequest.MediaTypeId,
                OrderBy = PurchaseHistoryRequest.OrderHistoryBy.DateOfTransaction,
                PageNum = receiptsRequest.PageNumber,
                PageSize = receiptsRequest.PageSize,
                Store = receiptsRequest.StoreId == 0 ? (PurchaseHistoryRequest.MarketplaceStore.Mobile) : (PurchaseHistoryRequest.MarketplaceStore)receiptsRequest.StoreId,
                TitleId = resolvedTitleId,
                View = PurchaseHistoryRequest.DetailView.Ultimate
            };

            if (receiptsRequest.TransactionIds != null && receiptsRequest.TransactionIds.Length > 0)
            {
                phRequest.TransactionIDs.AddRange(receiptsRequest.TransactionIds);
            }

            // call live cache billing wrapper for receipts
            IBillingOfferingDataAccess billingOffering = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
            PurchaseHistoryResponse phResponse = billingOffering.GetPurchaseHistory(phRequest);
            
            // convert the response to PurchaseReceipts response.
            if (phResponse != null)
            {
                pagedReceipts.TotalItems = phResponse.TotalItems;

                List<PurchaseReceipt> receiptList = new List<PurchaseReceipt>();
            
                if (phResponse.PurchaseHistoryEntries != null)
                {
                    Dictionary<PurchaseReceipt, IList<IMediaInstance>> mediaInstancesHash = new Dictionary<PurchaseReceipt, IList<IMediaInstance>>(phResponse.PurchaseHistoryEntries.Count);
                    foreach (PurchaseHistoryEntry entry in phResponse.PurchaseHistoryEntries)
                    {
                        PurchaseReceipt pr = new PurchaseReceipt();
                        pr.PurchaseDate = entry.TheOffer.PurchaseDate.ToUniversalTime();
                        pr.TransactionId = entry.TheOffer.TransactionId;
                        pr.OfferId = entry.OfferId;
                        pr.PurchasingPartnerId = partnerId;
                        pr.Title = entry.Title;
                        mediaInstancesHash.Add(pr, entry.MediaInstances);
                        receiptList.Add(pr);
                    }

                    //Fill all mediaInstanceUrls with one call to the back end
                    FillMediaInstanceUrls(mediaInstancesHash);
                }
                
                pagedReceipts.ReceiptsPage = receiptList.ToArray();
            }

            XmlDocument serializedReceipts = SerializeReceipts(pagedReceipts);
            
            // sign the xml if SignReceipts is true
            if (receiptsRequest.SignReceipts)
            {
                string certificateSubjectName = config.GetSetting(Settings.PDLCResponseSigningCertSubjectName);
                XmlDocument envelopedXml = null;
                XmlSignature.GetSignedXml(serializedReceipts, certificateSubjectName, out envelopedXml);
                return envelopedXml;
            }

            return serializedReceipts;
        }

        /// <summary>
        /// Serializes PurchaseReceipts to XmlDocument using the DataContract Serializer
        /// </summary>
        /// <param name="purchaseReceipts">Receipts to be serialized.</param>
        /// <returns>the serialized receipts as XML Document</returns>
        private static XmlDocument SerializeReceipts(PurchaseReceipts purchaseReceipts)
        {
            Debug.Assert(purchaseReceipts != null);

            //serialize PurchaseReceipts into a stream
            DataContractSerializer sz = new DataContractSerializer(typeof(PurchaseReceipts));
            MemoryStream stream = new MemoryStream();
            XmlTextWriter xw = new XmlTextWriter(stream, Encoding.Unicode);
            sz.WriteObject(xw, purchaseReceipts);
            xw.Flush();
            //load the stream in the XmlDocument
            stream.Position = 0;
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.PreserveWhitespace = true;
            xmlDocument.Load(stream);

            xw.Close(); //this should also close the enclosing stream
            return xmlDocument;
        }

        /// <summary>
        /// Queries LiveCache wrapper for Media Instance Urls for a list of IMedisInstance
        /// </summary>
        /// <param name="mediaInstanceIdList">The list of media instance Ids to get download URLs.</param>
        /// <returns>The list of URLs for the requested media instances.</returns>
        private static List<string> GetMediaInstanceUrlsFromMediaInstanceIds(IList<IMediaInstance> mediaInstanceIdList)
        {
            List<string> mediaInstanceUrls = null;
            if (mediaInstanceIdList != null && mediaInstanceIdList.Count > 0)
            {
                IBillingOfferingDataAccess billingOffering = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
                var mediaInstanceIdArray = mediaInstanceIdList.Select(iMediaInstance => iMediaInstance.InstanceId).ToArray();
                mediaInstanceUrls = billingOffering.GetMediaInstanceUrls(mediaInstanceIdArray)
                    .Where(mediaInstanceUrl => (mediaInstanceUrl.urls != null) && (mediaInstanceUrl.urls.Count() != 0))
                    .Select(mediaInstanceUrl => mediaInstanceUrl.urls[0].url).ToList();
            }

            return mediaInstanceUrls;
        }

        private static void FillMediaInstanceUrls(Dictionary<PurchaseReceipt, IList<IMediaInstance>> mediaInstancesHash)
        {
            var allMediaInstanceIdsList = new List<IMediaInstance>();

            //collect all the mediaInstanceIds from all the receipts
            foreach (var pReceipt in mediaInstancesHash.Keys)
            {
                allMediaInstanceIdsList.AddRange(mediaInstancesHash[pReceipt]);
            }

            //make one call to the get the media Instance Urls
            List<String> allMediaInstanceUrls = GetMediaInstanceUrlsFromMediaInstanceIds(allMediaInstanceIdsList);

            //we have one to one mapping between the mediaInstanceIds and the list of urls returned (this is back end commitment)
            if (allMediaInstanceUrls != null && allMediaInstanceUrls.Count > 0)
            {
                //we need to track how many urls to fit into each purchase receipt (we will use the count of the mediaInstanceId list)
                Int32 trackingIndex = 0;
                foreach (var pReceipt in mediaInstancesHash.Keys)
                {
                    pReceipt.MediaInstanceURLs = allMediaInstanceUrls.GetRange(trackingIndex,
                                                                               mediaInstancesHash[pReceipt].Count);
                    trackingIndex += mediaInstancesHash[pReceipt].Count; //move the tracking index to point ehere the meadiaInstanceUrl of the next receipt starts
                }
            }
        }

        private static bool IsTitleIdToBeMasked(uint requestTitleId)
        {
            String[] maskedTitles = config.GetMultiSetting(MultiSettings.Pdlc_GetPurchaseHistoryMaskedTitles);
            if (maskedTitles != null && maskedTitles.Length > 0)
            {
                for (Int32 count = 0; count < maskedTitles.Length; count++)
                {
                    UInt32 maskedTitleID = 0;
                    if (UInt32.TryParse(maskedTitles[count], System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.CurrentUICulture, out maskedTitleID) &&
                        maskedTitleID == requestTitleId)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\Diagnostics\PdlcEvents.cs ===
﻿using System;
namespace XboxLive.PDLC.Service
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public class PdlcServiceStartupEvent : BaseEvent
    {
        public PdlcServiceStartupEvent() :
            base(1000, TraceEventType.Start, "The Pdlc Service has started")
        { }
    }

    public class PdlcServiceShutdownEvent : BaseEvent
    {
        public PdlcServiceShutdownEvent() :

            base(1001, TraceEventType.Stop, "The Pdlc Service has stopped")
        { }
    }

    public class LiveServiceUnavailableEvent : BaseEvent
    {
        const string msg = "LiveCache threw ServiceUnavailable exception!";
        public LiveServiceUnavailableEvent()
            : base(1002, TraceEventType.Critical, msg)
        { }
    }

    public class LiveServiceThrottledEvent : BaseEvent
    {
        const string msg = "LiveCache calls are being throttled!";
        public LiveServiceThrottledEvent()
            : base(1003, TraceEventType.Critical, msg)
        { }
    }

    public class LiveServiceConfigErrorEvent : BaseEvent
    {
        const string msg = "LiveCache configuration error!";
        public LiveServiceConfigErrorEvent()
            : base(1004, TraceEventType.Error, msg)
        { }

    }

    public class LivenNpdbExceptionEvent : BaseEvent
    {
        const string msg = "GetSettings from LiveN NPDB returned an exception!";
        public LivenNpdbExceptionEvent()
            : base(1005, TraceEventType.Critical, msg)
        { }
    }

    public class LiveServiceResponseErrorEvent : BaseEvent
    {
        const string msg = "LiveCache Response error!";
        public LiveServiceResponseErrorEvent()
            : base(1006, TraceEventType.Error, msg)
        { }

    }

    public class XblmMarketplaceAccessErrorEvent : BaseEvent
    { 
        public XblmMarketplaceAccessErrorEvent()
            : base(1007, TraceEventType.Error, "Error querying Xblm Marketplace catalog")
        { }
    }

    public class PdlcServiceUnknownErrorEvent : BaseEvent
    {
        const string msg = "Pdlc Unknown Error";
        public PdlcServiceUnknownErrorEvent()
            : base(1100, TraceEventType.Error, msg)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\Diagnostics\PdlcServiceErrorMessage.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="PdlcServiceErrorMessage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC Service error messages
// </summary>
//
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using xonline.common.service;

    /// <summary>
    /// Custom Error buckets for PDLC/XBL/XBLM errors
    /// </summary>
    public enum ServiceErrorBucket : uint
    {
        /// <summary>
        ///  Unknown errors/buckets.
        /// </summary>
        Unknown = 0,

        /// <summary>
        ///  Errors that indicate a temporary server error.
        /// </summary>
        TryAgainLater = 1,

        /// <summary>
        ///  Errors that indicate a stale cache on client side.
        /// </summary>
        TryAgainRefresh = 2,

        /// <summary>
        ///  Errors that indicate a problem with the current gamer account.
        /// </summary>
        AccountSetting = 3,

        /// <summary>
        ///  Errors that indicate not enough points for a purchase.
        /// </summary>
        NotEnoughPoints = 4,

        /// <summary>
        ///  Errors that indicate the offer to purchase is not valid for the gamer.
        /// </summary>
        OfferNotPurchasable = 5,

        /// <summary>
        ///  Errors that indicate one or more input parameters from XNA client are invalid .
        /// </summary>
        InputArguments = 6,

        /// <summary>
        ///  Errors that indicate at least one asset to consume is invalid, or low balance.
        /// </summary>
        AssetBalance = 7,

        /// <summary>
        ///  Errors that indicate the token cannot be redeemed.
        /// </summary>
        TokenNotRedeemable = 8,
    }

    /// <summary>
    /// Custom Error Message for PDLC Service
    /// </summary>
    [DataContract(Name = "PdlcServiceErrorMessage", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class PdlcServiceErrorMessage
    {
        /// <summary>
        /// Static container that has the mapping from error codes to buckets
        /// </summary>
        private static Dictionary<uint, ServiceErrorBucket> errorBucketMap = new Dictionary<uint, ServiceErrorBucket>()
        {
            // TryAgainLater bucket
            { HResult.XONLINE_E_DMP_E_UNKNOWN_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_DMP_E_UNKNOWNSERVER_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_DMP_E_SYSTEM_INTERNAL_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_DMP_E_MAX_CONSUMPTION_EXCEEDED, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_MULTI_PURCHASE_INVALID_PAYMENT_TYPE, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_FINBUS_SQL_TRANSACTION_FAILED, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_DATABASE_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_DATABASE_EXECUTE_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_TRACKED_API_DATABASE_ERROR, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_PURCHASE_PENDING, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER, ServiceErrorBucket.TryAgainLater },
            { HResult.XONLINE_E_OFFERING_ASSET_CONSUME_ERROR, ServiceErrorBucket.TryAgainLater },
            { PdlcErrors.PDLC_E_UNSPECIFIED_ERROR, ServiceErrorBucket.TryAgainLater },
            { PdlcErrors.PDLC_E_XBL_SERVICE_UNAVAILABLE, ServiceErrorBucket.TryAgainLater },
            { PdlcErrors.PDLC_E_XBL_CALLS_THROTTLED, ServiceErrorBucket.TryAgainLater },
            { PdlcErrors.PDLC_E_LIVEN_NPDB_EXCEPTION, ServiceErrorBucket.TryAgainLater },
            { PdlcErrors.PDLC_E_NO_PURCHASE_ENTRY_FOR_TRANSACTION, ServiceErrorBucket.TryAgainLater },
            { PdlcErrors.PDLC_E_PURCHASE_SUCCEEDED_RECEIPT_UNAVAILABLE, ServiceErrorBucket.TryAgainLater },

            // TryAgainRefresh bucket
            { HResult.XONLINE_E_OFFERING_PRICE_CHANGED, ServiceErrorBucket.TryAgainRefresh },

            // NotEnoughPoints bucket
            { HResult.XONLINE_E_DMP_E_INSUFFICIENT_BALANCE, ServiceErrorBucket.NotEnoughPoints },

            // OfferNotPurchasable bucket
            { HResult.XONLINE_E_GEO_DENIED, ServiceErrorBucket.OfferNotPurchasable },
            { HResult.XONLINE_E_MEDIA_INSTANCE_NOT_ACQUIRABLE, ServiceErrorBucket.OfferNotPurchasable },
            { HResult.XONLINE_E_OFFERING_ALREADY_OWN_MAX, ServiceErrorBucket.OfferNotPurchasable },
            { HResult.XONLINE_E_OFFERING_INVALID_OFFER_ID, ServiceErrorBucket.OfferNotPurchasable },
            { HResult.XONLINE_E_BILLING_CHILD_CONTENT_PURCHASE_NOT_ALLOWED, ServiceErrorBucket.OfferNotPurchasable },
            { HResult.XONLINE_E_ACCOUNTS_NOT_XENON_USER, ServiceErrorBucket.OfferNotPurchasable },
            { HResult.XOFF_E_OFFER_EXPIRED, ServiceErrorBucket.OfferNotPurchasable },

            // AssetBalance bucket
            { HResult.XONLINE_E_OFFERING_INVALID_CONSUME_ITEMS, ServiceErrorBucket.AssetBalance },

            // TokenNotRedeemable
            { HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, ServiceErrorBucket.TokenNotRedeemable },
            { HResult.XOFF_E_INELIGIBLE_FOR_OFFER, ServiceErrorBucket.TokenNotRedeemable },
            { HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE, ServiceErrorBucket.TokenNotRedeemable },
            { HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED, ServiceErrorBucket.TokenNotRedeemable },

            // InputArguments bucket
            { HResult.E_INVALIDARG, ServiceErrorBucket.InputArguments },
            { HResult.XONLINE_E_TRACKED_API_DUPLICATE_TRACKING_GUID, ServiceErrorBucket.InputArguments },
            { PdlcErrors.PDLC_E_INVALID_PARAMETER, ServiceErrorBucket.InputArguments },
            { PdlcErrors.PDLC_E_LEGAL_LOCALE_NOT_SUPPORTED, ServiceErrorBucket.InputArguments },
            { PdlcErrors.PDLC_E_USER_NOT_AUTHENTICATED, ServiceErrorBucket.InputArguments },
            { PdlcErrors.PDLC_E_TITLE_ID_MISSING_IN_PARTNER_TOKEN, ServiceErrorBucket.InputArguments },
            { PdlcErrors.PDLC_E_TITLE_ID_WRONG_FORMAT_IN_PARTNER_TOKEN, ServiceErrorBucket.InputArguments },
        };

        /// <summary>
        /// Initializes a new instance of the PdlcServiceErrorMessage class.
        /// </summary>
        public PdlcServiceErrorMessage()
        {
            this.Bucket = ServiceErrorBucket.Unknown;
            this.ErrorCode = PdlcErrors.PDLC_E_UNSPECIFIED_ERROR;
            this.ErrorMessage = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the PdlcServiceErrorMessage class.
        /// </summary>
        /// <param name="errorCode">The error code from PDLC, XBL, or XBLM.</param>
        /// <param name="errorMessage">A short description of the error.</param>
        public PdlcServiceErrorMessage(uint errorCode, string errorMessage)
        {
            this.ErrorCode = errorCode;
            this.ErrorMessage = errorMessage;
            if (PdlcServiceErrorMessage.errorBucketMap.ContainsKey(errorCode))
            {
                this.Bucket = PdlcServiceErrorMessage.errorBucketMap[errorCode];
            }
            else
            {
                this.Bucket = ServiceErrorBucket.Unknown;
            }
        }

        /// <summary>
        /// Gets or sets the error bucket
        /// </summary>
        [DataMember(Name = "Bucket", Order = 1, IsRequired = true)]
        public ServiceErrorBucket Bucket { get; set; }

        /// <summary>
        /// Gets or sets the error code
        /// </summary>
        [DataMember(Name = "ErrorCode", Order = 2, IsRequired = true)]
        public uint ErrorCode { get; set; }

        /// <summary>
        /// Gets or sets the error message
        /// </summary>
        [DataMember(Name = "ErrorMessage", Order = 3, IsRequired = true)]
        public string ErrorMessage { get; set; }

        /// <summary>
        /// Initializes a new instance of the PdlcServiceErrorMessage class.
        /// </summary>
        /// <param name="errorCode">The error code from PDLC, XBL, or XBLM.</param>
        /// <returns>True if the error is an internal server.</returns>
        public static bool IsServerError(uint errorCode)
        {
            if (PdlcServiceErrorMessage.errorBucketMap.ContainsKey(errorCode))
            {
                ServiceErrorBucket bucket = PdlcServiceErrorMessage.errorBucketMap[errorCode];
                if ((bucket == ServiceErrorBucket.TryAgainLater) ||
                    (bucket == ServiceErrorBucket.Unknown))
                {
                    return true;
                }
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PdlcServiceLibrary")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
[assembly: System.CLSCompliant(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Pdlc\PdlcServiceLibrary\Diagnostics\PdlcErrors.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="PdlcError.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PDLC error definition.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="11/03/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace XboxLive.PDLC.Service
{
    /// <summary>
    /// Pdlc defined error code wrapped by ServiceErrorMessage and returned to client. 
    /// </summary>
    public sealed class PdlcErrors
    {
        private PdlcErrors()
        { }
        private const uint PDLC_FACILITY_PREFIX = 0x80080000;
        private const uint PDLC_ERROR_BASE = 0x6000;

        public const uint PDLC_E_UNSPECIFIED_ERROR                      = 0x80086000;
        public const uint PDLC_E_INVALID_PARAMETER                      = 0x80086001;
        public const uint PDLC_E_LEGAL_LOCALE_NOT_SUPPORTED             = 0x80086002;
        public const uint PDLC_E_USER_NOT_AUTHENTICATED                 = 0x80086003;
        public const uint PDLC_E_TITLE_ID_MISSING_IN_PARTNER_TOKEN      = 0x80086004;
        public const uint PDLC_E_TITLE_ID_WRONG_FORMAT_IN_PARTNER_TOKEN = 0x80086005;
        public const uint PDLC_E_XBL_SERVICE_UNAVAILABLE                = 0x80086006;
        public const uint PDLC_E_XBL_CALLS_THROTTLED                    = 0x80086007;
        public const uint PDLC_E_LIVEN_NPDB_EXCEPTION                   = 0x80086008;
        public const uint PDLC_E_NO_PURCHASE_ENTRY_FOR_TRANSACTION      = 0x80086009;
        public const uint PDLC_E_PURCHASE_SUCCEEDED_RECEIPT_UNAVAILABLE = 0x8008600A;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\AutoSubmit.cs ===
using System;
using System.IO;
using System.Collections.Generic;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Create a submission to Codesign.Net.
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class CodesignSubmission
    {
        public int CreateSubmission(string file, IList<string> signers, string largeFileCertID, string normalFileCertID, string strongNameCertID, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            CODESIGN.Submitter.Job job = null;
            try 
            {
                Log.WriteLog("Submitting {0} for CodeSign...", Path.GetFileName(file));
                //Initialize the Codesign.Submitter object
                //"Codesign" represents the server - constant value do not change
                //9556 represents the port - constant value do not change
                job = CODESIGN.Submitter.Job.Initialize("codesign.gtm.microsoft.com", 9556, true); 
                                
                // Sets the Partial return flag option.
                // False - If any files fail signing you will not get any files back.
                // True - Only retrieve successfully signed files.
                job.IsAllowReturnPartial = true;            // default is false

                // This is reference information that can be displayed or used in searches
                job.Description = "Job Description - a way to make it easier to associate jobs";
                job.Keywords = "Keywords to improve searches";

                // This call selects a certificate from the ones allowed for this user
                // You may pick only one Authenticode certificate
                // You may pick only one Strong Name certificate
                // You may pick an Authenticode and Strong Name certificate at the same time
                // Example:
                FileInfo info = new FileInfo(file);
                if (info.Length > 524288000)
                {
                    job.SelectCertificate(largeFileCertID);   // You must have permissions to the requested cert
                }
                else
                {
                    job.SelectCertificate(normalFileCertID);   // You must have permissions to the requested cert
                    if (strongNameCertID != @"")
                    {
                        job.SelectCertificate(strongNameCertID);   // You must have permissions to the requested cert
                    }
                }
                
                // This will populate the approvers to the job
                // NOTE: these users are invalid, must substitute real user aliases who are authorized for approval
                // You need at minimum two approvers - you may add as many as necessary
                // Approvers must be entered in the system to approve jobs
                // Approvers CANNOT be the job submitter
                foreach (string strSigner in signers)
                {
                    job.AddApprover(strSigner);
                }

                // These calls add notification subscriptions to the job. A number of others are 
                // available, these are the standard ones.
                // Check the CODESIGN.NotificationEventTypeEnum enumaration for a complete list.
                //job.SetNotification(job.Submitter, new CODESIGN.NotificationEventTypeEnum[] {CODESIGN.NotificationEventTypeEnum.JobCompletionFailure,CODESIGN.NotificationEventTypeEnum.JobCompletionSuccess,CODESIGN.NotificationEventTypeEnum.JobVirusScanFailure});


                // This call adds an entire directory tree to the job, duplicating its structure in
                // the submission share and making all metadata the same for each file.
                job.AddFile(file, "CodeSign", "http://CodeSignInfo", CODESIGN.JavaPermissionsTypeEnum.None);

                // This call sends the job to the back end for processing
                job.Send();

                Log.WriteLog("Submitting {0} finished", Path.GetFileName(file));
                // This call displays the job number, assigned during the send process
                Log.WriteLog("Job Number is: {0}", job.JobNumber);
                Log.WriteLog("Job Completion Path is: {0}", job.JobCompletionPath);
                if (jobList != null)
                {
                    jobList.Add(job);
                }
            }
            catch (Exception exc)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(exc));
                if (job != null)
                {
                    foreach(CODESIGN.Submitter.JobError je in job.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\makefile.inc ===
#{$(OBJ_PATH)\$O}.resx {$(OBJ_PATH)\$O}.resources:
#    resgen.exe $< $@
#    move $@ $(OBJ_PATH)\$(O)


$(OBJ_PATH)\$(O)\Lfit.ico : Lfit.ico
  copy $** $(OBJ_PATH)\$(O)\Lfit.ico
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\JobWatcher.cs ===
using System;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Monitor a job until completionsubmission
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class Watcher
    {
        /// <summary>
        /// The main method
        /// </summary>
        public static int Monitor(string strJobNumber)
        {
            int ret = 0;
            //Check if user passed the job number in the parameters

            //Jobwatcher instance, still null here
            CODESIGN.Submitter.JobWatcher jw = null;

            try
            {
                //Instantiate new JobWatcher object
                jw = new CODESIGN.Submitter.JobWatcher();

                // This call waits until the job is finished
                //jw.Watch(JobNumber, RelayServer, RelayPort, IsSSL);
                jw.Watch(strJobNumber, "codesign.gtm.microsoft.com", 9556, true);

                if (jw.IsDone)
                {
                    // Now we're done, so display any errors or warnings (in case we are in non-event mode)
                    Log.WriteLog("Job is finished, Success={0}  Signed={1}  BytesSigned={2}", jw.IsSuccess, jw.TotalSigned, jw.TotalByteSize);
                    if (!jw.IsSuccess)
                    {
                        ret = -1;
                    }
                    if (jw.IsPartial)
                    {
                        Log.WriteLog("Partial Success: {0}", jw.IsPartial);
                    }
                    //Display errors
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                    //Display failed files
                    foreach (CODESIGN.Submitter.JobFile jf in jw.FailedFileList.Values)
                    {
                        Log.WriteLog("Failed -> " + jf.FileFullPath);
                    }
                }
                else
                {
                    Log.WriteLog("Job {0} is still being processed!", strJobNumber);
                }

            }
            catch (Exception ex)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(ex));
                if (jw != null)
                {
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Log.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public static class Log
    {
        private static bool quiet;
        private static bool exceptionCaught;
        private static string logFileName;

        static Log()
        {
            try
            {
                logFileName = Path.Combine(Directory.GetCurrentDirectory(), @"log.txt");
                StreamWriter SW;
                SW = File.CreateText(logFileName);
                SW.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
        public static bool ExceptionCaught
        {
            get { return exceptionCaught; }
            set { exceptionCaught = value; }
        }

        public static bool Quiet
        {
            get { return quiet; }
            set { quiet = value; }
        }

        public static void WriteLog(string line)
        {
            if (!quiet)
            {
                Console.WriteLine(line);

                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + line);
                SW.Close();
            }
        }

        public static void WriteLog(string format, object arg0)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg0);

                string str = string.Format(format, arg0);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();

            }
        }
        public static void WriteLog(string format, params object[] arg)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg);
                string str = string.Format(format, arg);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Program.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Security.Permissions;
using Microsoft.Deployment.Compression;
using Microsoft.Deployment.Compression.Zip;
using Microsoft.Deployment.Compression.Cab;

namespace Microsoft.LFIT
{
    class Program
    {
        static string strTempManifestCabPath;

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static void Run(string[] args)
        {
            Settings settings = new Settings();

            // Parse command line
            try
            {
                settings.ParseCommandLine(args);
            }
            catch (System.ArgumentException ex)
            {
                Log.ExceptionCaught = true;
                if (ex.ParamName != "-?")
                {
                    Log.WriteLog("Error: " + ex.Message);
                }

                Settings.DisplayUsage();
                throw;
            }

            Log.Quiet = settings.Quiet;

            // justify the input
            switch (settings.InputCommand)
            {
                case Command.All:
                    {
                        try
                        {
                            CreateCabFiles(settings);
/*
                            IList<CODESIGN.Submitter.Job> jobList = new List<CODESIGN.Submitter.Job>();

                            if (CodeSignSubmitCabs(settings, jobList) == 0)
                            {
                                CodeSignJobCheck(settings, jobList);
                                Log.WriteLog("LFIT job finished");
                            }
                            else
                            {
                                Log.WriteLog("LFIT job failed");
                            }
 */ 
                        }
                        catch (System.Exception)
                        {
                            Log.WriteLog("LFIT job failed");
                            throw;
                        }
                        break;
                    }
                case Command.Create:
                    {
                        CreateCabFiles(settings);
                        CopyCabsFromTempFolder(settings);
                        break;
                    }

                case Command.Submit:
                    {
                        //CodeSignSubmitFile(settings);
                        break;
                    }

                case Command.Check:
                    {
                        //CodeSignOneJobCheck(settings.CodeSignJobNumber);
                        break;
                    }

                default:
                        break;
            }

        }

        private static int CreateCabFiles(Settings settings)
        {
            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting " + settings.TempDirectory + @"...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting " + settings.TempDirectory + @" finished");
                }
                catch (System.IO.IOException)
                {
                    throw;
                }
            }

            if( !Directory.Exists(settings.InputFolder))
            {
                throw new System.IO.FileNotFoundException("Input folder not found", settings.InputFolder);
            }

/*
            string strUnZipFolder = Path.Combine(settings.TempDirectory, @"UnZipFiles");
            ZipInfo zip = new ZipInfo(settings.ZipFilePath);
            Log.WriteLog("Unzipping " + settings.ZipFilePath + "...");
            zip.Unpack(strUnZipFolder);
            Log.WriteLog("Unzipping finished");
*/ 

            long totalInstallSize = 0;
            CreateContentCabs(settings, settings.InputFolder, ref totalInstallSize);
            CreateManifestCab(settings, totalInstallSize);

            return 0;
        }

        private static int CreateContentCabs(Settings settings, string strUnZipFolder, ref long totalInstallSize)
        {
            CreateContentXbx(settings, settings.InputFolder);

            // Re-pack the file to CAB files ( < 2.0 G)
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            Directory.CreateDirectory(strCabFileFolder);
            string strCabName = Path.Combine(strCabFileFolder, settings.ContentID);

            totalInstallSize = 0;
            IList<string> fileList = new List<string>();
            RecursiveGetFilePathsInDirectoryTree(strUnZipFolder, true, fileList);

            foreach (string file in fileList)
            {
                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(file);
                totalInstallSize += info.Length;
            }

            IList<string> archiveFiles = new List<string>();
            long maxVolumNum = totalInstallSize / settings.MaxCabSize + 1;
            for (int i = 1; i <= maxVolumNum; i++)
            {
                archiveFiles.Add(strCabName + string.Format("_{0}.cab", i));
            }
            //Create cab files 
            CabInfo cab = new CabInfo(strCabName);

            Log.WriteLog("Compressing content cab files for " + strUnZipFolder + "...");
            cab.Pack(archiveFiles, strUnZipFolder, true, (CompressionLevel)settings.CompressionLevel, null, settings.MaxCabSize);
            Log.WriteLog("Compressing content cab files finished");
            
            return 0;
        }

        private static int CreateManifestCab(Settings settings, long totalInstallSize)
        {
            Log.WriteLog("Creating manifest.cab...");
            string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
            Directory.CreateDirectory(strManifestFolder);
            string contentFolder = Path.Combine(strManifestFolder, @"Content");
            Directory.CreateDirectory(contentFolder);

            string srcXbx = Path.Combine(settings.InputFolder, @"content.xbx");
            string destXbx = Path.Combine(strManifestFolder, @"content.xbx");
            File.Copy(srcXbx, destXbx);
            Log.WriteLog("Copied content.xbx from " + srcXbx + " to " + destXbx);

            // Create manifest file
            string strManifestFileName = Path.Combine(contentFolder, @"OfferManifest.xml");
            Manifest manifest = new Manifest();
            manifest.NewFile();
            manifest.CabFolder = Path.Combine(settings.TempDirectory, @"cabs");
            manifest.InstallSize = totalInstallSize;
            manifest.TitleId = settings.TitleID;
            manifest.LinkURL = settings.ContentURL;
            string log = manifest.SaveFile(strManifestFileName);
            Log.WriteLog(log);

            // Pack content.xbx and manifest file
            strTempManifestCabPath = Path.Combine(strManifestFolder, settings.ContentID + @"_Manifest.cab");
            CabInfo cabManifest = new CabInfo(strTempManifestCabPath);
            cabManifest.Pack(strManifestFolder, true, (CompressionLevel)settings.CompressionLevel, null);
            Log.WriteLog("Creating " + strTempManifestCabPath + " finished");

            return 0;
        }

        private static string CreateContentXbx(Settings settings, string strFolder)
        {
            // Create content.xbx
            // Create an instance of StreamWriter to write text to a file.
            // The using statement also closes the StreamWriter.
            string stringContentXbxFileName = Path.Combine(strFolder, @"content.xbx");

            if (settings.Nooverwritexbx)
            {
                if (!File.Exists(stringContentXbxFileName))
                {
                    throw new System.IO.FileNotFoundException("Error: content.xbx not found", stringContentXbxFileName);
                }
                else
                {
                    Log.WriteLog("Using content.xbx at " + stringContentXbxFileName);
                }
            }
            else
            {
                using (StreamWriter sw = new StreamWriter(stringContentXbxFileName, false, Encoding.Unicode))
                {
                    // Add some text to the file.
                    sw.WriteLine(";");
                    sw.WriteLine("; GFWL Submission Metadata File -- Generated by LFIT.exe on " + DateTime.Now.ToShortDateString());
                    sw.WriteLine(";");
                    sw.WriteLine("; Copyright (c) Microsoft Corporation");
                    sw.WriteLine(";");
                    sw.WriteLine("");

                    sw.WriteLine("[All]");
                    sw.WriteLine("Premium=No");
                    sw.WriteLine("TitleID=0x" + settings.TitleID);
                    sw.WriteLine("ContentPackageType=" + settings.ContentType);
                    sw.WriteLine("LicenseBits=0x00000000");
                    sw.WriteLine("BaseVersion=0x00000000");
                    sw.WriteLine("UpdateVersion=0x00000000");
                    sw.WriteLine("ThumbnailImage=\"generic.PNG\"");
                    sw.WriteLine("OfferingID=0x" + settings.OfferID);
                    sw.WriteLine("AdminFriendlyName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("TitleName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("PurchaseOnceOnly=Yes");
                    sw.WriteLine("ContentFlags=0xC0");
                    sw.WriteLine("ContentID=" + settings.ContentID);
                    sw.WriteLine("Platform=0x10");
                    sw.WriteLine("BitFlags=0xFFFFFFFF");
                    sw.WriteLine("ActivationDate=" + DateTime.Now.ToShortDateString());
                    sw.WriteLine("DefaultDisplayName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("OfferRegions.0=103,0,0,TaxNotApplicable");
                    if (string.Compare(settings.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=Content");
                    }
                    else if (string.Compare(settings.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=FullGame");
                    }
                    sw.WriteLine("EndDate=12/31/2999");
                    sw.WriteLine("DisplayInDash=Yes");
                    sw.WriteLine("Version=0x00020001");
                    sw.WriteLine("DashDisplayName.0=EN,\"This is LFIT.exe generic text\"");
                    sw.WriteLine("DashDescription.0=EN,\"This is LFIT.exe generic text\"");
                }
                Log.WriteLog("Saved content.xbx at " + stringContentXbxFileName);
            }

            return stringContentXbxFileName;
        }
/*
        private static int CodeSignSubmitFile(Settings settings)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                ret = codeSignSubmission.CreateSubmission(settings.CodeSignFileName, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, null);
                if (ret == 0)
                {
                    Log.WriteLog("CodeSign submission succeeded. please limit the submission less than 6G per hour before the next submission");
                }
                else
                {
                    Log.WriteLog("CodeSign submission failed.");
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignSubmitCabs(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                foreach (string file in Directory.GetFiles(strCabFileFolder))
                {
                    ret = codeSignSubmission.CreateSubmission(file, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                    if (ret == 0)
                    {
                        Log.WriteLog("Waiting 20 minutes to start submitting next job...");
                        System.Threading.Thread.Sleep(1200000);         // 20 minutes
                    }
                    else
                    {
                        break;
                    }
                }

                // Codesigne manifest.cab
                if (ret == 0)
                {
                    string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
                    string strManifesCabFile = Path.Combine(strManifestFolder, @"Manifest.cab");
                    ret = codeSignSubmission.CreateSubmission(strManifesCabFile, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        } 
        private static int CodeSignOneJobCheck(string jobNumber)
        {
            int ret = 0;
            try
            {
                    Log.WriteLog("Waiting for  CodeSign result. Job Number = {0}...", jobNumber);
                    if (Watcher.Monitor(jobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", jobNumber);
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", jobNumber);
                        ret = -1;
                    }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignJobCheck(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                Log.WriteLog("Waiting for content cab files CodeSign result...");
                foreach (CODESIGN.Submitter.Job job in jobList)
                {
                    string file = Path.GetFileName(job.FileList.Values[0].ToString());
                    Log.WriteLog("Waiting for {0} CodeSign result...", file);
                    if (Watcher.Monitor(job.JobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", file);

                        if (string.Compare(file, "manifest.cab", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                        {
                            string destManifestFileName = Path.Combine(settings.CurrentWorkingDirectory, @"Manifest.cab");
                            Log.WriteLog("Copying {0}...", file);
                            File.Copy(job.JobCompletionPath, destManifestFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                        else
                        {
                            if (!Directory.Exists(settings.ContentFilePath))
                            {
                                Directory.CreateDirectory(settings.ContentFilePath);
                            }
                            Log.WriteLog("Copying {0}...", file);
                            string destFileName = Path.Combine(settings.ContentFilePath, file);
                            File.Copy(job.JobCompletionPath, destFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", file);
                        ret = -1;
                    }
                }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }
*/
        private static int CopyCabsFromTempFolder(Settings settings)
        {
            Log.WriteLog("Moving content cab files to the unsigned cabs folder...");
            // Copy CAB files to /contentFilePath:<ContentFilePaht>
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            string strUnSignedCabPath = Path.Combine(settings.UnSignedCabPath, settings.TitleID);
            if (!Directory.Exists(strUnSignedCabPath))
            {
                Directory.CreateDirectory(strUnSignedCabPath);
            }
            foreach (string file in Directory.GetFiles(strCabFileFolder))
            {
                string destFileName = Path.Combine(strUnSignedCabPath, Path.GetFileName(file));

                // Delete (if exists) & move to overwrite
                try
                {
                    File.Delete(destFileName);
                }
                catch (System.IO.IOException)
                {
                }
                File.Move(file, destFileName);
            }
            Log.WriteLog("Moving content cab files finished");

            // Copy manifest.cab to /manifestFilePath:<ManifestFilePath>
            FileInfo fiManifest = new FileInfo(strTempManifestCabPath);
            string strManifestFileName = fiManifest.FullName;
            string destManifestFileName = Path.Combine(settings.UnSignedCabPath, fiManifest.Name);
            Log.WriteLog("Copying manifest.cab to " + destManifestFileName);

            // Delete (if exists) & move to overwrite
            try
            {
                File.Delete(destManifestFileName);
            }
            catch (System.IO.IOException)
            {
            }
            File.Move(strManifestFileName, destManifestFileName);

            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting temporary working folder...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting temporary working finished");
                }
                catch (System.IO.IOException)
                {
                }
            }

            return 0;
        }

        private static void RecursiveGetFilePathsInDirectoryTree(
            string dir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                fileList.Add(file);
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    RecursiveGetFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static int Main(string[] args)
        {
            Log.WriteLog(@"LFIT.EXE starts...");

            int returnResult = 1;
            try
            {
                Run(args);
                returnResult = 0;
            }
            catch (System.Exception ex)
            {
                if (!Log.ExceptionCaught)
                {
                    Log.WriteLog(ex.ToString());
                }
            }
            Log.WriteLog(@"LFIT.EXE ends...");
            return returnResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\AutoSubmit.cs ===
using System;
using System.IO;
using System.Collections.Generic;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Create a submission to Codesign.Net.
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class CodesignSubmission
    {
        public int CreateSubmission(string file, IList<string> signers, string largeFileCertID, string normalFileCertID, string strongNameCertID, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            CODESIGN.Submitter.Job job = null;
            try 
            {
                Log.WriteLog("Submitting {0} for CodeSign...", Path.GetFileName(file));
                //Initialize the Codesign.Submitter object
                //"Codesign" represents the server - constant value do not change
                //9556 represents the port - constant value do not change
                job = CODESIGN.Submitter.Job.Initialize("codesign.gtm.microsoft.com", 9556, true); 
                                
                // Sets the Partial return flag option.
                // False - If any files fail signing you will not get any files back.
                // True - Only retrieve successfully signed files.
                job.IsAllowReturnPartial = true;            // default is false

                // This is reference information that can be displayed or used in searches
                job.Description = "Job Description - a way to make it easier to associate jobs";
                job.Keywords = "Keywords to improve searches";

                // This call selects a certificate from the ones allowed for this user
                // You may pick only one Authenticode certificate
                // You may pick only one Strong Name certificate
                // You may pick an Authenticode and Strong Name certificate at the same time
                // Example:
                FileInfo info = new FileInfo(file);
                if (info.Length > 524288000)
                {
                    job.SelectCertificate(largeFileCertID);   // You must have permissions to the requested cert
                }
                else
                {
                    job.SelectCertificate(normalFileCertID);   // You must have permissions to the requested cert
                    if (strongNameCertID != @"")
                    {
                        job.SelectCertificate(strongNameCertID);   // You must have permissions to the requested cert
                    }
                }
                
                // This will populate the approvers to the job
                // NOTE: these users are invalid, must substitute real user aliases who are authorized for approval
                // You need at minimum two approvers - you may add as many as necessary
                // Approvers must be entered in the system to approve jobs
                // Approvers CANNOT be the job submitter
                foreach (string strSigner in signers)
                {
                    job.AddApprover(strSigner);
                }

                // These calls add notification subscriptions to the job. A number of others are 
                // available, these are the standard ones.
                // Check the CODESIGN.NotificationEventTypeEnum enumaration for a complete list.
                //job.SetNotification(job.Submitter, new CODESIGN.NotificationEventTypeEnum[] {CODESIGN.NotificationEventTypeEnum.JobCompletionFailure,CODESIGN.NotificationEventTypeEnum.JobCompletionSuccess,CODESIGN.NotificationEventTypeEnum.JobVirusScanFailure});


                // This call adds an entire directory tree to the job, duplicating its structure in
                // the submission share and making all metadata the same for each file.
                job.AddFile(file, "CodeSign", "http://CodeSignInfo", CODESIGN.JavaPermissionsTypeEnum.None);

                // This call sends the job to the back end for processing
                job.Send();

                Log.WriteLog("Submitting {0} finished", Path.GetFileName(file));
                // This call displays the job number, assigned during the send process
                Log.WriteLog("Job Number is: {0}", job.JobNumber);
                Log.WriteLog("Job Completion Path is: {0}", job.JobCompletionPath);
                if (jobList != null)
                {
                    jobList.Add(job);
                }
            }
            catch (Exception exc)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(exc));
                if (job != null)
                {
                    foreach(CODESIGN.Submitter.JobError je in job.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\JobWatcher.cs ===
using System;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Monitor a job until completionsubmission
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class Watcher
    {
        /// <summary>
        /// The main method
        /// </summary>
        public static int Monitor(string strJobNumber)
        {
            int ret = 0;
            //Check if user passed the job number in the parameters

            //Jobwatcher instance, still null here
            CODESIGN.Submitter.JobWatcher jw = null;

            try
            {
                //Instantiate new JobWatcher object
                jw = new CODESIGN.Submitter.JobWatcher();

                // This call waits until the job is finished
                //jw.Watch(JobNumber, RelayServer, RelayPort, IsSSL);
                jw.Watch(strJobNumber, "codesign.gtm.microsoft.com", 9556, true);

                if (jw.IsDone)
                {
                    // Now we're done, so display any errors or warnings (in case we are in non-event mode)
                    Log.WriteLog("Job is finished, Success={0}  Signed={1}  BytesSigned={2}", jw.IsSuccess, jw.TotalSigned, jw.TotalByteSize);
                    if (!jw.IsSuccess)
                    {
                        ret = -1;
                    }
                    if (jw.IsPartial)
                    {
                        Log.WriteLog("Partial Success: {0}", jw.IsPartial);
                    }
                    //Display errors
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                    //Display failed files
                    foreach (CODESIGN.Submitter.JobFile jf in jw.FailedFileList.Values)
                    {
                        Log.WriteLog("Failed -> " + jf.FileFullPath);
                    }
                }
                else
                {
                    Log.WriteLog("Job {0} is still being processed!", strJobNumber);
                }

            }
            catch (Exception ex)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(ex));
                if (jw != null)
                {
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Log.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public static class Log
    {
        private static bool quiet;
        private static bool exceptionCaught;
        private static string logFileName;

        static Log()
        {
            try
            {
                logFileName = Path.Combine(Directory.GetCurrentDirectory(), @"log.txt");
                StreamWriter SW;
                SW = File.CreateText(logFileName);
                SW.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
        public static bool ExceptionCaught
        {
            get { return exceptionCaught; }
            set { exceptionCaught = value; }
        }

        public static bool Quiet
        {
            get { return quiet; }
            set { quiet = value; }
        }

        public static void WriteLog(string line)
        {
            if (!quiet)
            {
                Console.WriteLine(line);

                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + line);
                SW.Close();
            }
        }

        public static void WriteLog(string format, object arg0)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg0);

                string str = string.Format(format, arg0);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();

            }
        }
        public static void WriteLog(string format, params object[] arg)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg);
                string str = string.Format(format, arg);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Manifest.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Manifest.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------

namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Xml;

    public class Manifest
    {
        private string cabFolder;
        private long installSize;
        private string linkURL;
        private string titleId;

        public Manifest()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        public string CabFolder
        {
            get { return this.cabFolder; }
            set { this.cabFolder = value; }
        }

        public long InstallSize
        {
            get { return this.installSize; }
            set { this.installSize = value; }
        }

        public string LinkURL
        {
            get { return this.linkURL; }
            set { this.linkURL = value; }
        }

        public string TitleId
        {
            get { return this.titleId; }
            set { this.titleId = value; }
        }

        public void NewFile()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public string SaveFile(string outputPath)
        {
            XmlDocument doc = new XmlDocument();

            XmlNode node = doc.CreateNode(XmlNodeType.XmlDeclaration, "OfferManifest", null);
            XmlDeclaration decl = (XmlDeclaration)node;
            decl.Encoding = @"utf-8";
            doc.AppendChild(node);

            XmlNode root = doc.CreateNode(XmlNodeType.Element, "OfferManifest", null);
            XmlAttribute titleIDAtt = doc.CreateAttribute("TitleId");
            titleIDAtt.Value = this.titleId;
            root.Attributes.Append(titleIDAtt);
            doc.AppendChild(root);

            XmlNode itemsNode = doc.CreateNode(XmlNodeType.Element, "Items", null);
            XmlAttribute installSizeAtt = doc.CreateAttribute("InstallSize");
            installSizeAtt.Value = this.installSize.ToString();
            itemsNode.Attributes.Append(installSizeAtt);
            root.AppendChild(itemsNode);


            foreach (string fileName in Directory.GetFiles(cabFolder))
            {
                XmlNode fileNode = doc.CreateNode(XmlNodeType.Element, "Item", null);
                XmlAttribute idAtt = doc.CreateAttribute("ID");
                idAtt.Value = Path.GetFileName(fileName);
                fileNode.Attributes.Append(idAtt);

                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(fileName);
                XmlAttribute sizeAtt = doc.CreateAttribute("DownloadSize");
                sizeAtt.Value = info.Length.ToString();
                fileNode.Attributes.Append(sizeAtt);
                itemsNode.AppendChild(fileNode);

                XmlNode linkNode = doc.CreateNode(XmlNodeType.Element, "Link", null);
                XmlAttribute urlAtt = doc.CreateAttribute("Url");

                Uri urlBase = new Uri(this.linkURL);
                if( this.linkURL.EndsWith("\\") || this.linkURL.EndsWith("/"))
                {
                    urlAtt.Value = this.linkURL + Path.GetFileName(fileName);
                }
                else
                {
                    if (this.linkURL.Contains("://"))
                    {
                        urlAtt.Value = this.linkURL + "/" + Path.GetFileName(fileName);
                    }
                    else
                    {
                        Log.WriteLog("File: " + Path.GetFileName(fileName));
                        urlAtt.Value = Path.Combine(this.linkURL, Path.GetFileName(fileName));
                    }
                }
                Log.WriteLog("FileURL: " + urlAtt.Value);
                linkNode.Attributes.Append(urlAtt);
                fileNode.AppendChild(linkNode);
            }

            doc.Save(outputPath);
            if (!File.Exists(outputPath))
            {
                throw new FileNotFoundException();
            }

            return "Saved manifest file at " + outputPath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Settings.cs ===
﻿using System.Globalization;
//-----------------------------------------------------------------------
// <copyright file="Settings.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    
    public enum Command
    {
        All = 0,
        Create,
        Submit,
        Check
    }
    
    public class Settings
    {
        private const long twoGigs = 2146435072;
        private const int lengthTitleId = 8;
        private const int lengthContentId = 40;
        private const int lengthOfferId = 16;

        private bool quiet;

        private Command inputCommand;
        //private string codeSignFileName;
        private string srcFileName;
        private string dstFileName;
        //private string codeSignJobNumber;
        //private string codeSignCompletionPath;
        private long maxCabSize;
        private string titleID;
        private string contentID;
        private string offerID;
        private string contentType;
        private string contentURL;
        private string inputFolder;
        private string unSignedCabPath;
        private string contentFilePath;
        private string currentWorkingDirectory;
        private string tempDirectory;
        private int compressionLevel;
        private bool nooverwritexbx;
        //private IList<string> signers;
        //private string largeFileCertID;
        //private string normalFileCertID;
        //private string strongNameCertID;

        public Settings()
        {
            quiet = false;
            inputCommand = Command.All;
            //signers = new List<string>();
            //largeFileCertID = @"10038";
            //normalFileCertID = @"10006";
            //strongNameCertID = @"";
            //codeSignJobNumber = @"";
            //codeSignCompletionPath = @"";
            //codeSignFileName = @"";
            maxCabSize = Settings.twoGigs;    // default = 2G - 1MB
            contentFilePath = @"\\xsinfxferinh001\Content\";
            contentURL = @"\\xsinfxferinh001\Content\";
            this.currentWorkingDirectory = Directory.GetCurrentDirectory();
            srcFileName = @"";
            dstFileName = @"";
        }

        public bool Quiet
        {
            get { return this.quiet; }
        }

        public Command InputCommand
        {
            get { return this.inputCommand; }
        }

        public string SrcFileName
        {
            get { return this.srcFileName; }
        }

        public int CompressionLevel
        {
            get { return compressionLevel; }
        }

        public bool Nooverwritexbx
        {
            get { return nooverwritexbx; }
        }

        public string DstFileName
        {
            get { return this.dstFileName; }
        }
        /*
        public string CodeSignFileName
        {
            get { return this.codeSignFileName; }
        }

        public string CodeSignJobNumber
        {
            get { return this.codeSignJobNumber; }
        }

        public string CodeSignCompletionPath
        {
            get { return this.codeSignCompletionPath; }
        }
        public IList<string> Signers
        {
            get { return this.signers; }
        }
        public string LargeFileCertID
        {
            get { return this.largeFileCertID; }
        }

        public string NormalFileCertID
        {
            get { return this.normalFileCertID; }
        }

        public string StrongNameCertID
        {
            get { return this.strongNameCertID; }
        }
        */
        public long MaxCabSize
        {
            get { return this.maxCabSize; }
        }

        public string InputFolder
        {
            get { return this.inputFolder; }
        }
        public string TitleID
        {
            get { return this.titleID; }
        }
        public string OfferID
        {
            get { return this.offerID; }
        }
        public string ContentID
        {
            get { return this.contentID; }
        }
        public string ContentType
        {
            get { return this.contentType; }
        }
        public string ContentFilePath
        {
            get { return this.contentFilePath; }
        }
        public string ContentURL
        {
            get { return this.contentURL; }
        }
        public string CurrentWorkingDirectory
        {
            get { return this.currentWorkingDirectory; }
        }
        public string TempDirectory
        {
            get { return this.tempDirectory; }
        }
        public string UnSignedCabPath
        {
            get { return this.unSignedCabPath; }
        }

        public static void DisplayUsage()
        {
            Log.WriteLog("\nCreates and props full game content files for Windows - LIVE title");
            Log.WriteLog(string.Empty);
            Log.WriteLog("Usage: LFIT.exe [command] /inputFolder <inputFolder> /titleId <TitleID> /contentId <ContentID> /offerId <OfferID> /contentType <ContentType> /unsignedCabPath <UnsignedCabPath> [/maxCabSize <maxCabSize>] [/contentURL <ContentURL>] [/compressionLevel <CompressionLevel>]");
            Log.WriteLog(string.Empty);
            Log.WriteLog("\t[command]\tcreate - create content and manifest cabs\n");
            Log.WriteLog("\t/q\t\t\tQuiet mode. No output displayed\n");
            Log.WriteLog("\t/inputFolder\t\tThe folder containing all of the full game files\n");
            Log.WriteLog("\t/titleId\t\tThe 8-char Title ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentId\t\tThe Content ID to be assigned to the spanned cabs\n");
            Log.WriteLog("\t/offerId\t\tThe full Offer ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentType\t\tCan be 0x00007000 (for FullGame) or 0x00080000 (for GameDemo)\n");
            Log.WriteLog("\t/maxCabSize\t\tThe maximum size of one cab file (in megabyte)\n\t\t\t\tDefault: 2048\n");
            Log.WriteLog("\t/unsignedCabPath\tThe folder to where the unsigned spanned CABs will be dropped\n");
            Log.WriteLog("\t/contentURL\t\tThe CDN location from which the spanned CABs can be reached\n\t\t\t\tDefault: \\\\xsinfxferinh001\\Content\n");
            Log.WriteLog("\t/compressionLevel\tCompression level number between 0 to 10. 0 = none and fast. 10 = max and slow. Defaults to 10.\n");
            Log.WriteLog("\t/nooverwritexbx\t\tLFIT will not overwrite or create a content.xbx.  It uses the existing one in the input folder\n");
            //Log.WriteLog("\t\t\tsubmit - submit one cab for CodeSign\n");
            //Log.WriteLog("\t\t\t\t  /fileName <FileName> /signer <Alias1> /signer <Alias2>\n");
            //Log.WriteLog("\t\t\tcheck - check CodeSign result\n");
            //Log.WriteLog("\t\t\t\t  /codeSignJobNumber <CodeSignJobNumber> \n");
            //Log.WriteLog("\t/signer \t\tRepeat input once for each person who can approve the request\n");
            //Log.WriteLog("\t/largeFileCertID\tCertificate ID used to sign files bigger than 500M\n\t\t\t\tDefault: 10038\n");
            //Log.WriteLog("\t/normalFileCertID\tCertificate ID used to sign files less than 500M\n\t\t\t\tDefault: 10006\n");
            //Log.WriteLog("\t/strongNameCertID\tCertificate ID used to sign files with strong name\n\t\t\t\tDefault: not used\n");
        }

        public void ParseCommandLine(string[] args)
        {
            this.tempDirectory = Path.Combine(System.IO.Path.GetTempPath(), @"LFIT");

            for (int i = 0; i < args.Length; i++)
            {
                string arg = args[i];
                if (arg[0] == '-' || arg[0] == '/')
                {
                    arg = arg.Remove(0, 1);
                    if (string.Compare(arg, "q", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.quiet = true;
                    }
                    else if (string.Compare(arg, "MaxCabSize", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.maxCabSize = Convert.ToInt64(args[i]) * 1048576;
                            if( this.maxCabSize > Settings.twoGigs )
                            {
                                throw new ArgumentException("Cab size too large.  2047MB is max", "/MaxCabSize");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing cab size", "/MaxCabSize");
                        }
                    }
                    else if (string.Compare(arg, "nooverwritexbx", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.nooverwritexbx = true;
                    }
                    else if (string.Compare(arg, "compressionLevel", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            try
                            {
                                this.compressionLevel = Int32.Parse(args[i]);
                                if (this.compressionLevel < 0 || this.compressionLevel > 10)
                                {
                                    throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                                }
                            }
                            catch (System.Exception)
                            {
                                throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing compressionLevel", "/compressionLevel");
                        }
                    }
                    else if (string.Compare(arg, "inputFolder", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.inputFolder = args[i];
                            this.inputFolder = Settings.UnquoteString(this.inputFolder);
                        }
                        else
                        {
                            throw new ArgumentException("Missing input folder", "/inputFolder");
                        }
                    }
                    else if (string.Compare(arg, "titleID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.titleID = args[i];
                            ValidateHexParameter(this.titleID, lengthTitleId, "titleID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing title ID", "/titleID");
                        }
                    }
                    else if (string.Compare(arg, "contentID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentID = args[i];
                            ValidateHexParameter(this.contentID, lengthContentId, "contentID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing content ID", "/contentID");
                        }
                    }
                    else if (string.Compare(arg, "offerID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.offerID = args[i];
                            ValidateHexParameter(this.offerID, lengthOfferId, "offerID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing offer ID", "/offerID");
                        }
                    }
                    else if (string.Compare(arg, "contentType", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentType = args[i];
                            if (string.Compare( this.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase ) != 0 &&
                                string.Compare( this.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase ) != 0) 
                            {
                                throw new ArgumentException("Invalid content type", "/contentType");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing content type", "/contentType");
                        }
                    }
                    else if (string.Compare(arg, "contentFilePath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentFilePath = args[i];
                            this.contentFilePath = Settings.UnquoteString(this.contentFilePath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content file path", "/contentFilePath");
                        }
                    }
                    else if (string.Compare(arg, "unsignedCabPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.unSignedCabPath = args[i];
                            this.unSignedCabPath = Settings.UnquoteString(this.unSignedCabPath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing unsigned cab files save path", "/unsignedCabPath");
                        }
                    }
                    else if (string.Compare(arg, "contentURL", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentURL = args[i];
                            this.contentURL = Settings.UnquoteString(this.contentURL);

                            Log.WriteLog("ContentURL: " + this.contentURL);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content URL", "/contentURL");
                        }
                    }
/*
                    else if (string.Compare(arg, "signer", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.signers.Add(args[i].ToUpper());
                        }
                        else
                        {
                            throw new ArgumentException("Missing CodeSign signer", "/signer");
                        }
                    }
                    else if (string.Compare(arg, "largeFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.largeFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the larger certificate ID", "/largeFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "normalFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.normalFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the normal certificate ID", "/normalFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "strongNameCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.strongNameCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the strong name certificate ID", "/strongNameCertID");
                        }
                    }  
                    else if (string.Compare(arg, "fileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignFileName = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the file name", "/fileName");
                        }
                    }

                    else if (string.Compare(arg, "codeSignJobNumber", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignJobNumber = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign job number", "/codeSignJobNumber");
                        }
                    }
                    else if (string.Compare(arg, "codeSignCompletionPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignCompletionPath = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign completion path", "/codeSignCompletionPath");
                        }
                    }
 */ 
                    else if (string.Compare(arg, "srcFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.srcFileName = args[i];
                            this.srcFileName = Settings.UnquoteString(this.srcFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the source file name", "/srcFileName");
                        }
                    }
                    else if (string.Compare(arg, "dstFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.dstFileName = args[i];
                            this.dstFileName = Settings.UnquoteString(this.dstFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the destination file name", "/dstFileName");
                        }
                    }
                    else if (string.Compare(arg, "?", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        throw new ArgumentException("Display help", "-?");
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }
                else
                {
                    if (string.Compare(arg, "create", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Create;
                    }
                    else if (string.Compare(arg, "submit", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Submit;
                    }
                    else if (string.Compare(arg, "check", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Check;
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }

            }

            if (string.IsNullOrEmpty(this.contentFilePath))
            {
                this.contentFilePath = @"\\xsinfxferinh001\Content";
            }
            if (string.IsNullOrEmpty(this.contentURL))
            {
                this.contentURL = @"\\xsinfxferinh001\Content";
            }

            if( this.inputCommand != Command.Create )
            {
                throw new ArgumentException("Command must be create", "command");
            }

            // justify the input
            switch (this.inputCommand)
            {
                case Command.All:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }
/*
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }
 
                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }

                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
*/
                    break;
                }
                case Command.Create:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }

                    break;
                }
/*
                case Command.Submit:
                {
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }

                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }
                    break;
                }

                case Command.Check:
                {
                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
                    break;
                }
*/
            }

        }

        private static string UnquoteString(string input)
        {
            bool quotedString = false;
            if (input.EndsWith("\"") || input.StartsWith("\""))
            {
                quotedString = true;
            }

            if (quotedString)
            {
                // Remove quotes
                if (input.EndsWith("\""))
                {
                    input = input.Substring(0, input.Length - 1);
                }

                if (input.StartsWith("\""))
                {
                    input = input.Substring(1, input.Length - 1);
                }
            }

            return input;
        }

        private void ValidateHexParameter(string hexString, int expectedLength, string paramName)
        {
            if (hexString.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
            {
                throw new ArgumentException(string.Format("{0} should not start with 0x.", paramName), string.Format("/{0}", paramName));
            }
            else if (hexString.Length != expectedLength)
            {
                throw new ArgumentException(string.Format("{0} should be in the length of {1}.", paramName, expectedLength), string.Format("/{0}", paramName));
            }
            else if (!IsHexString(hexString))
            {
                throw new ArgumentException(string.Format("{0} is not a valid hexadecimal string", paramName), string.Format("/{0}", paramName));
            }
        }

        private bool IsHexString(string hexString)
        {
            Regex hexRegex = new Regex("^[0-9a-fA-F]+$", RegexOptions.CultureInvariant | RegexOptions.Compiled);
            return hexRegex.IsMatch(hexString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ServiceErrorCode\obj\Debug\ErrorCodeClass\ErrorCodeClasses.cs ===
// This is a generated file. Please don't modify directly.
  //
  // This file defines a number of classes which provide a symbolic way to
  // reference instances of configuration items (e.g. Interfaces, Settings,
  // etc.).
  //
  // It is generated from the /product/SharedSource/LIVEN.Common/ErrorCode.xml
  // file. Please update that file and this code will get updated automatically
  // by the build.

  namespace LIVEN.Common.Diagnostics
  {
      using System.Diagnostics;
      using System.Diagnostics.CodeAnalysis;
      using System.Threading;
      using Leet.Utils;



  
    
     [EventCategory(MessageIdBase = 10000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class RewardsEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(RewardsEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10000, Error = false,  Facility= 10, Message = "Rewards service started.", TraceEventType = TraceEventType.Start)]
         public static int ServiceStarted = 10000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10001, Error = true,  Facility= 10, Message = "Application Error has occurred: {0}\n", TraceEventType = TraceEventType.Error)]
         public static int ApplicationError = 10001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10002, Error = true,  Facility= 10, Message = "Unexpected failure: {0}\n", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedFailure = 10002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10003, Error = false,  Facility= 10, Message = "Loaded configuration provider: {0}", TraceEventType = TraceEventType.Information)]
         public static int LoadedConfigProviderEvent = 10003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10004, Error = false,  Facility= 10, Message = "Setting value has been updated and change has been vetoed. Restart the service to apply new setting\n Setting Name: {0}\nSetting Value (old): {1}\nSetting Value (new): {2}", TraceEventType = TraceEventType.Warning)]
         public static int SettingUpdatedWarningEvent = 10004;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10005, Error = true,  Facility= 10, Message = "Critical Exception during configuration provider setup: {0}\n{1}", TraceEventType = TraceEventType.Error)]
         public static int LoadConfigProviderExceptionEvent = 10005;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10006, Error = true,  Facility= 10, Message = "Sql Exception Error: {0}\n", TraceEventType = TraceEventType.Error)]
         public static int SqlExceptionError = 10006;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10007, Error = true,  Facility= 10, Message = "Authentication failure.", TraceEventType = TraceEventType.Warning)]
         public static int AuthenticationFailure = 10007;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10008, Error = true,  Facility= 10, Message = "Empty or Null GameResult object given.", TraceEventType = TraceEventType.Warning)]
         public static int NullGameResultObject = 10008;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10009, Error = true,  Facility= 10, Message = "GameResult object posted is invalid.", TraceEventType = TraceEventType.Warning)]
         public static int BadGameResultPost = 10009;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10010, Error = true,  Facility= 10, Message = "Submission does not have a valid associated X-Locale Header: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidLocaleNotProvided = 10010;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10011, Error = true,  Facility= 10, Message = "Submission does not have a valid associated X-Platform-Type Header: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidPlatformTypeNotProvided = 10011;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10012, Error = true,  Facility= 10, Message = "A ZEST VerifyPastPurchase request has return an error.", TraceEventType = TraceEventType.Warning)]
         public static int ZestVerifyPastPurchaseRequestError = 10012;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10013, Error = true,  Facility= 10, Message = "A ZEST SignIn request has return an error.", TraceEventType = TraceEventType.Warning)]
         public static int ZestSignInRequestError = 10013;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10014, Error = true,  Facility= 10, Message = "A duplicate GameResult is received: {0}", TraceEventType = TraceEventType.Warning)]
         public static int IdempotencyFilterDuplicateError = 10014;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10015, Error = true,  Facility= 10, Message = "GrantAchievements object posted is invalid.", TraceEventType = TraceEventType.Warning)]
         public static int BadGrantAchievementsPost = 10015;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10016, Error = true,  Facility= 10, Message = "A LiveCache request has return an error.", TraceEventType = TraceEventType.Warning)]
         public static int LiveCacheError = 10016;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10017, Error = true,  Facility= 10, Message = "User has not purchased this title.", TraceEventType = TraceEventType.Warning)]
         public static int ZestNotPurchased = 10017;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10018, Error = true,  Facility= 10, Message = "User has purchased this item but there is a mismatch LiveEngagementId and AppId.", TraceEventType = TraceEventType.Warning)]
         public static int ZestLiveEngagementMismatchError = 10018;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10019, Error = true,  Facility= 10, Message = "An unknown error code was returned while calling Zest.", TraceEventType = TraceEventType.Warning)]
         public static int ZestUnknownErrorCode = 10019;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10020, Error = true,  Facility= 10, Message = "No cookie returned. The user is invalid or user has not agreed to the terms of service.", TraceEventType = TraceEventType.Warning)]
         public static int ZestSignInInvalidXuid = 10020;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10021, Error = true,  Facility= 10, Message = "Submission does not have a valid associated titleId: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidTitleIdNotProvided = 10021;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 10022, Error = true,  Facility= 10, Message = "GrantAvatarAssets object posted is invalid.", TraceEventType = TraceEventType.Warning)]
         public static int BadGrantAvatarAssetsPost = 10022;
       
    }
   
    
     [EventCategory(MessageIdBase = 11000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class GarbageCollectorServiceEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(GarbageCollectorServiceEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 11000, Error = true,  Facility= 11, Message = "Unexpected exception in garbage collector service: {0}", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedExceptionInService = 11000;
       
    }
   
    
     [EventCategory(MessageIdBase = 12000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class SystemNudgeServiceEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(SystemNudgeServiceEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 12000, Error = true,  Facility= 12, Message = "Unexpected exception in system nudge service: {0}", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedExceptionInService = 12000;
       
    }
   
    
     [EventCategory(MessageIdBase = 20000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class UserDataEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(UserDataEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20000, Error = false,  Facility= 20, Message = "User Data service started.", TraceEventType = TraceEventType.Start)]
         public static int ServiceStarted = 20000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20001, Error = true,  Facility= 20, Message = "Application Error has occurred: {0}\n", TraceEventType = TraceEventType.Error)]
         public static int ApplicationError = 20001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20002, Error = true,  Facility= 20, Message = "Unexpected failure: {0}\n", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedFailure = 20002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20003, Error = true,  Facility= 20, Message = "Authentication failure.", TraceEventType = TraceEventType.Warning)]
         public static int AuthenticationFailure = 20003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20004, Error = true,  Facility= 20, Message = "Invalid argument or bad request", TraceEventType = TraceEventType.Warning)]
         public static int InvalidArgument = 20004;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20005, Error = true,  Facility= 20, Message = "A LiveCache request has return an error.", TraceEventType = TraceEventType.Warning)]
         public static int LiveCacheError = 20005;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20006, Error = true,  Facility= 20, Message = "Sql Exception Error: {0}\n", TraceEventType = TraceEventType.Warning)]
         public static int SqlExceptionError = 20006;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20007, Error = true,  Facility= 20, Message = "Submission does not have a valid associated titleId: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidTitleIdNotProvided = 20007;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20008, Error = true,  Facility= 20, Message = "Submission does not have a valid associated X-Platform-Type Header: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidPlatformTypeNotProvided = 20008;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 20009, Error = true,  Facility= 20, Message = "Submission does not have a valid associated X-Locale Header: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidLocaleNotProvided = 20009;
       
    }
   
    
     [EventCategory(MessageIdBase = 30000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class RulesEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(RulesEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30000, Error = false,  Facility= 30, Message = "Rules service leaderboard stats processing started.", TraceEventType = TraceEventType.Start)]
         public static int RulesServiceStarted = 30000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30001, Error = false,  Facility= 30, Message = "An exception occurred while starting the service.", TraceEventType = TraceEventType.Error)]
         public static int RulesServiceStartupFailure = 30001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30002, Error = false,  Facility= 30, Message = "Rules service leaderboard stats processing stopped.", TraceEventType = TraceEventType.Stop)]
         public static int RulesServiceStopped = 30002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30003, Error = false,  Facility= 30, Message = "An exception occurred while stopping rules service.", TraceEventType = TraceEventType.Error)]
         public static int RulesServiceStoppedFailure = 30003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30004, Error = false,  Facility= 30, Message = "A Sql exception has occurred.", TraceEventType = TraceEventType.Warning)]
         public static int SqlExceptionError = 30004;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30005, Error = false,  Facility= 30, Message = "The Sql service broker queue is disabled.", TraceEventType = TraceEventType.Error)]
         public static int QueueDisabledError = 30005;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30006, Error = false,  Facility= 30, Message = "Rules driver in the rules service failed to initialized.", TraceEventType = TraceEventType.Error)]
         public static int RulesDriverInitializationFailed = 30006;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30007, Error = false,  Facility= 30, Message = "Event retrieval from the SQL service broker queue has failed.", TraceEventType = TraceEventType.Warning)]
         public static int BadMessageRetrieved = 30007;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30008, Error = false,  Facility= 30, Message = "An exception occurred while evaluating a game event.", TraceEventType = TraceEventType.Warning)]
         public static int EvaluateGameEventFailed = 30008;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30012, Error = false,  Facility= 30, Message = "An exception occurred while getting gamertag for Xuid: {0}", TraceEventType = TraceEventType.Warning)]
         public static int ExceptionWhileGettingGamertag = 30012;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30013, Error = false,  Facility= 30, Message = "A retriable exception occurred while processing a GameEvent", TraceEventType = TraceEventType.Warning)]
         public static int RetriableExceptionOccurred = 30013;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30014, Error = true,  Facility= 30, Message = "A non retriable exception occurred while processing a GameEvent", TraceEventType = TraceEventType.Error)]
         public static int NonRetriableExceptionOccurred = 30014;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30015, Error = true,  Facility= 30, Message = "An exception has occured while processing GameEvent = {0}", TraceEventType = TraceEventType.Error)]
         public static int ExceptionWhileProcessingGameEvent = 30015;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30016, Error = true,  Facility= 30, Message = "The rating column specified is not supported, MobileAndWebRatingColumn = {0}", TraceEventType = TraceEventType.Error)]
         public static int RatingColumnNotSupported = 30016;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30017, Error = true,  Facility= 30, Message = "GameEvent was dropped and not processed, GameEvent = {0}", TraceEventType = TraceEventType.Warning)]
         public static int GameEventDropped = 30017;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30018, Error = true,  Facility= 30, Message = "StatRanking not supported : {0}", TraceEventType = TraceEventType.Error)]
         public static int StatRankingNotSupported = 30018;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 30019, Error = true,  Facility= 30, Message = "Failed to write the leaderboard data blob. ownerPuid:{0}, path:{1}, titleId:{2}", TraceEventType = TraceEventType.Error)]
         public static int LeaderboardDataBlobWriteFailed = 30019;
       
    }
   
    
     [EventCategory(MessageIdBase = 40000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class GMSEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(GMSEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 40000, Error = true,  Facility= 40, Message = "GMS Service was started", TraceEventType = TraceEventType.Information)]
         public static int ServiceStarted = 40000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 40001, Error = true,  Facility= 40, Message = "GMS Service was stopped", TraceEventType = TraceEventType.Information)]
         public static int ServiceStopped = 40001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 40002, Error = true,  Facility= 40, Message = "GMS Service hit a fatal Sql Exception when trying to connect to database", TraceEventType = TraceEventType.Error)]
         public static int SqlException = 40002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 40002, Error = true,  Facility= 40, Message = "GMS Ingestion service hit an error when loading xml", TraceEventType = TraceEventType.Warning)]
         public static int ErrorLoadingXml = 40002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 40002, Error = true,  Facility= 40, Message = "GMS Ingestion failed to ingest a game", TraceEventType = TraceEventType.Warning)]
         public static int ErrorConfiguringGame = 40002;
       
    }
   
    
     [EventCategory(MessageIdBase = 50000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class STSEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(STSEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 50000, Error = true,  Facility= 50, Message = "Security Token Service was started", TraceEventType = TraceEventType.Information)]
         public static int ServiceStarted = 50000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 50001, Error = true,  Facility= 50, Message = "Security Token Service was stopped", TraceEventType = TraceEventType.Information)]
         public static int ServiceStopped = 50001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 50002, Error = true,  Facility= 50, Message = "A LiveCache request has return an error.", TraceEventType = TraceEventType.Warning)]
         public static int LiveCacheError = 50002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 50003, Error = true,  Facility= 50, Message = "An unknown error occurred.", TraceEventType = TraceEventType.Warning)]
         public static int UnknownError = 50003;
       
    }
   
    
     [EventCategory(MessageIdBase = 60000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class UserDataPartnerEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(UserDataPartnerEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60000, Error = false,  Facility= 60, Message = "User Data Partner service started.", TraceEventType = TraceEventType.Start)]
         public static int ServiceStarted = 60000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60001, Error = true,  Facility= 60, Message = "AuthenticationFailure.", TraceEventType = TraceEventType.Warning)]
         public static int AuthenticationFailure = 60001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60002, Error = true,  Facility= 60, Message = "Invalid argument or bad request", TraceEventType = TraceEventType.Warning)]
         public static int InvalidArgument = 60002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60003, Error = true,  Facility= 60, Message = "Application Error has occurred: {0}\n", TraceEventType = TraceEventType.Error)]
         public static int ApplicationError = 60003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60004, Error = true,  Facility= 60, Message = "User is not eligible for changing gamertag.\n", TraceEventType = TraceEventType.Warning)]
         public static int ChangeGamertagNotEligible = 60004;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60005, Error = true,  Facility= 60, Message = "Gamertag is invalid.\n", TraceEventType = TraceEventType.Warning)]
         public static int ChangeGamertagInvalidPattern = 60005;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60006, Error = true,  Facility= 60, Message = "An error has occured changing gamertag.\n", TraceEventType = TraceEventType.Warning)]
         public static int ChangeGamertagError = 60006;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60007, Error = true,  Facility= 60, Message = "Gamertag does not exist.\n", TraceEventType = TraceEventType.Warning)]
         public static int GamertagDoesNotExist = 60007;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60008, Error = true,  Facility= 60, Message = "AuthorizationFailure.", TraceEventType = TraceEventType.Warning)]
         public static int AuthorizationFailure = 60008;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60009, Error = true,  Facility= 60, Message = "Submission does not have a valid associated titleId: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidTitleIdNotProvided = 60009;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60010, Error = true,  Facility= 60, Message = "Submission does not have a valid associated X-Platform-Type Header: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidPlatformTypeNotProvided = 60010;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60011, Error = true,  Facility= 60, Message = "Submission does not have a valid associated X-Locale Header: {0}.", TraceEventType = TraceEventType.Warning)]
         public static int ValidLocaleNotProvided = 60011;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60012, Error = true,  Facility= 60, Message = "LivecacheUserThrottleException is hit.", TraceEventType = TraceEventType.Warning)]
         public static int LivecacheUserThrottledException = 60012;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 60013, Error = true,  Facility= 60, Message = "LivecacheResponseException is hit.", TraceEventType = TraceEventType.Warning)]
         public static int LivecacheResponseException = 60013;
       
    }
   
    
     [EventCategory(MessageIdBase = 7000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class SessionMaintenanceEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(SessionMaintenanceEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 7003, Error = true,  Facility= 7, Message = "Unhandled exception in ProcessSessions worker thread, Partition: {0}", TraceEventType = TraceEventType.Error)]
         public static int UnhandledExceptionInProcessSessionsThread = 7003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 7004, Error = true,  Facility= 7, Message = "WebException thrown in while querying data, Partition: {0}", TraceEventType = TraceEventType.Error)]
         public static int WebExceptionInSendSystemNudges = 7004;
       
    }
   
    
     [EventCategory(MessageIdBase = 8000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class NotificationEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(NotificationEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8000, Error = true,  Facility= 8, Message = "Unexpected failure: {0}", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedFailure = 8000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8001, Error = true,  Facility= 8, Message = "Azure storage access failure: {0}", TraceEventType = TraceEventType.Error)]
         public static int AzureStorageAccessFailure = 8001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8002, Error = true,  Facility= 8, Message = "Feature not implemented.", TraceEventType = TraceEventType.Error)]
         public static int NotImplemented = 8002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8003, Error = true,  Facility= 8, Message = "Queue access failure.", TraceEventType = TraceEventType.Error)]
         public static int QueueAccessFailure = 8003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8004, Error = false,  Facility= 8, Message = "Notification service started.", TraceEventType = TraceEventType.Information)]
         public static int ServiceStarted = 8004;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8005, Error = false,  Facility= 8, Message = "Notification service stopped.", TraceEventType = TraceEventType.Information)]
         public static int ServiceStopped = 8005;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8006, Error = true,  Facility= 8, Message = "Too many invites sent in a hour.", TraceEventType = TraceEventType.Information)]
         public static int QuotaExceeded = 8006;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8007, Error = true,  Facility= 8, Message = "Invalid argument or bad request: {0}", TraceEventType = TraceEventType.Information)]
         public static int InvalidArgument = 8007;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8008, Error = true,  Facility= 8, Message = "Not Authorized.", TraceEventType = TraceEventType.Information)]
         public static int AuthenticationFailure = 8008;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8009, Error = true,  Facility= 8, Message = "Invite Email Template not found", TraceEventType = TraceEventType.Error)]
         public static int InviteEmailTemplateNotFound = 8009;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8010, Error = true,  Facility= 8, Message = "Invite Email Template Initialization failed", TraceEventType = TraceEventType.Error)]
         public static int InviteEmailTemplateInitFailed = 8010;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8011, Error = true,  Facility= 8, Message = "Invite Email Template: Duplicated entries", TraceEventType = TraceEventType.Error)]
         public static int InviteEmailTemplateDuplicatedEntries = 8011;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8012, Error = true,  Facility= 8, Message = "Error connecting SMTP server", TraceEventType = TraceEventType.Error)]
         public static int SmtpServerConnectionError = 8012;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8013, Error = true,  Facility= 8, Message = "SMTP Server Invalid Operation", TraceEventType = TraceEventType.Error)]
         public static int SmtpServerInvalidOperation = 8013;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8014, Error = true,  Facility= 8, Message = "Notification internal NT service failed to start: \n{0}", TraceEventType = TraceEventType.Error)]
         public static int ServiceFailedToStart = 8014;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8015, Error = true,  Facility= 8, Message = "Notification internal NT service failed to stop: \n{0}", TraceEventType = TraceEventType.Error)]
         public static int ServiceFailedToStop = 8015;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8016, Error = true,  Facility= 8, Message = "Notification internal NT service stopped unexpectedly: \n{0}", TraceEventType = TraceEventType.Error)]
         public static int ServiceStoppedUnexpectedly = 8016;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8017, Error = true,  Facility= 8, Message = "Notification internal NT service hit a fatal Sql Exception: \n{0}", TraceEventType = TraceEventType.Error)]
         public static int SqlException = 8017;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8018, Error = true,  Facility= 8, Message = "Unexpected Exception in notification garbage collector plugin, stopping the notification garbage collection run.", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedExceptionInNotificationGarbageCollector = 8018;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8019, Error = true,  Facility= 8, Message = "Retriable exception is caught in processing notification", TraceEventType = TraceEventType.Warning)]
         public static int RetriableError = 8019;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8020, Error = true,  Facility= 8, Message = "Exception is caught in processing notification.", TraceEventType = TraceEventType.Error)]
         public static int ErrorProcessingNotification = 8020;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8021, Error = true,  Facility= 8, Message = "HTTPS Cert needed for mutual auth with MPNS not found on the server", TraceEventType = TraceEventType.Error)]
         public static int MpnsCertNotFound = 8021;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8022, Error = true,  Facility= 8, Message = "Mutliple HTTPS Cert needed for mutual auth with MPNS were found on the server", TraceEventType = TraceEventType.Error)]
         public static int MpnsCertMultFound = 8022;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 8023, Error = true,  Facility= 8, Message = "Sending Push notification failed with unexpected error", TraceEventType = TraceEventType.Warning)]
         public static int SendPushFailedUnexpected = 8023;
       
    }
   
    
     [EventCategory(MessageIdBase = 9000, IncrementAmount = 1)]
     [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1401:FieldsMustBePrivate",
     Justification = "Special class to define error codes.")]
     public class SessionServiceEvents
     {
         private const int Initialized = 1;
         private const int NotInitialized = 0;
  
         public static EventsCollection Events {get; set;}
         private static int isInitialized;
  
         // This function is re-entrant from other threads, only one of them will initialize this class.
         public static void Initialize(string eventSource)
         {
             if (NotInitialized == Interlocked.CompareExchange(ref isInitialized, Initialized, NotInitialized))
             {
                 // Initialize Event Source
                 Events = new EventsCollection(typeof(SessionServiceEvents), null);
             }
         }
  
   
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9000, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer, GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormat = 9000;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9001, Error = true,  Facility= 9, Message = "User is not allowed to query a session he/she is not in", TraceEventType = TraceEventType.Warning)]
         public static int UserNotAllowedToGetStateInSession = 9001;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9002, Error = true,  Facility= 9, Message = "Session not found in the session store, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int SessionNotFoundInAzureStore = 9002;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9003, Error = true,  Facility= 9, Message = "Game data not found in the Azure game data store, SessionID: {0}, GameID: {1}, fileName: {2}", TraceEventType = TraceEventType.Warning)]
         public static int GameDataNotFoundInAzureStore = 9003;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9004, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer, GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatWhilePostingGameAction = 9004;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9005, Error = true,  Facility= 9, Message = "This user: {0} is not allowed to set state in the session: SessionID: {1}, GameID: {2}", TraceEventType = TraceEventType.Warning)]
         public static int UserNotAllowedToSetStateInThisSession = 9005;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9006, Error = true,  Facility= 9, Message = "This user: {0} is not allowed to submit game action to the session: SessionID: {1}, GameID: {2}", TraceEventType = TraceEventType.Warning)]
         public static int UserNotAllowedToSubmitActionToSession = 9006;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9008, Error = true,  Facility= 9, Message = "Cannot set game state if the game is not a passthrough server game, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int SetGameStateNotAllowedForNonPassthruGames = 9008;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9009, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer, GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatWhileSettingGameState = 9009;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9010, Error = true,  Facility= 9, Message = "No owner found for this session, cannot modify game state. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int NoOwnerFoundForTheSession = 9010;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9011, Error = true,  Facility= 9, Message = "The user is not allowed to modify the game state for this session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int UserNotAllowedToModifyGameStateForTheSession = 9011;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9012, Error = true,  Facility= 9, Message = "Only the session owner can modify the game state for this session with a missing active user. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int OnlySessionOwnerCanModifyGameState = 9012;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9013, Error = true,  Facility= 9, Message = "Storage object passed for Modify is invalid", TraceEventType = TraceEventType.Error)]
         public static int StorageObjectPassedForModifyIsInvalid = 9013;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9014, Error = true,  Facility= 9, Message = "Error on provisioning Azure storage. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorOnProvisioningAzureStorage = 9014;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9015, Error = true,  Facility= 9, Message = "Error on deprovisioning Azure storage. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorOnDeprovisioningAzureStorage = 9015;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9016, Error = true,  Facility= 9, Message = "Error on enumerating files in Azure storage. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorOnEnumeratingFilesInAzureStorage = 9016;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9019, Error = true,  Facility= 9, Message = "Error while saving Azure Game Data Blob. SessionID: {0}, GameID: {1}, FileName: {2}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileSavingAzureBlob = 9019;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9020, Error = true,  Facility= 9, Message = "Error while querying Azure Game Data Blob. SessionID: {0}, GameID: {1}, FileName: {2}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileQueryingAzureBlob = 9020;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9021, Error = true,  Facility= 9, Message = "Error while deleting Azure Game Data Blob. SessionID: {0}, GameID: {1}, FileName: {2}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileDeletingAzureBlob = 9021;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9022, Error = true,  Facility= 9, Message = "OnSubmitGameAction for game specific actions is not implemented in Passthru Game Logic Module. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int OnSubmitGameActionNotImplementedInPassthru = 9022;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9023, Error = true,  Facility= 9, Message = "GameID inconsistent in input parameters. GameID: {0}, creationData.GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int GameIDInconsistentInInputParameters = 9023;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9024, Error = true,  Facility= 9, Message = "Error while creating Session. GameID: {0}, CreationData: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileCreatingSession = 9024;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9026, Error = true,  Facility= 9, Message = "Error on trying to Serialize SeatInfo. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int UnableToSerializeSeatInfo = 9026;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9027, Error = true,  Facility= 9, Message = "Error on trying to DeSerialize SeatInfo. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int UnableToDeSerializeSeatInfo = 9027;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9029, Error = true,  Facility= 9, Message = "Add player failed: No more seats available in this session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int NoMoreSeatsInSession = 9029;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9030, Error = true,  Facility= 9, Message = "Add player failed: Incorrect seat index specified.  SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidSeatIndex = 9030;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9031, Error = true,  Facility= 9, Message = "Add player failed: this seat is already taken in this session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int SeatAlreadyTaken = 9031;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9033, Error = true,  Facility= 9, Message = "Error while trying to serialize SeatInfo. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileSerializingSeatInfo = 9033;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9034, Error = true,  Facility= 9, Message = "Error while trying to AddPlayer in Azure. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileTryingToAddPlayerInAzure = 9034;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9035, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer. GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatOnCreate = 9035;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9036, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatOnLeave = 9036;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9037, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatOnModify = 9037;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9038, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatOnView = 9038;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9039, Error = true,  Facility= 9, Message = "Cannot remove player: the player is not in the session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int PlayerIsNotInSession = 9039;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9040, Error = true,  Facility= 9, Message = "Error while serializing SeatInfo during RemovePlayer. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileSerializingSeatInfoWhileRemove = 9040;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9041, Error = true,  Facility= 9, Message = "Azure error during RemovePlayer. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int AzureErrorWhileRemovingPlayer = 9041;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9042, Error = true,  Facility= 9, Message = "New SessionState not found during RemovingPlayer. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int NewSessionStateNotFoundWhileRemovingPlayer = 9042;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9043, Error = true,  Facility= 9, Message = "Azure error while deleting SessionEntry. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int AzureErrorWhileDeletingSessionEntry = 9043;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9045, Error = true,  Facility= 9, Message = "Deserialization error while modifying the session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int DeserializationErrorWhileModifying = 9045;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9046, Error = true,  Facility= 9, Message = "No owner found for this session, cannot modify. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int NoOwnerFoundCannotModifySession = 9046;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9047, Error = true,  Facility= 9, Message = "The user is not allowed to modify the session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int UserNotAllowedToModifySession = 9047;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9048, Error = true,  Facility= 9, Message = "Error while trying to get SessionEntry list in ModifySession. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int ErrorWhileTryingToGetSessionEntriesInModify = 9048;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9049, Error = true,  Facility= 9, Message = "Error while trying to QuerySessions. User: {0}", TraceEventType = TraceEventType.Warning)]
         public static int ErrorWhileTryingToQuerySessions = 9049;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9050, Error = true,  Facility= 9, Message = "Deserialization error while deleting the session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int DeserializationErrorWhileDeleting = 9050;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9055, Error = true,  Facility= 9, Message = "Active player not found in the session. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ActivePlayerNotFound = 9055;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9058, Error = true,  Facility= 9, Message = "User Nudged player not found in the session. SessionID: {0}, GameID: {1}, Nudged player SeatIndex: {2}", TraceEventType = TraceEventType.Warning)]
         public static int UserNudgedPlayerNotFound = 9058;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9060, Error = true,  Facility= 9, Message = "GameID should be an unsigned integer, GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatWhilePostingGameResults = 9060;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9061, Error = true,  Facility= 9, Message = "This user: {0} is not allowed to submit game results for the session: SessionID: {1}, GameID: {2}", TraceEventType = TraceEventType.Warning)]
         public static int UserNotAllowedToSubmitResultsForSession = 9061;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9062, Error = true,  Facility= 9, Message = "Post GameEnd not allowed for non-Passthrough server games, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Warning)]
         public static int PostGameEndNotAllowedForNonPassthruGames = 9062;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9063, Error = true,  Facility= 9, Message = "GameID or Variant is not present in Game Metadata System, cannot create session, GameID: {0}, Variant: {1}", TraceEventType = TraceEventType.Warning)]
         public static int GameIDOrVariantIsNotInGMS = 9063;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9064, Error = true,  Facility= 9, Message = "This GameID is not a LIVE Multiplayer game, GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int ThisGameIDIsNotALIVEMultiplayerGame = 9064;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9072, Error = true,  Facility= 9, Message = "The actor IdentityToken does not have a valid XUID, IdentityToken.Token: {0}", TraceEventType = TraceEventType.Error)]
         public static int IdentityTokenDoesNotHaveValidXuid = 9072;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9073, Error = true,  Facility= 9, Message = "Error while trying to populate profile, target gamertag: {0}", TraceEventType = TraceEventType.Warning)]
         public static int ErrorWhileTryingToPopulateProfile = 9073;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9074, Error = true,  Facility= 9, Message = "Dont know how to populate profile for Non-Xuid IdentityTokens, IdentityToken.ServiceType: {0}", TraceEventType = TraceEventType.Error)]
         public static int DontKnowHowToPopulateProfileForNonXuidIdentityTokens = 9074;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9075, Error = true,  Facility= 9, Message = "The game results submitted failed validation.", TraceEventType = TraceEventType.Warning)]
         public static int ErrorWhileTryingToValidateCompositeGameResults = 9075;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9076, Error = true,  Facility= 9, Message = "Rewards error while processing GameResults, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int RewardsErrorWhileProcessingGameResults = 9076;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9077, Error = true,  Facility= 9, Message = "X-Locale HTTP header is null or empty", TraceEventType = TraceEventType.Warning)]
         public static int InvalidLocaleHeader = 9077;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9078, Error = true,  Facility= 9, Message = "X-Platform-Type HTTP header is invalid, X-Platform-Type: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidPlatformTypeHeader = 9078;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9079, Error = true,  Facility= 9, Message = "Error while trying to get and update SessionEntries from Azure storage, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileTryingToGetAndUpdateSessionEntries = 9079;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9080, Error = true,  Facility= 9, Message = "Error while serializing SeatInfo object.", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileSerializingSeatInfoObject = 9080;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9081, Error = true,  Facility= 9, Message = "Error on trying to DeSerialize SeatInfo object. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int UnableToDeSerializeSeatInfoObject = 9081;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9082, Error = true,  Facility= 9, Message = "Cannot find the actor in the the Session while Modifying it. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int CannotFindTheActorInTheSessionWhileModifying = 9082;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9084, Error = true,  Facility= 9, Message = "Variant can be specified only if GameID is specified as a query parameter. GameID: {0}, Variant: {1}", TraceEventType = TraceEventType.Warning)]
         public static int VariantCanBeSpecifiedOnlyIfGameIDIsSpecified = 9084;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9085, Error = true,  Facility= 9, Message = "Invalid GameID format on trying to validate query params. GameID: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidGameIDFormatOnValidateQueryParams = 9085;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9086, Error = true,  Facility= 9, Message = "Invalid variant format on trying to validate query params. Variant: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidVariantFormatOnValidateQueryParams = 9086;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9090, Error = true,  Facility= 9, Message = "Invalid maxSessions parameter, it must be an integer greater than 0 and less than or equal to {0}, maxSessions: {1}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidMaxSessionsParam = 9090;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9091, Error = true,  Facility= 9, Message = "Invalid ShowSession format on trying to validate query params. ShowSession: {0}", TraceEventType = TraceEventType.Warning)]
         public static int InvalidShowSessionTypeParam = 9091;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9092, Error = true,  Facility= 9, Message = "Unexpected exception in session management service. MethodName: {0}", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedExceptionInSessionService = 9092;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9093, Error = true,  Facility= 9, Message = "Unexpected exception in game state service. MethodName: {0}", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedExceptionInGameStateService = 9093;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9094, Error = true,  Facility= 9, Message = "GameId: {0} or Variant: {1} submitted in GameResult does not match the Session GameID: {2} or the Session Variant: {3}", TraceEventType = TraceEventType.Error)]
         public static int BadGameIDOrVariantSubmittedInGameResult = 9094;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9095, Error = true,  Facility= 9, Message = "Owner not found for the session while trying to get the owner's locale, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int OwnerNotFoundForTheSession = 9095;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9096, Error = true,  Facility= 9, Message = "Player: {0} not found in the session while trying to get the player's locale, SessionID: {1}, GameID: {2}", TraceEventType = TraceEventType.Error)]
         public static int PlayerNotFoundInTheSession = 9096;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9097, Error = true,  Facility= 9, Message = "Session to be modified not found, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int SessionToBeModifiedNotFound = 9097;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9098, Error = true,  Facility= 9, Message = "Error while trying to delete SessionEntries. SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileTryingToDeleteSessionEntries = 9098;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9099, Error = true,  Facility= 9, Message = "Unexpected Exception in session garbage collector plugin, stopping the session garbage collection run.", TraceEventType = TraceEventType.Error)]
         public static int UnexpectedExceptionInSessionGarbageCollector = 9099;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9100, Error = true,  Facility= 9, Message = "User is not authenticated", TraceEventType = TraceEventType.Error)]
         public static int UserIsNotAuthenticated = 9100;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9101, Error = true,  Facility= 9, Message = "User is authenticated but no current user data found", TraceEventType = TraceEventType.Error)]
         public static int UserAuthenticatedButNoCurrentUserFound = 9101;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9102, Error = true,  Facility= 9, Message = "Error while trying to get user Xuid: Xuid returned was 0, cannot associate an identity with the user", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileTryingToGetXuid = 9102;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9103, Error = true,  Facility= 9, Message = "Error while trying to get user GamerTag: GamerTag returned was null or empty, cannot associate an identity with the user", TraceEventType = TraceEventType.Error)]
         public static int ErrorWhileTryingToGetGamerTag = 9103;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9104, Error = true,  Facility= 9, Message = "Internal server error: Current user does not have a partner identity", TraceEventType = TraceEventType.Error)]
         public static int CurrentUserDoesNotHaveAPartnerIdentity = 9104;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9105, Error = true,  Facility= 9, Message = "TitleID in partner token is null or empty, cannot authorize user: TitleID: {0}", TraceEventType = TraceEventType.Error)]
         public static int PartnerTokenTitleIDIsNullOrEmpty = 9105;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9106, Error = true,  Facility= 9, Message = "GameID does not match TitleID in PartnerToken, cannot authorize user: GameID: {0}, TitleID: {1}", TraceEventType = TraceEventType.Error)]
         public static int GameIDDoesNotMatchPartnerTokenTitleID = 9106;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9107, Error = true,  Facility= 9, Message = "Invalid TitleID format in partner token, cannot authorize user: TitleID: {0}", TraceEventType = TraceEventType.Error)]
         public static int InvalidTitleIDFormat = 9107;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9108, Error = true,  Facility= 9, Message = "Invalid GameID format while getting user identity, cannot authorize user: GameID: {0}", TraceEventType = TraceEventType.Error)]
         public static int InvalidGameIDFormatWhileGettingIdentity = 9108;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9109, Error = true,  Facility= 9, Message = "Null JoinData, bad JoinSession request: SessionID: {0}", TraceEventType = TraceEventType.Error)]
         public static int NullJoinDataBadJoinSessionRequest = 9109;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9110, Error = true,  Facility= 9, Message = "SessionParameters field in CreateSession has length {0} bytes which is greater than the maximum allowed: {1} bytes", TraceEventType = TraceEventType.Error)]
         public static int SessionParametersTooLongInCreateSession = 9110;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9111, Error = true,  Facility= 9, Message = "SessionParameters field in ModifySession has length {0} bytes which is greater than the maximum allowed: {1} bytes", TraceEventType = TraceEventType.Error)]
         public static int SessionParametersTooLongInModifySession = 9111;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9112, Error = true,  Facility= 9, Message = "GameData is null or longer than the maximum allowed: {0} bytes, SessionID {1}, GameID: {2}", TraceEventType = TraceEventType.Error)]
         public static int GameDataIsNullOrTooLong = 9112;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9113, Error = true,  Facility= 9, Message = "InactivityWarning is null", TraceEventType = TraceEventType.Error)]
         public static int InactivityWarningIsNull = 9113;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9114, Error = true,  Facility= 9, Message = "MaxNumberOfNudges is less than 0 or more than {0}, value: {1}", TraceEventType = TraceEventType.Error)]
         public static int MaxNumberOfNudgesIsNotBetweenAllowedLimits = 9114;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9115, Error = true,  Facility= 9, Message = "Interval is less than 0, value: {0}", TraceEventType = TraceEventType.Error)]
         public static int IntervalIsNegative = 9115;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9116, Error = true,  Facility= 9, Message = "Operation not allowed for a session that is complete, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int OperationNotAllowedForCompleteSession = 9116;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9117, Error = true,  Facility= 9, Message = "Invalid TotalSeatsAvailable, it must not be less than 2 or greater than {0}, TotalSeatsAvailable: {1}", TraceEventType = TraceEventType.Error)]
         public static int InvalidTotalSeatsAvailable = 9117;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9119, Error = true,  Facility= 9, Message = "Cannot Nudge, active seat is empty, SessionID: {0}, GameID: {1}", TraceEventType = TraceEventType.Error)]
         public static int CannotNudgeEmptyActiveSeat = 9119;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9120, Error = true,  Facility= 9, Message = "Negative SeatIndex is not allowed, SeatIndex: {0}", TraceEventType = TraceEventType.Error)]
         public static int NegativeSeatIndexNotAllowed = 9120;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9121, Error = true,  Facility= 9, Message = "GameID is null or empty, GameID: {0}", TraceEventType = TraceEventType.Error)]
         public static int GameIDIsNullOrEmpty = 9121;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9122, Error = true,  Facility= 9, Message = "Invalid ActiveSeatIndex, it must be a positive number less than the total seats in a session. ActiveSeatIndex: {0}, TotalSeats: {1}", TraceEventType = TraceEventType.Error)]
         public static int InvalidActiveSeatIndex = 9122;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9123, Error = true,  Facility= 9, Message = "Too many sessions have been created by the user, please wait till your older sessions are garbage collected. Number of sessions created: {0}, maximum allowed: {1}", TraceEventType = TraceEventType.Warning)]
         public static int TooManySessionsCreatedByTheUser = 9123;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9124, Error = true,  Facility= 9, Message = "Interval is less than 1 when the inactivity warning behavior action is not none. InactivityWarning.Interval: {0}", TraceEventType = TraceEventType.Error)]
         public static int IntervalIsInvalid = 9124;
       
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
         [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
         [Event (MessageId = 9200, Error = true,  Facility= 9, Message = "This message id is reserved for Bug 10390: Return a better error code in two player trying to PostGameEnd scenario", TraceEventType = TraceEventType.Error)]
         public static int Reserved = 9200;
       
    }
   

   }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Program.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Security.Permissions;
using Microsoft.Deployment.Compression;
using Microsoft.Deployment.Compression.Zip;
using Microsoft.Deployment.Compression.Cab;

namespace Microsoft.LFIT
{
    class Program
    {
        static string strTempManifestCabPath;

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static void Run(string[] args)
        {
            Settings settings = new Settings();

            // Parse command line
            try
            {
                settings.ParseCommandLine(args);
            }
            catch (System.ArgumentException ex)
            {
                Log.ExceptionCaught = true;
                if (ex.ParamName != "-?")
                {
                    Log.WriteLog("Error: " + ex.Message);
                }

                Settings.DisplayUsage();
                throw;
            }

            Log.Quiet = settings.Quiet;

            // justify the input
            switch (settings.InputCommand)
            {
                case Command.All:
                    {
                        try
                        {
                            CreateCabFiles(settings);
/*
                            IList<CODESIGN.Submitter.Job> jobList = new List<CODESIGN.Submitter.Job>();

                            if (CodeSignSubmitCabs(settings, jobList) == 0)
                            {
                                CodeSignJobCheck(settings, jobList);
                                Log.WriteLog("LFIT job finished");
                            }
                            else
                            {
                                Log.WriteLog("LFIT job failed");
                            }
 */ 
                        }
                        catch (System.Exception)
                        {
                            Log.WriteLog("LFIT job failed");
                            throw;
                        }
                        break;
                    }
                case Command.Create:
                    {
                        CreateCabFiles(settings);
                        CopyCabsFromTempFolder(settings);
                        break;
                    }

                case Command.Submit:
                    {
                        //CodeSignSubmitFile(settings);
                        break;
                    }

                case Command.Check:
                    {
                        //CodeSignOneJobCheck(settings.CodeSignJobNumber);
                        break;
                    }

                default:
                        break;
            }

        }

        private static int CreateCabFiles(Settings settings)
        {
            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting " + settings.TempDirectory + @"...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting " + settings.TempDirectory + @" finished");
                }
                catch (System.IO.IOException)
                {
                    throw;
                }
            }

            if( !Directory.Exists(settings.InputFolder))
            {
                throw new System.IO.FileNotFoundException("Input folder not found", settings.InputFolder);
            }

/*
            string strUnZipFolder = Path.Combine(settings.TempDirectory, @"UnZipFiles");
            ZipInfo zip = new ZipInfo(settings.ZipFilePath);
            Log.WriteLog("Unzipping " + settings.ZipFilePath + "...");
            zip.Unpack(strUnZipFolder);
            Log.WriteLog("Unzipping finished");
*/ 

            long totalInstallSize = 0;
            CreateContentCabs(settings, settings.InputFolder, ref totalInstallSize);
            CreateManifestCab(settings, totalInstallSize);

            return 0;
        }

        private static int CreateContentCabs(Settings settings, string strUnZipFolder, ref long totalInstallSize)
        {
            CreateContentXbx(settings, settings.InputFolder);

            // Re-pack the file to CAB files ( < 2.0 G)
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            Directory.CreateDirectory(strCabFileFolder);
            string strCabName = Path.Combine(strCabFileFolder, settings.ContentID);

            totalInstallSize = 0;
            IList<string> fileList = new List<string>();
            RecursiveGetFilePathsInDirectoryTree(strUnZipFolder, true, fileList);

            foreach (string file in fileList)
            {
                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(file);
                totalInstallSize += info.Length;
            }

            IList<string> archiveFiles = new List<string>();
            long maxVolumNum = totalInstallSize / settings.MaxCabSize + 1;
            for (int i = 1; i <= maxVolumNum; i++)
            {
                archiveFiles.Add(strCabName + string.Format("_{0}.cab", i));
            }
            //Create cab files 
            CabInfo cab = new CabInfo(strCabName);

            Log.WriteLog("Compressing content cab files for " + strUnZipFolder + "...");
            cab.Pack(archiveFiles, strUnZipFolder, true, (CompressionLevel)settings.CompressionLevel, null, settings.MaxCabSize);
            Log.WriteLog("Compressing content cab files finished");
            
            return 0;
        }

        private static int CreateManifestCab(Settings settings, long totalInstallSize)
        {
            Log.WriteLog("Creating manifest.cab...");
            string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
            Directory.CreateDirectory(strManifestFolder);
            string contentFolder = Path.Combine(strManifestFolder, @"Content");
            Directory.CreateDirectory(contentFolder);

            string srcXbx = Path.Combine(settings.InputFolder, @"content.xbx");
            string destXbx = Path.Combine(strManifestFolder, @"content.xbx");
            File.Copy(srcXbx, destXbx);
            Log.WriteLog("Copied content.xbx from " + srcXbx + " to " + destXbx);

            // Create manifest file
            string strManifestFileName = Path.Combine(contentFolder, @"OfferManifest.xml");
            Manifest manifest = new Manifest();
            manifest.NewFile();
            manifest.CabFolder = Path.Combine(settings.TempDirectory, @"cabs");
            manifest.InstallSize = totalInstallSize;
            manifest.TitleId = settings.TitleID;
            manifest.LinkURL = settings.ContentURL;
            string log = manifest.SaveFile(strManifestFileName);
            Log.WriteLog(log);

            // Pack content.xbx and manifest file
            strTempManifestCabPath = Path.Combine(strManifestFolder, settings.ContentID + @"_Manifest.cab");
            CabInfo cabManifest = new CabInfo(strTempManifestCabPath);
            cabManifest.Pack(strManifestFolder, true, (CompressionLevel)settings.CompressionLevel, null);
            Log.WriteLog("Creating " + strTempManifestCabPath + " finished");

            return 0;
        }

        private static string CreateContentXbx(Settings settings, string strFolder)
        {
            // Create content.xbx
            // Create an instance of StreamWriter to write text to a file.
            // The using statement also closes the StreamWriter.
            string stringContentXbxFileName = Path.Combine(strFolder, @"content.xbx");

            if (settings.Nooverwritexbx)
            {
                if (!File.Exists(stringContentXbxFileName))
                {
                    throw new System.IO.FileNotFoundException("Error: content.xbx not found", stringContentXbxFileName);
                }
                else
                {
                    Log.WriteLog("Using content.xbx at " + stringContentXbxFileName);
                }
            }
            else
            {
                using (StreamWriter sw = new StreamWriter(stringContentXbxFileName, false, Encoding.Unicode))
                {
                    // Add some text to the file.
                    sw.WriteLine(";");
                    sw.WriteLine("; GFWL Submission Metadata File -- Generated by LFIT.exe on " + DateTime.Now.ToShortDateString());
                    sw.WriteLine(";");
                    sw.WriteLine("; Copyright (c) Microsoft Corporation");
                    sw.WriteLine(";");
                    sw.WriteLine("");

                    sw.WriteLine("[All]");
                    sw.WriteLine("Premium=No");
                    sw.WriteLine("TitleID=0x" + settings.TitleID);
                    sw.WriteLine("ContentPackageType=" + settings.ContentType);
                    sw.WriteLine("LicenseBits=0x00000000");
                    sw.WriteLine("BaseVersion=0x00000000");
                    sw.WriteLine("UpdateVersion=0x00000000");
                    sw.WriteLine("ThumbnailImage=\"generic.PNG\"");
                    sw.WriteLine("OfferingID=0x" + settings.OfferID);
                    sw.WriteLine("AdminFriendlyName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("TitleName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("PurchaseOnceOnly=Yes");
                    sw.WriteLine("ContentFlags=0xC0");
                    sw.WriteLine("ContentID=" + settings.ContentID);
                    sw.WriteLine("Platform=0x10");
                    sw.WriteLine("BitFlags=0xFFFFFFFF");
                    sw.WriteLine("ActivationDate=" + DateTime.Now.ToShortDateString());
                    sw.WriteLine("DefaultDisplayName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("OfferRegions.0=103,0,0,TaxNotApplicable");
                    if (string.Compare(settings.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=Content");
                    }
                    else if (string.Compare(settings.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=FullGame");
                    }
                    sw.WriteLine("EndDate=12/31/2999");
                    sw.WriteLine("DisplayInDash=Yes");
                    sw.WriteLine("Version=0x00020001");
                    sw.WriteLine("DashDisplayName.0=EN,\"This is LFIT.exe generic text\"");
                    sw.WriteLine("DashDescription.0=EN,\"This is LFIT.exe generic text\"");
                }
                Log.WriteLog("Saved content.xbx at " + stringContentXbxFileName);
            }

            return stringContentXbxFileName;
        }
/*
        private static int CodeSignSubmitFile(Settings settings)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                ret = codeSignSubmission.CreateSubmission(settings.CodeSignFileName, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, null);
                if (ret == 0)
                {
                    Log.WriteLog("CodeSign submission succeeded. please limit the submission less than 6G per hour before the next submission");
                }
                else
                {
                    Log.WriteLog("CodeSign submission failed.");
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignSubmitCabs(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                foreach (string file in Directory.GetFiles(strCabFileFolder))
                {
                    ret = codeSignSubmission.CreateSubmission(file, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                    if (ret == 0)
                    {
                        Log.WriteLog("Waiting 20 minutes to start submitting next job...");
                        System.Threading.Thread.Sleep(1200000);         // 20 minutes
                    }
                    else
                    {
                        break;
                    }
                }

                // Codesigne manifest.cab
                if (ret == 0)
                {
                    string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
                    string strManifesCabFile = Path.Combine(strManifestFolder, @"Manifest.cab");
                    ret = codeSignSubmission.CreateSubmission(strManifesCabFile, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        } 
        private static int CodeSignOneJobCheck(string jobNumber)
        {
            int ret = 0;
            try
            {
                    Log.WriteLog("Waiting for  CodeSign result. Job Number = {0}...", jobNumber);
                    if (Watcher.Monitor(jobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", jobNumber);
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", jobNumber);
                        ret = -1;
                    }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignJobCheck(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                Log.WriteLog("Waiting for content cab files CodeSign result...");
                foreach (CODESIGN.Submitter.Job job in jobList)
                {
                    string file = Path.GetFileName(job.FileList.Values[0].ToString());
                    Log.WriteLog("Waiting for {0} CodeSign result...", file);
                    if (Watcher.Monitor(job.JobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", file);

                        if (string.Compare(file, "manifest.cab", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                        {
                            string destManifestFileName = Path.Combine(settings.CurrentWorkingDirectory, @"Manifest.cab");
                            Log.WriteLog("Copying {0}...", file);
                            File.Copy(job.JobCompletionPath, destManifestFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                        else
                        {
                            if (!Directory.Exists(settings.ContentFilePath))
                            {
                                Directory.CreateDirectory(settings.ContentFilePath);
                            }
                            Log.WriteLog("Copying {0}...", file);
                            string destFileName = Path.Combine(settings.ContentFilePath, file);
                            File.Copy(job.JobCompletionPath, destFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", file);
                        ret = -1;
                    }
                }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }
*/
        private static int CopyCabsFromTempFolder(Settings settings)
        {
            Log.WriteLog("Moving content cab files to the unsigned cabs folder...");
            // Copy CAB files to /contentFilePath:<ContentFilePaht>
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            string strUnSignedCabPath = Path.Combine(settings.UnSignedCabPath, settings.TitleID);
            if (!Directory.Exists(strUnSignedCabPath))
            {
                Directory.CreateDirectory(strUnSignedCabPath);
            }
            foreach (string file in Directory.GetFiles(strCabFileFolder))
            {
                string destFileName = Path.Combine(strUnSignedCabPath, Path.GetFileName(file));

                // Delete (if exists) & move to overwrite
                try
                {
                    File.Delete(destFileName);
                }
                catch (System.IO.IOException)
                {
                }
                File.Move(file, destFileName);
            }
            Log.WriteLog("Moving content cab files finished");

            // Copy manifest.cab to /manifestFilePath:<ManifestFilePath>
            FileInfo fiManifest = new FileInfo(strTempManifestCabPath);
            string strManifestFileName = fiManifest.FullName;
            string destManifestFileName = Path.Combine(settings.UnSignedCabPath, fiManifest.Name);
            Log.WriteLog("Copying manifest.cab to " + destManifestFileName);

            // Delete (if exists) & move to overwrite
            try
            {
                File.Delete(destManifestFileName);
            }
            catch (System.IO.IOException)
            {
            }
            File.Move(strManifestFileName, destManifestFileName);

            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting temporary working folder...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting temporary working finished");
                }
                catch (System.IO.IOException)
                {
                }
            }

            return 0;
        }

        private static void RecursiveGetFilePathsInDirectoryTree(
            string dir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                fileList.Add(file);
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    RecursiveGetFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static int Main(string[] args)
        {
            Log.WriteLog(@"LFIT.EXE starts...");

            int returnResult = 1;
            try
            {
                Run(args);
                returnResult = 0;
            }
            catch (System.Exception ex)
            {
                if (!Log.ExceptionCaught)
                {
                    Log.WriteLog(ex.ToString());
                }
            }
            Log.WriteLog(@"LFIT.EXE ends...");
            return returnResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\ArchiveFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed file within an archive;
    /// provides operations for getting the file properties and unpacking
    /// the file.
    /// </summary>
    [Serializable]
    public abstract class ArchiveFileInfo : FileSystemInfo
    {
        private ArchiveInfo archiveInfo;
        private string name;
        private string path;

        private bool initialized;
        private bool exists;
        private int archiveNumber;
        private FileAttributes attributes;
        private DateTime lastWriteTime;
        private long length;

        /// <summary>
        /// Creates a new ArchiveFileInfo object representing a file within
        /// an archive in a specified path.
        /// </summary>
        /// <param name="archiveInfo">An object representing the archive
        /// containing the file.</param>
        /// <param name="filePath">The path to the file within the archive.
        /// Usually, this is a simple file name, but if the archive contains
        /// a directory structure this may include the directory.</param>
        protected ArchiveFileInfo(ArchiveInfo archiveInfo, string filePath)
            : base()
        {
            if (filePath == null)
            {
                throw new ArgumentNullException("filePath");
            }

            this.Archive = archiveInfo;

            this.name = System.IO.Path.GetFileName(filePath);
            this.path = System.IO.Path.GetDirectoryName(filePath);

            this.attributes = FileAttributes.Normal;
            this.lastWriteTime = DateTime.MinValue;
        }

        /// <summary>
        /// Creates a new ArchiveFileInfo object with all parameters specified;
        /// used by subclasses when reading the metadata out of an archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in
        /// the archive.</param>
        /// <param name="archiveNumber">The archive number where the file
        /// starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the
        /// file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        protected ArchiveFileInfo(
            string filePath,
            int archiveNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : this(null, filePath)
        {
            this.exists = true;
            this.archiveNumber = archiveNumber;
            this.attributes = attributes;
            this.lastWriteTime = lastWriteTime;
            this.length = length;
            this.initialized = true;
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveFileInfo class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.archiveInfo = (ArchiveInfo) info.GetValue(
                "archiveInfo", typeof(ArchiveInfo));
            this.name = info.GetString("name");
            this.path = info.GetString("path");
            this.initialized = info.GetBoolean("initialized");
            this.exists = info.GetBoolean("exists");
            this.archiveNumber = info.GetInt32("archiveNumber");
            this.attributes = (FileAttributes) info.GetValue(
                "attributes", typeof(FileAttributes));
            this.lastWriteTime = info.GetDateTime("lastWriteTime");
            this.length = info.GetInt64("length");
        }

        /// <summary>
        /// Gets the name of the file.
        /// </summary>
        /// <value>The name of the file, not including any path.</value>
        public override string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Gets the internal path of the file in the archive.
        /// </summary>
        /// <value>The internal path of the file in the archive, not including
        /// the file name.</value>
        public string Path
        {
            get
            {
                return this.path;
            }
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <value>The full path to the file, including the full path to the
        /// archive, the internal path in the archive, and the file name.</value>
        /// <remarks>
        /// For example, the path <c>"C:\archive.cab\file.txt"</c> refers to
        /// a file "file.txt" inside the archive "archive.cab".
        /// </remarks>
        public override string FullName
        {
            get
            {
                string fullName = System.IO.Path.Combine(this.Path, this.Name);
                
                if (this.Archive != null)
                {
                    fullName = System.IO.Path.Combine(this.ArchiveName, fullName);
                }

                return fullName;
            }
        }

        /// <summary>
        /// Gets or sets the archive that contains this file.
        /// </summary>
        /// <value>
        /// The ArchiveInfo instance that retrieved this file information -- this
        /// may be null if the ArchiveFileInfo object was returned directly from
        /// a stream.
        /// </value>
        public ArchiveInfo Archive
        {
            get
            {
                return (ArchiveInfo) this.archiveInfo;
            }

            internal set
            {
                this.archiveInfo = value;

                // protected instance members inherited from FileSystemInfo:
                this.OriginalPath = (value != null ? value.FullName : null);
                this.FullPath = this.OriginalPath;
            }
        }

        /// <summary>
        /// Gets the full path of the archive that contains this file.
        /// </summary>
        /// <value>The full path of the archive that contains this file.</value>
        public string ArchiveName
        {
            get
            {
                return this.Archive != null ? this.Archive.FullName : null;
            }
        }

        /// <summary>
        /// Gets the number of the archive where this file starts.
        /// </summary>
        /// <value>The number of the archive where this file starts.</value>
        /// <remarks>A single archive or the first archive in a chain is
        /// numbered 0.</remarks>
        public int ArchiveNumber
        {
            get
            {
                return this.archiveNumber;
            }
        }

        /// <summary>
        /// Checks if the file exists within the archive.
        /// </summary>
        /// <value>True if the file exists, false otherwise.</value>
        public override bool Exists
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.exists;
            }
        }

        /// <summary>
        /// Gets the uncompressed size of the file.
        /// </summary>
        /// <value>The uncompressed size of the file in bytes.</value>
        public long Length
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.length;
            }
        }

        /// <summary>
        /// Gets the attributes of the file.
        /// </summary>
        /// <value>The attributes of the file as stored in the archive.</value>
        public new FileAttributes Attributes
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.attributes;
            }
        }

        /// <summary>
        /// Gets the last modification time of the file.
        /// </summary>
        /// <value>The last modification time of the file as stored in the
        /// archive.</value>
        public new DateTime LastWriteTime
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.lastWriteTime;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(
            SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("archiveInfo", this.archiveInfo);
            info.AddValue("name", this.name);
            info.AddValue("path", this.path);
            info.AddValue("initialized", this.initialized);
            info.AddValue("exists", this.exists);
            info.AddValue("archiveNumber", this.archiveNumber);
            info.AddValue("attributes", this.attributes);
            info.AddValue("lastWriteTime", this.lastWriteTime);
            info.AddValue("length", this.length);
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <returns>The same as <see cref="FullName"/></returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the file. NOT SUPPORTED.
        /// </summary>
        /// <exception cref="NotSupportedException">Files cannot be deleted
        /// from an existing archive.</exception>
        public override void Delete()
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// Refreshes the attributes and other cached information about the file,
        /// by re-reading the information from the archive.
        /// </summary>
        public new void Refresh()
        {
            base.Refresh();

            if (this.Archive != null)
            {
                string filePath = System.IO.Path.Combine(this.Path, this.Name);
                ArchiveFileInfo updatedFile = this.Archive.GetFile(filePath);
                if (updatedFile == null)
                {
                    throw new FileNotFoundException(
                            "File not found in archive.", filePath);
                }

                this.Refresh(updatedFile);
            }
        }

        /// <summary>
        /// Extracts the file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            this.CopyTo(destFileName, false);
        }

        /// <summary>
        /// Extracts the file, optionally overwriting any existing file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        /// <param name="overwrite">If true, <paramref name="destFileName"/>
        /// will be overwritten if it exists.</param>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false
        /// and <paramref name="destFileName"/> exists.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            if (!overwrite && File.Exists(destFileName))
            {
                throw new IOException();
            }

            if (this.Archive == null)
            {
                throw new InvalidOperationException();
            }

            this.Archive.UnpackFile(
                System.IO.Path.Combine(this.Path, this.Name), destFileName);
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// Subclasses may override this method to refresh sublcass fields.
        /// However they should always call the base implementation first.
        /// </remarks>
        protected virtual void Refresh(ArchiveFileInfo newFileInfo)
        {
            this.exists = newFileInfo.exists;
            this.length = newFileInfo.length;
            this.attributes = newFileInfo.attributes;
            this.lastWriteTime = newFileInfo.lastWriteTime;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\ArchiveFileStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="ArchiveFileStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Provides a basic implementation of the archive pack and unpack stream context
    /// interfaces, based on a list of archive files, a default directory, and an
    /// optional mapping from internal to external file paths.
    /// </summary>
    /// <remarks>
    /// This class can also handle creating or extracting chained archive packages.
    /// </remarks>
    public class ArchiveFileStreamContext
        : IPackStreamContext, IUnpackStreamContext
    {
        private IList<string> archiveFiles;
        private string directory;
        private IDictionary<string, string> files;
        private bool extractOnlyNewerFiles;
        private bool enableOffsetOpen;

        #region Constructors

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file and
        /// no default directory or file mapping.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        public ArchiveFileStreamContext(string archiveFile)
            : this(archiveFile, null, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file, default
        /// directory and mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are
        /// used, see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            string archiveFile,
            string directory,
            IDictionary<string, string> files)
            : this(new string[] { archiveFile }, directory, files)
        {
            if (archiveFile == null)
            {
                throw new ArgumentNullException("archiveFile");
            }
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a list of archive files,
        /// a default directory and a mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFiles">A list of paths to archive files that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// When creating chained archives, the <paramref name="archiveFiles"/> list
        /// should include at least enough archives to handle the entire set of
        /// input files, based on the maximum archive size that is passed to the
        /// <see cref="CompressionEngine"/>.<see
        /// cref="CompressionEngine.Pack(IPackStreamContext,IEnumerable&lt;string&gt;,long)"/>.
        /// <para>If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.</para>
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are used,
        /// see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            IList<string> archiveFiles,
            string directory,
            IDictionary<string, string> files)
        {
            if (archiveFiles == null || archiveFiles.Count == 0)
            {
                throw new ArgumentNullException("archiveFiles");
            }

            this.archiveFiles = archiveFiles;
            this.directory = directory;
            this.files = files;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the list of archive files that are created or extracted.
        /// </summary>
        /// <value>The list of archive files that are created or extracted.</value>
        public IList<string> ArchiveFiles
        {
            get
            {
                return this.archiveFiles;
            }
        }

        /// <summary>
        /// Gets or sets the default root directory where files are located.
        /// </summary>
        /// <value>The default root directory where files are located.</value>
        /// <remarks>
        /// For details about how the default directory is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public string Directory
        {
            get
            {
                return this.directory;
            }
        }

        /// <summary>
        /// Gets or sets the mapping from internal file paths to external file paths.
        /// </summary>
        /// <value>A mapping from internal file paths to external file paths.</value>
        /// <remarks>
        /// For details about how the files mapping is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public IDictionary<string, string> Files
        {
            get
            {
                return this.files;
            }
        }

        /// <summary>
        /// Gets or sets a flag that can prevent extracted files from overwriting
        /// newer files that already exist.
        /// </summary>
        /// <value>True to prevent overwriting newer files that already exist
        /// during extraction; false to always extract from the archive regardless
        /// of existing files.</value>
        public bool ExtractOnlyNewerFiles
        {
            get
            {
                return this.extractOnlyNewerFiles;
            }

            set
            {
                this.extractOnlyNewerFiles = value;
            }
        }

        /// <summary>
        /// Gets or sets a flag that enables creating or extracting an archive
        /// at an offset within an existing file. (This is typically used to open
        /// archive-based self-extracting packages.)
        /// </summary>
        /// <value>True to search an existing package file for an archive offset
        /// or the end of the file;/ false to always create or open a plain
        /// archive file.</value>
        public bool EnableOffsetOpen
        {
            get
            {
                return this.enableOffsetOpen;
            }

            set
            {
                this.enableOffsetOpen = value;
            }
        }

        #endregion

        #region IPackStreamContext Members

        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>This method returns the file name of the archive from the
        /// <see cref="archiveFiles"/> list with the specified index, or an empty
        /// string if the archive number is outside the bounds of the list. The
        /// file name should not include any directory path.</remarks>
        public virtual string GetArchiveName(int archiveNumber)
        {
            if (archiveNumber < this.archiveFiles.Count)
            {
                return Path.GetFileName(this.archiveFiles[archiveNumber]);
            }

            return String.Empty;
        }

        /// <summary>
        /// Opens a stream for writing an archive.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list
        /// with the specified index. If the archive number is outside the bounds
        /// of the list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method
        /// will seek to the start of any existing archive in the file, or to the
        /// end of the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            if (String.IsNullOrEmpty(archiveName))
            {
                throw new ArgumentNullException("archiveName");
            }

            // All archives must be in the same directory,
            // so always use the directory from the first archive.
            string archiveFile = Path.Combine(
                Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
            Stream stream = File.Open(
                archiveFile,
                (truncate ? FileMode.OpenOrCreate : FileMode.Open),
                FileAccess.ReadWrite);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));

                // If this is not an archive file, append the archive to it.
                if (offset < 0)
                {
                    offset = stream.Length;
                }

                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }

                stream.Seek(0, SeekOrigin.Begin);
            }

            if (truncate)
            {
                // Truncate the stream, in case a larger old archive starts here.
                stream.SetLength(0);
            }
            
            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            Stream stream)
        {
            if (stream != null)
            {
                stream.Close();

                FileStream fileStream = stream as FileStream;
                if (fileStream != null)
                {
                    string streamFile = fileStream.Name;
                    if (!String.IsNullOrEmpty(archiveName) &&
                        archiveName != Path.GetFileName(streamFile))
                    {
                        string archiveFile = Path.Combine(
                            Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
                        if (File.Exists(archiveFile))
                        {
                            File.Delete(archiveFile);
                        }
                        File.Move(streamFile, archiveFile);
                    }
                }
            }
        }

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="attributes">The returned attributes of the opened file,
        /// to be stored in the archive.</param>
        /// <param name="lastWriteTime">The returned last-modified time of the
        /// opened file, to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from
        /// before they are compressed, or null to skip inclusion of the file and
        /// continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened, relative
        /// to the specified directory (or it may be an absolute path). If no mapping
        /// exists, the file is skipped.</item>
        /// </list>
        /// </remarks>
        public virtual Stream OpenFileReadStream(
            string path, out FileAttributes attributes, out DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                attributes = FileAttributes.Normal;
                lastWriteTime = DateTime.Now;
                return null;
            }

            attributes = File.GetAttributes(filePath);
            lastWriteTime = File.GetLastWriteTime(filePath);
            return File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
        }

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseFileReadStream(string path, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Gets extended parameter information specific to the compression format
        /// being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This implementation does not handle any options. Subclasses may override
        /// this method to allow for non-default behavior.
        /// </remarks>
        public virtual object GetOption(string optionName, object[] parameters)
        {
            return null;
        }

        #endregion

        #region IUnpackStreamContext Members

        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to
        /// open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel
        /// extraction of the archive.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list with
        /// the specified index. If the archive number is outside the bounds of the
        /// list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method will
        /// seek to the start of any existing archive in the file, or to the end of
        /// the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveReadStream(
            int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            string archiveFile = this.archiveFiles[archiveNumber];
            Stream stream = File.Open(
                archiveFile, FileMode.Open, FileAccess.Read, FileShare.Read);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));
                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }
                else
                {
                    stream.Seek(0, SeekOrigin.Begin);
                }
            }

            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream
        /// to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveReadStream(
            int archiveNumber, string archiveName, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be
        /// extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be
        /// extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null
        /// to skip extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened,
        /// relative to the specified directory (or it may be an absolute path).
        /// If no mapping exists, the file is skipped.</item>
        /// </list>
        /// <para>If the <see cref="ExtractOnlyNewerFiles"/> flag is set, the file
        /// is skipped if a file currently exists in the same path with an equal
        /// or newer write time.</para>
        /// </remarks>
        public virtual Stream OpenFileWriteStream(
            string path,
            long fileSize,
            DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                return null;
            }

            FileInfo file = new FileInfo(filePath);
            if (file.Exists)
            {
                if (this.extractOnlyNewerFiles && lastWriteTime != DateTime.MinValue)
                {
                    if (file.LastWriteTime >= lastWriteTime)
                    {
                        return null;
                    }
                }

                if ((file.Attributes & FileAttributes.ReadOnly) != 0)
                {
                    file.Attributes &= ~FileAttributes.ReadOnly;
                }
            }

            if (!file.Directory.Exists)
            {
                file.Directory.Create();
            }

            return File.Open(
                filePath, FileMode.Create, FileAccess.Write, FileShare.None);
        }

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenFileWriteStream"/> and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// After closing the extracted file stream, this method applies the date
        /// and attributes to that file.
        /// </remarks>
        public virtual void CloseFileWriteStream(
            string path,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime)
        {
            if (stream != null)
            {
                stream.Close();
            }

            string filePath = this.TranslateFilePath(path);
            if (filePath != null)
            {
                FileInfo file = new FileInfo(filePath);

                if (lastWriteTime != DateTime.MinValue)
                {
                    try
                    {
                        file.LastWriteTime = lastWriteTime;
                    }
                    catch (ArgumentException)
                    {
                    }
                    catch (IOException)
                    {
                    }
                }

                try
                {
                    file.Attributes = attributes;
                }
                catch (IOException)
                {
                }
            }
        }

        #endregion

        #region Private utility methods

        /// <summary>
        /// Translates an internal file path to an external file path using the
        /// <see cref="Directory"/> and the <see cref="Files"/> mapping, according to
        /// rules documented in <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.
        /// </summary>
        /// <param name="path">The path of the file with the archive.</param>
        /// <returns>The external path of the file, or null if there is no
        /// valid translation.</returns>
        private string TranslateFilePath(string path)
        {
            string filePath;
            if (this.files != null)
            {
                filePath = this.files[path];
            }
            else
            {
                filePath = path;
            }

            if (filePath != null)
            {
                if (this.directory != null)
                {
                    filePath = Path.Combine(this.directory, filePath);
                }
            }

            return filePath;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Manifest.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Manifest.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------

namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Xml;

    public class Manifest
    {
        private string cabFolder;
        private long installSize;
        private string linkURL;
        private string titleId;

        public Manifest()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        public string CabFolder
        {
            get { return this.cabFolder; }
            set { this.cabFolder = value; }
        }

        public long InstallSize
        {
            get { return this.installSize; }
            set { this.installSize = value; }
        }

        public string LinkURL
        {
            get { return this.linkURL; }
            set { this.linkURL = value; }
        }

        public string TitleId
        {
            get { return this.titleId; }
            set { this.titleId = value; }
        }

        public void NewFile()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public string SaveFile(string outputPath)
        {
            XmlDocument doc = new XmlDocument();

            XmlNode node = doc.CreateNode(XmlNodeType.XmlDeclaration, "OfferManifest", null);
            XmlDeclaration decl = (XmlDeclaration)node;
            decl.Encoding = @"utf-8";
            doc.AppendChild(node);

            XmlNode root = doc.CreateNode(XmlNodeType.Element, "OfferManifest", null);
            XmlAttribute titleIDAtt = doc.CreateAttribute("TitleId");
            titleIDAtt.Value = this.titleId;
            root.Attributes.Append(titleIDAtt);
            doc.AppendChild(root);

            XmlNode itemsNode = doc.CreateNode(XmlNodeType.Element, "Items", null);
            XmlAttribute installSizeAtt = doc.CreateAttribute("InstallSize");
            installSizeAtt.Value = this.installSize.ToString();
            itemsNode.Attributes.Append(installSizeAtt);
            root.AppendChild(itemsNode);


            foreach (string fileName in Directory.GetFiles(cabFolder))
            {
                XmlNode fileNode = doc.CreateNode(XmlNodeType.Element, "Item", null);
                XmlAttribute idAtt = doc.CreateAttribute("ID");
                idAtt.Value = Path.GetFileName(fileName);
                fileNode.Attributes.Append(idAtt);

                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(fileName);
                XmlAttribute sizeAtt = doc.CreateAttribute("DownloadSize");
                sizeAtt.Value = info.Length.ToString();
                fileNode.Attributes.Append(sizeAtt);
                itemsNode.AppendChild(fileNode);

                XmlNode linkNode = doc.CreateNode(XmlNodeType.Element, "Link", null);
                XmlAttribute urlAtt = doc.CreateAttribute("Url");

                Uri urlBase = new Uri(this.linkURL);
                if( this.linkURL.EndsWith("\\") || this.linkURL.EndsWith("/"))
                {
                    urlAtt.Value = this.linkURL + Path.GetFileName(fileName);
                }
                else
                {
                    if (this.linkURL.Contains("://"))
                    {
                        urlAtt.Value = this.linkURL + "/" + Path.GetFileName(fileName);
                    }
                    else
                    {
                        Log.WriteLog("File: " + Path.GetFileName(fileName));
                        urlAtt.Value = Path.Combine(this.linkURL, Path.GetFileName(fileName));
                    }
                }
                Log.WriteLog("FileURL: " + urlAtt.Value);
                linkNode.Attributes.Append(urlAtt);
                fileNode.AppendChild(linkNode);
            }

            doc.Save(outputPath);
            if (!File.Exists(outputPath))
            {
                throw new FileNotFoundException();
            }

            return "Saved manifest file at " + outputPath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\ArchiveInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed archive on disk;
    /// provides access to file-based operations on the archive.
    /// </summary>
    [Serializable]
    public abstract class ArchiveInfo : FileSystemInfo
    {
        /// <summary>
        /// Creates a new ArchiveInfo object representing an archive in a
        /// specified path.
        /// </summary>
        /// <param name="path">The path to the archive. When creating an archive,
        /// this file does not necessarily exist yet.</param>
        protected ArchiveInfo(string path) : base()
        {
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // protected instance members inherited from FileSystemInfo:
            this.OriginalPath = path;
            this.FullPath = Path.GetFullPath(path);
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object
        /// data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Gets the directory that contains the archive.
        /// </summary>
        /// <value>A DirectoryInfo object representing the parent directory of the
        /// archive.</value>
        public DirectoryInfo Directory
        {
            get
            {
                return new DirectoryInfo(Path.GetDirectoryName(this.FullName));
            }
        }

        /// <summary>
        /// Gets the full path of the directory that contains the archive.
        /// </summary>
        /// <value>The full path of the directory that contains the archive.</value>
        public string DirectoryName
        {
            get
            {
                return Path.GetDirectoryName(this.FullName);
            }
        }

        /// <summary>
        /// Gets the size of the archive.
        /// </summary>
        /// <value>The size of the archive in bytes.</value>
        public long Length
        {
            get
            {
                return new FileInfo(this.FullName).Length;
            }
        }

        /// <summary>
        /// Gets the file name of the archive.
        /// </summary>
        /// <value>The file name of the archive, not including any path.</value>
        public override string Name
        {
            get
            {
                return Path.GetFileName(this.FullName);
            }
        }

        /// <summary>
        /// Checks if the archive exists.
        /// </summary>
        /// <value>True if the archive exists; else false.</value>
        public override bool Exists
        {
            get
            {
                return File.Exists(this.FullName);
            }
        }

        /// <summary>
        /// Gets the full path of the archive.
        /// </summary>
        /// <returns>The full path of the archive.</returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the archive.
        /// </summary>
        public override void Delete()
        {
            File.Delete(this.FullName);
        }

        /// <summary>
        /// Copies an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            File.Copy(this.FullName, destFileName);
        }

        /// <summary>
        /// Copies an existing archive to another location, optionally
        /// overwriting the destination file.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        /// <param name="overwrite">If true, the destination file will be
        /// overwritten if it exists.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            File.Copy(this.FullName, destFileName, overwrite);
        }
        
        /// <summary>
        /// Moves an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void MoveTo(string destFileName)
        {
            File.Move(this.FullName, destFileName);
            this.FullPath = Path.GetFullPath(destFileName);
        }

        /// <summary>
        /// Checks if the archive contains a valid archive header.
        /// </summary>
        /// <returns>True if the file is a valid archive; false otherwise.</returns>
        public bool IsValid()
        {
            using (Stream stream = File.OpenRead(this.FullName))
            {
                using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
                {
                    return compressionEngine.FindArchiveOffset(stream) >= 0;
                }
            }
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles()
        {
            return this.InternalGetFiles((Predicate<string>) null);
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles(string searchPattern)
        {
            if (searchPattern == null)
            {
                throw new ArgumentNullException("searchPattern");
            }

            string regexPattern = String.Format(
                CultureInfo.InvariantCulture,
                "^{0}$",
                Regex.Escape(searchPattern).Replace("\\*", ".*").Replace("\\?", "."));
            Regex regex = new Regex(
                    regexPattern,
                    RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

            return this.InternalGetFiles(
                delegate(string match)
                {
                    return regex.IsMatch(match);
                });
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(string destDirectory)
        {
            this.Unpack(destDirectory, null);
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory,
        /// optionally extracting only newer files.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, null);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(streamContext, null);
            }
        }

        /// <summary>
        /// Extracts a single file from the archive.
        /// </summary>
        /// <param name="fileName">The name of the file in the archive. Also
        /// includes the internal path of the file, if any. File name matching
        /// is case-insensitive.</param>
        /// <param name="destFileName">The path where the file is to be
        /// extracted on disk.</param>
        /// <remarks>If <paramref name="destFileName"/> already exists,
        /// it will be overwritten.</remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFile(string fileName, string destFileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            this.UnpackFiles(
                new string[] { fileName },
                null,
                new string[] { destFileName });
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames)
        {
            this.UnpackFiles(fileNames, destDirectory, destFileNames, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive, optionally extracting
        /// only newer files.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            if (destFileNames == null)
            {
                if (destDirectory == null)
                {
                    throw new ArgumentNullException("destFileNames");
                }

                destFileNames = fileNames;
            }

            if (destFileNames.Count != fileNames.Count)
            {
                throw new ArgumentOutOfRangeException("destFileNames");
            }

            IDictionary<string, string> files =
                ArchiveInfo.CreateStringDictionary(fileNames, destFileNames);
            this.UnpackFileSet(files, destDirectory, progressHandler);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal paths
        /// depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external paths
        /// in <paramref name="fileNameMap"/>.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory)
        {
            this.UnpackFileSet(fileNames, destDirectory, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal
        /// paths depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external
        /// paths in <paramref name="fileNameMap"/>.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(
                    streamContext,
                    delegate(string match)
                    {
                        return fileNames.ContainsKey(match);
                    });
            }
        }

        /// <summary>
        /// Compresses all files in a directory into the archive.
        /// Does not include subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">The directory containing the
        /// files to be included.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void Pack(string sourceDirectory)
        {
            this.Pack(sourceDirectory, false, CompressionLevel.Max, null);
        }
        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            IList<string> archiveFiles,
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(archiveFiles, sourceDirectory, files, files, compLevel, progressHandler, maxArchiveSize);
        }

        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(sourceDirectory, files, files, compLevel, progressHandler);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored
        /// in the archive. Each name
        /// includes the internal path of the file, if any. This parameter may
        /// be null, in which case the files are stored in the archive with their
        /// source file names and no path information.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// <p>Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.</p>
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames)
        {
            this.PackFiles(
                sourceDirectory,
                sourceFileNames,
                fileNames,
                CompressionLevel.Max,
                null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            IList<string> archiveFiles,
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                
                ArchiveFileStreamContext streamContext;
                if (archiveFiles == null)
                {
                    streamContext = new ArchiveFileStreamContext(
                            this.FullName, sourceDirectory, contextFiles);
                }
                else
                {
                    streamContext = new ArchiveFileStreamContext(
                            archiveFiles, sourceDirectory, contextFiles);
                }
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames, maxArchiveSize);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, contextFiles);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used
        /// to store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames)
        {
            this.PackFileSet(sourceDirectory, fileNames, CompressionLevel.Max, null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            string[] fileNamesArray = new string[fileNames.Count];
            fileNames.Keys.CopyTo(fileNamesArray, 0);

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNamesArray);
            }
        }

        /// <summary>
        /// Given a directory, gets the relative paths of all files in the
        /// directory, optionally including all subdirectories.
        /// </summary>
        /// <param name="dir">The directory to search.</param>
        /// <param name="includeSubdirectories">True to include subdirectories
        /// in the search.</param>
        /// <returns>A list of file paths relative to the directory.</returns>
        internal IList<string> GetRelativeFilePathsInDirectoryTree(
            string dir, bool includeSubdirectories)
        {
            IList<string> fileList = new List<string>();
            this.RecursiveGetRelativeFilePathsInDirectoryTree(
                dir, String.Empty, includeSubdirectories, fileList);
            return fileList;
        }

        /// <summary>
        /// Retrieves information about one file from this archive.
        /// </summary>
        /// <param name="path">Path of the file in the archive.</param>
        /// <returns>File information, or null if the file was not found
        /// in the archive.</returns>
        internal ArchiveFileInfo GetFile(string path)
        {
            IList<ArchiveFileInfo> files = this.InternalGetFiles(
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            return (files != null && files.Count > 0 ? files[0] : null);
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new compression engine instance that matches the specific
        /// subclass of archive.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected abstract CompressionEngine CreateCompressionEngine();

        /// <summary>
        /// Creates a case-insensitive dictionary mapping from one list of
        /// strings to the other.
        /// </summary>
        /// <param name="keys">List of keys.</param>
        /// <param name="values">List of values that are mapped 1-to-1 to
        /// the keys.</param>
        /// <returns>A filled dictionary of the strings.</returns>
        private static IDictionary<string, string> CreateStringDictionary(
            IList<string> keys, IList<string> values)
        {
            IDictionary<string, string> stringDict =
                new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < keys.Count; i++)
            {
                stringDict.Add(keys[i], values[i]);
            }

            return stringDict;
        }

        /// <summary>
        /// Recursive-descent helper function for
        /// GetRelativeFilePathsInDirectoryTree.
        /// </summary>
        /// <param name="dir">The root directory of the search.</param>
        /// <param name="relativeDir">The relative directory to be
        /// processed now.</param>
        /// <param name="includeSubdirectories">True to descend into
        /// subdirectories.</param>
        /// <param name="fileList">List of files found so far.</param>
        private void RecursiveGetRelativeFilePathsInDirectoryTree(
            string dir,
            string relativeDir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                string fileName = Path.GetFileName(file);
                fileList.Add(Path.Combine(relativeDir, fileName));
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    this.RecursiveGetRelativeFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        Path.Combine(relativeDir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        /// <summary>
        /// Uses a CompressionEngine to get ArchiveFileInfo objects from this
        /// archive, and then associates them with this ArchiveInfo instance.
        /// </summary>
        /// <param name="fileFilter">Optional predicate that can determine
        /// which files to process.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        private IList<ArchiveFileInfo> InternalGetFiles(Predicate<string> fileFilter)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, null, null);
                streamContext.EnableOffsetOpen = true;
                IList<ArchiveFileInfo> files =
                    compressionEngine.GetFileInfo(streamContext, fileFilter);
                for (int i = 0; i < files.Count; i++)
                {
                    files[i].Archive = this;
                }

                return files;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Settings.cs ===
﻿using System.Globalization;
//-----------------------------------------------------------------------
// <copyright file="Settings.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    
    public enum Command
    {
        All = 0,
        Create,
        Submit,
        Check
    }
    
    public class Settings
    {
        private const long twoGigs = 2146435072;
        private const int lengthTitleId = 8;
        private const int lengthContentId = 40;
        private const int lengthOfferId = 16;

        private bool quiet;

        private Command inputCommand;
        //private string codeSignFileName;
        private string srcFileName;
        private string dstFileName;
        //private string codeSignJobNumber;
        //private string codeSignCompletionPath;
        private long maxCabSize;
        private string titleID;
        private string contentID;
        private string offerID;
        private string contentType;
        private string contentURL;
        private string inputFolder;
        private string unSignedCabPath;
        private string contentFilePath;
        private string currentWorkingDirectory;
        private string tempDirectory;
        private int compressionLevel;
        private bool nooverwritexbx;
        //private IList<string> signers;
        //private string largeFileCertID;
        //private string normalFileCertID;
        //private string strongNameCertID;

        public Settings()
        {
            quiet = false;
            inputCommand = Command.All;
            //signers = new List<string>();
            //largeFileCertID = @"10038";
            //normalFileCertID = @"10006";
            //strongNameCertID = @"";
            //codeSignJobNumber = @"";
            //codeSignCompletionPath = @"";
            //codeSignFileName = @"";
            maxCabSize = Settings.twoGigs;    // default = 2G - 1MB
            contentFilePath = @"\\xsinfxferinh001\Content\";
            contentURL = @"\\xsinfxferinh001\Content\";
            this.currentWorkingDirectory = Directory.GetCurrentDirectory();
            srcFileName = @"";
            dstFileName = @"";
        }

        public bool Quiet
        {
            get { return this.quiet; }
        }

        public Command InputCommand
        {
            get { return this.inputCommand; }
        }

        public string SrcFileName
        {
            get { return this.srcFileName; }
        }

        public int CompressionLevel
        {
            get { return compressionLevel; }
        }

        public bool Nooverwritexbx
        {
            get { return nooverwritexbx; }
        }

        public string DstFileName
        {
            get { return this.dstFileName; }
        }
        /*
        public string CodeSignFileName
        {
            get { return this.codeSignFileName; }
        }

        public string CodeSignJobNumber
        {
            get { return this.codeSignJobNumber; }
        }

        public string CodeSignCompletionPath
        {
            get { return this.codeSignCompletionPath; }
        }
        public IList<string> Signers
        {
            get { return this.signers; }
        }
        public string LargeFileCertID
        {
            get { return this.largeFileCertID; }
        }

        public string NormalFileCertID
        {
            get { return this.normalFileCertID; }
        }

        public string StrongNameCertID
        {
            get { return this.strongNameCertID; }
        }
        */
        public long MaxCabSize
        {
            get { return this.maxCabSize; }
        }

        public string InputFolder
        {
            get { return this.inputFolder; }
        }
        public string TitleID
        {
            get { return this.titleID; }
        }
        public string OfferID
        {
            get { return this.offerID; }
        }
        public string ContentID
        {
            get { return this.contentID; }
        }
        public string ContentType
        {
            get { return this.contentType; }
        }
        public string ContentFilePath
        {
            get { return this.contentFilePath; }
        }
        public string ContentURL
        {
            get { return this.contentURL; }
        }
        public string CurrentWorkingDirectory
        {
            get { return this.currentWorkingDirectory; }
        }
        public string TempDirectory
        {
            get { return this.tempDirectory; }
        }
        public string UnSignedCabPath
        {
            get { return this.unSignedCabPath; }
        }

        public static void DisplayUsage()
        {
            Log.WriteLog("\nCreates and props full game content files for Windows - LIVE title");
            Log.WriteLog(string.Empty);
            Log.WriteLog("Usage: LFIT.exe [command] /inputFolder <inputFolder> /titleId <TitleID> /contentId <ContentID> /offerId <OfferID> /contentType <ContentType> /unsignedCabPath <UnsignedCabPath> [/maxCabSize <maxCabSize>] [/contentURL <ContentURL>] [/compressionLevel <CompressionLevel>]");
            Log.WriteLog(string.Empty);
            Log.WriteLog("\t[command]\tcreate - create content and manifest cabs\n");
            Log.WriteLog("\t/q\t\t\tQuiet mode. No output displayed\n");
            Log.WriteLog("\t/inputFolder\t\tThe folder containing all of the full game files\n");
            Log.WriteLog("\t/titleId\t\tThe 8-char Title ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentId\t\tThe Content ID to be assigned to the spanned cabs\n");
            Log.WriteLog("\t/offerId\t\tThe full Offer ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentType\t\tCan be 0x00007000 (for FullGame) or 0x00080000 (for GameDemo)\n");
            Log.WriteLog("\t/maxCabSize\t\tThe maximum size of one cab file (in megabyte)\n\t\t\t\tDefault: 2048\n");
            Log.WriteLog("\t/unsignedCabPath\tThe folder to where the unsigned spanned CABs will be dropped\n");
            Log.WriteLog("\t/contentURL\t\tThe CDN location from which the spanned CABs can be reached\n\t\t\t\tDefault: \\\\xsinfxferinh001\\Content\n");
            Log.WriteLog("\t/compressionLevel\tCompression level number between 0 to 10. 0 = none and fast. 10 = max and slow. Defaults to 10.\n");
            Log.WriteLog("\t/nooverwritexbx\t\tLFIT will not overwrite or create a content.xbx.  It uses the existing one in the input folder\n");
            //Log.WriteLog("\t\t\tsubmit - submit one cab for CodeSign\n");
            //Log.WriteLog("\t\t\t\t  /fileName <FileName> /signer <Alias1> /signer <Alias2>\n");
            //Log.WriteLog("\t\t\tcheck - check CodeSign result\n");
            //Log.WriteLog("\t\t\t\t  /codeSignJobNumber <CodeSignJobNumber> \n");
            //Log.WriteLog("\t/signer \t\tRepeat input once for each person who can approve the request\n");
            //Log.WriteLog("\t/largeFileCertID\tCertificate ID used to sign files bigger than 500M\n\t\t\t\tDefault: 10038\n");
            //Log.WriteLog("\t/normalFileCertID\tCertificate ID used to sign files less than 500M\n\t\t\t\tDefault: 10006\n");
            //Log.WriteLog("\t/strongNameCertID\tCertificate ID used to sign files with strong name\n\t\t\t\tDefault: not used\n");
        }

        public void ParseCommandLine(string[] args)
        {
            this.tempDirectory = Path.Combine(System.IO.Path.GetTempPath(), @"LFIT");

            for (int i = 0; i < args.Length; i++)
            {
                string arg = args[i];
                if (arg[0] == '-' || arg[0] == '/')
                {
                    arg = arg.Remove(0, 1);
                    if (string.Compare(arg, "q", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.quiet = true;
                    }
                    else if (string.Compare(arg, "MaxCabSize", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.maxCabSize = Convert.ToInt64(args[i]) * 1048576;
                            if( this.maxCabSize > Settings.twoGigs )
                            {
                                throw new ArgumentException("Cab size too large.  2047MB is max", "/MaxCabSize");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing cab size", "/MaxCabSize");
                        }
                    }
                    else if (string.Compare(arg, "nooverwritexbx", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.nooverwritexbx = true;
                    }
                    else if (string.Compare(arg, "compressionLevel", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            try
                            {
                                this.compressionLevel = Int32.Parse(args[i]);
                                if (this.compressionLevel < 0 || this.compressionLevel > 10)
                                {
                                    throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                                }
                            }
                            catch (System.Exception)
                            {
                                throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing compressionLevel", "/compressionLevel");
                        }
                    }
                    else if (string.Compare(arg, "inputFolder", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.inputFolder = args[i];
                            this.inputFolder = Settings.UnquoteString(this.inputFolder);
                        }
                        else
                        {
                            throw new ArgumentException("Missing input folder", "/inputFolder");
                        }
                    }
                    else if (string.Compare(arg, "titleID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.titleID = args[i];
                            ValidateHexParameter(this.titleID, lengthTitleId, "titleID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing title ID", "/titleID");
                        }
                    }
                    else if (string.Compare(arg, "contentID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentID = args[i];
                            ValidateHexParameter(this.contentID, lengthContentId, "contentID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing content ID", "/contentID");
                        }
                    }
                    else if (string.Compare(arg, "offerID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.offerID = args[i];
                            ValidateHexParameter(this.offerID, lengthOfferId, "offerID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing offer ID", "/offerID");
                        }
                    }
                    else if (string.Compare(arg, "contentType", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentType = args[i];
                            if (string.Compare( this.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase ) != 0 &&
                                string.Compare( this.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase ) != 0) 
                            {
                                throw new ArgumentException("Invalid content type", "/contentType");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing content type", "/contentType");
                        }
                    }
                    else if (string.Compare(arg, "contentFilePath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentFilePath = args[i];
                            this.contentFilePath = Settings.UnquoteString(this.contentFilePath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content file path", "/contentFilePath");
                        }
                    }
                    else if (string.Compare(arg, "unsignedCabPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.unSignedCabPath = args[i];
                            this.unSignedCabPath = Settings.UnquoteString(this.unSignedCabPath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing unsigned cab files save path", "/unsignedCabPath");
                        }
                    }
                    else if (string.Compare(arg, "contentURL", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentURL = args[i];
                            this.contentURL = Settings.UnquoteString(this.contentURL);

                            Log.WriteLog("ContentURL: " + this.contentURL);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content URL", "/contentURL");
                        }
                    }
/*
                    else if (string.Compare(arg, "signer", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.signers.Add(args[i].ToUpper());
                        }
                        else
                        {
                            throw new ArgumentException("Missing CodeSign signer", "/signer");
                        }
                    }
                    else if (string.Compare(arg, "largeFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.largeFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the larger certificate ID", "/largeFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "normalFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.normalFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the normal certificate ID", "/normalFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "strongNameCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.strongNameCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the strong name certificate ID", "/strongNameCertID");
                        }
                    }  
                    else if (string.Compare(arg, "fileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignFileName = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the file name", "/fileName");
                        }
                    }

                    else if (string.Compare(arg, "codeSignJobNumber", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignJobNumber = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign job number", "/codeSignJobNumber");
                        }
                    }
                    else if (string.Compare(arg, "codeSignCompletionPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignCompletionPath = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign completion path", "/codeSignCompletionPath");
                        }
                    }
 */ 
                    else if (string.Compare(arg, "srcFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.srcFileName = args[i];
                            this.srcFileName = Settings.UnquoteString(this.srcFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the source file name", "/srcFileName");
                        }
                    }
                    else if (string.Compare(arg, "dstFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.dstFileName = args[i];
                            this.dstFileName = Settings.UnquoteString(this.dstFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the destination file name", "/dstFileName");
                        }
                    }
                    else if (string.Compare(arg, "?", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        throw new ArgumentException("Display help", "-?");
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }
                else
                {
                    if (string.Compare(arg, "create", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Create;
                    }
                    else if (string.Compare(arg, "submit", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Submit;
                    }
                    else if (string.Compare(arg, "check", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Check;
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }

            }

            if (string.IsNullOrEmpty(this.contentFilePath))
            {
                this.contentFilePath = @"\\xsinfxferinh001\Content";
            }
            if (string.IsNullOrEmpty(this.contentURL))
            {
                this.contentURL = @"\\xsinfxferinh001\Content";
            }

            if( this.inputCommand != Command.Create )
            {
                throw new ArgumentException("Command must be create", "command");
            }

            // justify the input
            switch (this.inputCommand)
            {
                case Command.All:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }
/*
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }
 
                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }

                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
*/
                    break;
                }
                case Command.Create:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }

                    break;
                }
/*
                case Command.Submit:
                {
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }

                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }
                    break;
                }

                case Command.Check:
                {
                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
                    break;
                }
*/
            }

        }

        private static string UnquoteString(string input)
        {
            bool quotedString = false;
            if (input.EndsWith("\"") || input.StartsWith("\""))
            {
                quotedString = true;
            }

            if (quotedString)
            {
                // Remove quotes
                if (input.EndsWith("\""))
                {
                    input = input.Substring(0, input.Length - 1);
                }

                if (input.StartsWith("\""))
                {
                    input = input.Substring(1, input.Length - 1);
                }
            }

            return input;
        }

        private void ValidateHexParameter(string hexString, int expectedLength, string paramName)
        {
            if (hexString.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
            {
                throw new ArgumentException(string.Format("{0} should not start with 0x.", paramName), string.Format("/{0}", paramName));
            }
            else if (hexString.Length != expectedLength)
            {
                throw new ArgumentException(string.Format("{0} should be in the length of {1}.", paramName, expectedLength), string.Format("/{0}", paramName));
            }
            else if (!IsHexString(hexString))
            {
                throw new ArgumentException(string.Format("{0} is not a valid hexadecimal string", paramName), string.Format("/{0}", paramName));
            }
        }

        private bool IsHexString(string hexString)
        {
            Regex hexRegex = new Regex("^[0-9a-fA-F]+$", RegexOptions.CultureInvariant | RegexOptions.Compiled);
            return hexRegex.IsMatch(hexString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\ArchiveProgressEventArgs.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressEventArgs.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Contains the data reported in an archive progress event.
    /// </summary>
    public class ArchiveProgressEventArgs : EventArgs
    {
        private ArchiveProgressType progressType;

        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;

        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;

        private long fileBytesProcessed;
        private long totalFileBytes;

        /// <summary>
        /// Creates a new ArchiveProgressEventArgs object from specified event parameters.
        /// </summary>
        /// <param name="progressType">type of status message</param>
        /// <param name="currentFileName">name of the file being processed</param>
        /// <param name="currentFileNumber">number of the current file being processed</param>
        /// <param name="totalFiles">total number of files to be processed</param>
        /// <param name="currentFileBytesProcessed">number of bytes processed so far when compressing or extracting a file</param>
        /// <param name="currentFileTotalBytes">total number of bytes in the current file</param>
        /// <param name="currentArchiveName">name of the current Archive</param>
        /// <param name="currentArchiveNumber">current Archive number, when processing a chained set of Archives</param>
        /// <param name="totalArchives">total number of Archives in a chained set</param>
        /// <param name="currentArchiveBytesProcessed">number of compressed bytes processed so far during an extraction</param>
        /// <param name="currentArchiveTotalBytes">total number of compressed bytes to be processed during an extraction</param>
        /// <param name="fileBytesProcessed">number of uncompressed file bytes processed so far</param>
        /// <param name="totalFileBytes">total number of uncompressed file bytes to be processed</param>
        public ArchiveProgressEventArgs(
            ArchiveProgressType progressType,
            string currentFileName,
            int currentFileNumber,
            int totalFiles,
            long currentFileBytesProcessed,
            long currentFileTotalBytes,
            string currentArchiveName,
            int currentArchiveNumber,
            int totalArchives,
            long currentArchiveBytesProcessed,
            long currentArchiveTotalBytes,
            long fileBytesProcessed,
            long totalFileBytes)
        {
            this.progressType = progressType;
            this.currentFileName = currentFileName;
            this.currentFileNumber = currentFileNumber;
            this.totalFiles = totalFiles;
            this.currentFileBytesProcessed = currentFileBytesProcessed;
            this.currentFileTotalBytes = currentFileTotalBytes;
            this.currentArchiveName = currentArchiveName;
            this.currentArchiveNumber = (short) currentArchiveNumber;
            this.totalArchives = (short) totalArchives;
            this.currentArchiveBytesProcessed = currentArchiveBytesProcessed;
            this.currentArchiveTotalBytes = currentArchiveTotalBytes;
            this.fileBytesProcessed = fileBytesProcessed;
            this.totalFileBytes = totalFileBytes;
        }

        /// <summary>
        /// Gets the type of status message.
        /// </summary>
        /// <value>A <see cref="ArchiveProgressType"/> value indicating what type of progress event occurred.</value>
        /// <remarks>
        /// The handler may choose to ignore some types of progress events.
        /// For example, if the handler will only list each file as it is
        /// compressed/extracted, it can ignore events that
        /// are not of type <see cref="ArchiveProgressType.FinishFile"/>.
        /// </remarks>
        public ArchiveProgressType ProgressType
        {
            get
            {
                return this.progressType;
            }
        }

        /// <summary>
        /// Gets the name of the file being processed. (The name of the file within the Archive; not the external
        /// file path.) Also includes the internal path of the file, if any.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The name of the file currently being processed, or null if processing
        /// is currently at the stream or archive level.</value>
        public string CurrentFileName
        {
            get
            {
                return this.currentFileName;
            }
        }

        /// <summary>
        /// Gets the number of the current file being processed. The first file is number 0, and the last file
        /// is <see cref="TotalFiles"/>-1. Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of the file currently being processed, or the most recent
        /// file processed if processing is currently at the stream or archive level.</value>
        public int CurrentFileNumber
        {
            get
            {
                return this.currentFileNumber;
            }
        }

        /// <summary>
        /// Gets the total number of files to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of files to be processed that are known so far.</value>
        public int TotalFiles
        {
            get
            {
                return this.totalFiles;
            }
        }

        /// <summary>
        /// Gets the number of bytes processed so far when compressing or extracting a file.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of uncompressed bytes processed so far for the current file,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileBytesProcessed
        {
            get
            {
                return this.currentFileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of bytes in the current file.  Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The uncompressed size of the current file being processed,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileTotalBytes
        {
            get
            {
                return this.currentFileTotalBytes;
            }
        }

        /// <summary>
        /// Gets the name of the current archive.  Not necessarily the name of the archive on disk.
        /// Valid for all message types.
        /// </summary>
        /// <value>The name of the current archive, or an empty string if no name was specified.</value>
        public string CurrentArchiveName
        {
            get
            {
                return this.currentArchiveName;
            }
        }

        /// <summary>
        /// Gets the current archive number, when processing a chained set of archives. Valid for all message types.
        /// </summary>
        /// <value>The number of the current archive.</value>
        /// <remarks>The first archive is number 0, and the last archive is
        /// <see cref="TotalArchives"/>-1.</remarks>
        public int CurrentArchiveNumber
        {
            get
            {
                return this.currentArchiveNumber;
            }
        }

        /// <summary>
        /// Gets the total number of known archives in a chained set. Valid for all message types.
        /// </summary>
        /// <value>The total number of known archives in a chained set.</value>
        /// <remarks>
        /// When using the compression option to auto-split into multiple archives based on data size,
        /// this value will not be accurate until the end.
        /// </remarks>
        public int TotalArchives
        {
            get
            {
                return this.totalArchives;
            }
        }

        /// <summary>
        /// Gets the number of compressed bytes processed so far during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The number of compressed bytes processed so far during extraction
        /// of the current archive.</value>
        public long CurrentArchiveBytesProcessed
        {
            get
            {
                return this.currentArchiveBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of compressed bytes to be processed during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The total number of compressed bytes to be processed during extraction
        /// of the current archive.</value>
        public long CurrentArchiveTotalBytes
        {
            get
            {
                return this.currentArchiveTotalBytes;
            }
        }

        /// <summary>
        /// Gets the number of uncompressed bytes processed so far among all files. Valid for all message types.  
        /// </summary>
        /// <value>The number of uncompressed file bytes processed so far among all files.</value>
        /// <remarks>
        /// When compared to <see cref="TotalFileBytes"/>, this can be used as a measure of overall progress.
        /// </remarks>
        public long FileBytesProcessed
        {
            get
            {
                return this.fileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of uncompressed file bytes to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of uncompressed bytes to be processed among all files.</value>
        public long TotalFileBytes
        {
            get
            {
                return this.totalFileBytes;
            }
        }

#if DEBUG

    /// <summary>
    /// Creates a string representation of the progress event.
    /// </summary>
    /// <returns>a listing of all event parameters and values</returns>
    public override string ToString()
    {
        string formatString =
            "{0}\n" +
            "\t CurrentFileName              = {1}\n" +
            "\t CurrentFileNumber            = {2}\n" +
            "\t TotalFiles                   = {3}\n" +
            "\t CurrentFileBytesProcessed    = {4}\n" +
            "\t CurrentFileTotalBytes        = {5}\n" +
            "\t CurrentArchiveName           = {6}\n" +
            "\t CurrentArchiveNumber         = {7}\n" +
            "\t TotalArchives                = {8}\n" +
            "\t CurrentArchiveBytesProcessed = {9}\n" +
            "\t CurrentArchiveTotalBytes     = {10}\n" +
            "\t FileBytesProcessed           = {11}\n" +
            "\t TotalFileBytes               = {12}\n";
        return String.Format(
            System.Globalization.CultureInfo.InvariantCulture,
            formatString,
            this.ProgressType,
            this.CurrentFileName,
            this.CurrentFileNumber,
            this.TotalFiles,
            this.CurrentFileBytesProcessed,
            this.CurrentFileTotalBytes,
            this.CurrentArchiveName,
            this.CurrentArchiveNumber,
            this.TotalArchives,
            this.CurrentArchiveBytesProcessed,
            this.CurrentArchiveTotalBytes,
            this.FileBytesProcessed,
            this.TotalFileBytes);
    }

#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\ArchiveException.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;

    /// <summary>
    /// Base exception class for compression operations. Compression libraries should
    /// derive subclass exceptions with more specific error information relevent to the
    /// file format.
    /// </summary>
    [Serializable]
    public class ArchiveException : IOException
    {
        /// <summary>
        /// Creates a new ArchiveException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ArchiveException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ArchiveException(string message)
            : this(message, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException.
        /// </summary>
        public ArchiveException()
            : this(null, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ArchiveException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\BasicUnpackStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="BasicUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Stream context used to extract a single file from an archive into a memory stream.
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
    public class BasicUnpackStreamContext : IUnpackStreamContext
    {
        private Stream archiveStream;
        private Stream fileStream;

        /// <summary>
        /// Creates a new BasicExtractStreamContext that reads from the specified archive stream.
        /// </summary>
        /// <param name="archiveStream">Archive stream to read from.</param>
        public BasicUnpackStreamContext(Stream archiveStream)
        {
            this.archiveStream = archiveStream;
        }

        /// <summary>
        /// Gets the stream for the extracted file, or null if no file was extracted.
        /// </summary>
        public Stream FileStream
        {
            get
            {
                return this.fileStream;
            }
        }

        /// <summary>
        /// Opens the archive stream for reading. Returns a DuplicateStream instance,
        /// so the stream may be virtually opened multiple times.
        /// </summary>
        /// <param name="archiveNumber">The archive number to open (ignored; 0 is assumed).</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read.</returns>
        public Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            return new DuplicateStream(this.archiveStream);
        }

        /// <summary>
        /// Does *not* close the stream. The archive stream should be managed by
        /// the code that invokes the archive extraction.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream being closed.</param>
        public void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream)
        {
            // Do nothing.
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes. The returned stream is a MemoryStream
        /// instance, so the file is extracted straight into memory.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <returns>A stream where extracted file bytes are to be written.</returns>
        public Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime)
        {
            this.fileStream = new MemoryStream(new byte[fileSize], 0, (int) fileSize, true, true);
            return this.fileStream;
        }

        /// <summary>
        /// Does *not* close the file stream. The file stream is saved in memory so it can
        /// be read later.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="stream">The file stream to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        public void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime)
        {
            // Do nothing.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\ArchiveProgressType.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressType.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// The type of progress event.
    /// </summary>
    /// <remarks>
    /// <p>PACKING EXAMPLE: The following sequence of events might be received when
    /// extracting a simple archive file with 2 files.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartArchive</term> <description>Begin extracting archive</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting first file</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting second file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting second file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting second file</description></item>
    /// <item><term>FinishArchive</term><description>Finished extracting archive</description></item>
    /// </list>
    /// <p></p>
    /// <p>UNPACKING EXAMPLE:  Packing 3 files into 2 archive chunks, where the second file is
    ///	continued to the second archive chunk.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartFile</term>     <description>Begin compressing first file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing first file</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing second file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing first archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing first archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing first archive</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing third file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing third file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing third file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing second archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing second archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing second archive</description></item>
    /// </list>
    /// </remarks>
    public enum ArchiveProgressType : int
    {
        /// <summary>Status message before beginning the packing or unpacking an individual file.</summary>
        StartFile,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking a file.</summary>
        PartialFile,

        /// <summary>Status message after completion of the packing or unpacking an individual file.</summary>
        FinishFile,

        /// <summary>Status message before beginning the packing or unpacking an archive.</summary>
        StartArchive,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking an archiv.</summary>
        PartialArchive,

        /// <summary>Status message after completion of the packing or unpacking of an archive.</summary>
        FinishArchive,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\DuplicateStream.cs ===
//---------------------------------------------------------------------
// <copyright file="DuplicateStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Duplicates a source stream by maintaining a separate position.
    /// </summary>
    /// <remarks>
    /// WARNING: duplicate streams are not thread-safe with respect to each other or the original stream.
    /// If multiple threads use duplicate copies of the same stream, they must synchronize for any operations.
    /// </remarks>
    public class DuplicateStream : Stream
    {
        private Stream source;
        private long position;

        /// <summary>
        /// Creates a new duplicate of a stream.
        /// </summary>
        /// <param name="source">source of the duplicate</param>
        public DuplicateStream(Stream source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = DuplicateStream.OriginalStream(source);
        }

        /// <summary>
        /// Gets the original stream that was used to create the duplicate.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the current stream,
        /// ignoring the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.position;
            }

            set
            {
                this.position = value;
            }
        }

        /// <summary>
        /// Retrieves the original stream from a possible duplicate stream.
        /// </summary>
        /// <param name="stream">Possible duplicate stream.</param>
        /// <returns>If the stream is a DuplicateStream, returns
        /// the duplicate's source; otherwise returns the same stream.</returns>
        public static Stream OriginalStream(Stream stream)
        {
            DuplicateStream dupStream = stream as DuplicateStream;
            return dupStream != null ? dupStream.Source : stream;
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the stream in bytes.</param>
        public override void SetLength(long value)
        { 
            this.source.SetLength(value);
        }

        /// <summary>
        /// Closes the underlying stream, effectively closing ALL duplicates.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }

        /// <summary>
        /// Reads from the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            int read = this.source.Read(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
            return read;
        }

        /// <summary>
        /// Writes to the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            this.source.Write(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
        }

        /// <summary>
        /// Changes the position of this stream without impacting the
        /// source stream's position.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating the reference
        /// point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            long originPosition = 0;
            if (origin == SeekOrigin.Current)
            {
                originPosition = this.position;
            }
            else if (origin == SeekOrigin.End)
            {
                originPosition = this.Length;
            }

            this.position = originPosition + offset;
            return this.position;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\CompressionEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;

    /// <summary>
    /// Base class for an engine capable of packing and unpacking a particular
    /// compressed file format.
    /// </summary>
    public abstract class CompressionEngine : IDisposable
    {
        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;

        /// <summary>
        /// Creates a new instance of the compression engine base class.
        /// </summary>
        protected CompressionEngine()
        {
            this.compressionLevel = CompressionLevel.Normal;
        }

        /// <summary>
        /// Disposes the compression engine.
        /// </summary>
        ~CompressionEngine()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Occurs when the compression engine reports progress in packing
        /// or unpacking an archive.
        /// </summary>
        /// <seealso cref="ArchiveProgressType"/>
        public event EventHandler<ArchiveProgressEventArgs> Progress;

        /// <summary>
        /// Gets or sets a flag indicating whether temporary files are created
        /// and used during compression.
        /// </summary>
        /// <value>True if temporary files are used; false if compression is done
        /// entirely in-memory.</value>
        /// <remarks>The value of this property is true by default. Using temporary
        /// files can greatly reduce the memory requirement of compression,
        /// especially when compressing large archives. However, setting this property
        /// to false may yield slightly better performance when creating small
        /// archives. Or it may be necessary if the process does not have sufficient
        /// privileges to create temporary files.</remarks>
        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        /// <summary>
        /// Compression level to use when compressing files.
        /// </summary>
        /// <value>A compression level ranging from minimum to maximum compression,
        /// or no compression.</value>
        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Creates an archive.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive
        /// (not external file paths).</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the archive to the external file paths.
        /// </remarks>
        public void Pack(IPackStreamContext streamContext, IEnumerable<string> files)
        {
            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            this.Pack(streamContext, files, 0);
        }

        /// <summary>
        /// Creates an archive or chain of archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// archive before the contents are chained to the next archive, or zero
        /// for unlimited archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public abstract void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize);

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid archive
        /// (with no offset); false otherwise.</returns>
        public abstract bool IsArchive(Stream stream);

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public virtual long FindArchiveOffset(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            long sectionSize = 4;
            long length = stream.Length;
            for (long offset = 0; offset <= length - sectionSize; offset += sectionSize)
            {
                stream.Seek(offset, SeekOrigin.Begin);
                if (this.IsArchive(stream))
                {
                    return offset;
                }
            }

            return -1;
        }

        /// <summary>
        /// Gets information about all files in an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>Information about all files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<ArchiveFileInfo> GetFileInfo(Stream stream)
        {
            return this.GetFileInfo(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets information about files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Gets the list of files in an archive Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>A list of the paths of all files contained in the
        /// archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<string> GetFiles(Stream stream)
        {
            return this.GetFiles(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets the list of files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>An array containing the names of all files contained in
        /// the archive or archive chain.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public IList<string> GetFiles(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            IList<ArchiveFileInfo> files =
                this.GetFileInfo(streamContext, fileFilter);
            IList<string> fileNames = new List<string>(files.Count);
            for (int i = 0; i < files.Count; i++)
            {
                fileNames.Add(files[i].Name);
            }

            return fileNames;
        }

        /// <summary>
        /// Reads a single file from an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <param name="path">The path of the file within the archive
        /// (not the external file path).</param>
        /// <returns>A stream for reading the extracted file, or null
        /// if the file does not exist in the archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        /// <remarks>The entire extracted file is cached in memory, so this
        /// method requires enough free memory to hold the file.</remarks>
        public Stream Unpack(Stream stream, string path)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            BasicUnpackStreamContext streamContext =
                new BasicUnpackStreamContext(stream);
            this.Unpack(
                streamContext,
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            
            Stream extractStream = streamContext.FileStream;
            if (extractStream != null)
            {
                extractStream.Position = 0;
            }

            return extractStream;
        }

        /// <summary>
        /// Extracts files from an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Called by sublcasses to distribute a packing or unpacking progress
        /// event to listeners.
        /// </summary>
        /// <param name="e">Event details.</param>
        protected void OnProgress(ArchiveProgressEventArgs e)
        {
            if (this.Progress != null)
            {
                this.Progress(this, e);
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called
        /// directly or indirectly by a user's code, so managed and unmanaged
        /// resources will be disposed. If false, the method has been called by
        /// the runtime from inside the finalizer, and only unmanaged resources
        /// will be disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        /// Compresion utility function for converting old-style
        /// date and time values to a DateTime structure.
        /// </summary>
        public static void DosDateAndTimeToDateTime(
            short dosDate, short dosTime, out DateTime dateTime)
        {
            if (dosDate == 0 && dosTime == 0)
            {
                dateTime = DateTime.MinValue;
            }
            else
            {
                long fileTime;
                SafeNativeMethods.DosDateTimeToFileTime(dosDate, dosTime, out fileTime);
                dateTime = DateTime.FromFileTimeUtc(fileTime);
                dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Local);
            }
        }

        /// <summary>
        /// Compresion utility function for converting a DateTime structure
        /// to old-style date and time values.
        /// </summary>
        public static void DateTimeToDosDateAndTime(
            DateTime dateTime, out short dosDate, out short dosTime)
        {
            dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
            long filetime = dateTime.ToFileTimeUtc();
            SafeNativeMethods.FileTimeToDosDateTime(ref filetime, out dosDate, out dosTime);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\CompressionLevel.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionLevel.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Specifies the compression level ranging from minimum compresion to
    /// maximum compression, or no compression at all.
    /// </summary>
    /// <remarks>
    /// Although only four values are enumerated, any integral value between
    /// <see cref="CompressionLevel.Min"/> and <see cref="CompressionLevel.Max"/> can also be used.
    /// </remarks>
    public enum CompressionLevel
    {
        /// <summary>Do not compress files, only store.</summary>
        None = 0,

        /// <summary>Minimum compression; fastest.</summary>
        Min = 1,

        /// <summary>A compromize between speed and compression efficiency.</summary>
        Normal = 6,

        /// <summary>Maximum compression; slowest.</summary>
        Max = 10
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\IPackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IPackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// This interface provides the methods necessary for the
    /// <see cref="CompressionEngine"/> to open and close streams for archives
    /// and files. The implementor of this interface can use any kind of logic
    /// to determine what kind of streams to open and where.
    /// </summary>
    public interface IPackStreamContext
    {
        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive
        /// within the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>The archive name is the name stored within the archive, used for
        /// identification of the archive especially among archive chains. That
        /// name is often, but not necessarily the same as the filename of the
        /// archive package.</remarks>
        string GetArchiveName(int archiveNumber);

        /// <summary>
        /// Opens a stream for writing an archive package.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// If this method returns null, the archive engine will throw a
        /// FileNotFoundException.
        /// </remarks>
        Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by
        /// <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        /// <remarks>
        /// If there is another archive package in the chain, then after this stream
        /// is closed a new stream will be opened.
        /// </remarks>
        void CloseArchiveWriteStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often,
        /// but not necessarily, the same as the relative path of the file outside
        /// the archive.</param>
        /// <param name="attributes">Returned attributes of the opened file, to be
        /// stored in the archive.</param>
        /// <param name="lastWriteTime">Returned last-modified time of the opened file,
        /// to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from before
        /// they are compressed, or null to skip inclusion of the file and continue to
        /// the next file.</returns>
        [SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters")]
        Stream OpenFileReadStream(
            string path,
            out FileAttributes attributes,
            out DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided
        /// when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        void CloseFileReadStream(string path, Stream stream);

        /// <summary>
        /// Gets extended parameter information specific to the compression
        /// format being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This method provides a way to set uncommon options during packaging, or a
        /// way to handle aspects of compression formats not supported by the base library.
        /// <para>For example, this may be used by the zip compression library to
        /// specify different compression methods/levels on a per-file basis.</para>
        /// <para>The available option names, parameters, and expected return values
        /// should be documented by each compression library.</para>
        /// </remarks>
        object GetOption(string optionName, object[] parameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\OffsetStream.cs ===
//---------------------------------------------------------------------
// <copyright file="OffsetStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Wraps a source stream and offsets all read/write/seek calls by a given value.
    /// </summary>
    /// <remarks>
    /// This class is used to trick archive an packing or unpacking process
    /// into reading or writing at an offset into a file, primarily for
    /// self-extracting packages.
    /// </remarks>
    public class OffsetStream : Stream
    {
        private Stream source;
        private long sourceOffset;

        /// <summary>
        /// Creates a new OffsetStream instance from a source stream
        /// and using a specified offset.
        /// </summary>
        /// <param name="source">Underlying stream for which all calls will be offset.</param>
        /// <param name="offset">Positive or negative number of bytes to offset.</param>
        public OffsetStream(Stream source, long offset)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = source;
            this.sourceOffset = offset;

            this.source.Seek(this.sourceOffset, SeekOrigin.Current);
        }

        /// <summary>
        /// Gets the underlying stream that this OffsetStream calls into.
        /// </summary>
        public Stream Source
        {
            get { return this.source; }
        }

        /// <summary>
        /// Gets the number of bytes to offset all calls before
        /// redirecting to the underlying stream.
        /// </summary>
        public long Offset
        {
            get { return this.sourceOffset; }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        public override long Length
        {
            get { return this.source.Length - this.sourceOffset; } 
        }

        /// <summary>
        /// Gets or sets the effective position of the stream, which
        /// is equal to the position of the source stream minus the offset.
        /// </summary>
        public override long Position
        {
            get { return this.source.Position - this.sourceOffset; }
            set { this.source.Position = value + this.sourceOffset; }
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this.source.Read(buffer, offset, count);
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the
        /// source stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>The unsigned byte cast to an Int32, or -1 if at the
        /// end of the stream.</returns>
        public override int ReadByte()
        {
            return this.source.ReadByte();
        }

        /// <summary>
        /// Writes a byte to the current position in the source stream and
        /// advances the position within the stream by one byte.
        /// </summary>
        /// <param name="value">The byte to write to the stream.</param>
        public override void WriteByte(byte value)
        {
            this.source.WriteByte(value);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the position within the current stream, which is
        /// equal to the position within the source stream minus the offset.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset + (origin == SeekOrigin.Begin ? this.sourceOffset : 0), origin) - this.sourceOffset;
        }

        /// <summary>
        /// Sets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        /// <param name="value">The desired length of the
        /// current stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value + this.sourceOffset);
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\IUnpackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// This interface provides the methods necessary for the <see cref="CompressionEngine"/> to open
    /// and close streams for archives and files. The implementor of this interface can use any
    /// kind of logic to determine what kind of streams to open and where 
    /// </summary>
    public interface IUnpackStreamContext
    {
        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel extraction
        /// of the archive.</returns>
        /// <remarks>
        /// When the first archive in a chain is opened, the name is not yet known, so the
        /// provided value will be an empty string. When opening further archives, the
        /// provided value is the next-archive name stored in the previous archive. This
        /// name is often, but not necessarily, the same as the filename of the archive
        /// package to be opened.
        /// <para>If this method returns null, the archive engine will throw a
        /// FileNotFoundException.</para>
        /// </remarks>
        Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often, but
        /// not necessarily, the same as the relative path of the file outside the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null to skip
        /// extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// The implementor may use the path, size and date information to dynamically
        /// decide whether or not the file should be extracted.
        /// </remarks>
        Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by <see cref="OpenFileWriteStream"/>
        /// and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// The implementor may wish to apply the attributes and date to the newly-extracted file.
        /// </remarks>
        void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabException.cs ===
//---------------------------------------------------------------------
// <copyright file="CabException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for cabinet operations.
    /// </summary>
    [Serializable]
    public class CabException : ArchiveException
    {
        private static ResourceManager errorResources;
        private int error;
        private int errorCode;

        /// <summary>
        /// Creates a new CabException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public CabException(string message, Exception innerException)
            : this(0, 0, message, innerException) { }

        /// <summary>
        /// Creates a new CabException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public CabException(string message)
            : this(0, 0, message, null) { }

        /// <summary>
        /// Creates a new CabException.
        /// </summary>
        public CabException()
            : this(0, 0, null, null) { }

        internal CabException(int error, int errorCode, string message, Exception innerException)
            : base(message, innerException)
        {
            this.error = error;
            this.errorCode = errorCode;
        }

        internal CabException(int error, int errorCode, string message)
            : this(error, errorCode, message, null) { }

        /// <summary>
        /// Initializes a new instance of the CabException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            this.error = info.GetInt32("cabError");
            this.errorCode = info.GetInt32("cabErrorCode");
        }

        /// <summary>
        /// Gets the FCI or FDI cabinet engine error number.
        /// </summary>
        /// <value>A cabinet engine error number, or 0 if the exception was
        /// not related to a cabinet engine error number.</value>
        public int Error
        {
            get
            {
                return this.error;
            }
        }

        /// <summary>
        /// Gets the Win32 error code.
        /// </summary>
        /// <value>A Win32 error code, or 0 if the exception was
        /// not related to a Win32 error.</value>
        public int ErrorCode
        {
            get
            {
                return this.errorCode;
            }
        }

        internal static ResourceManager ErrorResources
        {
            get
            {
                if (errorResources == null)
                {
                    errorResources = new ResourceManager(
                        typeof(CabException).Namespace + ".Errors",
                        typeof(CabException).Assembly);
                }
                return errorResources;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            info.AddValue("cabError", this.error);
            info.AddValue("cabErrorCode", this.errorCode);
            base.GetObjectData(info, context);
        }

        internal static string GetErrorMessage(int error, int errorCode, bool extracting)
        {
            const int FCI_ERROR_RESOURCE_OFFSET = 1000;
            const int FDI_ERROR_RESOURCE_OFFSET = 2000;
            int resourceOffset = (extracting ? FDI_ERROR_RESOURCE_OFFSET : FCI_ERROR_RESOURCE_OFFSET);

            string msg = CabException.ErrorResources.GetString(
                (resourceOffset + error).ToString(CultureInfo.InvariantCulture.NumberFormat),
                CultureInfo.CurrentCulture);

            if (msg == null)
            {
                msg = CabException.ErrorResources.GetString(
                    resourceOffset.ToString(CultureInfo.InvariantCulture.NumberFormat),
                    CultureInfo.CurrentCulture);
            }

            if (errorCode != 0)
            {
                const string GENERIC_ERROR_RESOURCE = "1";
                string msg2 = CabException.ErrorResources.GetString(GENERIC_ERROR_RESOURCE, CultureInfo.CurrentCulture);
                msg = String.Format(CultureInfo.InvariantCulture, "{0} " + msg2, msg, errorCode);
            }
            return msg;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a cabinet file on disk; provides access to
    /// file-based operations on the cabinet file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="CabEngine"/> class.
    /// </remarks>
    [Serializable]
    public class CabInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a cabinet file in a specified path.
        /// </summary>
        /// <param name="path">The path to the cabinet file. When creating a cabinet file, this file does not
        /// necessarily exist yet.</param>
        public CabInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="CabEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new CabEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabFileInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a cabinet package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class CabFileInfo : ArchiveFileInfo
    {
        private int cabFolder;

        /// <summary>
        /// Creates a new CabinetFileInfo object representing a file within a cabinet in a specified path.
        /// </summary>
        /// <param name="cabinetInfo">An object representing the cabinet containing the file.</param>
        /// <param name="filePath">The path to the file within the cabinet. Usually, this is a simple file
        /// name, but if the cabinet contains a directory structure this may include the directory.</param>
        public CabFileInfo(CabInfo cabinetInfo, string filePath)
            : base(cabinetInfo, filePath)
        {
            if (cabinetInfo == null)
            {
                throw new ArgumentNullException("cabinetInfo");
            }

            this.cabFolder = -1;
        }

        /// <summary>
        /// Creates a new CabinetFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a cab.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the cab.</param>
        /// <param name="cabFolder">The folder number containing the file.</param>
        /// <param name="cabNumber">The cabinet number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        internal CabFileInfo(
            string filePath,
            int cabFolder,
            int cabNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : base(filePath, cabNumber, attributes, lastWriteTime, length)
        {
            this.cabFolder = cabFolder;
        }

        /// <summary>
        /// Initializes a new instance of the CabinetFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.cabFolder = info.GetInt32("cabFolder");
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("cabFolder", this.cabFolder);
        }

        /// <summary>
        /// Gets or sets the cabinet that contains this file.
        /// </summary>
        /// <value>
        /// The CabinetInfo instance that retrieved this file information -- this
        /// may be null if the CabinetFileInfo object was returned directly from a
        /// stream.
        /// </value>
        public CabInfo Cabinet
        {
            get
            {
                return (CabInfo) this.Archive;
            }
        }

        /// <summary>
        /// Gets the full path of the cabinet that contains this file.
        /// </summary>
        /// <value>The full path of the cabinet that contains this file.</value>
        public string CabinetName
        {
            get
            {
                return this.ArchiveName;
            }
        }

        /// <summary>
        /// Gets the number of the folder containing this file.
        /// </summary>
        /// <value>The number of the cabinet folder containing this file.</value>
        /// <remarks>A single folder or the first folder of a cabinet
        /// (or chain of cabinets) is numbered 0.</remarks>
        public int CabinetFolderNumber
        {
            get
            {
                if (this.cabFolder < 0)
                {
                    this.Refresh();
                }
                return this.cabFolder;
            }
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// This implementation refreshes the <see cref="CabinetFolderNumber"/>.
        /// </remarks>
        protected override void Refresh(ArchiveFileInfo newFileInfo)
        {
            base.Refresh(newFileInfo);
            this.cabFolder = ((CabFileInfo) newFileInfo).cabFolder;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CabEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the cabinet format.
    /// </summary>
    public class CabEngine : CompressionEngine
    {
        private CabPacker packer;
        private CabUnpacker unpacker;

        /// <summary>
        /// Creates a new instance of the cabinet engine.
        /// </summary>
        public CabEngine()
            : base()
        {
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly
        /// or indirectly by a user's code, so managed and unmanaged resources
        /// will be disposed. If false, the method has been called by the runtime
        /// from inside the finalizer, and only unmanaged resources will be
        /// disposed.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (packer != null)
                {
                    packer.Dispose();
                    packer = null;
                }
                if (unpacker != null)
                {
                    unpacker.Dispose();
                    unpacker = null;
                }
            }

            base.Dispose(disposing);
        }

        private CabPacker Packer
        {
            get
            {
                if (this.packer == null)
                {
                    this.packer = new CabPacker(this);
                }

                return this.packer;
            }
        }

        private CabUnpacker Unpacker
        {
            get
            {
                if (this.unpacker == null)
                {
                    this.unpacker = new CabUnpacker(this);
                }

                return this.unpacker;
            }
        }

        /// <summary>
        /// Creates a cabinet or chain of cabinets.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// cabinet before the contents are chained to the next cabinet, or zero
        /// for unlimited cabinet size.</param>
        /// <exception cref="ArchiveException">The cabinet could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the cabinet to the external file paths.
        /// <para>Smaller folder sizes can make it more efficient to extract
        /// individual files out of large cabinet packages.</para>
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            this.Packer.CompressionLevel = this.CompressionLevel;
            this.Packer.UseTempFiles = this.UseTempFiles;
            this.Packer.Pack(streamContext, files, maxArchiveSize);
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid cabinet file.
        /// </summary>
        /// <param name="stream">Stream for reading the cabinet file.</param>
        /// <returns>True if the stream is a valid cabinet file
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            return this.Unpacker.IsArchive(stream);
        }

        /// <summary>
        /// Gets information about files in a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the cabinet stream.</returns>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            return this.Unpacker.GetFileInfo(streamContext, fileFilter);
        }

        /// <summary>
        /// Extracts files from a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            this.Unpacker.Unpack(streamContext, fileFilter);
        }

        internal void ReportProgress(ArchiveProgressEventArgs e)
        {
            base.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabUnpacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabUnpacker : CabWorker
    {
        private NativeMethods.FDI.Handle fdiHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FDI.PFNALLOC fdiAllocMemHandler;
        private NativeMethods.FDI.PFNFREE fdiFreeMemHandler;
        private NativeMethods.FDI.PFNOPEN fdiOpenStreamHandler;
        private NativeMethods.FDI.PFNREAD fdiReadStreamHandler;
        private NativeMethods.FDI.PFNWRITE fdiWriteStreamHandler;
        private NativeMethods.FDI.PFNCLOSE fdiCloseStreamHandler;
        private NativeMethods.FDI.PFNSEEK fdiSeekStreamHandler;

        private IUnpackStreamContext context;

        private List<ArchiveFileInfo> fileList;

        private int folderId;

        private Predicate<string> filter;

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public CabUnpacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fdiAllocMemHandler = this.CabAllocMem;
            this.fdiFreeMemHandler = this.CabFreeMem;
            this.fdiOpenStreamHandler = this.CabOpenStream;
            this.fdiReadStreamHandler = this.CabReadStream;
            this.fdiWriteStreamHandler = this.CabWriteStream;
            this.fdiCloseStreamHandler = this.CabCloseStream;
            this.fdiSeekStreamHandler = this.CabSeekStream;

            this.fdiHandle = NativeMethods.FDI.Create(
                this.fdiAllocMemHandler,
                this.fdiFreeMemHandler,
                this.fdiOpenStreamHandler,
                this.fdiReadStreamHandler,
                this.fdiWriteStreamHandler,
                this.fdiCloseStreamHandler,
                this.fdiSeekStreamHandler,
                NativeMethods.FDI.CPU_80386,
                this.ErfHandle.AddrOfPinnedObject());
            if (this.Erf.Error)
            {
                int error = this.Erf.Oper;
                int errorCode = this.Erf.Type;
                this.ErfHandle.Free();
                throw new CabException(
                    error,
                    errorCode,
                    CabException.GetErrorMessage(error, errorCode, true));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            lock (this)
            {
                short id;
                int folderCount, fileCount;
                return this.IsCabinet(stream, out id, out folderCount, out fileCount);
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                this.context = streamContext;
                this.filter = fileFilter;
                this.NextCabinetName = String.Empty;
                this.fileList = new List<ArchiveFileInfo>();
                bool tmpSuppress = this.SuppressProgressEvents;
                this.SuppressProgressEvents = true;
                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;
                        
                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabListNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }

                    List<ArchiveFileInfo> tmpFileList = this.fileList;
                    this.fileList = null;
                    return tmpFileList.AsReadOnly();
                }
                finally
                {
                    this.SuppressProgressEvents = tmpSuppress;

                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    this.context = null;
                }
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            lock (this)
            {
                IList<ArchiveFileInfo> files =
                    this.GetFileInfo(streamContext, fileFilter);

                this.ResetProgressData();

                if (files != null)
                {
                    this.totalFiles = files.Count;

                    for (int i = 0; i < files.Count; i++)
                    {
                        this.totalFileBytes += files[i].Length;
                        if (files[i].ArchiveNumber >= this.totalArchives)
                        {
                            int totalArchives = files[i].ArchiveNumber + 1;
                            this.totalArchives = (short) totalArchives;
                        }
                    }
                }

                this.context = streamContext;
                this.fileList = null;
                this.NextCabinetName = String.Empty;
                this.folderId = -1;
                this.currentFileNumber = -1;

                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;

                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabExtractNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileWriteStream(this.currentFileName, this.FileStream, FileAttributes.Normal, DateTime.Now);
                        this.FileStream = null;
                    }

                    this.context = null;
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    stream = this.context.OpenArchiveReadStream(cabNumber, path, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;
                    this.currentArchiveNumber = cabNumber;
                    if (this.totalArchives <= this.currentArchiveNumber)
                    {
                        int totalArchives = this.currentArchiveNumber + 1;
                        this.totalArchives = (short) totalArchives;
                    }
                    this.currentArchiveTotalBytes = stream.Length;
                    this.currentArchiveBytesProcessed = 0;

                    if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                    {
                        this.OnProgress(ArchiveProgressType.StartArchive);
                    }
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabReadStreamEx(streamHandle, memory, cb, out err, pv);
            if (err == 0 && this.CabStream != null)
            {
                if (this.fileList == null)
                {
                    Stream stream = this.StreamHandles[streamHandle];
                    if (DuplicateStream.OriginalStream(stream) ==
                        DuplicateStream.OriginalStream(this.CabStream))
                    {
                        this.currentArchiveBytesProcessed += cb;
                        if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                        {
                            this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                        }
                    }
                }
            }
            return count;
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                this.currentFileBytesProcessed += cb;
                this.fileBytesProcessed += cb;
                this.OnProgress(ArchiveProgressType.PartialFile);
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                {
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                }

                this.context.CloseArchiveReadStream(this.currentArchiveNumber, this.currentArchiveName, stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;

                this.CabStream = null;
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (disposing)
                {
                    if (this.fdiHandle != null)
                    {
                        this.fdiHandle.Dispose();
                        this.fdiHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static string GetFileName(NativeMethods.FDI.NOTIFICATION notification)
        {
            bool utf8Name = (notification.attribs & (ushort) FileAttributes.Normal) != 0;  // _A_NAME_IS_UTF

            // Non-utf8 names should be completely ASCII. But for compatibility with
            // legacy tools, interpret them using the current (Default) ANSI codepage.
            Encoding nameEncoding = utf8Name ? Encoding.UTF8 : Encoding.Default;

            // Find how many bytes are in the string.
            // Unfortunately there is no faster way.
            int nameBytesCount = 0;
            while (Marshal.ReadByte(notification.psz1, nameBytesCount) != 0)
            {
                nameBytesCount++;
            }

            byte[] nameBytes = new byte[nameBytesCount];
            Marshal.Copy(notification.psz1, nameBytes, 0, nameBytesCount);
            string name = nameEncoding.GetString(nameBytes);
            if (Path.IsPathRooted(name))
            {
                name = name.Replace("" + Path.VolumeSeparatorChar, "");
            }

            return name;
        }

        private bool IsCabinet(Stream cabStream, out short id, out int cabFolderCount, out int fileCount)
        {
            int streamHandle = this.StreamHandles.AllocHandle(cabStream);
            try
            {
                this.Erf.Clear();
                NativeMethods.FDI.CABINFO fdici;
                bool isCabinet = 0 != NativeMethods.FDI.IsCabinet(this.fdiHandle, streamHandle, out fdici);

                if (this.Erf.Error)
                {
                    if (((NativeMethods.FDI.ERROR) this.Erf.Oper) == NativeMethods.FDI.ERROR.UNKNOWN_CABINET_VERSION)
                    {
                        isCabinet = false;
                    }
                    else
                    {
                        throw new CabException(
                            this.Erf.Oper,
                            this.Erf.Type,
                            CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, true));
                    }
                }

                id = fdici.setID;
                cabFolderCount = (int) fdici.cFolders;
                fileCount = (int) fdici.cFiles;
                return isCabinet;
            }
            finally
            {
                this.StreamHandles.FreeHandle(streamHandle);
            }
        }

        private int CabListNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.PARTIAL_FILE:
                    {
                        // This notification can occur when examining the contents of a non-first cab file.
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

                        string name = CabUnpacker.GetFileName(notification);

                        if (this.filter == null || this.filter(name))
                        {
                            if (this.fileList != null)
                            {
                                FileAttributes attributes = (FileAttributes) notification.attribs &
                                    (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
                                if (attributes == (FileAttributes) 0)
                                {
                                    attributes = FileAttributes.Normal;
                                }
                                DateTime lastWriteTime;
                                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);
                                long length = notification.cb;

                                CabFileInfo fileInfo = new CabFileInfo(
                                    name,
                                    notification.iFolder,
                                    notification.iCabinet,
                                    attributes,
                                    lastWriteTime,
                                    length);
                                this.fileList.Add(fileInfo);
                                this.currentFileNumber = this.fileList.Count - 1;
                                this.fileBytesProcessed += notification.cb;
                            }
                        }

                        this.totalFiles++;
                        this.totalFileBytes += notification.cb;
                        return 0;  // Continue
                    }
            }
            return 0;
        }

        private int CabExtractNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        if (this.NextCabinetName != null && this.NextCabinetName.StartsWith("?", StringComparison.Ordinal))
                        {
                            // We are just continuing the copy of a file that spanned cabinets.
                            // The next cabinet name needs to be preserved.
                            this.NextCabinetName = this.NextCabinetName.Substring(1);
                        }
                        else
                        {
                            string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                            this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        }
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.NEXT_CABINET:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.CabNumbers[nextCab] = (short) notification.iCabinet;
                        this.NextCabinetName = "?" + this.NextCabinetName;
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        return this.CabExtractCopyFile(notification);
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.CLOSE_FILE_INFO:
                    {
                        return this.CabExtractCloseFile(notification);
                    }
            }
            return 0;
        }

        private int CabExtractCopyFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            if (notification.iFolder != this.folderId)
            {
                if (notification.iFolder != -3)  // -3 is a special folderId used when continuing a folder from a previous cab
                {
                    if (this.folderId != -1) // -1 means we just started the extraction sequence
                    {
                        this.currentFolderNumber++;
                    }
                }
                this.folderId = notification.iFolder;
            }

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            if (this.filter == null || this.filter(name))
            {
                this.currentFileNumber++;
                this.currentFileName = name;

                this.currentFileBytesProcessed = 0;
                this.currentFileTotalBytes = notification.cb;
                this.OnProgress(ArchiveProgressType.StartFile);

                DateTime lastWriteTime;
                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

                Stream stream = this.context.OpenFileWriteStream(name, notification.cb, lastWriteTime);
                if (stream != null)
                {
                    this.FileStream = stream;
                    int streamHandle = this.StreamHandles.AllocHandle(stream);
                    return streamHandle;
                }
                else
                {
                    this.fileBytesProcessed += notification.cb;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentFileName = null;
                }
            }
            return 0;  // Continue
        }

        private int CabExtractCloseFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            Stream stream = this.StreamHandles[notification.hf];
            this.StreamHandles.FreeHandle(notification.hf);

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            FileAttributes attributes = (FileAttributes) notification.attribs &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            if (attributes == (FileAttributes) 0)
            {
                attributes = FileAttributes.Normal;
            }
            DateTime lastWriteTime;
            CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

            stream.Flush();
            this.context.CloseFileWriteStream(name, stream, attributes, lastWriteTime);
            this.FileStream = null;

            long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
            this.currentFileBytesProcessed += remainder;
            this.fileBytesProcessed += remainder;
            this.OnProgress(ArchiveProgressType.FinishFile);
            this.currentFileName = null;

            return 1;  // Continue
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabPacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabPacker : CabWorker
    {
        private const string TempStreamName = "%%TEMP%%";

        private NativeMethods.FCI.Handle fciHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FCI.PFNALLOC fciAllocMemHandler;
        private NativeMethods.FCI.PFNFREE fciFreeMemHandler;
        private NativeMethods.FCI.PFNOPEN fciOpenStreamHandler;
        private NativeMethods.FCI.PFNREAD fciReadStreamHandler;
        private NativeMethods.FCI.PFNWRITE fciWriteStreamHandler;
        private NativeMethods.FCI.PFNCLOSE fciCloseStreamHandler;
        private NativeMethods.FCI.PFNSEEK fciSeekStreamHandler;
        private NativeMethods.FCI.PFNFILEPLACED fciFilePlacedHandler;
        private NativeMethods.FCI.PFNDELETE fciDeleteFileHandler;
        private NativeMethods.FCI.PFNGETTEMPFILE fciGetTempFileHandler;

        private NativeMethods.FCI.PFNGETNEXTCABINET fciGetNextCabinet;
        private NativeMethods.FCI.PFNSTATUS fciCreateStatus;
        private NativeMethods.FCI.PFNGETOPENINFO fciGetOpenInfo;

        private IPackStreamContext context;

        private FileAttributes fileAttributes;
        private DateTime fileLastWriteTime;

        private int maxCabBytes;

        private long totalFolderBytesProcessedInCurrentCab;

        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;
        private IList<Stream> tempStreams;

        public CabPacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fciAllocMemHandler    = this.CabAllocMem;
            this.fciFreeMemHandler     = this.CabFreeMem;
            this.fciOpenStreamHandler  = this.CabOpenStreamEx;
            this.fciReadStreamHandler  = this.CabReadStreamEx;
            this.fciWriteStreamHandler = this.CabWriteStreamEx;
            this.fciCloseStreamHandler = this.CabCloseStreamEx;
            this.fciSeekStreamHandler  = this.CabSeekStreamEx;
            this.fciFilePlacedHandler  = this.CabFilePlaced;
            this.fciDeleteFileHandler  = this.CabDeleteFile;
            this.fciGetTempFileHandler = this.CabGetTempFile;
            this.fciGetNextCabinet     = this.CabGetNextCabinet;
            this.fciCreateStatus       = this.CabCreateStatus;
            this.fciGetOpenInfo        = this.CabGetOpenInfo;
            this.tempStreams = new List<Stream>();
            this.compressionLevel = CompressionLevel.Normal;
        }

        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void CreateFci(long maxArchiveSize)
        {
            NativeMethods.FCI.CCAB ccab = new NativeMethods.FCI.CCAB();
            if (maxArchiveSize > 0 && maxArchiveSize < ccab.cb)
            {
                ccab.cb = Math.Max(
                    NativeMethods.FCI.MIN_DISK, (int) maxArchiveSize);
            }

            object maxFolderSizeOption = this.context.GetOption(
                "maxFolderSize", null);
            if (maxFolderSizeOption != null)
            {
                long maxFolderSize = Convert.ToInt64(
                    maxFolderSizeOption, CultureInfo.InvariantCulture);
                if (maxFolderSize > 0 && maxFolderSize < ccab.cbFolderThresh)
                {
                    ccab.cbFolderThresh = (int) maxFolderSize;
                }
            }

            this.maxCabBytes = ccab.cb;
            ccab.szCab = this.context.GetArchiveName(0);
            if (ccab.szCab == null)
            {
                throw new FileNotFoundException(
                    "Cabinet name not provided by stream context.");
            }
            ccab.setID = (short) new Random().Next(
                Int16.MinValue, Int16.MaxValue + 1);
            this.CabNumbers[ccab.szCab] = 0;
            this.currentArchiveName = ccab.szCab;
            this.totalArchives = 1;
            this.CabStream = null;

            this.Erf.Clear();
            this.fciHandle = NativeMethods.FCI.Create(
                this.ErfHandle.AddrOfPinnedObject(),
                this.fciFilePlacedHandler,
                this.fciAllocMemHandler,
                this.fciFreeMemHandler,
                this.fciOpenStreamHandler,
                this.fciReadStreamHandler,
                this.fciWriteStreamHandler,
                this.fciCloseStreamHandler,
                this.fciSeekStreamHandler,
                this.fciDeleteFileHandler,
                this.fciGetTempFileHandler,
                ccab,
                IntPtr.Zero);
            this.CheckError(false);
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                try
                {
                    this.context = streamContext;

                    this.ResetProgressData();

                    this.CreateFci(maxArchiveSize);

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            this.context.CloseFileReadStream(file, fileStream);
                        }
                    }

                    long uncompressedBytesInFolder = 0;
                    this.currentFileNumber = -1;

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file, out attributes, out lastWriteTime);
                        if (fileStream == null)
                        {
                            continue;
                        }

                        if (fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER)
                        {
                            throw new NotSupportedException(String.Format(
                                CultureInfo.InvariantCulture,
                                "File {0} exceeds maximum file size " +
                                "for cabinet format.",
                                file));
                        }

                        if (uncompressedBytesInFolder > 0)
                        {
                            // Automatically create a new folder if this file
                            // won't fit in the current folder.
                            bool nextFolder = uncompressedBytesInFolder
                                + fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER;

                            // Otherwise ask the client if it wants to
                            // move to the next folder.
                            if (!nextFolder)
                            {
                                object nextFolderOption = streamContext.GetOption(
                                    "nextFolder",
                                    new object[] { file, this.currentFolderNumber });
                                nextFolder = Convert.ToBoolean(
                                    nextFolderOption, CultureInfo.InvariantCulture);
                            }

                            if (nextFolder)
                            {
                                this.FlushFolder();
                                uncompressedBytesInFolder = 0;
                            }
                        }

                        if (this.currentFolderTotalBytes > 0)
                        {
                            this.currentFolderTotalBytes = 0;
                            this.currentFolderNumber++;
                            uncompressedBytesInFolder = 0;
                        }

                        this.currentFileName = file;
                        this.currentFileNumber++;

                        this.currentFileTotalBytes = fileStream.Length;
                        this.currentFileBytesProcessed = 0;
                        this.OnProgress(ArchiveProgressType.StartFile);

                        uncompressedBytesInFolder += fileStream.Length;

                        this.AddFile(
                            file,
                            fileStream,
                            attributes,
                            lastWriteTime,
                            false,
                            this.CompressionLevel);
                    }

                    this.FlushFolder();
                    this.FlushCabinet();
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveWriteStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileReadStream(
                            this.currentFileName, this.FileStream);
                        this.FileStream = null;
                    }
                    this.context = null;

                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    this.currentFolderTotalBytes = 0;

                    stream = this.context.OpenArchiveWriteStream(cabNumber, path, true, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(
                            String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;

                    this.currentArchiveTotalBytes = Math.Min(
                        this.totalFolderBytesProcessedInCurrentCab, this.maxCabBytes);
                    this.currentArchiveBytesProcessed = 0;

                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            else if (path == CabPacker.TempStreamName)
            {
                // Opening memory stream for a temp file.
                Stream stream = new MemoryStream();
                this.tempStreams.Add(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            else if (path != CabWorker.CabStreamName)
            {
                // Opening a file on disk for a temp file.
                path = Path.Combine(Path.GetTempPath(), path);
                Stream stream = new FileStream(path, FileMode.Open, FileAccess.ReadWrite);
                this.tempStreams.Add(stream);
                stream = new DuplicateStream(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                Stream stream = this.StreamHandles[streamHandle];
                if (DuplicateStream.OriginalStream(stream) ==
                    DuplicateStream.OriginalStream(this.CabStream))
                {
                    this.currentArchiveBytesProcessed += cb;
                    if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                    {
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }
                }
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.FileStream))
            {
                this.context.CloseFileReadStream(this.currentFileName, stream);
                this.FileStream = null;
                long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
                this.currentFileBytesProcessed += remainder;
                this.fileBytesProcessed += remainder;
                this.OnProgress(ArchiveProgressType.FinishFile);

                this.currentFileTotalBytes = 0;
                this.currentFileBytesProcessed = 0;
                this.currentFileName = null;
            }
            else if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (stream.CanWrite)
                {
                    stream.Flush();
                }

                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                this.OnProgress(ArchiveProgressType.FinishArchive);
                this.currentArchiveNumber++;
                this.totalArchives++;

                this.context.CloseArchiveWriteStream(
                    this.currentArchiveNumber,
                    this.currentArchiveName,
                    stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;
                this.totalFolderBytesProcessedInCurrentCab = 0;

                this.CabStream = null;
            }
            else  // Must be a temp stream
            {
                stream.Close();
                this.tempStreams.Remove(stream);
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing) 
        {
            try
            {
                if (disposing)
                {
                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static NativeMethods.FCI.TCOMP GetCompressionType(CompressionLevel compLevel)
        {
            if (compLevel < CompressionLevel.Min)
            {
                return NativeMethods.FCI.TCOMP.TYPE_NONE;
            }
            else
            {
                if (compLevel > CompressionLevel.Max)
                {
                    compLevel = CompressionLevel.Max;
                }

                int lzxWindowMax =
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_HI >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW) -
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW);
                int lzxWindow = lzxWindowMax *
                    (compLevel - CompressionLevel.Min) / (CompressionLevel.Max - CompressionLevel.Min);

                return (NativeMethods.FCI.TCOMP) ((int) NativeMethods.FCI.TCOMP.TYPE_LZX |
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO +
                    (lzxWindow << (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW)));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void AddFile(
            string name,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime,
            bool execute,
            CompressionLevel compLevel)
        {
            this.FileStream = stream;
            this.fileAttributes = attributes &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            this.fileLastWriteTime = lastWriteTime;
            this.currentFileName = name;

            NativeMethods.FCI.TCOMP tcomp = CabPacker.GetCompressionType(compLevel);

            IntPtr namePtr = IntPtr.Zero;
            try
            {
                Encoding nameEncoding = Encoding.ASCII;
                if (Encoding.UTF8.GetByteCount(name) > name.Length)
                {
                    nameEncoding = Encoding.UTF8;
                    this.fileAttributes |= FileAttributes.Normal;  // _A_NAME_IS_UTF
                }

                byte[] nameBytes = nameEncoding.GetBytes(name);
                namePtr = Marshal.AllocHGlobal(nameBytes.Length + 1);
                Marshal.Copy(nameBytes, 0, namePtr, nameBytes.Length);
                Marshal.WriteByte(namePtr, nameBytes.Length, 0);

                this.Erf.Clear();
                NativeMethods.FCI.AddFile(
                    this.fciHandle,
                    String.Empty,
                    namePtr,
                    execute,
                    this.fciGetNextCabinet,
                    this.fciCreateStatus,
                    this.fciGetOpenInfo,
                    tcomp);
            }
            finally
            {
                if (namePtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(namePtr);
                }
            }

            this.CheckError(false);
            this.FileStream = null;
            this.currentFileName = null;
        }

        private void FlushFolder()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushFolder(this.fciHandle, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private void FlushCabinet()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushCabinet(this.fciHandle, false, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private int CabGetOpenInfo(
            string path,
            out short date,
            out short time,
            out short attribs,
            out int err,
            IntPtr pv)
        {
            CompressionEngine.DateTimeToDosDateAndTime(this.fileLastWriteTime, out date, out time);
            attribs = (short) this.fileAttributes;

            Stream stream = this.FileStream;
            this.FileStream = new DuplicateStream(stream);
            int streamHandle = this.StreamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        private int CabFilePlaced(
            IntPtr pccab,
            string filePath,
            long fileSize,
            int continuation,
            IntPtr pv)
        {
            return 0;
        }

        private int CabGetNextCabinet(IntPtr pccab, uint prevCabSize, IntPtr pv)
        {
            NativeMethods.FCI.CCAB nextCcab = new NativeMethods.FCI.CCAB();
            Marshal.PtrToStructure(pccab, nextCcab);

            nextCcab.szDisk = String.Empty;
            nextCcab.szCab = this.context.GetArchiveName(nextCcab.iCab);
            this.CabNumbers[nextCcab.szCab] = (short) nextCcab.iCab;
            this.NextCabinetName = nextCcab.szCab;

            Marshal.StructureToPtr(nextCcab, pccab, false);
            return 1;
        }

        private int CabCreateStatus(NativeMethods.FCI.STATUS typeStatus, uint cb1, uint cb2, IntPtr pv)
        {
            switch (typeStatus)
            {
                case NativeMethods.FCI.STATUS.FILE:
                    if (cb2 > 0 && this.currentFileBytesProcessed < this.currentFileTotalBytes)
                    {
                        if (this.currentFileBytesProcessed + cb2 > this.currentFileTotalBytes)
                        {
                            cb2 = (uint) this.currentFileTotalBytes - (uint) this.currentFileBytesProcessed;
                        }
                        this.currentFileBytesProcessed += cb2;
                        this.fileBytesProcessed += cb2;

                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                    break;

                case NativeMethods.FCI.STATUS.FOLDER:
                    if (cb1 == 0)
                    {
                        this.currentFolderTotalBytes = cb2 - this.totalFolderBytesProcessedInCurrentCab;
                        this.totalFolderBytesProcessedInCurrentCab = cb2;
                    }
                    else if (this.currentFolderTotalBytes == 0)
                    {
                        this.OnProgress(ArchiveProgressType.PartialArchive);
                    }
                    break;

                case NativeMethods.FCI.STATUS.CABINET:
                    break;
            }
            return 0;
        }

        private int CabGetTempFile(IntPtr tempNamePtr, int tempNameSize, IntPtr pv)
        {
            string tempFileName;
            if (this.UseTempFiles)
            {
                tempFileName = Path.GetFileName(Path.GetTempFileName());
            }
            else
            {
                tempFileName = CabPacker.TempStreamName;
            }

            byte[] tempNameBytes = Encoding.ASCII.GetBytes(tempFileName);
            if (tempNameBytes.Length >= tempNameSize)
            {
                return -1;
            }

            Marshal.Copy(tempNameBytes, 0, tempNamePtr, tempNameBytes.Length);
            Marshal.WriteByte(tempNamePtr, tempNameBytes.Length, 0);  // null-terminator
            return 1;
        }

        private int CabDeleteFile(string path, out int err, IntPtr pv)
        {
            try
            {
                // Deleting a temp file - don't bother if it is only a memory stream.
                if (path != CabPacker.TempStreamName)
                {
                    path = Path.Combine(Path.GetTempPath(), path);
                    File.Delete(path);
                }
            }
            catch (IOException)
            {
                // Failure to delete a temp file is not fatal.
            }
            err = 0;
            return 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression\SafeNativeMethods.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.Security;
    using System.Runtime.InteropServices;

    [SuppressUnmanagedCodeSecurity]
    internal static class SafeNativeMethods
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool DosDateTimeToFileTime(
            short wFatDate, short wFatTime, out long fileTime);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool FileTimeToDosDateTime(
            ref long fileTime, out short wFatDate, out short wFatTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\CabWorker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabWorker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.IO.IsolatedStorage;
    using System.Text;
    using System.Security;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal abstract class CabWorker : IDisposable
    {
        internal const string CabStreamName = "%%CAB%%";

        private CabEngine cabEngine;

        private HandleManager<Stream> streamHandles;
        private Stream cabStream;
        private Stream fileStream;

        private NativeMethods.ERF erf;
        private GCHandle erfHandle;

        private IDictionary<string, short> cabNumbers;
        private string nextCabinetName;

        private bool suppressProgressEvents;

        private byte[] buf;

        // Progress data
        protected string currentFileName;
        protected int    currentFileNumber;
        protected int    totalFiles;
        protected long   currentFileBytesProcessed;
        protected long   currentFileTotalBytes;
        protected short  currentFolderNumber;
        protected long   currentFolderTotalBytes;
        protected string currentArchiveName;
        protected short  currentArchiveNumber;
        protected short  totalArchives;
        protected long   currentArchiveBytesProcessed;
        protected long   currentArchiveTotalBytes;
        protected long   fileBytesProcessed;
        protected long   totalFileBytes;

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected CabWorker(CabEngine cabEngine)
        {
            this.cabEngine = cabEngine;
            this.streamHandles = new HandleManager<Stream>();
            this.erf = new NativeMethods.ERF();
            this.erfHandle = GCHandle.Alloc(this.erf, GCHandleType.Pinned);
            this.cabNumbers = new Dictionary<string, short>(1);

            // 32K seems to be the size of the largest chunks processed by cabinet.dll.
            // But just in case, this buffer will auto-enlarge.
            this.buf = new byte[32768];
        }

        ~CabWorker()
        {
            this.Dispose(false);
        }

        public CabEngine CabEngine
        {
            get
            {
                return this.cabEngine;
            }
        }

        internal NativeMethods.ERF Erf
        {
            get
            {
                return this.erf;
            }
        }

        internal GCHandle ErfHandle
        {
            get
            {
                return this.erfHandle;
            }
        }

        internal HandleManager<Stream> StreamHandles
        {
            get
            {
                return this.streamHandles;
            }
        }

        internal bool SuppressProgressEvents
        {
            get
            {
                return this.suppressProgressEvents;
            }

            set
            {
                this.suppressProgressEvents = value;
            }
        }

        internal IDictionary<string, short> CabNumbers
        {
            get
            {
                return this.cabNumbers;
            }
        }

        internal string NextCabinetName
        {
            get
            {
                return this.nextCabinetName;
            }

            set
            {
                this.nextCabinetName = value;
            }
        }

        internal Stream CabStream
        {
            get
            {
                return this.cabStream;
            }

            set
            {
                this.cabStream = value;
            }
        }

        internal Stream FileStream
        {
            get
            {
                return this.fileStream;
            }

            set
            {
                this.fileStream = value;
            }
        }

        public void Dispose() 
        {
            this.Dispose(true);
            GC.SuppressFinalize(this); 
        }

        protected void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentFolderNumber = 0;
            this.currentFolderTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        protected void OnProgress(ArchiveProgressType progressType)
        {
            if (!this.suppressProgressEvents)
            {
                ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                    progressType,
                    this.currentFileName,
                    this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                    this.totalFiles,
                    this.currentFileBytesProcessed,
                    this.currentFileTotalBytes,
                    this.currentArchiveName,
                    this.currentArchiveNumber,
                    this.totalArchives,
                    this.currentArchiveBytesProcessed,
                    this.currentArchiveTotalBytes,
                    this.fileBytesProcessed,
                    this.totalFileBytes);
                this.CabEngine.ReportProgress(e);
            }
        }

        internal IntPtr CabAllocMem(int byteCount)
        {
            IntPtr memPointer = Marshal.AllocHGlobal((IntPtr) byteCount);
            return memPointer;
        }

        internal void CabFreeMem(IntPtr memPointer)
        {
            Marshal.FreeHGlobal(memPointer);
        }

        internal int CabOpenStream(string path, int openFlags, int shareMode)
        {
            int err; return this.CabOpenStreamEx(path, openFlags, shareMode, out err, IntPtr.Zero);
        }

        internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            path = path.Trim();
            Stream stream = this.cabStream;
            this.cabStream = new DuplicateStream(stream);
            int streamHandle = this.streamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        internal int CabReadStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabReadStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            count = stream.Read(this.buf, 0, count);
            Marshal.Copy(this.buf, 0, memory, count);
            err = 0;
            return count;
        }

        internal int CabWriteStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabWriteStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            Marshal.Copy(memory, this.buf, 0, count);
            stream.Write(this.buf, 0, count);
            err = 0;
            return cb;
        }

        internal int CabCloseStream(int streamHandle)
        {
            int err; return this.CabCloseStreamEx(streamHandle, out err, IntPtr.Zero);
        }

        internal virtual int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            this.streamHandles.FreeHandle(streamHandle);
            err = 0;
            return 0;
        }

        internal int CabSeekStream(int streamHandle, int offset, int seekOrigin)
        {
            int err; return this.CabSeekStreamEx(streamHandle, offset, seekOrigin, out err, IntPtr.Zero);
        }

        internal virtual int CabSeekStreamEx(int streamHandle, int offset, int seekOrigin, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            offset = (int) stream.Seek(offset, (SeekOrigin) seekOrigin);
            err = 0;
            return offset;
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected virtual void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                if (this.cabStream != null)
                {
                    this.cabStream.Close();
                    this.cabStream = null;
                }

                if (this.fileStream != null)
                {
                    this.fileStream.Close();
                    this.fileStream = null;
                }
            }

            if (this.erfHandle.IsAllocated)
            {
                this.erfHandle.Free();
            }
        }

        protected void CheckError(bool extracting)
        {
            if (this.Erf.Error)
            {
                throw new CabException(
                    this.Erf.Oper,
                    this.Erf.Type,
                    CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, extracting));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\HandleManager.cs ===
//---------------------------------------------------------------------
// <copyright file="HandleManager.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Generic class for managing allocations of integer handles
    /// for objects of a certain type.
    /// </summary>
    /// <typeparam name="T">The type of objects the handles refer to.</typeparam>
    internal sealed class HandleManager<T> where T : class
    {
        /// <summary>
        /// Auto-resizing list of objects for which handles have been allocated.
        /// Each handle is just an index into this list. When a handle is freed,
        /// the list item at that index is set to null.
        /// </summary>
        private List<T> handles;

        /// <summary>
        /// Creates a new HandleManager instance.
        /// </summary>
        public HandleManager()
        {
            this.handles = new List<T>();
        }

        /// <summary>
        /// Gets the object of a handle, or null if the handle is invalid.
        /// </summary>
        /// <param name="handle">The integer handle previously allocated
        /// for the desired object.</param>
        /// <returns>The object for which the handle was allocated.</returns>
        public T this[int handle]
        {
            get
            {
                if (handle > 0 && handle <= this.handles.Count)
                {
                    return this.handles[handle - 1];
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Allocates a new handle for an object.
        /// </summary>
        /// <param name="obj">Object that the handle will refer to.</param>
        /// <returns>New handle that can be later used to retrieve the object.</returns>
        public int AllocHandle(T obj)
        {
            this.handles.Add(obj);
            int handle = this.handles.Count;
            return handle;
        }

        /// <summary>
        /// Frees a handle that was previously allocated. Afterward the handle
        /// will be invalid and the object it referred to can no longer retrieved.
        /// </summary>
        /// <param name="handle">Handle to be freed.</param>
        public void FreeHandle(int handle)
        {
            if (handle > 0 && handle <= this.handles.Count)
            {
                this.handles[handle - 1] = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ConcatStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ConcatStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;

    /// <summary>
    /// Used to trick a DeflateStream into reading from or writing to
    /// a series of (chunked) streams instead of a single steream.
    /// </summary>
    internal class ConcatStream : Stream
    {
        private Stream source;
        private long position;
        private long length;
        private Action<ConcatStream> nextStreamHandler;

        public ConcatStream(Action<ConcatStream> nextStreamHandler)
        {
            if (nextStreamHandler == null)
            {
                throw new ArgumentNullException("nextStreamHandler");
            }

            this.nextStreamHandler = nextStreamHandler;
            this.length = Int64.MaxValue;
        }

        public Stream Source
        {
            get { return this.source; }
            set { this.source = value; }
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override bool CanWrite
        {
            get { return true; }
        }

        public override bool CanSeek
        {
            get { return false; }
        }

        public override long Length
        {
            get
            {
                return this.length;
            }
        }

        public override long Position
        {
            get { return this.position; }
            set { throw new NotSupportedException(); }
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            count = (int) Math.Min(count, this.length - this.position);

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    this.source.Length - this.source.Position);

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                partialCount = this.source.Read(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }

            return count;
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    Math.Max(0, this.length - this.source.Position));

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                this.source.Write(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }
        }

        public override void Flush()
        {
            if (this.source != null)
            {
                this.source.Flush();
            }
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        public override void SetLength(long value)
        {
            this.length = value;
        }

        public override void Close()
        {
            if (this.source != null)
            {
                this.source.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipCompressionMethod.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipCompressionMethod.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Identifies the compression method or &quot;algorithm&quot;
    /// used for a single file within a zip archive.
    /// </summary>
    /// <remarks>
    /// Proprietary zip implementations may define additional compression
    /// methods outside of those included here.
    /// </remarks>
    public enum ZipCompressionMethod
    {
        /// <summary>
        /// The file is stored (no compression)
        /// </summary>
        Store = 0,
        
        /// <summary>
        /// The file is Shrunk
        /// </summary>
        Shrink = 1,
        
        /// <summary>
        /// The file is Reduced with compression factor 1
        /// </summary>
        Reduce1 = 2,

        /// <summary>
        /// The file is Reduced with compression factor 2
        /// </summary>
        Reduce2 = 3,

        /// <summary>
        /// The file is Reduced with compression factor 3
        /// </summary>
        Reduce3 = 4,

        /// <summary>
        /// The file is Reduced with compression factor 4
        /// </summary>
        Reduce4 = 5,
        
        /// <summary>
        /// The file is Imploded
        /// </summary>
        Implode = 6,
        
        /// <summary>
        /// The file is Deflated;
        /// the most common and widely-compatible form of zip compression.
        /// </summary>
        Deflate = 8,
        
        /// <summary>
        /// The file is Deflated using the enhanced Deflate64 method.
        /// </summary>
        Deflate64 = 9,

        /// <summary>
        /// The file is compressed using the BZIP2 algorithm.
        /// </summary>
        BZip2 = 12,

        /// <summary>
        /// The file is compressed using the LZMA algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lzma")]
        Lzma = 14,

        /// <summary>
        /// The file is compressed using the PPMd algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ppmd")]
        Ppmd = 98
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipException.cs ===
//---------------------------------------------------------------------
// <copyright file="ZipException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for zip operations.
    /// </summary>
    [Serializable]
    public class ZipException : ArchiveException
    {
        /// <summary>
        /// Creates a new ZipException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ZipException(string message, Exception innerException)
            : base(message, innerException) { }

        /// <summary>
        /// Creates a new ZipException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ZipException(string message)
            : this(message, null) { }

        /// <summary>
        /// Creates a new ZipException.
        /// </summary>
        public ZipException()
            : this(null, null) { }

        /// <summary>
        /// Initializes a new instance of the ZipException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Reflection;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the zip format.
    /// </summary>
    public partial class ZipEngine : CompressionEngine
    {
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            compressionStreamCreators;
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            decompressionStreamCreators;

        private static void InitCompressionStreamCreators()
        {
            if (ZipEngine.compressionStreamCreators == null)
            {
                ZipEngine.compressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();
                ZipEngine.decompressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();

                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Compress, true);
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Decompress, true);
                    });
            }
        }

        /// <summary>
        /// Registers a delegate that can create a warpper stream for
        /// compressing or uncompressing the data of a source stream.
        /// </summary>
        /// <param name="compressionMethod">Compression method being registered.</param>
        /// <param name="compressionMode">Indicates registration for ether
        /// compress or decompress mode.</param>
        /// <param name="creator">Delegate being registered.</param>
        /// <remarks>
        /// For compression, the delegate accepts a stream that writes to the archive
        /// and returns a wrapper stream that compresses bytes as they are written.
        /// For decompression, the delegate accepts a stream that reads from the archive
        /// and returns a wrapper stream that decompresses bytes as they are read.
        /// This wrapper stream model follows the design used by
        /// System.IO.Compression.DeflateStream, and indeed that class is used
        /// to implement the Deflate compression method by default.
        /// <para>To unregister a delegate, call this method again and pass
        /// null for the delegate parameter.</para>
        /// </remarks>
        /// <example>
        /// When the ZipEngine class is initialized, the Deflate compression method
        /// is automatically registered like this:
        /// <code>
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Compress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Compress, true);
        ///            });
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Decompress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Decompress, true);
        ///            });
        /// </code></example>
        public static void RegisterCompressionStreamCreator(
            ZipCompressionMethod compressionMethod,
            CompressionMode compressionMode,
            Converter<Stream, Stream> creator)
        {
            ZipEngine.InitCompressionStreamCreators();
            if (compressionMode == CompressionMode.Compress)
            {
                ZipEngine.compressionStreamCreators[compressionMethod] = creator;
            }
            else
            {
                ZipEngine.decompressionStreamCreators[compressionMethod] = creator;
            }
        }

        // Progress data
        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;
        private string mainArchiveName;
        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;
        private long fileBytesProcessed;
        private long totalFileBytes;
        private string comment;

        /// <summary>
        /// Creates a new instance of the zip engine.
        /// </summary>
        public ZipEngine()
            : base()
        {
            ZipEngine.InitCompressionStreamCreators();
        }

        /// <summary>
        /// Gets the comment from the last-examined archive,
        /// or sets the comment to be added to any created archives.
        /// </summary>
        public string ArchiveComment
        {
            get
            {
                return this.comment;
            }
            set
            {
                this.comment = value;
            }
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive file.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid zip archive
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (stream.Length - stream.Position < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();
            switch (sig)
            {
                case ZipFileHeader.LFHSIG:
                case ZipEndOfCentralDirectory.EOCDSIG:
                case ZipEndOfCentralDirectory.EOCD64SIG:
                case ZipFileHeader.SPANSIG:
                case ZipFileHeader.SPANSIG2:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public override long FindArchiveOffset(Stream stream)
        {
            long offset = base.FindArchiveOffset(stream);
            if (offset > 0)
            {
                // Some self-extract packages include the exe stub in file offset calculations.
                // Check the first header directory offset to decide whether the entire
                // archive needs to be offset or not.

                ZipEndOfCentralDirectory eocd = this.GetEOCD(null, stream);
                if (eocd != null && eocd.totalEntries > 0)
                {
                    stream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                    ZipFileHeader header = new ZipFileHeader();
                    if (header.Read(stream, true) && header.localHeaderOffset < stream.Length)
                    {
                        stream.Seek(header.localHeaderOffset, SeekOrigin.Begin);
                        if (header.Read(stream, false))
                        {
                            return 0;
                        }
                    }
                }
            }

            return offset;
        }

        /// <summary>
        /// Gets information about files in a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> headers = this.GetCentralDirectory(streamContext);
                if (headers == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                List<ArchiveFileInfo> files = new List<ArchiveFileInfo>(headers.Count);
                foreach (ZipFileHeader header in headers)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        files.Add(header.ToZipFileInfo());
                    }
                }

                return files.AsReadOnly();
            }
        }

        /// <summary>
        /// Reads all the file headers from the central directory in the main archive.
        /// </summary>
        private IList<ZipFileHeader> GetCentralDirectory(IUnpackStreamContext streamContext)
        {
            Stream archiveStream = null;
            this.currentArchiveNumber = 0;
            try
            {
                List<ZipFileHeader> headers = new List<ZipFileHeader>();
                archiveStream = this.OpenArchive(streamContext, 0);

                ZipEndOfCentralDirectory eocd = this.GetEOCD(streamContext, archiveStream);
                if (eocd == null)
                {
                    return null;
                }
                else if (eocd.totalEntries == 0)
                {
                    return headers;
                }

                headers.Capacity = (int) eocd.totalEntries;

                if (eocd.dirOffset > archiveStream.Length - ZipFileHeader.CFH_FIXEDSIZE)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                    archiveStream = null;
                }
                else
                {
                    archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);
                    uint sig = new BinaryReader(archiveStream).ReadUInt32();
                    if (sig != ZipFileHeader.CFHSIG)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        archiveStream = null;
                    }
                }

                if (archiveStream == null)
                {
                    this.currentArchiveNumber = (short) (eocd.dirStartDiskNumber + 1);
                    archiveStream = streamContext.OpenArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, this);

                    if (archiveStream == null)
                    {
                        return null;
                    }
                }

                archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                while (headers.Count < eocd.totalEntries)
                {
                    ZipFileHeader header = new ZipFileHeader();
                    if (!header.Read(archiveStream, true))
                    {
                        throw new ZipException(
                            "Missing or invalid central directory file header");
                    }

                    headers.Add(header);

                    if (headers.Count < eocd.totalEntries &&
                        archiveStream.Position == archiveStream.Length)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        this.currentArchiveNumber++;
                        archiveStream = streamContext.OpenArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, this);
                        if (archiveStream == null)
                        {
                            this.currentArchiveNumber = 0;
                            archiveStream = streamContext.OpenArchiveReadStream(
                                this.currentArchiveNumber, String.Empty, this);
                        }
                    }
                }

                return headers;
            }
            finally
            {
                if (archiveStream != null)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                }
            }
        }

        /// <summary>
        /// Locates and reads the end of central directory record near the
        /// end of the archive.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "streamContext")]
        private ZipEndOfCentralDirectory GetEOCD(
            IUnpackStreamContext streamContext, Stream archiveStream)
        {
            BinaryReader reader = new BinaryReader(archiveStream);
            long offset = archiveStream.Length
                - ZipEndOfCentralDirectory.EOCD_RECORD_FIXEDSIZE;
            while (offset >= 0)
            {
                archiveStream.Seek(offset, SeekOrigin.Begin);

                uint sig = reader.ReadUInt32();
                if (sig == ZipEndOfCentralDirectory.EOCDSIG)
                {
                    break;
                }

                offset--;
            }

            if (offset < 0)
            {
                return null;
            }

            ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
            archiveStream.Seek(offset, SeekOrigin.Begin);
            if (!eocd.Read(archiveStream))
            {
                throw new ZipException("Invalid end of central directory record");
            }

            if (eocd.dirOffset == (long) UInt32.MaxValue)
            {
                string saveComment = eocd.comment;

                archiveStream.Seek(
                    offset - Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE,
                    SeekOrigin.Begin);

                Zip64EndOfCentralDirectoryLocator eocdl =
                    new Zip64EndOfCentralDirectoryLocator();
                if (!eocdl.Read(archiveStream))
                {
                    throw new ZipException("Missing or invalid end of " +
                        "central directory record locator");
                }

                if (eocdl.dirStartDiskNumber == eocdl.totalDisks - 1)
                {
                    // ZIP64 eocd is entirely in current stream.
                    archiveStream.Seek(eocdl.dirOffset, SeekOrigin.Begin);
                    if (!eocd.Read(archiveStream))
                    {
                        throw new ZipException("Missing or invalid ZIP64 end of " +
                            "central directory record");
                    }
                }
                else if (streamContext == null)
                {
                    return null;
                }
                else
                {
                    // TODO: handle EOCD64 spanning archives!
                    throw new NotImplementedException("Zip implementation does not " +
                        "handle end of central directory record that spans archives.");
                }

                eocd.comment = saveComment;
            }

            return eocd;
        }

        private void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        private void OnProgress(ArchiveProgressType progressType)
        {
            ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                progressType,
                this.currentFileName,
                this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                this.totalFiles,
                this.currentFileBytesProcessed,
                this.currentFileTotalBytes,
                this.currentArchiveName,
                this.currentArchiveNumber,
                this.totalArchives,
                this.currentArchiveBytesProcessed,
                this.currentArchiveTotalBytes,
                this.fileBytesProcessed,
                this.totalFileBytes);
            this.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Cab\NativeMethods.cs ===
//---------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
using System;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

/// <summary>
/// Native DllImport methods and related structures and constants used for
/// cabinet creation and extraction via cabinet.dll.
/// </summary>
internal static class NativeMethods
{
    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fci.h.
    /// Refer to comments in fci.h for documentation.
    /// </summary>
    internal static class FCI
    {
        internal const int MIN_DISK = 32768;
        internal const int MAX_DISK = Int32.MaxValue;
        internal const int MAX_FOLDER = 0x7FFF8000;
        internal const int MAX_FILENAME = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH = 256;
        internal const int MAX_DISK_NAME = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int fileHandle, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int fileHandle, int dist, int seekType, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNDELETE(string path, out int err, IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETNEXTCABINET(IntPtr pccab, uint cbPrevCab, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNFILEPLACED(IntPtr pccab, string path, long fileSize, int continuation, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETOPENINFO(string path, out short date, out short time, out short pattribs, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSTATUS(STATUS typeStatus, uint cb1, uint cb2, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETTEMPFILE(IntPtr tempNamePtr, int tempNameSize, IntPtr pv);

        /// <summary>
        /// Error codes that can be returned by FCI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            OPEN_SRC,
            READ_SRC,
            ALLOC_FAIL,
            TEMP_FILE,
            BAD_COMPR_TYPE,
            CAB_FILE,
            USER_ABORT,
            MCI_FAIL,
        }

        /// <summary>
        /// FCI compression algorithm types and parameters.
        /// </summary>
        internal enum TCOMP : ushort
        {
            MASK_TYPE           = 0x000F,
            TYPE_NONE           = 0x0000,
            TYPE_MSZIP          = 0x0001,
            TYPE_QUANTUM        = 0x0002,
            TYPE_LZX            = 0x0003,
            BAD                 = 0x000F,

            MASK_LZX_WINDOW     = 0x1F00,
            LZX_WINDOW_LO       = 0x0F00,
            LZX_WINDOW_HI       = 0x1500,
            SHIFT_LZX_WINDOW    = 0x0008,

            MASK_QUANTUM_LEVEL  = 0x00F0,
            QUANTUM_LEVEL_LO    = 0x0010,
            QUANTUM_LEVEL_HI    = 0x0070,
            SHIFT_QUANTUM_LEVEL = 0x0004,

            MASK_QUANTUM_MEM    = 0x1F00,
            QUANTUM_MEM_LO      = 0x0A00,
            QUANTUM_MEM_HI      = 0x1500,
            SHIFT_QUANTUM_MEM   = 0x0008,

            MASK_RESERVED       = 0xE000,
        }

        /// <summary>
        /// Reason for FCI status callback.
        /// </summary>
        internal enum STATUS : uint
        {
            FILE    = 0,
            FOLDER  = 1,
            CABINET = 2,
        }

        [SuppressMessage("Microsoft.Globalization", "CA2101:SpecifyMarshalingForPInvokeStringArguments")]
        [DllImport("cabinet.dll", EntryPoint = "FCICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create(IntPtr perf, PFNFILEPLACED pfnfcifp, PFNALLOC pfna, PFNFREE pfnf, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, PFNDELETE pfndelete, PFNGETTEMPFILE pfnfcigtf, [MarshalAs(UnmanagedType.LPStruct)] CCAB pccab, IntPtr pv);

        [DllImport("cabinet.dll", EntryPoint = "FCIAddFile", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int AddFile(Handle hfci, string pszSourceFile, IntPtr pszFileName, [MarshalAs(UnmanagedType.Bool)] bool fExecute, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis, PFNGETOPENINFO pfnfcigoi, TCOMP typeCompress);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushCabinet(Handle hfci, [MarshalAs(UnmanagedType.Bool)] bool fGetNextCab, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushFolder", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushFolder(Handle hfci, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FCIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfci);

        /// <summary>
        /// Cabinet information structure used for FCI initialization and GetNextCabinet callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class CCAB
        {
            internal int cb             = MAX_DISK;
            internal int cbFolderThresh = MAX_FOLDER;
            internal int cbReserveCFHeader;
            internal int cbReserveCFFolder;
            internal int cbReserveCFData;
            internal int iCab;
            internal int iDisk;
            internal int fFailOnIncompressible;
            internal short setID;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_DISK_NAME   )] internal string szDisk    = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CABINET_NAME)] internal string szCab     = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CAB_PATH    )] internal string szCabPath = String.Empty;
        }

        /// <summary>
        /// Ensures that the FCI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FCI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
            protected override bool ReleaseHandle()
            {
                return FCI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fdi.h.
    /// Refer to comments in fdi.h for documentation.
    /// </summary>
    internal static class FDI
    {
        internal const int MAX_DISK         = Int32.MaxValue;
        internal const int MAX_FILENAME     = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH     = 256;
        internal const int MAX_DISK_NAME    = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int hf);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int hf, int dist, int seektype);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNNOTIFY(NOTIFICATIONTYPE fdint, NOTIFICATION fdin);

        /// <summary>
        /// Error codes that can be returned by FDI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            CABINET_NOT_FOUND,
            NOT_A_CABINET,
            UNKNOWN_CABINET_VERSION,
            CORRUPT_CABINET,
            ALLOC_FAIL,
            BAD_COMPR_TYPE,
            MDI_FAIL,
            TARGET_FILE,
            RESERVE_MISMATCH,
            WRONG_CABINET,
            USER_ABORT,
        }

        /// <summary>
        /// Type of notification message for the FDI Notify callback.
        /// </summary>
        internal enum NOTIFICATIONTYPE : int
        {
            CABINET_INFO,
            PARTIAL_FILE,
            COPY_FILE,
            CLOSE_FILE_INFO,
            NEXT_CABINET,
            ENUMERATE,
        }

        [DllImport("cabinet.dll", EntryPoint = "FDICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create([MarshalAs(UnmanagedType.FunctionPtr)] PFNALLOC pfnalloc, [MarshalAs(UnmanagedType.FunctionPtr)] PFNFREE pfnfree, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, int cpuType, IntPtr perf);

        [DllImport("cabinet.dll", EntryPoint = "FDICopy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int Copy(Handle hfdi, string pszCabinet, string pszCabPath, int flags, PFNNOTIFY pfnfdin, IntPtr pfnfdid, IntPtr pvUser);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FDIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfdi);

        [DllImport("cabinet.dll", EntryPoint = "FDIIsCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [SuppressMessage("Microsoft.Portability", "CA1901:PInvokeDeclarationsShouldBePortable", Justification="FDI file handles definitely remain 4 bytes on 64bit platforms.")]
        internal static extern int IsCabinet(Handle hfdi, int hf, out CABINFO pfdici);

        /// <summary>
        /// Cabinet information structure filled in by FDI IsCabinet.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct CABINFO
        {
            internal int cbCabinet;
            internal short cFolders;
            internal short cFiles;
            internal short setID;
            internal short iCabinet;
            internal int fReserve;
            internal int hasprev;
            internal int hasnext;
        }

        /// <summary>
        /// Cabinet notification details passed to the FDI Notify callback.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class NOTIFICATION
        {
            internal int cb;
            internal IntPtr psz1;
            internal IntPtr psz2;
            internal IntPtr psz3;
            internal IntPtr pv;

            internal IntPtr hf_ptr;

            internal short date;
            internal short time;
            internal short attribs;
            internal short setID;
            internal short iCabinet;
            internal short iFolder;
            internal int fdie;

            // Unlike all the other file handles in FCI/FDI, this one is
            // actually pointer-sized. Use a property to pretend it isn't.
            internal int hf
            {
                get { return (int) this.hf_ptr; }
            }
        }

        /// <summary>
        /// Ensures that the FDI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FDI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            protected override bool ReleaseHandle()
            {
                return FDI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// Error info structure for FCI and FDI.
    /// </summary>
    /// <remarks>Before being passed to FCI or FDI, this structure is
    /// pinned in memory via a GCHandle. The pinning is necessary
    /// to be able to read the results, since the ERF structure doesn't
    /// get marshalled back out after an error.</remarks>
    [StructLayout(LayoutKind.Sequential)]
    internal class ERF
    {
        private int erfOper;
        private int erfType;
        private int fError;

        /// <summary>
        /// Gets or sets the cabinet error code.
        /// </summary>
        internal int Oper
        {
            get
            {
                return this.erfOper;
            }

            set
            {
                this.erfOper = value;
            }
        }

        /// <summary>
        /// Gets or sets the Win32 error code.
        /// </summary>
        internal int Type
        {
            get
            {
                return this.erfType;
            }

            set
            {
                this.erfType = value;
            }
        }

        /// <summary>
        /// GCHandle doesn't like the bool type, so use an int underneath.
        /// </summary>
        internal bool Error
        {
            get
            {
                return this.fError != 0;
            }

            set
            {
                this.fError = value ? 1 : 0;
            }
        }

        /// <summary>
        /// Clears the error information.
        /// </summary>
        internal void Clear()
        {
            this.Oper = 0;
            this.Type = 0;
            this.Error = false;
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\AutoSubmit.cs ===
using System;
using System.IO;
using System.Collections.Generic;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Create a submission to Codesign.Net.
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class CodesignSubmission
    {
        public int CreateSubmission(string file, IList<string> signers, string largeFileCertID, string normalFileCertID, string strongNameCertID, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            CODESIGN.Submitter.Job job = null;
            try 
            {
                Log.WriteLog("Submitting {0} for CodeSign...", Path.GetFileName(file));
                //Initialize the Codesign.Submitter object
                //"Codesign" represents the server - constant value do not change
                //9556 represents the port - constant value do not change
                job = CODESIGN.Submitter.Job.Initialize("codesign.gtm.microsoft.com", 9556, true); 
                                
                // Sets the Partial return flag option.
                // False - If any files fail signing you will not get any files back.
                // True - Only retrieve successfully signed files.
                job.IsAllowReturnPartial = true;            // default is false

                // This is reference information that can be displayed or used in searches
                job.Description = "Job Description - a way to make it easier to associate jobs";
                job.Keywords = "Keywords to improve searches";

                // This call selects a certificate from the ones allowed for this user
                // You may pick only one Authenticode certificate
                // You may pick only one Strong Name certificate
                // You may pick an Authenticode and Strong Name certificate at the same time
                // Example:
                FileInfo info = new FileInfo(file);
                if (info.Length > 524288000)
                {
                    job.SelectCertificate(largeFileCertID);   // You must have permissions to the requested cert
                }
                else
                {
                    job.SelectCertificate(normalFileCertID);   // You must have permissions to the requested cert
                    if (strongNameCertID != @"")
                    {
                        job.SelectCertificate(strongNameCertID);   // You must have permissions to the requested cert
                    }
                }
                
                // This will populate the approvers to the job
                // NOTE: these users are invalid, must substitute real user aliases who are authorized for approval
                // You need at minimum two approvers - you may add as many as necessary
                // Approvers must be entered in the system to approve jobs
                // Approvers CANNOT be the job submitter
                foreach (string strSigner in signers)
                {
                    job.AddApprover(strSigner);
                }

                // These calls add notification subscriptions to the job. A number of others are 
                // available, these are the standard ones.
                // Check the CODESIGN.NotificationEventTypeEnum enumaration for a complete list.
                //job.SetNotification(job.Submitter, new CODESIGN.NotificationEventTypeEnum[] {CODESIGN.NotificationEventTypeEnum.JobCompletionFailure,CODESIGN.NotificationEventTypeEnum.JobCompletionSuccess,CODESIGN.NotificationEventTypeEnum.JobVirusScanFailure});


                // This call adds an entire directory tree to the job, duplicating its structure in
                // the submission share and making all metadata the same for each file.
                job.AddFile(file, "CodeSign", "http://CodeSignInfo", CODESIGN.JavaPermissionsTypeEnum.None);

                // This call sends the job to the back end for processing
                job.Send();

                Log.WriteLog("Submitting {0} finished", Path.GetFileName(file));
                // This call displays the job number, assigned during the send process
                Log.WriteLog("Job Number is: {0}", job.JobNumber);
                Log.WriteLog("Job Completion Path is: {0}", job.JobCompletionPath);
                if (jobList != null)
                {
                    jobList.Add(job);
                }
            }
            catch (Exception exc)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(exc));
                if (job != null)
                {
                    foreach(CODESIGN.Submitter.JobError je in job.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\JobWatcher.cs ===
using System;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Monitor a job until completionsubmission
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class Watcher
    {
        /// <summary>
        /// The main method
        /// </summary>
        public static int Monitor(string strJobNumber)
        {
            int ret = 0;
            //Check if user passed the job number in the parameters

            //Jobwatcher instance, still null here
            CODESIGN.Submitter.JobWatcher jw = null;

            try
            {
                //Instantiate new JobWatcher object
                jw = new CODESIGN.Submitter.JobWatcher();

                // This call waits until the job is finished
                //jw.Watch(JobNumber, RelayServer, RelayPort, IsSSL);
                jw.Watch(strJobNumber, "codesign.gtm.microsoft.com", 9556, true);

                if (jw.IsDone)
                {
                    // Now we're done, so display any errors or warnings (in case we are in non-event mode)
                    Log.WriteLog("Job is finished, Success={0}  Signed={1}  BytesSigned={2}", jw.IsSuccess, jw.TotalSigned, jw.TotalByteSize);
                    if (!jw.IsSuccess)
                    {
                        ret = -1;
                    }
                    if (jw.IsPartial)
                    {
                        Log.WriteLog("Partial Success: {0}", jw.IsPartial);
                    }
                    //Display errors
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                    //Display failed files
                    foreach (CODESIGN.Submitter.JobFile jf in jw.FailedFileList.Values)
                    {
                        Log.WriteLog("Failed -> " + jf.FileFullPath);
                    }
                }
                else
                {
                    Log.WriteLog("Job {0} is still being processed!", strJobNumber);
                }

            }
            catch (Exception ex)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(ex));
                if (jw != null)
                {
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\CrcStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CrcStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Wraps a source stream and calcaluates a CRC over all bytes that are read or written.
    /// </summary>
    /// <remarks>
    /// The CRC algorithm matches that used in the standard ZIP file format.
    /// </remarks>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
    public class CrcStream : Stream
    {
        private Stream source;
        private uint crc;

        /// <summary>
        /// Creates a new CrcStream instance from a source stream.
        /// </summary>
        /// <param name="source">Underlying stream where bytes will be read from or written to.</param>
        public CrcStream(Stream source)
        {
            this.source = source;
        }

        /// <summary>
        /// Gets the current CRC over all bytes that have been read or written
        /// since this instance was created.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
        [CLSCompliant(false)]
        public uint Crc
        {
            get
            {
                return this.crc;
            }
        }

        /// <summary>
        /// Gets the underlying stream that this stream reads from or writes to.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.source.Position;
            }

            set
            {
                this.source.Position = value;
            }
        }

        /// <summary>
        /// Sets the position within the source stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the source stream.</returns>
        /// <remarks>
        /// Note the CRC is only calculated over bytes that are actually read or
        /// written, so any bytes skipped by seeking will not contribute to the CRC.
        /// </remarks>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset, origin);
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the
        /// stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value);
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            count = this.source.Read(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
            return count;
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
            base.Close();
        }

        /// <summary>
        /// Updates the CRC with a range of bytes that were read or written.
        /// </summary>
        private void UpdateCrc(byte[] buffer, int offset, int count)
        {
            this.crc = ~this.crc;
            for( ; count > 0; count--, offset++)
            {
                this.crc = (this.crc >> 8) ^
                    CrcStream.crcTable[(this.crc  & 0xFF) ^ buffer[offset]];
            }
            this.crc = ~this.crc;
        }

        private static uint[] crcTable = MakeCrcTable();

        /// <summary>
        /// Computes a table that speeds up calculation of the CRC.
        /// </summary>
        private static uint[] MakeCrcTable()
        {
            const uint poly = 0x04C11DB7u;
            uint[] crcTable = new uint[256];
            for(uint n = 0; n < 256; n++)
            {
                uint c = CrcStream.Reflect(n, 8);
                c = c << 24;
                for(uint k = 0; k < 8; k++)
                {
                    c = (c << 1) ^ ((c & 0x80000000u) != 0 ? poly : 0);
                }
                crcTable[n] = CrcStream.Reflect(c, 32);
            }
            return crcTable;
        }

        /// <summary>
        /// Reflects the ordering of certain number of bits. For exmample when reflecting
        /// one byte, bit one is swapped with bit eight, bit two with bit seven, etc.
        /// </summary>
        private static uint Reflect(uint value, int bits)
        {
            for (int i = 0; i < bits / 2; i++)
            {
                uint leftBit = 1u << (bits - 1 - i);
                uint rightBit = 1u << i;
                if (((value & leftBit) != 0) != ((value & rightBit) != 0))
                {
                    value ^= leftBit | rightBit;
                }
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Log.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public static class Log
    {
        private static bool quiet;
        private static bool exceptionCaught;
        private static string logFileName;

        static Log()
        {
            try
            {
                logFileName = Path.Combine(Directory.GetCurrentDirectory(), @"log.txt");
                StreamWriter SW;
                SW = File.CreateText(logFileName);
                SW.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
        public static bool ExceptionCaught
        {
            get { return exceptionCaught; }
            set { exceptionCaught = value; }
        }

        public static bool Quiet
        {
            get { return quiet; }
            set { quiet = value; }
        }

        public static void WriteLog(string line)
        {
            if (!quiet)
            {
                Console.WriteLine(line);

                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + line);
                SW.Close();
            }
        }

        public static void WriteLog(string format, object arg0)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg0);

                string str = string.Format(format, arg0);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();

            }
        }
        public static void WriteLog(string format, params object[] arg)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg);
                string str = string.Format(format, arg);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Manifest.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Manifest.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------

namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Xml;

    public class Manifest
    {
        private string cabFolder;
        private long installSize;
        private string linkURL;
        private string titleId;

        public Manifest()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        public string CabFolder
        {
            get { return this.cabFolder; }
            set { this.cabFolder = value; }
        }

        public long InstallSize
        {
            get { return this.installSize; }
            set { this.installSize = value; }
        }

        public string LinkURL
        {
            get { return this.linkURL; }
            set { this.linkURL = value; }
        }

        public string TitleId
        {
            get { return this.titleId; }
            set { this.titleId = value; }
        }

        public void NewFile()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public string SaveFile(string outputPath)
        {
            XmlDocument doc = new XmlDocument();

            XmlNode node = doc.CreateNode(XmlNodeType.XmlDeclaration, "OfferManifest", null);
            XmlDeclaration decl = (XmlDeclaration)node;
            decl.Encoding = @"utf-8";
            doc.AppendChild(node);

            XmlNode root = doc.CreateNode(XmlNodeType.Element, "OfferManifest", null);
            XmlAttribute titleIDAtt = doc.CreateAttribute("TitleId");
            titleIDAtt.Value = this.titleId;
            root.Attributes.Append(titleIDAtt);
            doc.AppendChild(root);

            XmlNode itemsNode = doc.CreateNode(XmlNodeType.Element, "Items", null);
            XmlAttribute installSizeAtt = doc.CreateAttribute("InstallSize");
            installSizeAtt.Value = this.installSize.ToString();
            itemsNode.Attributes.Append(installSizeAtt);
            root.AppendChild(itemsNode);


            foreach (string fileName in Directory.GetFiles(cabFolder))
            {
                XmlNode fileNode = doc.CreateNode(XmlNodeType.Element, "Item", null);
                XmlAttribute idAtt = doc.CreateAttribute("ID");
                idAtt.Value = Path.GetFileName(fileName);
                fileNode.Attributes.Append(idAtt);

                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(fileName);
                XmlAttribute sizeAtt = doc.CreateAttribute("DownloadSize");
                sizeAtt.Value = info.Length.ToString();
                fileNode.Attributes.Append(sizeAtt);
                itemsNode.AppendChild(fileNode);

                XmlNode linkNode = doc.CreateNode(XmlNodeType.Element, "Link", null);
                XmlAttribute urlAtt = doc.CreateAttribute("Url");

                Uri urlBase = new Uri(this.linkURL);
                if( this.linkURL.EndsWith("\\") || this.linkURL.EndsWith("/"))
                {
                    urlAtt.Value = this.linkURL + Path.GetFileName(fileName);
                }
                else
                {
                    if (this.linkURL.Contains("://"))
                    {
                        urlAtt.Value = this.linkURL + "/" + Path.GetFileName(fileName);
                    }
                    else
                    {
                        Log.WriteLog("File: " + Path.GetFileName(fileName));
                        urlAtt.Value = Path.Combine(this.linkURL, Path.GetFileName(fileName));
                    }
                }
                Log.WriteLog("FileURL: " + urlAtt.Value);
                linkNode.Attributes.Append(urlAtt);
                fileNode.AppendChild(linkNode);
            }

            doc.Save(outputPath);
            if (!File.Exists(outputPath))
            {
                throw new FileNotFoundException();
            }

            return "Saved manifest file at " + outputPath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a zip file on disk; provides access to
    /// file-based operations on the zip file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="ZipEngine"/> class.
    /// </remarks>
    [Serializable]
    public class ZipInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a zip file in a specified path.
        /// </summary>
        /// <param name="path">The path to the zip file. When creating a zip file, this file does not
        /// necessarily exist yet.</param>
        public ZipInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="ZipEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new ZipEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a zip package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class ZipFileInfo : ArchiveFileInfo
    {
        private long compressedLength;
        private ZipCompressionMethod compressionMethod;

        /// <summary>
        /// Creates a new ZipFileInfo object representing a file within a zip in a specified path.
        /// </summary>
        /// <param name="zipInfo">An object representing the zip archive containing the file.</param>
        /// <param name="filePath">The path to the file within the zip archive. Usually, this is a simple file
        /// name, but if the zip archive contains a directory structure this may include the directory.</param>
        public ZipFileInfo(ZipInfo zipInfo, string filePath)
            : base(zipInfo, filePath)
        {
            if (zipInfo == null)
            {
                throw new ArgumentNullException("zipInfo");
            }
        }

        /// <summary>
        /// Creates a new ZipFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a zip archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the zip archive.</param>
        /// <param name="zipNumber">The zip archive number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        /// <param name="compressedLength">The compressed size of the file.</param>
        /// <param name="compressionMethod">Compression algorithm used for this file.</param>
        internal ZipFileInfo(
            string filePath,
            int zipNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length,
            long compressedLength,
            ZipCompressionMethod compressionMethod)
            : base(filePath, zipNumber, attributes, lastWriteTime, length)
        {
            this.compressedLength = compressedLength;
            this.compressionMethod = compressionMethod;
        }

        /// <summary>
        /// Initializes a new instance of the ZipFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.compressedLength = info.GetInt64("compressedLength");
        }

        /// <summary>
        /// Gets the compressed size of the file in bytes.
        /// </summary>
        public long CompressedLength
        {
            get
            {
                return this.compressedLength;
            }
        }

        /// <summary>
        /// Gets the method used to compress this file.
        /// </summary>
        public ZipCompressionMethod CompressionMethod
        {
            get
            {
                return this.compressionMethod;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("compressedLength", this.compressedLength);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\ArchiveException.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;

    /// <summary>
    /// Base exception class for compression operations. Compression libraries should
    /// derive subclass exceptions with more specific error information relevent to the
    /// file format.
    /// </summary>
    [Serializable]
    public class ArchiveException : IOException
    {
        /// <summary>
        /// Creates a new ArchiveException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ArchiveException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ArchiveException(string message)
            : this(message, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException.
        /// </summary>
        public ArchiveException()
            : this(null, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ArchiveException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipFormat.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFormat.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;

    [Flags]
    internal enum ZipFileFlags : ushort
    {
        None            = 0x0000,
        Encrypt         = 0x0001,
        CompressOption1 = 0x0002,
        CompressOption2 = 0x0004,
        DataDescriptor  = 0x0008,
        StrongEncrypt   = 0x0040,
        UTF8            = 0x0800
    }

    internal enum ZipExtraFileFieldType : ushort
    {
        ZIP64 = 0x0001,
        NTFS_TIMES = 0x000A,
        NTFS_ACLS = 0x4453,
        EXTIME = 0x5455
    }

    internal class ZipFileHeader
    {
        public const uint LFHSIG = 0x04034B50;
        public const uint CFHSIG = 0x02014B50;

        public const uint SPANSIG  = 0x08074b50;
        public const uint SPANSIG2 = 0x30304b50;
        
        public const uint LFH_FIXEDSIZE = 30;
        public const uint CFH_FIXEDSIZE = 46;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public ZipFileFlags flags;
        public ZipCompressionMethod compressionMethod;
        public short lastModTime;
        public short lastModDate;
        public uint crc32;
        public uint compressedSize;
        public uint uncompressedSize;
        public ushort diskStart;
        public ushort internalFileAttrs;
        public uint externalFileAttrs;
        public uint localHeaderOffset;
        public string fileName;
        public ZipExtraFileField[] extraFields;
        public string fileComment;
        public bool zip64;

        public ZipFileHeader()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public ZipFileHeader(ZipFileInfo fileInfo, bool zip64)
            : this()
        {
            this.flags = ZipFileFlags.None;
            this.compressionMethod = fileInfo.CompressionMethod;
            this.fileName = Path.Combine(fileInfo.Path, fileInfo.Name);
            CompressionEngine.DateTimeToDosDateAndTime(
                fileInfo.LastWriteTime, out this.lastModDate, out this.lastModTime);
            this.zip64 = zip64;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;
                this.versionMadeBy = 45;
                this.versionNeeded = 45;
                ZipExtraFileField field = new ZipExtraFileField();
                field.fieldType = ZipExtraFileFieldType.ZIP64;
                field.SetZip64Data(
                    fileInfo.CompressedLength,
                    fileInfo.Length,
                    0,
                    fileInfo.ArchiveNumber);
                this.extraFields = new ZipExtraFileField[] { field };
            }
            else
            {
                this.compressedSize = (uint) fileInfo.CompressedLength;
                this.uncompressedSize = (uint) fileInfo.Length;
                this.diskStart = (ushort) fileInfo.ArchiveNumber;
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void Update(
            long compressedSize,
            long uncompressedSize,
            uint crc32,
            long localHeaderOffset,
            int archiveNumber)
        {
            this.crc32 = crc32;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.localHeaderOffset = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;

                if (this.extraFields != null)
                {
                    foreach (ZipExtraFileField field in this.extraFields)
                    {
                        if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                        {
                            field.SetZip64Data(
                                compressedSize,
                                uncompressedSize,
                                localHeaderOffset,
                                archiveNumber);
                        }
                    }
                }
            }
            else
            {
                this.compressedSize = (uint) compressedSize;
                this.uncompressedSize = (uint) uncompressedSize;
                this.localHeaderOffset = (uint) localHeaderOffset;
                this.diskStart = (ushort) archiveNumber;
            }
        }

        public bool Read(Stream stream, bool central)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos <
                (central ? CFH_FIXEDSIZE : LFH_FIXEDSIZE))
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig == SPANSIG || sig == SPANSIG2)
            {
                // Spanned zip files may optionally begin with a special marker.
                // Just ignore it and move on.
                sig = reader.ReadUInt32();
            }

            if (sig != (central ? CFHSIG : LFHSIG))
            {
                return false;
            }

            this.versionMadeBy = (central ? reader.ReadUInt16() : (ushort) 0);
            this.versionNeeded = reader.ReadUInt16();
            this.flags = (ZipFileFlags) reader.ReadUInt16();
            this.compressionMethod = (ZipCompressionMethod) reader.ReadUInt16();
            this.lastModTime = reader.ReadInt16();
            this.lastModDate = reader.ReadInt16();
            this.crc32 = reader.ReadUInt32();
            this.compressedSize = reader.ReadUInt32();
            this.uncompressedSize = reader.ReadUInt32();
            
            this.zip64 = this.uncompressedSize == UInt32.MaxValue;

            int fileNameLength = reader.ReadUInt16();
            int extraFieldLength = reader.ReadUInt16();
            int fileCommentLength;

            if (central)
            {
                fileCommentLength = reader.ReadUInt16();

                this.diskStart = reader.ReadUInt16();
                this.internalFileAttrs = reader.ReadUInt16();
                this.externalFileAttrs = reader.ReadUInt32();
                this.localHeaderOffset = reader.ReadUInt32();
            }
            else
            {
                fileCommentLength = 0;
                this.diskStart = 0;
                this.internalFileAttrs = 0;
                this.externalFileAttrs = 0;
                this.localHeaderOffset = 0;
            }

            if (stream.Length - stream.Position <
                fileNameLength + extraFieldLength + fileCommentLength)
            {
                return false;
            }

            Encoding headerEncoding = ((this.flags | ZipFileFlags.UTF8) != 0 ?
                Encoding.UTF8 : Encoding.GetEncoding(CultureInfo.CurrentCulture.TextInfo.OEMCodePage));

            byte[] fileNameBytes = reader.ReadBytes(fileNameLength);
            this.fileName = headerEncoding.GetString(fileNameBytes);

            List<ZipExtraFileField> fields = new List<ZipExtraFileField>();
            while (extraFieldLength > 0)
            {
                ZipExtraFileField field = new ZipExtraFileField();
                if (!field.Read(stream, ref extraFieldLength))
                {
                    return false;
                }
                fields.Add(field);
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    this.zip64 = true;
                }
            }
            this.extraFields = fields.ToArray();

            byte[] fileCommentBytes = reader.ReadBytes(fileCommentLength);
            this.fileComment = headerEncoding.GetString(fileCommentBytes);

            return true;
        }

        public void Write(Stream stream, bool central)
        {
            byte[] fileNameBytes = (this.fileName != null
                ? Encoding.UTF8.GetBytes(this.fileName) : new byte[0]);
            byte[] fileCommentBytes = (this.fileComment != null
                ? Encoding.UTF8.GetBytes(this.fileComment) : new byte[0]);
            bool useUtf8 =
                (this.fileName != null && fileNameBytes.Length > this.fileName.Length) ||
                (this.fileComment != null && fileCommentBytes.Length > this.fileComment.Length);
            if (useUtf8)
            {
                this.flags |= ZipFileFlags.UTF8;
            }

            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(central ? CFHSIG : LFHSIG);
            if (central)
            {
                writer.Write(this.versionMadeBy);
            }
            writer.Write(this.versionNeeded);
            writer.Write((ushort) this.flags);
            writer.Write((ushort) this.compressionMethod);
            writer.Write(this.lastModTime);
            writer.Write(this.lastModDate);
            writer.Write(this.crc32);
            writer.Write(this.compressedSize);
            writer.Write(this.uncompressedSize);
            
            ushort extraFieldLength = 0;
            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        extraFieldLength += (ushort) (4 + field.data.Length);
                    }
                }
            }

            writer.Write((ushort) fileNameBytes.Length);
            writer.Write(extraFieldLength);

            if (central)
            {
                writer.Write((ushort) fileCommentBytes.Length);

                writer.Write(this.diskStart);
                writer.Write(this.internalFileAttrs);
                writer.Write(this.externalFileAttrs);
                writer.Write(this.localHeaderOffset);
            }

            writer.Write(fileNameBytes);

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        field.Write(stream);
                    }
                }
            }

            if (central)
            {
                writer.Write(fileCommentBytes);
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void GetZip64Fields(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int archiveNumber,
            out uint crc)
        {
            compressedSize = this.compressedSize;
            uncompressedSize = this.uncompressedSize;
            localHeaderOffset = this.localHeaderOffset;
            archiveNumber = this.diskStart;
            crc = this.crc32;

            foreach (ZipExtraFileField field in this.extraFields)
            {
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    field.GetZip64Data(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber);
                }
            }
        }

        public ZipFileInfo ToZipFileInfo()
        {
            string name = this.fileName;
            
            long compressedSizeL;
            long uncompressedSizeL;
            long localHeaderOffsetL;
            int archiveNumberL;
            uint crc;
            this.GetZip64Fields(
                out compressedSizeL,
                out uncompressedSizeL,
                out localHeaderOffsetL,
                out archiveNumberL,
                out crc);

            DateTime dateTime;
            CompressionEngine.DosDateAndTimeToDateTime(
                this.lastModDate,
                this.lastModTime,
                out dateTime);
            FileAttributes attrs = FileAttributes.Normal;
            // TODO: look for attrs or times in extra fields

            return new ZipFileInfo(name, archiveNumberL, attrs, dateTime,
                uncompressedSizeL, compressedSizeL, this.compressionMethod);
        }

        public bool IsDirectory
        {
            get
            {
                return this.fileName != null &&
                    (this.fileName.EndsWith("/", StringComparison.Ordinal) ||
                    this.fileName.EndsWith("\\", StringComparison.Ordinal));
            }
        }

        public int GetSize(bool central)
        {
            int size = 30;

            int fileNameSize = (this.fileName != null
                ? Encoding.UTF8.GetByteCount(this.fileName) : 0);
            size += fileNameSize;

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        size += 4 + field.data.Length;
                    }
                }
            }

            if (central)
            {
                size += 16;

                int fileCommentSize = (this.fileComment != null
                    ? Encoding.UTF8.GetByteCount(this.fileComment) : 0);
                size += fileCommentSize;
            }

            return size;
        }
    }

    internal class ZipExtraFileField
    {
        public ZipExtraFileFieldType fieldType;
        public byte[] data;

        public bool Read(Stream stream, ref int bytesRemaining)
        {
            if (bytesRemaining < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);

            this.fieldType = (ZipExtraFileFieldType) reader.ReadUInt16();
            ushort dataSize = reader.ReadUInt16();
            bytesRemaining -= 4;

            if (bytesRemaining < dataSize)
            {
                return false;
            }

            this.data = reader.ReadBytes(dataSize);
            bytesRemaining -= dataSize;

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write((ushort) this.fieldType);

            byte[] dataBytes = (this.data != null ? this.data : new byte[0]);
            writer.Write((ushort) dataBytes.Length);
            writer.Write(dataBytes);
        }

        public bool GetZip64Data(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int diskStart)
        {
            uncompressedSize = 0;
            compressedSize = 0;
            localHeaderOffset = 0;
            diskStart = 0;

            if (this.fieldType != ZipExtraFileFieldType.ZIP64 ||
                this.data == null || this.data.Length != 28)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream(this.data))
            {
                BinaryReader reader = new BinaryReader(dataStream);
                uncompressedSize = reader.ReadInt64();
                compressedSize = reader.ReadInt64();
                localHeaderOffset = reader.ReadInt64();
                diskStart = reader.ReadInt32();
            }

            return true;
        }

        public bool SetZip64Data(
            long compressedSize,
            long uncompressedSize,
            long localHeaderOffset,
            int diskStart)
        {
            if (this.fieldType != ZipExtraFileFieldType.ZIP64)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream())
            {
                BinaryWriter writer = new BinaryWriter(dataStream);
                writer.Write(uncompressedSize);
                writer.Write(compressedSize);
                writer.Write(localHeaderOffset);
                writer.Write(diskStart);
                this.data = dataStream.ToArray();
            }

            return true;
        }
    }

    internal class ZipEndOfCentralDirectory
    {
        public const uint EOCDSIG = 0x06054B50;
        public const uint EOCD64SIG = 0x06064B50;

        public const uint EOCD_RECORD_FIXEDSIZE = 22;
        public const uint EOCD64_RECORD_FIXEDSIZE = 56;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public uint diskNumber;
        public uint dirStartDiskNumber;
        public long entriesOnDisk;
        public long totalEntries;
        public long dirSize;
        public long dirOffset;
        public string comment;
        public bool zip64;

        public ZipEndOfCentralDirectory()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos < EOCD_RECORD_FIXEDSIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            this.zip64 = false;
            if (sig != EOCDSIG)
            {
                if (sig == EOCD64SIG)
                {
                    this.zip64 = true;
                }
                else
                {
                    return false;
                }
            }

            if (this.zip64)
            {
                if (stream.Length - startPos < EOCD64_RECORD_FIXEDSIZE)
                {
                    return false;
                }

                long recordSize = reader.ReadInt64();
                this.versionMadeBy = reader.ReadUInt16();
                this.versionNeeded = reader.ReadUInt16();
                this.diskNumber = reader.ReadUInt32();
                this.dirStartDiskNumber = reader.ReadUInt32();
                this.entriesOnDisk = reader.ReadInt64();
                this.totalEntries = reader.ReadInt64();
                this.dirSize = reader.ReadInt64();
                this.dirOffset = reader.ReadInt64();

                // Ignore any extended zip64 eocd data.
                long exDataSize = recordSize + 12 - EOCD64_RECORD_FIXEDSIZE;

                if (stream.Length - stream.Position < exDataSize)
                {
                    return false;
                }

                stream.Seek(exDataSize, SeekOrigin.Current);

                this.comment = null;
            }
            else
            {
                this.diskNumber = reader.ReadUInt16();
                this.dirStartDiskNumber = reader.ReadUInt16();
                this.entriesOnDisk = reader.ReadUInt16();
                this.totalEntries = reader.ReadUInt16();
                this.dirSize = reader.ReadUInt32();
                this.dirOffset = reader.ReadUInt32();

                int commentLength = reader.ReadUInt16();

                if (stream.Length - stream.Position < commentLength)
                {
                    return false;
                }

                byte[] commentBytes = reader.ReadBytes(commentLength);
                this.comment = Encoding.UTF8.GetString(commentBytes);
            }

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);

            if (this.zip64)
            {
                writer.Write(EOCD64SIG);
                writer.Write((long) EOCD64_RECORD_FIXEDSIZE);
                writer.Write(this.versionMadeBy);
                writer.Write(this.versionNeeded);
                writer.Write(this.diskNumber);
                writer.Write(this.dirStartDiskNumber);
                writer.Write(this.entriesOnDisk);
                writer.Write(this.totalEntries);
                writer.Write(this.dirSize);
                writer.Write(this.dirOffset);
            }
            else
            {
                writer.Write(EOCDSIG);
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.diskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.dirStartDiskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.entriesOnDisk));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.totalEntries));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirSize));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirOffset));

                byte[] commentBytes = (this.comment != null
                    ? Encoding.UTF8.GetBytes(this.comment) : new byte[0]);
                writer.Write((ushort) commentBytes.Length);
                writer.Write(commentBytes);
            }
        }

        public int GetSize(bool zip64Size)
        {
            if (zip64Size)
            {
                return 56;
            }
            else
            {
                int commentSize = (this.comment != null
                    ? Encoding.UTF8.GetByteCount(this.comment) : 0);
                return 22 + commentSize;
            }
        }
    }

    internal class Zip64EndOfCentralDirectoryLocator
    {
        public const uint EOCDL64SIG = 0x07064B50;

        public const uint EOCDL64_SIZE = 20;

        public uint dirStartDiskNumber;
        public long dirOffset;
        public uint totalDisks;

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;
            if (stream.Length - startPos < EOCDL64_SIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig != EOCDL64SIG)
            {
                return false;
            }

            this.dirStartDiskNumber = reader.ReadUInt32();
            this.dirOffset = reader.ReadInt64();
            this.totalDisks = reader.ReadUInt32();

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(EOCDL64SIG);
            writer.Write(this.dirStartDiskNumber);
            writer.Write(this.dirOffset);
            writer.Write(this.totalDisks);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipPacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Globalization;

    public partial class ZipEngine
    {
        /// <summary>
        /// Creates a zip archive or chain of zip archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">An array of file lists.  Each list is
        /// compressed into one stream in the archive.</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one archive
        /// before the contents are chained to the next archive, or zero for unlimited
        /// archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                Stream archiveStream = null;
                try
                {
                    this.ResetProgressData();
                    this.totalArchives = 1;

                    object forceZip64Value = streamContext.GetOption("forceZip64", null);
                    bool forceZip64 = Convert.ToBoolean(
                        forceZip64Value, CultureInfo.InvariantCulture);

                    // Count the total number of files and bytes to be compressed.
                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = streamContext.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            streamContext.CloseFileReadStream(file, fileStream);
                        }
                    }

                    List<ZipFileHeader> fileHeaders = new List<ZipFileHeader>();
                    this.currentFileNumber = -1;

                    if (this.currentArchiveName == null)
                    {
                        this.mainArchiveName = streamContext.GetArchiveName(0);
                        this.currentArchiveName = this.mainArchiveName;

                        if (String.IsNullOrEmpty(this.currentArchiveName))
                        {
                            throw new FileNotFoundException("No name provided for archive.");
                        }
                    }

                    this.OnProgress(ArchiveProgressType.StartArchive);

                    // Compress files one by one, saving header info for each.
                    foreach (string file in files)
                    {
                        ZipFileHeader fileHeader = this.PackOneFile(
                                streamContext,
                                file,
                                maxArchiveSize,
                                forceZip64,
                                ref archiveStream);

                        if (fileHeader != null)
                        {
                            fileHeaders.Add(fileHeader);
                        }

                        this.currentArchiveTotalBytes = (archiveStream != null ?
                            archiveStream.Position : 0);
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }

                    // Write the central directory composed of all the file headers.
                    bool zip64 = forceZip64;
                    uint centralDirStartArchiveNumber = 0;
                    long centralDirStartPosition = 0;
                    long centralDirSize = 0;
                    for (int i = 0; i < fileHeaders.Count; i++)
                    {
                        ZipFileHeader fileHeader = fileHeaders[i];

                        int headerSize = fileHeader.GetSize(true);
                        centralDirSize += headerSize;

                        this.CheckArchiveWriteStream(
                            streamContext,
                            maxArchiveSize,
                            headerSize,
                            ref archiveStream);

                        if (i == 0)
                        {
                            centralDirStartArchiveNumber = (uint) this.currentArchiveNumber;
                            centralDirStartPosition = archiveStream.Position;
                        }

                        fileHeader.Write(archiveStream, true);
                        if (fileHeader.zip64)
                        {
                            zip64 = true;
                        }
                    }

                    this.currentArchiveTotalBytes =
                        (archiveStream != null ? archiveStream.Position : 0);
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
                    eocd.dirStartDiskNumber = centralDirStartArchiveNumber;
                    eocd.entriesOnDisk = fileHeaders.Count;
                    eocd.totalEntries = fileHeaders.Count;
                    eocd.dirSize = centralDirSize;
                    eocd.dirOffset = centralDirStartPosition;
                    eocd.comment = this.comment;

                    Zip64EndOfCentralDirectoryLocator eocdl =
                        new Zip64EndOfCentralDirectoryLocator();

                    int maxFooterSize = eocd.GetSize(false);
                    if (archiveStream != null && (zip64 || archiveStream.Position >
                        ((long) UInt32.MaxValue) - eocd.GetSize(false)))
                    {
                        maxFooterSize += eocd.GetSize(true) + (int)
                            Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE;
                        zip64 = true;
                    }

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        maxFooterSize,
                        ref archiveStream);
                    eocd.diskNumber = (uint) this.currentArchiveNumber;

                    if (zip64)
                    {
                        eocd.versionMadeBy = 45;
                        eocd.versionNeeded = 45;
                        eocd.zip64 = true;
                        eocdl.dirOffset = archiveStream.Position;
                        eocdl.dirStartDiskNumber = (uint) this.currentArchiveNumber;
                        eocdl.totalDisks = (uint) this.currentArchiveNumber + 1;
                        eocd.Write(archiveStream);
                        eocdl.Write(archiveStream);

                        if (forceZip64)
                        {
                            eocd.dirOffset = UInt32.MaxValue;
                            eocd.dirStartDiskNumber = UInt16.MaxValue;
                        }
                    }

                    eocd.zip64 = false;
                    eocd.Write(archiveStream);

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveWriteStream(
                            this.currentArchiveNumber, this.mainArchiveName, archiveStream);
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Moves to the next archive in the sequence if necessary.
        /// </summary>
        private void CheckArchiveWriteStream(
            IPackStreamContext streamContext,
            long maxArchiveSize,
            long requiredSize,
            ref Stream archiveStream)
        {
            if (archiveStream != null &&
                archiveStream.Length > 0 && maxArchiveSize > 0)
            {
                long sizeRemaining = maxArchiveSize - archiveStream.Length;
                if (sizeRemaining < requiredSize)
                {
                    string nextArchiveName = streamContext.GetArchiveName(
                        this.currentArchiveNumber + 1);

                    if (String.IsNullOrEmpty(nextArchiveName))
                    {
                        throw new FileNotFoundException("No name provided for archive #" +
                            this.currentArchiveNumber + 1);
                    }

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    streamContext.CloseArchiveWriteStream(
                        this.currentArchiveNumber,
                        nextArchiveName,
                        archiveStream);
                    archiveStream = null;

                    this.OnProgress(ArchiveProgressType.FinishArchive);

                    this.currentArchiveNumber++;
                    this.totalArchives++;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;
                }
            }

            if (archiveStream == null)
            {
                if (this.currentArchiveNumber > 0)
                {
                    this.OnProgress(ArchiveProgressType.StartArchive);
                }

                archiveStream = streamContext.OpenArchiveWriteStream(
                    this.currentArchiveNumber, this.mainArchiveName, true, this);

                if (archiveStream == null)
                {
                    throw new FileNotFoundException("Stream not provided for archive #" +
                        this.currentArchiveNumber);
                }
            }
        }

        /// <summary>
        /// Adds one file to a zip archive in the process of being created.
        /// </summary>
        private ZipFileHeader PackOneFile(
            IPackStreamContext streamContext,
            string file,
            long maxArchiveSize,
            bool forceZip64,
            ref Stream archiveStream)
        {
            Stream fileStream = null;
            int headerArchiveNumber = 0;
            try
            {
                // TODO: call GetOption to get compression method for the specific file
                ZipCompressionMethod compressionMethod = ZipCompressionMethod.Deflate;
                if (this.CompressionLevel == CompressionLevel.None)
                {
                    compressionMethod = ZipCompressionMethod.Store;
                }

                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.compressionStreamCreators.TryGetValue(
                    compressionMethod, out compressionStreamCreator))
                {
                    return null;
                }

                FileAttributes attributes;
                DateTime lastWriteTime;
                fileStream = streamContext.OpenFileReadStream(
                    file, out attributes, out lastWriteTime);
                if (fileStream == null)
                {
                    return null;
                }

                this.currentFileName = file;
                this.currentFileNumber++;

                this.currentFileTotalBytes = fileStream.Length;
                this.currentFileBytesProcessed = 0;
                this.OnProgress(ArchiveProgressType.StartFile);

                ZipFileInfo fileInfo = new ZipFileInfo(
                    file,
                    this.currentArchiveNumber,
                    attributes,
                    lastWriteTime,
                    fileStream.Length,
                    0,
                    compressionMethod);

                bool zip64 = forceZip64 || fileStream.Length >= (long) UInt32.MaxValue;
                ZipFileHeader fileHeader = new ZipFileHeader(fileInfo, zip64);

                this.CheckArchiveWriteStream(
                    streamContext,
                    maxArchiveSize,
                    fileHeader.GetSize(false),
                    ref archiveStream);

                long headerPosition = archiveStream.Position;
                fileHeader.Write(archiveStream, false);
                headerArchiveNumber = this.currentArchiveNumber;

                uint crc;
                long bytesWritten = this.PackFileBytes(
                    streamContext,
                    fileStream,
                    maxArchiveSize,
                    compressionStreamCreator,
                    ref archiveStream,
                    out crc);

                fileHeader.Update(
                    bytesWritten,
                    fileStream.Length,
                    crc,
                    headerPosition,
                    headerArchiveNumber);

                streamContext.CloseFileReadStream(file, fileStream);
                fileStream = null;

                // Go back and rewrite the updated file header.
                if (this.currentArchiveNumber == headerArchiveNumber)
                {
                    long fileEndPosition = archiveStream.Position;
                    archiveStream.Seek(headerPosition, SeekOrigin.Begin);
                    fileHeader.Write(archiveStream, false);
                    archiveStream.Seek(fileEndPosition, SeekOrigin.Begin);
                }
                else
                {
                    // The file spanned archives, so temporarily reopen
                    // the archive where it started.
                    string headerArchiveName = streamContext.GetArchiveName(
                        headerArchiveNumber + 1);
                    Stream headerStream = null;
                    try
                    {
                        headerStream = streamContext.OpenArchiveWriteStream(
                            headerArchiveNumber, headerArchiveName, false, this);
                        headerStream.Seek(headerPosition, SeekOrigin.Begin);
                        fileHeader.Write(headerStream, false);
                    }
                    finally
                    {
                        if (headerStream != null)
                        {
                            streamContext.CloseArchiveWriteStream(
                                headerArchiveNumber, headerArchiveName, headerStream);
                        }
                    }
                }

                this.OnProgress(ArchiveProgressType.FinishFile);

                return fileHeader;
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileReadStream(
                        this.currentFileName, fileStream);
                }
            }
        }

        /// <summary>
        /// Writes compressed bytes of one file to the archive,
        /// keeping track of the CRC and number of bytes written.
        /// </summary>
        private long PackFileBytes(
            IPackStreamContext streamContext,
            Stream fileStream,
            long maxArchiveSize,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream,
            out uint crc)
        {
            long writeStartPosition = archiveStream.Position;
            long bytesWritten = 0;
            CrcStream fileCrcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    Stream sourceStream = s.Source;
                    bytesWritten += sourceStream.Position - writeStartPosition;

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        1,
                        ref sourceStream);

                    writeStartPosition = sourceStream.Position;
                    s.Source = sourceStream;
                });

            concatStream.Source = archiveStream;

            if (maxArchiveSize > 0)
            {
                concatStream.SetLength(maxArchiveSize);
            }

            Stream compressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = fileStream.Length;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(
                        bytesRemaining, (long) buf.Length);

                    count = fileCrcStream.Read(buf, 0, count);
                    if (count <= 0)
                    {
                        throw new ZipException(
                            "Failed to read file: " + this.currentFileName);
                    }

                    compressionStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveTotalBytes = concatStream.Source.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                }

                if (compressionStream is DeflateStream)
                {
                    compressionStream.Close();
                }
                else
                {
                    compressionStream.Flush();
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            bytesWritten += archiveStream.Position - writeStartPosition;

            crc = fileCrcStream.Crc;

            return bytesWritten;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Compression.Zip\ZipUnpacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;

    public partial class ZipEngine
    {
        /// <summary>
        /// Extracts files from a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> allHeaders = this.GetCentralDirectory(streamContext);
                if (allHeaders == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                IList<ZipFileHeader> headers = new List<ZipFileHeader>(allHeaders.Count);
                foreach (ZipFileHeader header in allHeaders)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        headers.Add(header);
                    }
                }

                this.ResetProgressData();

                // Count the total number of files and bytes to be compressed.
                this.totalFiles = headers.Count;
                foreach (ZipFileHeader header in headers)
                {
                    long compressedSize;
                    long uncompressedSize;
                    long localHeaderOffset;
                    int archiveNumber;
                    uint crc;
                    header.GetZip64Fields(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber,
                        out crc);

                    this.totalFileBytes += uncompressedSize;
                    if (archiveNumber >= this.totalArchives)
                    {
                        this.totalArchives = (short) (archiveNumber + 1);
                    }
                }

                this.currentArchiveNumber = -1;
                this.currentFileNumber = -1;
                Stream archiveStream = null;
                try
                {
                    foreach (ZipFileHeader header in headers)
                    {
                        this.currentFileNumber++;
                        this.UnpackOneFile(streamContext, header, ref archiveStream);
                    }
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            0, String.Empty, archiveStream);
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Unpacks a single file from an archive or archive chain.
        /// </summary>
        private void UnpackOneFile(
            IUnpackStreamContext streamContext,
            ZipFileHeader header,
            ref Stream archiveStream)
        {
            ZipFileInfo fileInfo = null;
            Stream fileStream = null;
            try
            {
                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.decompressionStreamCreators.TryGetValue(
                    header.compressionMethod, out compressionStreamCreator))
                {
                    // Silently skip files of an unsupported compression method.
                    return;
                }

                long compressedSize;
                long uncompressedSize;
                long localHeaderOffset;
                int archiveNumber;
                uint crc;
                header.GetZip64Fields(
                    out compressedSize,
                    out uncompressedSize,
                    out localHeaderOffset,
                    out archiveNumber,
                    out crc);

                if (this.currentArchiveNumber != archiveNumber + 1)
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            String.Empty,
                            archiveStream);
                        archiveStream = null;

                        this.OnProgress(ArchiveProgressType.FinishArchive);
                        this.currentArchiveName = null;
                    }

                    this.currentArchiveNumber = (short) (archiveNumber + 1);
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    archiveStream = this.OpenArchive(
                        streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = archiveStream as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = archiveStream.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                }

                archiveStream.Seek(localHeaderOffset, SeekOrigin.Begin);

                ZipFileHeader localHeader = new ZipFileHeader();
                if (!localHeader.Read(archiveStream, false) ||
                    !localHeader.fileName.Equals(header.fileName))
                {
                    string msg = "Could not read file: " + header.fileName;
                    throw new ZipException(msg);
                }

                fileInfo = header.ToZipFileInfo();

                fileStream = streamContext.OpenFileWriteStream(
                    fileInfo.FullName,
                    fileInfo.Length,
                    fileInfo.LastWriteTime);

                if (fileStream != null)
                {
                    this.currentFileName = header.fileName;
                    this.currentFileBytesProcessed = 0;
                    this.currentFileTotalBytes = fileInfo.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartFile);
                    this.currentArchiveNumber++;

                    this.UnpackFileBytes(
                        streamContext,
                        fileInfo.FullName,
                        fileInfo.CompressedLength,
                        fileInfo.Length,
                        header.crc32,
                        fileStream,
                        compressionStreamCreator,
                        ref archiveStream);
                }
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileWriteStream(
                        fileInfo.FullName,
                        fileStream,
                        fileInfo.Attributes,
                        fileInfo.LastWriteTime);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentArchiveNumber++;
                }
            }
        }

        private Stream OpenArchive(IUnpackStreamContext streamContext, int archiveNumber)
        {
            Stream archiveStream = streamContext.OpenArchiveReadStream(
                archiveNumber, String.Empty, this);
            if (archiveStream == null && archiveNumber != 0)
            {
                archiveStream = streamContext.OpenArchiveReadStream(
                    0, String.Empty, this);
            }

            if (archiveStream == null)
            {
                throw new FileNotFoundException("Archive stream not provided.");
            }

            return archiveStream;
        }

        /// <summary>
        /// Decompresses bytes for one file from an archive or archive chain,
        /// checking the crc at the end.
        /// </summary>
        private void UnpackFileBytes(
            IUnpackStreamContext streamContext,
            string fileName,
            long compressedSize,
            long uncompressedSize,
            uint crc,
            Stream fileStream,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream)
        {
            CrcStream crcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    this.currentArchiveBytesProcessed = s.Source.Position;
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber,
                        String.Empty,
                        s.Source);

                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                    this.currentArchiveNumber += 2;
                    this.currentArchiveName = null;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;

                    s.Source = this.OpenArchive(streamContext, this.currentArchiveNumber);

                    FileStream archiveFileStream = s.Source as FileStream;
                    this.currentArchiveName = (archiveFileStream != null ?
                        Path.GetFileName(archiveFileStream.Name) : null);

                    this.currentArchiveTotalBytes = s.Source.Length;
                    this.currentArchiveNumber--;
                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.currentArchiveNumber++;
                });

            concatStream.Source = archiveStream;
            concatStream.SetLength(compressedSize);

            Stream decompressionStream = compressionStreamCreator(concatStream);

            try
            {
                byte[] buf = new byte[4096];
                long bytesRemaining = uncompressedSize;
                int counter = 0;
                while (bytesRemaining > 0)
                {
                    int count = (int) Math.Min(buf.Length, bytesRemaining);
                    count = decompressionStream.Read(buf, 0, count);
                    crcStream.Write(buf, 0, count);
                    bytesRemaining -= count;

                    this.fileBytesProcessed += count;
                    this.currentFileBytesProcessed += count;
                    this.currentArchiveBytesProcessed = concatStream.Source.Position;

                    if (++counter % 16 == 0) // Report every 64K
                    {
                        this.currentArchiveNumber--;
                        this.OnProgress(ArchiveProgressType.PartialFile);
                        this.currentArchiveNumber++;
                    }
                }
            }
            finally
            {
                archiveStream = concatStream.Source;
            }

            crcStream.Flush();

            if (crcStream.Crc != crc)
            {
                throw new ZipException("CRC check failed for file: " + fileName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\ArchiveProgressType.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressType.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// The type of progress event.
    /// </summary>
    /// <remarks>
    /// <p>PACKING EXAMPLE: The following sequence of events might be received when
    /// extracting a simple archive file with 2 files.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartArchive</term> <description>Begin extracting archive</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting first file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting first file</description></item>
    /// <item><term>StartFile</term>    <description>Begin extracting second file</description></item>
    /// <item><term>PartialFile</term>  <description>Extracting second file</description></item>
    /// <item><term>FinishFile</term>   <description>Finished extracting second file</description></item>
    /// <item><term>FinishArchive</term><description>Finished extracting archive</description></item>
    /// </list>
    /// <p></p>
    /// <p>UNPACKING EXAMPLE:  Packing 3 files into 2 archive chunks, where the second file is
    ///	continued to the second archive chunk.</p>
    /// <list type="table">
    /// <listheader><term>Message Type</term><description>Description</description></listheader>
    /// <item><term>StartFile</term>     <description>Begin compressing first file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing first file</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing second file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing second file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing first archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing first archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing first archive</description></item>
    /// <item><term>StartFile</term>     <description>Begin compressing third file</description></item>
    /// <item><term>PartialFile</term>   <description>Compressing third file</description></item>
    /// <item><term>FinishFile</term>    <description>Finished compressing third file</description></item>
    /// <item><term>StartArchive</term>  <description>Begin writing second archive</description></item>
    /// <item><term>PartialArchive</term><description>Writing second archive</description></item>
    /// <item><term>FinishArchive</term> <description>Finished writing second archive</description></item>
    /// </list>
    /// </remarks>
    public enum ArchiveProgressType : int
    {
        /// <summary>Status message before beginning the packing or unpacking an individual file.</summary>
        StartFile,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking a file.</summary>
        PartialFile,

        /// <summary>Status message after completion of the packing or unpacking an individual file.</summary>
        FinishFile,

        /// <summary>Status message before beginning the packing or unpacking an archive.</summary>
        StartArchive,

        /// <summary>Status message (possibly reported multiple times) during the process of packing or unpacking an archiv.</summary>
        PartialArchive,

        /// <summary>Status message after completion of the packing or unpacking of an archive.</summary>
        FinishArchive,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\ArchiveFileStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="ArchiveFileStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Provides a basic implementation of the archive pack and unpack stream context
    /// interfaces, based on a list of archive files, a default directory, and an
    /// optional mapping from internal to external file paths.
    /// </summary>
    /// <remarks>
    /// This class can also handle creating or extracting chained archive packages.
    /// </remarks>
    public class ArchiveFileStreamContext
        : IPackStreamContext, IUnpackStreamContext
    {
        private IList<string> archiveFiles;
        private string directory;
        private IDictionary<string, string> files;
        private bool extractOnlyNewerFiles;
        private bool enableOffsetOpen;

        #region Constructors

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file and
        /// no default directory or file mapping.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        public ArchiveFileStreamContext(string archiveFile)
            : this(archiveFile, null, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a archive file, default
        /// directory and mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFile">The path to a archive file that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are
        /// used, see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            string archiveFile,
            string directory,
            IDictionary<string, string> files)
            : this(new string[] { archiveFile }, directory, files)
        {
            if (archiveFile == null)
            {
                throw new ArgumentNullException("archiveFile");
            }
        }

        /// <summary>
        /// Creates a new ArchiveFileStreamContext with a list of archive files,
        /// a default directory and a mapping from internal to external file paths.
        /// </summary>
        /// <param name="archiveFiles">A list of paths to archive files that will be
        /// created or extracted.</param>
        /// <param name="directory">The default root directory where files will be
        /// located, optional.</param>
        /// <param name="files">A mapping from internal file paths to external file
        /// paths, optional.</param>
        /// <remarks>
        /// When creating chained archives, the <paramref name="archiveFiles"/> list
        /// should include at least enough archives to handle the entire set of
        /// input files, based on the maximum archive size that is passed to the
        /// <see cref="CompressionEngine"/>.<see
        /// cref="CompressionEngine.Pack(IPackStreamContext,IEnumerable&lt;string&gt;,long)"/>.
        /// <para>If the mapping is not null and a file is not included in the mapping,
        /// the file will be skipped.</para>
        /// <para>If the external path in the mapping is a simple file name or
        /// relative file path, it will be concatenated onto the default directory,
        /// if one was specified.</para>
        /// <para>For more about how the default directory and files mapping are used,
        /// see <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.</para>
        /// </remarks>
        public ArchiveFileStreamContext(
            IList<string> archiveFiles,
            string directory,
            IDictionary<string, string> files)
        {
            if (archiveFiles == null || archiveFiles.Count == 0)
            {
                throw new ArgumentNullException("archiveFiles");
            }

            this.archiveFiles = archiveFiles;
            this.directory = directory;
            this.files = files;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the list of archive files that are created or extracted.
        /// </summary>
        /// <value>The list of archive files that are created or extracted.</value>
        public IList<string> ArchiveFiles
        {
            get
            {
                return this.archiveFiles;
            }
        }

        /// <summary>
        /// Gets or sets the default root directory where files are located.
        /// </summary>
        /// <value>The default root directory where files are located.</value>
        /// <remarks>
        /// For details about how the default directory is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public string Directory
        {
            get
            {
                return this.directory;
            }
        }

        /// <summary>
        /// Gets or sets the mapping from internal file paths to external file paths.
        /// </summary>
        /// <value>A mapping from internal file paths to external file paths.</value>
        /// <remarks>
        /// For details about how the files mapping is used,
        /// see <see cref="OpenFileReadStream"/> and <see cref="OpenFileWriteStream"/>.
        /// </remarks>
        public IDictionary<string, string> Files
        {
            get
            {
                return this.files;
            }
        }

        /// <summary>
        /// Gets or sets a flag that can prevent extracted files from overwriting
        /// newer files that already exist.
        /// </summary>
        /// <value>True to prevent overwriting newer files that already exist
        /// during extraction; false to always extract from the archive regardless
        /// of existing files.</value>
        public bool ExtractOnlyNewerFiles
        {
            get
            {
                return this.extractOnlyNewerFiles;
            }

            set
            {
                this.extractOnlyNewerFiles = value;
            }
        }

        /// <summary>
        /// Gets or sets a flag that enables creating or extracting an archive
        /// at an offset within an existing file. (This is typically used to open
        /// archive-based self-extracting packages.)
        /// </summary>
        /// <value>True to search an existing package file for an archive offset
        /// or the end of the file;/ false to always create or open a plain
        /// archive file.</value>
        public bool EnableOffsetOpen
        {
            get
            {
                return this.enableOffsetOpen;
            }

            set
            {
                this.enableOffsetOpen = value;
            }
        }

        #endregion

        #region IPackStreamContext Members

        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>This method returns the file name of the archive from the
        /// <see cref="archiveFiles"/> list with the specified index, or an empty
        /// string if the archive number is outside the bounds of the list. The
        /// file name should not include any directory path.</remarks>
        public virtual string GetArchiveName(int archiveNumber)
        {
            if (archiveNumber < this.archiveFiles.Count)
            {
                return Path.GetFileName(this.archiveFiles[archiveNumber]);
            }

            return String.Empty;
        }

        /// <summary>
        /// Opens a stream for writing an archive.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list
        /// with the specified index. If the archive number is outside the bounds
        /// of the list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method
        /// will seek to the start of any existing archive in the file, or to the
        /// end of the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            if (String.IsNullOrEmpty(archiveName))
            {
                throw new ArgumentNullException("archiveName");
            }

            // All archives must be in the same directory,
            // so always use the directory from the first archive.
            string archiveFile = Path.Combine(
                Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
            Stream stream = File.Open(
                archiveFile,
                (truncate ? FileMode.OpenOrCreate : FileMode.Open),
                FileAccess.ReadWrite);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));

                // If this is not an archive file, append the archive to it.
                if (offset < 0)
                {
                    offset = stream.Length;
                }

                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }

                stream.Seek(0, SeekOrigin.Begin);
            }

            if (truncate)
            {
                // Truncate the stream, in case a larger old archive starts here.
                stream.SetLength(0);
            }
            
            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            Stream stream)
        {
            if (stream != null)
            {
                stream.Close();

                FileStream fileStream = stream as FileStream;
                if (fileStream != null)
                {
                    string streamFile = fileStream.Name;
                    if (!String.IsNullOrEmpty(archiveName) &&
                        archiveName != Path.GetFileName(streamFile))
                    {
                        string archiveFile = Path.Combine(
                            Path.GetDirectoryName(this.archiveFiles[0]), archiveName);
                        if (File.Exists(archiveFile))
                        {
                            File.Delete(archiveFile);
                        }
                        File.Move(streamFile, archiveFile);
                    }
                }
            }
        }

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="attributes">The returned attributes of the opened file,
        /// to be stored in the archive.</param>
        /// <param name="lastWriteTime">The returned last-modified time of the
        /// opened file, to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from
        /// before they are compressed, or null to skip inclusion of the file and
        /// continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened, relative
        /// to the specified directory (or it may be an absolute path). If no mapping
        /// exists, the file is skipped.</item>
        /// </list>
        /// </remarks>
        public virtual Stream OpenFileReadStream(
            string path, out FileAttributes attributes, out DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                attributes = FileAttributes.Normal;
                lastWriteTime = DateTime.Now;
                return null;
            }

            attributes = File.GetAttributes(filePath);
            lastWriteTime = File.GetLastWriteTime(filePath);
            return File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
        }

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseFileReadStream(string path, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Gets extended parameter information specific to the compression format
        /// being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This implementation does not handle any options. Subclasses may override
        /// this method to allow for non-default behavior.
        /// </remarks>
        public virtual object GetOption(string optionName, object[] parameters)
        {
            return null;
        }

        #endregion

        #region IUnpackStreamContext Members

        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to
        /// open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel
        /// extraction of the archive.</returns>
        /// <remarks>
        /// This method opens the file from the <see cref="ArchiveFiles"/> list with
        /// the specified index. If the archive number is outside the bounds of the
        /// list, this method returns null.
        /// <para>If the <see cref="EnableOffsetOpen"/> flag is set, this method will
        /// seek to the start of any existing archive in the file, or to the end of
        /// the file if the existing file is not an archive.</para>
        /// </remarks>
        public virtual Stream OpenArchiveReadStream(
            int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            if (archiveNumber >= this.archiveFiles.Count)
            {
                return null;
            }

            string archiveFile = this.archiveFiles[archiveNumber];
            Stream stream = File.Open(
                archiveFile, FileMode.Open, FileAccess.Read, FileShare.Read);

            if (this.enableOffsetOpen)
            {
                long offset = compressionEngine.FindArchiveOffset(
                    new DuplicateStream(stream));
                if (offset > 0)
                {
                    stream = new OffsetStream(stream, offset);
                }
                else
                {
                    stream.Seek(0, SeekOrigin.Begin);
                }
            }

            return stream;
        }

        /// <summary>
        /// Closes a stream where an archive was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream
        /// to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        public virtual void CloseArchiveReadStream(
            int archiveNumber, string archiveName, Stream stream)
        {
            if (stream != null)
            {
                stream.Close();
            }
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be
        /// extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be
        /// extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null
        /// to skip extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// This method opens a file using the following logic:
        /// <list>
        /// <item>If the <see cref="Directory"/> and the <see cref="Files"/> mapping
        /// are both null, the path is treated as relative to the current directory,
        /// and that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is not null but the <see cref="Files"/>
        /// mapping is null, the path is treated as relative to that directory, and
        /// that file is opened.</item>
        /// <item>If the <see cref="Directory"/> is null but the <see cref="Files"/>
        /// mapping is not null, the path parameter is used as a key into the mapping,
        /// and the resulting value is the file path that is opened, relative to the
        /// current directory (or it may be an absolute path). If no mapping exists,
        /// the file is skipped.</item>
        /// <item>If both the <see cref="Directory"/> and the <see cref="Files"/>
        /// mapping are specified, the path parameter is used as a key into the
        /// mapping, and the resulting value is the file path that is opened,
        /// relative to the specified directory (or it may be an absolute path).
        /// If no mapping exists, the file is skipped.</item>
        /// </list>
        /// <para>If the <see cref="ExtractOnlyNewerFiles"/> flag is set, the file
        /// is skipped if a file currently exists in the same path with an equal
        /// or newer write time.</para>
        /// </remarks>
        public virtual Stream OpenFileWriteStream(
            string path,
            long fileSize,
            DateTime lastWriteTime)
        {
            string filePath = this.TranslateFilePath(path);

            if (filePath == null)
            {
                return null;
            }

            FileInfo file = new FileInfo(filePath);
            if (file.Exists)
            {
                if (this.extractOnlyNewerFiles && lastWriteTime != DateTime.MinValue)
                {
                    if (file.LastWriteTime >= lastWriteTime)
                    {
                        return null;
                    }
                }

                if ((file.Attributes & FileAttributes.ReadOnly) != 0)
                {
                    file.Attributes &= ~FileAttributes.ReadOnly;
                }
            }

            if (!file.Directory.Exists)
            {
                file.Directory.Create();
            }

            return File.Open(
                filePath, FileMode.Create, FileAccess.Write, FileShare.None);
        }

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenFileWriteStream"/> and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// After closing the extracted file stream, this method applies the date
        /// and attributes to that file.
        /// </remarks>
        public virtual void CloseFileWriteStream(
            string path,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime)
        {
            if (stream != null)
            {
                stream.Close();
            }

            string filePath = this.TranslateFilePath(path);
            if (filePath != null)
            {
                FileInfo file = new FileInfo(filePath);

                if (lastWriteTime != DateTime.MinValue)
                {
                    try
                    {
                        file.LastWriteTime = lastWriteTime;
                    }
                    catch (ArgumentException)
                    {
                    }
                    catch (IOException)
                    {
                    }
                }

                try
                {
                    file.Attributes = attributes;
                }
                catch (IOException)
                {
                }
            }
        }

        #endregion

        #region Private utility methods

        /// <summary>
        /// Translates an internal file path to an external file path using the
        /// <see cref="Directory"/> and the <see cref="Files"/> mapping, according to
        /// rules documented in <see cref="OpenFileReadStream"/> and
        /// <see cref="OpenFileWriteStream"/>.
        /// </summary>
        /// <param name="path">The path of the file with the archive.</param>
        /// <returns>The external path of the file, or null if there is no
        /// valid translation.</returns>
        private string TranslateFilePath(string path)
        {
            string filePath;
            if (this.files != null)
            {
                filePath = this.files[path];
            }
            else
            {
                filePath = path;
            }

            if (filePath != null)
            {
                if (this.directory != null)
                {
                    filePath = Path.Combine(this.directory, filePath);
                }
            }

            return filePath;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\BasicUnpackStreamContext.cs ===
//---------------------------------------------------------------------
// <copyright file="BasicUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Stream context used to extract a single file from an archive into a memory stream.
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
    public class BasicUnpackStreamContext : IUnpackStreamContext
    {
        private Stream archiveStream;
        private Stream fileStream;

        /// <summary>
        /// Creates a new BasicExtractStreamContext that reads from the specified archive stream.
        /// </summary>
        /// <param name="archiveStream">Archive stream to read from.</param>
        public BasicUnpackStreamContext(Stream archiveStream)
        {
            this.archiveStream = archiveStream;
        }

        /// <summary>
        /// Gets the stream for the extracted file, or null if no file was extracted.
        /// </summary>
        public Stream FileStream
        {
            get
            {
                return this.fileStream;
            }
        }

        /// <summary>
        /// Opens the archive stream for reading. Returns a DuplicateStream instance,
        /// so the stream may be virtually opened multiple times.
        /// </summary>
        /// <param name="archiveNumber">The archive number to open (ignored; 0 is assumed).</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read.</returns>
        public Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine)
        {
            return new DuplicateStream(this.archiveStream);
        }

        /// <summary>
        /// Does *not* close the stream. The archive stream should be managed by
        /// the code that invokes the archive extraction.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream being closed.</param>
        public void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream)
        {
            // Do nothing.
        }

        /// <summary>
        /// Opens a stream for writing extracted file bytes. The returned stream is a MemoryStream
        /// instance, so the file is extracted straight into memory.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <returns>A stream where extracted file bytes are to be written.</returns>
        public Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime)
        {
            this.fileStream = new MemoryStream(new byte[fileSize], 0, (int) fileSize, true, true);
            return this.fileStream;
        }

        /// <summary>
        /// Does *not* close the file stream. The file stream is saved in memory so it can
        /// be read later.
        /// </summary>
        /// <param name="path">Path of the file within the archive.</param>
        /// <param name="stream">The file stream to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        public void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime)
        {
            // Do nothing.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Program.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Security.Permissions;
using Microsoft.Deployment.Compression;
using Microsoft.Deployment.Compression.Zip;
using Microsoft.Deployment.Compression.Cab;

namespace Microsoft.LFIT
{
    class Program
    {
        static string strTempManifestCabPath;

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static void Run(string[] args)
        {
            Settings settings = new Settings();

            // Parse command line
            try
            {
                settings.ParseCommandLine(args);
            }
            catch (System.ArgumentException ex)
            {
                Log.ExceptionCaught = true;
                if (ex.ParamName != "-?")
                {
                    Log.WriteLog("Error: " + ex.Message);
                }

                Settings.DisplayUsage();
                throw;
            }

            Log.Quiet = settings.Quiet;

            // justify the input
            switch (settings.InputCommand)
            {
                case Command.All:
                    {
                        try
                        {
                            CreateCabFiles(settings);
/*
                            IList<CODESIGN.Submitter.Job> jobList = new List<CODESIGN.Submitter.Job>();

                            if (CodeSignSubmitCabs(settings, jobList) == 0)
                            {
                                CodeSignJobCheck(settings, jobList);
                                Log.WriteLog("LFIT job finished");
                            }
                            else
                            {
                                Log.WriteLog("LFIT job failed");
                            }
 */ 
                        }
                        catch (System.Exception)
                        {
                            Log.WriteLog("LFIT job failed");
                            throw;
                        }
                        break;
                    }
                case Command.Create:
                    {
                        CreateCabFiles(settings);
                        CopyCabsFromTempFolder(settings);
                        break;
                    }

                case Command.Submit:
                    {
                        //CodeSignSubmitFile(settings);
                        break;
                    }

                case Command.Check:
                    {
                        //CodeSignOneJobCheck(settings.CodeSignJobNumber);
                        break;
                    }

                default:
                        break;
            }

        }

        private static int CreateCabFiles(Settings settings)
        {
            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting " + settings.TempDirectory + @"...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting " + settings.TempDirectory + @" finished");
                }
                catch (System.IO.IOException)
                {
                    throw;
                }
            }

            if( !Directory.Exists(settings.InputFolder))
            {
                throw new System.IO.FileNotFoundException("Input folder not found", settings.InputFolder);
            }

/*
            string strUnZipFolder = Path.Combine(settings.TempDirectory, @"UnZipFiles");
            ZipInfo zip = new ZipInfo(settings.ZipFilePath);
            Log.WriteLog("Unzipping " + settings.ZipFilePath + "...");
            zip.Unpack(strUnZipFolder);
            Log.WriteLog("Unzipping finished");
*/ 

            long totalInstallSize = 0;
            CreateContentCabs(settings, settings.InputFolder, ref totalInstallSize);
            CreateManifestCab(settings, totalInstallSize);

            return 0;
        }

        private static int CreateContentCabs(Settings settings, string strUnZipFolder, ref long totalInstallSize)
        {
            CreateContentXbx(settings, settings.InputFolder);

            // Re-pack the file to CAB files ( < 2.0 G)
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            Directory.CreateDirectory(strCabFileFolder);
            string strCabName = Path.Combine(strCabFileFolder, settings.ContentID);

            totalInstallSize = 0;
            IList<string> fileList = new List<string>();
            RecursiveGetFilePathsInDirectoryTree(strUnZipFolder, true, fileList);

            foreach (string file in fileList)
            {
                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(file);
                totalInstallSize += info.Length;
            }

            IList<string> archiveFiles = new List<string>();
            long maxVolumNum = totalInstallSize / settings.MaxCabSize + 1;
            for (int i = 1; i <= maxVolumNum; i++)
            {
                archiveFiles.Add(strCabName + string.Format("_{0}.cab", i));
            }
            //Create cab files 
            CabInfo cab = new CabInfo(strCabName);

            Log.WriteLog("Compressing content cab files for " + strUnZipFolder + "...");
            cab.Pack(archiveFiles, strUnZipFolder, true, (CompressionLevel)settings.CompressionLevel, null, settings.MaxCabSize);
            Log.WriteLog("Compressing content cab files finished");
            
            return 0;
        }

        private static int CreateManifestCab(Settings settings, long totalInstallSize)
        {
            Log.WriteLog("Creating manifest.cab...");
            string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
            Directory.CreateDirectory(strManifestFolder);
            string contentFolder = Path.Combine(strManifestFolder, @"Content");
            Directory.CreateDirectory(contentFolder);

            string srcXbx = Path.Combine(settings.InputFolder, @"content.xbx");
            string destXbx = Path.Combine(strManifestFolder, @"content.xbx");
            File.Copy(srcXbx, destXbx);
            Log.WriteLog("Copied content.xbx from " + srcXbx + " to " + destXbx);

            // Create manifest file
            string strManifestFileName = Path.Combine(contentFolder, @"OfferManifest.xml");
            Manifest manifest = new Manifest();
            manifest.NewFile();
            manifest.CabFolder = Path.Combine(settings.TempDirectory, @"cabs");
            manifest.InstallSize = totalInstallSize;
            manifest.TitleId = settings.TitleID;
            manifest.LinkURL = settings.ContentURL;
            string log = manifest.SaveFile(strManifestFileName);
            Log.WriteLog(log);

            // Pack content.xbx and manifest file
            strTempManifestCabPath = Path.Combine(strManifestFolder, settings.ContentID + @"_Manifest.cab");
            CabInfo cabManifest = new CabInfo(strTempManifestCabPath);
            cabManifest.Pack(strManifestFolder, true, (CompressionLevel)settings.CompressionLevel, null);
            Log.WriteLog("Creating " + strTempManifestCabPath + " finished");

            return 0;
        }

        private static string CreateContentXbx(Settings settings, string strFolder)
        {
            // Create content.xbx
            // Create an instance of StreamWriter to write text to a file.
            // The using statement also closes the StreamWriter.
            string stringContentXbxFileName = Path.Combine(strFolder, @"content.xbx");

            if (settings.Nooverwritexbx)
            {
                if (!File.Exists(stringContentXbxFileName))
                {
                    throw new System.IO.FileNotFoundException("Error: content.xbx not found", stringContentXbxFileName);
                }
                else
                {
                    Log.WriteLog("Using content.xbx at " + stringContentXbxFileName);
                }
            }
            else
            {
                using (StreamWriter sw = new StreamWriter(stringContentXbxFileName, false, Encoding.Unicode))
                {
                    // Add some text to the file.
                    sw.WriteLine(";");
                    sw.WriteLine("; GFWL Submission Metadata File -- Generated by LFIT.exe on " + DateTime.Now.ToShortDateString());
                    sw.WriteLine(";");
                    sw.WriteLine("; Copyright (c) Microsoft Corporation");
                    sw.WriteLine(";");
                    sw.WriteLine("");

                    sw.WriteLine("[All]");
                    sw.WriteLine("Premium=No");
                    sw.WriteLine("TitleID=0x" + settings.TitleID);
                    sw.WriteLine("ContentPackageType=" + settings.ContentType);
                    sw.WriteLine("LicenseBits=0x00000000");
                    sw.WriteLine("BaseVersion=0x00000000");
                    sw.WriteLine("UpdateVersion=0x00000000");
                    sw.WriteLine("ThumbnailImage=\"generic.PNG\"");
                    sw.WriteLine("OfferingID=0x" + settings.OfferID);
                    sw.WriteLine("AdminFriendlyName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("TitleName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("PurchaseOnceOnly=Yes");
                    sw.WriteLine("ContentFlags=0xC0");
                    sw.WriteLine("ContentID=" + settings.ContentID);
                    sw.WriteLine("Platform=0x10");
                    sw.WriteLine("BitFlags=0xFFFFFFFF");
                    sw.WriteLine("ActivationDate=" + DateTime.Now.ToShortDateString());
                    sw.WriteLine("DefaultDisplayName=\"This is LFIT.exe generic text\"");
                    sw.WriteLine("OfferRegions.0=103,0,0,TaxNotApplicable");
                    if (string.Compare(settings.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=Content");
                    }
                    else if (string.Compare(settings.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        sw.WriteLine("OfferingType=FullGame");
                    }
                    sw.WriteLine("EndDate=12/31/2999");
                    sw.WriteLine("DisplayInDash=Yes");
                    sw.WriteLine("Version=0x00020001");
                    sw.WriteLine("DashDisplayName.0=EN,\"This is LFIT.exe generic text\"");
                    sw.WriteLine("DashDescription.0=EN,\"This is LFIT.exe generic text\"");
                }
                Log.WriteLog("Saved content.xbx at " + stringContentXbxFileName);
            }

            return stringContentXbxFileName;
        }
/*
        private static int CodeSignSubmitFile(Settings settings)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                ret = codeSignSubmission.CreateSubmission(settings.CodeSignFileName, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, null);
                if (ret == 0)
                {
                    Log.WriteLog("CodeSign submission succeeded. please limit the submission less than 6G per hour before the next submission");
                }
                else
                {
                    Log.WriteLog("CodeSign submission failed.");
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignSubmitCabs(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                // Codesign the CAB fiels
                string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
                CodesignSubmission codeSignSubmission = new CodesignSubmission();
                Log.WriteLog("Start CodeSign submitting...");

                foreach (string file in Directory.GetFiles(strCabFileFolder))
                {
                    ret = codeSignSubmission.CreateSubmission(file, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                    if (ret == 0)
                    {
                        Log.WriteLog("Waiting 20 minutes to start submitting next job...");
                        System.Threading.Thread.Sleep(1200000);         // 20 minutes
                    }
                    else
                    {
                        break;
                    }
                }

                // Codesigne manifest.cab
                if (ret == 0)
                {
                    string strManifestFolder = Path.Combine(settings.TempDirectory, @"Manifest");
                    string strManifesCabFile = Path.Combine(strManifestFolder, @"Manifest.cab");
                    ret = codeSignSubmission.CreateSubmission(strManifesCabFile, settings.Signers, settings.LargeFileCertID, settings.NormalFileCertID, settings.StrongNameCertID, jobList);
                }

                Log.WriteLog("CodeSign submitting finished");
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        } 
        private static int CodeSignOneJobCheck(string jobNumber)
        {
            int ret = 0;
            try
            {
                    Log.WriteLog("Waiting for  CodeSign result. Job Number = {0}...", jobNumber);
                    if (Watcher.Monitor(jobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", jobNumber);
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", jobNumber);
                        ret = -1;
                    }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }

        private static int CodeSignJobCheck(Settings settings, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            try
            {
                Log.WriteLog("Waiting for content cab files CodeSign result...");
                foreach (CODESIGN.Submitter.Job job in jobList)
                {
                    string file = Path.GetFileName(job.FileList.Values[0].ToString());
                    Log.WriteLog("Waiting for {0} CodeSign result...", file);
                    if (Watcher.Monitor(job.JobNumber) == 0)
                    {
                        Log.WriteLog("{0} CodeSign succeeded.", file);

                        if (string.Compare(file, "manifest.cab", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                        {
                            string destManifestFileName = Path.Combine(settings.CurrentWorkingDirectory, @"Manifest.cab");
                            Log.WriteLog("Copying {0}...", file);
                            File.Copy(job.JobCompletionPath, destManifestFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                        else
                        {
                            if (!Directory.Exists(settings.ContentFilePath))
                            {
                                Directory.CreateDirectory(settings.ContentFilePath);
                            }
                            Log.WriteLog("Copying {0}...", file);
                            string destFileName = Path.Combine(settings.ContentFilePath, file);
                            File.Copy(job.JobCompletionPath, destFileName, true);
                            Log.WriteLog("Copying {0} finished", file);
                        }
                    }
                    else
                    {
                        Log.WriteLog("Content {0} CodeSign failed", file);
                        ret = -1;
                    }
                }
            }
            catch (Exception)
            {
                ret = -1;
                throw;
            }

            return ret;
        }
*/
        private static int CopyCabsFromTempFolder(Settings settings)
        {
            Log.WriteLog("Moving content cab files to the unsigned cabs folder...");
            // Copy CAB files to /contentFilePath:<ContentFilePaht>
            string strCabFileFolder = Path.Combine(settings.TempDirectory, @"cabs");
            string strUnSignedCabPath = Path.Combine(settings.UnSignedCabPath, settings.TitleID);
            if (!Directory.Exists(strUnSignedCabPath))
            {
                Directory.CreateDirectory(strUnSignedCabPath);
            }
            foreach (string file in Directory.GetFiles(strCabFileFolder))
            {
                string destFileName = Path.Combine(strUnSignedCabPath, Path.GetFileName(file));

                // Delete (if exists) & move to overwrite
                try
                {
                    File.Delete(destFileName);
                }
                catch (System.IO.IOException)
                {
                }
                File.Move(file, destFileName);
            }
            Log.WriteLog("Moving content cab files finished");

            // Copy manifest.cab to /manifestFilePath:<ManifestFilePath>
            FileInfo fiManifest = new FileInfo(strTempManifestCabPath);
            string strManifestFileName = fiManifest.FullName;
            string destManifestFileName = Path.Combine(settings.UnSignedCabPath, fiManifest.Name);
            Log.WriteLog("Copying manifest.cab to " + destManifestFileName);

            // Delete (if exists) & move to overwrite
            try
            {
                File.Delete(destManifestFileName);
            }
            catch (System.IO.IOException)
            {
            }
            File.Move(strManifestFileName, destManifestFileName);

            // Delete the existing directory and all subdirectories with Directory static method...
            if (System.IO.Directory.Exists(settings.TempDirectory))
            {
                try
                {
                    Log.WriteLog("Deleting temporary working folder...");
                    System.IO.Directory.Delete(settings.TempDirectory, true);
                    Log.WriteLog("Deleting temporary working finished");
                }
                catch (System.IO.IOException)
                {
                }
            }

            return 0;
        }

        private static void RecursiveGetFilePathsInDirectoryTree(
            string dir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                fileList.Add(file);
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    RecursiveGetFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static int Main(string[] args)
        {
            Log.WriteLog(@"LFIT.EXE starts...");

            int returnResult = 1;
            try
            {
                Run(args);
                returnResult = 0;
            }
            catch (System.Exception ex)
            {
                if (!Log.ExceptionCaught)
                {
                    Log.WriteLog(ex.ToString());
                }
            }
            Log.WriteLog(@"LFIT.EXE ends...");
            return returnResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\CompressionLevel.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionLevel.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Specifies the compression level ranging from minimum compresion to
    /// maximum compression, or no compression at all.
    /// </summary>
    /// <remarks>
    /// Although only four values are enumerated, any integral value between
    /// <see cref="CompressionLevel.Min"/> and <see cref="CompressionLevel.Max"/> can also be used.
    /// </remarks>
    public enum CompressionLevel
    {
        /// <summary>Do not compress files, only store.</summary>
        None = 0,

        /// <summary>Minimum compression; fastest.</summary>
        Min = 1,

        /// <summary>A compromize between speed and compression efficiency.</summary>
        Normal = 6,

        /// <summary>Maximum compression; slowest.</summary>
        Max = 10
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\DuplicateStream.cs ===
//---------------------------------------------------------------------
// <copyright file="DuplicateStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Duplicates a source stream by maintaining a separate position.
    /// </summary>
    /// <remarks>
    /// WARNING: duplicate streams are not thread-safe with respect to each other or the original stream.
    /// If multiple threads use duplicate copies of the same stream, they must synchronize for any operations.
    /// </remarks>
    public class DuplicateStream : Stream
    {
        private Stream source;
        private long position;

        /// <summary>
        /// Creates a new duplicate of a stream.
        /// </summary>
        /// <param name="source">source of the duplicate</param>
        public DuplicateStream(Stream source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = DuplicateStream.OriginalStream(source);
        }

        /// <summary>
        /// Gets the original stream that was used to create the duplicate.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the current stream,
        /// ignoring the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.position;
            }

            set
            {
                this.position = value;
            }
        }

        /// <summary>
        /// Retrieves the original stream from a possible duplicate stream.
        /// </summary>
        /// <param name="stream">Possible duplicate stream.</param>
        /// <returns>If the stream is a DuplicateStream, returns
        /// the duplicate's source; otherwise returns the same stream.</returns>
        public static Stream OriginalStream(Stream stream)
        {
            DuplicateStream dupStream = stream as DuplicateStream;
            return dupStream != null ? dupStream.Source : stream;
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the stream in bytes.</param>
        public override void SetLength(long value)
        { 
            this.source.SetLength(value);
        }

        /// <summary>
        /// Closes the underlying stream, effectively closing ALL duplicates.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }

        /// <summary>
        /// Reads from the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            int read = this.source.Read(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
            return read;
        }

        /// <summary>
        /// Writes to the source stream while maintaining a separate position
        /// and not impacting the source stream's position.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            long saveSourcePosition = this.source.Position;
            this.source.Position = this.position;
            this.source.Write(buffer, offset, count);
            this.position = this.source.Position;
            this.source.Position = saveSourcePosition;
        }

        /// <summary>
        /// Changes the position of this stream without impacting the
        /// source stream's position.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating the reference
        /// point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            long originPosition = 0;
            if (origin == SeekOrigin.Current)
            {
                originPosition = this.position;
            }
            else if (origin == SeekOrigin.End)
            {
                originPosition = this.Length;
            }

            this.position = originPosition + offset;
            return this.position;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup\Properties\AssemblyInfo.cs ===
﻿using System;
using System.Resources;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: CLSCompliant(true)]
[assembly: NeutralResourcesLanguage("en-US")]
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LFIT")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ee0eea6d-89be-4709-b22f-30110754d5cb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\IPackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IPackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// This interface provides the methods necessary for the
    /// <see cref="CompressionEngine"/> to open and close streams for archives
    /// and files. The implementor of this interface can use any kind of logic
    /// to determine what kind of streams to open and where.
    /// </summary>
    public interface IPackStreamContext
    {
        /// <summary>
        /// Gets the name of the archive with a specified number.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive
        /// within the chain.</param>
        /// <returns>The name of the requested archive. May be an empty string
        /// for non-chained archives, but may never be null.</returns>
        /// <remarks>The archive name is the name stored within the archive, used for
        /// identification of the archive especially among archive chains. That
        /// name is often, but not necessarily the same as the filename of the
        /// archive package.</remarks>
        string GetArchiveName(int archiveNumber);

        /// <summary>
        /// Opens a stream for writing an archive package.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was returned
        /// by <see cref="GetArchiveName"/>.</param>
        /// <param name="truncate">True if the stream should be truncated when
        /// opened (if it already exists); false if an existing stream is being
        /// re-opened for writing additional data.</param>
        /// <param name="compressionEngine">Instance of the compression engine
        /// doing the operations.</param>
        /// <returns>A writable Stream where the compressed archive bytes will be
        /// written, or null to cancel the archive creation.</returns>
        /// <remarks>
        /// If this method returns null, the archive engine will throw a
        /// FileNotFoundException.
        /// </remarks>
        Stream OpenArchiveWriteStream(
            int archiveNumber,
            string archiveName,
            bool truncate,
            CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was written.
        /// </summary>
        /// <param name="archiveNumber">The 0-based index of the archive within
        /// the chain.</param>
        /// <param name="archiveName">The name of the archive that was previously
        /// returned by
        /// <see cref="GetArchiveName"/>.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenArchiveWriteStream"/> and is now ready to be closed.</param>
        /// <remarks>
        /// If there is another archive package in the chain, then after this stream
        /// is closed a new stream will be opened.
        /// </remarks>
        void CloseArchiveWriteStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream to read a file that is to be included in an archive.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often,
        /// but not necessarily, the same as the relative path of the file outside
        /// the archive.</param>
        /// <param name="attributes">Returned attributes of the opened file, to be
        /// stored in the archive.</param>
        /// <param name="lastWriteTime">Returned last-modified time of the opened file,
        /// to be stored in the archive.</param>
        /// <returns>A readable Stream where the file bytes will be read from before
        /// they are compressed, or null to skip inclusion of the file and continue to
        /// the next file.</returns>
        [SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters")]
        Stream OpenFileReadStream(
            string path,
            out FileAttributes attributes,
            out DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream that has been used to read a file.
        /// </summary>
        /// <param name="path">The path of the file within the archive; the same as
        /// the path provided
        /// when the stream was opened.</param>
        /// <param name="stream">A stream that was previously returned by
        /// <see cref="OpenFileReadStream"/> and is now ready to be closed.</param>
        void CloseFileReadStream(string path, Stream stream);

        /// <summary>
        /// Gets extended parameter information specific to the compression
        /// format being used.
        /// </summary>
        /// <param name="optionName">Name of the option being requested.</param>
        /// <param name="parameters">Parameters for the option; for per-file options,
        /// the first parameter is typically the internal file path.</param>
        /// <returns>Option value, or null to use the default behavior.</returns>
        /// <remarks>
        /// This method provides a way to set uncommon options during packaging, or a
        /// way to handle aspects of compression formats not supported by the base library.
        /// <para>For example, this may be used by the zip compression library to
        /// specify different compression methods/levels on a per-file basis.</para>
        /// <para>The available option names, parameters, and expected return values
        /// should be documented by each compression library.</para>
        /// </remarks>
        object GetOption(string optionName, object[] parameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\IUnpackStreamContext.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="IUnpackStreamContext.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// This interface provides the methods necessary for the <see cref="CompressionEngine"/> to open
    /// and close streams for archives and files. The implementor of this interface can use any
    /// kind of logic to determine what kind of streams to open and where 
    /// </summary>
    public interface IUnpackStreamContext
    {
        /// <summary>
        /// Opens the archive stream for reading.
        /// </summary>
        /// <param name="archiveNumber">The zero-based index of the archive to open.</param>
        /// <param name="archiveName">The name of the archive being opened.</param>
        /// <param name="compressionEngine">Instance of the compression engine doing the operations.</param>
        /// <returns>A stream from which archive bytes are read, or null to cancel extraction
        /// of the archive.</returns>
        /// <remarks>
        /// When the first archive in a chain is opened, the name is not yet known, so the
        /// provided value will be an empty string. When opening further archives, the
        /// provided value is the next-archive name stored in the previous archive. This
        /// name is often, but not necessarily, the same as the filename of the archive
        /// package to be opened.
        /// <para>If this method returns null, the archive engine will throw a
        /// FileNotFoundException.</para>
        /// </remarks>
        Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);

        /// <summary>
        /// Closes a stream where an archive package was read.
        /// </summary>
        /// <param name="archiveNumber">The archive number of the stream to close.</param>
        /// <param name="archiveName">The name of the archive being closed.</param>
        /// <param name="stream">The stream that was previously returned by
        /// <see cref="OpenArchiveReadStream"/> and is now ready to be closed.</param>
        void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);

        /// <summary>
        /// Opens a stream for writing extracted file bytes.
        /// </summary>
        /// <param name="path">The path of the file within the archive. This is often, but
        /// not necessarily, the same as the relative path of the file outside the archive.</param>
        /// <param name="fileSize">The uncompressed size of the file to be extracted.</param>
        /// <param name="lastWriteTime">The last write time of the file to be extracted.</param>
        /// <returns>A stream where extracted file bytes are to be written, or null to skip
        /// extraction of the file and continue to the next file.</returns>
        /// <remarks>
        /// The implementor may use the path, size and date information to dynamically
        /// decide whether or not the file should be extracted.
        /// </remarks>
        Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);

        /// <summary>
        /// Closes a stream where an extracted file was written.
        /// </summary>
        /// <param name="path">The path of the file within the archive.</param>
        /// <param name="stream">The stream that was previously returned by <see cref="OpenFileWriteStream"/>
        /// and is now ready to be closed.</param>
        /// <param name="attributes">The attributes of the extracted file.</param>
        /// <param name="lastWriteTime">The last write time of the file.</param>
        /// <remarks>
        /// The implementor may wish to apply the attributes and date to the newly-extracted file.
        /// </remarks>
        void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\OffsetStream.cs ===
//---------------------------------------------------------------------
// <copyright file="OffsetStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;

    /// <summary>
    /// Wraps a source stream and offsets all read/write/seek calls by a given value.
    /// </summary>
    /// <remarks>
    /// This class is used to trick archive an packing or unpacking process
    /// into reading or writing at an offset into a file, primarily for
    /// self-extracting packages.
    /// </remarks>
    public class OffsetStream : Stream
    {
        private Stream source;
        private long sourceOffset;

        /// <summary>
        /// Creates a new OffsetStream instance from a source stream
        /// and using a specified offset.
        /// </summary>
        /// <param name="source">Underlying stream for which all calls will be offset.</param>
        /// <param name="offset">Positive or negative number of bytes to offset.</param>
        public OffsetStream(Stream source, long offset)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            this.source = source;
            this.sourceOffset = offset;

            this.source.Seek(this.sourceOffset, SeekOrigin.Current);
        }

        /// <summary>
        /// Gets the underlying stream that this OffsetStream calls into.
        /// </summary>
        public Stream Source
        {
            get { return this.source; }
        }

        /// <summary>
        /// Gets the number of bytes to offset all calls before
        /// redirecting to the underlying stream.
        /// </summary>
        public long Offset
        {
            get { return this.sourceOffset; }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        public override long Length
        {
            get { return this.source.Length - this.sourceOffset; } 
        }

        /// <summary>
        /// Gets or sets the effective position of the stream, which
        /// is equal to the position of the source stream minus the offset.
        /// </summary>
        public override long Position
        {
            get { return this.source.Position - this.sourceOffset; }
            set { this.source.Position = value + this.sourceOffset; }
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this.source.Read(buffer, offset, count);
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the
        /// source stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>The unsigned byte cast to an Int32, or -1 if at the
        /// end of the stream.</returns>
        public override int ReadByte()
        {
            return this.source.ReadByte();
        }

        /// <summary>
        /// Writes a byte to the current position in the source stream and
        /// advances the position within the stream by one byte.
        /// </summary>
        /// <param name="value">The byte to write to the stream.</param>
        public override void WriteByte(byte value)
        {
            this.source.WriteByte(value);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Sets the position within the current stream, which is
        /// equal to the position within the source stream minus the offset.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset + (origin == SeekOrigin.Begin ? this.sourceOffset : 0), origin) - this.sourceOffset;
        }

        /// <summary>
        /// Sets the effective length of the stream, which is equal to
        /// the length of the source stream minus the offset.
        /// </summary>
        /// <param name="value">The desired length of the
        /// current stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value + this.sourceOffset);
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\SafeNativeMethods.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.Security;
    using System.Runtime.InteropServices;

    [SuppressUnmanagedCodeSecurity]
    internal static class SafeNativeMethods
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool DosDateTimeToFileTime(
            short wFatDate, short wFatTime, out long fileTime);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool FileTimeToDosDateTime(
            ref long fileTime, out short wFatDate, out short wFatTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CabEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Collections.Generic;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the cabinet format.
    /// </summary>
    public class CabEngine : CompressionEngine
    {
        private CabPacker packer;
        private CabUnpacker unpacker;

        /// <summary>
        /// Creates a new instance of the cabinet engine.
        /// </summary>
        public CabEngine()
            : base()
        {
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly
        /// or indirectly by a user's code, so managed and unmanaged resources
        /// will be disposed. If false, the method has been called by the runtime
        /// from inside the finalizer, and only unmanaged resources will be
        /// disposed.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (packer != null)
                {
                    packer.Dispose();
                    packer = null;
                }
                if (unpacker != null)
                {
                    unpacker.Dispose();
                    unpacker = null;
                }
            }

            base.Dispose(disposing);
        }

        private CabPacker Packer
        {
            get
            {
                if (this.packer == null)
                {
                    this.packer = new CabPacker(this);
                }

                return this.packer;
            }
        }

        private CabUnpacker Unpacker
        {
            get
            {
                if (this.unpacker == null)
                {
                    this.unpacker = new CabUnpacker(this);
                }

                return this.unpacker;
            }
        }

        /// <summary>
        /// Creates a cabinet or chain of cabinets.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// cabinet before the contents are chained to the next cabinet, or zero
        /// for unlimited cabinet size.</param>
        /// <exception cref="ArchiveException">The cabinet could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the cabinet to the external file paths.
        /// <para>Smaller folder sizes can make it more efficient to extract
        /// individual files out of large cabinet packages.</para>
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            this.Packer.CompressionLevel = this.CompressionLevel;
            this.Packer.UseTempFiles = this.UseTempFiles;
            this.Packer.Pack(streamContext, files, maxArchiveSize);
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid cabinet file.
        /// </summary>
        /// <param name="stream">Stream for reading the cabinet file.</param>
        /// <returns>True if the stream is a valid cabinet file
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            return this.Unpacker.IsArchive(stream);
        }

        /// <summary>
        /// Gets information about files in a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the cabinet stream.</returns>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            return this.Unpacker.GetFileInfo(streamContext, fileFilter);
        }

        /// <summary>
        /// Extracts files from a cabinet or cabinet chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of cabinet and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The cabinet provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            this.Unpacker.Unpack(streamContext, fileFilter);
        }

        internal void ReportProgress(ArchiveProgressEventArgs e)
        {
            base.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabException.cs ===
//---------------------------------------------------------------------
// <copyright file="CabException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for cabinet operations.
    /// </summary>
    [Serializable]
    public class CabException : ArchiveException
    {
        private static ResourceManager errorResources;
        private int error;
        private int errorCode;

        /// <summary>
        /// Creates a new CabException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public CabException(string message, Exception innerException)
            : this(0, 0, message, innerException) { }

        /// <summary>
        /// Creates a new CabException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public CabException(string message)
            : this(0, 0, message, null) { }

        /// <summary>
        /// Creates a new CabException.
        /// </summary>
        public CabException()
            : this(0, 0, null, null) { }

        internal CabException(int error, int errorCode, string message, Exception innerException)
            : base(message, innerException)
        {
            this.error = error;
            this.errorCode = errorCode;
        }

        internal CabException(int error, int errorCode, string message)
            : this(error, errorCode, message, null) { }

        /// <summary>
        /// Initializes a new instance of the CabException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            this.error = info.GetInt32("cabError");
            this.errorCode = info.GetInt32("cabErrorCode");
        }

        /// <summary>
        /// Gets the FCI or FDI cabinet engine error number.
        /// </summary>
        /// <value>A cabinet engine error number, or 0 if the exception was
        /// not related to a cabinet engine error number.</value>
        public int Error
        {
            get
            {
                return this.error;
            }
        }

        /// <summary>
        /// Gets the Win32 error code.
        /// </summary>
        /// <value>A Win32 error code, or 0 if the exception was
        /// not related to a Win32 error.</value>
        public int ErrorCode
        {
            get
            {
                return this.errorCode;
            }
        }

        internal static ResourceManager ErrorResources
        {
            get
            {
                if (errorResources == null)
                {
                    errorResources = new ResourceManager(
                        typeof(CabException).Namespace + ".Errors",
                        typeof(CabException).Assembly);
                }
                return errorResources;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            info.AddValue("cabError", this.error);
            info.AddValue("cabErrorCode", this.errorCode);
            base.GetObjectData(info, context);
        }

        internal static string GetErrorMessage(int error, int errorCode, bool extracting)
        {
            const int FCI_ERROR_RESOURCE_OFFSET = 1000;
            const int FDI_ERROR_RESOURCE_OFFSET = 2000;
            int resourceOffset = (extracting ? FDI_ERROR_RESOURCE_OFFSET : FCI_ERROR_RESOURCE_OFFSET);

            string msg = CabException.ErrorResources.GetString(
                (resourceOffset + error).ToString(CultureInfo.InvariantCulture.NumberFormat),
                CultureInfo.CurrentCulture);

            if (msg == null)
            {
                msg = CabException.ErrorResources.GetString(
                    resourceOffset.ToString(CultureInfo.InvariantCulture.NumberFormat),
                    CultureInfo.CurrentCulture);
            }

            if (errorCode != 0)
            {
                const string GENERIC_ERROR_RESOURCE = "1";
                string msg2 = CabException.ErrorResources.GetString(GENERIC_ERROR_RESOURCE, CultureInfo.CurrentCulture);
                msg = String.Format(CultureInfo.InvariantCulture, "{0} " + msg2, msg, errorCode);
            }
            return msg;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a cabinet file on disk; provides access to
    /// file-based operations on the cabinet file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="CabEngine"/> class.
    /// </remarks>
    [Serializable]
    public class CabInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a cabinet file in a specified path.
        /// </summary>
        /// <param name="path">The path to the cabinet file. When creating a cabinet file, this file does not
        /// necessarily exist yet.</param>
        public CabInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="CabEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new CabEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="CabFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<CabFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<CabFileInfo> cabFiles = new List<CabFileInfo>(files.Count);
            foreach (CabFileInfo cabFile in files) cabFiles.Add(cabFile);
            return cabFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabFileInfo.cs ===
//---------------------------------------------------------------------
// <copyright file="CabFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a cabinet package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class CabFileInfo : ArchiveFileInfo
    {
        private int cabFolder;

        /// <summary>
        /// Creates a new CabinetFileInfo object representing a file within a cabinet in a specified path.
        /// </summary>
        /// <param name="cabinetInfo">An object representing the cabinet containing the file.</param>
        /// <param name="filePath">The path to the file within the cabinet. Usually, this is a simple file
        /// name, but if the cabinet contains a directory structure this may include the directory.</param>
        public CabFileInfo(CabInfo cabinetInfo, string filePath)
            : base(cabinetInfo, filePath)
        {
            if (cabinetInfo == null)
            {
                throw new ArgumentNullException("cabinetInfo");
            }

            this.cabFolder = -1;
        }

        /// <summary>
        /// Creates a new CabinetFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a cab.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the cab.</param>
        /// <param name="cabFolder">The folder number containing the file.</param>
        /// <param name="cabNumber">The cabinet number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        internal CabFileInfo(
            string filePath,
            int cabFolder,
            int cabNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : base(filePath, cabNumber, attributes, lastWriteTime, length)
        {
            this.cabFolder = cabFolder;
        }

        /// <summary>
        /// Initializes a new instance of the CabinetFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected CabFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.cabFolder = info.GetInt32("cabFolder");
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("cabFolder", this.cabFolder);
        }

        /// <summary>
        /// Gets or sets the cabinet that contains this file.
        /// </summary>
        /// <value>
        /// The CabinetInfo instance that retrieved this file information -- this
        /// may be null if the CabinetFileInfo object was returned directly from a
        /// stream.
        /// </value>
        public CabInfo Cabinet
        {
            get
            {
                return (CabInfo) this.Archive;
            }
        }

        /// <summary>
        /// Gets the full path of the cabinet that contains this file.
        /// </summary>
        /// <value>The full path of the cabinet that contains this file.</value>
        public string CabinetName
        {
            get
            {
                return this.ArchiveName;
            }
        }

        /// <summary>
        /// Gets the number of the folder containing this file.
        /// </summary>
        /// <value>The number of the cabinet folder containing this file.</value>
        /// <remarks>A single folder or the first folder of a cabinet
        /// (or chain of cabinets) is numbered 0.</remarks>
        public int CabinetFolderNumber
        {
            get
            {
                if (this.cabFolder < 0)
                {
                    this.Refresh();
                }
                return this.cabFolder;
            }
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// This implementation refreshes the <see cref="CabinetFolderNumber"/>.
        /// </remarks>
        protected override void Refresh(ArchiveFileInfo newFileInfo)
        {
            base.Refresh(newFileInfo);
            this.cabFolder = ((CabFileInfo) newFileInfo).cabFolder;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\ArchiveFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed file within an archive;
    /// provides operations for getting the file properties and unpacking
    /// the file.
    /// </summary>
    [Serializable]
    public abstract class ArchiveFileInfo : FileSystemInfo
    {
        private ArchiveInfo archiveInfo;
        private string name;
        private string path;

        private bool initialized;
        private bool exists;
        private int archiveNumber;
        private FileAttributes attributes;
        private DateTime lastWriteTime;
        private long length;

        /// <summary>
        /// Creates a new ArchiveFileInfo object representing a file within
        /// an archive in a specified path.
        /// </summary>
        /// <param name="archiveInfo">An object representing the archive
        /// containing the file.</param>
        /// <param name="filePath">The path to the file within the archive.
        /// Usually, this is a simple file name, but if the archive contains
        /// a directory structure this may include the directory.</param>
        protected ArchiveFileInfo(ArchiveInfo archiveInfo, string filePath)
            : base()
        {
            if (filePath == null)
            {
                throw new ArgumentNullException("filePath");
            }

            this.Archive = archiveInfo;

            this.name = System.IO.Path.GetFileName(filePath);
            this.path = System.IO.Path.GetDirectoryName(filePath);

            this.attributes = FileAttributes.Normal;
            this.lastWriteTime = DateTime.MinValue;
        }

        /// <summary>
        /// Creates a new ArchiveFileInfo object with all parameters specified;
        /// used by subclasses when reading the metadata out of an archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in
        /// the archive.</param>
        /// <param name="archiveNumber">The archive number where the file
        /// starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the
        /// file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        protected ArchiveFileInfo(
            string filePath,
            int archiveNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length)
            : this(null, filePath)
        {
            this.exists = true;
            this.archiveNumber = archiveNumber;
            this.attributes = attributes;
            this.lastWriteTime = lastWriteTime;
            this.length = length;
            this.initialized = true;
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveFileInfo class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.archiveInfo = (ArchiveInfo) info.GetValue(
                "archiveInfo", typeof(ArchiveInfo));
            this.name = info.GetString("name");
            this.path = info.GetString("path");
            this.initialized = info.GetBoolean("initialized");
            this.exists = info.GetBoolean("exists");
            this.archiveNumber = info.GetInt32("archiveNumber");
            this.attributes = (FileAttributes) info.GetValue(
                "attributes", typeof(FileAttributes));
            this.lastWriteTime = info.GetDateTime("lastWriteTime");
            this.length = info.GetInt64("length");
        }

        /// <summary>
        /// Gets the name of the file.
        /// </summary>
        /// <value>The name of the file, not including any path.</value>
        public override string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Gets the internal path of the file in the archive.
        /// </summary>
        /// <value>The internal path of the file in the archive, not including
        /// the file name.</value>
        public string Path
        {
            get
            {
                return this.path;
            }
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <value>The full path to the file, including the full path to the
        /// archive, the internal path in the archive, and the file name.</value>
        /// <remarks>
        /// For example, the path <c>"C:\archive.cab\file.txt"</c> refers to
        /// a file "file.txt" inside the archive "archive.cab".
        /// </remarks>
        public override string FullName
        {
            get
            {
                string fullName = System.IO.Path.Combine(this.Path, this.Name);
                
                if (this.Archive != null)
                {
                    fullName = System.IO.Path.Combine(this.ArchiveName, fullName);
                }

                return fullName;
            }
        }

        /// <summary>
        /// Gets or sets the archive that contains this file.
        /// </summary>
        /// <value>
        /// The ArchiveInfo instance that retrieved this file information -- this
        /// may be null if the ArchiveFileInfo object was returned directly from
        /// a stream.
        /// </value>
        public ArchiveInfo Archive
        {
            get
            {
                return (ArchiveInfo) this.archiveInfo;
            }

            internal set
            {
                this.archiveInfo = value;

                // protected instance members inherited from FileSystemInfo:
                this.OriginalPath = (value != null ? value.FullName : null);
                this.FullPath = this.OriginalPath;
            }
        }

        /// <summary>
        /// Gets the full path of the archive that contains this file.
        /// </summary>
        /// <value>The full path of the archive that contains this file.</value>
        public string ArchiveName
        {
            get
            {
                return this.Archive != null ? this.Archive.FullName : null;
            }
        }

        /// <summary>
        /// Gets the number of the archive where this file starts.
        /// </summary>
        /// <value>The number of the archive where this file starts.</value>
        /// <remarks>A single archive or the first archive in a chain is
        /// numbered 0.</remarks>
        public int ArchiveNumber
        {
            get
            {
                return this.archiveNumber;
            }
        }

        /// <summary>
        /// Checks if the file exists within the archive.
        /// </summary>
        /// <value>True if the file exists, false otherwise.</value>
        public override bool Exists
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.exists;
            }
        }

        /// <summary>
        /// Gets the uncompressed size of the file.
        /// </summary>
        /// <value>The uncompressed size of the file in bytes.</value>
        public long Length
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.length;
            }
        }

        /// <summary>
        /// Gets the attributes of the file.
        /// </summary>
        /// <value>The attributes of the file as stored in the archive.</value>
        public new FileAttributes Attributes
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.attributes;
            }
        }

        /// <summary>
        /// Gets the last modification time of the file.
        /// </summary>
        /// <value>The last modification time of the file as stored in the
        /// archive.</value>
        public new DateTime LastWriteTime
        {
            get
            {
                if (!this.initialized)
                {
                    this.Refresh();
                }

                return this.lastWriteTime;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized
        /// object data.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(
            SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("archiveInfo", this.archiveInfo);
            info.AddValue("name", this.name);
            info.AddValue("path", this.path);
            info.AddValue("initialized", this.initialized);
            info.AddValue("exists", this.exists);
            info.AddValue("archiveNumber", this.archiveNumber);
            info.AddValue("attributes", this.attributes);
            info.AddValue("lastWriteTime", this.lastWriteTime);
            info.AddValue("length", this.length);
        }

        /// <summary>
        /// Gets the full path to the file.
        /// </summary>
        /// <returns>The same as <see cref="FullName"/></returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the file. NOT SUPPORTED.
        /// </summary>
        /// <exception cref="NotSupportedException">Files cannot be deleted
        /// from an existing archive.</exception>
        public override void Delete()
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// Refreshes the attributes and other cached information about the file,
        /// by re-reading the information from the archive.
        /// </summary>
        public new void Refresh()
        {
            base.Refresh();

            if (this.Archive != null)
            {
                string filePath = System.IO.Path.Combine(this.Path, this.Name);
                ArchiveFileInfo updatedFile = this.Archive.GetFile(filePath);
                if (updatedFile == null)
                {
                    throw new FileNotFoundException(
                            "File not found in archive.", filePath);
                }

                this.Refresh(updatedFile);
            }
        }

        /// <summary>
        /// Extracts the file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            this.CopyTo(destFileName, false);
        }

        /// <summary>
        /// Extracts the file, optionally overwriting any existing file.
        /// </summary>
        /// <param name="destFileName">The destination path where the file
        /// will be extracted.</param>
        /// <param name="overwrite">If true, <paramref name="destFileName"/>
        /// will be overwritten if it exists.</param>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false
        /// and <paramref name="destFileName"/> exists.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            if (!overwrite && File.Exists(destFileName))
            {
                throw new IOException();
            }

            if (this.Archive == null)
            {
                throw new InvalidOperationException();
            }

            this.Archive.UnpackFile(
                System.IO.Path.Combine(this.Path, this.Name), destFileName);
        }

        /// <summary>
        /// Refreshes the information in this object with new data retrieved
        /// from an archive.
        /// </summary>
        /// <param name="newFileInfo">Fresh instance for the same file just
        /// read from the archive.</param>
        /// <remarks>
        /// Subclasses may override this method to refresh sublcass fields.
        /// However they should always call the base implementation first.
        /// </remarks>
        protected virtual void Refresh(ArchiveFileInfo newFileInfo)
        {
            this.exists = newFileInfo.exists;
            this.length = newFileInfo.length;
            this.attributes = newFileInfo.attributes;
            this.lastWriteTime = newFileInfo.lastWriteTime;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\ArchiveInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Abstract object representing a compressed archive on disk;
    /// provides access to file-based operations on the archive.
    /// </summary>
    [Serializable]
    public abstract class ArchiveInfo : FileSystemInfo
    {
        /// <summary>
        /// Creates a new ArchiveInfo object representing an archive in a
        /// specified path.
        /// </summary>
        /// <param name="path">The path to the archive. When creating an archive,
        /// this file does not necessarily exist yet.</param>
        protected ArchiveInfo(string path) : base()
        {
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // protected instance members inherited from FileSystemInfo:
            this.OriginalPath = path;
            this.FullPath = Path.GetFullPath(path);
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object
        /// data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual
        /// information about the source or destination.</param>
        protected ArchiveInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Gets the directory that contains the archive.
        /// </summary>
        /// <value>A DirectoryInfo object representing the parent directory of the
        /// archive.</value>
        public DirectoryInfo Directory
        {
            get
            {
                return new DirectoryInfo(Path.GetDirectoryName(this.FullName));
            }
        }

        /// <summary>
        /// Gets the full path of the directory that contains the archive.
        /// </summary>
        /// <value>The full path of the directory that contains the archive.</value>
        public string DirectoryName
        {
            get
            {
                return Path.GetDirectoryName(this.FullName);
            }
        }

        /// <summary>
        /// Gets the size of the archive.
        /// </summary>
        /// <value>The size of the archive in bytes.</value>
        public long Length
        {
            get
            {
                return new FileInfo(this.FullName).Length;
            }
        }

        /// <summary>
        /// Gets the file name of the archive.
        /// </summary>
        /// <value>The file name of the archive, not including any path.</value>
        public override string Name
        {
            get
            {
                return Path.GetFileName(this.FullName);
            }
        }

        /// <summary>
        /// Checks if the archive exists.
        /// </summary>
        /// <value>True if the archive exists; else false.</value>
        public override bool Exists
        {
            get
            {
                return File.Exists(this.FullName);
            }
        }

        /// <summary>
        /// Gets the full path of the archive.
        /// </summary>
        /// <returns>The full path of the archive.</returns>
        public override string ToString()
        {
            return this.FullName;
        }

        /// <summary>
        /// Deletes the archive.
        /// </summary>
        public override void Delete()
        {
            File.Delete(this.FullName);
        }

        /// <summary>
        /// Copies an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName)
        {
            File.Copy(this.FullName, destFileName);
        }

        /// <summary>
        /// Copies an existing archive to another location, optionally
        /// overwriting the destination file.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        /// <param name="overwrite">If true, the destination file will be
        /// overwritten if it exists.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void CopyTo(string destFileName, bool overwrite)
        {
            File.Copy(this.FullName, destFileName, overwrite);
        }
        
        /// <summary>
        /// Moves an existing archive to another location.
        /// </summary>
        /// <param name="destFileName">The destination file path.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void MoveTo(string destFileName)
        {
            File.Move(this.FullName, destFileName);
            this.FullPath = Path.GetFullPath(destFileName);
        }

        /// <summary>
        /// Checks if the archive contains a valid archive header.
        /// </summary>
        /// <returns>True if the file is a valid archive; false otherwise.</returns>
        public bool IsValid()
        {
            using (Stream stream = File.OpenRead(this.FullName))
            {
                using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
                {
                    return compressionEngine.FindArchiveOffset(stream) >= 0;
                }
            }
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles()
        {
            return this.InternalGetFiles((Predicate<string>) null);
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public IList<ArchiveFileInfo> GetFiles(string searchPattern)
        {
            if (searchPattern == null)
            {
                throw new ArgumentNullException("searchPattern");
            }

            string regexPattern = String.Format(
                CultureInfo.InvariantCulture,
                "^{0}$",
                Regex.Escape(searchPattern).Replace("\\*", ".*").Replace("\\?", "."));
            Regex regex = new Regex(
                    regexPattern,
                    RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

            return this.InternalGetFiles(
                delegate(string match)
                {
                    return regex.IsMatch(match);
                });
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(string destDirectory)
        {
            this.Unpack(destDirectory, null);
        }

        /// <summary>
        /// Extracts all files from an archive to a destination directory,
        /// optionally extracting only newer files.
        /// </summary>
        /// <param name="destDirectory">Directory where the files are to be
        /// extracted.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void Unpack(
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, null);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(streamContext, null);
            }
        }

        /// <summary>
        /// Extracts a single file from the archive.
        /// </summary>
        /// <param name="fileName">The name of the file in the archive. Also
        /// includes the internal path of the file, if any. File name matching
        /// is case-insensitive.</param>
        /// <param name="destFileName">The path where the file is to be
        /// extracted on disk.</param>
        /// <remarks>If <paramref name="destFileName"/> already exists,
        /// it will be overwritten.</remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFile(string fileName, string destFileName)
        {
            if (fileName == null)
            {
                throw new ArgumentNullException("fileName");
            }

            if (destFileName == null)
            {
                throw new ArgumentNullException("destFileName");
            }

            this.UnpackFiles(
                new string[] { fileName },
                null,
                new string[] { destFileName });
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames)
        {
            this.UnpackFiles(fileNames, destDirectory, destFileNames, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive, optionally extracting
        /// only newer files.
        /// </summary>
        /// <param name="fileNames">The names of the files in the archive.
        /// Each name includes the internal path of the file, if any. File name
        /// matching is case-insensitive.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative paths in
        /// <paramref name="destFileNames"/>.</param>
        /// <param name="destFileNames">The paths where the files are to be
        /// extracted on disk. If this parameter is null, the files will be
        /// extracted with the names from the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// <p>The <paramref name="destDirectory"/> and
        /// <paramref name="destFileNames"/> parameters cannot both be null.</p>
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFiles(
            IList<string> fileNames,
            string destDirectory,
            IList<string> destFileNames,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            if (destFileNames == null)
            {
                if (destDirectory == null)
                {
                    throw new ArgumentNullException("destFileNames");
                }

                destFileNames = fileNames;
            }

            if (destFileNames.Count != fileNames.Count)
            {
                throw new ArgumentOutOfRangeException("destFileNames");
            }

            IDictionary<string, string> files =
                ArchiveInfo.CreateStringDictionary(fileNames, destFileNames);
            this.UnpackFileSet(files, destDirectory, progressHandler);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal paths
        /// depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external paths
        /// in <paramref name="fileNameMap"/>.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory)
        {
            this.UnpackFileSet(fileNames, destDirectory, null);
        }

        /// <summary>
        /// Extracts multiple files from the archive.
        /// </summary>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths. Case-senstivity when matching internal
        /// paths depends on the IDictionary implementation.</param>
        /// <param name="destDirectory">This parameter may be null, but if
        /// specified it is the root directory for any relative external
        /// paths in <paramref name="fileNameMap"/>.</param>
        /// <param name="progressHandler">Handler for receiving progress
        /// information; this may be null if progress is not desired.</param>
        /// <remarks>
        /// If any extracted files already exist on disk, they will be overwritten.
        /// </remarks>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "dest")]
        public void UnpackFileSet(
            IDictionary<string, string> fileNames,
            string destDirectory,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, destDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.Unpack(
                    streamContext,
                    delegate(string match)
                    {
                        return fileNames.ContainsKey(match);
                    });
            }
        }

        /// <summary>
        /// Compresses all files in a directory into the archive.
        /// Does not include subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">The directory containing the
        /// files to be included.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void Pack(string sourceDirectory)
        {
            this.Pack(sourceDirectory, false, CompressionLevel.Max, null);
        }
        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            IList<string> archiveFiles,
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(archiveFiles, sourceDirectory, files, files, compLevel, progressHandler, maxArchiveSize);
        }

        /// <summary>
        /// Compresses all files in a directory into the archive, optionally
        /// including subdirectories.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="includeSubdirectories">If true, recursively include
        /// files in subdirectories.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// The files are stored in the archive using their relative file paths in
        /// the directory tree, if supported by the archive file format.
        /// </remarks>
        public void Pack(
            string sourceDirectory,
            bool includeSubdirectories,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            IList<string> files = this.GetRelativeFilePathsInDirectoryTree(
                sourceDirectory, includeSubdirectories);
            this.PackFiles(sourceDirectory, files, files, compLevel, progressHandler);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but
        /// if specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored
        /// in the archive. Each name
        /// includes the internal path of the file, if any. This parameter may
        /// be null, in which case the files are stored in the archive with their
        /// source file names and no path information.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// <p>Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.</p>
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames)
        {
            this.PackFiles(
                sourceDirectory,
                sourceFileNames,
                fileNames,
                CompressionLevel.Max,
                null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            IList<string> archiveFiles,
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler,
            long maxArchiveSize)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                
                ArchiveFileStreamContext streamContext;
                if (archiveFiles == null)
                {
                    streamContext = new ArchiveFileStreamContext(
                            this.FullName, sourceDirectory, contextFiles);
                }
                else
                {
                    streamContext = new ArchiveFileStreamContext(
                            archiveFiles, sourceDirectory, contextFiles);
                }
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames, maxArchiveSize);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="sourceFileNames"/>.</param>
        /// <param name="sourceFileNames">The list of files to be included in
        /// the archive.</param>
        /// <param name="fileNames">The names of the files as they are stored in
        /// the archive. Each name includes the internal path of the file, if any.
        /// This parameter may be null, in which case the files are stored in the
        /// archive with their source file names and no path information.</param>
        /// <param name="compLevel">The compression level used when creating the
        /// archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        /// <remarks>
        /// Duplicate items in the <paramref name="fileNames"/> array will cause
        /// an <see cref="ArchiveException"/>.
        /// </remarks>
        public void PackFiles(
            string sourceDirectory,
            IList<string> sourceFileNames,
            IList<string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (sourceFileNames == null)
            {
                throw new ArgumentNullException("sourceFileNames");
            }

            if (fileNames == null)
            {
                string[] fileNamesArray = new string[sourceFileNames.Count];
                for (int i = 0; i < sourceFileNames.Count; i++)
                {
                    fileNamesArray[i] = Path.GetFileName(sourceFileNames[i]);
                }

                fileNames = fileNamesArray;
            }
            else if (fileNames.Count != sourceFileNames.Count)
            {
                throw new ArgumentOutOfRangeException("fileNames");
            }

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                IDictionary<string, string> contextFiles =
                    ArchiveInfo.CreateStringDictionary(fileNames, sourceFileNames);

                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, contextFiles);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNames);
            }
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used
        /// to store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <remarks>
        /// Uses maximum compression level.
        /// </remarks>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames)
        {
            this.PackFileSet(sourceDirectory, fileNames, CompressionLevel.Max, null);
        }

        /// <summary>
        /// Compresses files into the archive, specifying the names used to
        /// store the files in the archive.
        /// </summary>
        /// <param name="sourceDirectory">This parameter may be null, but if
        /// specified it is the root directory
        /// for any relative paths in <paramref name="fileNames"/>.</param>
        /// <param name="fileNames">A mapping from internal file paths to
        /// external file paths.</param>
        /// <param name="compLevel">The compression level used when creating
        /// the archive.</param>
        /// <param name="progressHandler">Handler for receiving progress information;
        /// this may be null if progress is not desired.</param>
        public void PackFileSet(
            string sourceDirectory,
            IDictionary<string, string> fileNames,
            CompressionLevel compLevel,
            EventHandler<ArchiveProgressEventArgs> progressHandler)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }

            string[] fileNamesArray = new string[fileNames.Count];
            fileNames.Keys.CopyTo(fileNamesArray, 0);

            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                compressionEngine.Progress += progressHandler;
                ArchiveFileStreamContext streamContext = new ArchiveFileStreamContext(
                        this.FullName, sourceDirectory, fileNames);
                streamContext.EnableOffsetOpen = true;
                compressionEngine.CompressionLevel = compLevel;
                compressionEngine.Pack(streamContext, fileNamesArray);
            }
        }

        /// <summary>
        /// Given a directory, gets the relative paths of all files in the
        /// directory, optionally including all subdirectories.
        /// </summary>
        /// <param name="dir">The directory to search.</param>
        /// <param name="includeSubdirectories">True to include subdirectories
        /// in the search.</param>
        /// <returns>A list of file paths relative to the directory.</returns>
        internal IList<string> GetRelativeFilePathsInDirectoryTree(
            string dir, bool includeSubdirectories)
        {
            IList<string> fileList = new List<string>();
            this.RecursiveGetRelativeFilePathsInDirectoryTree(
                dir, String.Empty, includeSubdirectories, fileList);
            return fileList;
        }

        /// <summary>
        /// Retrieves information about one file from this archive.
        /// </summary>
        /// <param name="path">Path of the file in the archive.</param>
        /// <returns>File information, or null if the file was not found
        /// in the archive.</returns>
        internal ArchiveFileInfo GetFile(string path)
        {
            IList<ArchiveFileInfo> files = this.InternalGetFiles(
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            return (files != null && files.Count > 0 ? files[0] : null);
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new compression engine instance that matches the specific
        /// subclass of archive.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected abstract CompressionEngine CreateCompressionEngine();

        /// <summary>
        /// Creates a case-insensitive dictionary mapping from one list of
        /// strings to the other.
        /// </summary>
        /// <param name="keys">List of keys.</param>
        /// <param name="values">List of values that are mapped 1-to-1 to
        /// the keys.</param>
        /// <returns>A filled dictionary of the strings.</returns>
        private static IDictionary<string, string> CreateStringDictionary(
            IList<string> keys, IList<string> values)
        {
            IDictionary<string, string> stringDict =
                new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < keys.Count; i++)
            {
                stringDict.Add(keys[i], values[i]);
            }

            return stringDict;
        }

        /// <summary>
        /// Recursive-descent helper function for
        /// GetRelativeFilePathsInDirectoryTree.
        /// </summary>
        /// <param name="dir">The root directory of the search.</param>
        /// <param name="relativeDir">The relative directory to be
        /// processed now.</param>
        /// <param name="includeSubdirectories">True to descend into
        /// subdirectories.</param>
        /// <param name="fileList">List of files found so far.</param>
        private void RecursiveGetRelativeFilePathsInDirectoryTree(
            string dir,
            string relativeDir,
            bool includeSubdirectories,
            IList<string> fileList)
        {
            foreach (string file in System.IO.Directory.GetFiles(dir))
            {
                string fileName = Path.GetFileName(file);
                fileList.Add(Path.Combine(relativeDir, fileName));
            }

            if (includeSubdirectories)
            {
                foreach (string subDir in System.IO.Directory.GetDirectories(dir))
                {
                    string subDirName = Path.GetFileName(subDir);
                    this.RecursiveGetRelativeFilePathsInDirectoryTree(
                        Path.Combine(dir, subDirName),
                        Path.Combine(relativeDir, subDirName),
                        includeSubdirectories,
                        fileList);
                }
            }
        }

        /// <summary>
        /// Uses a CompressionEngine to get ArchiveFileInfo objects from this
        /// archive, and then associates them with this ArchiveInfo instance.
        /// </summary>
        /// <param name="fileFilter">Optional predicate that can determine
        /// which files to process.</param>
        /// <returns>A list of <see cref="ArchiveFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        private IList<ArchiveFileInfo> InternalGetFiles(Predicate<string> fileFilter)
        {
            using (CompressionEngine compressionEngine = this.CreateCompressionEngine())
            {
                ArchiveFileStreamContext streamContext =
                    new ArchiveFileStreamContext(this.FullName, null, null);
                streamContext.EnableOffsetOpen = true;
                IList<ArchiveFileInfo> files =
                    compressionEngine.GetFileInfo(streamContext, fileFilter);
                for (int i = 0; i < files.Count; i++)
                {
                    files[i].Archive = this;
                }

                return files;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Settings.cs ===
﻿using System.Globalization;
//-----------------------------------------------------------------------
// <copyright file="Settings.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    
    public enum Command
    {
        All = 0,
        Create,
        Submit,
        Check
    }
    
    public class Settings
    {
        private const long twoGigs = 2146435072;
        private const int lengthTitleId = 8;
        private const int lengthContentId = 40;
        private const int lengthOfferId = 16;

        private bool quiet;

        private Command inputCommand;
        //private string codeSignFileName;
        private string srcFileName;
        private string dstFileName;
        //private string codeSignJobNumber;
        //private string codeSignCompletionPath;
        private long maxCabSize;
        private string titleID;
        private string contentID;
        private string offerID;
        private string contentType;
        private string contentURL;
        private string inputFolder;
        private string unSignedCabPath;
        private string contentFilePath;
        private string currentWorkingDirectory;
        private string tempDirectory;
        private int compressionLevel;
        private bool nooverwritexbx;
        //private IList<string> signers;
        //private string largeFileCertID;
        //private string normalFileCertID;
        //private string strongNameCertID;

        public Settings()
        {
            quiet = false;
            inputCommand = Command.All;
            //signers = new List<string>();
            //largeFileCertID = @"10038";
            //normalFileCertID = @"10006";
            //strongNameCertID = @"";
            //codeSignJobNumber = @"";
            //codeSignCompletionPath = @"";
            //codeSignFileName = @"";
            maxCabSize = Settings.twoGigs;    // default = 2G - 1MB
            contentFilePath = @"\\xsinfxferinh001\Content\";
            contentURL = @"\\xsinfxferinh001\Content\";
            this.currentWorkingDirectory = Directory.GetCurrentDirectory();
            srcFileName = @"";
            dstFileName = @"";
        }

        public bool Quiet
        {
            get { return this.quiet; }
        }

        public Command InputCommand
        {
            get { return this.inputCommand; }
        }

        public string SrcFileName
        {
            get { return this.srcFileName; }
        }

        public int CompressionLevel
        {
            get { return compressionLevel; }
        }

        public bool Nooverwritexbx
        {
            get { return nooverwritexbx; }
        }

        public string DstFileName
        {
            get { return this.dstFileName; }
        }
        /*
        public string CodeSignFileName
        {
            get { return this.codeSignFileName; }
        }

        public string CodeSignJobNumber
        {
            get { return this.codeSignJobNumber; }
        }

        public string CodeSignCompletionPath
        {
            get { return this.codeSignCompletionPath; }
        }
        public IList<string> Signers
        {
            get { return this.signers; }
        }
        public string LargeFileCertID
        {
            get { return this.largeFileCertID; }
        }

        public string NormalFileCertID
        {
            get { return this.normalFileCertID; }
        }

        public string StrongNameCertID
        {
            get { return this.strongNameCertID; }
        }
        */
        public long MaxCabSize
        {
            get { return this.maxCabSize; }
        }

        public string InputFolder
        {
            get { return this.inputFolder; }
        }
        public string TitleID
        {
            get { return this.titleID; }
        }
        public string OfferID
        {
            get { return this.offerID; }
        }
        public string ContentID
        {
            get { return this.contentID; }
        }
        public string ContentType
        {
            get { return this.contentType; }
        }
        public string ContentFilePath
        {
            get { return this.contentFilePath; }
        }
        public string ContentURL
        {
            get { return this.contentURL; }
        }
        public string CurrentWorkingDirectory
        {
            get { return this.currentWorkingDirectory; }
        }
        public string TempDirectory
        {
            get { return this.tempDirectory; }
        }
        public string UnSignedCabPath
        {
            get { return this.unSignedCabPath; }
        }

        public static void DisplayUsage()
        {
            Log.WriteLog("\nCreates and props full game content files for Windows - LIVE title");
            Log.WriteLog(string.Empty);
            Log.WriteLog("Usage: LFIT.exe [command] /inputFolder <inputFolder> /titleId <TitleID> /contentId <ContentID> /offerId <OfferID> /contentType <ContentType> /unsignedCabPath <UnsignedCabPath> [/maxCabSize <maxCabSize>] [/contentURL <ContentURL>] [/compressionLevel <CompressionLevel>]");
            Log.WriteLog(string.Empty);
            Log.WriteLog("\t[command]\tcreate - create content and manifest cabs\n");
            Log.WriteLog("\t/q\t\t\tQuiet mode. No output displayed\n");
            Log.WriteLog("\t/inputFolder\t\tThe folder containing all of the full game files\n");
            Log.WriteLog("\t/titleId\t\tThe 8-char Title ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentId\t\tThe Content ID to be assigned to the spanned cabs\n");
            Log.WriteLog("\t/offerId\t\tThe full Offer ID for the game without the hex prefix (0x)\n");
            Log.WriteLog("\t/contentType\t\tCan be 0x00007000 (for FullGame) or 0x00080000 (for GameDemo)\n");
            Log.WriteLog("\t/maxCabSize\t\tThe maximum size of one cab file (in megabyte)\n\t\t\t\tDefault: 2048\n");
            Log.WriteLog("\t/unsignedCabPath\tThe folder to where the unsigned spanned CABs will be dropped\n");
            Log.WriteLog("\t/contentURL\t\tThe CDN location from which the spanned CABs can be reached\n\t\t\t\tDefault: \\\\xsinfxferinh001\\Content\n");
            Log.WriteLog("\t/compressionLevel\tCompression level number between 0 to 10. 0 = none and fast. 10 = max and slow. Defaults to 10.\n");
            Log.WriteLog("\t/nooverwritexbx\t\tLFIT will not overwrite or create a content.xbx.  It uses the existing one in the input folder\n");
            //Log.WriteLog("\t\t\tsubmit - submit one cab for CodeSign\n");
            //Log.WriteLog("\t\t\t\t  /fileName <FileName> /signer <Alias1> /signer <Alias2>\n");
            //Log.WriteLog("\t\t\tcheck - check CodeSign result\n");
            //Log.WriteLog("\t\t\t\t  /codeSignJobNumber <CodeSignJobNumber> \n");
            //Log.WriteLog("\t/signer \t\tRepeat input once for each person who can approve the request\n");
            //Log.WriteLog("\t/largeFileCertID\tCertificate ID used to sign files bigger than 500M\n\t\t\t\tDefault: 10038\n");
            //Log.WriteLog("\t/normalFileCertID\tCertificate ID used to sign files less than 500M\n\t\t\t\tDefault: 10006\n");
            //Log.WriteLog("\t/strongNameCertID\tCertificate ID used to sign files with strong name\n\t\t\t\tDefault: not used\n");
        }

        public void ParseCommandLine(string[] args)
        {
            this.tempDirectory = Path.Combine(System.IO.Path.GetTempPath(), @"LFIT");

            for (int i = 0; i < args.Length; i++)
            {
                string arg = args[i];
                if (arg[0] == '-' || arg[0] == '/')
                {
                    arg = arg.Remove(0, 1);
                    if (string.Compare(arg, "q", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.quiet = true;
                    }
                    else if (string.Compare(arg, "MaxCabSize", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.maxCabSize = Convert.ToInt64(args[i]) * 1048576;
                            if( this.maxCabSize > Settings.twoGigs )
                            {
                                throw new ArgumentException("Cab size too large.  2047MB is max", "/MaxCabSize");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing cab size", "/MaxCabSize");
                        }
                    }
                    else if (string.Compare(arg, "nooverwritexbx", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.nooverwritexbx = true;
                    }
                    else if (string.Compare(arg, "compressionLevel", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            try
                            {
                                this.compressionLevel = Int32.Parse(args[i]);
                                if (this.compressionLevel < 0 || this.compressionLevel > 10)
                                {
                                    throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                                }
                            }
                            catch (System.Exception)
                            {
                                throw new ArgumentException("Invalid compressionLevel", "/compressionLevel");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing compressionLevel", "/compressionLevel");
                        }
                    }
                    else if (string.Compare(arg, "inputFolder", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.inputFolder = args[i];
                            this.inputFolder = Settings.UnquoteString(this.inputFolder);
                        }
                        else
                        {
                            throw new ArgumentException("Missing input folder", "/inputFolder");
                        }
                    }
                    else if (string.Compare(arg, "titleID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.titleID = args[i];
                            ValidateHexParameter(this.titleID, lengthTitleId, "titleID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing title ID", "/titleID");
                        }
                    }
                    else if (string.Compare(arg, "contentID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentID = args[i];
                            ValidateHexParameter(this.contentID, lengthContentId, "contentID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing content ID", "/contentID");
                        }
                    }
                    else if (string.Compare(arg, "offerID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.offerID = args[i];
                            ValidateHexParameter(this.offerID, lengthOfferId, "offerID");
                        }
                        else
                        {
                            throw new ArgumentException("Missing offer ID", "/offerID");
                        }
                    }
                    else if (string.Compare(arg, "contentType", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentType = args[i];
                            if (string.Compare( this.ContentType, "0x00080000", StringComparison.OrdinalIgnoreCase ) != 0 &&
                                string.Compare( this.ContentType, "0x00007000", StringComparison.OrdinalIgnoreCase ) != 0) 
                            {
                                throw new ArgumentException("Invalid content type", "/contentType");
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Missing content type", "/contentType");
                        }
                    }
                    else if (string.Compare(arg, "contentFilePath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentFilePath = args[i];
                            this.contentFilePath = Settings.UnquoteString(this.contentFilePath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content file path", "/contentFilePath");
                        }
                    }
                    else if (string.Compare(arg, "unsignedCabPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.unSignedCabPath = args[i];
                            this.unSignedCabPath = Settings.UnquoteString(this.unSignedCabPath);
                        }
                        else
                        {
                            throw new ArgumentException("Missing unsigned cab files save path", "/unsignedCabPath");
                        }
                    }
                    else if (string.Compare(arg, "contentURL", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.contentURL = args[i];
                            this.contentURL = Settings.UnquoteString(this.contentURL);

                            Log.WriteLog("ContentURL: " + this.contentURL);
                        }
                        else
                        {
                            throw new ArgumentException("Missing content URL", "/contentURL");
                        }
                    }
/*
                    else if (string.Compare(arg, "signer", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.signers.Add(args[i].ToUpper());
                        }
                        else
                        {
                            throw new ArgumentException("Missing CodeSign signer", "/signer");
                        }
                    }
                    else if (string.Compare(arg, "largeFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.largeFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the larger certificate ID", "/largeFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "normalFileCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.normalFileCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the normal certificate ID", "/normalFileCertID");
                        }
                    }
                    else if (string.Compare(arg, "strongNameCertID", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.strongNameCertID = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the strong name certificate ID", "/strongNameCertID");
                        }
                    }  
                    else if (string.Compare(arg, "fileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignFileName = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing the file name", "/fileName");
                        }
                    }

                    else if (string.Compare(arg, "codeSignJobNumber", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignJobNumber = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign job number", "/codeSignJobNumber");
                        }
                    }
                    else if (string.Compare(arg, "codeSignCompletionPath", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.codeSignCompletionPath = args[i];
                        }
                        else
                        {
                            throw new ArgumentException("Missing code sign completion path", "/codeSignCompletionPath");
                        }
                    }
 */ 
                    else if (string.Compare(arg, "srcFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.srcFileName = args[i];
                            this.srcFileName = Settings.UnquoteString(this.srcFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the source file name", "/srcFileName");
                        }
                    }
                    else if (string.Compare(arg, "dstFileName", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        if (i + 1 < args.Length)
                        {
                            i++;
                            this.dstFileName = args[i];
                            this.dstFileName = Settings.UnquoteString(this.dstFileName);
                        }
                        else
                        {
                            throw new ArgumentException("Missing the destination file name", "/dstFileName");
                        }
                    }
                    else if (string.Compare(arg, "?", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        throw new ArgumentException("Display help", "-?");
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }
                else
                {
                    if (string.Compare(arg, "create", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Create;
                    }
                    else if (string.Compare(arg, "submit", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Submit;
                    }
                    else if (string.Compare(arg, "check", true, System.Globalization.CultureInfo.InvariantCulture) == 0)
                    {
                        this.inputCommand = Command.Check;
                    }
                    else
                    {
                        throw new ArgumentException("Unknown arg", arg);
                    }
                }

            }

            if (string.IsNullOrEmpty(this.contentFilePath))
            {
                this.contentFilePath = @"\\xsinfxferinh001\Content";
            }
            if (string.IsNullOrEmpty(this.contentURL))
            {
                this.contentURL = @"\\xsinfxferinh001\Content";
            }

            if( this.inputCommand != Command.Create )
            {
                throw new ArgumentException("Command must be create", "command");
            }

            // justify the input
            switch (this.inputCommand)
            {
                case Command.All:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }
/*
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }
 
                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }

                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
*/
                    break;
                }
                case Command.Create:
                {
                    if (string.IsNullOrEmpty(this.inputFolder))
                    {
                        throw new ArgumentException("Missing input folder path", "/inputFolder");
                    }

                    if (string.IsNullOrEmpty(this.titleID))
                    {
                        throw new ArgumentException("Missing title ID", "/titleID");
                    }

                    if (string.IsNullOrEmpty(this.contentID))
                    {
                        throw new ArgumentException("Missing content ID", "/contentID");
                    }

                    if (string.IsNullOrEmpty(this.offerID))
                    {
                        throw new ArgumentException("Missing offer ID", "/offerID");
                    }

                    if (string.IsNullOrEmpty(this.contentType))
                    {
                        throw new ArgumentException("Missing content type", "/contentType");
                    }

                    if (string.IsNullOrEmpty(this.unSignedCabPath))
                    {
                        throw new ArgumentException("Missing unsigned cab file save path", "/unSignedCabPath");
                    }

                    // The first 8 digit in offer id should be title id
                    if (!this.offerID.StartsWith(this.titleID, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new ArgumentException("offerID and titleID does not match", "/offerID");
                    }

                    break;
                }
/*
                case Command.Submit:
                {
                    if (string.IsNullOrEmpty(this.CodeSignFileName))
                    {
                        throw new ArgumentException("Missing the input file name", "/fileName");
                    }

                    if (this.signers.Count < 2)
                    {
                        throw new ArgumentException("Missing CodeSign approvers", "/signer");
                    }
                    break;
                }

                case Command.Check:
                {
                    if (string.IsNullOrEmpty(this.codeSignJobNumber))
                    {
                        throw new ArgumentException("Missing the input job number", "/codeSignJobNumber");
                    }
                    break;
                }
*/
            }

        }

        private static string UnquoteString(string input)
        {
            bool quotedString = false;
            if (input.EndsWith("\"") || input.StartsWith("\""))
            {
                quotedString = true;
            }

            if (quotedString)
            {
                // Remove quotes
                if (input.EndsWith("\""))
                {
                    input = input.Substring(0, input.Length - 1);
                }

                if (input.StartsWith("\""))
                {
                    input = input.Substring(1, input.Length - 1);
                }
            }

            return input;
        }

        private void ValidateHexParameter(string hexString, int expectedLength, string paramName)
        {
            if (hexString.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
            {
                throw new ArgumentException(string.Format("{0} should not start with 0x.", paramName), string.Format("/{0}", paramName));
            }
            else if (hexString.Length != expectedLength)
            {
                throw new ArgumentException(string.Format("{0} should be in the length of {1}.", paramName, expectedLength), string.Format("/{0}", paramName));
            }
            else if (!IsHexString(hexString))
            {
                throw new ArgumentException(string.Format("{0} is not a valid hexadecimal string", paramName), string.Format("/{0}", paramName));
            }
        }

        private bool IsHexString(string hexString)
        {
            Regex hexRegex = new Regex("^[0-9a-fA-F]+$", RegexOptions.CultureInvariant | RegexOptions.Compiled);
            return hexRegex.IsMatch(hexString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\ArchiveProgressEventArgs.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveProgressEventArgs.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.Collections.Generic;
using System.Text;

    /// <summary>
    /// Contains the data reported in an archive progress event.
    /// </summary>
    public class ArchiveProgressEventArgs : EventArgs
    {
        private ArchiveProgressType progressType;

        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;

        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;

        private long fileBytesProcessed;
        private long totalFileBytes;

        /// <summary>
        /// Creates a new ArchiveProgressEventArgs object from specified event parameters.
        /// </summary>
        /// <param name="progressType">type of status message</param>
        /// <param name="currentFileName">name of the file being processed</param>
        /// <param name="currentFileNumber">number of the current file being processed</param>
        /// <param name="totalFiles">total number of files to be processed</param>
        /// <param name="currentFileBytesProcessed">number of bytes processed so far when compressing or extracting a file</param>
        /// <param name="currentFileTotalBytes">total number of bytes in the current file</param>
        /// <param name="currentArchiveName">name of the current Archive</param>
        /// <param name="currentArchiveNumber">current Archive number, when processing a chained set of Archives</param>
        /// <param name="totalArchives">total number of Archives in a chained set</param>
        /// <param name="currentArchiveBytesProcessed">number of compressed bytes processed so far during an extraction</param>
        /// <param name="currentArchiveTotalBytes">total number of compressed bytes to be processed during an extraction</param>
        /// <param name="fileBytesProcessed">number of uncompressed file bytes processed so far</param>
        /// <param name="totalFileBytes">total number of uncompressed file bytes to be processed</param>
        public ArchiveProgressEventArgs(
            ArchiveProgressType progressType,
            string currentFileName,
            int currentFileNumber,
            int totalFiles,
            long currentFileBytesProcessed,
            long currentFileTotalBytes,
            string currentArchiveName,
            int currentArchiveNumber,
            int totalArchives,
            long currentArchiveBytesProcessed,
            long currentArchiveTotalBytes,
            long fileBytesProcessed,
            long totalFileBytes)
        {
            this.progressType = progressType;
            this.currentFileName = currentFileName;
            this.currentFileNumber = currentFileNumber;
            this.totalFiles = totalFiles;
            this.currentFileBytesProcessed = currentFileBytesProcessed;
            this.currentFileTotalBytes = currentFileTotalBytes;
            this.currentArchiveName = currentArchiveName;
            this.currentArchiveNumber = (short) currentArchiveNumber;
            this.totalArchives = (short) totalArchives;
            this.currentArchiveBytesProcessed = currentArchiveBytesProcessed;
            this.currentArchiveTotalBytes = currentArchiveTotalBytes;
            this.fileBytesProcessed = fileBytesProcessed;
            this.totalFileBytes = totalFileBytes;
        }

        /// <summary>
        /// Gets the type of status message.
        /// </summary>
        /// <value>A <see cref="ArchiveProgressType"/> value indicating what type of progress event occurred.</value>
        /// <remarks>
        /// The handler may choose to ignore some types of progress events.
        /// For example, if the handler will only list each file as it is
        /// compressed/extracted, it can ignore events that
        /// are not of type <see cref="ArchiveProgressType.FinishFile"/>.
        /// </remarks>
        public ArchiveProgressType ProgressType
        {
            get
            {
                return this.progressType;
            }
        }

        /// <summary>
        /// Gets the name of the file being processed. (The name of the file within the Archive; not the external
        /// file path.) Also includes the internal path of the file, if any.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The name of the file currently being processed, or null if processing
        /// is currently at the stream or archive level.</value>
        public string CurrentFileName
        {
            get
            {
                return this.currentFileName;
            }
        }

        /// <summary>
        /// Gets the number of the current file being processed. The first file is number 0, and the last file
        /// is <see cref="TotalFiles"/>-1. Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of the file currently being processed, or the most recent
        /// file processed if processing is currently at the stream or archive level.</value>
        public int CurrentFileNumber
        {
            get
            {
                return this.currentFileNumber;
            }
        }

        /// <summary>
        /// Gets the total number of files to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of files to be processed that are known so far.</value>
        public int TotalFiles
        {
            get
            {
                return this.totalFiles;
            }
        }

        /// <summary>
        /// Gets the number of bytes processed so far when compressing or extracting a file.  Valid for
        /// <see cref="ArchiveProgressType.StartFile"/>, <see cref="ArchiveProgressType.PartialFile"/>,
        /// and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The number of uncompressed bytes processed so far for the current file,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileBytesProcessed
        {
            get
            {
                return this.currentFileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of bytes in the current file.  Valid for <see cref="ArchiveProgressType.StartFile"/>,
        /// <see cref="ArchiveProgressType.PartialFile"/>, and <see cref="ArchiveProgressType.FinishFile"/> messages.
        /// </summary>
        /// <value>The uncompressed size of the current file being processed,
        /// or 0 if processing is currently at the stream or archive level.</value>
        public long CurrentFileTotalBytes
        {
            get
            {
                return this.currentFileTotalBytes;
            }
        }

        /// <summary>
        /// Gets the name of the current archive.  Not necessarily the name of the archive on disk.
        /// Valid for all message types.
        /// </summary>
        /// <value>The name of the current archive, or an empty string if no name was specified.</value>
        public string CurrentArchiveName
        {
            get
            {
                return this.currentArchiveName;
            }
        }

        /// <summary>
        /// Gets the current archive number, when processing a chained set of archives. Valid for all message types.
        /// </summary>
        /// <value>The number of the current archive.</value>
        /// <remarks>The first archive is number 0, and the last archive is
        /// <see cref="TotalArchives"/>-1.</remarks>
        public int CurrentArchiveNumber
        {
            get
            {
                return this.currentArchiveNumber;
            }
        }

        /// <summary>
        /// Gets the total number of known archives in a chained set. Valid for all message types.
        /// </summary>
        /// <value>The total number of known archives in a chained set.</value>
        /// <remarks>
        /// When using the compression option to auto-split into multiple archives based on data size,
        /// this value will not be accurate until the end.
        /// </remarks>
        public int TotalArchives
        {
            get
            {
                return this.totalArchives;
            }
        }

        /// <summary>
        /// Gets the number of compressed bytes processed so far during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The number of compressed bytes processed so far during extraction
        /// of the current archive.</value>
        public long CurrentArchiveBytesProcessed
        {
            get
            {
                return this.currentArchiveBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of compressed bytes to be processed during extraction
        /// of the current archive. Valid for all extraction messages.
        /// </summary>
        /// <value>The total number of compressed bytes to be processed during extraction
        /// of the current archive.</value>
        public long CurrentArchiveTotalBytes
        {
            get
            {
                return this.currentArchiveTotalBytes;
            }
        }

        /// <summary>
        /// Gets the number of uncompressed bytes processed so far among all files. Valid for all message types.  
        /// </summary>
        /// <value>The number of uncompressed file bytes processed so far among all files.</value>
        /// <remarks>
        /// When compared to <see cref="TotalFileBytes"/>, this can be used as a measure of overall progress.
        /// </remarks>
        public long FileBytesProcessed
        {
            get
            {
                return this.fileBytesProcessed;
            }
        }

        /// <summary>
        /// Gets the total number of uncompressed file bytes to be processed.  Valid for all message types.
        /// </summary>
        /// <value>The total number of uncompressed bytes to be processed among all files.</value>
        public long TotalFileBytes
        {
            get
            {
                return this.totalFileBytes;
            }
        }

#if DEBUG

    /// <summary>
    /// Creates a string representation of the progress event.
    /// </summary>
    /// <returns>a listing of all event parameters and values</returns>
    public override string ToString()
    {
        string formatString =
            "{0}\n" +
            "\t CurrentFileName              = {1}\n" +
            "\t CurrentFileNumber            = {2}\n" +
            "\t TotalFiles                   = {3}\n" +
            "\t CurrentFileBytesProcessed    = {4}\n" +
            "\t CurrentFileTotalBytes        = {5}\n" +
            "\t CurrentArchiveName           = {6}\n" +
            "\t CurrentArchiveNumber         = {7}\n" +
            "\t TotalArchives                = {8}\n" +
            "\t CurrentArchiveBytesProcessed = {9}\n" +
            "\t CurrentArchiveTotalBytes     = {10}\n" +
            "\t FileBytesProcessed           = {11}\n" +
            "\t TotalFileBytes               = {12}\n";
        return String.Format(
            System.Globalization.CultureInfo.InvariantCulture,
            formatString,
            this.ProgressType,
            this.CurrentFileName,
            this.CurrentFileNumber,
            this.TotalFiles,
            this.CurrentFileBytesProcessed,
            this.CurrentFileTotalBytes,
            this.CurrentArchiveName,
            this.CurrentArchiveNumber,
            this.TotalArchives,
            this.CurrentArchiveBytesProcessed,
            this.CurrentArchiveTotalBytes,
            this.FileBytesProcessed,
            this.TotalFileBytes);
    }

#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\HandleManager.cs ===
//---------------------------------------------------------------------
// <copyright file="HandleManager.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Generic class for managing allocations of integer handles
    /// for objects of a certain type.
    /// </summary>
    /// <typeparam name="T">The type of objects the handles refer to.</typeparam>
    internal sealed class HandleManager<T> where T : class
    {
        /// <summary>
        /// Auto-resizing list of objects for which handles have been allocated.
        /// Each handle is just an index into this list. When a handle is freed,
        /// the list item at that index is set to null.
        /// </summary>
        private List<T> handles;

        /// <summary>
        /// Creates a new HandleManager instance.
        /// </summary>
        public HandleManager()
        {
            this.handles = new List<T>();
        }

        /// <summary>
        /// Gets the object of a handle, or null if the handle is invalid.
        /// </summary>
        /// <param name="handle">The integer handle previously allocated
        /// for the desired object.</param>
        /// <returns>The object for which the handle was allocated.</returns>
        public T this[int handle]
        {
            get
            {
                if (handle > 0 && handle <= this.handles.Count)
                {
                    return this.handles[handle - 1];
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Allocates a new handle for an object.
        /// </summary>
        /// <param name="obj">Object that the handle will refer to.</param>
        /// <returns>New handle that can be later used to retrieve the object.</returns>
        public int AllocHandle(T obj)
        {
            this.handles.Add(obj);
            int handle = this.handles.Count;
            return handle;
        }

        /// <summary>
        /// Frees a handle that was previously allocated. Afterward the handle
        /// will be invalid and the object it referred to can no longer retrieved.
        /// </summary>
        /// <param name="handle">Handle to be freed.</param>
        public void FreeHandle(int handle)
        {
            if (handle > 0 && handle <= this.handles.Count)
            {
                this.handles[handle - 1] = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ConcatStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ConcatStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;

    /// <summary>
    /// Used to trick a DeflateStream into reading from or writing to
    /// a series of (chunked) streams instead of a single steream.
    /// </summary>
    internal class ConcatStream : Stream
    {
        private Stream source;
        private long position;
        private long length;
        private Action<ConcatStream> nextStreamHandler;

        public ConcatStream(Action<ConcatStream> nextStreamHandler)
        {
            if (nextStreamHandler == null)
            {
                throw new ArgumentNullException("nextStreamHandler");
            }

            this.nextStreamHandler = nextStreamHandler;
            this.length = Int64.MaxValue;
        }

        public Stream Source
        {
            get { return this.source; }
            set { this.source = value; }
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override bool CanWrite
        {
            get { return true; }
        }

        public override bool CanSeek
        {
            get { return false; }
        }

        public override long Length
        {
            get
            {
                return this.length;
            }
        }

        public override long Position
        {
            get { return this.position; }
            set { throw new NotSupportedException(); }
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            count = (int) Math.Min(count, this.length - this.position);

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    this.source.Length - this.source.Position);

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                partialCount = this.source.Read(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }

            return count;
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this.source == null)
            {
                this.nextStreamHandler(this);
            }

            int bytesRemaining = count;
            while (bytesRemaining > 0)
            {
                if (this.source == null)
                {
                    throw new InvalidOperationException();
                }

                int partialCount = (int) Math.Min(bytesRemaining,
                    Math.Max(0, this.length - this.source.Position));

                if (partialCount == 0)
                {
                    this.nextStreamHandler(this);
                    continue;
                }

                this.source.Write(
                    buffer, offset + count - bytesRemaining, partialCount);
                bytesRemaining -= partialCount;
                this.position += partialCount;
            }
        }

        public override void Flush()
        {
            if (this.source != null)
            {
                this.source.Flush();
            }
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        public override void SetLength(long value)
        {
            this.length = value;
        }

        public override void Close()
        {
            if (this.source != null)
            {
                this.source.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipCompressionMethod.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipCompressionMethod.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Identifies the compression method or &quot;algorithm&quot;
    /// used for a single file within a zip archive.
    /// </summary>
    /// <remarks>
    /// Proprietary zip implementations may define additional compression
    /// methods outside of those included here.
    /// </remarks>
    public enum ZipCompressionMethod
    {
        /// <summary>
        /// The file is stored (no compression)
        /// </summary>
        Store = 0,
        
        /// <summary>
        /// The file is Shrunk
        /// </summary>
        Shrink = 1,
        
        /// <summary>
        /// The file is Reduced with compression factor 1
        /// </summary>
        Reduce1 = 2,

        /// <summary>
        /// The file is Reduced with compression factor 2
        /// </summary>
        Reduce2 = 3,

        /// <summary>
        /// The file is Reduced with compression factor 3
        /// </summary>
        Reduce3 = 4,

        /// <summary>
        /// The file is Reduced with compression factor 4
        /// </summary>
        Reduce4 = 5,
        
        /// <summary>
        /// The file is Imploded
        /// </summary>
        Implode = 6,
        
        /// <summary>
        /// The file is Deflated;
        /// the most common and widely-compatible form of zip compression.
        /// </summary>
        Deflate = 8,
        
        /// <summary>
        /// The file is Deflated using the enhanced Deflate64 method.
        /// </summary>
        Deflate64 = 9,

        /// <summary>
        /// The file is compressed using the BZIP2 algorithm.
        /// </summary>
        BZip2 = 12,

        /// <summary>
        /// The file is compressed using the LZMA algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lzma")]
        Lzma = 14,

        /// <summary>
        /// The file is compressed using the PPMd algorithm.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ppmd")]
        Ppmd = 98
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipException.cs ===
//---------------------------------------------------------------------
// <copyright file="ZipException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Resources;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.Serialization;

    /// <summary>
    /// Exception class for zip operations.
    /// </summary>
    [Serializable]
    public class ZipException : ArchiveException
    {
        /// <summary>
        /// Creates a new ZipException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ZipException(string message, Exception innerException)
            : base(message, innerException) { }

        /// <summary>
        /// Creates a new ZipException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ZipException(string message)
            : this(message, null) { }

        /// <summary>
        /// Creates a new ZipException.
        /// </summary>
        public ZipException()
            : this(null, null) { }

        /// <summary>
        /// Initializes a new instance of the ZipException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the exception.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipFileInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFileInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <summary>
    /// Object representing a compressed file within a zip package; provides operations for getting
    /// the file properties and extracting the file.
    /// </summary>
    [Serializable]
    public class ZipFileInfo : ArchiveFileInfo
    {
        private long compressedLength;
        private ZipCompressionMethod compressionMethod;

        /// <summary>
        /// Creates a new ZipFileInfo object representing a file within a zip in a specified path.
        /// </summary>
        /// <param name="zipInfo">An object representing the zip archive containing the file.</param>
        /// <param name="filePath">The path to the file within the zip archive. Usually, this is a simple file
        /// name, but if the zip archive contains a directory structure this may include the directory.</param>
        public ZipFileInfo(ZipInfo zipInfo, string filePath)
            : base(zipInfo, filePath)
        {
            if (zipInfo == null)
            {
                throw new ArgumentNullException("zipInfo");
            }
        }

        /// <summary>
        /// Creates a new ZipFileInfo object with all parameters specified,
        /// used internally when reading the metadata out of a zip archive.
        /// </summary>
        /// <param name="filePath">The internal path and name of the file in the zip archive.</param>
        /// <param name="zipNumber">The zip archive number where the file starts.</param>
        /// <param name="attributes">The stored attributes of the file.</param>
        /// <param name="lastWriteTime">The stored last write time of the file.</param>
        /// <param name="length">The uncompressed size of the file.</param>
        /// <param name="compressedLength">The compressed size of the file.</param>
        /// <param name="compressionMethod">Compression algorithm used for this file.</param>
        internal ZipFileInfo(
            string filePath,
            int zipNumber,
            FileAttributes attributes,
            DateTime lastWriteTime,
            long length,
            long compressedLength,
            ZipCompressionMethod compressionMethod)
            : base(filePath, zipNumber, attributes, lastWriteTime, length)
        {
            this.compressedLength = compressedLength;
            this.compressionMethod = compressionMethod;
        }

        /// <summary>
        /// Initializes a new instance of the ZipFileInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipFileInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            this.compressedLength = info.GetInt64("compressedLength");
        }

        /// <summary>
        /// Gets the compressed size of the file in bytes.
        /// </summary>
        public long CompressedLength
        {
            get
            {
                return this.compressedLength;
            }
        }

        /// <summary>
        /// Gets the method used to compress this file.
        /// </summary>
        public ZipCompressionMethod CompressionMethod
        {
            get
            {
                return this.compressionMethod;
            }
        }

        /// <summary>
        /// Sets the SerializationInfo with information about the archive.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data.</param>
        /// <param name="context">The StreamingContext that contains contextual information
        /// about the source or destination.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("compressedLength", this.compressedLength);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression\CompressionEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CompressionEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;

    /// <summary>
    /// Base class for an engine capable of packing and unpacking a particular
    /// compressed file format.
    /// </summary>
    public abstract class CompressionEngine : IDisposable
    {
        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;

        /// <summary>
        /// Creates a new instance of the compression engine base class.
        /// </summary>
        protected CompressionEngine()
        {
            this.compressionLevel = CompressionLevel.Normal;
        }

        /// <summary>
        /// Disposes the compression engine.
        /// </summary>
        ~CompressionEngine()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Occurs when the compression engine reports progress in packing
        /// or unpacking an archive.
        /// </summary>
        /// <seealso cref="ArchiveProgressType"/>
        public event EventHandler<ArchiveProgressEventArgs> Progress;

        /// <summary>
        /// Gets or sets a flag indicating whether temporary files are created
        /// and used during compression.
        /// </summary>
        /// <value>True if temporary files are used; false if compression is done
        /// entirely in-memory.</value>
        /// <remarks>The value of this property is true by default. Using temporary
        /// files can greatly reduce the memory requirement of compression,
        /// especially when compressing large archives. However, setting this property
        /// to false may yield slightly better performance when creating small
        /// archives. Or it may be necessary if the process does not have sufficient
        /// privileges to create temporary files.</remarks>
        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        /// <summary>
        /// Compression level to use when compressing files.
        /// </summary>
        /// <value>A compression level ranging from minimum to maximum compression,
        /// or no compression.</value>
        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Creates an archive.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive
        /// (not external file paths).</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the
        /// file paths within the archive to the external file paths.
        /// </remarks>
        public void Pack(IPackStreamContext streamContext, IEnumerable<string> files)
        {
            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            this.Pack(streamContext, files, 0);
        }

        /// <summary>
        /// Creates an archive or chain of archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">The paths of the files in the archive (not
        /// external file paths).</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one
        /// archive before the contents are chained to the next archive, or zero
        /// for unlimited archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public abstract void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize);

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid archive
        /// (with no offset); false otherwise.</returns>
        public abstract bool IsArchive(Stream stream);

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public virtual long FindArchiveOffset(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            long sectionSize = 4;
            long length = stream.Length;
            for (long offset = 0; offset <= length - sectionSize; offset += sectionSize)
            {
                stream.Seek(offset, SeekOrigin.Begin);
                if (this.IsArchive(stream))
                {
                    return offset;
                }
            }

            return -1;
        }

        /// <summary>
        /// Gets information about all files in an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>Information about all files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<ArchiveFileInfo> GetFileInfo(Stream stream)
        {
            return this.GetFileInfo(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets information about files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Gets the list of files in an archive Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>A list of the paths of all files contained in the
        /// archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        public IList<string> GetFiles(Stream stream)
        {
            return this.GetFiles(new BasicUnpackStreamContext(stream), null);
        }

        /// <summary>
        /// Gets the list of files in an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>An array containing the names of all files contained in
        /// the archive or archive chain.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public IList<string> GetFiles(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            IList<ArchiveFileInfo> files =
                this.GetFileInfo(streamContext, fileFilter);
            IList<string> fileNames = new List<string>(files.Count);
            for (int i = 0; i < files.Count; i++)
            {
                fileNames.Add(files[i].Name);
            }

            return fileNames;
        }

        /// <summary>
        /// Reads a single file from an archive stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <param name="path">The path of the file within the archive
        /// (not the external file path).</param>
        /// <returns>A stream for reading the extracted file, or null
        /// if the file does not exist in the archive.</returns>
        /// <exception cref="ArchiveException">The stream is not a valid
        /// archive.</exception>
        /// <remarks>The entire extracted file is cached in memory, so this
        /// method requires enough free memory to hold the file.</remarks>
        public Stream Unpack(Stream stream, string path)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            BasicUnpackStreamContext streamContext =
                new BasicUnpackStreamContext(stream);
            this.Unpack(
                streamContext,
                delegate(string match)
                {
                    return String.Compare(
                        match, path, true, CultureInfo.InvariantCulture) == 0;
                });
            
            Stream extractStream = streamContext.FileStream;
            if (extractStream != null)
            {
                extractStream.Position = 0;
            }

            return extractStream;
        }

        /// <summary>
        /// Extracts files from an archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">An optional predicate that can determine
        /// which files to process.</param>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public abstract void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter);

        /// <summary>
        /// Called by sublcasses to distribute a packing or unpacking progress
        /// event to listeners.
        /// </summary>
        /// <param name="e">Event details.</param>
        protected void OnProgress(ArchiveProgressEventArgs e)
        {
            if (this.Progress != null)
            {
                this.Progress(this, e);
            }
        }

        /// <summary>
        /// Disposes of resources allocated by the compression engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called
        /// directly or indirectly by a user's code, so managed and unmanaged
        /// resources will be disposed. If false, the method has been called by
        /// the runtime from inside the finalizer, and only unmanaged resources
        /// will be disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        /// Compresion utility function for converting old-style
        /// date and time values to a DateTime structure.
        /// </summary>
        public static void DosDateAndTimeToDateTime(
            short dosDate, short dosTime, out DateTime dateTime)
        {
            if (dosDate == 0 && dosTime == 0)
            {
                dateTime = DateTime.MinValue;
            }
            else
            {
                long fileTime;
                SafeNativeMethods.DosDateTimeToFileTime(dosDate, dosTime, out fileTime);
                dateTime = DateTime.FromFileTimeUtc(fileTime);
                dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Local);
            }
        }

        /// <summary>
        /// Compresion utility function for converting a DateTime structure
        /// to old-style date and time values.
        /// </summary>
        public static void DateTimeToDosDateAndTime(
            DateTime dateTime, out short dosDate, out short dosTime)
        {
            dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
            long filetime = dateTime.ToFileTimeUtc();
            SafeNativeMethods.FileTimeToDosDateTime(ref filetime, out dosDate, out dosTime);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipInfo.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipInfo.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Object representing a zip file on disk; provides access to
    /// file-based operations on the zip file.
    /// </summary>
    /// <remarks>
    /// Generally, the methods on this class are much easier to use than the
    /// stream-based interfaces provided by the <see cref="ZipEngine"/> class.
    /// </remarks>
    [Serializable]
    public class ZipInfo : ArchiveInfo
    {
        /// <summary>
        /// Creates a new CabinetInfo object representing a zip file in a specified path.
        /// </summary>
        /// <param name="path">The path to the zip file. When creating a zip file, this file does not
        /// necessarily exist yet.</param>
        public ZipInfo(string path)
            : base(path)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CabinetInfo class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ZipInfo(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Creates a compression engine that does the low-level work for
        /// this object.
        /// </summary>
        /// <returns>A new <see cref="ZipEngine"/> instance.</returns>
        /// <remarks>
        /// Each instance will be <see cref="CompressionEngine.Dispose()"/>d
        /// immediately after use.
        /// </remarks>
        protected override CompressionEngine CreateCompressionEngine()
        {
            return new ZipEngine();
        }

        /// <summary>
        /// Gets information about the files contained in the archive.
        /// </summary>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each
        /// containing information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles()
        {
            IList<ArchiveFileInfo> files = base.GetFiles();
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }

        /// <summary>
        /// Gets information about the certain files contained in the archive file.
        /// </summary>
        /// <param name="searchPattern">The search string, such as
        /// &quot;*.txt&quot;.</param>
        /// <returns>A list of <see cref="ZipFileInfo"/> objects, each containing
        /// information about a file in the archive.</returns>
        public new IList<ZipFileInfo> GetFiles(string searchPattern)
        {
            IList<ArchiveFileInfo> files = base.GetFiles(searchPattern);
            List<ZipFileInfo> zipFiles = new List<ZipFileInfo>(files.Count);
            foreach (ZipFileInfo zipFile in files) zipFiles.Add(zipFile);
            return zipFiles.AsReadOnly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabUnpacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabUnpacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabUnpacker : CabWorker
    {
        private NativeMethods.FDI.Handle fdiHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FDI.PFNALLOC fdiAllocMemHandler;
        private NativeMethods.FDI.PFNFREE fdiFreeMemHandler;
        private NativeMethods.FDI.PFNOPEN fdiOpenStreamHandler;
        private NativeMethods.FDI.PFNREAD fdiReadStreamHandler;
        private NativeMethods.FDI.PFNWRITE fdiWriteStreamHandler;
        private NativeMethods.FDI.PFNCLOSE fdiCloseStreamHandler;
        private NativeMethods.FDI.PFNSEEK fdiSeekStreamHandler;

        private IUnpackStreamContext context;

        private List<ArchiveFileInfo> fileList;

        private int folderId;

        private Predicate<string> filter;

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public CabUnpacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fdiAllocMemHandler = this.CabAllocMem;
            this.fdiFreeMemHandler = this.CabFreeMem;
            this.fdiOpenStreamHandler = this.CabOpenStream;
            this.fdiReadStreamHandler = this.CabReadStream;
            this.fdiWriteStreamHandler = this.CabWriteStream;
            this.fdiCloseStreamHandler = this.CabCloseStream;
            this.fdiSeekStreamHandler = this.CabSeekStream;

            this.fdiHandle = NativeMethods.FDI.Create(
                this.fdiAllocMemHandler,
                this.fdiFreeMemHandler,
                this.fdiOpenStreamHandler,
                this.fdiReadStreamHandler,
                this.fdiWriteStreamHandler,
                this.fdiCloseStreamHandler,
                this.fdiSeekStreamHandler,
                NativeMethods.FDI.CPU_80386,
                this.ErfHandle.AddrOfPinnedObject());
            if (this.Erf.Error)
            {
                int error = this.Erf.Oper;
                int errorCode = this.Erf.Type;
                this.ErfHandle.Free();
                throw new CabException(
                    error,
                    errorCode,
                    CabException.GetErrorMessage(error, errorCode, true));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            lock (this)
            {
                short id;
                int folderCount, fileCount;
                return this.IsCabinet(stream, out id, out folderCount, out fileCount);
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                this.context = streamContext;
                this.filter = fileFilter;
                this.NextCabinetName = String.Empty;
                this.fileList = new List<ArchiveFileInfo>();
                bool tmpSuppress = this.SuppressProgressEvents;
                this.SuppressProgressEvents = true;
                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;
                        
                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabListNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }

                    List<ArchiveFileInfo> tmpFileList = this.fileList;
                    this.fileList = null;
                    return tmpFileList.AsReadOnly();
                }
                finally
                {
                    this.SuppressProgressEvents = tmpSuppress;

                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    this.context = null;
                }
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Unpack(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            lock (this)
            {
                IList<ArchiveFileInfo> files =
                    this.GetFileInfo(streamContext, fileFilter);

                this.ResetProgressData();

                if (files != null)
                {
                    this.totalFiles = files.Count;

                    for (int i = 0; i < files.Count; i++)
                    {
                        this.totalFileBytes += files[i].Length;
                        if (files[i].ArchiveNumber >= this.totalArchives)
                        {
                            int totalArchives = files[i].ArchiveNumber + 1;
                            this.totalArchives = (short) totalArchives;
                        }
                    }
                }

                this.context = streamContext;
                this.fileList = null;
                this.NextCabinetName = String.Empty;
                this.folderId = -1;
                this.currentFileNumber = -1;

                try
                {
                    for (short cabNumber = 0;
                         this.NextCabinetName != null;
                         cabNumber++)
                    {
                        this.Erf.Clear();
                        this.CabNumbers[this.NextCabinetName] = cabNumber;

                        NativeMethods.FDI.Copy(
                            this.fdiHandle,
                            this.NextCabinetName,
                            String.Empty,
                            0,
                            this.CabExtractNotify,
                            IntPtr.Zero,
                            IntPtr.Zero);
                        this.CheckError(true);
                    }
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveReadStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileWriteStream(this.currentFileName, this.FileStream, FileAttributes.Normal, DateTime.Now);
                        this.FileStream = null;
                    }

                    this.context = null;
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    stream = this.context.OpenArchiveReadStream(cabNumber, path, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;
                    this.currentArchiveNumber = cabNumber;
                    if (this.totalArchives <= this.currentArchiveNumber)
                    {
                        int totalArchives = this.currentArchiveNumber + 1;
                        this.totalArchives = (short) totalArchives;
                    }
                    this.currentArchiveTotalBytes = stream.Length;
                    this.currentArchiveBytesProcessed = 0;

                    if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                    {
                        this.OnProgress(ArchiveProgressType.StartArchive);
                    }
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabReadStreamEx(streamHandle, memory, cb, out err, pv);
            if (err == 0 && this.CabStream != null)
            {
                if (this.fileList == null)
                {
                    Stream stream = this.StreamHandles[streamHandle];
                    if (DuplicateStream.OriginalStream(stream) ==
                        DuplicateStream.OriginalStream(this.CabStream))
                    {
                        this.currentArchiveBytesProcessed += cb;
                        if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                        {
                            this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                        }
                    }
                }
            }
            return count;
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                this.currentFileBytesProcessed += cb;
                this.fileBytesProcessed += cb;
                this.OnProgress(ArchiveProgressType.PartialFile);
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (this.folderId != -3)  // -3 is a special folderId that requires re-opening the same cab
                {
                    this.OnProgress(ArchiveProgressType.FinishArchive);
                }

                this.context.CloseArchiveReadStream(this.currentArchiveNumber, this.currentArchiveName, stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;

                this.CabStream = null;
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (disposing)
                {
                    if (this.fdiHandle != null)
                    {
                        this.fdiHandle.Dispose();
                        this.fdiHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static string GetFileName(NativeMethods.FDI.NOTIFICATION notification)
        {
            bool utf8Name = (notification.attribs & (ushort) FileAttributes.Normal) != 0;  // _A_NAME_IS_UTF

            // Non-utf8 names should be completely ASCII. But for compatibility with
            // legacy tools, interpret them using the current (Default) ANSI codepage.
            Encoding nameEncoding = utf8Name ? Encoding.UTF8 : Encoding.Default;

            // Find how many bytes are in the string.
            // Unfortunately there is no faster way.
            int nameBytesCount = 0;
            while (Marshal.ReadByte(notification.psz1, nameBytesCount) != 0)
            {
                nameBytesCount++;
            }

            byte[] nameBytes = new byte[nameBytesCount];
            Marshal.Copy(notification.psz1, nameBytes, 0, nameBytesCount);
            string name = nameEncoding.GetString(nameBytes);
            if (Path.IsPathRooted(name))
            {
                name = name.Replace("" + Path.VolumeSeparatorChar, "");
            }

            return name;
        }

        private bool IsCabinet(Stream cabStream, out short id, out int cabFolderCount, out int fileCount)
        {
            int streamHandle = this.StreamHandles.AllocHandle(cabStream);
            try
            {
                this.Erf.Clear();
                NativeMethods.FDI.CABINFO fdici;
                bool isCabinet = 0 != NativeMethods.FDI.IsCabinet(this.fdiHandle, streamHandle, out fdici);

                if (this.Erf.Error)
                {
                    if (((NativeMethods.FDI.ERROR) this.Erf.Oper) == NativeMethods.FDI.ERROR.UNKNOWN_CABINET_VERSION)
                    {
                        isCabinet = false;
                    }
                    else
                    {
                        throw new CabException(
                            this.Erf.Oper,
                            this.Erf.Type,
                            CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, true));
                    }
                }

                id = fdici.setID;
                cabFolderCount = (int) fdici.cFolders;
                fileCount = (int) fdici.cFiles;
                return isCabinet;
            }
            finally
            {
                this.StreamHandles.FreeHandle(streamHandle);
            }
        }

        private int CabListNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.PARTIAL_FILE:
                    {
                        // This notification can occur when examining the contents of a non-first cab file.
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

                        string name = CabUnpacker.GetFileName(notification);

                        if (this.filter == null || this.filter(name))
                        {
                            if (this.fileList != null)
                            {
                                FileAttributes attributes = (FileAttributes) notification.attribs &
                                    (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
                                if (attributes == (FileAttributes) 0)
                                {
                                    attributes = FileAttributes.Normal;
                                }
                                DateTime lastWriteTime;
                                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);
                                long length = notification.cb;

                                CabFileInfo fileInfo = new CabFileInfo(
                                    name,
                                    notification.iFolder,
                                    notification.iCabinet,
                                    attributes,
                                    lastWriteTime,
                                    length);
                                this.fileList.Add(fileInfo);
                                this.currentFileNumber = this.fileList.Count - 1;
                                this.fileBytesProcessed += notification.cb;
                            }
                        }

                        this.totalFiles++;
                        this.totalFileBytes += notification.cb;
                        return 0;  // Continue
                    }
            }
            return 0;
        }

        private int CabExtractNotify(NativeMethods.FDI.NOTIFICATIONTYPE notificationType, NativeMethods.FDI.NOTIFICATION notification)
        {
            switch (notificationType)
            {
                case NativeMethods.FDI.NOTIFICATIONTYPE.CABINET_INFO:
                    {
                        if (this.NextCabinetName != null && this.NextCabinetName.StartsWith("?", StringComparison.Ordinal))
                        {
                            // We are just continuing the copy of a file that spanned cabinets.
                            // The next cabinet name needs to be preserved.
                            this.NextCabinetName = this.NextCabinetName.Substring(1);
                        }
                        else
                        {
                            string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                            this.NextCabinetName = (nextCab.Length != 0 ? nextCab : null);
                        }
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.NEXT_CABINET:
                    {
                        string nextCab = Marshal.PtrToStringAnsi(notification.psz1);
                        this.CabNumbers[nextCab] = (short) notification.iCabinet;
                        this.NextCabinetName = "?" + this.NextCabinetName;
                        return 0;  // Continue
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.COPY_FILE:
                    {
                        return this.CabExtractCopyFile(notification);
                    }
                case NativeMethods.FDI.NOTIFICATIONTYPE.CLOSE_FILE_INFO:
                    {
                        return this.CabExtractCloseFile(notification);
                    }
            }
            return 0;
        }

        private int CabExtractCopyFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            if (notification.iFolder != this.folderId)
            {
                if (notification.iFolder != -3)  // -3 is a special folderId used when continuing a folder from a previous cab
                {
                    if (this.folderId != -1) // -1 means we just started the extraction sequence
                    {
                        this.currentFolderNumber++;
                    }
                }
                this.folderId = notification.iFolder;
            }

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            if (this.filter == null || this.filter(name))
            {
                this.currentFileNumber++;
                this.currentFileName = name;

                this.currentFileBytesProcessed = 0;
                this.currentFileTotalBytes = notification.cb;
                this.OnProgress(ArchiveProgressType.StartFile);

                DateTime lastWriteTime;
                CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

                Stream stream = this.context.OpenFileWriteStream(name, notification.cb, lastWriteTime);
                if (stream != null)
                {
                    this.FileStream = stream;
                    int streamHandle = this.StreamHandles.AllocHandle(stream);
                    return streamHandle;
                }
                else
                {
                    this.fileBytesProcessed += notification.cb;
                    this.OnProgress(ArchiveProgressType.FinishFile);
                    this.currentFileName = null;
                }
            }
            return 0;  // Continue
        }

        private int CabExtractCloseFile(NativeMethods.FDI.NOTIFICATION notification)
        {
            Stream stream = this.StreamHandles[notification.hf];
            this.StreamHandles.FreeHandle(notification.hf);

            //bool execute = (notification.attribs & (ushort) FileAttributes.Device) != 0;  // _A_EXEC

            string name = CabUnpacker.GetFileName(notification);

            FileAttributes attributes = (FileAttributes) notification.attribs &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            if (attributes == (FileAttributes) 0)
            {
                attributes = FileAttributes.Normal;
            }
            DateTime lastWriteTime;
            CompressionEngine.DosDateAndTimeToDateTime(notification.date, notification.time, out lastWriteTime);

            stream.Flush();
            this.context.CloseFileWriteStream(name, stream, attributes, lastWriteTime);
            this.FileStream = null;

            long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
            this.currentFileBytesProcessed += remainder;
            this.fileBytesProcessed += remainder;
            this.OnProgress(ArchiveProgressType.FinishFile);
            this.currentFileName = null;

            return 1;  // Continue
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabWorker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabWorker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.IO.IsolatedStorage;
    using System.Text;
    using System.Security;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal abstract class CabWorker : IDisposable
    {
        internal const string CabStreamName = "%%CAB%%";

        private CabEngine cabEngine;

        private HandleManager<Stream> streamHandles;
        private Stream cabStream;
        private Stream fileStream;

        private NativeMethods.ERF erf;
        private GCHandle erfHandle;

        private IDictionary<string, short> cabNumbers;
        private string nextCabinetName;

        private bool suppressProgressEvents;

        private byte[] buf;

        // Progress data
        protected string currentFileName;
        protected int    currentFileNumber;
        protected int    totalFiles;
        protected long   currentFileBytesProcessed;
        protected long   currentFileTotalBytes;
        protected short  currentFolderNumber;
        protected long   currentFolderTotalBytes;
        protected string currentArchiveName;
        protected short  currentArchiveNumber;
        protected short  totalArchives;
        protected long   currentArchiveBytesProcessed;
        protected long   currentArchiveTotalBytes;
        protected long   fileBytesProcessed;
        protected long   totalFileBytes;

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected CabWorker(CabEngine cabEngine)
        {
            this.cabEngine = cabEngine;
            this.streamHandles = new HandleManager<Stream>();
            this.erf = new NativeMethods.ERF();
            this.erfHandle = GCHandle.Alloc(this.erf, GCHandleType.Pinned);
            this.cabNumbers = new Dictionary<string, short>(1);

            // 32K seems to be the size of the largest chunks processed by cabinet.dll.
            // But just in case, this buffer will auto-enlarge.
            this.buf = new byte[32768];
        }

        ~CabWorker()
        {
            this.Dispose(false);
        }

        public CabEngine CabEngine
        {
            get
            {
                return this.cabEngine;
            }
        }

        internal NativeMethods.ERF Erf
        {
            get
            {
                return this.erf;
            }
        }

        internal GCHandle ErfHandle
        {
            get
            {
                return this.erfHandle;
            }
        }

        internal HandleManager<Stream> StreamHandles
        {
            get
            {
                return this.streamHandles;
            }
        }

        internal bool SuppressProgressEvents
        {
            get
            {
                return this.suppressProgressEvents;
            }

            set
            {
                this.suppressProgressEvents = value;
            }
        }

        internal IDictionary<string, short> CabNumbers
        {
            get
            {
                return this.cabNumbers;
            }
        }

        internal string NextCabinetName
        {
            get
            {
                return this.nextCabinetName;
            }

            set
            {
                this.nextCabinetName = value;
            }
        }

        internal Stream CabStream
        {
            get
            {
                return this.cabStream;
            }

            set
            {
                this.cabStream = value;
            }
        }

        internal Stream FileStream
        {
            get
            {
                return this.fileStream;
            }

            set
            {
                this.fileStream = value;
            }
        }

        public void Dispose() 
        {
            this.Dispose(true);
            GC.SuppressFinalize(this); 
        }

        protected void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentFolderNumber = 0;
            this.currentFolderTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        protected void OnProgress(ArchiveProgressType progressType)
        {
            if (!this.suppressProgressEvents)
            {
                ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                    progressType,
                    this.currentFileName,
                    this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                    this.totalFiles,
                    this.currentFileBytesProcessed,
                    this.currentFileTotalBytes,
                    this.currentArchiveName,
                    this.currentArchiveNumber,
                    this.totalArchives,
                    this.currentArchiveBytesProcessed,
                    this.currentArchiveTotalBytes,
                    this.fileBytesProcessed,
                    this.totalFileBytes);
                this.CabEngine.ReportProgress(e);
            }
        }

        internal IntPtr CabAllocMem(int byteCount)
        {
            IntPtr memPointer = Marshal.AllocHGlobal((IntPtr) byteCount);
            return memPointer;
        }

        internal void CabFreeMem(IntPtr memPointer)
        {
            Marshal.FreeHGlobal(memPointer);
        }

        internal int CabOpenStream(string path, int openFlags, int shareMode)
        {
            int err; return this.CabOpenStreamEx(path, openFlags, shareMode, out err, IntPtr.Zero);
        }

        internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            path = path.Trim();
            Stream stream = this.cabStream;
            this.cabStream = new DuplicateStream(stream);
            int streamHandle = this.streamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        internal int CabReadStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabReadStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            count = stream.Read(this.buf, 0, count);
            Marshal.Copy(this.buf, 0, memory, count);
            err = 0;
            return count;
        }

        internal int CabWriteStream(int streamHandle, IntPtr memory, int cb)
        {
            int err; return this.CabWriteStreamEx(streamHandle, memory, cb, out err, IntPtr.Zero);
        }

        internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            int count = (int) cb;
            if (count > this.buf.Length)
            {
                this.buf = new byte[count];
            }
            Marshal.Copy(memory, this.buf, 0, count);
            stream.Write(this.buf, 0, count);
            err = 0;
            return cb;
        }

        internal int CabCloseStream(int streamHandle)
        {
            int err; return this.CabCloseStreamEx(streamHandle, out err, IntPtr.Zero);
        }

        internal virtual int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            this.streamHandles.FreeHandle(streamHandle);
            err = 0;
            return 0;
        }

        internal int CabSeekStream(int streamHandle, int offset, int seekOrigin)
        {
            int err; return this.CabSeekStreamEx(streamHandle, offset, seekOrigin, out err, IntPtr.Zero);
        }

        internal virtual int CabSeekStreamEx(int streamHandle, int offset, int seekOrigin, out int err, IntPtr pv)
        {
            Stream stream = this.streamHandles[streamHandle];
            offset = (int) stream.Seek(offset, (SeekOrigin) seekOrigin);
            err = 0;
            return offset;
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected virtual void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                if (this.cabStream != null)
                {
                    this.cabStream.Close();
                    this.cabStream = null;
                }

                if (this.fileStream != null)
                {
                    this.fileStream.Close();
                    this.fileStream = null;
                }
            }

            if (this.erfHandle.IsAllocated)
            {
                this.erfHandle.Free();
            }
        }

        protected void CheckError(bool extracting)
        {
            if (this.Erf.Error)
            {
                throw new CabException(
                    this.Erf.Oper,
                    this.Erf.Type,
                    CabException.GetErrorMessage(this.Erf.Oper, this.Erf.Type, extracting));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\CabPacker.cs ===
//---------------------------------------------------------------------
// <copyright file="CabPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Diagnostics.CodeAnalysis;

    internal class CabPacker : CabWorker
    {
        private const string TempStreamName = "%%TEMP%%";

        private NativeMethods.FCI.Handle fciHandle;

        // These delegates need to be saved as member variables
        // so that they don't get GC'd.
        private NativeMethods.FCI.PFNALLOC fciAllocMemHandler;
        private NativeMethods.FCI.PFNFREE fciFreeMemHandler;
        private NativeMethods.FCI.PFNOPEN fciOpenStreamHandler;
        private NativeMethods.FCI.PFNREAD fciReadStreamHandler;
        private NativeMethods.FCI.PFNWRITE fciWriteStreamHandler;
        private NativeMethods.FCI.PFNCLOSE fciCloseStreamHandler;
        private NativeMethods.FCI.PFNSEEK fciSeekStreamHandler;
        private NativeMethods.FCI.PFNFILEPLACED fciFilePlacedHandler;
        private NativeMethods.FCI.PFNDELETE fciDeleteFileHandler;
        private NativeMethods.FCI.PFNGETTEMPFILE fciGetTempFileHandler;

        private NativeMethods.FCI.PFNGETNEXTCABINET fciGetNextCabinet;
        private NativeMethods.FCI.PFNSTATUS fciCreateStatus;
        private NativeMethods.FCI.PFNGETOPENINFO fciGetOpenInfo;

        private IPackStreamContext context;

        private FileAttributes fileAttributes;
        private DateTime fileLastWriteTime;

        private int maxCabBytes;

        private long totalFolderBytesProcessedInCurrentCab;

        private CompressionLevel compressionLevel;
        private bool dontUseTempFiles;
        private IList<Stream> tempStreams;

        public CabPacker(CabEngine cabEngine)
            : base(cabEngine)
        {
            this.fciAllocMemHandler    = this.CabAllocMem;
            this.fciFreeMemHandler     = this.CabFreeMem;
            this.fciOpenStreamHandler  = this.CabOpenStreamEx;
            this.fciReadStreamHandler  = this.CabReadStreamEx;
            this.fciWriteStreamHandler = this.CabWriteStreamEx;
            this.fciCloseStreamHandler = this.CabCloseStreamEx;
            this.fciSeekStreamHandler  = this.CabSeekStreamEx;
            this.fciFilePlacedHandler  = this.CabFilePlaced;
            this.fciDeleteFileHandler  = this.CabDeleteFile;
            this.fciGetTempFileHandler = this.CabGetTempFile;
            this.fciGetNextCabinet     = this.CabGetNextCabinet;
            this.fciCreateStatus       = this.CabCreateStatus;
            this.fciGetOpenInfo        = this.CabGetOpenInfo;
            this.tempStreams = new List<Stream>();
            this.compressionLevel = CompressionLevel.Normal;
        }

        public bool UseTempFiles
        {
            get
            {
                return !this.dontUseTempFiles;
            }

            set
            {
                this.dontUseTempFiles = !value;
            }
        }

        public CompressionLevel CompressionLevel
        {
            get
            {
                return this.compressionLevel;
            }

            set
            {
                this.compressionLevel = value;
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void CreateFci(long maxArchiveSize)
        {
            NativeMethods.FCI.CCAB ccab = new NativeMethods.FCI.CCAB();
            if (maxArchiveSize > 0 && maxArchiveSize < ccab.cb)
            {
                ccab.cb = Math.Max(
                    NativeMethods.FCI.MIN_DISK, (int) maxArchiveSize);
            }

            object maxFolderSizeOption = this.context.GetOption(
                "maxFolderSize", null);
            if (maxFolderSizeOption != null)
            {
                long maxFolderSize = Convert.ToInt64(
                    maxFolderSizeOption, CultureInfo.InvariantCulture);
                if (maxFolderSize > 0 && maxFolderSize < ccab.cbFolderThresh)
                {
                    ccab.cbFolderThresh = (int) maxFolderSize;
                }
            }

            this.maxCabBytes = ccab.cb;
            ccab.szCab = this.context.GetArchiveName(0);
            if (ccab.szCab == null)
            {
                throw new FileNotFoundException(
                    "Cabinet name not provided by stream context.");
            }
            ccab.setID = (short) new Random().Next(
                Int16.MinValue, Int16.MaxValue + 1);
            this.CabNumbers[ccab.szCab] = 0;
            this.currentArchiveName = ccab.szCab;
            this.totalArchives = 1;
            this.CabStream = null;

            this.Erf.Clear();
            this.fciHandle = NativeMethods.FCI.Create(
                this.ErfHandle.AddrOfPinnedObject(),
                this.fciFilePlacedHandler,
                this.fciAllocMemHandler,
                this.fciFreeMemHandler,
                this.fciOpenStreamHandler,
                this.fciReadStreamHandler,
                this.fciWriteStreamHandler,
                this.fciCloseStreamHandler,
                this.fciSeekStreamHandler,
                this.fciDeleteFileHandler,
                this.fciGetTempFileHandler,
                ccab,
                IntPtr.Zero);
            this.CheckError(false);
        }

        [SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts")]
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
        public void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                try
                {
                    this.context = streamContext;

                    this.ResetProgressData();

                    this.CreateFci(maxArchiveSize);

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            this.context.CloseFileReadStream(file, fileStream);
                        }
                    }

                    long uncompressedBytesInFolder = 0;
                    this.currentFileNumber = -1;

                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = this.context.OpenFileReadStream(
                            file, out attributes, out lastWriteTime);
                        if (fileStream == null)
                        {
                            continue;
                        }

                        if (fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER)
                        {
                            throw new NotSupportedException(String.Format(
                                CultureInfo.InvariantCulture,
                                "File {0} exceeds maximum file size " +
                                "for cabinet format.",
                                file));
                        }

                        if (uncompressedBytesInFolder > 0)
                        {
                            // Automatically create a new folder if this file
                            // won't fit in the current folder.
                            bool nextFolder = uncompressedBytesInFolder
                                + fileStream.Length >= (long) NativeMethods.FCI.MAX_FOLDER;

                            // Otherwise ask the client if it wants to
                            // move to the next folder.
                            if (!nextFolder)
                            {
                                object nextFolderOption = streamContext.GetOption(
                                    "nextFolder",
                                    new object[] { file, this.currentFolderNumber });
                                nextFolder = Convert.ToBoolean(
                                    nextFolderOption, CultureInfo.InvariantCulture);
                            }

                            if (nextFolder)
                            {
                                this.FlushFolder();
                                uncompressedBytesInFolder = 0;
                            }
                        }

                        if (this.currentFolderTotalBytes > 0)
                        {
                            this.currentFolderTotalBytes = 0;
                            this.currentFolderNumber++;
                            uncompressedBytesInFolder = 0;
                        }

                        this.currentFileName = file;
                        this.currentFileNumber++;

                        this.currentFileTotalBytes = fileStream.Length;
                        this.currentFileBytesProcessed = 0;
                        this.OnProgress(ArchiveProgressType.StartFile);

                        uncompressedBytesInFolder += fileStream.Length;

                        this.AddFile(
                            file,
                            fileStream,
                            attributes,
                            lastWriteTime,
                            false,
                            this.CompressionLevel);
                    }

                    this.FlushFolder();
                    this.FlushCabinet();
                }
                finally
                {
                    if (this.CabStream != null)
                    {
                        this.context.CloseArchiveWriteStream(
                            this.currentArchiveNumber,
                            this.currentArchiveName,
                            this.CabStream);
                        this.CabStream = null;
                    }

                    if (this.FileStream != null)
                    {
                        this.context.CloseFileReadStream(
                            this.currentFileName, this.FileStream);
                        this.FileStream = null;
                    }
                    this.context = null;

                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
        }

        internal override int CabOpenStreamEx(string path, int openFlags, int shareMode, out int err, IntPtr pv)
        {
            if (this.CabNumbers.ContainsKey(path))
            {
                Stream stream = this.CabStream;
                if (stream == null)
                {
                    short cabNumber = this.CabNumbers[path];

                    this.currentFolderTotalBytes = 0;

                    stream = this.context.OpenArchiveWriteStream(cabNumber, path, true, this.CabEngine);
                    if (stream == null)
                    {
                        throw new FileNotFoundException(
                            String.Format(CultureInfo.InvariantCulture, "Cabinet {0} not provided.", cabNumber));
                    }
                    this.currentArchiveName = path;

                    this.currentArchiveTotalBytes = Math.Min(
                        this.totalFolderBytesProcessedInCurrentCab, this.maxCabBytes);
                    this.currentArchiveBytesProcessed = 0;

                    this.OnProgress(ArchiveProgressType.StartArchive);
                    this.CabStream = stream;
                }
                path = CabWorker.CabStreamName;
            }
            else if (path == CabPacker.TempStreamName)
            {
                // Opening memory stream for a temp file.
                Stream stream = new MemoryStream();
                this.tempStreams.Add(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            else if (path != CabWorker.CabStreamName)
            {
                // Opening a file on disk for a temp file.
                path = Path.Combine(Path.GetTempPath(), path);
                Stream stream = new FileStream(path, FileMode.Open, FileAccess.ReadWrite);
                this.tempStreams.Add(stream);
                stream = new DuplicateStream(stream);
                int streamHandle = this.StreamHandles.AllocHandle(stream);
                err = 0;
                return streamHandle;
            }
            return base.CabOpenStreamEx(path, openFlags, shareMode, out err, pv);
        }

        internal override int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, out int err, IntPtr pv)
        {
            int count = base.CabWriteStreamEx(streamHandle, memory, cb, out err, pv);
            if (count > 0 && err == 0)
            {
                Stream stream = this.StreamHandles[streamHandle];
                if (DuplicateStream.OriginalStream(stream) ==
                    DuplicateStream.OriginalStream(this.CabStream))
                {
                    this.currentArchiveBytesProcessed += cb;
                    if (this.currentArchiveBytesProcessed > this.currentArchiveTotalBytes)
                    {
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }
                }
            }
            return count;
        }

        internal override int CabCloseStreamEx(int streamHandle, out int err, IntPtr pv)
        {
            Stream stream = DuplicateStream.OriginalStream(this.StreamHandles[streamHandle]);

            if (stream == DuplicateStream.OriginalStream(this.FileStream))
            {
                this.context.CloseFileReadStream(this.currentFileName, stream);
                this.FileStream = null;
                long remainder = this.currentFileTotalBytes - this.currentFileBytesProcessed;
                this.currentFileBytesProcessed += remainder;
                this.fileBytesProcessed += remainder;
                this.OnProgress(ArchiveProgressType.FinishFile);

                this.currentFileTotalBytes = 0;
                this.currentFileBytesProcessed = 0;
                this.currentFileName = null;
            }
            else if (stream == DuplicateStream.OriginalStream(this.CabStream))
            {
                if (stream.CanWrite)
                {
                    stream.Flush();
                }

                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                this.OnProgress(ArchiveProgressType.FinishArchive);
                this.currentArchiveNumber++;
                this.totalArchives++;

                this.context.CloseArchiveWriteStream(
                    this.currentArchiveNumber,
                    this.currentArchiveName,
                    stream);

                this.currentArchiveName = this.NextCabinetName;
                this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes = 0;
                this.totalFolderBytesProcessedInCurrentCab = 0;

                this.CabStream = null;
            }
            else  // Must be a temp stream
            {
                stream.Close();
                this.tempStreams.Remove(stream);
            }
            return base.CabCloseStreamEx(streamHandle, out err, pv);
        }

        /// <summary>
        /// Disposes of resources allocated by the cabinet engine.
        /// </summary>
        /// <param name="disposing">If true, the method has been called directly or indirectly by a user's code,
        /// so managed and unmanaged resources will be disposed. If false, the method has been called by the 
        /// runtime from inside the finalizer, and only unmanaged resources will be disposed.</param>
        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        protected override void Dispose(bool disposing) 
        {
            try
            {
                if (disposing)
                {
                    if (this.fciHandle != null)
                    {
                        this.fciHandle.Dispose();
                        this.fciHandle = null;
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        private static NativeMethods.FCI.TCOMP GetCompressionType(CompressionLevel compLevel)
        {
            if (compLevel < CompressionLevel.Min)
            {
                return NativeMethods.FCI.TCOMP.TYPE_NONE;
            }
            else
            {
                if (compLevel > CompressionLevel.Max)
                {
                    compLevel = CompressionLevel.Max;
                }

                int lzxWindowMax =
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_HI >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW) -
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO >> (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW);
                int lzxWindow = lzxWindowMax *
                    (compLevel - CompressionLevel.Min) / (CompressionLevel.Max - CompressionLevel.Min);

                return (NativeMethods.FCI.TCOMP) ((int) NativeMethods.FCI.TCOMP.TYPE_LZX |
                    ((int) NativeMethods.FCI.TCOMP.LZX_WINDOW_LO +
                    (lzxWindow << (int) NativeMethods.FCI.TCOMP.SHIFT_LZX_WINDOW)));
            }
        }

        [SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
        private void AddFile(
            string name,
            Stream stream,
            FileAttributes attributes,
            DateTime lastWriteTime,
            bool execute,
            CompressionLevel compLevel)
        {
            this.FileStream = stream;
            this.fileAttributes = attributes &
                (FileAttributes.Archive | FileAttributes.Hidden | FileAttributes.ReadOnly | FileAttributes.System);
            this.fileLastWriteTime = lastWriteTime;
            this.currentFileName = name;

            NativeMethods.FCI.TCOMP tcomp = CabPacker.GetCompressionType(compLevel);

            IntPtr namePtr = IntPtr.Zero;
            try
            {
                Encoding nameEncoding = Encoding.ASCII;
                if (Encoding.UTF8.GetByteCount(name) > name.Length)
                {
                    nameEncoding = Encoding.UTF8;
                    this.fileAttributes |= FileAttributes.Normal;  // _A_NAME_IS_UTF
                }

                byte[] nameBytes = nameEncoding.GetBytes(name);
                namePtr = Marshal.AllocHGlobal(nameBytes.Length + 1);
                Marshal.Copy(nameBytes, 0, namePtr, nameBytes.Length);
                Marshal.WriteByte(namePtr, nameBytes.Length, 0);

                this.Erf.Clear();
                NativeMethods.FCI.AddFile(
                    this.fciHandle,
                    String.Empty,
                    namePtr,
                    execute,
                    this.fciGetNextCabinet,
                    this.fciCreateStatus,
                    this.fciGetOpenInfo,
                    tcomp);
            }
            finally
            {
                if (namePtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(namePtr);
                }
            }

            this.CheckError(false);
            this.FileStream = null;
            this.currentFileName = null;
        }

        private void FlushFolder()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushFolder(this.fciHandle, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private void FlushCabinet()
        {
            this.Erf.Clear();
            NativeMethods.FCI.FlushCabinet(this.fciHandle, false, this.fciGetNextCabinet, this.fciCreateStatus);
            this.CheckError(false);
        }

        private int CabGetOpenInfo(
            string path,
            out short date,
            out short time,
            out short attribs,
            out int err,
            IntPtr pv)
        {
            CompressionEngine.DateTimeToDosDateAndTime(this.fileLastWriteTime, out date, out time);
            attribs = (short) this.fileAttributes;

            Stream stream = this.FileStream;
            this.FileStream = new DuplicateStream(stream);
            int streamHandle = this.StreamHandles.AllocHandle(stream);
            err = 0;
            return streamHandle;
        }

        private int CabFilePlaced(
            IntPtr pccab,
            string filePath,
            long fileSize,
            int continuation,
            IntPtr pv)
        {
            return 0;
        }

        private int CabGetNextCabinet(IntPtr pccab, uint prevCabSize, IntPtr pv)
        {
            NativeMethods.FCI.CCAB nextCcab = new NativeMethods.FCI.CCAB();
            Marshal.PtrToStructure(pccab, nextCcab);

            nextCcab.szDisk = String.Empty;
            nextCcab.szCab = this.context.GetArchiveName(nextCcab.iCab);
            this.CabNumbers[nextCcab.szCab] = (short) nextCcab.iCab;
            this.NextCabinetName = nextCcab.szCab;

            Marshal.StructureToPtr(nextCcab, pccab, false);
            return 1;
        }

        private int CabCreateStatus(NativeMethods.FCI.STATUS typeStatus, uint cb1, uint cb2, IntPtr pv)
        {
            switch (typeStatus)
            {
                case NativeMethods.FCI.STATUS.FILE:
                    if (cb2 > 0 && this.currentFileBytesProcessed < this.currentFileTotalBytes)
                    {
                        if (this.currentFileBytesProcessed + cb2 > this.currentFileTotalBytes)
                        {
                            cb2 = (uint) this.currentFileTotalBytes - (uint) this.currentFileBytesProcessed;
                        }
                        this.currentFileBytesProcessed += cb2;
                        this.fileBytesProcessed += cb2;

                        this.OnProgress(ArchiveProgressType.PartialFile);
                    }
                    break;

                case NativeMethods.FCI.STATUS.FOLDER:
                    if (cb1 == 0)
                    {
                        this.currentFolderTotalBytes = cb2 - this.totalFolderBytesProcessedInCurrentCab;
                        this.totalFolderBytesProcessedInCurrentCab = cb2;
                    }
                    else if (this.currentFolderTotalBytes == 0)
                    {
                        this.OnProgress(ArchiveProgressType.PartialArchive);
                    }
                    break;

                case NativeMethods.FCI.STATUS.CABINET:
                    break;
            }
            return 0;
        }

        private int CabGetTempFile(IntPtr tempNamePtr, int tempNameSize, IntPtr pv)
        {
            string tempFileName;
            if (this.UseTempFiles)
            {
                tempFileName = Path.GetFileName(Path.GetTempFileName());
            }
            else
            {
                tempFileName = CabPacker.TempStreamName;
            }

            byte[] tempNameBytes = Encoding.ASCII.GetBytes(tempFileName);
            if (tempNameBytes.Length >= tempNameSize)
            {
                return -1;
            }

            Marshal.Copy(tempNameBytes, 0, tempNamePtr, tempNameBytes.Length);
            Marshal.WriteByte(tempNamePtr, tempNameBytes.Length, 0);  // null-terminator
            return 1;
        }

        private int CabDeleteFile(string path, out int err, IntPtr pv)
        {
            try
            {
                // Deleting a temp file - don't bother if it is only a memory stream.
                if (path != CabPacker.TempStreamName)
                {
                    path = Path.Combine(Path.GetTempPath(), path);
                    File.Delete(path);
                }
            }
            catch (IOException)
            {
                // Failure to delete a temp file is not fatal.
            }
            err = 0;
            return 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Properties\AssemblyInfo.cs ===
﻿using System;
using System.Resources;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: CLSCompliant(true)]
[assembly: NeutralResourcesLanguage("en-US")]
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LFIT")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ee0eea6d-89be-4709-b22f-30110754d5cb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\AutoSubmit.cs ===
using System;
using System.IO;
using System.Collections.Generic;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Create a submission to Codesign.Net.
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class CodesignSubmission
    {
        public int CreateSubmission(string file, IList<string> signers, string largeFileCertID, string normalFileCertID, string strongNameCertID, IList<CODESIGN.Submitter.Job> jobList)
        {
            int ret = 0;
            CODESIGN.Submitter.Job job = null;
            try 
            {
                Log.WriteLog("Submitting {0} for CodeSign...", Path.GetFileName(file));
                //Initialize the Codesign.Submitter object
                //"Codesign" represents the server - constant value do not change
                //9556 represents the port - constant value do not change
                job = CODESIGN.Submitter.Job.Initialize("codesign.gtm.microsoft.com", 9556, true); 
                                
                // Sets the Partial return flag option.
                // False - If any files fail signing you will not get any files back.
                // True - Only retrieve successfully signed files.
                job.IsAllowReturnPartial = true;            // default is false

                // This is reference information that can be displayed or used in searches
                job.Description = "Job Description - a way to make it easier to associate jobs";
                job.Keywords = "Keywords to improve searches";

                // This call selects a certificate from the ones allowed for this user
                // You may pick only one Authenticode certificate
                // You may pick only one Strong Name certificate
                // You may pick an Authenticode and Strong Name certificate at the same time
                // Example:
                FileInfo info = new FileInfo(file);
                if (info.Length > 524288000)
                {
                    job.SelectCertificate(largeFileCertID);   // You must have permissions to the requested cert
                }
                else
                {
                    job.SelectCertificate(normalFileCertID);   // You must have permissions to the requested cert
                    if (strongNameCertID != @"")
                    {
                        job.SelectCertificate(strongNameCertID);   // You must have permissions to the requested cert
                    }
                }
                
                // This will populate the approvers to the job
                // NOTE: these users are invalid, must substitute real user aliases who are authorized for approval
                // You need at minimum two approvers - you may add as many as necessary
                // Approvers must be entered in the system to approve jobs
                // Approvers CANNOT be the job submitter
                foreach (string strSigner in signers)
                {
                    job.AddApprover(strSigner);
                }

                // These calls add notification subscriptions to the job. A number of others are 
                // available, these are the standard ones.
                // Check the CODESIGN.NotificationEventTypeEnum enumaration for a complete list.
                //job.SetNotification(job.Submitter, new CODESIGN.NotificationEventTypeEnum[] {CODESIGN.NotificationEventTypeEnum.JobCompletionFailure,CODESIGN.NotificationEventTypeEnum.JobCompletionSuccess,CODESIGN.NotificationEventTypeEnum.JobVirusScanFailure});


                // This call adds an entire directory tree to the job, duplicating its structure in
                // the submission share and making all metadata the same for each file.
                job.AddFile(file, "CodeSign", "http://CodeSignInfo", CODESIGN.JavaPermissionsTypeEnum.None);

                // This call sends the job to the back end for processing
                job.Send();

                Log.WriteLog("Submitting {0} finished", Path.GetFileName(file));
                // This call displays the job number, assigned during the send process
                Log.WriteLog("Job Number is: {0}", job.JobNumber);
                Log.WriteLog("Job Completion Path is: {0}", job.JobCompletionPath);
                if (jobList != null)
                {
                    jobList.Add(job);
                }
            }
            catch (Exception exc)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(exc));
                if (job != null)
                {
                    foreach(CODESIGN.Submitter.JobError je in job.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\JobWatcher.cs ===
using System;
/*
namespace Microsoft.LFIT
{
    /// <summary>
    /// Monitor a job until completionsubmission
    /// 
    /// REQUIREMENTS: The user needs to add the appropriate references to this project:
    /// (1) CODESIGN.PolictyManager.dll
    /// (2) CODESIGN.Submitter.dll
    /// (3) MS.IT.BGCOE.RDS.Common.MultiThreadedFileCopier.dll
    /// (4) MS.IT.BGCOE.RDS.LongFile.IO.FileIOEx.dll
    /// These are located in "%ProgramFiles%\CODESIGN\CodeSign.Submitter" (32 bit) or "%ProgramFiles(x86)%\CODESIGN\CodeSign.Submitter" (64 bit)
    /// </summary>
    class Watcher
    {
        /// <summary>
        /// The main method
        /// </summary>
        public static int Monitor(string strJobNumber)
        {
            int ret = 0;
            //Check if user passed the job number in the parameters

            //Jobwatcher instance, still null here
            CODESIGN.Submitter.JobWatcher jw = null;

            try
            {
                //Instantiate new JobWatcher object
                jw = new CODESIGN.Submitter.JobWatcher();

                // This call waits until the job is finished
                //jw.Watch(JobNumber, RelayServer, RelayPort, IsSSL);
                jw.Watch(strJobNumber, "codesign.gtm.microsoft.com", 9556, true);

                if (jw.IsDone)
                {
                    // Now we're done, so display any errors or warnings (in case we are in non-event mode)
                    Log.WriteLog("Job is finished, Success={0}  Signed={1}  BytesSigned={2}", jw.IsSuccess, jw.TotalSigned, jw.TotalByteSize);
                    if (!jw.IsSuccess)
                    {
                        ret = -1;
                    }
                    if (jw.IsPartial)
                    {
                        Log.WriteLog("Partial Success: {0}", jw.IsPartial);
                    }
                    //Display errors
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                    //Display failed files
                    foreach (CODESIGN.Submitter.JobFile jf in jw.FailedFileList.Values)
                    {
                        Log.WriteLog("Failed -> " + jf.FileFullPath);
                    }
                }
                else
                {
                    Log.WriteLog("Job {0} is still being processed!", strJobNumber);
                }

            }
            catch (Exception ex)
            {
                Log.WriteLog("Job submission failed: {0}", CODESIGN.EventLogProxy.GetMessage(ex));
                if (jw != null)
                {
                    foreach (CODESIGN.Submitter.JobError je in jw.ErrorList.Values)
                    {
                        Log.WriteLog(je.Number + ":" + je.Description + " {" + je.Explanation + "}");
                    }
                }
                ret = -1;
            }

            return ret;
        }
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Log.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Log.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------
namespace Microsoft.LFIT
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public static class Log
    {
        private static bool quiet;
        private static bool exceptionCaught;
        private static string logFileName;

        static Log()
        {
            try
            {
                logFileName = Path.Combine(Directory.GetCurrentDirectory(), @"log.txt");
                StreamWriter SW;
                SW = File.CreateText(logFileName);
                SW.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
        public static bool ExceptionCaught
        {
            get { return exceptionCaught; }
            set { exceptionCaught = value; }
        }

        public static bool Quiet
        {
            get { return quiet; }
            set { quiet = value; }
        }

        public static void WriteLog(string line)
        {
            if (!quiet)
            {
                Console.WriteLine(line);

                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + line);
                SW.Close();
            }
        }

        public static void WriteLog(string format, object arg0)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg0);

                string str = string.Format(format, arg0);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();

            }
        }
        public static void WriteLog(string format, params object[] arg)
        {
            if (!quiet)
            {
                Console.WriteLine(format, arg);
                string str = string.Format(format, arg);
                StreamWriter SW = new StreamWriter(logFileName,true);
                SW.WriteLine(DateTime.Now + ": " + str);
                SW.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Manifest.cs ===
﻿//--------------------------------------------------------------------------------------
// <copyright file="Manifest.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//--------------------------------------------------------------------------------------

namespace Microsoft.LFIT
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Xml;

    public class Manifest
    {
        private string cabFolder;
        private long installSize;
        private string linkURL;
        private string titleId;

        public Manifest()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        public string CabFolder
        {
            get { return this.cabFolder; }
            set { this.cabFolder = value; }
        }

        public long InstallSize
        {
            get { return this.installSize; }
            set { this.installSize = value; }
        }

        public string LinkURL
        {
            get { return this.linkURL; }
            set { this.linkURL = value; }
        }

        public string TitleId
        {
            get { return this.titleId; }
            set { this.titleId = value; }
        }

        public void NewFile()
        {
            this.installSize = 0;
            this.linkURL = string.Empty;
            this.titleId = string.Empty;
            this.cabFolder = string.Empty;
        }

        [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public string SaveFile(string outputPath)
        {
            XmlDocument doc = new XmlDocument();

            XmlNode node = doc.CreateNode(XmlNodeType.XmlDeclaration, "OfferManifest", null);
            XmlDeclaration decl = (XmlDeclaration)node;
            decl.Encoding = @"utf-8";
            doc.AppendChild(node);

            XmlNode root = doc.CreateNode(XmlNodeType.Element, "OfferManifest", null);
            XmlAttribute titleIDAtt = doc.CreateAttribute("TitleId");
            titleIDAtt.Value = this.titleId;
            root.Attributes.Append(titleIDAtt);
            doc.AppendChild(root);

            XmlNode itemsNode = doc.CreateNode(XmlNodeType.Element, "Items", null);
            XmlAttribute installSizeAtt = doc.CreateAttribute("InstallSize");
            installSizeAtt.Value = this.installSize.ToString();
            itemsNode.Attributes.Append(installSizeAtt);
            root.AppendChild(itemsNode);


            foreach (string fileName in Directory.GetFiles(cabFolder))
            {
                XmlNode fileNode = doc.CreateNode(XmlNodeType.Element, "Item", null);
                XmlAttribute idAtt = doc.CreateAttribute("ID");
                idAtt.Value = Path.GetFileName(fileName);
                fileNode.Attributes.Append(idAtt);

                // Use FileInfo to get length of each file.
                FileInfo info = new FileInfo(fileName);
                XmlAttribute sizeAtt = doc.CreateAttribute("DownloadSize");
                sizeAtt.Value = info.Length.ToString();
                fileNode.Attributes.Append(sizeAtt);
                itemsNode.AppendChild(fileNode);

                XmlNode linkNode = doc.CreateNode(XmlNodeType.Element, "Link", null);
                XmlAttribute urlAtt = doc.CreateAttribute("Url");

                Uri urlBase = new Uri(this.linkURL);
                if( this.linkURL.EndsWith("\\") || this.linkURL.EndsWith("/"))
                {
                    urlAtt.Value = this.linkURL + Path.GetFileName(fileName);
                }
                else
                {
                    if (this.linkURL.Contains("://"))
                    {
                        urlAtt.Value = this.linkURL + "/" + Path.GetFileName(fileName);
                    }
                    else
                    {
                        Log.WriteLog("File: " + Path.GetFileName(fileName));
                        urlAtt.Value = Path.Combine(this.linkURL, Path.GetFileName(fileName));
                    }
                }
                Log.WriteLog("FileURL: " + urlAtt.Value);
                linkNode.Attributes.Append(urlAtt);
                fileNode.AppendChild(linkNode);
            }

            doc.Save(outputPath);
            if (!File.Exists(outputPath))
            {
                throw new FileNotFoundException();
            }

            return "Saved manifest file at " + outputPath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\CrcStream.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="CrcStream.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Wraps a source stream and calcaluates a CRC over all bytes that are read or written.
    /// </summary>
    /// <remarks>
    /// The CRC algorithm matches that used in the standard ZIP file format.
    /// </remarks>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
    public class CrcStream : Stream
    {
        private Stream source;
        private uint crc;

        /// <summary>
        /// Creates a new CrcStream instance from a source stream.
        /// </summary>
        /// <param name="source">Underlying stream where bytes will be read from or written to.</param>
        public CrcStream(Stream source)
        {
            this.source = source;
        }

        /// <summary>
        /// Gets the current CRC over all bytes that have been read or written
        /// since this instance was created.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Crc")]
        [CLSCompliant(false)]
        public uint Crc
        {
            get
            {
                return this.crc;
            }
        }

        /// <summary>
        /// Gets the underlying stream that this stream reads from or writes to.
        /// </summary>
        public Stream Source
        {
            get
            {
                return this.source;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports reading.
        /// </summary>
        /// <value>true if the stream supports reading; otherwise, false.</value>
        public override bool CanRead
        {
            get
            {
                return this.source.CanRead;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports writing.
        /// </summary>
        /// <value>true if the stream supports writing; otherwise, false.</value>
        public override bool CanWrite
        {
            get
            {
                return this.source.CanWrite;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the source stream supports seeking.
        /// </summary>
        /// <value>true if the stream supports seeking; otherwise, false.</value>
        public override bool CanSeek
        {
            get
            {
                return this.source.CanSeek;
            }
        }

        /// <summary>
        /// Gets the length of the source stream.
        /// </summary>
        public override long Length
        {
            get
            {
                return this.source.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the source stream.
        /// </summary>
        public override long Position
        {
            get
            {
                return this.source.Position;
            }

            set
            {
                this.source.Position = value;
            }
        }

        /// <summary>
        /// Sets the position within the source stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the origin parameter.</param>
        /// <param name="origin">A value of type SeekOrigin indicating
        /// the reference point used to obtain the new position.</param>
        /// <returns>The new position within the source stream.</returns>
        /// <remarks>
        /// Note the CRC is only calculated over bytes that are actually read or
        /// written, so any bytes skipped by seeking will not contribute to the CRC.
        /// </remarks>
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this.source.Seek(offset, origin);
        }

        /// <summary>
        /// Sets the length of the source stream.
        /// </summary>
        /// <param name="value">The desired length of the
        /// stream in bytes.</param>
        public override void SetLength(long value)
        {
            this.source.SetLength(value);
        }

        /// <summary>
        /// Reads a sequence of bytes from the source stream and advances
        /// the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer
        /// contains the specified byte array with the values between offset and
        /// (offset + count - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin
        /// storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer. This can be less
        /// than the number of bytes requested if that many bytes are not currently available,
        /// or zero (0) if the end of the stream has been reached.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            count = this.source.Read(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
            return count;
        }

        /// <summary>
        /// Writes a sequence of bytes to the source stream and advances the
        /// current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count
        /// bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which
        /// to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the
        /// current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            this.source.Write(buffer, offset, count);
            this.UpdateCrc(buffer, offset, count);
        }

        /// <summary>
        /// Flushes the source stream.
        /// </summary>
        public override void Flush()
        {
            this.source.Flush();
        }

        /// <summary>
        /// Closes the underlying stream.
        /// </summary>
        public override void Close()
        {
            this.source.Close();
            base.Close();
        }

        /// <summary>
        /// Updates the CRC with a range of bytes that were read or written.
        /// </summary>
        private void UpdateCrc(byte[] buffer, int offset, int count)
        {
            this.crc = ~this.crc;
            for( ; count > 0; count--, offset++)
            {
                this.crc = (this.crc >> 8) ^
                    CrcStream.crcTable[(this.crc  & 0xFF) ^ buffer[offset]];
            }
            this.crc = ~this.crc;
        }

        private static uint[] crcTable = MakeCrcTable();

        /// <summary>
        /// Computes a table that speeds up calculation of the CRC.
        /// </summary>
        private static uint[] MakeCrcTable()
        {
            const uint poly = 0x04C11DB7u;
            uint[] crcTable = new uint[256];
            for(uint n = 0; n < 256; n++)
            {
                uint c = CrcStream.Reflect(n, 8);
                c = c << 24;
                for(uint k = 0; k < 8; k++)
                {
                    c = (c << 1) ^ ((c & 0x80000000u) != 0 ? poly : 0);
                }
                crcTable[n] = CrcStream.Reflect(c, 32);
            }
            return crcTable;
        }

        /// <summary>
        /// Reflects the ordering of certain number of bits. For exmample when reflecting
        /// one byte, bit one is swapped with bit eight, bit two with bit seven, etc.
        /// </summary>
        private static uint Reflect(uint value, int bits)
        {
            for (int i = 0; i < bits / 2; i++)
            {
                uint leftBit = 1u << (bits - 1 - i);
                uint rightBit = 1u << i;
                if (((value & leftBit) != 0) != ((value & rightBit) != 0))
                {
                    value ^= leftBit | rightBit;
                }
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup2\Compression\ArchiveException.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ArchiveException.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;

    /// <summary>
    /// Base exception class for compression operations. Compression libraries should
    /// derive subclass exceptions with more specific error information relevent to the
    /// file format.
    /// </summary>
    [Serializable]
    public class ArchiveException : IOException
    {
        /// <summary>
        /// Creates a new ArchiveException with a specified error message and a reference to the
        /// inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the
        /// innerException parameter is not a null reference (Nothing in Visual Basic), the current exception
        /// is raised in a catch block that handles the inner exception.</param>
        public ArchiveException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ArchiveException(string message)
            : this(message, null)
        {
        }

        /// <summary>
        /// Creates a new ArchiveException.
        /// </summary>
        public ArchiveException()
            : this(null, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ArchiveException class with serialized data.
        /// </summary>
        /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        protected ArchiveException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Cab\NativeMethods.cs ===
//---------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
// <auto-generated />
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Cab
{
using System;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

/// <summary>
/// Native DllImport methods and related structures and constants used for
/// cabinet creation and extraction via cabinet.dll.
/// </summary>
internal static class NativeMethods
{
    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fci.h.
    /// Refer to comments in fci.h for documentation.
    /// </summary>
    internal static class FCI
    {
        internal const int MIN_DISK = 32768;
        internal const int MAX_DISK = Int32.MaxValue;
        internal const int MAX_FOLDER = 0x7FFF8000;
        internal const int MAX_FILENAME = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH = 256;
        internal const int MAX_DISK_NAME = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int fileHandle, IntPtr memory, int cb, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int fileHandle, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int fileHandle, int dist, int seekType, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNDELETE(string path, out int err, IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETNEXTCABINET(IntPtr pccab, uint cbPrevCab, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNFILEPLACED(IntPtr pccab, string path, long fileSize, int continuation, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETOPENINFO(string path, out short date, out short time, out short pattribs, out int err, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSTATUS(STATUS typeStatus, uint cb1, uint cb2, IntPtr pv);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNGETTEMPFILE(IntPtr tempNamePtr, int tempNameSize, IntPtr pv);

        /// <summary>
        /// Error codes that can be returned by FCI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            OPEN_SRC,
            READ_SRC,
            ALLOC_FAIL,
            TEMP_FILE,
            BAD_COMPR_TYPE,
            CAB_FILE,
            USER_ABORT,
            MCI_FAIL,
        }

        /// <summary>
        /// FCI compression algorithm types and parameters.
        /// </summary>
        internal enum TCOMP : ushort
        {
            MASK_TYPE           = 0x000F,
            TYPE_NONE           = 0x0000,
            TYPE_MSZIP          = 0x0001,
            TYPE_QUANTUM        = 0x0002,
            TYPE_LZX            = 0x0003,
            BAD                 = 0x000F,

            MASK_LZX_WINDOW     = 0x1F00,
            LZX_WINDOW_LO       = 0x0F00,
            LZX_WINDOW_HI       = 0x1500,
            SHIFT_LZX_WINDOW    = 0x0008,

            MASK_QUANTUM_LEVEL  = 0x00F0,
            QUANTUM_LEVEL_LO    = 0x0010,
            QUANTUM_LEVEL_HI    = 0x0070,
            SHIFT_QUANTUM_LEVEL = 0x0004,

            MASK_QUANTUM_MEM    = 0x1F00,
            QUANTUM_MEM_LO      = 0x0A00,
            QUANTUM_MEM_HI      = 0x1500,
            SHIFT_QUANTUM_MEM   = 0x0008,

            MASK_RESERVED       = 0xE000,
        }

        /// <summary>
        /// Reason for FCI status callback.
        /// </summary>
        internal enum STATUS : uint
        {
            FILE    = 0,
            FOLDER  = 1,
            CABINET = 2,
        }

        [SuppressMessage("Microsoft.Globalization", "CA2101:SpecifyMarshalingForPInvokeStringArguments")]
        [DllImport("cabinet.dll", EntryPoint = "FCICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create(IntPtr perf, PFNFILEPLACED pfnfcifp, PFNALLOC pfna, PFNFREE pfnf, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, PFNDELETE pfndelete, PFNGETTEMPFILE pfnfcigtf, [MarshalAs(UnmanagedType.LPStruct)] CCAB pccab, IntPtr pv);

        [DllImport("cabinet.dll", EntryPoint = "FCIAddFile", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int AddFile(Handle hfci, string pszSourceFile, IntPtr pszFileName, [MarshalAs(UnmanagedType.Bool)] bool fExecute, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis, PFNGETOPENINFO pfnfcigoi, TCOMP typeCompress);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushCabinet(Handle hfci, [MarshalAs(UnmanagedType.Bool)] bool fGetNextCab, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [DllImport("cabinet.dll", EntryPoint = "FCIFlushFolder", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FlushFolder(Handle hfci, PFNGETNEXTCABINET pfnfcignc, PFNSTATUS pfnfcis);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FCIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfci);

        /// <summary>
        /// Cabinet information structure used for FCI initialization and GetNextCabinet callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class CCAB
        {
            internal int cb             = MAX_DISK;
            internal int cbFolderThresh = MAX_FOLDER;
            internal int cbReserveCFHeader;
            internal int cbReserveCFFolder;
            internal int cbReserveCFData;
            internal int iCab;
            internal int iDisk;
            internal int fFailOnIncompressible;
            internal short setID;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_DISK_NAME   )] internal string szDisk    = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CABINET_NAME)] internal string szCab     = String.Empty;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_CAB_PATH    )] internal string szCabPath = String.Empty;
        }

        /// <summary>
        /// Ensures that the FCI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FCI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
            protected override bool ReleaseHandle()
            {
                return FCI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// A direct import of constants, enums, structures, delegates, and functions from fdi.h.
    /// Refer to comments in fdi.h for documentation.
    /// </summary>
    internal static class FDI
    {
        internal const int MAX_DISK         = Int32.MaxValue;
        internal const int MAX_FILENAME     = 256;
        internal const int MAX_CABINET_NAME = 256;
        internal const int MAX_CAB_PATH     = 256;
        internal const int MAX_DISK_NAME    = 256;

        internal const int CPU_80386 = 1;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate IntPtr PFNALLOC(int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate void PFNFREE(IntPtr pv);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNOPEN(string path, int oflag, int pmode);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNREAD(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNWRITE(int hf, IntPtr pv, int cb);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNCLOSE(int hf);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNSEEK(int hf, int dist, int seektype);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)] internal delegate int PFNNOTIFY(NOTIFICATIONTYPE fdint, NOTIFICATION fdin);

        /// <summary>
        /// Error codes that can be returned by FDI.
        /// </summary>
        internal enum ERROR : int
        {
            NONE,
            CABINET_NOT_FOUND,
            NOT_A_CABINET,
            UNKNOWN_CABINET_VERSION,
            CORRUPT_CABINET,
            ALLOC_FAIL,
            BAD_COMPR_TYPE,
            MDI_FAIL,
            TARGET_FILE,
            RESERVE_MISMATCH,
            WRONG_CABINET,
            USER_ABORT,
        }

        /// <summary>
        /// Type of notification message for the FDI Notify callback.
        /// </summary>
        internal enum NOTIFICATIONTYPE : int
        {
            CABINET_INFO,
            PARTIAL_FILE,
            COPY_FILE,
            CLOSE_FILE_INFO,
            NEXT_CABINET,
            ENUMERATE,
        }

        [DllImport("cabinet.dll", EntryPoint = "FDICreate", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Handle Create([MarshalAs(UnmanagedType.FunctionPtr)] PFNALLOC pfnalloc, [MarshalAs(UnmanagedType.FunctionPtr)] PFNFREE pfnfree, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, int cpuType, IntPtr perf);

        [DllImport("cabinet.dll", EntryPoint = "FDICopy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int Copy(Handle hfdi, string pszCabinet, string pszCabPath, int flags, PFNNOTIFY pfnfdin, IntPtr pfnfdid, IntPtr pvUser);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("cabinet.dll", EntryPoint = "FDIDestroy", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool Destroy(IntPtr hfdi);

        [DllImport("cabinet.dll", EntryPoint = "FDIIsCabinet", CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true, CallingConvention = CallingConvention.Cdecl)]
        [SuppressMessage("Microsoft.Portability", "CA1901:PInvokeDeclarationsShouldBePortable", Justification="FDI file handles definitely remain 4 bytes on 64bit platforms.")]
        internal static extern int IsCabinet(Handle hfdi, int hf, out CABINFO pfdici);

        /// <summary>
        /// Cabinet information structure filled in by FDI IsCabinet.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct CABINFO
        {
            internal int cbCabinet;
            internal short cFolders;
            internal short cFiles;
            internal short setID;
            internal short iCabinet;
            internal int fReserve;
            internal int hasprev;
            internal int hasnext;
        }

        /// <summary>
        /// Cabinet notification details passed to the FDI Notify callback.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal class NOTIFICATION
        {
            internal int cb;
            internal IntPtr psz1;
            internal IntPtr psz2;
            internal IntPtr psz3;
            internal IntPtr pv;

            internal IntPtr hf_ptr;

            internal short date;
            internal short time;
            internal short attribs;
            internal short setID;
            internal short iCabinet;
            internal short iFolder;
            internal int fdie;

            // Unlike all the other file handles in FCI/FDI, this one is
            // actually pointer-sized. Use a property to pretend it isn't.
            internal int hf
            {
                get { return (int) this.hf_ptr; }
            }
        }

        /// <summary>
        /// Ensures that the FDI handle is safely released.
        /// </summary>
        internal class Handle : SafeHandle
        {
            /// <summary>
            /// Creates a new unintialized handle. The handle will be initialized
            /// when it is marshalled back from native code.
            /// </summary>
            internal Handle()
                : base(IntPtr.Zero, true)
            {
            }

            /// <summary>
            /// Checks if the handle is invalid. An FDI handle is invalid when it is zero.
            /// </summary>
            public override bool IsInvalid
            {
                get
                {
                    return this.handle == IntPtr.Zero;
                }
            }

            /// <summary>
            /// Releases the handle by calling FDIDestroy().
            /// </summary>
            /// <returns>True if the release succeeded.</returns>
            protected override bool ReleaseHandle()
            {
                return FDI.Destroy(this.handle);
            }
        }
    }

    /// <summary>
    /// Error info structure for FCI and FDI.
    /// </summary>
    /// <remarks>Before being passed to FCI or FDI, this structure is
    /// pinned in memory via a GCHandle. The pinning is necessary
    /// to be able to read the results, since the ERF structure doesn't
    /// get marshalled back out after an error.</remarks>
    [StructLayout(LayoutKind.Sequential)]
    internal class ERF
    {
        private int erfOper;
        private int erfType;
        private int fError;

        /// <summary>
        /// Gets or sets the cabinet error code.
        /// </summary>
        internal int Oper
        {
            get
            {
                return this.erfOper;
            }

            set
            {
                this.erfOper = value;
            }
        }

        /// <summary>
        /// Gets or sets the Win32 error code.
        /// </summary>
        internal int Type
        {
            get
            {
                return this.erfType;
            }

            set
            {
                this.erfType = value;
            }
        }

        /// <summary>
        /// GCHandle doesn't like the bool type, so use an int underneath.
        /// </summary>
        internal bool Error
        {
            get
            {
                return this.fError != 0;
            }

            set
            {
                this.fError = value ? 1 : 0;
            }
        }

        /// <summary>
        /// Clears the error information.
        /// </summary>
        internal void Clear()
        {
            this.Oper = 0;
            this.Type = 0;
            this.Error = false;
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipFormat.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipFormat.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;

    [Flags]
    internal enum ZipFileFlags : ushort
    {
        None            = 0x0000,
        Encrypt         = 0x0001,
        CompressOption1 = 0x0002,
        CompressOption2 = 0x0004,
        DataDescriptor  = 0x0008,
        StrongEncrypt   = 0x0040,
        UTF8            = 0x0800
    }

    internal enum ZipExtraFileFieldType : ushort
    {
        ZIP64 = 0x0001,
        NTFS_TIMES = 0x000A,
        NTFS_ACLS = 0x4453,
        EXTIME = 0x5455
    }

    internal class ZipFileHeader
    {
        public const uint LFHSIG = 0x04034B50;
        public const uint CFHSIG = 0x02014B50;

        public const uint SPANSIG  = 0x08074b50;
        public const uint SPANSIG2 = 0x30304b50;
        
        public const uint LFH_FIXEDSIZE = 30;
        public const uint CFH_FIXEDSIZE = 46;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public ZipFileFlags flags;
        public ZipCompressionMethod compressionMethod;
        public short lastModTime;
        public short lastModDate;
        public uint crc32;
        public uint compressedSize;
        public uint uncompressedSize;
        public ushort diskStart;
        public ushort internalFileAttrs;
        public uint externalFileAttrs;
        public uint localHeaderOffset;
        public string fileName;
        public ZipExtraFileField[] extraFields;
        public string fileComment;
        public bool zip64;

        public ZipFileHeader()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public ZipFileHeader(ZipFileInfo fileInfo, bool zip64)
            : this()
        {
            this.flags = ZipFileFlags.None;
            this.compressionMethod = fileInfo.CompressionMethod;
            this.fileName = Path.Combine(fileInfo.Path, fileInfo.Name);
            CompressionEngine.DateTimeToDosDateAndTime(
                fileInfo.LastWriteTime, out this.lastModDate, out this.lastModTime);
            this.zip64 = zip64;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;
                this.versionMadeBy = 45;
                this.versionNeeded = 45;
                ZipExtraFileField field = new ZipExtraFileField();
                field.fieldType = ZipExtraFileFieldType.ZIP64;
                field.SetZip64Data(
                    fileInfo.CompressedLength,
                    fileInfo.Length,
                    0,
                    fileInfo.ArchiveNumber);
                this.extraFields = new ZipExtraFileField[] { field };
            }
            else
            {
                this.compressedSize = (uint) fileInfo.CompressedLength;
                this.uncompressedSize = (uint) fileInfo.Length;
                this.diskStart = (ushort) fileInfo.ArchiveNumber;
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void Update(
            long compressedSize,
            long uncompressedSize,
            uint crc32,
            long localHeaderOffset,
            int archiveNumber)
        {
            this.crc32 = crc32;

            if (this.zip64)
            {
                this.compressedSize = UInt32.MaxValue;
                this.uncompressedSize = UInt32.MaxValue;
                this.localHeaderOffset = UInt32.MaxValue;
                this.diskStart = UInt16.MaxValue;

                if (this.extraFields != null)
                {
                    foreach (ZipExtraFileField field in this.extraFields)
                    {
                        if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                        {
                            field.SetZip64Data(
                                compressedSize,
                                uncompressedSize,
                                localHeaderOffset,
                                archiveNumber);
                        }
                    }
                }
            }
            else
            {
                this.compressedSize = (uint) compressedSize;
                this.uncompressedSize = (uint) uncompressedSize;
                this.localHeaderOffset = (uint) localHeaderOffset;
                this.diskStart = (ushort) archiveNumber;
            }
        }

        public bool Read(Stream stream, bool central)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos <
                (central ? CFH_FIXEDSIZE : LFH_FIXEDSIZE))
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig == SPANSIG || sig == SPANSIG2)
            {
                // Spanned zip files may optionally begin with a special marker.
                // Just ignore it and move on.
                sig = reader.ReadUInt32();
            }

            if (sig != (central ? CFHSIG : LFHSIG))
            {
                return false;
            }

            this.versionMadeBy = (central ? reader.ReadUInt16() : (ushort) 0);
            this.versionNeeded = reader.ReadUInt16();
            this.flags = (ZipFileFlags) reader.ReadUInt16();
            this.compressionMethod = (ZipCompressionMethod) reader.ReadUInt16();
            this.lastModTime = reader.ReadInt16();
            this.lastModDate = reader.ReadInt16();
            this.crc32 = reader.ReadUInt32();
            this.compressedSize = reader.ReadUInt32();
            this.uncompressedSize = reader.ReadUInt32();
            
            this.zip64 = this.uncompressedSize == UInt32.MaxValue;

            int fileNameLength = reader.ReadUInt16();
            int extraFieldLength = reader.ReadUInt16();
            int fileCommentLength;

            if (central)
            {
                fileCommentLength = reader.ReadUInt16();

                this.diskStart = reader.ReadUInt16();
                this.internalFileAttrs = reader.ReadUInt16();
                this.externalFileAttrs = reader.ReadUInt32();
                this.localHeaderOffset = reader.ReadUInt32();
            }
            else
            {
                fileCommentLength = 0;
                this.diskStart = 0;
                this.internalFileAttrs = 0;
                this.externalFileAttrs = 0;
                this.localHeaderOffset = 0;
            }

            if (stream.Length - stream.Position <
                fileNameLength + extraFieldLength + fileCommentLength)
            {
                return false;
            }

            Encoding headerEncoding = ((this.flags | ZipFileFlags.UTF8) != 0 ?
                Encoding.UTF8 : Encoding.GetEncoding(CultureInfo.CurrentCulture.TextInfo.OEMCodePage));

            byte[] fileNameBytes = reader.ReadBytes(fileNameLength);
            this.fileName = headerEncoding.GetString(fileNameBytes);

            List<ZipExtraFileField> fields = new List<ZipExtraFileField>();
            while (extraFieldLength > 0)
            {
                ZipExtraFileField field = new ZipExtraFileField();
                if (!field.Read(stream, ref extraFieldLength))
                {
                    return false;
                }
                fields.Add(field);
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    this.zip64 = true;
                }
            }
            this.extraFields = fields.ToArray();

            byte[] fileCommentBytes = reader.ReadBytes(fileCommentLength);
            this.fileComment = headerEncoding.GetString(fileCommentBytes);

            return true;
        }

        public void Write(Stream stream, bool central)
        {
            byte[] fileNameBytes = (this.fileName != null
                ? Encoding.UTF8.GetBytes(this.fileName) : new byte[0]);
            byte[] fileCommentBytes = (this.fileComment != null
                ? Encoding.UTF8.GetBytes(this.fileComment) : new byte[0]);
            bool useUtf8 =
                (this.fileName != null && fileNameBytes.Length > this.fileName.Length) ||
                (this.fileComment != null && fileCommentBytes.Length > this.fileComment.Length);
            if (useUtf8)
            {
                this.flags |= ZipFileFlags.UTF8;
            }

            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(central ? CFHSIG : LFHSIG);
            if (central)
            {
                writer.Write(this.versionMadeBy);
            }
            writer.Write(this.versionNeeded);
            writer.Write((ushort) this.flags);
            writer.Write((ushort) this.compressionMethod);
            writer.Write(this.lastModTime);
            writer.Write(this.lastModDate);
            writer.Write(this.crc32);
            writer.Write(this.compressedSize);
            writer.Write(this.uncompressedSize);
            
            ushort extraFieldLength = 0;
            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        extraFieldLength += (ushort) (4 + field.data.Length);
                    }
                }
            }

            writer.Write((ushort) fileNameBytes.Length);
            writer.Write(extraFieldLength);

            if (central)
            {
                writer.Write((ushort) fileCommentBytes.Length);

                writer.Write(this.diskStart);
                writer.Write(this.internalFileAttrs);
                writer.Write(this.externalFileAttrs);
                writer.Write(this.localHeaderOffset);
            }

            writer.Write(fileNameBytes);

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        field.Write(stream);
                    }
                }
            }

            if (central)
            {
                writer.Write(fileCommentBytes);
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "compressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "uncompressedSize")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "crc32")]
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "localHeaderOffset")]
        public void GetZip64Fields(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int archiveNumber,
            out uint crc)
        {
            compressedSize = this.compressedSize;
            uncompressedSize = this.uncompressedSize;
            localHeaderOffset = this.localHeaderOffset;
            archiveNumber = this.diskStart;
            crc = this.crc32;

            foreach (ZipExtraFileField field in this.extraFields)
            {
                if (field.fieldType == ZipExtraFileFieldType.ZIP64)
                {
                    field.GetZip64Data(
                        out compressedSize,
                        out uncompressedSize,
                        out localHeaderOffset,
                        out archiveNumber);
                }
            }
        }

        public ZipFileInfo ToZipFileInfo()
        {
            string name = this.fileName;
            
            long compressedSizeL;
            long uncompressedSizeL;
            long localHeaderOffsetL;
            int archiveNumberL;
            uint crc;
            this.GetZip64Fields(
                out compressedSizeL,
                out uncompressedSizeL,
                out localHeaderOffsetL,
                out archiveNumberL,
                out crc);

            DateTime dateTime;
            CompressionEngine.DosDateAndTimeToDateTime(
                this.lastModDate,
                this.lastModTime,
                out dateTime);
            FileAttributes attrs = FileAttributes.Normal;
            // TODO: look for attrs or times in extra fields

            return new ZipFileInfo(name, archiveNumberL, attrs, dateTime,
                uncompressedSizeL, compressedSizeL, this.compressionMethod);
        }

        public bool IsDirectory
        {
            get
            {
                return this.fileName != null &&
                    (this.fileName.EndsWith("/", StringComparison.Ordinal) ||
                    this.fileName.EndsWith("\\", StringComparison.Ordinal));
            }
        }

        public int GetSize(bool central)
        {
            int size = 30;

            int fileNameSize = (this.fileName != null
                ? Encoding.UTF8.GetByteCount(this.fileName) : 0);
            size += fileNameSize;

            if (this.extraFields != null)
            {
                foreach (ZipExtraFileField field in this.extraFields)
                {
                    if (field.data != null)
                    {
                        size += 4 + field.data.Length;
                    }
                }
            }

            if (central)
            {
                size += 16;

                int fileCommentSize = (this.fileComment != null
                    ? Encoding.UTF8.GetByteCount(this.fileComment) : 0);
                size += fileCommentSize;
            }

            return size;
        }
    }

    internal class ZipExtraFileField
    {
        public ZipExtraFileFieldType fieldType;
        public byte[] data;

        public bool Read(Stream stream, ref int bytesRemaining)
        {
            if (bytesRemaining < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);

            this.fieldType = (ZipExtraFileFieldType) reader.ReadUInt16();
            ushort dataSize = reader.ReadUInt16();
            bytesRemaining -= 4;

            if (bytesRemaining < dataSize)
            {
                return false;
            }

            this.data = reader.ReadBytes(dataSize);
            bytesRemaining -= dataSize;

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write((ushort) this.fieldType);

            byte[] dataBytes = (this.data != null ? this.data : new byte[0]);
            writer.Write((ushort) dataBytes.Length);
            writer.Write(dataBytes);
        }

        public bool GetZip64Data(
            out long compressedSize,
            out long uncompressedSize,
            out long localHeaderOffset,
            out int diskStart)
        {
            uncompressedSize = 0;
            compressedSize = 0;
            localHeaderOffset = 0;
            diskStart = 0;

            if (this.fieldType != ZipExtraFileFieldType.ZIP64 ||
                this.data == null || this.data.Length != 28)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream(this.data))
            {
                BinaryReader reader = new BinaryReader(dataStream);
                uncompressedSize = reader.ReadInt64();
                compressedSize = reader.ReadInt64();
                localHeaderOffset = reader.ReadInt64();
                diskStart = reader.ReadInt32();
            }

            return true;
        }

        public bool SetZip64Data(
            long compressedSize,
            long uncompressedSize,
            long localHeaderOffset,
            int diskStart)
        {
            if (this.fieldType != ZipExtraFileFieldType.ZIP64)
            {
                return false;
            }

            using (MemoryStream dataStream = new MemoryStream())
            {
                BinaryWriter writer = new BinaryWriter(dataStream);
                writer.Write(uncompressedSize);
                writer.Write(compressedSize);
                writer.Write(localHeaderOffset);
                writer.Write(diskStart);
                this.data = dataStream.ToArray();
            }

            return true;
        }
    }

    internal class ZipEndOfCentralDirectory
    {
        public const uint EOCDSIG = 0x06054B50;
        public const uint EOCD64SIG = 0x06064B50;

        public const uint EOCD_RECORD_FIXEDSIZE = 22;
        public const uint EOCD64_RECORD_FIXEDSIZE = 56;

        public ushort versionMadeBy;
        public ushort versionNeeded;
        public uint diskNumber;
        public uint dirStartDiskNumber;
        public long entriesOnDisk;
        public long totalEntries;
        public long dirSize;
        public long dirOffset;
        public string comment;
        public bool zip64;

        public ZipEndOfCentralDirectory()
        {
            this.versionMadeBy = 20;
            this.versionNeeded = 20;
        }

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;

            if (stream.Length - startPos < EOCD_RECORD_FIXEDSIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            this.zip64 = false;
            if (sig != EOCDSIG)
            {
                if (sig == EOCD64SIG)
                {
                    this.zip64 = true;
                }
                else
                {
                    return false;
                }
            }

            if (this.zip64)
            {
                if (stream.Length - startPos < EOCD64_RECORD_FIXEDSIZE)
                {
                    return false;
                }

                long recordSize = reader.ReadInt64();
                this.versionMadeBy = reader.ReadUInt16();
                this.versionNeeded = reader.ReadUInt16();
                this.diskNumber = reader.ReadUInt32();
                this.dirStartDiskNumber = reader.ReadUInt32();
                this.entriesOnDisk = reader.ReadInt64();
                this.totalEntries = reader.ReadInt64();
                this.dirSize = reader.ReadInt64();
                this.dirOffset = reader.ReadInt64();

                // Ignore any extended zip64 eocd data.
                long exDataSize = recordSize + 12 - EOCD64_RECORD_FIXEDSIZE;

                if (stream.Length - stream.Position < exDataSize)
                {
                    return false;
                }

                stream.Seek(exDataSize, SeekOrigin.Current);

                this.comment = null;
            }
            else
            {
                this.diskNumber = reader.ReadUInt16();
                this.dirStartDiskNumber = reader.ReadUInt16();
                this.entriesOnDisk = reader.ReadUInt16();
                this.totalEntries = reader.ReadUInt16();
                this.dirSize = reader.ReadUInt32();
                this.dirOffset = reader.ReadUInt32();

                int commentLength = reader.ReadUInt16();

                if (stream.Length - stream.Position < commentLength)
                {
                    return false;
                }

                byte[] commentBytes = reader.ReadBytes(commentLength);
                this.comment = Encoding.UTF8.GetString(commentBytes);
            }

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);

            if (this.zip64)
            {
                writer.Write(EOCD64SIG);
                writer.Write((long) EOCD64_RECORD_FIXEDSIZE);
                writer.Write(this.versionMadeBy);
                writer.Write(this.versionNeeded);
                writer.Write(this.diskNumber);
                writer.Write(this.dirStartDiskNumber);
                writer.Write(this.entriesOnDisk);
                writer.Write(this.totalEntries);
                writer.Write(this.dirSize);
                writer.Write(this.dirOffset);
            }
            else
            {
                writer.Write(EOCDSIG);
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.diskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.dirStartDiskNumber));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.entriesOnDisk));
                writer.Write((ushort) Math.Min((int) UInt16.MaxValue, this.totalEntries));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirSize));
                writer.Write((uint) Math.Min((long) UInt32.MaxValue, this.dirOffset));

                byte[] commentBytes = (this.comment != null
                    ? Encoding.UTF8.GetBytes(this.comment) : new byte[0]);
                writer.Write((ushort) commentBytes.Length);
                writer.Write(commentBytes);
            }
        }

        public int GetSize(bool zip64Size)
        {
            if (zip64Size)
            {
                return 56;
            }
            else
            {
                int commentSize = (this.comment != null
                    ? Encoding.UTF8.GetByteCount(this.comment) : 0);
                return 22 + commentSize;
            }
        }
    }

    internal class Zip64EndOfCentralDirectoryLocator
    {
        public const uint EOCDL64SIG = 0x07064B50;

        public const uint EOCDL64_SIZE = 20;

        public uint dirStartDiskNumber;
        public long dirOffset;
        public uint totalDisks;

        public bool Read(Stream stream)
        {
            long startPos = stream.Position;
            if (stream.Length - startPos < EOCDL64_SIZE)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();

            if (sig != EOCDL64SIG)
            {
                return false;
            }

            this.dirStartDiskNumber = reader.ReadUInt32();
            this.dirOffset = reader.ReadInt64();
            this.totalDisks = reader.ReadUInt32();

            return true;
        }

        public void Write(Stream stream)
        {
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(EOCDL64SIG);
            writer.Write(this.dirStartDiskNumber);
            writer.Write(this.dirOffset);
            writer.Write(this.totalDisks);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipEngine.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipEngine.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Reflection;
    using System.Diagnostics.CodeAnalysis;

    /// <summary>
    /// Engine capable of packing and unpacking archives in the zip format.
    /// </summary>
    public partial class ZipEngine : CompressionEngine
    {
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            compressionStreamCreators;
        private static Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>
            decompressionStreamCreators;

        private static void InitCompressionStreamCreators()
        {
            if (ZipEngine.compressionStreamCreators == null)
            {
                ZipEngine.compressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();
                ZipEngine.decompressionStreamCreators = new
                    Dictionary<ZipCompressionMethod, Converter<Stream, Stream>>();

                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Compress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Compress, true);
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Store,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return stream;
                    });
                ZipEngine.RegisterCompressionStreamCreator(
                    ZipCompressionMethod.Deflate,
                    CompressionMode.Decompress,
                    delegate(Stream stream) {
                        return new DeflateStream(stream, CompressionMode.Decompress, true);
                    });
            }
        }

        /// <summary>
        /// Registers a delegate that can create a warpper stream for
        /// compressing or uncompressing the data of a source stream.
        /// </summary>
        /// <param name="compressionMethod">Compression method being registered.</param>
        /// <param name="compressionMode">Indicates registration for ether
        /// compress or decompress mode.</param>
        /// <param name="creator">Delegate being registered.</param>
        /// <remarks>
        /// For compression, the delegate accepts a stream that writes to the archive
        /// and returns a wrapper stream that compresses bytes as they are written.
        /// For decompression, the delegate accepts a stream that reads from the archive
        /// and returns a wrapper stream that decompresses bytes as they are read.
        /// This wrapper stream model follows the design used by
        /// System.IO.Compression.DeflateStream, and indeed that class is used
        /// to implement the Deflate compression method by default.
        /// <para>To unregister a delegate, call this method again and pass
        /// null for the delegate parameter.</para>
        /// </remarks>
        /// <example>
        /// When the ZipEngine class is initialized, the Deflate compression method
        /// is automatically registered like this:
        /// <code>
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Compress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Compress, true);
        ///            });
        ///        ZipEngine.RegisterCompressionStreamCreator(
        ///            ZipCompressionMethod.Deflate,
        ///            CompressionMode.Decompress,
        ///            delegate(Stream stream) {
        ///                return new DeflateStream(stream, CompressionMode.Decompress, true);
        ///            });
        /// </code></example>
        public static void RegisterCompressionStreamCreator(
            ZipCompressionMethod compressionMethod,
            CompressionMode compressionMode,
            Converter<Stream, Stream> creator)
        {
            ZipEngine.InitCompressionStreamCreators();
            if (compressionMode == CompressionMode.Compress)
            {
                ZipEngine.compressionStreamCreators[compressionMethod] = creator;
            }
            else
            {
                ZipEngine.decompressionStreamCreators[compressionMethod] = creator;
            }
        }

        // Progress data
        private string currentFileName;
        private int currentFileNumber;
        private int totalFiles;
        private long currentFileBytesProcessed;
        private long currentFileTotalBytes;
        private string mainArchiveName;
        private string currentArchiveName;
        private short currentArchiveNumber;
        private short totalArchives;
        private long currentArchiveBytesProcessed;
        private long currentArchiveTotalBytes;
        private long fileBytesProcessed;
        private long totalFileBytes;
        private string comment;

        /// <summary>
        /// Creates a new instance of the zip engine.
        /// </summary>
        public ZipEngine()
            : base()
        {
            ZipEngine.InitCompressionStreamCreators();
        }

        /// <summary>
        /// Gets the comment from the last-examined archive,
        /// or sets the comment to be added to any created archives.
        /// </summary>
        public string ArchiveComment
        {
            get
            {
                return this.comment;
            }
            set
            {
                this.comment = value;
            }
        }

        /// <summary>
        /// Checks whether a Stream begins with a header that indicates
        /// it is a valid archive file.
        /// </summary>
        /// <param name="stream">Stream for reading the archive file.</param>
        /// <returns>True if the stream is a valid zip archive
        /// (with no offset); false otherwise.</returns>
        public override bool IsArchive(Stream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (stream.Length - stream.Position < 4)
            {
                return false;
            }

            BinaryReader reader = new BinaryReader(stream);
            uint sig = reader.ReadUInt32();
            switch (sig)
            {
                case ZipFileHeader.LFHSIG:
                case ZipEndOfCentralDirectory.EOCDSIG:
                case ZipEndOfCentralDirectory.EOCD64SIG:
                case ZipFileHeader.SPANSIG:
                case ZipFileHeader.SPANSIG2:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets the offset of an archive that is positioned 0 or more bytes
        /// from the start of the Stream.
        /// </summary>
        /// <param name="stream">A stream for reading the archive.</param>
        /// <returns>The offset in bytes of the archive,
        /// or -1 if no archive is found in the Stream.</returns>
        /// <remarks>The archive must begin on a 4-byte boundary.</remarks>
        public override long FindArchiveOffset(Stream stream)
        {
            long offset = base.FindArchiveOffset(stream);
            if (offset > 0)
            {
                // Some self-extract packages include the exe stub in file offset calculations.
                // Check the first header directory offset to decide whether the entire
                // archive needs to be offset or not.

                ZipEndOfCentralDirectory eocd = this.GetEOCD(null, stream);
                if (eocd != null && eocd.totalEntries > 0)
                {
                    stream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                    ZipFileHeader header = new ZipFileHeader();
                    if (header.Read(stream, true) && header.localHeaderOffset < stream.Length)
                    {
                        stream.Seek(header.localHeaderOffset, SeekOrigin.Begin);
                        if (header.Read(stream, false))
                        {
                            return 0;
                        }
                    }
                }
            }

            return offset;
        }

        /// <summary>
        /// Gets information about files in a zip archive or archive chain.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="fileFilter">A predicate that can determine
        /// which files to process, optional.</param>
        /// <returns>Information about files in the archive stream.</returns>
        /// <exception cref="ArchiveException">The archive provided
        /// by the stream context is not valid.</exception>
        /// <remarks>
        /// The <paramref name="fileFilter"/> predicate takes an internal file
        /// path and returns true to include the file or false to exclude it.
        /// </remarks>
        public override IList<ArchiveFileInfo> GetFileInfo(
            IUnpackStreamContext streamContext,
            Predicate<string> fileFilter)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            lock (this)
            {
                IList<ZipFileHeader> headers = this.GetCentralDirectory(streamContext);
                if (headers == null)
                {
                    throw new ZipException("Zip central directory not found.");
                }

                List<ArchiveFileInfo> files = new List<ArchiveFileInfo>(headers.Count);
                foreach (ZipFileHeader header in headers)
                {
                    if (!header.IsDirectory &&
                        (fileFilter == null || fileFilter(header.fileName)))
                    {
                        files.Add(header.ToZipFileInfo());
                    }
                }

                return files.AsReadOnly();
            }
        }

        /// <summary>
        /// Reads all the file headers from the central directory in the main archive.
        /// </summary>
        private IList<ZipFileHeader> GetCentralDirectory(IUnpackStreamContext streamContext)
        {
            Stream archiveStream = null;
            this.currentArchiveNumber = 0;
            try
            {
                List<ZipFileHeader> headers = new List<ZipFileHeader>();
                archiveStream = this.OpenArchive(streamContext, 0);

                ZipEndOfCentralDirectory eocd = this.GetEOCD(streamContext, archiveStream);
                if (eocd == null)
                {
                    return null;
                }
                else if (eocd.totalEntries == 0)
                {
                    return headers;
                }

                headers.Capacity = (int) eocd.totalEntries;

                if (eocd.dirOffset > archiveStream.Length - ZipFileHeader.CFH_FIXEDSIZE)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                    archiveStream = null;
                }
                else
                {
                    archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);
                    uint sig = new BinaryReader(archiveStream).ReadUInt32();
                    if (sig != ZipFileHeader.CFHSIG)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        archiveStream = null;
                    }
                }

                if (archiveStream == null)
                {
                    this.currentArchiveNumber = (short) (eocd.dirStartDiskNumber + 1);
                    archiveStream = streamContext.OpenArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, this);

                    if (archiveStream == null)
                    {
                        return null;
                    }
                }

                archiveStream.Seek(eocd.dirOffset, SeekOrigin.Begin);

                while (headers.Count < eocd.totalEntries)
                {
                    ZipFileHeader header = new ZipFileHeader();
                    if (!header.Read(archiveStream, true))
                    {
                        throw new ZipException(
                            "Missing or invalid central directory file header");
                    }

                    headers.Add(header);

                    if (headers.Count < eocd.totalEntries &&
                        archiveStream.Position == archiveStream.Length)
                    {
                        streamContext.CloseArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, archiveStream);
                        this.currentArchiveNumber++;
                        archiveStream = streamContext.OpenArchiveReadStream(
                            this.currentArchiveNumber, String.Empty, this);
                        if (archiveStream == null)
                        {
                            this.currentArchiveNumber = 0;
                            archiveStream = streamContext.OpenArchiveReadStream(
                                this.currentArchiveNumber, String.Empty, this);
                        }
                    }
                }

                return headers;
            }
            finally
            {
                if (archiveStream != null)
                {
                    streamContext.CloseArchiveReadStream(
                        this.currentArchiveNumber, String.Empty, archiveStream);
                }
            }
        }

        /// <summary>
        /// Locates and reads the end of central directory record near the
        /// end of the archive.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "streamContext")]
        private ZipEndOfCentralDirectory GetEOCD(
            IUnpackStreamContext streamContext, Stream archiveStream)
        {
            BinaryReader reader = new BinaryReader(archiveStream);
            long offset = archiveStream.Length
                - ZipEndOfCentralDirectory.EOCD_RECORD_FIXEDSIZE;
            while (offset >= 0)
            {
                archiveStream.Seek(offset, SeekOrigin.Begin);

                uint sig = reader.ReadUInt32();
                if (sig == ZipEndOfCentralDirectory.EOCDSIG)
                {
                    break;
                }

                offset--;
            }

            if (offset < 0)
            {
                return null;
            }

            ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
            archiveStream.Seek(offset, SeekOrigin.Begin);
            if (!eocd.Read(archiveStream))
            {
                throw new ZipException("Invalid end of central directory record");
            }

            if (eocd.dirOffset == (long) UInt32.MaxValue)
            {
                string saveComment = eocd.comment;

                archiveStream.Seek(
                    offset - Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE,
                    SeekOrigin.Begin);

                Zip64EndOfCentralDirectoryLocator eocdl =
                    new Zip64EndOfCentralDirectoryLocator();
                if (!eocdl.Read(archiveStream))
                {
                    throw new ZipException("Missing or invalid end of " +
                        "central directory record locator");
                }

                if (eocdl.dirStartDiskNumber == eocdl.totalDisks - 1)
                {
                    // ZIP64 eocd is entirely in current stream.
                    archiveStream.Seek(eocdl.dirOffset, SeekOrigin.Begin);
                    if (!eocd.Read(archiveStream))
                    {
                        throw new ZipException("Missing or invalid ZIP64 end of " +
                            "central directory record");
                    }
                }
                else if (streamContext == null)
                {
                    return null;
                }
                else
                {
                    // TODO: handle EOCD64 spanning archives!
                    throw new NotImplementedException("Zip implementation does not " +
                        "handle end of central directory record that spans archives.");
                }

                eocd.comment = saveComment;
            }

            return eocd;
        }

        private void ResetProgressData()
        {
            this.currentFileName = null;
            this.currentFileNumber = 0;
            this.totalFiles = 0;
            this.currentFileBytesProcessed = 0;
            this.currentFileTotalBytes = 0;
            this.currentArchiveName = null;
            this.currentArchiveNumber = 0;
            this.totalArchives = 0;
            this.currentArchiveBytesProcessed = 0;
            this.currentArchiveTotalBytes = 0;
            this.fileBytesProcessed = 0;
            this.totalFileBytes = 0;
        }

        private void OnProgress(ArchiveProgressType progressType)
        {
            ArchiveProgressEventArgs e = new ArchiveProgressEventArgs(
                progressType,
                this.currentFileName,
                this.currentFileNumber >= 0 ? this.currentFileNumber : 0,
                this.totalFiles,
                this.currentFileBytesProcessed,
                this.currentFileTotalBytes,
                this.currentArchiveName,
                this.currentArchiveNumber,
                this.totalArchives,
                this.currentArchiveBytesProcessed,
                this.currentArchiveTotalBytes,
                this.fileBytesProcessed,
                this.totalFileBytes);
            this.OnProgress(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\LFIT\Backup1\Compression.Zip\ZipPacker.cs ===
﻿//---------------------------------------------------------------------
// <copyright file="ZipPacker.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
// Part of the Deployment Tools Foundation project.
// </summary>
//---------------------------------------------------------------------

namespace Microsoft.Deployment.Compression.Zip
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Collections.Generic;
    using System.Globalization;

    public partial class ZipEngine
    {
        /// <summary>
        /// Creates a zip archive or chain of zip archives.
        /// </summary>
        /// <param name="streamContext">A context interface to handle opening
        /// and closing of archive and file streams.</param>
        /// <param name="files">An array of file lists.  Each list is
        /// compressed into one stream in the archive.</param>
        /// <param name="maxArchiveSize">The maximum number of bytes for one archive
        /// before the contents are chained to the next archive, or zero for unlimited
        /// archive size.</param>
        /// <exception cref="ArchiveException">The archive could not be
        /// created.</exception>
        /// <remarks>
        /// The stream context implementation may provide a mapping from the file
        /// paths within the archive to the external file paths.
        /// </remarks>
        public override void Pack(
            IPackStreamContext streamContext,
            IEnumerable<string> files,
            long maxArchiveSize)
        {
            if (streamContext == null)
            {
                throw new ArgumentNullException("streamContext");
            }

            if (files == null)
            {
                throw new ArgumentNullException("files");
            }

            lock (this)
            {
                Stream archiveStream = null;
                try
                {
                    this.ResetProgressData();
                    this.totalArchives = 1;

                    object forceZip64Value = streamContext.GetOption("forceZip64", null);
                    bool forceZip64 = Convert.ToBoolean(
                        forceZip64Value, CultureInfo.InvariantCulture);

                    // Count the total number of files and bytes to be compressed.
                    foreach (string file in files)
                    {
                        FileAttributes attributes;
                        DateTime lastWriteTime;
                        Stream fileStream = streamContext.OpenFileReadStream(
                            file,
                            out attributes,
                            out lastWriteTime);
                        if (fileStream != null)
                        {
                            this.totalFileBytes += fileStream.Length;
                            this.totalFiles++;
                            streamContext.CloseFileReadStream(file, fileStream);
                        }
                    }

                    List<ZipFileHeader> fileHeaders = new List<ZipFileHeader>();
                    this.currentFileNumber = -1;

                    if (this.currentArchiveName == null)
                    {
                        this.mainArchiveName = streamContext.GetArchiveName(0);
                        this.currentArchiveName = this.mainArchiveName;

                        if (String.IsNullOrEmpty(this.currentArchiveName))
                        {
                            throw new FileNotFoundException("No name provided for archive.");
                        }
                    }

                    this.OnProgress(ArchiveProgressType.StartArchive);

                    // Compress files one by one, saving header info for each.
                    foreach (string file in files)
                    {
                        ZipFileHeader fileHeader = this.PackOneFile(
                                streamContext,
                                file,
                                maxArchiveSize,
                                forceZip64,
                                ref archiveStream);

                        if (fileHeader != null)
                        {
                            fileHeaders.Add(fileHeader);
                        }

                        this.currentArchiveTotalBytes = (archiveStream != null ?
                            archiveStream.Position : 0);
                        this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                    }

                    // Write the central directory composed of all the file headers.
                    bool zip64 = forceZip64;
                    uint centralDirStartArchiveNumber = 0;
                    long centralDirStartPosition = 0;
                    long centralDirSize = 0;
                    for (int i = 0; i < fileHeaders.Count; i++)
                    {
                        ZipFileHeader fileHeader = fileHeaders[i];

                        int headerSize = fileHeader.GetSize(true);
                        centralDirSize += headerSize;

                        this.CheckArchiveWriteStream(
                            streamContext,
                            maxArchiveSize,
                            headerSize,
                            ref archiveStream);

                        if (i == 0)
                        {
                            centralDirStartArchiveNumber = (uint) this.currentArchiveNumber;
                            centralDirStartPosition = archiveStream.Position;
                        }

                        fileHeader.Write(archiveStream, true);
                        if (fileHeader.zip64)
                        {
                            zip64 = true;
                        }
                    }

                    this.currentArchiveTotalBytes =
                        (archiveStream != null ? archiveStream.Position : 0);
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    ZipEndOfCentralDirectory eocd = new ZipEndOfCentralDirectory();
                    eocd.dirStartDiskNumber = centralDirStartArchiveNumber;
                    eocd.entriesOnDisk = fileHeaders.Count;
                    eocd.totalEntries = fileHeaders.Count;
                    eocd.dirSize = centralDirSize;
                    eocd.dirOffset = centralDirStartPosition;
                    eocd.comment = this.comment;

                    Zip64EndOfCentralDirectoryLocator eocdl =
                        new Zip64EndOfCentralDirectoryLocator();

                    int maxFooterSize = eocd.GetSize(false);
                    if (archiveStream != null && (zip64 || archiveStream.Position >
                        ((long) UInt32.MaxValue) - eocd.GetSize(false)))
                    {
                        maxFooterSize += eocd.GetSize(true) + (int)
                            Zip64EndOfCentralDirectoryLocator.EOCDL64_SIZE;
                        zip64 = true;
                    }

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        maxFooterSize,
                        ref archiveStream);
                    eocd.diskNumber = (uint) this.currentArchiveNumber;

                    if (zip64)
                    {
                        eocd.versionMadeBy = 45;
                        eocd.versionNeeded = 45;
                        eocd.zip64 = true;
                        eocdl.dirOffset = archiveStream.Position;
                        eocdl.dirStartDiskNumber = (uint) this.currentArchiveNumber;
                        eocdl.totalDisks = (uint) this.currentArchiveNumber + 1;
                        eocd.Write(archiveStream);
                        eocdl.Write(archiveStream);

                        if (forceZip64)
                        {
                            eocd.dirOffset = UInt32.MaxValue;
                            eocd.dirStartDiskNumber = UInt16.MaxValue;
                        }
                    }

                    eocd.zip64 = false;
                    eocd.Write(archiveStream);

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;
                }
                finally
                {
                    if (archiveStream != null)
                    {
                        streamContext.CloseArchiveWriteStream(
                            this.currentArchiveNumber, this.mainArchiveName, archiveStream);
                        this.OnProgress(ArchiveProgressType.FinishArchive);
                    }
                }
            }
        }

        /// <summary>
        /// Moves to the next archive in the sequence if necessary.
        /// </summary>
        private void CheckArchiveWriteStream(
            IPackStreamContext streamContext,
            long maxArchiveSize,
            long requiredSize,
            ref Stream archiveStream)
        {
            if (archiveStream != null &&
                archiveStream.Length > 0 && maxArchiveSize > 0)
            {
                long sizeRemaining = maxArchiveSize - archiveStream.Length;
                if (sizeRemaining < requiredSize)
                {
                    string nextArchiveName = streamContext.GetArchiveName(
                        this.currentArchiveNumber + 1);

                    if (String.IsNullOrEmpty(nextArchiveName))
                    {
                        throw new FileNotFoundException("No name provided for archive #" +
                            this.currentArchiveNumber + 1);
                    }

                    this.currentArchiveTotalBytes = archiveStream.Position;
                    this.currentArchiveBytesProcessed = this.currentArchiveTotalBytes;

                    streamContext.CloseArchiveWriteStream(
                        this.currentArchiveNumber,
                        nextArchiveName,
                        archiveStream);
                    archiveStream = null;

                    this.OnProgress(ArchiveProgressType.FinishArchive);

                    this.currentArchiveNumber++;
                    this.totalArchives++;
                    this.currentArchiveBytesProcessed = 0;
                    this.currentArchiveTotalBytes = 0;
                }
            }

            if (archiveStream == null)
            {
                if (this.currentArchiveNumber > 0)
                {
                    this.OnProgress(ArchiveProgressType.StartArchive);
                }

                archiveStream = streamContext.OpenArchiveWriteStream(
                    this.currentArchiveNumber, this.mainArchiveName, true, this);

                if (archiveStream == null)
                {
                    throw new FileNotFoundException("Stream not provided for archive #" +
                        this.currentArchiveNumber);
                }
            }
        }

        /// <summary>
        /// Adds one file to a zip archive in the process of being created.
        /// </summary>
        private ZipFileHeader PackOneFile(
            IPackStreamContext streamContext,
            string file,
            long maxArchiveSize,
            bool forceZip64,
            ref Stream archiveStream)
        {
            Stream fileStream = null;
            int headerArchiveNumber = 0;
            try
            {
                // TODO: call GetOption to get compression method for the specific file
                ZipCompressionMethod compressionMethod = ZipCompressionMethod.Deflate;
                if (this.CompressionLevel == CompressionLevel.None)
                {
                    compressionMethod = ZipCompressionMethod.Store;
                }

                Converter<Stream, Stream> compressionStreamCreator;
                if (!ZipEngine.compressionStreamCreators.TryGetValue(
                    compressionMethod, out compressionStreamCreator))
                {
                    return null;
                }

                FileAttributes attributes;
                DateTime lastWriteTime;
                fileStream = streamContext.OpenFileReadStream(
                    file, out attributes, out lastWriteTime);
                if (fileStream == null)
                {
                    return null;
                }

                this.currentFileName = file;
                this.currentFileNumber++;

                this.currentFileTotalBytes = fileStream.Length;
                this.currentFileBytesProcessed = 0;
                this.OnProgress(ArchiveProgressType.StartFile);

                ZipFileInfo fileInfo = new ZipFileInfo(
                    file,
                    this.currentArchiveNumber,
                    attributes,
                    lastWriteTime,
                    fileStream.Length,
                    0,
                    compressionMethod);

                bool zip64 = forceZip64 || fileStream.Length >= (long) UInt32.MaxValue;
                ZipFileHeader fileHeader = new ZipFileHeader(fileInfo, zip64);

                this.CheckArchiveWriteStream(
                    streamContext,
                    maxArchiveSize,
                    fileHeader.GetSize(false),
                    ref archiveStream);

                long headerPosition = archiveStream.Position;
                fileHeader.Write(archiveStream, false);
                headerArchiveNumber = this.currentArchiveNumber;

                uint crc;
                long bytesWritten = this.PackFileBytes(
                    streamContext,
                    fileStream,
                    maxArchiveSize,
                    compressionStreamCreator,
                    ref archiveStream,
                    out crc);

                fileHeader.Update(
                    bytesWritten,
                    fileStream.Length,
                    crc,
                    headerPosition,
                    headerArchiveNumber);

                streamContext.CloseFileReadStream(file, fileStream);
                fileStream = null;

                // Go back and rewrite the updated file header.
                if (this.currentArchiveNumber == headerArchiveNumber)
                {
                    long fileEndPosition = archiveStream.Position;
                    archiveStream.Seek(headerPosition, SeekOrigin.Begin);
                    fileHeader.Write(archiveStream, false);
                    archiveStream.Seek(fileEndPosition, SeekOrigin.Begin);
                }
                else
                {
                    // The file spanned archives, so temporarily reopen
                    // the archive where it started.
                    string headerArchiveName = streamContext.GetArchiveName(
                        headerArchiveNumber + 1);
                    Stream headerStream = null;
                    try
                    {
                        headerStream = streamContext.OpenArchiveWriteStream(
                            headerArchiveNumber, headerArchiveName, false, this);
                        headerStream.Seek(headerPosition, SeekOrigin.Begin);
                        fileHeader.Write(headerStream, false);
                    }
                    finally
                    {
                        if (headerStream != null)
                        {
                            streamContext.CloseArchiveWriteStream(
                                headerArchiveNumber, headerArchiveName, headerStream);
                        }
                    }
                }

                this.OnProgress(ArchiveProgressType.FinishFile);

                return fileHeader;
            }
            finally
            {
                if (fileStream != null)
                {
                    streamContext.CloseFileReadStream(
                        this.currentFileName, fileStream);
                }
            }
        }

        /// <summary>
        /// Writes compressed bytes of one file to the archive,
        /// keeping track of the CRC and number of bytes written.
        /// </summary>
        private long PackFileBytes(
            IPackStreamContext streamContext,
            Stream fileStream,
            long maxArchiveSize,
            Converter<Stream, Stream> compressionStreamCreator,
            ref Stream archiveStream,
            out uint crc)
        {
            long writeStartPosition = archiveStream.Position;
            long bytesWritten = 0;
            CrcStream fileCrcStream = new CrcStream(fileStream);

            ConcatStream concatStream = new ConcatStream(
                delegate(ConcatStream s)
                {
                    Stream sourceStream = s.Source;
                    bytesWritten += sourceStream.Position - writeStartPosition;

                    this.CheckArchiveWriteStream(
                        streamContext,
                        maxArchiveSize,
                        1,
                        ref sourceStream);

                    writeStartPosition = sourceStream.Position;
                    s.Source = sourceStream;
           